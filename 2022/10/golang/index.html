<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>
        Golang - 木木的个人博客
      </title>
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  
  <meta name="theme-color" content="#000000" />
  
  <meta http-equiv="window-target" content="_top" />
  
  
  <meta name="description" content="Golang" />
  <meta name="generator" content="Hugo 0.59.1 with theme pure" />
  <title>Golang - 木木的个人博客</title>
  

  <link rel="stylesheet" href="https://mumulx.gitee.io/css/style.css">
  <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.15.10/styles/github.min.css"> 
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <meta property="og:title" content="Golang" />
<meta property="og:description" content="Golang" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mumulx.gitee.io/2022/10/golang/" />
<meta property="article:published_time" content="2022-10-24T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-10-24T00:00:00+00:00" />

<meta itemprop="name" content="Golang">
<meta itemprop="description" content="Golang">


<meta itemprop="datePublished" content="2022-10-24T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2022-10-24T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="63341">



<meta itemprop="keywords" content="Golang," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Golang"/>
<meta name="twitter:description" content="Golang"/>

  <!--[if lte IE 9]>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
    <![endif]-->

  <!--[if lt IE 9]>
      <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
    <![endif]-->

</head>
  </head>
  

  <body class="main-center" itemscope itemtype="https://schema.org/WebPage"><header class="header" itemscope itemtype="https://schema.org/WPHeader">
    <div class="slimContent">
      <div class="navbar-header">
        <div class="profile-block text-center">
          <a id="avatar" href="https://gitee.com/mumulx" target="_blank">
            <img class="img-circle img-rotate" src="https://mumulx.gitee.io/avatar.png" width="200" height="200">
          </a>
          <h2 id="name" class="hidden-xs hidden-sm">木木就是两个木</h2>
          <h3 id="title" class="hidden-xs hidden-sm hidden-md">木木</h3>
          <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i>xuzhou, China</small>
        </div><div class="search" id="search-form-wrap">
    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i
                        class="icon icon-search"></i></button>
            </span>
        </div>
        <div class="ins-search">
            <div class="ins-search-mask"></div>
            <div class="ins-search-container">
                <div class="ins-input-wrapper">
                    <input type="text" class="ins-search-input" placeholder="想要查找什么..."
                        x-webkit-speech />
                    <button type="button" class="close ins-close ins-selectable" data-dismiss="modal"
                        aria-label="Close"><span aria-hidden="true">×</span></button>
                </div>
                <div class="ins-section-wrapper">
                    <div class="ins-section-container"></div>
                </div>
            </div>
        </div>
    </form>
</div>
        <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
      <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="https://schema.org/SiteNavigationElement" role="navigation">
        <ul class="nav navbar-nav main-nav">
            <li class="menu-item menu-item-home">
                <a href="/">
                    <i class="icon icon-home-fill"></i>
                  <span class="menu-title">主页</span>
                </a>
            </li>
            <li class="menu-item menu-item-archives">
                <a href="/posts">
                    <i class="icon icon-archives-fill"></i>
                  <span class="menu-title">归档</span>
                </a>
            </li>
            <li class="menu-item menu-item-categories">
                <a href="/categories">
                    <i class="icon icon-folder"></i>
                  <span class="menu-title">分类</span>
                </a>
            </li>
            <li class="menu-item menu-item-tags">
                <a href="/tags">
                    <i class="icon icon-tags"></i>
                  <span class="menu-title">标签</span>
                </a>
            </li>
            <li class="menu-item menu-item-about">
                <a href="/about">
                    <i class="icon icon-cup-fill"></i>
                  <span class="menu-title">关于</span>
                </a>
            </li>
        </ul>
      </nav>
    </div>
  </header>
  <aside class="sidebar" itemscope itemtype="https://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content"><p>我们的征途是星辰大海！</p>
            </div>
        </div>
    </div>
</div>

      <div class="widget">
    <h3 class="widget-title"> 分类</h3>
    <div class="widget-body">
        <ul class="category-list">
            <li class="category-list-item"><a href="https://mumulx.gitee.io/categories/golang/" class="category-list-link">golang</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://mumulx.gitee.io/categories/java%E9%9D%A2%E8%AF%95/" class="category-list-link">java面试</a><span class="category-list-count">5</span></li>
            <li class="category-list-item"><a href="https://mumulx.gitee.io/categories/%E6%8A%80%E6%9C%AF%E6%94%B6%E5%BD%95/" class="category-list-link">技术收录</a><span class="category-list-count">36</span></li>
            <li class="category-list-item"><a href="https://mumulx.gitee.io/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/" class="category-list-link">技术框架</a><span class="category-list-count">17</span></li>
            <li class="category-list-item"><a href="https://mumulx.gitee.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" class="category-list-link">杂七杂八</a><span class="category-list-count">7</span></li>
        </ul>
    </div>
</div>
      <div class="widget">
    <h3 class="widget-title"> 标签</h3>
    <div class="widget-body">
        <ul class="tag-list">
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/golang/" class="tag-list-link">golang</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/java/" class="tag-list-link">java</a><span
                    class="tag-list-count">10</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/java%E5%B9%B6%E5%8F%91/" class="tag-list-link">java并发</a><span
                    class="tag-list-count">5</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/java%E5%BA%95%E5%B1%82/" class="tag-list-link">java底层</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/linux/" class="tag-list-link">linux</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/spring%E5%AE%B6%E6%97%8F/" class="tag-list-link">spring家族</a><span
                    class="tag-list-count">15</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="tag-list-link">中间件</a><span
                    class="tag-list-count">6</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" class="tag-list-link">分布式</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" class="tag-list-link">前端框架</a><span
                    class="tag-list-count">6</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" class="tag-list-link">开发工具</a><span
                    class="tag-list-count">4</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="tag-list-link">数据库</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" class="tag-list-link">杂七杂八</a><span
                    class="tag-list-count">5</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E6%9D%83%E9%99%90/" class="tag-list-link">权限</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="tag-list-link">面试题</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/" class="tag-list-link">项目实战</a><span
                    class="tag-list-count">1</span></li>
            
        </ul>

    </div>
</div>
      
<div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
        <ul class="recent-post-list list-unstyled no-thumbnail">
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.gitee.io/2022/10/golang/" class="title">Golang</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-10-24 00:00:00 &#43;0000 UTC" itemprop="datePublished">2022-10-24</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.gitee.io/2022/06/springbatch/" class="title">SpringBatch中文文档</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-06-07 00:00:00 &#43;0000 UTC" itemprop="datePublished">2022-06-07</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.gitee.io/2022/03/%E5%BE%AE%E5%89%8D%E7%AB%AFqiankun%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/" class="title">微前端qiankun自动部署</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-03-10 00:00:00 &#43;0000 UTC" itemprop="datePublished">2022-03-10</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.gitee.io/2022/03/docker/" class="title">Docker</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-03-07 00:00:00 &#43;0000 UTC" itemprop="datePublished">2022-03-07</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.gitee.io/2022/02/elasticsearch%E7%AC%94%E8%AE%B0/" class="title">ElasticSearch笔记</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-02-20 00:00:00 &#43;0000 UTC" itemprop="datePublished">2022-02-20</time>
                    </p>
                </div>
            </li>
        </ul>
    </div>
</div>
  </div>
</aside>

    
    
  <aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="https://schema.org/WPSideBar">
    <div class="slimContent">
      <nav id="toc" class="article-toc">
        <h3 class="toc-title">文章目录</h3>
        <div class="toc-content always-active"><nav id="TableOfContents">
<ul>
<li><a href="#golang">Golang</a>
<ul>
<li><a href="#为什么你应该学习go语言">为什么你应该学习Go语言？</a></li>
<li><a href="#为什么互联网世界需要go语言">为什么互联网世界需要Go语言</a>
<ul>
<li><a href="#硬件限制-摩尔定律已然失效">硬件限制：摩尔定律已然失效</a></li>
<li><a href="#go语言为并发而生">Go语言为并发而生</a></li>
<li><a href="#go性能强悍">Go性能强悍</a></li>
<li><a href="#go语言简单易学">Go语言简单易学</a>
<ul>
<li><a href="#语法简洁">语法简洁</a></li>
<li><a href="#代码风格统一">代码风格统一</a></li>
<li><a href="#开发效率高">开发效率高</a></li>
</ul></li>
</ul></li>
<li><a href="#学习go语言的前景">学习Go语言的前景</a></li>
</ul></li>
<li><a href="#开发环境准备">开发环境准备</a>
<ul>
<li><a href="#从零开始搭建go语言开发环境-新">从零开始搭建Go语言开发环境（新）</a>
<ul>
<li><a href="#安装go语言及搭建go语言开发环境">安装Go语言及搭建Go语言开发环境</a></li>
<li><a href="#下载">下载</a>
<ul>
<li><a href="#下载地址">下载地址</a></li>
<li><a href="#版本的选择">版本的选择</a></li>
</ul></li>
<li><a href="#安装">安装</a>
<ul>
<li><a href="#windows安装">Windows安装</a></li>
<li><a href="#linux下安装">Linux下安装</a></li>
<li><a href="#mac下安装">Mac下安装</a></li>
<li><a href="#检查">检查</a></li>
</ul></li>
<li><a href="#goroot和gopath">GOROOT和GOPATH</a>
<ul>
<li><a href="#goproxy-非常重要">GOPROXY 非常重要</a></li>
</ul></li>
<li><a href="#go开发编辑器">Go开发编辑器</a>
<ul>
<li><a href="#vs-code介绍">VS Code介绍</a></li>
<li><a href="#下载与安装">下载与安装</a></li>
<li><a href="#配置">配置</a>
<ul>
<li><a href="#安装中文简体插件">安装中文简体插件</a></li>
<li><a href="#安装go扩展">安装go扩展</a></li>
</ul></li>
</ul></li>
<li><a href="#第一个go程序">第一个Go程序</a>
<ul>
<li><a href="#hello-world">Hello World</a>
<ul>
<li><a href="#go-mod-init">go mod init</a></li>
<li><a href="#编写代码">编写代码</a></li>
</ul></li>
<li><a href="#编译">编译</a></li>
<li><a href="#windows下vscode切换cmd-exe作为默认终端">Windows下VSCode切换cmd.exe作为默认终端</a></li>
<li><a href="#go-run">go run</a></li>
<li><a href="#go-install">go install</a></li>
<li><a href="#跨平台编译">跨平台编译</a>
<ul>
<li><a href="#mac编译linux可执行文件">Mac编译Linux可执行文件</a></li>
<li><a href="#mac编译windows可执行文件">Mac编译Windows可执行文件</a></li>
<li><a href="#linux编译mac可执行文件">Linux编译Mac可执行文件</a></li>
<li><a href="#linux编译windows可执行文件">Linux编译Windows可执行文件</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#vs-code配置go语言开发环境">VS Code配置Go语言开发环境</a>
<ul>
<li><a href="#下载与安装-1">下载与安装</a></li>
<li><a href="#安装中文简体插件-1">安装中文简体插件</a></li>
<li><a href="#安装go开发扩展">安装Go开发扩展</a></li>
<li><a href="#变更编辑器主题">变更编辑器主题</a></li>
<li><a href="#安装go语言开发工具包">安装Go语言开发工具包</a></li>
<li><a href="#配置vscode开启自动保存">配置VSCode开启自动保存</a></li>
<li><a href="#配置代码片段快捷键">配置代码片段快捷键</a></li>
</ul></li>
<li><a href="#go语言之依赖管理">Go语言之依赖管理</a></li>
<li><a href="#依赖管理">依赖管理</a>
<ul>
<li><a href="#为什么需要依赖管理">为什么需要依赖管理</a>
<ul>
<li><a href="#godep">godep</a></li>
<li><a href="#安装-1">安装</a></li>
<li><a href="#基本命令">基本命令</a></li>
<li><a href="#使用godep">使用godep</a></li>
<li><a href="#vender机制">vender机制</a></li>
<li><a href="#godep开发流程">godep开发流程</a></li>
</ul></li>
<li><a href="#go-module">go module</a>
<ul>
<li><a href="#go111module">GO111MODULE</a></li>
<li><a href="#goproxy">GOPROXY</a></li>
<li><a href="#go-mod命令">go mod命令</a></li>
<li><a href="#go-mod">go.mod</a>
<ul>
<li><a href="#依赖的版本">依赖的版本</a></li>
<li><a href="#replace">replace</a></li>
<li><a href="#go-get">go get</a></li>
<li><a href="#整理依赖">整理依赖</a></li>
</ul></li>
<li><a href="#go-mod-edit">go mod edit</a>
<ul>
<li><a href="#格式化">格式化</a></li>
<li><a href="#添加依赖项">添加依赖项</a></li>
<li><a href="#移除依赖项">移除依赖项</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#在项目中使用go-module">在项目中使用go module</a>
<ul>
<li><a href="#既有项目">既有项目</a></li>
<li><a href="#新项目">新项目</a></li>
</ul></li>
<li><a href="#如何使用go-module导入本地包">如何使用go module导入本地包</a>
<ul>
<li><a href="#前提">前提</a></li>
<li><a href="#在同一个项目下">在同一个项目下</a>
<ul>
<li><a href="#目录结构">目录结构</a></li>
<li><a href="#导入包">导入包</a></li>
<li><a href="#举个例子">举个例子</a></li>
</ul></li>
<li><a href="#不在同一个项目下">不在同一个项目下</a>
<ul>
<li><a href="#目录结构-1">目录结构</a></li>
<li><a href="#导入包-1">导入包</a></li>
<li><a href="#举个例子-1">举个例子</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础">Go语言基础</a>
<ul>
<li><a href="#go语言基础之变量和常量">Go语言基础之变量和常量</a>
<ul>
<li><a href="#标识符与关键字">标识符与关键字</a>
<ul>
<li><a href="#标识符">标识符</a></li>
<li><a href="#关键字">关键字</a></li>
</ul></li>
<li><a href="#变量">变量</a>
<ul>
<li><a href="#变量的来历">变量的来历</a></li>
<li><a href="#变量类型">变量类型</a></li>
<li><a href="#变量声明">变量声明</a>
<ul>
<li><a href="#标准声明">标准声明</a></li>
<li><a href="#批量声明">批量声明</a></li>
<li><a href="#变量的初始化">变量的初始化</a></li>
<li><a href="#类型推导">类型推导</a></li>
<li><a href="#短变量声明">短变量声明</a></li>
<li><a href="#匿名变量">匿名变量</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#常量">常量</a>
<ul>
<li><a href="#iota">iota</a>
<ul>
<li><a href="#几个常见的-iota-示例">几个常见的<code>iota</code>示例:</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之基本数据类型">Go语言基础之基本数据类型</a></li>
<li><a href="#基本数据类型">基本数据类型</a>
<ul>
<li><a href="#整型">整型</a>
<ul>
<li><a href="#特殊整型">特殊整型</a></li>
<li><a href="#数字字面量语法-number-literals-syntax">数字字面量语法（Number literals syntax）</a></li>
</ul></li>
<li><a href="#浮点型">浮点型</a></li>
<li><a href="#复数">复数</a></li>
<li><a href="#布尔值">布尔值</a></li>
<li><a href="#字符串">字符串</a>
<ul>
<li><a href="#字符串转义符">字符串转义符</a></li>
<li><a href="#多行字符串">多行字符串</a></li>
<li><a href="#字符串的常用操作">字符串的常用操作</a></li>
</ul></li>
<li><a href="#byte和rune类型">byte和rune类型</a>
<ul>
<li><a href="#修改字符串">修改字符串</a></li>
</ul></li>
<li><a href="#类型转换">类型转换</a>
<ul>
<li><a href="#练习题">练习题</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之运算符">Go语言基础之运算符</a></li>
<li><a href="#运算符">运算符</a>
<ul>
<li><a href="#算术运算符">算术运算符</a></li>
<li><a href="#关系运算符">关系运算符</a></li>
<li><a href="#逻辑运算符">逻辑运算符</a></li>
<li><a href="#位运算符">位运算符</a></li>
<li><a href="#赋值运算符">赋值运算符</a>
<ul>
<li><a href="#练习题-1">练习题</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之流程控制">Go语言基础之流程控制</a>
<ul>
<li><a href="#if-else-分支结构">if else(分支结构)</a>
<ul>
<li><a href="#if条件判断基本写法">if条件判断基本写法</a></li>
<li><a href="#if条件判断特殊写法">if条件判断特殊写法</a></li>
</ul></li>
<li><a href="#for-循环结构">for(循环结构)</a>
<ul>
<li><a href="#无限循环">无限循环</a></li>
</ul></li>
<li><a href="#for-range-键值循环">for range(键值循环)</a></li>
<li><a href="#switch-case">switch case</a></li>
<li><a href="#goto-跳转到指定标签">goto(跳转到指定标签)</a></li>
<li><a href="#break-跳出循环">break(跳出循环)</a></li>
<li><a href="#continue-继续下次循环">continue(继续下次循环)</a>
<ul>
<li><a href="#练习题-2">练习题</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之数组">Go语言基础之数组</a></li>
<li><a href="#array-数组">Array(数组)</a>
<ul>
<li><a href="#数组定义">数组定义：</a></li>
<li><a href="#数组的初始化">数组的初始化</a>
<ul>
<li><a href="#方法一">方法一</a></li>
<li><a href="#方法二">方法二</a></li>
<li><a href="#方法三">方法三</a></li>
</ul></li>
<li><a href="#数组的遍历">数组的遍历</a></li>
<li><a href="#多维数组">多维数组</a>
<ul>
<li><a href="#二维数组的定义">二维数组的定义</a></li>
<li><a href="#二维数组的遍历">二维数组的遍历</a></li>
</ul></li>
<li><a href="#数组是值类型">数组是值类型</a></li>
<li><a href="#练习题-3">练习题</a></li>
</ul></li>
<li><a href="#go语言基础之切片">Go语言基础之切片</a></li>
<li><a href="#引子">引子</a></li>
<li><a href="#切片">切片</a>
<ul>
<li><a href="#切片的定义">切片的定义</a>
<ul>
<li><a href="#切片的长度和容量">切片的长度和容量</a></li>
<li><a href="#切片表达式">切片表达式</a>
<ul>
<li><a href="#简单切片表达式">简单切片表达式</a></li>
<li><a href="#完整切片表达式">完整切片表达式</a></li>
</ul></li>
<li><a href="#使用make-函数构造切片">使用make()函数构造切片</a></li>
<li><a href="#切片的本质">切片的本质</a></li>
<li><a href="#判断切片是否为空">判断切片是否为空</a></li>
</ul></li>
<li><a href="#切片不能直接比较">切片不能直接比较</a></li>
<li><a href="#切片的赋值拷贝">切片的赋值拷贝</a></li>
<li><a href="#切片遍历">切片遍历</a></li>
<li><a href="#append-方法为切片添加元素">append()方法为切片添加元素</a></li>
<li><a href="#切片的扩容策略">切片的扩容策略</a></li>
<li><a href="#使用copy-函数复制切片">使用copy()函数复制切片</a></li>
<li><a href="#从切片中删除元素">从切片中删除元素</a></li>
<li><a href="#练习题-4">练习题</a></li>
</ul></li>
<li><a href="#go语言基础之map">Go语言基础之map</a></li>
<li><a href="#map">map</a>
<ul>
<li><a href="#map定义">map定义</a></li>
<li><a href="#map基本使用">map基本使用</a></li>
<li><a href="#判断某个键是否存在">判断某个键是否存在</a></li>
<li><a href="#map的遍历">map的遍历</a></li>
<li><a href="#使用delete-函数删除键值对">使用delete()函数删除键值对</a></li>
<li><a href="#按照指定顺序遍历map">按照指定顺序遍历map</a></li>
<li><a href="#元素为map类型的切片">元素为map类型的切片</a></li>
<li><a href="#值为切片类型的map">值为切片类型的map</a></li>
</ul></li>
<li><a href="#练习题-5">练习题</a></li>
<li><a href="#go语言基础之函数">Go语言基础之函数</a></li>
<li><a href="#函数">函数</a>
<ul>
<li><a href="#函数定义">函数定义</a></li>
<li><a href="#函数的调用">函数的调用</a></li>
<li><a href="#参数">参数</a>
<ul>
<li><a href="#类型简写">类型简写</a></li>
<li><a href="#可变参数">可变参数</a></li>
</ul></li>
<li><a href="#返回值">返回值</a>
<ul>
<li><a href="#多返回值">多返回值</a></li>
<li><a href="#返回值命名">返回值命名</a></li>
<li><a href="#返回值补充">返回值补充</a></li>
</ul></li>
</ul></li>
<li><a href="#函数进阶">函数进阶</a>
<ul>
<li><a href="#变量作用域">变量作用域</a>
<ul>
<li><a href="#全局变量">全局变量</a></li>
<li><a href="#局部变量">局部变量</a></li>
</ul></li>
<li><a href="#函数类型与变量">函数类型与变量</a>
<ul>
<li><a href="#定义函数类型">定义函数类型</a></li>
<li><a href="#函数类型变量">函数类型变量</a></li>
</ul></li>
<li><a href="#高阶函数">高阶函数</a>
<ul>
<li><a href="#函数作为参数">函数作为参数</a></li>
<li><a href="#函数作为返回值">函数作为返回值</a></li>
</ul></li>
<li><a href="#匿名函数和闭包">匿名函数和闭包</a>
<ul>
<li><a href="#匿名函数">匿名函数</a></li>
<li><a href="#闭包">闭包</a></li>
</ul></li>
<li><a href="#defer语句">defer语句</a>
<ul>
<li><a href="#defer执行时机">defer执行时机</a></li>
<li><a href="#defer经典案例">defer经典案例</a></li>
<li><a href="#defer面试题">defer面试题</a></li>
</ul></li>
</ul></li>
<li><a href="#内置函数介绍">内置函数介绍</a>
<ul>
<li>
<ul>
<li><a href="#panic-recover">panic/recover</a></li>
</ul></li>
</ul></li>
<li><a href="#练习题-6">练习题</a></li>
<li><a href="#go语言基础之指针">Go语言基础之指针</a></li>
<li><a href="#go语言中的指针">Go语言中的指针</a>
<ul>
<li><a href="#指针地址和指针类型">指针地址和指针类型</a></li>
<li><a href="#指针取值">指针取值</a></li>
<li><a href="#new和make">new和make</a>
<ul>
<li><a href="#new">new</a></li>
<li><a href="#make">make</a></li>
<li><a href="#new与make的区别">new与make的区别</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之接口">Go语言基础之接口</a></li>
<li><a href="#接口">接口</a>
<ul>
<li><a href="#接口类型">接口类型</a>
<ul>
<li><a href="#接口的定义">接口的定义</a></li>
<li><a href="#实现接口的条件">实现接口的条件</a></li>
<li><a href="#为什么要使用接口">为什么要使用接口？</a></li>
<li><a href="#面向接口编程">面向接口编程</a></li>
<li><a href="#接口类型变量">接口类型变量</a></li>
</ul></li>
<li><a href="#值接收者和指针接收者">值接收者和指针接收者</a>
<ul>
<li><a href="#值接收者实现接口">值接收者实现接口</a></li>
<li><a href="#指针接收者实现接口">指针接收者实现接口</a></li>
</ul></li>
<li><a href="#类型与接口的关系">类型与接口的关系</a>
<ul>
<li><a href="#一个类型实现多个接口">一个类型实现多个接口</a></li>
<li><a href="#多种类型实现同一接口">多种类型实现同一接口</a></li>
</ul></li>
<li><a href="#接口组合">接口组合</a></li>
<li><a href="#空接口">空接口</a>
<ul>
<li><a href="#空接口的定义">空接口的定义</a></li>
<li><a href="#空接口的应用">空接口的应用</a>
<ul>
<li><a href="#空接口作为函数的参数">空接口作为函数的参数</a></li>
<li><a href="#空接口作为map的值">空接口作为map的值</a></li>
</ul></li>
</ul></li>
<li><a href="#接口值">接口值</a></li>
<li><a href="#类型断言">类型断言</a></li>
<li><a href="#练习题-7">练习题</a></li>
</ul></li>
<li><a href="#error接口和错误处理">Error接口和错误处理</a></li>
<li><a href="#error接口和错误处理-1">Error接口和错误处理</a>
<ul>
<li><a href="#error-接口">Error 接口</a></li>
<li><a href="#error-接口-1">Error 接口</a>
<ul>
<li><a href="#创建错误">创建错误</a>
<ul>
<li><a href="#errors-new">errors.New</a></li>
</ul></li>
<li><a href="#fmt-errorf">fmt.Errorf</a></li>
<li><a href="#错误结构体类型">错误结构体类型</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之反射">Go语言基础之反射</a></li>
<li><a href="#变量的内在机制">变量的内在机制</a></li>
<li><a href="#反射介绍">反射介绍</a></li>
<li><a href="#reflect包">reflect包</a>
<ul>
<li><a href="#typeof">TypeOf</a>
<ul>
<li><a href="#type-name和type-kind">type name和type kind</a></li>
</ul></li>
<li><a href="#valueof">ValueOf</a>
<ul>
<li><a href="#通过反射获取值">通过反射获取值</a></li>
<li><a href="#通过反射设置变量的值">通过反射设置变量的值</a></li>
<li><a href="#isnil-和isvalid">isNil()和isValid()</a>
<ul>
<li><a href="#isnil">isNil()</a></li>
<li><a href="#isvalid">isValid()</a></li>
<li><a href="#举个例子-2">举个例子</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#结构体反射">结构体反射</a>
<ul>
<li><a href="#与结构体相关的方法">与结构体相关的方法</a></li>
<li><a href="#structfield类型">StructField类型</a></li>
<li><a href="#结构体反射示例">结构体反射示例</a></li>
</ul></li>
<li><a href="#反射是把双刃剑">反射是把双刃剑</a></li>
<li><a href="#练习题-8">练习题</a></li>
</ul></li>
<li><a href="#go语言常用标准库">Go语言常用标准库</a>
<ul>
<li><a href="#go语言fmt-printf使用指南">Go语言fmt.Printf使用指南</a></li>
<li><a href="#fmt">fmt</a>
<ul>
<li><a href="#向外输出">向外输出</a>
<ul>
<li><a href="#print">Print</a></li>
<li><a href="#fprint">Fprint</a></li>
<li><a href="#sprint">Sprint</a></li>
<li><a href="#errorf">Errorf</a></li>
</ul></li>
<li><a href="#格式化占位符">格式化占位符</a>
<ul>
<li><a href="#通用占位符">通用占位符</a></li>
<li><a href="#布尔型">布尔型</a></li>
<li><a href="#整型-1">整型</a></li>
<li><a href="#浮点数与复数">浮点数与复数</a></li>
<li><a href="#字符串和-byte">字符串和[]byte</a></li>
<li><a href="#指针">指针</a></li>
<li><a href="#宽度标识符">宽度标识符</a></li>
<li><a href="#其他flag">其他flag</a></li>
</ul></li>
<li><a href="#获取输入">获取输入</a>
<ul>
<li><a href="#fmt-scan">fmt.Scan</a></li>
<li><a href="#fmt-scanf">fmt.Scanf</a></li>
<li><a href="#fmt-scanln">fmt.Scanln</a></li>
<li><a href="#bufio-newreader">bufio.NewReader</a></li>
<li><a href="#fscan系列">Fscan系列</a></li>
<li><a href="#sscan系列">Sscan系列</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之time包">Go语言基础之time包</a></li>
<li><a href="#time包">time包</a>
<ul>
<li><a href="#时间类型">时间类型</a></li>
<li><a href="#location和time-zone">Location和time zone</a></li>
<li><a href="#unix-time">Unix Time</a></li>
<li><a href="#时间间隔">时间间隔</a>
<ul>
<li><a href="#时间操作">时间操作</a></li>
<li><a href="#add">Add</a></li>
<li><a href="#sub">Sub</a></li>
<li><a href="#equal">Equal</a></li>
<li><a href="#before">Before</a></li>
<li><a href="#after">After</a></li>
</ul></li>
<li><a href="#定时器">定时器</a></li>
<li><a href="#时间格式化">时间格式化</a></li>
<li><a href="#解析字符串格式的时间">解析字符串格式的时间</a></li>
<li><a href="#练习题-9">练习题</a></li>
</ul></li>
<li><a href="#go语言标准库flag基本使用">Go语言标准库flag基本使用</a></li>
<li><a href="#os-args">os.Args</a></li>
<li><a href="#flag包基本使用">flag包基本使用</a>
<ul>
<li><a href="#导入flag包">导入flag包</a></li>
<li><a href="#flag参数类型">flag参数类型</a></li>
<li><a href="#定义命令行flag参数">定义命令行flag参数</a>
<ul>
<li><a href="#flag-type">flag.Type()</a></li>
<li><a href="#flag-typevar">flag.TypeVar()</a></li>
</ul></li>
<li><a href="#flag-parse">flag.Parse()</a></li>
<li><a href="#flag其他函数">flag其他函数</a></li>
<li><a href="#完整示例">完整示例</a>
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#使用">使用</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言标准库log介绍">Go语言标准库log介绍</a></li>
<li><a href="#log">log</a>
<ul>
<li><a href="#使用logger">使用Logger</a></li>
<li><a href="#配置logger">配置logger</a>
<ul>
<li><a href="#标准logger的配置">标准logger的配置</a></li>
<li><a href="#flag选项">flag选项</a></li>
<li><a href="#配置日志前缀">配置日志前缀</a></li>
<li><a href="#配置日志输出位置">配置日志输出位置</a></li>
</ul></li>
<li><a href="#创建logger">创建logger</a></li>
<li><a href="#总结">总结</a></li>
</ul></li>
<li><a href="#go语言文件操作">Go语言文件操作</a></li>
<li><a href="#打开和关闭文件">打开和关闭文件</a></li>
<li><a href="#读取文件">读取文件</a>
<ul>
<li><a href="#file-read">file.Read()</a>
<ul>
<li><a href="#基本使用">基本使用</a></li>
<li><a href="#循环读取">循环读取</a></li>
</ul></li>
<li><a href="#bufio读取文件">bufio读取文件</a></li>
<li><a href="#ioutil读取整个文件">ioutil读取整个文件</a></li>
</ul></li>
<li><a href="#文件写入操作">文件写入操作</a>
<ul>
<li><a href="#write和writestring">Write和WriteString</a></li>
<li><a href="#bufio-newwriter">bufio.NewWriter</a></li>
<li><a href="#ioutil-writefile">ioutil.WriteFile</a></li>
</ul></li>
<li><a href="#练习">练习</a>
<ul>
<li><a href="#copyfile">copyFile</a></li>
<li><a href="#实现一个cat命令">实现一个cat命令</a></li>
</ul></li>
<li><a href="#go语言内置包之strconv">Go语言内置包之strconv</a></li>
<li><a href="#strconv包">strconv包</a>
<ul>
<li><a href="#string与int类型转换">string与int类型转换</a>
<ul>
<li><a href="#atoi">Atoi()</a></li>
<li><a href="#itoa">Itoa()</a></li>
<li><a href="#a的典故">a的典故</a></li>
</ul></li>
<li><a href="#parse系列函数">Parse系列函数</a>
<ul>
<li><a href="#parsebool">ParseBool()</a></li>
<li><a href="#parseint">ParseInt()</a></li>
<li><a href="#parseunit">ParseUnit()</a></li>
<li><a href="#parsefloat">ParseFloat()</a></li>
<li><a href="#代码示例">代码示例</a></li>
</ul></li>
<li><a href="#format系列函数">Format系列函数</a>
<ul>
<li><a href="#formatbool">FormatBool()</a></li>
<li><a href="#formatint">FormatInt()</a></li>
<li><a href="#formatuint">FormatUint()</a></li>
<li><a href="#formatfloat">FormatFloat()</a></li>
<li><a href="#代码示例-1">代码示例</a></li>
</ul></li>
<li><a href="#其他">其他</a>
<ul>
<li><a href="#isprint">isPrint()</a></li>
<li><a href="#canbackquote">CanBackquote()</a></li>
<li><a href="#其他-1">其他</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之net-http">Go语言基础之net/http</a>
<ul>
<li><a href="#net-http介绍">net/http介绍</a>
<ul>
<li><a href="#http协议">HTTP协议</a></li>
</ul></li>
<li><a href="#http客户端">HTTP客户端</a>
<ul>
<li><a href="#基本的http-https请求">基本的HTTP/HTTPS请求</a></li>
<li><a href="#get请求示例">GET请求示例</a></li>
<li><a href="#带参数的get请求示例">带参数的GET请求示例</a></li>
<li><a href="#post请求示例">Post请求示例</a></li>
<li><a href="#自定义client">自定义Client</a></li>
<li><a href="#自定义transport">自定义Transport</a></li>
</ul></li>
<li><a href="#服务端">服务端</a>
<ul>
<li><a href="#默认的server">默认的Server</a></li>
<li><a href="#默认的server示例">默认的Server示例</a></li>
<li><a href="#自定义server">自定义Server</a></li>
</ul></li>
</ul></li>
<li><a href="#go标准库context">Go标准库Context</a>
<ul>
<li><a href="#为什么需要context">为什么需要Context</a>
<ul>
<li><a href="#基本示例">基本示例</a></li>
<li><a href="#全局变量方式">全局变量方式</a></li>
<li><a href="#通道方式">通道方式</a></li>
<li><a href="#官方版的方案">官方版的方案</a></li>
</ul></li>
<li><a href="#context初识">Context初识</a></li>
<li><a href="#context接口">Context接口</a>
<ul>
<li><a href="#background-和todo">Background()和TODO()</a></li>
</ul></li>
<li><a href="#with系列函数">With系列函数</a>
<ul>
<li><a href="#withcancel">WithCancel</a></li>
<li><a href="#withdeadline">WithDeadline</a></li>
<li><a href="#withtimeout">WithTimeout</a></li>
<li><a href="#withvalue">WithValue</a></li>
</ul></li>
<li><a href="#使用context的注意事项">使用Context的注意事项</a></li>
<li><a href="#客户端超时取消示例">客户端超时取消示例</a>
<ul>
<li><a href="#server端">server端</a></li>
<li><a href="#client端">client端</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
        </div>
      </nav>
    </div>
  </aside>
<main class="main" role="main"><div class="content">
  <article id="-" class="article article-type-" itemscope
    itemtype="https://schema.org/BlogPosting">
    
    <div class="article-header">
      <h1 itemprop="name">
  <a
    class="article-title"
    href="/2022/10/golang/"
    >Golang</a
  >
</h1>

      <div class="article-meta">
        <span class="article-date">
  <i class="icon icon-calendar-check"></i>
<a href="https://mumulx.gitee.io/2022/10/golang/" class="article-date">
  <time datetime="2022-10-24 00:00:00 &#43;0000 UTC" itemprop="datePublished">2022-10-24</time>
</a>
</span><span class="article-category">
  <i class="icon icon-folder"></i>
  <a class="article-category-link" href="/categories/golang/"> Golang </a>
</span>  
  <span class="article-tag">
    <i class="icon icon-tags"></i>
    <a class="article-tag-link" href="/tags/golang/"> Golang </a>
  </span>

	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>
        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/10/golang/#comments"
            class="article-comment-link">评论</a></span>
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计:63341字</span>
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长:127分 </span>
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      

<h1 id="golang">Golang</h1>

<p><a href="https://www.liwenzhou.com/posts/Go/golang-menu/">李文周的博客</a></p>

<h2 id="为什么你应该学习go语言">为什么你应该学习Go语言？</h2>

<p>终于等到你！Go语言——让你用写Python代码的开发效率编写C语言代码。</p>

<h2 id="为什么互联网世界需要go语言">为什么互联网世界需要Go语言</h2>

<p>世界上已经有太多太多的编程语言了，为什么又出来一个Go语言？</p>

<h3 id="硬件限制-摩尔定律已然失效">硬件限制：摩尔定律已然失效</h3>

<blockquote>
<p>摩尔定律：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。 换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。</p>
</blockquote>

<p><img src="/resources/技术收录/golang/15511542807193.jpg" alt="img" /></p>

<p>从上面的图表可以看出，近十年单线程性能和处理器频率保持稳定。我们不能像之前一样把添加更多晶体管当成是解决方案，因为在较小规模上一些量子特性开始出现（如隧道效应），并且因为在同样小的空间里放置更多晶体管的代价非常昂贵，每1美元可以添加的晶体管数量开始下降。</p>

<p>制造商开始从其他方面提高处理器的性能：</p>

<ol>
<li>向处理器添加越来越多的内核，如四核和八核CPU。</li>
<li>发明了超线程技术。</li>
<li>为处理器添加了更多缓存以提高性能。</li>
</ol>

<p>但上述解决方案也有其自身的局限性。因为成本原因我们不能无限制的为计算机添加内核，也无法无限制的添加缓存来提高性能，因为缓存越大，取值的性能越低。</p>

<p>我们没有办法在硬件上一直取得突破，我们需要提高软件的性能或者说我们需要高性能的软件。</p>

<h3 id="go语言为并发而生">Go语言为并发而生</h3>

<p>如上所述，硬件制造商正在为处理器添加越来越多的内核以提高性能。所有数据中心都在这些处理器上运行，更重要的是，今天的应用程序使用多个微服务来维护数据库连接，消息队列和维护缓存。因此，开发的软件和编程语言应该可以轻松地支持并发性，并且应该能够随着CPU核心数量的增加而可扩展。</p>

<p>但是，大多数现代编程语言（如Java，Python等）都来自90年代的单线程环境。虽然一些编程语言的框架在不断地提高多核资源使用效率，例如 Java 的 Netty 等，但仍然需要开发人员花费大量的时间和精力搞懂这些框架的运行原理后才能熟练掌握。</p>

<p>Go于2009年发布，当时多核处理器已经上市。Go语言在多核并发上拥有原生的设计优势，Go语言从底层原生支持并发，无须第三方库、开发者的编程技巧和开发经验。</p>

<p>很多公司，特别是中国的互联网公司，即将或者已经完成了使用 Go 语言改造旧系统的过程。经过 Go 语言重构的系统能使用更少的硬件资源获得更高的并发和I/O吞吐表现。充分挖掘硬件设备的潜力也满足当前精细化运营的市场大环境。</p>

<p>Go语言的并发是基于 <code>goroutine</code> 的，<code>goroutine</code> 类似于线程，但并非线程。可以将 <code>goroutine</code> 理解为一种虚拟线程。Go 语言运行时会参与调度 <code>goroutine</code>，并将 <code>goroutine</code> 合理地分配到每个 CPU 中，最大限度地使用CPU性能。开启一个<code>goroutine</code>的消耗非常小（大约2KB的内存），你可以轻松创建数百万个<code>goroutine</code>。</p>

<p><code>goroutine</code>的特点：</p>

<ol>
<li><code>goroutine</code>具有可增长的分段堆栈。这意味着它们只在需要时才会使用更多内存。</li>
<li><code>goroutine</code>的启动时间比线程快。</li>
<li><code>goroutine</code>原生支持利用channel安全地进行通信。</li>
<li><code>goroutine</code>共享数据结构时无需使用互斥锁。</li>
</ol>

<h3 id="go性能强悍">Go性能强悍</h3>

<p>与其他现代高级语言（如Java/Python）相比，使用C，C++的最大好处是它们的性能。因为C/ C++是编译型语言而不是解释的语言。 处理器只能理解二进制文件，Java和Python这种高级语言在运行的时候需要先将人类可读的代码翻译成字节码，然后由专门的解释器再转变成处理器可以理解的二进制文件。<img src="/resources/技术收录/golang/15511649241043.jpg" alt="-w839" />同C,C++一样，Go语言也是编译型的语言，它直接将人类可读的代码编译成了处理器可以直接运行的二进制文件，执行效率更高，性能更好。<img src="/resources/技术收录/golang/15511709770708.jpg" alt="-w1112" />数据来源：<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/">https://benchmarksgame-team.pages.debian.net/benchmarksgame/</a></p>

<p>可以看出，Go 语言在性能上更接近于 Java 语言，虽然在某些测试用例上不如经过多年优化的 Java 语言，但毕竟 Java 语言已经经历了多年的积累和优化。Go 语言在未来的版本中会通过不断的版本优化提高单核运行性能。</p>

<h3 id="go语言简单易学">Go语言简单易学</h3>

<h4 id="语法简洁">语法简洁</h4>

<p>Go 语言简单易学，学习曲线平缓，不需要像 C/C++ 语言动辄需要两到三年的学习期。Go 语言被称为“互联网时代的C语言”。Go 语言的风格类似于C语言。其语法在C语言的基础上进行了大幅的简化，去掉了不需要的表达式括号，循环也只有 for 一种表示方法，就可以实现数值、键值等各种遍历。</p>

<h4 id="代码风格统一">代码风格统一</h4>

<p>Go 语言提供了一套格式化工具——<code>go fmt</code>。一些 Go 语言的开发环境或者编辑器在保存时，都会使用格式化工具进行修改代码的格式化，这样就保证了不同开发者提交的代码都是统一的格式。(吐槽下：再也不用担心那些看不懂的黑魔法了…)</p>

<h4 id="开发效率高">开发效率高</h4>

<p><img src="/resources/技术收录/golang/15511721724188.jpg" alt="img" />Go语言实现了开发效率与执行效率的完美结合，让你像写Python代码（效率）一样编写C代码（性能）。</p>

<h2 id="学习go语言的前景">学习Go语言的前景</h2>

<p>目前Go语言已经⼴泛应用于人工智能、云计算开发、容器虚拟化、⼤数据开发、数据分析及科学计算、运维开发、爬虫开发、游戏开发等领域。</p>

<p>Go语言简单易学，天生支持并发，完美契合当下高并发的互联网生态。Go语言的岗位需求持续高涨，目前的Go程序员数量少，待遇好。</p>

<p>抓住趋势，要学会做一个领跑者而不是跟随者。</p>

<p>国内Go语言的需求潜力巨大，目前无论是国内大厂还是新兴互联网公司基本上都会有Go语言的岗位需求。</p>

<p>下图是应用Go语言的公司举例：</p>

<p><img src="/resources/技术收录/golang/image-20190203135218456.png" alt="image-20190203135218456" /></p>

<p>除了上面列出的大厂外，很多小型公司或创业公司也开始使用Go语言，并且很多公司把Go语言作为其主要开发语言。</p>

<p>现在就开始你的Go语言学习之旅吧！人生苦短，let’s Go.</p>

<p><a href="https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65">参考链接</a></p>

<h1 id="开发环境准备">开发环境准备</h1>

<h2 id="从零开始搭建go语言开发环境-新">从零开始搭建Go语言开发环境（新）</h2>

<p>Go1.14版本，一步一步，从零搭建Go语言开发环境。</p>

<p><strong>因为Go语言及相关编辑工具的更新迭代，本文已于2021/05/12更新，可能会和视频有所出入，请以更新后的本文为准。</strong></p>

<h3 id="安装go语言及搭建go语言开发环境">安装Go语言及搭建Go语言开发环境</h3>

<p><strong>注意：</strong>Go语言1.14版本之后推荐使用go modules管理依赖，也不再需要把代码写在GOPATH目录下了，之前旧版本的教程戳这个<a href="https://www.liwenzhou.com/posts/Go/install_go_dev_old/">链接</a>。</p>

<h3 id="下载">下载</h3>

<h4 id="下载地址">下载地址</h4>

<p>Go官网下载地址：<a href="https://golang.org/dl/">https://golang.org/dl/</a></p>

<p>Go官方镜像站（推荐）：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p>

<h4 id="版本的选择">版本的选择</h4>

<p>Windows平台和Mac平台推荐下载可执行文件版，Linux平台下载压缩文件版。</p>

<p><strong>下图中的版本号可能并不是最新的，但总体来说安装教程是类似的。Go语言更新迭代比较快，推荐使用较新版本，体验最新特性。</strong></p>

<p><img src="/resources/技术收录/golang/download1.png" alt="download1" /></p>

<h3 id="安装">安装</h3>

<h4 id="windows安装">Windows安装</h4>

<p>此安装实例以 <code>64位Win10</code>系统安装 <code>Go1.14.1可执行文件版本</code>为例。</p>

<p>将上一步选好的安装包下载到本地。</p>

<p><img src="/resources/技术收录/golang/download2.png" alt="download2" /></p>

<p>双击下载好的文件，然后按照下图的步骤安装即可。</p>

<p><img src="/resources/技术收录/golang/install01.png" alt="install01" /><img src="/resources/技术收录/golang/install02.png" alt="install02" /><img src="/resources/技术收录/golang/install03.png" alt="install03" /><img src="/resources/技术收录/golang/install04.png" alt="install04" /><img src="/resources/技术收录/golang/install05.png" alt="install05" /></p>

<h4 id="linux下安装">Linux下安装</h4>

<p>如果不是要在Linux平台敲go代码就不需要在Linux平台安装Go，我们开发机上写好的go代码只需要跨平台编译（详见文章末尾的跨平台编译）好之后就可以拷贝到Linux服务器上运行了，这也是go程序跨平台易部署的优势。</p>

<p>我们在版本选择页面选择并下载好<code>go1.14.1.linux-amd64.tar.gz</code>文件：</p>

<pre><code class="language-bash">wget https://dl.google.com/go/go1.14.1.linux-amd64.tar.gz
</code></pre>

<p>将下载好的文件解压到<code>/usr/local</code>目录下：</p>

<pre><code class="language-bash">tar -zxvf go1.14.1.linux-amd64.tar.gz -C /usr/local  # 解压
</code></pre>

<p>如果提示没有权限，加上<code>sudo</code>以root用户的身份再运行。执行完就可以在<code>/usr/local/</code>下看到<code>go</code>目录了。</p>

<p>配置环境变量： Linux下有两个文件可以配置环境变量，其中<code>/etc/profile</code>是对所有用户生效的；<code>$HOME/.profile</code>是对当前用户生效的，根据自己的情况自行选择一个文件打开，添加如下两行代码，保存退出。</p>

<pre><code class="language-bash">export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
</code></pre>

<p>修改<code>/etc/profile</code>后要重启生效，修改<code>$HOME/.profile</code>后使用source命令加载<code>$HOME/.profile</code>文件即可生效。 检查：</p>

<pre><code class="language-bash">~ go version
go version go1.14.1 linux/amd64
</code></pre>

<h4 id="mac下安装">Mac下安装</h4>

<p>下载可执行文件版，直接点击<strong>下一步</strong>安装即可，默认会将go安装到<code>/usr/local/go</code>目录下。<img src="/resources/技术收录/golang/mac_install_go.png" alt="Mac安装Go" /></p>

<h4 id="检查">检查</h4>

<p>上一步安装过程执行完毕后，可以打开终端窗口，输入<code>go version</code>命令，查看安装的Go版本。<img src="/resources/技术收录/golang/install06.png" alt="install06" /></p>

<h3 id="goroot和gopath">GOROOT和GOPATH</h3>

<p><code>GOROOT</code>和<code>GOPATH</code>都是环境变量，其中<code>GOROOT</code>是我们安装go开发包的路径，而从Go 1.8版本开始，Go开发包在安装完成后会为<code>GOPATH</code>设置一个默认目录，并且在Go1.14及之后的版本中启用了Go Module模式之后，不一定非要将代码写到GOPATH目录下，所以也就<strong>不需要我们再自己配置GOPATH</strong>了，使用默认的即可。</p>

<h4 id="goproxy-非常重要">GOPROXY 非常重要</h4>

<p>Go1.14版本之后，都推荐使用<code>go mod</code>模式来管理依赖环境了，也不再强制我们把代码必须写在<code>GOPATH</code>下面的src目录了，你可以在你电脑的任意位置编写go代码。（网上有些教程适用于1.11版本之前。）</p>

<p>默认GoPROXY配置是：<code>GOPROXY=https://proxy.golang.org,direct</code>，由于国内访问不到<code>https://proxy.golang.org</code>，所以我们需要换一个PROXY，这里推荐使用<code>https://goproxy.io</code>或<code>https://goproxy.cn</code>。</p>

<p>可以执行下面的命令修改GOPROXY：</p>

<pre><code class="language-bash">go env -w GOPROXY=https://goproxy.cn,direct
</code></pre>

<h3 id="go开发编辑器">Go开发编辑器</h3>

<p>Go采用的是UTF-8编码的文本文件存放源代码，理论上使用任何一款文本编辑器都可以做Go语言开发，这里推荐使用<code>VS Code</code>和<code>Goland</code>。 <code>VS Code</code>是微软开源的编辑器，而<code>Goland</code>是jetbrains出品的付费IDE。</p>

<p>我们这里使用<code>VS Code</code> 加插件做为go语言的开发工具。</p>

<h4 id="vs-code介绍">VS Code介绍</h4>

<p><code>VS Code</code>全称<code>Visual Studio Code</code>，是微软公司开源的一款<strong>免费</strong>现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，支持 Win、Mac 以及 Linux平台。</p>

<p>虽然不如某些IDE功能强大，但是它添加Go扩展插件后已经足够胜任我们日常的Go开发。</p>

<h4 id="下载与安装">下载与安装</h4>

<p><code>VS Code</code>官方下载地址：<a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></p>

<p>三大主流平台都支持，请根据自己的电脑平台选择对应的安装包。<img src="/resources/技术收录/golang/vscode_home.png" alt="vscode_home" />双击下载好的安装文件，双击安装即可。</p>

<h4 id="配置">配置</h4>

<h5 id="安装中文简体插件">安装中文简体插件</h5>

<p>点击左侧菜单栏最后一项<code>管理扩展</code>，在<code>搜索框</code>中输入<code>chinese</code> ，选中结果列表第一项，点击<code>install</code>安装。</p>

<p>安装完毕后右下角会提示<code>重启VS Code</code>，重启之后你的VS Code就显示中文啦！<img src="https://www.liwenzhou.com/images/Go/install_go_dev/vscode1.gif" alt="安装简体中文插件" /><code>VSCode</code>主界面介绍：<img src="/resources/技术收录/golang/vscode_menu.png" alt="vscode_menu" /></p>

<h5 id="安装go扩展">安装go扩展</h5>

<p>现在我们要为我们的VS Code编辑器安装<code>Go</code>扩展插件，让它支持Go语言开发。<img src="/resources/技术收录/golang/vscode_plugin.png" alt="安装go扩展图" /></p>

<h3 id="第一个go程序">第一个Go程序</h3>

<h4 id="hello-world">Hello World</h4>

<p>现在我们来创建第一个Go项目——<code>hello</code>。在我们桌面创建一个<code>hello</code>目录。</p>

<h5 id="go-mod-init">go mod init</h5>

<p>使用go module模式新建项目时，我们需要通过<code>go mod init 项目名</code>命令对项目进行初始化，该命令会在项目根目录下生成<code>go.mod</code>文件。例如，我们使用<code>hello</code>作为我们第一个Go项目的名称，执行如下命令。</p>

<pre><code class="language-bash">go mod init hello
</code></pre>

<h5 id="编写代码">编写代码</h5>

<p>接下来在该目录中创建一个<code>main.go</code>文件：</p>

<pre><code class="language-go">package main  // 声明 main 包，表明当前是一个可执行程序

import &quot;fmt&quot;  // 导入内置 fmt 包

func main(){  // main函数，是程序执行的入口
	fmt.Println(&quot;Hello World!&quot;)  // 在终端打印 Hello World!
}
</code></pre>

<p><strong>非常重要！！！</strong> 如果此时VS Code右下角弹出提示让你安装插件，务必点 <strong>install all</strong> 进行安装。</p>

<h4 id="编译">编译</h4>

<p><code>go build</code>命令表示将源代码编译成可执行文件。</p>

<p>在hello目录下执行：</p>

<pre><code class="language-bash">go build
</code></pre>

<p>或者在其他目录执行以下命令：</p>

<pre><code class="language-bash">go build hello
</code></pre>

<p>go编译器会去 <code>GOPATH</code>的src目录下查找你要编译的<code>hello</code>项目</p>

<p>编译得到的可执行文件会保存在执行编译命令的当前目录下，如果是windows平台会在当前目录下找到<code>hello.exe</code>可执行文件。</p>

<p>可在终端直接执行该<code>hello.exe</code>文件：</p>

<pre><code class="language-bash">c:\desktop\hello&gt;hello.exe
Hello World!
</code></pre>

<p>我们还可以使用<code>-o</code>参数来指定编译后得到的可执行文件的名字。</p>

<pre><code class="language-bash">go build -o heiheihei.exe
</code></pre>

<h4 id="windows下vscode切换cmd-exe作为默认终端">Windows下VSCode切换cmd.exe作为默认终端</h4>

<p>如果你打开VS Code的终端界面出现如下图场景（注意观察红框圈中部分），那么你的<code>VS Code</code>此时正使用<code>powershell</code>作为默认终端：<img src="/resources/技术收录/golang/vscode_shell1.png" alt="vscode shell配置1" />十分推荐你按照下面的步骤，选择<code>cmd.exe</code>作为默认的终端工具：<img src="/resources/技术收录/golang/vscode_shell2.png" alt="vscode shell配置2" />此时，VS Code正上方中间位置会弹出如下界面，参照下图挪动鼠标使光标选中后缀为<code>cmd.exe</code>的那一个，然后点击鼠标左键。</p>

<p>最后<strong>重启VS Code中已经打开的终端</strong>或者<strong>直接重启VS Code</strong>就可以了。<img src="/resources/技术收录/golang/vscode_shell3.png" alt="vscode shell配置3" />如果没有出现下拉三角，也没有关系，按下<code>Ctrl+Shift+P</code>，VS Code正上方会出现一个框，你按照下图输入<code>shell</code>，然后点击指定选项即可出现上面的界面了。<img src="/resources/技术收录/golang/vscode_shell4.png" alt="vscode shell配置4" /></p>

<h4 id="go-run">go run</h4>

<p><code>go run main.go</code>也可以执行程序，该命令本质上也是先编译再执行。</p>

<h4 id="go-install">go install</h4>

<p><code>go install</code>表示安装的意思，它先编译源代码得到可执行文件，然后将可执行文件移动到<code>GOPATH</code>的bin目录下。因为我们的环境变量中配置了<code>GOPATH</code>下的bin目录，所以我们就可以在任意地方直接执行可执行文件了。</p>

<h4 id="跨平台编译">跨平台编译</h4>

<p>默认我们<code>go build</code>的可执行文件都是当前操作系统可执行的文件，Go语言支持跨平台编译——在当前平台（例如Windows）下编译其他平台（例如Linux）的可执行文件。</p>

<p>Windows编译Linux可执行文件</p>

<p>如果我想在Windows下编译一个Linux下可执行文件，那需要怎么做呢？只需要在编译时指定目标操作系统的平台和处理器架构即可。</p>

<blockquote>
<p>注意：无论你在Windows电脑上使用VsCode编辑器还是Goland编辑器，都要注意你使用的终端类型，因为不同的终端下命令不一样！！！目前的Windows通常默认使用的是<code>PowerShell</code>终端。</p>
</blockquote>

<p>如果你的<code>Windows</code>使用的是<code>cmd</code>，那么按如下方式指定环境变量。</p>

<pre><code class="language-bash">SET CGO_ENABLED=0  // 禁用CGO
SET GOOS=linux  // 目标平台是linux
SET GOARCH=amd64  // 目标处理器架构是amd64
</code></pre>

<p>如果你的<code>Windows</code>使用的是<code>PowerShell</code>终端，那么设置环境变量的语法为</p>

<pre><code class="language-bash">$ENV:CGO_ENABLED=0
$ENV:GOOS=&quot;linux&quot;
$ENV:GOARCH=&quot;amd64&quot;
</code></pre>

<p>在你的<code>Windows</code>终端下执行完上述命令后，再执行下面的命令，得到的就是能够在Linux平台运行的可执行文件了。</p>

<pre><code class="language-bash">go build
</code></pre>

<p>Windows编译Mac可执行文件</p>

<p>Windows下编译Mac平台64位可执行程序：</p>

<p>cmd终端下执行：</p>

<pre><code class="language-bash">SET CGO_ENABLED=0
SET GOOS=darwin
SET GOARCH=amd64
go build
</code></pre>

<p>PowerShell终端下执行：</p>

<pre><code class="language-bash">$ENV:CGO_ENABLED=0
$ENV:GOOS=&quot;darwin&quot;
$ENV:GOARCH=&quot;amd64&quot;
go build
</code></pre>

<h5 id="mac编译linux可执行文件">Mac编译Linux可执行文件</h5>

<p>Mac电脑编译得到Linux平台64位可执行程序：</p>

<pre><code class="language-bash">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build
</code></pre>

<h5 id="mac编译windows可执行文件">Mac编译Windows可执行文件</h5>

<p>Mac电脑编译得到Windows平台64位可执行程序：</p>

<pre><code class="language-bash">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build
</code></pre>

<h5 id="linux编译mac可执行文件">Linux编译Mac可执行文件</h5>

<p>Linux平台下编译Mac平台64位可执行程序：</p>

<pre><code class="language-bash">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build
</code></pre>

<h5 id="linux编译windows可执行文件">Linux编译Windows可执行文件</h5>

<p>Linux平台下编译Windows平台64位可执行程序：</p>

<pre><code class="language-bash">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build
</code></pre>

<p>现在，开启你的Go语言学习之旅吧。人生苦短，let’s Go.</p>

<h2 id="vs-code配置go语言开发环境">VS Code配置Go语言开发环境</h2>

<p>VS Code是微软开源的一款编辑器，插件系统十分的丰富。本文就介绍了如何使用VS Code搭建Go语言开发环境。</p>

<p><strong>因为Go语言及相关编辑工具的更新迭代，本文已于2020/03/25更新，可能会和视频有所出入，请以更新后的本文为准。</strong></p>

<p>说在前面的话，Go语言是采用UTF8编码的，理论上使用任何文本编辑器都能做Go语言开发。大家可以根据自己的喜好自行选择。编辑器/IDE没有最好只有最适合。</p>

<h3 id="下载与安装-1">下载与安装</h3>

<p><code>VS Code</code>官方下载地址：<a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></p>

<p>三大主流平台都支持，请根据自己的电脑平台选择对应的安装包。<img src="/resources/技术收录/golang/vscode_home-166659257246841.png" alt="vscode_home" />双击下载好的安装文件，双击安装即可。</p>

<h3 id="安装中文简体插件-1">安装中文简体插件</h3>

<p>点击左侧菜单栏最后一项<code>管理扩展</code>，在<code>搜索框</code>中输入<code>chinese</code> ，选中结果列表第一项，点击<code>install</code>安装。</p>

<p>安装完毕后右下角会提示<code>重启VS Code</code>，重启之后你的VS Code就显示中文啦！<img src="https://www.liwenzhou.com/images/Go/install_go_dev/vscode1.gif" alt="安装简体中文插件" /><code>VSCode</code>主界面介绍：<img src="/resources/技术收录/golang/vscode_menu-166659257246844.png" alt="vscode_menu" /></p>

<h3 id="安装go开发扩展">安装Go开发扩展</h3>

<p>现在我们要为我们的VS Code编辑器安装<code>Go</code>扩展插件，让它支持Go语言开发。<img src="/resources/技术收录/golang/vscode_plugin-166659257246846.png" alt="安装go扩展图" /></p>

<h3 id="变更编辑器主题">变更编辑器主题</h3>

<p>依次点击<code>设置-&gt;颜色主题</code>，<img src="/resources/技术收录/golang/vscode_theme01.png" alt="vscode_theme" />会弹出如下窗口：<img src="/resources/技术收录/golang/vscode_theme02.png" alt="vscode_theme" />可以根据自己的喜好选择相应的主题。</p>

<h3 id="安装go语言开发工具包">安装Go语言开发工具包</h3>

<p>在座Go语言开发的时候为我们提供诸如代码提示、代码自动补全等功能。</p>

<p>在此之前请先设置<code>GOPROXY</code>，打开终端执行以下命令：</p>

<pre><code class="language-bash">go env -w GOPROXY=https://goproxy.cn,direct
</code></pre>

<p>Windows平台按下<code>Ctrl+Shift+P</code>，Mac平台按<code>Command+Shift+P</code>，这个时候VS Code界面会弹出一个输入框，如下图：<img src="/resources/技术收录/golang/vscode09.png" alt="vscode09" /></p>

<p>我们在这个输入框中输入<code>&gt;go:install</code>，下面会自动搜索相关命令，我们选择<code>Go:Install/Update Tools</code>这个命令，按下图选中并会回车执行该命令（或者使用鼠标点击该命令）<img src="/resources/技术收录/golang/vscode10.png" alt="vscode10" />在弹出的窗口选中所有，并点击“确定”按钮，进行安装。<img src="/resources/技术收录/golang/vscode11.png" alt="vscode11" /></p>

<p>然后会弹出如下窗口，开始安装工具：<img src="/resources/技术收录/golang/vscode12.png" alt="vscode12" /></p>

<p>喝口水，等待所有工具都安装成功，如下图所示:<img src="/resources/技术收录/golang/vscode14.png" alt="vscode14" /></p>

<h3 id="配置vscode开启自动保存">配置VSCode开启自动保存</h3>

<p>按下图依次点击 <code>文件-&gt;首选项-&gt;设置</code>，<img src="/resources/技术收录/golang/vscode15.png" alt="vscode15" />打开设置页面就能看到自动保存相关配置如下图，可以根据自己的喜好选择自动保存的方式：<img src="/resources/技术收录/golang/vscode16.png" alt="vscode16" /></p>

<h3 id="配置代码片段快捷键">配置代码片段快捷键</h3>

<p>还是按<code>Ctrl/Command+Shift+P</code>,按下图输入<code>&gt;snippets</code>，选择命令并执行：<img src="/resources/技术收录/golang/vscode17.png" alt="vscode16" /></p>

<p>然后在弹出的窗口点击选择<code>go</code>选项：<img src="/resources/技术收录/golang/vscode18.png" alt="vscode18" />然后弹出如下页面：<img src="/resources/技术收录/golang/vscode19.png" alt="vscode19" /></p>

<p>大家可以简单看下上面的注释，介绍了主要用法：</p>

<pre><code class="language-js">“这里放个名字”:{
    &quot;prefix&quot;: &quot;这个是快捷键&quot;,
    &quot;body&quot;: &quot;这里是按快捷键插入的代码片段&quot;,
    &quot;description&quot;: &quot;这里放提示信息的描述&quot;
}
</code></pre>

<p>其中<code>$0</code>表示最终光标提留的位置。 举个例子，我这里创建了两个快捷方式，一个是输入<code>pln</code>就会在编辑器中插入<code>fmt.Println()</code>代码；输入<code>plf</code>，就会插入<code>fmt.Printf(&quot;&quot;)</code>代码。</p>

<pre><code class="language-json">{
	&quot;println&quot;:{
		&quot;prefix&quot;: &quot;pln&quot;,
		&quot;body&quot;:&quot;fmt.Println($0)&quot;,
		&quot;description&quot;: &quot;println&quot;
	},
	&quot;printf&quot;:{
		&quot;prefix&quot;: &quot;plf&quot;,
		&quot;body&quot;: &quot;fmt.Printf(\&quot;$0\&quot;)&quot;,
		&quot;description&quot;: &quot;printf&quot;
	}
}
</code></pre>

<p>把上面的代码，按下图方式粘贴到配置文件中，保存并关闭配置文件即可。<img src="/resources/技术收录/golang/vscode20.png" alt="vscode20" />添加如上配置后，保存。 我们打开一个go文件，测试一下效果：<img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/vscode21.gif" alt="demo1" /></p>

<h2 id="go语言之依赖管理">Go语言之依赖管理</h2>

<p>Go语言的依赖管理随着版本的更迭正逐渐完善起来。</p>

<h2 id="依赖管理">依赖管理</h2>

<h3 id="为什么需要依赖管理">为什么需要依赖管理</h3>

<p>最早的时候，Go所依赖的所有的第三方库都放在GOPATH这个目录下面。这就导致了同一个库只能保存一个版本的代码。如果不同的项目依赖同一个第三方的库的不同版本，应该怎么解决？</p>

<h4 id="godep">godep</h4>

<p>Go语言从v1.5开始开始引入<code>vendor</code>模式，如果项目目录下有vendor目录，那么go工具链会优先使用<code>vendor</code>内的包进行编译、测试等。</p>

<p><code>godep</code>是一个通过vender模式实现的Go语言的第三方依赖管理工具，类似的还有由社区维护准官方包管理工具<code>dep</code>。</p>

<h4 id="安装-1">安装</h4>

<p>执行以下命令安装<code>godep</code>工具。</p>

<pre><code class="language-go">go get github.com/tools/godep
</code></pre>

<h4 id="基本命令">基本命令</h4>

<p>安装好godep之后，在终端输入<code>godep</code>查看支持的所有命令。</p>

<pre><code class="language-bash">godep save     将依赖项输出并复制到Godeps.json文件中
godep go       使用保存的依赖项运行go工具
godep get      下载并安装具有指定依赖项的包
godep path     打印依赖的GOPATH路径
godep restore  在GOPATH中拉取依赖的版本
godep update   更新选定的包或go版本
godep diff     显示当前和以前保存的依赖项集之间的差异
godep version  查看版本信息
</code></pre>

<p>使用<code>godep help [command]</code>可以看看具体命令的帮助信息。</p>

<h4 id="使用godep">使用godep</h4>

<p>在项目目录下执行<code>godep save</code>命令，会在当前项目中创建<code>Godeps</code>和<code>vender</code>两个文件夹。</p>

<p>其中<code>Godeps</code>文件夹下有一个<code>Godeps.json</code>的文件，里面记录了项目所依赖的包信息。 <code>vender</code>文件夹下是项目依赖的包的源代码文件。</p>

<h4 id="vender机制">vender机制</h4>

<p>Go1.5版本之后开始支持，能够控制Go语言程序编译时依赖包搜索路径的优先级。</p>

<p>例如查找项目的某个依赖包，首先会在项目根目录下的<code>vender</code>文件夹中查找，如果没有找到就会去<code>$GOAPTH/src</code>目录下查找。</p>

<h4 id="godep开发流程">godep开发流程</h4>

<ol>
<li>保证程序能够正常编译</li>
<li>执行<code>godep save</code>保存当前项目的所有第三方依赖的版本信息和代码</li>
<li>提交Godeps目录和vender目录到代码库。</li>
<li>如果要更新依赖的版本，可以直接修改<code>Godeps.json</code>文件中的对应项</li>
</ol>

<h3 id="go-module">go module</h3>

<p><code>go module</code>是Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，<code>go module</code>将是Go语言默认的依赖管理工具。</p>

<h4 id="go111module">GO111MODULE</h4>

<p>要启用<code>go module</code>支持首先要设置环境变量<code>GO111MODULE</code>，通过它可以开启或关闭模块支持，它有三个可选值：<code>off</code>、<code>on</code>、<code>auto</code>，默认值是<code>auto</code>。</p>

<ol>
<li><code>GO111MODULE=off</code>禁用模块支持，编译时会从<code>GOPATH</code>和<code>vendor</code>文件夹中查找包。</li>
<li><code>GO111MODULE=on</code>启用模块支持，编译时会忽略<code>GOPATH</code>和<code>vendor</code>文件夹，只根据 <code>go.mod</code>下载依赖。</li>
<li><code>GO111MODULE=auto</code>，当项目在<code>$GOPATH/src</code>外且项目根目录有<code>go.mod</code>文件时，开启模块支持。</li>
</ol>

<p>简单来说，设置<code>GO111MODULE=on</code>之后就可以使用<code>go module</code>了，以后就没有必要在GOPATH中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。</p>

<p>使用 go module 管理依赖后会在项目根目录下生成两个文件<code>go.mod</code>和<code>go.sum</code>。</p>

<h4 id="goproxy">GOPROXY</h4>

<p>Go1.11之后设置GOPROXY命令为：</p>

<pre><code class="language-bash">export GOPROXY=https://goproxy.cn
</code></pre>

<p>Go1.13之后<code>GOPROXY</code>默认值为<code>https://proxy.golang.org</code>，在国内是无法访问的，所以十分建议大家设置GOPROXY，这里我推荐使用<a href="https://studygolang.com/topics/10014">goproxy.cn</a>。</p>

<pre><code class="language-bash">go env -w GOPROXY=https://goproxy.cn,direct
</code></pre>

<h4 id="go-mod命令">go mod命令</h4>

<p>常用的<code>go mod</code>命令如下：</p>

<pre><code>go mod download    下载依赖的module到本地cache（默认为$GOPATH/pkg/mod目录）
go mod edit        编辑go.mod文件
go mod graph       打印模块依赖图
go mod init        初始化当前文件夹, 创建go.mod文件
go mod tidy        增加缺少的module，删除无用的module
go mod vendor      将依赖复制到vendor下
go mod verify      校验依赖
go mod why         解释为什么需要依赖
</code></pre>

<h4 id="go-mod">go.mod</h4>

<p>go.mod文件记录了项目所有的依赖信息，其结构大致如下：</p>

<pre><code class="language-sh">module github.com/Q1mi/studygo/blogger

go 1.12

require (
	github.com/DeanThompson/ginpprof v0.0.0-20190408063150-3be636683586
	github.com/gin-gonic/gin v1.4.0
	github.com/go-sql-driver/mysql v1.4.1
	github.com/jmoiron/sqlx v1.2.0
	github.com/satori/go.uuid v1.2.0
	google.golang.org/appengine v1.6.1 // indirect
)
</code></pre>

<p>其中，</p>

<ul>
<li><code>module</code>用来定义包名</li>
<li><code>require</code>用来定义依赖包及版本</li>
<li><code>indirect</code>表示间接引用</li>
</ul>

<h5 id="依赖的版本">依赖的版本</h5>

<p>go mod支持语义化版本号，比如<code>go get foo@v1.2.3</code>，也可以跟git的分支或tag，比如<code>go get foo@master</code>，当然也可以跟git提交哈希，比如<code>go get foo@e3702bed2</code>。关于依赖的版本支持以下几种格式：</p>

<pre><code class="language-go">gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7
gopkg.in/vmihailenco/msgpack.v2 v2.9.1
gopkg.in/yaml.v2 &lt;=v2.2.1
github.com/tatsushid/go-fastping v0.0.0-20160109021039-d7bb493dee3e
latest
</code></pre>

<h5 id="replace">replace</h5>

<p>在国内访问golang.org/x的各个包都需要翻墙，你可以在go.mod中使用replace替换成github上对应的库。</p>

<pre><code class="language-go">replace (
	golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac =&gt; github.com/golang/crypto v0.0.0-20180820150726-614d502a4dac
	golang.org/x/net v0.0.0-20180821023952-922f4815f713 =&gt; github.com/golang/net v0.0.0-20180826012351-8a410e7b638d
	golang.org/x/text v0.3.0 =&gt; github.com/golang/text v0.3.0
)
</code></pre>

<h5 id="go-get">go get</h5>

<p>在项目中执行<code>go get</code>命令可以下载依赖包，并且还可以指定下载的版本。</p>

<ol>
<li>运行<code>go get -u</code>将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</li>
<li>运行<code>go get -u=patch</code>将会升级到最新的修订版本</li>
<li>运行<code>go get package@version</code>将会升级到指定的版本号version</li>
</ol>

<p>如果下载所有依赖可以使用<code>go mod download</code>命令。</p>

<h5 id="整理依赖">整理依赖</h5>

<p>我们在代码中删除依赖代码后，相关的依赖库并不会在<code>go.mod</code>文件中自动移除。这种情况下我们可以使用<code>go mod tidy</code>命令更新<code>go.mod</code>中的依赖关系。</p>

<h4 id="go-mod-edit">go mod edit</h4>

<h5 id="格式化">格式化</h5>

<p>因为我们可以手动修改go.mod文件，所以有些时候需要格式化该文件。Go提供了一下命令：</p>

<pre><code class="language-bash">go mod edit -fmt
</code></pre>

<h5 id="添加依赖项">添加依赖项</h5>

<pre><code class="language-bash">go mod edit -require=golang.org/x/text
</code></pre>

<h5 id="移除依赖项">移除依赖项</h5>

<p>如果只是想修改<code>go.mod</code>文件中的内容，那么可以运行<code>go mod edit -droprequire=package path</code>，比如要在<code>go.mod</code>中移除<code>golang.org/x/text</code>包，可以使用如下命令：</p>

<pre><code class="language-bash">go mod edit -droprequire=golang.org/x/text
</code></pre>

<p>关于<code>go mod edit</code>的更多用法可以通过<code>go help mod edit</code>查看。</p>

<h2 id="在项目中使用go-module">在项目中使用go module</h2>

<h3 id="既有项目">既有项目</h3>

<p>如果需要对一个已经存在的项目启用<code>go module</code>，可以按照以下步骤操作：</p>

<ol>
<li>在项目目录下执行<code>go mod init</code>，生成一个<code>go.mod</code>文件。</li>
<li>执行<code>go get</code>，查找并记录当前项目的依赖，同时生成一个<code>go.sum</code>记录每个依赖库的版本和哈希值。</li>
</ol>

<h3 id="新项目">新项目</h3>

<p>对于一个新创建的项目，我们可以在项目文件夹下按照以下步骤操作：</p>

<ol>
<li>执行<code>go mod init 项目名</code>命令，在当前项目文件夹下创建一个<code>go.mod</code>文件。</li>
<li>手动编辑<code>go.mod</code>中的require依赖项或执行<code>go get</code>自动发现、维护依赖。</li>
</ol>

<h2 id="如何使用go-module导入本地包">如何使用go module导入本地包</h2>

<p><code>go module</code>是Go1.11版本之后官方推出的版本管理工具，并且从<code>Go1.13</code>版本开始，<code>go module</code>将是Go语言默认的依赖管理工具。到今天<code>Go1.14</code>版本推出之后<code>Go modules</code> 功能已经被正式推荐在生产环境下使用了。</p>

<p>这几天已经有很多教程讲解如何使用<code>go module</code>，以及如何使用<code>go module</code>导入gitlab私有仓库，我这里就不再啰嗦了。但是最近我发现很多小伙伴在群里问如何使用<code>go module</code>导入本地包，作为初学者大家刚开始接触package的时候肯定都是先在本地创建一个包，然后本地调用一下，然后就被卡住了。。。</p>

<p>这里就详细介绍下如何使用<code>go module</code>导入本地包。</p>

<h3 id="前提">前提</h3>

<p>假设我们现在有<code>moduledemo</code>和<code>mypackage</code>两个包，其中<code>moduledemo</code>包中会导入<code>mypackage</code>包并使用它的<code>New</code>方法。</p>

<p><code>mypackage/mypackage.go</code>内容如下：</p>

<pre><code class="language-go">package mypackage

import &quot;fmt&quot;

func New(){
	fmt.Println(&quot;mypackage.New&quot;)
}
</code></pre>

<p>我们现在分两种情况讨论：</p>

<h3 id="在同一个项目下">在同一个项目下</h3>

<p><strong>注意</strong>：在一个项目（project）下我们是可以定义多个包（package）的。</p>

<h4 id="目录结构">目录结构</h4>

<p>现在的情况是，我们在<code>moduledemo/main.go</code>中调用了<code>mypackage</code>这个包。</p>

<pre><code class="language-bash">moduledemo
├── go.mod
├── main.go
└── mypackage
    └── mypackage.go
</code></pre>

<h4 id="导入包">导入包</h4>

<p>这个时候，我们需要在<code>moduledemo/go.mod</code>中按如下定义：</p>

<pre><code class="language-go">module moduledemo

go 1.14
</code></pre>

<p>然后在<code>moduledemo/main.go</code>中按如下方式导入<code>mypackage</code></p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;moduledemo/mypackage&quot;  // 导入同一项目下的mypackage包
)
func main() {
	mypackage.New()
	fmt.Println(&quot;main&quot;)
}
</code></pre>

<h4 id="举个例子">举个例子</h4>

<p>举一反三，假设我们现在有文件目录结构如下：</p>

<pre><code class="language-bash">└── bubble
    ├── dao
    │   └── mysql.go
    ├── go.mod
    └── main.go
</code></pre>

<p>其中<code>bubble/go.mod</code>内容如下：</p>

<pre><code class="language-go">module github.com/q1mi/bubble

go 1.14
</code></pre>

<p><code>bubble/dao/mysql.go</code>内容如下：</p>

<pre><code class="language-go">package dao

import &quot;fmt&quot;

func New(){
	fmt.Println(&quot;mypackage.New&quot;)
}
</code></pre>

<p><code>bubble/main.go</code>内容如下：</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;github.com/q1mi/bubble/dao&quot;
)
func main() {
	dao.New()
	fmt.Println(&quot;main&quot;)
}
</code></pre>

<h3 id="不在同一个项目下">不在同一个项目下</h3>

<h4 id="目录结构-1">目录结构</h4>

<pre><code class="language-bash">├── moduledemo
│   ├── go.mod
│   └── main.go
└── mypackage
    ├── go.mod
    └── mypackage.go
</code></pre>

<h4 id="导入包-1">导入包</h4>

<p>这个时候，<code>mypackage</code>也需要进行module初始化，即拥有一个属于自己的<code>go.mod</code>文件，内容如下：</p>

<pre><code class="language-go">module mypackage

go 1.14
</code></pre>

<p>然后我们在<code>moduledemo/main.go</code>中按如下方式导入：</p>

<pre><code class="language-go">import (
	&quot;fmt&quot;
	&quot;mypackage&quot;
)
func main() {
	mypackage.New()
	fmt.Println(&quot;main&quot;)
}
</code></pre>

<p>因为这两个包不在同一个项目路径下，你想要导入本地包，并且这些包也没有发布到远程的github或其他代码仓库地址。这个时候我们就需要在<code>go.mod</code>文件中使用<code>replace</code>指令。</p>

<p>在调用方也就是<code>moduledemo/go.mod</code>中按如下方式指定使用相对路径来寻找<code>mypackage</code>这个包。</p>

<pre><code class="language-go">module moduledemo

go 1.14


require &quot;mypackage&quot; v0.0.0
replace &quot;mypackage&quot; =&gt; &quot;../mypackage&quot;
</code></pre>

<h4 id="举个例子-1">举个例子</h4>

<p>最后我们再举个例子巩固下上面的内容。</p>

<p>我们现在有文件目录结构如下：</p>

<pre><code class="language-bash">├── p1
│   ├── go.mod
│   └── main.go
└── p2
    ├── go.mod
    └── p2.go
</code></pre>

<p><code>p1/main.go</code>中想要导入<code>p2.go</code>中定义的函数。</p>

<p><code>p2/go.mod</code>内容如下：</p>

<pre><code class="language-go">module liwenzhou.com/q1mi/p2

go 1.14
</code></pre>

<p><code>p1/main.go</code>中按如下方式导入</p>

<pre><code class="language-go">import (
	&quot;fmt&quot;
	&quot;liwenzhou.com/q1mi/p2&quot;
)
func main() {
	p2.New()
	fmt.Println(&quot;main&quot;)
}
</code></pre>

<p>因为我并没有把<code>liwenzhou.com/q1mi/p2</code>这个包上传到<code>liwenzhou.com</code>这个网站，我们只是想导入本地的包，这个时候就需要用到<code>replace</code>这个指令了。</p>

<p><code>p1/go.mod</code>内容如下：</p>

<pre><code class="language-go">module github.com/q1mi/p1

go 1.14


require &quot;liwenzhou.com/q1mi/p2&quot; v0.0.0
replace &quot;liwenzhou.com/q1mi/p2&quot; =&gt; &quot;../p2&quot;
</code></pre>

<p>此时，我们就可以正常编译<code>p1</code>这个项目了。</p>

<p>说再多也没用，自己动手试试吧。</p>

<h1 id="go语言基础">Go语言基础</h1>

<h2 id="go语言基础之变量和常量">Go语言基础之变量和常量</h2>

<p>变量和常量是编程中必不可少的部分，也是很好理解的一部分。</p>

<h3 id="标识符与关键字">标识符与关键字</h3>

<h4 id="标识符">标识符</h4>

<p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头。 举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code>。</p>

<h4 id="关键字">关键字</h4>

<p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。</p>

<p>Go语言中有25个关键字：</p>

<pre><code class="language-go">    break        default      func         interface    select
    case         defer        go           map          struct
    chan         else         goto         package      switch
    const        fallthrough  if           range        type
    continue     for          import       return       var
</code></pre>

<p>此外，Go语言中还有37个保留字。</p>

<pre><code class="language-go">    Constants:    true  false  iota  nil

        Types:    int  int8  int16  int32  int64  
                  uint  uint8  uint16  uint32  uint64  uintptr
                  float32  float64  complex128  complex64
                  bool  byte  rune  string  error

    Functions:   make  len  cap  new  append  copy  close  delete
                 complex  real  imag
                 panic  recover
</code></pre>

<h3 id="变量">变量</h3>

<h4 id="变量的来历">变量的来历</h4>

<p>程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。</p>

<h4 id="变量类型">变量类型</h4>

<p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。</p>

<p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p>

<h4 id="变量声明">变量声明</h4>

<p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。</p>

<h5 id="标准声明">标准声明</h5>

<p>Go语言的变量声明格式为：</p>

<pre><code class="language-go">var 变量名 变量类型
</code></pre>

<p>变量声明以关键字<code>var</code>开头，变量类型放在变量的后面，行尾无需分号。 举个例子：</p>

<pre><code class="language-go">var name string
var age int
var isOk bool
</code></pre>

<h5 id="批量声明">批量声明</h5>

<p>每声明一个变量就需要写<code>var</code>关键字会比较繁琐，go语言中还支持批量变量声明：</p>

<pre><code class="language-go">var (
    a string
    b int
    c bool
    d float32
)
</code></pre>

<h5 id="变量的初始化">变量的初始化</h5>

<p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为<code>0</code>。 字符串变量的默认值为<code>空字符串</code>。 布尔型变量默认为<code>false</code>。 切片、函数、指针变量的默认为<code>nil</code>。</p>

<p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p>

<pre><code class="language-go">var 变量名 类型 = 表达式
</code></pre>

<p>举个例子：</p>

<pre><code class="language-go">var name string = &quot;Q1mi&quot;
var age int = 18
</code></pre>

<p>或者一次初始化多个变量</p>

<pre><code class="language-go">var name, age = &quot;Q1mi&quot;, 20
</code></pre>

<h5 id="类型推导">类型推导</h5>

<p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p>

<pre><code class="language-go">var name = &quot;Q1mi&quot;
var age = 18
</code></pre>

<h5 id="短变量声明">短变量声明</h5>

<p>在函数内部，可以使用更简略的 <code>:=</code> 方式声明并初始化变量。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)
// 全局变量m
var m = 100

func main() {
	n := 10
	m := 200 // 此处声明局部变量m
	fmt.Println(m, n)
}
</code></pre>

<h5 id="匿名变量">匿名变量</h5>

<p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code>表示，例如：</p>

<pre><code class="language-go">func foo() (int, string) {
	return 10, &quot;Q1mi&quot;
}
func main() {
	x, _ := foo()
	_, y := foo()
	fmt.Println(&quot;x=&quot;, x)
	fmt.Println(&quot;y=&quot;, y)
}
</code></pre>

<p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在<code>Lua</code>等编程语言里，匿名变量也被叫做哑元变量。)</p>

<p>注意事项：</p>

<ol>
<li>函数外的每个语句都必须以关键字开始（var、const、func等）</li>
<li><code>:=</code>不能使用在函数外。</li>
<li><code>_</code>多用于占位，表示忽略值。</li>
</ol>

<h2 id="常量">常量</h2>

<p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p>

<pre><code class="language-go">const pi = 3.1415
const e = 2.7182
</code></pre>

<p>声明了<code>pi</code>和<code>e</code>这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p>

<p>多个常量也可以一起声明：</p>

<pre><code class="language-go">const (
    pi = 3.1415
    e = 2.7182
)
</code></pre>

<p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p>

<pre><code class="language-go">const (
    n1 = 100
    n2
    n3
)
</code></pre>

<p>上面示例中，常量<code>n1</code>、<code>n2</code>、<code>n3</code>的值都是100。</p>

<h3 id="iota">iota</h3>

<p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p>

<p><code>iota</code>在const关键字出现时将被重置为0。const中每新增一行常量声明将使<code>iota</code>计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p>

<p>举个例子：</p>

<pre><code class="language-go">const (
		n1 = iota //0
		n2        //1
		n3        //2
		n4        //3
	)
</code></pre>

<h4 id="几个常见的-iota-示例">几个常见的<code>iota</code>示例:</h4>

<p>使用<code>_</code>跳过某些值</p>

<pre><code class="language-go">const (
		n1 = iota //0
		n2        //1
		_
		n4        //3
	)
</code></pre>

<p><code>iota</code>声明中间插队</p>

<pre><code class="language-go">const (
		n1 = iota //0
		n2 = 100  //100
		n3 = iota //2
		n4        //3
	)
	const n5 = iota //0
</code></pre>

<p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p>

<pre><code class="language-go">const (
		_  = iota
		KB = 1 &lt;&lt; (10 * iota)
		MB = 1 &lt;&lt; (10 * iota)
		GB = 1 &lt;&lt; (10 * iota)
		TB = 1 &lt;&lt; (10 * iota)
		PB = 1 &lt;&lt; (10 * iota)
	)
</code></pre>

<p>多个<code>iota</code>定义在一行</p>

<pre><code class="language-go">const (
		a, b = iota + 1, iota + 2 //1,2
		c, d                      //2,3
		e, f                      //3,4
	)
</code></pre>

<h2 id="go语言基础之基本数据类型">Go语言基础之基本数据类型</h2>

<p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</p>

<h2 id="基本数据类型">基本数据类型</h2>

<h3 id="整型">整型</h3>

<p>整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64</p>

<p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型，<code>int16</code>对应C语言中的<code>short</code>型，<code>int64</code>对应C语言中的<code>long</code>型。</p>

<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">uint8</td>
<td align="center">无符号 8位整型 (0 到 255)</td>
</tr>

<tr>
<td align="center">uint16</td>
<td align="center">无符号 16位整型 (0 到 65535)</td>
</tr>

<tr>
<td align="center">uint32</td>
<td align="center">无符号 32位整型 (0 到 4294967295)</td>
</tr>

<tr>
<td align="center">uint64</td>
<td align="center">无符号 64位整型 (0 到 18446744073709551615)</td>
</tr>

<tr>
<td align="center">int8</td>
<td align="center">有符号 8位整型 (-128 到 127)</td>
</tr>

<tr>
<td align="center">int16</td>
<td align="center">有符号 16位整型 (-32768 到 32767)</td>
</tr>

<tr>
<td align="center">int32</td>
<td align="center">有符号 32位整型 (-2147483648 到 2147483647)</td>
</tr>

<tr>
<td align="center">int64</td>
<td align="center">有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td>
</tr>
</tbody>
</table>

<h4 id="特殊整型">特殊整型</h4>

<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">uint</td>
<td align="center">32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td>
</tr>

<tr>
<td align="center">int</td>
<td align="center">32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td>
</tr>

<tr>
<td align="center">uintptr</td>
<td align="center">无符号整型，用于存放一个指针</td>
</tr>
</tbody>
</table>

<p><strong>注意：</strong> 在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平台上的差异。</p>

<p><strong>注意事项</strong> 获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p>

<h4 id="数字字面量语法-number-literals-syntax">数字字面量语法（Number literals syntax）</h4>

<p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p>

<p><code>v := 0b00101101</code>， 代表二进制的 101101，相当于十进制的 45。 <code>v := 0o377</code>，代表八进制的 377，相当于十进制的 255。 <code>v := 0x1p-2</code>，代表十六进制的 1 除以 2²，也就是 0.25。</p>

<p>而且还允许我们用 <code>_</code> 来分隔数字，比如说： <code>v := 123_456</code> 表示 v 的值等于 123456。</p>

<p>我们可以借助fmt函数来将一个整数以不同进制形式展示。</p>

<pre><code class="language-go">package main
 
import &quot;fmt&quot;
 
func main(){
	// 十进制
	var a int = 10
	fmt.Printf(&quot;%d \n&quot;, a)  // 10
	fmt.Printf(&quot;%b \n&quot;, a)  // 1010  占位符%b表示二进制
 
	// 八进制  以0开头
	var b int = 077
	fmt.Printf(&quot;%o \n&quot;, b)  // 77
 
	// 十六进制  以0x开头
	var c int = 0xff
	fmt.Printf(&quot;%x \n&quot;, c)  // ff
	fmt.Printf(&quot;%X \n&quot;, c)  // FF
}
</code></pre>

<h3 id="浮点型">浮点型</h3>

<p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code>标准： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p>

<p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p>

<pre><code class="language-go">package main
import (
        &quot;fmt&quot;
        &quot;math&quot;
)
func main() {
        fmt.Printf(&quot;%f\n&quot;, math.Pi)
        fmt.Printf(&quot;%.2f\n&quot;, math.Pi)
}
</code></pre>

<h3 id="复数">复数</h3>

<p>complex64和complex128</p>

<pre><code class="language-go">var c1 complex64
c1 = 1 + 2i
var c2 complex128
c2 = 2 + 3i
fmt.Println(c1)
fmt.Println(c2)
</code></pre>

<p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p>

<h3 id="布尔值">布尔值</h3>

<p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p>

<p><strong>注意：</strong></p>

<ol>
<li>布尔类型变量的默认值为<code>false</code>。</li>
<li>Go 语言中不允许将整型强制转换为布尔型.</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li>
</ol>

<h3 id="字符串">字符串</h3>

<p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码。 字符串的值为<code>双引号(&quot;)</code>中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p>

<pre><code class="language-go">s1 := &quot;hello&quot;
s2 := &quot;你好&quot;
</code></pre>

<h4 id="字符串转义符">字符串转义符</h4>

<p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p>

<table>
<thead>
<tr>
<th align="center">转义符</th>
<th align="center">含义</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><code>\r</code></td>
<td align="center">回车符（返回行首）</td>
</tr>

<tr>
<td align="center"><code>\n</code></td>
<td align="center">换行符（直接跳到下一行的同列位置）</td>
</tr>

<tr>
<td align="center"><code>\t</code></td>
<td align="center">制表符</td>
</tr>

<tr>
<td align="center"><code>\'</code></td>
<td align="center">单引号</td>
</tr>

<tr>
<td align="center"><code>\&quot;</code></td>
<td align="center">双引号</td>
</tr>

<tr>
<td align="center"><code>\\</code></td>
<td align="center">反斜杠</td>
</tr>
</tbody>
</table>

<p>举个例子，我们要打印一个Windows平台下的一个文件路径：</p>

<pre><code class="language-go">package main
import (
    &quot;fmt&quot;
)
func main() {
    fmt.Println(&quot;str := \&quot;c:\\Code\\lesson1\\go.exe\&quot;&quot;)
}
</code></pre>

<h4 id="多行字符串">多行字符串</h4>

<p>Go语言中要定义一个多行字符串时，就必须使用<code>反引号</code>字符：</p>

<pre><code class="language-go">s1 := `第一行
第二行
第三行
`
fmt.Println(s1)
</code></pre>

<p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p>

<h4 id="字符串的常用操作">字符串的常用操作</h4>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">介绍</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">len(str)</td>
<td align="center">求长度</td>
</tr>

<tr>
<td align="center">+或fmt.Sprintf</td>
<td align="center">拼接字符串</td>
</tr>

<tr>
<td align="center">strings.Split</td>
<td align="center">分割</td>
</tr>

<tr>
<td align="center">strings.contains</td>
<td align="center">判断是否包含</td>
</tr>

<tr>
<td align="center">strings.HasPrefix,strings.HasSuffix</td>
<td align="center">前缀/后缀判断</td>
</tr>

<tr>
<td align="center">strings.Index(),strings.LastIndex()</td>
<td align="center">子串出现的位置</td>
</tr>

<tr>
<td align="center">strings.Join(a[]string, sep string)</td>
<td align="center">join操作</td>
</tr>
</tbody>
</table>

<h3 id="byte和rune类型">byte和rune类型</h3>

<p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p>

<pre><code class="language-go">var a = '中'
var b = 'x'
</code></pre>

<p>Go 语言的字符有以下两种：</p>

<ol>
<li><code>uint8</code>类型，或者叫 byte 型，代表一个<code>ASCII码</code>字符。</li>
<li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li>
</ol>

<p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p>

<p>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p>

<pre><code class="language-go">// 遍历字符串
func traversalString() {
	s := &quot;hello沙河&quot;
	for i := 0; i &lt; len(s); i++ { //byte
		fmt.Printf(&quot;%v(%c) &quot;, s[i], s[i])
	}
	fmt.Println()
	for _, r := range s { //rune
		fmt.Printf(&quot;%v(%c) &quot;, r, r)
	}
	fmt.Println()
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) 
104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河) 
</code></pre>

<p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p>

<p>字符串底层是一个byte数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p>

<h4 id="修改字符串">修改字符串</h4>

<p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p>

<pre><code class="language-go">func changeString() {
	s1 := &quot;big&quot;
	// 强制类型转换
	byteS1 := []byte(s1)
	byteS1[0] = 'p'
	fmt.Println(string(byteS1))

	s2 := &quot;白萝卜&quot;
	runeS2 := []rune(s2)
	runeS2[0] = '红'
	fmt.Println(string(runeS2))
}
</code></pre>

<h3 id="类型转换">类型转换</h3>

<p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p>

<p>强制类型转换的基本语法如下：</p>

<pre><code class="language-bash">T(表达式)
</code></pre>

<p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p>

<p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p>

<pre><code class="language-go">func sqrtDemo() {
	var a, b = 3, 4
	var c int
	// math.Sqrt()接收的参数是float64类型，需要强制转换
	c = int(math.Sqrt(float64(a*a + b*b)))
	fmt.Println(c)
}
</code></pre>

<h4 id="练习题">练习题</h4>

<ol>
<li>编写代码分别定义一个整型、浮点型、布尔型、字符串型变量，使用<code>fmt.Printf()</code>搭配<code>%T</code>分别打印出上述变量的值和类型。</li>
<li>编写代码统计出字符串<code>&quot;hello沙河小王子&quot;</code>中汉字的数量。</li>
</ol>

<h2 id="go语言基础之运算符">Go语言基础之运算符</h2>

<p>运算符用于在程序运行时执行数学或逻辑运算。</p>

<h2 id="运算符">运算符</h2>

<p>Go 语言内置的运算符有：</p>

<ol>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
</ol>

<h3 id="算术运算符">算术运算符</h3>

<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">+</td>
<td align="center">相加</td>
</tr>

<tr>
<td align="center">-</td>
<td align="center">相减</td>
</tr>

<tr>
<td align="center">*</td>
<td align="center">相乘</td>
</tr>

<tr>
<td align="center">/</td>
<td align="center">相除</td>
</tr>

<tr>
<td align="center">%</td>
<td align="center">求余</td>
</tr>
</tbody>
</table>

<p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p>

<h3 id="关系运算符">关系运算符</h3>

<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">==</td>
<td align="center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td>
</tr>

<tr>
<td align="center">!=</td>
<td align="center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td>
</tr>

<tr>
<td align="center">&gt;</td>
<td align="center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td>
</tr>

<tr>
<td align="center">&gt;=</td>
<td align="center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>

<tr>
<td align="center">&lt;</td>
<td align="center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td>
</tr>

<tr>
<td align="center">&lt;=</td>
<td align="center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
</tbody>
</table>

<h3 id="逻辑运算符">逻辑运算符</h3>

<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">&amp;&amp;</td>
<td align="center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td>
</tr>

<tr>
<td align="center">||</td>
<td align="center">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td>
</tr>

<tr>
<td align="center">!</td>
<td align="center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td>
</tr>
</tbody>
</table>

<h3 id="位运算符">位运算符</h3>

<p>位运算符对整数在内存中的二进制位进行操作。</p>

<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">&amp;</td>
<td align="center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td>
</tr>

<tr>
<td align="center">|</td>
<td align="center">参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td>
</tr>

<tr>
<td align="center">^</td>
<td align="center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td>
</tr>

<tr>
<td align="center">&lt;&lt;</td>
<td align="center">左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td>
</tr>

<tr>
<td align="center">&gt;&gt;</td>
<td align="center">右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td>
</tr>
</tbody>
</table>

<h3 id="赋值运算符">赋值运算符</h3>

<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">=</td>
<td align="center">简单的赋值运算符，将一个表达式的值赋给一个左值</td>
</tr>

<tr>
<td align="center">+=</td>
<td align="center">相加后再赋值</td>
</tr>

<tr>
<td align="center">-=</td>
<td align="center">相减后再赋值</td>
</tr>

<tr>
<td align="center">*=</td>
<td align="center">相乘后再赋值</td>
</tr>

<tr>
<td align="center">/=</td>
<td align="center">相除后再赋值</td>
</tr>

<tr>
<td align="center">%=</td>
<td align="center">求余后再赋值</td>
</tr>

<tr>
<td align="center">&lt;&lt;=</td>
<td align="center">左移后赋值</td>
</tr>

<tr>
<td align="center">&gt;&gt;=</td>
<td align="center">右移后赋值</td>
</tr>

<tr>
<td align="center">&amp;=</td>
<td align="center">按位与后赋值</td>
</tr>

<tr>
<td align="center">|=</td>
<td align="center">按位或后赋值</td>
</tr>

<tr>
<td align="center">^=</td>
<td align="center">按位异或后赋值</td>
</tr>
</tbody>
</table>

<h4 id="练习题-1">练习题</h4>

<p>有一堆数字，如果除了一个数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？</p>

<h2 id="go语言基础之流程控制">Go语言基础之流程控制</h2>

<p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。</p>

<p>Go语言中最常用的流程控制有<code>if</code>和<code>for</code>，而<code>switch</code>和<code>goto</code>主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>

<h3 id="if-else-分支结构">if else(分支结构)</h3>

<h4 id="if条件判断基本写法">if条件判断基本写法</h4>

<p>Go语言中<code>if</code>条件判断的格式如下：</p>

<pre><code class="language-go">if 表达式1 {
    分支1
} else if 表达式2 {
    分支2
} else{
    分支3
}
</code></pre>

<p>当表达式1的结果为<code>true</code>时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 if判断中的<code>else if</code>和<code>else</code>都是可选的，可以根据实际需要进行选择。</p>

<p>Go语言规定与<code>if</code>匹配的左括号<code>{</code>必须与<code>if和表达式</code>放在同一行，<code>{</code>放在其他位置会触发编译错误。 同理，与<code>else</code>匹配的<code>{</code>也必须与<code>else</code>写在同一行，<code>else</code>也必须与上一个<code>if</code>或<code>else if</code>右边的大括号在同一行。</p>

<p>举个例子：</p>

<pre><code class="language-go">func ifDemo1() {
	score := 65
	if score &gt;= 90 {
		fmt.Println(&quot;A&quot;)
	} else if score &gt; 75 {
		fmt.Println(&quot;B&quot;)
	} else {
		fmt.Println(&quot;C&quot;)
	}
}
</code></pre>

<h4 id="if条件判断特殊写法">if条件判断特殊写法</h4>

<p>if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：</p>

<pre><code class="language-go">func ifDemo2() {
	if score := 65; score &gt;= 90 {
		fmt.Println(&quot;A&quot;)
	} else if score &gt; 75 {
		fmt.Println(&quot;B&quot;)
	} else {
		fmt.Println(&quot;C&quot;)
	}
}
</code></pre>

<p><strong>思考题：</strong> 上下两种写法的区别在哪里？</p>

<h3 id="for-循环结构">for(循环结构)</h3>

<p>Go 语言中的所有循环类型均可以使用<code>for</code>关键字来完成。</p>

<p>for循环的基本格式如下：</p>

<pre><code class="language-bash">for 初始语句;条件表达式;结束语句{
    循环体语句
}
</code></pre>

<p>条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p>

<pre><code class="language-go">func forDemo() {
	for i := 0; i &lt; 10; i++ {
		fmt.Println(i)
	}
}
</code></pre>

<p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p>

<pre><code class="language-go">func forDemo2() {
	i := 0
	for ; i &lt; 10; i++ {
		fmt.Println(i)
	}
}
</code></pre>

<p>for循环的初始语句和结束语句都可以省略，例如：</p>

<pre><code class="language-go">func forDemo3() {
	i := 0
	for i &lt; 10 {
		fmt.Println(i)
		i++
	}
}
</code></pre>

<p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p>

<h4 id="无限循环">无限循环</h4>

<pre><code class="language-go">for {
    循环体语句
}
</code></pre>

<p>for循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code>语句强制退出循环。</p>

<h3 id="for-range-键值循环">for range(键值循环)</h3>

<p>Go语言中可以使用<code>for range</code>遍历数组、切片、字符串、map 及通道（channel）。 通过<code>for range</code>遍历的返回值有以下规律：</p>

<ol>
<li>数组、切片、字符串返回索引和值。</li>
<li>map返回键和值。</li>
<li>通道（channel）只返回通道内的值。</li>
</ol>

<h3 id="switch-case">switch case</h3>

<p>使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p>

<pre><code class="language-go">func switchDemo1() {
	finger := 3
	switch finger {
	case 1:
		fmt.Println(&quot;大拇指&quot;)
	case 2:
		fmt.Println(&quot;食指&quot;)
	case 3:
		fmt.Println(&quot;中指&quot;)
	case 4:
		fmt.Println(&quot;无名指&quot;)
	case 5:
		fmt.Println(&quot;小拇指&quot;)
	default:
		fmt.Println(&quot;无效的输入！&quot;)
	}
}
</code></pre>

<p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p>

<p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p>

<pre><code class="language-go">func testSwitch3() {
	switch n := 7; n {
	case 1, 3, 5, 7, 9:
		fmt.Println(&quot;奇数&quot;)
	case 2, 4, 6, 8:
		fmt.Println(&quot;偶数&quot;)
	default:
		fmt.Println(n)
	}
}
</code></pre>

<p>分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p>

<pre><code class="language-go">func switchDemo4() {
	age := 30
	switch {
	case age &lt; 25:
		fmt.Println(&quot;好好学习吧&quot;)
	case age &gt; 25 &amp;&amp; age &lt; 35:
		fmt.Println(&quot;好好工作吧&quot;)
	case age &gt; 60:
		fmt.Println(&quot;好好享受吧&quot;)
	default:
		fmt.Println(&quot;活着真好&quot;)
	}
}
</code></pre>

<p><code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p>

<pre><code class="language-go">func switchDemo5() {
	s := &quot;a&quot;
	switch {
	case s == &quot;a&quot;:
		fmt.Println(&quot;a&quot;)
		fallthrough
	case s == &quot;b&quot;:
		fmt.Println(&quot;b&quot;)
	case s == &quot;c&quot;:
		fmt.Println(&quot;c&quot;)
	default:
		fmt.Println(&quot;...&quot;)
	}
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">a
b
</code></pre>

<h3 id="goto-跳转到指定标签">goto(跳转到指定标签)</h3>

<p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：</p>

<pre><code class="language-go">func gotoDemo1() {
	var breakFlag bool
	for i := 0; i &lt; 10; i++ {
		for j := 0; j &lt; 10; j++ {
			if j == 2 {
				// 设置退出标签
				breakFlag = true
				break
			}
			fmt.Printf(&quot;%v-%v\n&quot;, i, j)
		}
		// 外层for循环判断
		if breakFlag {
			break
		}
	}
}
</code></pre>

<p>使用<code>goto</code>语句能简化代码：</p>

<pre><code class="language-go">func gotoDemo2() {
	for i := 0; i &lt; 10; i++ {
		for j := 0; j &lt; 10; j++ {
			if j == 2 {
				// 设置退出标签
				goto breakTag
			}
			fmt.Printf(&quot;%v-%v\n&quot;, i, j)
		}
	}
	return
	// 标签
breakTag:
	fmt.Println(&quot;结束for循环&quot;)
}
</code></pre>

<h3 id="break-跳出循环">break(跳出循环)</h3>

<p><code>break</code>语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>的代码块。</p>

<p><code>break</code>语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和 <code>select</code>的代码块上。 举个例子：</p>

<pre><code class="language-go">func breakDemo1() {
BREAKDEMO1:
	for i := 0; i &lt; 10; i++ {
		for j := 0; j &lt; 10; j++ {
			if j == 2 {
				break BREAKDEMO1
			}
			fmt.Printf(&quot;%v-%v\n&quot;, i, j)
		}
	}
	fmt.Println(&quot;...&quot;)
}
</code></pre>

<h3 id="continue-继续下次循环">continue(继续下次循环)</h3>

<p><code>continue</code>语句可以结束当前循环，开始下一次的循环迭代过程，仅限在<code>for</code>循环内使用。</p>

<p>在 <code>continue</code>语句后添加标签时，表示开始标签对应的循环。例如：</p>

<pre><code class="language-go">func continueDemo() {
forloop1:
	for i := 0; i &lt; 5; i++ {
		// forloop2:
		for j := 0; j &lt; 5; j++ {
			if i == 2 &amp;&amp; j == 2 {
				continue forloop1
			}
			fmt.Printf(&quot;%v-%v\n&quot;, i, j)
		}
	}
}
</code></pre>

<h4 id="练习题-2">练习题</h4>

<ol>
<li>编写代码打印9*9乘法表。</li>
</ol>

<h2 id="go语言基础之数组">Go语言基础之数组</h2>

<p>本文主要介绍Go语言中数组（array）及它的基本使用。</p>

<h2 id="array-数组">Array(数组)</h2>

<p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p>

<pre><code class="language-go">// 定义一个长度为3元素类型为int的数组a
var a [3]int
</code></pre>

<h3 id="数组定义">数组定义：</h3>

<pre><code class="language-bash">var 数组变量名 [元素数量]T
</code></pre>

<p>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 <code>[5]int</code>和<code>[10]int</code>是不同的类型。</p>

<pre><code class="language-go">var a [3]int
var b [4]int
a = b //不可以这样做，因为此时a和b是不同的类型
</code></pre>

<p>数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p>

<h3 id="数组的初始化">数组的初始化</h3>

<p>数组的初始化也有很多方式。</p>

<h4 id="方法一">方法一</h4>

<p>初始化数组时可以使用初始化列表来设置数组元素的值。</p>

<pre><code class="language-go">func main() {
	var testArray [3]int                        //数组会初始化为int类型的零值
	var numArray = [3]int{1, 2}                 //使用指定的初始值完成初始化
	var cityArray = [3]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;} //使用指定的初始值完成初始化
	fmt.Println(testArray)                      //[0 0 0]
	fmt.Println(numArray)                       //[1 2 0]
	fmt.Println(cityArray)                      //[北京 上海 深圳]
}
</code></pre>

<h4 id="方法二">方法二</h4>

<p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p>

<pre><code class="language-go">func main() {
	var testArray [3]int
	var numArray = [...]int{1, 2}
	var cityArray = [...]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;}
	fmt.Println(testArray)                          //[0 0 0]
	fmt.Println(numArray)                           //[1 2]
	fmt.Printf(&quot;type of numArray:%T\n&quot;, numArray)   //type of numArray:[2]int
	fmt.Println(cityArray)                          //[北京 上海 深圳]
	fmt.Printf(&quot;type of cityArray:%T\n&quot;, cityArray) //type of cityArray:[3]string
}
</code></pre>

<h4 id="方法三">方法三</h4>

<p>我们还可以使用指定索引值的方式来初始化数组，例如:</p>

<pre><code class="language-go">func main() {
	a := [...]int{1: 1, 3: 5}
	fmt.Println(a)                  // [0 1 0 5]
	fmt.Printf(&quot;type of a:%T\n&quot;, a) //type of a:[4]int
}
</code></pre>

<h3 id="数组的遍历">数组的遍历</h3>

<p>遍历数组a有以下两种方法：</p>

<pre><code class="language-go">func main() {
	var a = [...]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;}
	// 方法1：for循环遍历
	for i := 0; i &lt; len(a); i++ {
		fmt.Println(a[i])
	}

	// 方法2：for range遍历
	for index, value := range a {
		fmt.Println(index, value)
	}
}
</code></pre>

<h3 id="多维数组">多维数组</h3>

<p>Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。</p>

<h4 id="二维数组的定义">二维数组的定义</h4>

<pre><code class="language-go">func main() {
	a := [3][2]string{
		{&quot;北京&quot;, &quot;上海&quot;},
		{&quot;广州&quot;, &quot;深圳&quot;},
		{&quot;成都&quot;, &quot;重庆&quot;},
	}
	fmt.Println(a) //[[北京 上海] [广州 深圳] [成都 重庆]]
	fmt.Println(a[2][1]) //支持索引取值:重庆
}
</code></pre>

<h4 id="二维数组的遍历">二维数组的遍历</h4>

<pre><code class="language-go">func main() {
	a := [3][2]string{
		{&quot;北京&quot;, &quot;上海&quot;},
		{&quot;广州&quot;, &quot;深圳&quot;},
		{&quot;成都&quot;, &quot;重庆&quot;},
	}
	for _, v1 := range a {
		for _, v2 := range v1 {
			fmt.Printf(&quot;%s\t&quot;, v2)
		}
		fmt.Println()
	}
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">北京	上海	
广州	深圳	
成都	重庆	
</code></pre>

<p><strong>注意：</strong> 多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。例如：</p>

<pre><code class="language-go">//支持的写法
a := [...][2]string{
	{&quot;北京&quot;, &quot;上海&quot;},
	{&quot;广州&quot;, &quot;深圳&quot;},
	{&quot;成都&quot;, &quot;重庆&quot;},
}
//不支持多维数组的内层使用...
b := [3][...]string{
	{&quot;北京&quot;, &quot;上海&quot;},
	{&quot;广州&quot;, &quot;深圳&quot;},
	{&quot;成都&quot;, &quot;重庆&quot;},
}
</code></pre>

<h3 id="数组是值类型">数组是值类型</h3>

<p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p>

<pre><code class="language-go">func modifyArray(x [3]int) {
	x[0] = 100
}

func modifyArray2(x [3][2]int) {
	x[2][0] = 100
}
func main() {
	a := [3]int{10, 20, 30}
	modifyArray(a) //在modify中修改的是a的副本x
	fmt.Println(a) //[10 20 30]
	b := [3][2]int{
		{1, 1},
		{1, 1},
		{1, 1},
	}
	modifyArray2(b) //在modify中修改的是b的副本x
	fmt.Println(b)  //[[1 1] [1 1] [1 1]]
}
</code></pre>

<p><strong>注意：</strong></p>

<ol>
<li>数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。</li>
<li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 。</li>
</ol>

<h3 id="练习题-3">练习题</h3>

<ol>
<li>求数组<code>[1, 3, 5, 7, 8]</code>所有元素的和</li>
<li>找出数组中和为指定值的两个元素的下标，比如从数组<code>[1, 3, 5, 7, 8]</code>中找出和为8的两个元素的下标分别为<code>(0,3)</code>和<code>(1,2)</code>。</li>
</ol>

<h2 id="go语言基础之切片">Go语言基础之切片</h2>

<p>本文主要介绍Go语言中切片（slice）及它的基本使用。</p>

<h2 id="引子">引子</h2>

<p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p>

<pre><code class="language-go">func arraySum(x [3]int) int{
    sum := 0
    for _, v := range x{
        sum = sum + v
    }
    return sum
}
</code></pre>

<p>这个求和函数只能接受<code>[3]int</code>类型，其他的都不支持。 再比如，</p>

<pre><code class="language-go">a := [3]int{1, 2, 3}
</code></pre>

<p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。</p>

<h2 id="切片">切片</h2>

<p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p>

<p>切片是一个引用类型，它的内部结构包含<code>地址</code>、<code>长度</code>和<code>容量</code>。切片一般用于快速地操作一块数据集合。</p>

<h3 id="切片的定义">切片的定义</h3>

<p>声明切片类型的基本语法如下：</p>

<pre><code class="language-go">var name []T
</code></pre>

<p>其中，</p>

<ul>
<li>name:表示变量名</li>
<li>T:表示切片中的元素类型</li>
</ul>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	// 声明切片类型
	var a []string              //声明一个字符串切片
	var b = []int{}             //声明一个整型切片并初始化
	var c = []bool{false, true} //声明一个布尔切片并初始化
	var d = []bool{false, true} //声明一个布尔切片并初始化
	fmt.Println(a)              //[]
	fmt.Println(b)              //[]
	fmt.Println(c)              //[false true]
	fmt.Println(a == nil)       //true
	fmt.Println(b == nil)       //false
	fmt.Println(c == nil)       //false
	// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较
}
</code></pre>

<h4 id="切片的长度和容量">切片的长度和容量</h4>

<p>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</p>

<h4 id="切片表达式">切片表达式</h4>

<p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p>

<h5 id="简单切片表达式">简单切片表达式</h5>

<p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的<code>low</code>和<code>high</code>表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出<code>1&lt;=索引值&lt;4</code>的元素组成切片s，得到的切片<code>长度=high-low</code>，容量等于得到的切片的底层数组的容量。</p>

<pre><code class="language-go">func main() {
	a := [5]int{1, 2, 3, 4, 5}
	s := a[1:3]  // s := a[low:high]
	fmt.Printf(&quot;s:%v len(s):%v cap(s):%v\n&quot;, s, len(s), cap(s))
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">s:[2 3] len(s):2 cap(s):4
</code></pre>

<p>为了方便起见，可以省略切片表达式中的任何索引。省略了<code>low</code>则默认为0；省略了<code>high</code>则默认为切片操作数的长度:</p>

<pre><code class="language-go">a[2:]  // 等同于 a[2:len(a)]
a[:3]  // 等同于 a[0:3]
a[:]   // 等同于 a[0:len(a)]
</code></pre>

<p><strong>注意：</strong></p>

<p>对于数组或字符串，如果<code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界（out of range）。</p>

<p>对切片再执行切片表达式时（切片再切片），<code>high</code>的上限边界是切片的容量<code>cap(a)</code>，而不是长度。<strong>常量索引</strong>必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果<code>low</code>和<code>high</code>两个指标都是常数，它们必须满足<code>low &lt;= high</code>。如果索引在运行时超出范围，就会发生运行时<code>panic</code>。</p>

<pre><code class="language-go">func main() {
	a := [5]int{1, 2, 3, 4, 5}
	s := a[1:3]  // s := a[low:high]
	fmt.Printf(&quot;s:%v len(s):%v cap(s):%v\n&quot;, s, len(s), cap(s))
	s2 := s[3:4]  // 索引的上限是cap(s)而不是len(s)
	fmt.Printf(&quot;s2:%v len(s2):%v cap(s2):%v\n&quot;, s2, len(s2), cap(s2))
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">s:[2 3] len(s):2 cap(s):4
s2:[5] len(s2):1 cap(s2):1
</code></pre>

<h5 id="完整切片表达式">完整切片表达式</h5>

<p>对于数组，指向数组的指针，或切片a(<strong>注意不能是字符串</strong>)支持完整切片表达式：</p>

<pre><code class="language-go">a[low : high : max]
</code></pre>

<p>上面的代码会构造与简单切片表达式<code>a[low: high]</code>相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为<code>max-low</code>。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。</p>

<pre><code class="language-go">func main() {
	a := [5]int{1, 2, 3, 4, 5}
	t := a[1:3:5]
	fmt.Printf(&quot;t:%v len(t):%v cap(t):%v\n&quot;, t, len(t), cap(t))
}
</code></pre>

<p>输出结果：</p>

<pre><code class="language-bash">t:[2 3] len(t):2 cap(t):4
</code></pre>

<p>完整切片表达式需要满足的条件是<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>，其他条件和简单切片表达式相同。</p>

<h4 id="使用make-函数构造切片">使用make()函数构造切片</h4>

<p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p>

<pre><code class="language-bash">make([]T, size, cap)
</code></pre>

<p>其中：</p>

<ul>
<li>T:切片的元素类型</li>
<li>size:切片中元素的数量</li>
<li>cap:切片的容量</li>
</ul>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	a := make([]int, 2, 10)
	fmt.Println(a)      //[0 0]
	fmt.Println(len(a)) //2
	fmt.Println(cap(a)) //10
}
</code></pre>

<p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p>

<h4 id="切片的本质">切片的本质</h4>

<p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p>

<p>举个例子，现在有一个数组<code>a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。<img src="/resources/技术收录/golang/slice_01.png" alt="slice_01" />切片<code>s2 := a[3:6]</code>，相应示意图如下：<img src="/resources/技术收录/golang/slice_02.png" alt="slice_02" /></p>

<h4 id="判断切片是否为空">判断切片是否为空</h4>

<p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p>

<h3 id="切片不能直接比较">切片不能直接比较</h3>

<p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p>

<pre><code class="language-go">var s1 []int         //len(s1)=0;cap(s1)=0;s1==nil
s2 := []int{}        //len(s2)=0;cap(s2)=0;s2!=nil
s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil
</code></pre>

<p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p>

<h3 id="切片的赋值拷贝">切片的赋值拷贝</h3>

<p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p>

<pre><code class="language-go">func main() {
	s1 := make([]int, 3) //[0 0 0]
	s2 := s1             //将s1直接赋值给s2，s1和s2共用一个底层数组
	s2[0] = 100
	fmt.Println(s1) //[100 0 0]
	fmt.Println(s2) //[100 0 0]
}
</code></pre>

<h3 id="切片遍历">切片遍历</h3>

<p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p>

<pre><code class="language-go">func main() {
	s := []int{1, 3, 5}

	for i := 0; i &lt; len(s); i++ {
		fmt.Println(i, s[i])
	}

	for index, value := range s {
		fmt.Println(index, value)
	}
}
</code></pre>

<h3 id="append-方法为切片添加元素">append()方法为切片添加元素</h3>

<p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p>

<pre><code class="language-go">func main(){
	var s []int
	s = append(s, 1)        // [1]
	s = append(s, 2, 3, 4)  // [1 2 3 4]
	s2 := []int{5, 6, 7}  
	s = append(s, s2...)    // [1 2 3 4 5 6 7]
}
</code></pre>

<p><strong>注意：</strong>通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p>

<pre><code class="language-go">var s []int
s = append(s, 1, 2, 3)
</code></pre>

<p>没有必要像下面的代码一样初始化一个切片再传入<code>append()</code>函数使用，</p>

<pre><code class="language-go">s := []int{}  // 没有必要初始化
s = append(s, 1, 2, 3)

var s = make([]int)  // 没有必要初始化
s = append(s, 1, 2, 3)
</code></pre>

<p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	//append()添加元素和切片扩容
	var numSlice []int
	for i := 0; i &lt; 10; i++ {
		numSlice = append(numSlice, i)
		fmt.Printf(&quot;%v  len:%d  cap:%d  ptr:%p\n&quot;, numSlice, len(numSlice), cap(numSlice), numSlice)
	}
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">[0]  len:1  cap:1  ptr:0xc0000a8000
[0 1]  len:2  cap:2  ptr:0xc0000a8040
[0 1 2]  len:3  cap:4  ptr:0xc0000b2020
[0 1 2 3]  len:4  cap:4  ptr:0xc0000b2020
[0 1 2 3 4]  len:5  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5]  len:6  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6]  len:7  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6 7]  len:8  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6 7 8]  len:9  cap:16  ptr:0xc0000b8000
[0 1 2 3 4 5 6 7 8 9]  len:10  cap:16  ptr:0xc0000b8000
</code></pre>

<p>从上面的结果可以看出：</p>

<ol>
<li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li>
<li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li>
</ol>

<p>append()函数还支持一次性追加多个元素。 例如：</p>

<pre><code class="language-go">var citySlice []string
// 追加一个元素
citySlice = append(citySlice, &quot;北京&quot;)
// 追加多个元素
citySlice = append(citySlice, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;)
// 追加切片
a := []string{&quot;成都&quot;, &quot;重庆&quot;}
citySlice = append(citySlice, a...)
fmt.Println(citySlice) //[北京 上海 广州 深圳 成都 重庆]
</code></pre>

<h3 id="切片的扩容策略">切片的扩容策略</h3>

<p>可以通过查看<code>$GOROOT/src/runtime/slice.go</code>源码，其中扩容相关代码如下：</p>

<pre><code class="language-go">newcap := old.cap
doublecap := newcap + newcap
if cap &gt; doublecap {
	newcap = cap
} else {
	if old.len &lt; 1024 {
		newcap = doublecap
	} else {
		// Check 0 &lt; newcap to detect overflow
		// and prevent an infinite loop.
		for 0 &lt; newcap &amp;&amp; newcap &lt; cap {
			newcap += newcap / 4
		}
		// Set newcap to the requested cap when
		// the newcap calculation overflowed.
		if newcap &lt;= 0 {
			newcap = cap
		}
	}
}
</code></pre>

<p>从上面的代码可以看出以下内容：</p>

<ul>
<li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），</li>
<li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li>
</ul>

<p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</p>

<h3 id="使用copy-函数复制切片">使用copy()函数复制切片</h3>

<p>首先我们来看一个问题：</p>

<pre><code class="language-go">func main() {
	a := []int{1, 2, 3, 4, 5}
	b := a
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(b) //[1 2 3 4 5]
	b[0] = 1000
	fmt.Println(a) //[1000 2 3 4 5]
	fmt.Println(b) //[1000 2 3 4 5]
}
</code></pre>

<p>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</p>

<p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p>

<pre><code class="language-bash">copy(destSlice, srcSlice []T)
</code></pre>

<p>其中：</p>

<ul>
<li>srcSlice: 数据来源切片</li>
<li>destSlice: 目标切片</li>
</ul>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	// copy()复制切片
	a := []int{1, 2, 3, 4, 5}
	c := make([]int, 5, 5)
	copy(c, a)     //使用copy()函数将切片a中的元素复制到切片c
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1 2 3 4 5]
	c[0] = 1000
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1000 2 3 4 5]
}
</code></pre>

<h3 id="从切片中删除元素">从切片中删除元素</h3>

<p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p>

<pre><code class="language-go">func main() {
	// 从切片中删除元素
	a := []int{30, 31, 32, 33, 34, 35, 36, 37}
	// 要删除索引为2的元素
	a = append(a[:2], a[3:]...)
	fmt.Println(a) //[30 31 33 34 35 36 37]
}
</code></pre>

<p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p>

<h3 id="练习题-4">练习题</h3>

<p>1.请写出下面代码的输出结果。</p>

<pre><code class="language-go">func main() {
	var a = make([]string, 5, 10)
	for i := 0; i &lt; 10; i++ {
		a = append(a, fmt.Sprintf(&quot;%v&quot;, i))
	}
	fmt.Println(a)
}
</code></pre>

<p>2.请使用内置的<code>sort</code>包对数组<code>var a = [...]int{3, 7, 8, 9, 1}</code>进行排序（附加题，自行查资料解答）。</p>

<h2 id="go语言基础之map">Go语言基础之map</h2>

<p>Go语言中提供的映射关系容器为<code>map</code>，其内部使用<code>散列表（hash）</code>实现。</p>

<h2 id="map">map</h2>

<p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p>

<h3 id="map定义">map定义</h3>

<p>Go语言中 <code>map</code>的定义语法如下：</p>

<pre><code class="language-go">map[KeyType]ValueType
</code></pre>

<p>其中，</p>

<ul>
<li>KeyType:表示键的类型。</li>
<li>ValueType:表示键对应的值的类型。</li>
</ul>

<p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p>

<pre><code class="language-go">make(map[KeyType]ValueType, [cap])
</code></pre>

<p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p>

<h3 id="map基本使用">map基本使用</h3>

<p>map中的数据都是成对出现的，map的基本使用示例代码如下：</p>

<pre><code class="language-go">func main() {
	scoreMap := make(map[string]int, 8)
	scoreMap[&quot;张三&quot;] = 90
	scoreMap[&quot;小明&quot;] = 100
	fmt.Println(scoreMap)
	fmt.Println(scoreMap[&quot;小明&quot;])
	fmt.Printf(&quot;type of a:%T\n&quot;, scoreMap)
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">map[小明:100 张三:90]
100
type of a:map[string]int
</code></pre>

<p>map也支持在声明的时候填充元素，例如：</p>

<pre><code class="language-go">func main() {
	userInfo := map[string]string{
		&quot;username&quot;: &quot;沙河小王子&quot;,
		&quot;password&quot;: &quot;123456&quot;,
	}
	fmt.Println(userInfo) //
}
</code></pre>

<h3 id="判断某个键是否存在">判断某个键是否存在</h3>

<p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p>

<pre><code class="language-go">value, ok := map[key]
</code></pre>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	scoreMap := make(map[string]int)
	scoreMap[&quot;张三&quot;] = 90
	scoreMap[&quot;小明&quot;] = 100
	// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值
	v, ok := scoreMap[&quot;张三&quot;]
	if ok {
		fmt.Println(v)
	} else {
		fmt.Println(&quot;查无此人&quot;)
	}
}
</code></pre>

<h3 id="map的遍历">map的遍历</h3>

<p>Go语言中使用<code>for range</code>遍历map。</p>

<pre><code class="language-go">func main() {
	scoreMap := make(map[string]int)
	scoreMap[&quot;张三&quot;] = 90
	scoreMap[&quot;小明&quot;] = 100
	scoreMap[&quot;娜扎&quot;] = 60
	for k, v := range scoreMap {
		fmt.Println(k, v)
	}
}
</code></pre>

<p>但我们只想遍历key的时候，可以按下面的写法：</p>

<pre><code class="language-go">func main() {
	scoreMap := make(map[string]int)
	scoreMap[&quot;张三&quot;] = 90
	scoreMap[&quot;小明&quot;] = 100
	scoreMap[&quot;娜扎&quot;] = 60
	for k := range scoreMap {
		fmt.Println(k)
	}
}
</code></pre>

<p><strong>注意：</strong> 遍历map时的元素顺序与添加键值对的顺序无关。</p>

<h3 id="使用delete-函数删除键值对">使用delete()函数删除键值对</h3>

<p>使用<code>delete()</code>内建函数从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p>

<pre><code class="language-go">delete(map, key)
</code></pre>

<p>其中，</p>

<ul>
<li>map:表示要删除键值对的map</li>
<li>key:表示要删除的键值对的键</li>
</ul>

<p>示例代码如下：</p>

<pre><code class="language-go">func main(){
	scoreMap := make(map[string]int)
	scoreMap[&quot;张三&quot;] = 90
	scoreMap[&quot;小明&quot;] = 100
	scoreMap[&quot;娜扎&quot;] = 60
	delete(scoreMap, &quot;小明&quot;)//将小明:100从map中删除
	for k,v := range scoreMap{
		fmt.Println(k, v)
	}
}
</code></pre>

<h3 id="按照指定顺序遍历map">按照指定顺序遍历map</h3>

<pre><code class="language-go">func main() {
	rand.Seed(time.Now().UnixNano()) //初始化随机数种子

	var scoreMap = make(map[string]int, 200)

	for i := 0; i &lt; 100; i++ {
		key := fmt.Sprintf(&quot;stu%02d&quot;, i) //生成stu开头的字符串
		value := rand.Intn(100)          //生成0~99的随机整数
		scoreMap[key] = value
	}
	//取出map中的所有key存入切片keys
	var keys = make([]string, 0, 200)
	for key := range scoreMap {
		keys = append(keys, key)
	}
	//对切片进行排序
	sort.Strings(keys)
	//按照排序后的key遍历map
	for _, key := range keys {
		fmt.Println(key, scoreMap[key])
	}
}
</code></pre>

<h3 id="元素为map类型的切片">元素为map类型的切片</h3>

<p>下面的代码演示了切片中的元素为map类型时的操作：</p>

<pre><code class="language-go">func main() {
	var mapSlice = make([]map[string]string, 3)
	for index, value := range mapSlice {
		fmt.Printf(&quot;index:%d value:%v\n&quot;, index, value)
	}
	fmt.Println(&quot;after init&quot;)
	// 对切片中的map元素进行初始化
	mapSlice[0] = make(map[string]string, 10)
	mapSlice[0][&quot;name&quot;] = &quot;小王子&quot;
	mapSlice[0][&quot;password&quot;] = &quot;123456&quot;
	mapSlice[0][&quot;address&quot;] = &quot;沙河&quot;
	for index, value := range mapSlice {
		fmt.Printf(&quot;index:%d value:%v\n&quot;, index, value)
	}
}
</code></pre>

<h3 id="值为切片类型的map">值为切片类型的map</h3>

<p>下面的代码演示了map中值为切片类型的操作：</p>

<pre><code class="language-go">func main() {
	var sliceMap = make(map[string][]string, 3)
	fmt.Println(sliceMap)
	fmt.Println(&quot;after init&quot;)
	key := &quot;中国&quot;
	value, ok := sliceMap[key]
	if !ok {
		value = make([]string, 0, 2)
	}
	value = append(value, &quot;北京&quot;, &quot;上海&quot;)
	sliceMap[key] = value
	fmt.Println(sliceMap)
}
</code></pre>

<h2 id="练习题-5">练习题</h2>

<ol>
<li>写一个程序，统计一个字符串中每个单词出现的次数。比如：”how do you do”中how=1 do=2 you=1。</li>

<li><p>观察下面代码，写出最终的打印结果。</p>

<pre><code class="language-go">func main() {
	type Map map[string][]int
	m := make(Map)
	s := []int{1, 2}
	s = append(s, 3)
	fmt.Printf(&quot;%+v\n&quot;, s)
	m[&quot;q1mi&quot;] = s
	s = append(s[:1], s[2:]...)
	fmt.Printf(&quot;%+v\n&quot;, s)
	fmt.Printf(&quot;%+v\n&quot;, m[&quot;q1mi&quot;])
}
</code></pre></li>
</ol>

<h2 id="go语言基础之函数">Go语言基础之函数</h2>

<p>函数是组织好的、可重复使用的、用于执行指定任务的代码块。本文介绍了Go语言中函数的相关内容。</p>

<h2 id="函数">函数</h2>

<p>Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”。</p>

<h3 id="函数定义">函数定义</h3>

<p>Go语言中定义函数使用<code>func</code>关键字，具体格式如下：</p>

<pre><code class="language-go">func 函数名(参数)(返回值){
    函数体
}
</code></pre>

<p>其中：</p>

<ul>
<li>函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名（包的概念详见后文）。</li>
<li>参数：参数由参数变量和参数变量的类型组成，多个参数之间使用<code>,</code>分隔。</li>
<li>返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用<code>()</code>包裹，并用<code>,</code>分隔。</li>
<li>函数体：实现指定功能的代码块。</li>
</ul>

<p>我们先来定义一个求两个数之和的函数：</p>

<pre><code class="language-go">func intSum(x int, y int) int {
	return x + y
}
</code></pre>

<p>函数的参数和返回值都是可选的，例如我们可以实现一个既不需要参数也没有返回值的函数：</p>

<pre><code class="language-go">func sayHello() {
	fmt.Println(&quot;Hello 沙河&quot;)
}
</code></pre>

<h3 id="函数的调用">函数的调用</h3>

<p>定义了函数之后，我们可以通过<code>函数名()</code>的方式调用函数。 例如我们调用上面定义的两个函数，代码如下：</p>

<pre><code class="language-go">func main() {
	sayHello()
	ret := intSum(10, 20)
	fmt.Println(ret)
}
</code></pre>

<p>注意，调用有返回值的函数时，可以不接收其返回值。</p>

<h3 id="参数">参数</h3>

<h4 id="类型简写">类型简写</h4>

<p>函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：</p>

<pre><code class="language-go">func intSum(x, y int) int {
	return x + y
}
</code></pre>

<p>上面的代码中，<code>intSum</code>函数有两个参数，这两个参数的类型均为<code>int</code>，因此可以省略<code>x</code>的类型，因为<code>y</code>后面有类型说明，<code>x</code>参数也是该类型。</p>

<h4 id="可变参数">可变参数</h4>

<p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加<code>...</code>来标识。</p>

<p>注意：可变参数通常要作为函数的最后一个参数。</p>

<p>举个例子：</p>

<pre><code class="language-go">func intSum2(x ...int) int {
	fmt.Println(x) //x是一个切片
	sum := 0
	for _, v := range x {
		sum = sum + v
	}
	return sum
}
</code></pre>

<p>调用上面的函数：</p>

<pre><code class="language-go">ret1 := intSum2()
ret2 := intSum2(10)
ret3 := intSum2(10, 20)
ret4 := intSum2(10, 20, 30)
fmt.Println(ret1, ret2, ret3, ret4) //0 10 30 60
</code></pre>

<p>固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下：</p>

<pre><code class="language-go">func intSum3(x int, y ...int) int {
	fmt.Println(x, y)
	sum := x
	for _, v := range y {
		sum = sum + v
	}
	return sum
}
</code></pre>

<p>调用上述函数：</p>

<pre><code class="language-go">ret5 := intSum3(100)
ret6 := intSum3(100, 10)
ret7 := intSum3(100, 10, 20)
ret8 := intSum3(100, 10, 20, 30)
fmt.Println(ret5, ret6, ret7, ret8) //100 110 130 160
</code></pre>

<p>本质上，函数的可变参数是通过切片来实现的。</p>

<h3 id="返回值">返回值</h3>

<p>Go语言中通过<code>return</code>关键字向外输出返回值。</p>

<h4 id="多返回值">多返回值</h4>

<p>Go语言中函数支持多返回值，函数如果有多个返回值时必须用<code>()</code>将所有返回值包裹起来。</p>

<p>举个例子：</p>

<pre><code class="language-go">func calc(x, y int) (int, int) {
	sum := x + y
	sub := x - y
	return sum, sub
}
</code></pre>

<h4 id="返回值命名">返回值命名</h4>

<p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。</p>

<p>例如：</p>

<pre><code class="language-go">func calc(x, y int) (sum, sub int) {
	sum = x + y
	sub = x - y
	return
}
</code></pre>

<h4 id="返回值补充">返回值补充</h4>

<p>当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。</p>

<pre><code class="language-go">func someFunc(x string) []int {
	if x == &quot;&quot; {
		return nil // 没必要返回[]int{}
	}
	...
}
</code></pre>

<h2 id="函数进阶">函数进阶</h2>

<h3 id="变量作用域">变量作用域</h3>

<h4 id="全局变量">全局变量</h4>

<p>全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

//定义全局变量num
var num int64 = 10

func testGlobalVar() {
	fmt.Printf(&quot;num=%d\n&quot;, num) //函数中可以访问全局变量num
}
func main() {
	testGlobalVar() //num=10
}
</code></pre>

<h4 id="局部变量">局部变量</h4>

<p>局部变量又分为两种： 函数内定义的变量无法在该函数外使用，例如下面的示例代码main函数中无法使用testLocalVar函数中定义的变量x：</p>

<pre><code class="language-go">func testLocalVar() {
	//定义一个函数局部变量x,仅在该函数内生效
	var x int64 = 100
	fmt.Printf(&quot;x=%d\n&quot;, x)
}

func main() {
	testLocalVar()
	fmt.Println(x) // 此时无法使用变量x
}
</code></pre>

<p>如果局部变量和全局变量重名，优先访问局部变量。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

//定义全局变量num
var num int64 = 10

func testNum() {
	num := 100
	fmt.Printf(&quot;num=%d\n&quot;, num) // 函数中优先使用局部变量
}
func main() {
	testNum() // num=100
}
</code></pre>

<p>接下来我们来看一下语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式。</p>

<pre><code class="language-go">func testLocalVar2(x, y int) {
	fmt.Println(x, y) //函数的参数也是只在本函数中生效
	if x &gt; 0 {
		z := 100 //变量z只在if语句块生效
		fmt.Println(z)
	}
	//fmt.Println(z)//此处无法使用变量z
}
</code></pre>

<p>还有我们之前讲过的for循环语句中定义的变量，也是只在for语句块中生效：</p>

<pre><code class="language-go">func testLocalVar3() {
	for i := 0; i &lt; 10; i++ {
		fmt.Println(i) //变量i只在当前for语句块中生效
	}
	//fmt.Println(i) //此处无法使用变量i
}
</code></pre>

<h3 id="函数类型与变量">函数类型与变量</h3>

<h4 id="定义函数类型">定义函数类型</h4>

<p>我们可以使用<code>type</code>关键字来定义一个函数类型，具体格式如下：</p>

<pre><code class="language-go">type calculation func(int, int) int
</code></pre>

<p>上面语句定义了一个<code>calculation</code>类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p>

<p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p>

<pre><code class="language-go">func add(x, y int) int {
	return x + y
}

func sub(x, y int) int {
	return x - y
}
</code></pre>

<p>add和sub都能赋值给calculation类型的变量。</p>

<pre><code class="language-go">var c calculation
c = add
</code></pre>

<h4 id="函数类型变量">函数类型变量</h4>

<p>我们可以声明函数类型的变量并且为该变量赋值：</p>

<pre><code class="language-go">func main() {
	var c calculation               // 声明一个calculation类型的变量c
	c = add                         // 把add赋值给c
	fmt.Printf(&quot;type of c:%T\n&quot;, c) // type of c:main.calculation
	fmt.Println(c(1, 2))            // 像调用add一样调用c

	f := add                        // 将函数add赋值给变量f
	fmt.Printf(&quot;type of f:%T\n&quot;, f) // type of f:func(int, int) int
	fmt.Println(f(10, 20))          // 像调用add一样调用f
}
</code></pre>

<h3 id="高阶函数">高阶函数</h3>

<p>高阶函数分为函数作为参数和函数作为返回值两部分。</p>

<h4 id="函数作为参数">函数作为参数</h4>

<p>函数可以作为参数：</p>

<pre><code class="language-go">func add(x, y int) int {
	return x + y
}
func calc(x, y int, op func(int, int) int) int {
	return op(x, y)
}
func main() {
	ret2 := calc(10, 20, add)
	fmt.Println(ret2) //30
}
</code></pre>

<h4 id="函数作为返回值">函数作为返回值</h4>

<p>函数也可以作为返回值：</p>

<pre><code class="language-go">func do(s string) (func(int, int) int, error) {
	switch s {
	case &quot;+&quot;:
		return add, nil
	case &quot;-&quot;:
		return sub, nil
	default:
		err := errors.New(&quot;无法识别的操作符&quot;)
		return nil, err
	}
}
</code></pre>

<h3 id="匿名函数和闭包">匿名函数和闭包</h3>

<h4 id="匿名函数">匿名函数</h4>

<p>函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p>

<pre><code class="language-go">func(参数)(返回值){
    函数体
}
</code></pre>

<p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:</p>

<pre><code class="language-go">func main() {
	// 将匿名函数保存到变量
	add := func(x, y int) {
		fmt.Println(x + y)
	}
	add(10, 20) // 通过变量调用匿名函数

	//自执行函数：匿名函数定义完加()直接执行
	func(x, y int) {
		fmt.Println(x + y)
	}(10, 20)
}
</code></pre>

<p>匿名函数多用于实现回调函数和闭包。</p>

<h4 id="闭包">闭包</h4>

<p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，<code>闭包=函数+引用环境</code>。 首先我们来看一个例子：</p>

<pre><code class="language-go">func adder() func(int) int {
	var x int
	return func(y int) int {
		x += y
		return x
	}
}
func main() {
	var f = adder()
	fmt.Println(f(10)) //10
	fmt.Println(f(20)) //30
	fmt.Println(f(30)) //60

	f1 := adder()
	fmt.Println(f1(40)) //40
	fmt.Println(f1(50)) //90
}
</code></pre>

<p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。 闭包进阶示例1：</p>

<pre><code class="language-go">func adder2(x int) func(int) int {
	return func(y int) int {
		x += y
		return x
	}
}
func main() {
	var f = adder2(10)
	fmt.Println(f(10)) //20
	fmt.Println(f(20)) //40
	fmt.Println(f(30)) //70

	f1 := adder2(20)
	fmt.Println(f1(40)) //60
	fmt.Println(f1(50)) //110
}
</code></pre>

<p>闭包进阶示例2：</p>

<pre><code class="language-go">func makeSuffixFunc(suffix string) func(string) string {
	return func(name string) string {
		if !strings.HasSuffix(name, suffix) {
			return name + suffix
		}
		return name
	}
}

func main() {
	jpgFunc := makeSuffixFunc(&quot;.jpg&quot;)
	txtFunc := makeSuffixFunc(&quot;.txt&quot;)
	fmt.Println(jpgFunc(&quot;test&quot;)) //test.jpg
	fmt.Println(txtFunc(&quot;test&quot;)) //test.txt
}
</code></pre>

<p>闭包进阶示例3：</p>

<pre><code class="language-go">func calc(base int) (func(int) int, func(int) int) {
	add := func(i int) int {
		base += i
		return base
	}

	sub := func(i int) int {
		base -= i
		return base
	}
	return add, sub
}

func main() {
	f1, f2 := calc(10)
	fmt.Println(f1(1), f2(2)) //11 9
	fmt.Println(f1(3), f2(4)) //12 8
	fmt.Println(f1(5), f2(6)) //13 7
}
</code></pre>

<p>闭包其实并不复杂，只要牢记<code>闭包=函数+引用环境</code>。</p>

<h3 id="defer语句">defer语句</h3>

<p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	fmt.Println(&quot;start&quot;)
	defer fmt.Println(1)
	defer fmt.Println(2)
	defer fmt.Println(3)
	fmt.Println(&quot;end&quot;)
}
</code></pre>

<p>输出结果：</p>

<pre><code class="language-go">start
end
3
2
1
</code></pre>

<p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p>

<h4 id="defer执行时机">defer执行时机</h4>

<p>在Go语言的函数中<code>return</code>语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而<code>defer</code>语句执行的时机就在返回值赋值操作后，RET指令执行前。具体如下图所示：<img src="/resources/技术收录/golang/defer.png" alt="defer执行时机" /></p>

<h4 id="defer经典案例">defer经典案例</h4>

<p>阅读下面的代码，写出最后的打印结果。</p>

<pre><code class="language-go">func f1() int {
	x := 5
	defer func() {
		x++
	}()
	return x
}

func f2() (x int) {
	defer func() {
		x++
	}()
	return 5
}

func f3() (y int) {
	x := 5
	defer func() {
		x++
	}()
	return x
}
func f4() (x int) {
	defer func(x int) {
		x++
	}(x)
	return 5
}
func main() {
	fmt.Println(f1())
	fmt.Println(f2())
	fmt.Println(f3())
	fmt.Println(f4())
}
</code></pre>

<h4 id="defer面试题">defer面试题</h4>

<pre><code class="language-go">func calc(index string, a, b int) int {
	ret := a + b
	fmt.Println(index, a, b, ret)
	return ret
}

func main() {
	x := 1
	y := 2
	defer calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))
	x = 10
	defer calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))
	y = 20
}
</code></pre>

<p>问，上面代码的输出结果是？（提示：defer注册要延迟执行的函数时该函数所有的参数都需要确定其值）</p>

<h2 id="内置函数介绍">内置函数介绍</h2>

<table>
<thead>
<tr>
<th align="center">内置函数</th>
<th align="center">介绍</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">close</td>
<td align="center">主要用来关闭channel</td>
</tr>

<tr>
<td align="center">len</td>
<td align="center">用来求长度，比如string、array、slice、map、channel</td>
</tr>

<tr>
<td align="center">new</td>
<td align="center">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td>
</tr>

<tr>
<td align="center">make</td>
<td align="center">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td>
</tr>

<tr>
<td align="center">append</td>
<td align="center">用来追加元素到数组、slice中</td>
</tr>

<tr>
<td align="center">panic和recover</td>
<td align="center">用来做错误处理</td>
</tr>
</tbody>
</table>

<h4 id="panic-recover">panic/recover</h4>

<p>Go语言中目前（Go1.12）是没有异常机制，但是使用<code>panic/recover</code>模式来处理错误。 <code>panic</code>可以在任何地方引发，但<code>recover</code>只有在<code>defer</code>调用的函数中有效。 首先来看一个例子：</p>

<pre><code class="language-go">func funcA() {
	fmt.Println(&quot;func A&quot;)
}

func funcB() {
	panic(&quot;panic in B&quot;)
}

func funcC() {
	fmt.Println(&quot;func C&quot;)
}
func main() {
	funcA()
	funcB()
	funcC()
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">func A
panic: panic in B

goroutine 1 [running]:
main.funcB(...)
        .../code/func/main.go:12
main.main()
        .../code/func/main.go:20 +0x98
</code></pre>

<p>程序运行期间<code>funcB</code>中引发了<code>panic</code>导致程序崩溃，异常退出了。这个时候我们就可以通过<code>recover</code>将程序恢复回来，继续往后执行。</p>

<pre><code class="language-go">func funcA() {
	fmt.Println(&quot;func A&quot;)
}

func funcB() {
	defer func() {
		err := recover()
		//如果程序出出现了panic错误,可以通过recover恢复过来
		if err != nil {
			fmt.Println(&quot;recover in B&quot;)
		}
	}()
	panic(&quot;panic in B&quot;)
}

func funcC() {
	fmt.Println(&quot;func C&quot;)
}
func main() {
	funcA()
	funcB()
	funcC()
}
</code></pre>

<p><strong>注意：</strong></p>

<ol>
<li><code>recover()</code>必须搭配<code>defer</code>使用。</li>
<li><code>defer</code>一定要在可能引发<code>panic</code>的语句之前定义。</li>
</ol>

<h2 id="练习题-6">练习题</h2>

<ol>
<li><p>分金币</p>

<pre><code class="language-go">/*
你有50枚金币，需要分配给以下几个人：Matthew,Sarah,Augustus,Heidi,Emilie,Peter,Giana,Adriano,Aaron,Elizabeth。
分配规则如下：
a. 名字中每包含1个'e'或'E'分1枚金币
b. 名字中每包含1个'i'或'I'分2枚金币
c. 名字中每包含1个'o'或'O'分3枚金币
d: 名字中每包含1个'u'或'U'分4枚金币
写一个程序，计算每个用户分到多少金币，以及最后剩余多少金币？
程序结构如下，请实现 ‘dispatchCoin’ 函数
*/
var (
	coins = 50
	users = []string{
		&quot;Matthew&quot;, &quot;Sarah&quot;, &quot;Augustus&quot;, &quot;Heidi&quot;, &quot;Emilie&quot;, &quot;Peter&quot;, &quot;Giana&quot;, &quot;Adriano&quot;, &quot;Aaron&quot;, &quot;Elizabeth&quot;,
	}
	distribution = make(map[string]int, len(users))
)

func main() {
	left := dispatchCoin()
	fmt.Println(&quot;剩下：&quot;, left)
}
</code></pre></li>
</ol>

<h2 id="go语言基础之指针">Go语言基础之指针</h2>

<p>区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。</p>

<p>要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。</p>

<h2 id="go语言中的指针">Go语言中的指针</h2>

<p>任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p>

<p>比如，“永远不要高估自己”这句话是我的座右铭，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），我在程序中把这段话赋值给变量<code>A</code>，把内存地址赋值给变量<code>B</code>。这时候变量<code>B</code>就是一个指针变量。通过变量<code>A</code>和变量<code>B</code>都能找到我的座右铭。</p>

<p>Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：<code>&amp;</code>（取地址）和<code>*</code>（根据地址取值）。</p>

<h3 id="指针地址和指针类型">指针地址和指针类型</h3>

<p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用<code>&amp;</code>字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：<code>*int</code>、<code>*int64</code>、<code>*string</code>等。</p>

<p>取变量指针的语法如下：</p>

<pre><code class="language-go">ptr := &amp;v    // v的类型为T
</code></pre>

<p>其中：</p>

<ul>
<li>v:代表被取地址的变量，类型为<code>T</code></li>
<li>ptr:用于接收地址的变量，ptr的类型就为<code>*T</code>，称做T的指针类型。*代表指针。</li>
</ul>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	a := 10
	b := &amp;a
	fmt.Printf(&quot;a:%d ptr:%p\n&quot;, a, &amp;a) // a:10 ptr:0xc00001a078
	fmt.Printf(&quot;b:%p type:%T\n&quot;, b, b) // b:0xc00001a078 type:*int
	fmt.Println(&amp;b)                    // 0xc00000e018
}
</code></pre>

<p>我们来看一下<code>b := &amp;a</code>的图示：<img src="/resources/技术收录/golang/ptr.png" alt="取变量地址图示" /></p>

<h3 id="指针取值">指针取值</h3>

<p>在对普通变量使用&amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。</p>

<pre><code class="language-go">func main() {
	//指针取值
	a := 10
	b := &amp;a // 取变量a的地址，将指针保存到b中
	fmt.Printf(&quot;type of b:%T\n&quot;, b)
	c := *b // 指针取值（根据指针去内存取值）
	fmt.Printf(&quot;type of c:%T\n&quot;, c)
	fmt.Printf(&quot;value of c:%v\n&quot;, c)
}
</code></pre>

<p>输出如下：</p>

<pre><code class="language-go">type of b:*int
type of c:int
value of c:10
</code></pre>

<p><strong>总结：</strong> 取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</p>

<p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p>

<ul>
<li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li>
<li>指针变量的值是指针地址。</li>
<li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li>
</ul>

<p><strong>指针传值示例：</strong></p>

<pre><code class="language-go">func modify1(x int) {
	x = 100
}

func modify2(x *int) {
	*x = 100
}

func main() {
	a := 10
	modify1(a)
	fmt.Println(a) // 10
	modify2(&amp;a)
	fmt.Println(a) // 100
}
</code></pre>

<h3 id="new和make">new和make</h3>

<p>我们先来看一个例子：</p>

<pre><code class="language-go">func main() {
	var a *int
	*a = 100
	fmt.Println(*a)

	var b map[string]int
	b[&quot;沙河娜扎&quot;] = 100
	fmt.Println(b)
}
</code></pre>

<p>执行上面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。</p>

<h4 id="new">new</h4>

<p>new是一个内置的函数，它的函数签名如下：</p>

<pre><code class="language-go">func new(Type) *Type
</code></pre>

<p>其中，</p>

<ul>
<li>Type表示类型，new函数只接受一个参数，这个参数是一个类型</li>
<li>*Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</li>
</ul>

<p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：</p>

<pre><code class="language-go">func main() {
	a := new(int)
	b := new(bool)
	fmt.Printf(&quot;%T\n&quot;, a) // *int
	fmt.Printf(&quot;%T\n&quot;, b) // *bool
	fmt.Println(*a)       // 0
	fmt.Println(*b)       // false
}	
</code></pre>

<p>本节开始的示例代码中<code>var a *int</code>只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：</p>

<pre><code class="language-go">func main() {
	var a *int
	a = new(int)
	*a = 10
	fmt.Println(*a)
}
</code></pre>

<h4 id="make">make</h4>

<p>make也是用于内存分配的，区别于new，它只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：</p>

<pre><code class="language-go">func make(t Type, size ...IntegerType) Type
</code></pre>

<p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。</p>

<p>本节开始的示例中<code>var b map[string]int</code>只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：</p>

<pre><code class="language-go">func main() {
	var b map[string]int
	b = make(map[string]int, 10)
	b[&quot;沙河娜扎&quot;] = 100
	fmt.Println(b)
}
</code></pre>

<h4 id="new与make的区别">new与make的区别</h4>

<ol>
<li>二者都是用来做内存分配的。</li>
<li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li>
<li>而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li>
</ol>

<h2 id="go语言基础之接口">Go语言基础之接口</h2>

<p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p>

<h2 id="接口">接口</h2>

<p><strong>本章学习目标</strong></p>

<ul>
<li>了解为什么需要接口以及接口的特点</li>
<li>掌握接口的声明和使用</li>
<li>掌握接口值的概念</li>
<li>掌握空接口的特点及其使用场景</li>
</ul>

<p>在Go语言中接口（interface）是一种类型，一种抽象的类型。相较于之前章节中讲到的那些具体类型（字符串、切片、结构体等）更注重“我是谁”，接口类型更注重“我能做什么”的问题。接口类型就像是一种约定——概括了一种类型应该具备哪些方法，在Go语言中提倡使用面向接口的编程方式实现解耦。</p>

<h3 id="接口类型">接口类型</h3>

<p>接口是一种由程序员来定义的类型，一个接口类型就是一组方法的集合，它规定了需要实现的所有方法。</p>

<p>相较于使用结构体类型，当我们使用接口类型说明相比于它是什么更关心它能做什么。</p>

<h4 id="接口的定义">接口的定义</h4>

<p>每个接口类型由任意个方法签名组成，接口的定义格式如下：</p>

<pre><code class="language-go">type 接口类型名 interface{
    方法名1( 参数列表1 ) 返回值列表1
    方法名2( 参数列表2 ) 返回值列表2
    …
}
</code></pre>

<p>其中：</p>

<ul>
<li>接口类型名：Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有关闭操作的接口叫<code>closer</code>等。接口名最好要能突出该接口的类型含义。</li>
<li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li>
<li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li>
</ul>

<p>举个例子，定义一个包含<code>Write</code>方法的<code>Writer</code>接口。</p>

<pre><code class="language-go">type Writer interface{
    Write([]byte) error
}
</code></pre>

<p>当你看到一个<code>Writer</code>接口类型的值时，你不知道它是什么，唯一知道的就是可以通过调用它的<code>Write</code>方法来做一些事情。</p>

<h4 id="实现接口的条件">实现接口的条件</h4>

<p>接口就是规定了一个<strong>需要实现的方法列表</strong>，在 Go 语言中一个类型只要实现了接口中规定的所有方法，那么我们就称它实现了这个接口。</p>

<p>我们定义的<code>Singer</code>接口类型，它包含一个<code>Sing</code>方法。</p>

<pre><code class="language-go">// Singer 接口
type Singer interface {
	Sing()
}
</code></pre>

<p>我们有一个<code>Bird</code>结构体类型如下。</p>

<pre><code class="language-go">type Bird struct {}
</code></pre>

<p>因为<code>Singer</code>接口只包含一个<code>Sing</code>方法，所以只需要给<code>Bird</code>结构体添加一个<code>Sing</code>方法就可以满足<code>Singer</code>接口的要求。</p>

<pre><code class="language-go">// Sing Bird类型的Sing方法
func (b Bird) Sing() {
	fmt.Println(&quot;汪汪汪&quot;)
}
</code></pre>

<p>这样就称为<code>Bird</code>实现了<code>Singer</code>接口。</p>

<h4 id="为什么要使用接口">为什么要使用接口？</h4>

<p>现在假设我们的代码世界里有很多小动物，下面的代码片段定义了猫和狗，它们饿了都会叫。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Cat struct{}

func (c Cat) Say() {
	fmt.Println(&quot;喵喵喵~&quot;)
}

type Dog struct{}

func (d Dog) Say() {
	fmt.Println(&quot;汪汪汪~&quot;)
}

func main() {
	c := Cat{}
	c.Say()
	d := Dog{}
	d.Say()
}
</code></pre>

<p>这个时候又跑来了一只羊，羊饿了也会发出叫声。</p>

<pre><code class="language-go">type Sheep struct{}

func (s Sheep) Say() {
	fmt.Println(&quot;咩咩咩~&quot;)
}
</code></pre>

<p>我们接下来定义一个饿肚子的场景。</p>

<pre><code class="language-go">// MakeCatHungry 猫饿了会喵喵喵~
func MakeCatHungry(c Cat) {
	c.Say()
}

// MakeSheepHungry 羊饿了会咩咩咩~
func MakeSheepHungry(s Sheep) {
	s.Say()
}
</code></pre>

<p>接下来会有越来越多的小动物跑过来，我们的代码世界该怎么拓展呢？</p>

<p>在饿肚子这个场景下，我们可不可以把所有动物都当成一个“会叫的类型”来处理呢？当然可以！使用接口类型就可以实现这个目标。 我们的代码其实并不关心究竟是什么动物在叫，我们只是在代码中调用它的<code>Say()</code>方法，这就足够了。</p>

<p>我们可以约定一个<code>Sayer</code>类型，它必须实现一个<code>Say()</code>方法，只要饿肚子了，我们就调用<code>Say()</code>方法。</p>

<pre><code class="language-go">type Sayer interface {
    Say()
}
</code></pre>

<p>然后我们定义一个通用的<code>MakeHungry</code>函数，接收<code>Sayer</code>类型的参数。</p>

<pre><code class="language-go">// MakeHungry 饿肚子了...
func MakeHungry(s Sayer) {
	s.Say()
}
</code></pre>

<p>我们通过使用接口类型，把所有会叫的动物当成<code>Sayer</code>类型来处理，只要实现了<code>Say()</code>方法都能当成<code>Sayer</code>类型的变量来处理。</p>

<pre><code class="language-go">var c cat
MakeHungry(c)
var d dog
MakeHungry(d)
</code></pre>

<p>在电商系统中我们允许用户使用多种支付方式（支付宝支付、微信支付、银联支付等），我们的交易流程中可能不太在乎用户究竟使用什么支付方式，只要它能提供一个实现支付功能的<code>Pay</code>方法让调用方调用就可以了。</p>

<p>再比如我们需要在某个程序中添加一个将某些指标数据向外输出的功能，根据不同的需求可能要将数据输出到终端、写入到文件或者通过网络连接发送出去。在这个场景下我们可以不关注最终输出的目的地是什么，只需要它能提供一个<code>Write</code>方法让我们把内容写入就可以了。</p>

<p>Go语言中为了解决类似上面的问题引入了接口的概念，接口类型区别于我们之前章节中介绍的那些具体类型，让我们专注于该类型提供的方法，而不是类型本身。使用接口类型通常能够让我们写出更加通用和灵活的代码。</p>

<h4 id="面向接口编程">面向接口编程</h4>

<p>PHP、Java等语言中也有接口的概念，不过在PHP和Java语言中需要显式声明一个类实现了哪些接口，在Go语言中使用隐式声明的方式实现接口。只要一个类型实现了接口中规定的所有方法，那么它就实现了这个接口。</p>

<p>Go语言中的这种设计符合程序开发中抽象的一般规律，例如在下面的代码示例中，我们的电商系统最开始只设计了支付宝一种支付方式：</p>

<pre><code class="language-go">type ZhiFuBao struct {
	// 支付宝
}

// Pay 支付宝的支付方法
func (z *ZhiFuBao) Pay(amount int64) {
  fmt.Printf(&quot;使用支付宝付款：%.2f元。\n&quot;, float64(amount/100))
}

// Checkout 结账
func Checkout(obj *ZhiFuBao) {
	// 支付100元
	obj.Pay(100)
}

func main() {
	Checkout(&amp;ZhiFuBao{})
}
</code></pre>

<p>随着业务的发展，根据用户需求添加支持微信支付。</p>

<pre><code class="language-go">type WeChat struct {
	// 微信
}

// Pay 微信的支付方法
func (w *WeChat) Pay(amount int64) {
	fmt.Printf(&quot;使用微信付款：%.2f元。\n&quot;, float64(amount/100))
}
</code></pre>

<p>在实际的交易流程中，我们可以根据用户选择的支付方式来决定最终调用支付宝的Pay方法还是微信支付的Pay方法。</p>

<pre><code class="language-go">// Checkout 支付宝结账
func CheckoutWithZFB(obj *ZhiFuBao) {
	// 支付100元
	obj.Pay(100)
}

// Checkout 微信支付结账
func CheckoutWithWX(obj *WeChat) {
	// 支付100元
	obj.Pay(100)
}
</code></pre>

<p>实际上，从上面的代码示例中我们可以看出，我们其实并不怎么关心用户选择的是什么支付方式，我们只关心调用Pay方法时能否正常运行。这就是典型的“不关心它是什么，只关心它能做什么”的场景。</p>

<p>在这种场景下我们可以将具体的支付方式抽象为一个名为<code>Payer</code>的接口类型，即任何实现了<code>Pay</code>方法的都可以称为<code>Payer</code>类型。</p>

<pre><code class="language-go">// Payer 包含支付方法的接口类型
type Payer interface {
	Pay(int64)
}
</code></pre>

<p>此时只需要修改下原始的<code>Checkout</code>函数，它接收一个<code>Payer</code>类型的参数。这样就能够在不修改既有函数调用的基础上，支持新的支付方式。</p>

<pre><code class="language-go">// Checkout 结账
func Checkout(obj Payer) {
	// 支付100元
	obj.Pay(100)
}

func main() {
	Checkout(&amp;ZhiFuBao{}) // 之前调用支付宝支付

	Checkout(&amp;WeChat{}) // 现在支持使用微信支付
}
</code></pre>

<p>像类似的例子在我们编程过程中会经常遇到：</p>

<ul>
<li>比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？</li>
<li>比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？</li>
<li>比如满减券、立减券、打折券都属于电商场景下常见的优惠方式，我们能不能把它们当成“优惠券”来处理呢？</li>
</ul>

<p>接口类型是Go语言提供的一种工具，在实际的编码过程中是否使用它由你自己决定，但是通常使用接口类型可以使代码更清晰易读。</p>

<h4 id="接口类型变量">接口类型变量</h4>

<p>那实现了接口又有什么用呢？一个接口类型的变量能够存储所有实现了该接口的类型变量。</p>

<p>例如在上面的示例中，<code>Dog</code>和<code>Cat</code>类型均实现了<code>Sayer</code>接口，此时一个<code>Sayer</code>类型的变量就能够接收<code>Cat</code>和<code>Dog</code>类型的变量。</p>

<pre><code class="language-go">var x Sayer // 声明一个Sayer类型的变量x
a := Cat{}  // 声明一个Cat类型变量a
b := Dog{}  // 声明一个Dog类型变量b
x = a       // 可以把Cat类型变量直接赋值给x
x.Say()     // 喵喵喵
x = b       // 可以把Dog类型变量直接赋值给x
x.Say()     // 汪汪汪
</code></pre>

<h3 id="值接收者和指针接收者">值接收者和指针接收者</h3>

<p>在结构体那一章节中，我们介绍了在定义结构体方法时既可以使用值接收者也可以使用指针接收者。那么对于实现接口来说使用值接收者和使用指针接收者有什么区别呢？接下来我们通过一个例子看一下其中的区别。</p>

<p>我们定义一个<code>Mover</code>接口，它包含一个<code>Move</code>方法。</p>

<pre><code class="language-go">// Mover 定义一个接口类型
type Mover interface {
	Move()
}
</code></pre>

<h4 id="值接收者实现接口">值接收者实现接口</h4>

<p>我们定义一个<code>Dog</code>结构体类型，并使用值接收者为其定义一个<code>Move</code>方法。</p>

<pre><code class="language-go">// Dog 狗结构体类型
type Dog struct{}

// Move 使用值接收者定义Move方法实现Mover接口
func (d Dog) Move() {
	fmt.Println(&quot;狗会动&quot;)
}
</code></pre>

<p>此时实现<code>Mover</code>接口的是<code>Dog</code>类型。</p>

<pre><code class="language-go">var x Mover    // 声明一个Mover类型的变量x

var d1 = Dog{} // d1是Dog类型
x = d1         // 可以将d1赋值给变量x
x.Move()

var d2 = &amp;Dog{} // d2是Dog指针类型
x = d2          // 也可以将d2赋值给变量x
x.Move()
</code></pre>

<p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是结构体类型还是对应的结构体指针类型的变量都可以赋值给该接口变量。</p>

<h4 id="指针接收者实现接口">指针接收者实现接口</h4>

<p>我们再来测试一下使用指针接收者实现接口有什么区别。</p>

<pre><code class="language-go">// Cat 猫结构体类型
type Cat struct{}

// Move 使用指针接收者定义Move方法实现Mover接口
func (c *Cat) Move() {
	fmt.Println(&quot;猫会动&quot;)
}
</code></pre>

<p>此时实现<code>Mover</code>接口的是<code>*Cat</code>类型，我们可以将<code>*Cat</code>类型的变量直接赋值给<code>Mover</code>接口类型的变量<code>x</code>。</p>

<pre><code class="language-go">var c1 = &amp;Cat{} // c1是*Cat类型
x = c1          // 可以将c1当成Mover类型
x.Move()
</code></pre>

<p>但是不能给将<code>Cat</code>类型的变量赋值给<code>Mover</code>接口类型的变量<code>x</code>。</p>

<pre><code class="language-go">// 下面的代码无法通过编译
var c2 = Cat{} // c2是Cat类型
x = c2         // 不能将c2当成Mover类型
</code></pre>

<p>由于Go语言中有对指针求值的语法糖，对于值接收者实现的接口，无论使用值类型还是指针类型都没有问题。但是我们并不总是能对一个值求址，所以对于指针接收者实现的接口要额外注意。</p>

<h3 id="类型与接口的关系">类型与接口的关系</h3>

<h4 id="一个类型实现多个接口">一个类型实现多个接口</h4>

<p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。例如狗不仅可以叫，还可以动。我们完全可以分别定义<code>Sayer</code>接口和<code>Mover</code>接口，具体代码示例如下。</p>

<pre><code class="language-go">// Sayer 接口
type Sayer interface {
	Say()
}

// Mover 接口
type Mover interface {
	Move()
}
</code></pre>

<p><code>Dog</code>既可以实现<code>Sayer</code>接口，也可以实现<code>Mover</code>接口。</p>

<pre><code class="language-go">type Dog struct {
	Name string
}

// 实现Sayer接口
func (d Dog) Say() {
	fmt.Printf(&quot;%s会叫汪汪汪\n&quot;, d.Name)
}

// 实现Mover接口
func (d Dog) Move() {
	fmt.Printf(&quot;%s会动\n&quot;, d.Name)
}
</code></pre>

<p>同一个类型实现不同的接口互相不影响使用。</p>

<pre><code class="language-go">var d = Dog{Name: &quot;旺财&quot;}

var s Sayer = d
var m Mover = d

s.Say()  // 对Sayer类型调用Say方法
m.Move() // 对Mover类型调用Move方法
</code></pre>

<h4 id="多种类型实现同一接口">多种类型实现同一接口</h4>

<p>Go语言中不同的类型还可以实现同一接口。例如在我们的代码世界中不仅狗可以动，汽车也可以动。我们可以使用如下代码体现这个关系。</p>

<pre><code class="language-go">// 实现Mover接口
func (d Dog) Move() {
	fmt.Printf(&quot;%s会动\n&quot;, d.Name)
}

// Car 汽车结构体类型
type Car struct {
	Brand string
}

// Move Car类型实现Mover接口
func (c Car) Move() {
	fmt.Printf(&quot;%s速度70迈\n&quot;, c.Brand)
}
</code></pre>

<p>这样我们在代码中就可以把狗和汽车当成一个会动的类型来处理，不必关注它们具体是什么，只需要调用它们的<code>Move</code>方法就可以了。</p>

<pre><code class="language-go">var obj Mover

obj = Dog{Name: &quot;旺财&quot;}
obj.Move()

obj = Car{Brand: &quot;宝马&quot;}
obj.Move()
</code></pre>

<p>上面的代码执行结果如下：</p>

<pre><code class="language-go">旺财会跑
宝马速度70迈
</code></pre>

<p>一个接口的所有方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p>

<pre><code class="language-go">// WashingMachine 洗衣机
type WashingMachine interface {
	wash()
	dry()
}

// 甩干器
type dryer struct{}

// 实现WashingMachine接口的dry()方法
func (d dryer) dry() {
	fmt.Println(&quot;甩一甩&quot;)
}

// 海尔洗衣机
type haier struct {
	dryer //嵌入甩干器
}

// 实现WashingMachine接口的wash()方法
func (h haier) wash() {
	fmt.Println(&quot;洗刷刷&quot;)
}
</code></pre>

<h3 id="接口组合">接口组合</h3>

<p>接口与接口之间可以通过互相嵌套形成新的接口类型，例如Go标准库<code>io</code>源码中就有很多接口之间互相组合的示例。</p>

<pre><code class="language-go">// src/io/io.go

type Reader interface {
	Read(p []byte) (n int, err error)
}

type Writer interface {
	Write(p []byte) (n int, err error)
}

type Closer interface {
	Close() error
}

// ReadWriter 是组合Reader接口和Writer接口形成的新接口类型
type ReadWriter interface {
	Reader
	Writer
}

// ReadCloser 是组合Reader接口和Closer接口形成的新接口类型
type ReadCloser interface {
	Reader
	Closer
}

// WriteCloser 是组合Writer接口和Closer接口形成的新接口类型
type WriteCloser interface {
	Writer
	Closer
}
</code></pre>

<p>对于这种由多个接口类型组合形成的新接口类型，同样只需要实现新接口类型中规定的所有方法就算实现了该接口类型。</p>

<p>接口也可以作为结构体的一个字段，我们来看一段Go标准库<code>sort</code>源码中的示例。</p>

<pre><code class="language-go">// src/sort/sort.go

// Interface 定义通过索引对元素排序的接口类型
type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}


// reverse 结构体中嵌入了Interface接口
type reverse struct {
    Interface
}
</code></pre>

<p>通过在结构体中嵌入一个接口类型，从而让该结构体类型实现了该接口类型，并且还可以改写该接口的方法。</p>

<pre><code class="language-go">// Less 为reverse类型添加Less方法，重写原Interface接口类型的Less方法
func (r reverse) Less(i, j int) bool {
	return r.Interface.Less(j, i)
}
</code></pre>

<p><code>Interface</code>类型原本的<code>Less</code>方法签名为<code>Less(i, j int) bool</code>，此处重写为<code>r.Interface.Less(j, i)</code>，即通过将索引参数交换位置实现反转。</p>

<p>在这个示例中还有一个需要注意的地方是<code>reverse</code>结构体本身是不可导出的（结构体类型名称首字母小写），<code>sort.go</code>中通过定义一个可导出的<code>Reverse</code>函数来让使用者创建<code>reverse</code>结构体实例。</p>

<pre><code class="language-go">func Reverse(data Interface) Interface {
	return &amp;reverse{data}
}
</code></pre>

<p>这样做的目的是保证得到的<code>reverse</code>结构体中的<code>Interface</code>属性一定不为<code>nil</code>，否者<code>r.Interface.Less(j, i)</code>就会出现空指针panic。</p>

<p>此外在Go内置标准库<code>database/sql</code>中也有很多类似的结构体内嵌接口类型的使用示例，各位读者可自行查阅。</p>

<h3 id="空接口">空接口</h3>

<h4 id="空接口的定义">空接口的定义</h4>

<p>空接口是指没有定义任何方法的接口类型。因此任何类型都可以视为实现了空接口。也正是因为空接口类型的这个特性，空接口类型的变量可以存储任意类型的值。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

// 空接口

// Any 不包含任何方法的空接口类型
type Any interface{}

// Dog 狗结构体
type Dog struct{}

func main() {
	var x Any

	x = &quot;你好&quot; // 字符串型
	fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)
	x = 100 // int型
	fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)
	x = true // 布尔型
	fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)
	x = Dog{} // 结构体类型
	fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)
}
</code></pre>

<p>通常我们在使用空接口类型时不必使用<code>type</code>关键字声明，可以像下面的代码一样直接使用<code>interface{}</code>。</p>

<pre><code class="language-go">var x interface{}  // 声明一个空接口类型变量x
</code></pre>

<h4 id="空接口的应用">空接口的应用</h4>

<h5 id="空接口作为函数的参数">空接口作为函数的参数</h5>

<p>使用空接口实现可以接收任意类型的函数参数。</p>

<pre><code class="language-go">// 空接口作为函数参数
func show(a interface{}) {
	fmt.Printf(&quot;type:%T value:%v\n&quot;, a, a)
}
</code></pre>

<h5 id="空接口作为map的值">空接口作为map的值</h5>

<p>使用空接口实现可以保存任意值的字典。</p>

<pre><code class="language-go">// 空接口作为map值
	var studentInfo = make(map[string]interface{})
	studentInfo[&quot;name&quot;] = &quot;沙河娜扎&quot;
	studentInfo[&quot;age&quot;] = 18
	studentInfo[&quot;married&quot;] = false
	fmt.Println(studentInfo)
</code></pre>

<h3 id="接口值">接口值</h3>

<p>由于接口类型的值可以是任意一个实现了该接口的类型值，所以接口值除了需要记录具体<strong>值</strong>之外，还需要记录这个值属于的<strong>类型</strong>。也就是说接口值由“类型”和“值”组成，鉴于这两部分会根据存入值的不同而发生变化，我们称之为接口的<code>动态类型</code>和<code>动态值</code>。</p>

<p><img src="/resources/技术收录/golang/interface01.png" alt="接口值示例" /></p>

<p>我们接下来通过一个示例来加深对接口值的理解。</p>

<p>下面的示例代码中，定义了一个<code>Mover</code>接口类型和两个实现了该接口的<code>Dog</code>和<code>Car</code>结构体类型。</p>

<pre><code class="language-go">type Mover interface {
	Move()
}

type Dog struct {
	Name string
}

func (d *Dog) Move() {
	fmt.Println(&quot;狗在跑~&quot;)
}

type Car struct {
	Brand string
}

func (c *Car) Move() {
	fmt.Println(&quot;汽车在跑~&quot;)
}
</code></pre>

<p>首先，我们创建一个<code>Mover</code>接口类型的变量<code>m</code>。</p>

<pre><code class="language-go">var m Mover
</code></pre>

<p>此时，接口变量<code>m</code>是接口类型的零值，也就是它的类型和值部分都是<code>nil</code>，就如下图所示。</p>

<p><img src="/resources/技术收录/golang/interface02.png" alt="接口值示例" /></p>

<p>我们可以使用<code>m == nil</code>来判断此时的接口值是否为空。</p>

<pre><code class="language-go">fmt.Println(m == nil)  // true
</code></pre>

<p><strong>注意：</strong>我们不能对一个空接口值调用任何方法，否则会产生panic。</p>

<pre><code class="language-go">m.Move() // panic: runtime error: invalid memory address or nil pointer dereference
</code></pre>

<p>接下来，我们将一个<code>*Dog</code>结构体指针赋值给变量<code>m</code>。</p>

<pre><code class="language-go">m = &amp;Dog{Name: &quot;旺财&quot;}
</code></pre>

<p>此时，接口值<code>m</code>的动态类型会被设置为<code>*Dog</code>，动态值为结构体变量的拷贝。</p>

<p><img src="/resources/技术收录/golang/interface03.png" alt="接口值示例" /></p>

<p>然后，我们给接口变量<code>m</code>赋值为一个<code>*Car</code>类型的值。</p>

<pre><code class="language-go">var c *Car
m = c
</code></pre>

<p>这一次，接口值<code>m</code>的动态类型为<code>*Car</code>，动态值为<code>nil</code>。</p>

<p><img src="/resources/技术收录/golang/interface04.png" alt="接口值示例" /></p>

<p><strong>注意：</strong>此时接口变量<code>m</code>与<code>nil</code>并不相等，因为它只是动态值的部分为<code>nil</code>，而动态类型部分保存着对应值的类型。</p>

<pre><code class="language-go">fmt.Println(m == nil) // false
</code></pre>

<p>接口值是支持相互比较的，当且仅当接口值的动态类型和动态值都相等时才相等。</p>

<pre><code class="language-go">var (
	x Mover = new(Dog)
	y Mover = new(Car)
)
fmt.Println(x == y) // false
</code></pre>

<p>但是有一种特殊情况需要特别注意，如果接口值保存的动态类型相同，但是这个动态类型不支持互相比较（比如切片），那么对它们相互比较时就会引发panic。</p>

<pre><code class="language-go">var z interface{} = []int{1, 2, 3}
fmt.Println(z == z) // panic: runtime error: comparing uncomparable type []int
</code></pre>

<h3 id="类型断言">类型断言</h3>

<p>接口值可能赋值为任意类型的值，那我们如何从接口值获取其存储的具体数据呢？</p>

<p>我们可以借助标准库<code>fmt</code>包的格式化打印获取到接口值的动态类型。</p>

<pre><code class="language-go">var m Mover

m = &amp;Dog{Name: &quot;旺财&quot;}
fmt.Printf(&quot;%T\n&quot;, m) // *main.Dog

m = new(Car)
fmt.Printf(&quot;%T\n&quot;, m) // *main.Car
</code></pre>

<p>而<code>fmt</code>包内部其实是使用反射的机制在程序运行时获取到动态类型的名称。关于反射的内容我们会在后续章节详细介绍。</p>

<p>而想要从接口值中获取到对应的实际值需要使用类型断言，其语法格式如下。</p>

<pre><code class="language-go">x.(T)
</code></pre>

<p>其中：</p>

<ul>
<li>x：表示接口类型的变量</li>
<li>T：表示断言<code>x</code>可能是的类型。</li>
</ul>

<p>该语法返回两个参数，第一个参数是<code>x</code>转化为<code>T</code>类型后的变量，第二个值是一个布尔值，若为<code>true</code>则表示断言成功，为<code>false</code>则表示断言失败。</p>

<p>举个例子：</p>

<pre><code class="language-go">var n Mover = &amp;Dog{Name: &quot;旺财&quot;}
v, ok := n.(*Dog)
if ok {
	fmt.Println(&quot;类型断言成功&quot;)
	v.Name = &quot;富贵&quot; // 变量v是*Dog类型
} else {
	fmt.Println(&quot;类型断言失败&quot;)
}
</code></pre>

<p>如果对一个接口值有多个实际类型需要判断，推荐使用<code>switch</code>语句来实现。</p>

<pre><code class="language-go">// justifyType 对传入的空接口类型变量x进行类型断言
func justifyType(x interface{}) {
	switch v := x.(type) {
	case string:
		fmt.Printf(&quot;x is a string，value is %v\n&quot;, v)
	case int:
		fmt.Printf(&quot;x is a int is %v\n&quot;, v)
	case bool:
		fmt.Printf(&quot;x is a bool is %v\n&quot;, v)
	default:
		fmt.Println(&quot;unsupport type！&quot;)
	}
}
</code></pre>

<p>由于接口类型变量能够动态存储不同类型值的特点，所以很多初学者会滥用接口类型（特别是空接口）来实现编码过程中的便捷。只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。切记不要为了使用接口类型而增加不必要的抽象，导致不必要的运行时损耗。</p>

<p>在 Go 语言中接口是一个非常重要的概念和特性，使用接口类型能够实现代码的抽象和解耦，也可以隐藏某个功能的内部实现，但是缺点就是在查看源码的时候，不太方便查找到具体实现接口的类型。</p>

<p>相信很多读者在刚接触到接口类型时都会有很多疑惑，请牢记接口是一种类型，一种抽象的类型。区别于我们在之前章节提到的那些具体类型（整型、数组、结构体类型等），它是一个只要求实现特定方法的抽象类型。</p>

<p><strong>小技巧：</strong> 下面的代码可以在程序编译阶段验证某一结构体是否满足特定的接口类型。</p>

<pre><code class="language-go">// 摘自gin框架routergroup.go
type IRouter interface{ ... }

type RouterGroup struct { ... }

var _ IRouter = &amp;RouterGroup{}  // 确保RouterGroup实现了接口IRouter
</code></pre>

<p>上面的代码中也可以使用<code>var _ IRouter = (*RouterGroup)(nil)</code>进行验证。</p>

<h3 id="练习题-7">练习题</h3>

<ol>
<li>使用接口的方式实现一个既可以往终端写日志也可以往文件写日志的简易日志库。</li>
</ol>

<h2 id="error接口和错误处理">Error接口和错误处理</h2>

<p>Go 语言中的错误处理与其他语言不太一样，它把错误当成一种值来处理，更强调判断错误、处理错误，而不是一股脑的 catch 捕获异常。</p>

<h2 id="error接口和错误处理-1">Error接口和错误处理</h2>

<h3 id="error-接口">Error 接口</h3>

<p>Go 语言中把错误当成一种特殊的值来处理，不支持其他语言中使用<code>try/catch</code>捕获异常的方式。</p>

<h3 id="error-接口-1">Error 接口</h3>

<p>Go 语言中使用一个名为 <code>error</code> 接口来表示错误类型。</p>

<pre><code class="language-go">type error interface {
    Error() string
}
</code></pre>

<p><code>error</code> 接口只包含一个方法——<code>Error</code>，这个函数需要返回一个描述错误信息的字符串。</p>

<p>当一个函数或方法需要返回错误时，我们通常是把错误作为最后一个返回值。例如下面标准库 os 中打开文件的函数。</p>

<pre><code class="language-go">func Open(name string) (*File, error) {
	return OpenFile(name, O_RDONLY, 0)
}
</code></pre>

<p>由于 error 是一个接口类型，默认零值为<code>nil</code>。所以我们通常将调用函数返回的错误与<code>nil</code>进行比较，以此来判断函数是否返回错误。例如你会经常看到类似下面的错误判断代码。</p>

<pre><code class="language-go">file, err := os.Open(&quot;./xx.go&quot;)
if err != nil {
	fmt.Println(&quot;打开文件失败,err:&quot;, err)
	return
}
</code></pre>

<p><strong>注意</strong></p>

<p>当我们使用<code>fmt</code>包打印错误时会自动调用 error 类型的 Error 方法，也就是会打印出错误的描述信息。</p>

<h4 id="创建错误">创建错误</h4>

<p>我们可以根据需求自定义 error，最简单的方式是使用<code>errors</code> 包提供的<code>New</code>函数创建一个错误。</p>

<h5 id="errors-new">errors.New</h5>

<p>函数签名如下，</p>

<pre><code class="language-go">func New(text string) error
</code></pre>

<p>它接收一个字符串参数返回包含该字符串的错误。我们可以在函数返回时快速创建一个错误。</p>

<pre><code class="language-go">func queryById(id int64) (*Info, error) {
	if id &lt;= 0 {
		return nil, errors.New(&quot;无效的id&quot;)
	}

	// ...
}
</code></pre>

<p>或者用来定义一个错误变量，例如标准库<code>io.EOF</code>错误定义如下。</p>

<pre><code class="language-go">var EOF = errors.New(&quot;EOF&quot;)
</code></pre>

<h4 id="fmt-errorf">fmt.Errorf</h4>

<p>当我们需要传入格式化的错误描述信息时，使用<code>fmt.Errorf</code>是个更好的选择。</p>

<pre><code class="language-go">fmt.Errorf(&quot;查询数据库失败，err:%v&quot;, err)
</code></pre>

<p>但是上面的方式会丢失原有的错误类型，只拿到错误描述的文本信息。</p>

<p>为了不丢失函数调用的错误链，使用<code>fmt.Errorf</code>时搭配使用特殊的格式化动词<code>%w</code>，可以实现基于已有的错误再包装得到一个新的错误。</p>

<pre><code class="language-go">fmt.Errorf(&quot;查询数据库失败，err:%w&quot;, err)
</code></pre>

<p>对于这种二次包装的错误，<code>errors</code>包中提供了以下三个方法。</p>

<pre><code class="language-go">func Unwrap(err error) error                 // 获得err包含下一层错误
func Is(err, target error) bool              // 判断err是否包含target
func As(err error, target interface{}) bool  // 判断err是否为target类型
</code></pre>

<h4 id="错误结构体类型">错误结构体类型</h4>

<p>此外我们还可以自己定义结构体类型，实现`<code>error</code>接口。</p>

<pre><code class="language-go">// OpError 自定义结构体类型
type OpError struct {
	Op string
}

// Error OpError 类型实现error接口
func (e *OpError) Error() string {
	return fmt.Sprintf(&quot;无权执行%s操作&quot;, e.Op)
}
</code></pre>

<h2 id="go语言基础之反射">Go语言基础之反射</h2>

<p>本文介绍了Go语言反射的意义和基本使用。</p>

<h2 id="变量的内在机制">变量的内在机制</h2>

<p>Go语言中的变量是分为两部分的:</p>

<ul>
<li>类型信息：预先定义好的元信息。</li>
<li>值信息：程序运行过程中可动态变化的。</li>
</ul>

<h2 id="反射介绍">反射介绍</h2>

<p>反射是指在程序运行期间对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p>

<p>支持反射的语言可以在程序编译期间将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期间获取类型的反射信息，并且有能力修改它们。</p>

<p>Go程序在运行期间使用reflect包访问程序的反射信息。</p>

<p>在上一篇博客中我们介绍了空接口。 空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？ 反射就是在运行时动态的获取一个变量的类型信息和值信息。</p>

<h2 id="reflect包">reflect包</h2>

<p>在Go语言的反射机制中，任何接口值都由是<code>一个具体类型</code>和<code>具体类型的值</code>两部分组成的(我们在上一篇接口的博客中有介绍相关概念)。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由<code>reflect.Type</code>和<code>reflect.Value</code>两部分组成，并且reflect包提供了<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>两个函数来获取任意对象的Value和Type。</p>

<h3 id="typeof">TypeOf</h3>

<p>在Go语言中，使用<code>reflect.TypeOf()</code>函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func reflectType(x interface{}) {
	v := reflect.TypeOf(x)
	fmt.Printf(&quot;type:%v\n&quot;, v)
}
func main() {
	var a float32 = 3.14
	reflectType(a) // type:float32
	var b int64 = 100
	reflectType(b) // type:int64
}
</code></pre>

<h4 id="type-name和type-kind">type name和type kind</h4>

<p>在反射中关于类型还划分为两种：<code>类型（Type）</code>和<code>种类（Kind）</code>。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而<code>种类（Kind）</code>就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到<code>种类（Kind）</code>。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

type myInt int64

func reflectType(x interface{}) {
	t := reflect.TypeOf(x)
	fmt.Printf(&quot;type:%v kind:%v\n&quot;, t.Name(), t.Kind())
}

func main() {
	var a *float32 // 指针
	var b myInt    // 自定义类型
	var c rune     // 类型别名
	reflectType(a) // type: kind:ptr
	reflectType(b) // type:myInt kind:int64
	reflectType(c) // type:int32 kind:int32

	type person struct {
		name string
		age  int
	}
	type book struct{ title string }
	var d = person{
		name: &quot;沙河小王子&quot;,
		age:  18,
	}
	var e = book{title: &quot;《跟小王子学Go语言》&quot;}
	reflectType(d) // type:person kind:struct
	reflectType(e) // type:book kind:struct
}
</code></pre>

<p>Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的<code>.Name()</code>都是返回<code>空</code>。</p>

<p>在<code>reflect</code>包中定义的Kind类型如下：</p>

<pre><code class="language-go">type Kind uint
const (
    Invalid Kind = iota  // 非法类型
    Bool                 // 布尔型
    Int                  // 有符号整型
    Int8                 // 有符号8位整型
    Int16                // 有符号16位整型
    Int32                // 有符号32位整型
    Int64                // 有符号64位整型
    Uint                 // 无符号整型
    Uint8                // 无符号8位整型
    Uint16               // 无符号16位整型
    Uint32               // 无符号32位整型
    Uint64               // 无符号64位整型
    Uintptr              // 指针
    Float32              // 单精度浮点数
    Float64              // 双精度浮点数
    Complex64            // 64位复数类型
    Complex128           // 128位复数类型
    Array                // 数组
    Chan                 // 通道
    Func                 // 函数
    Interface            // 接口
    Map                  // 映射
    Ptr                  // 指针
    Slice                // 切片
    String               // 字符串
    Struct               // 结构体
    UnsafePointer        // 底层指针
)
</code></pre>

<h3 id="valueof">ValueOf</h3>

<p><code>reflect.ValueOf()</code>返回的是<code>reflect.Value</code>类型，其中包含了原始值的值信息。<code>reflect.Value</code>与原始值之间可以互相转换。</p>

<p><code>reflect.Value</code>类型提供的获取原始值的方法如下：</p>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">Interface() interface {}</td>
<td align="center">将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td>
</tr>

<tr>
<td align="center">Int() int64</td>
<td align="center">将值以 int 类型返回，所有有符号整型均可以此方式返回</td>
</tr>

<tr>
<td align="center">Uint() uint64</td>
<td align="center">将值以 uint 类型返回，所有无符号整型均可以此方式返回</td>
</tr>

<tr>
<td align="center">Float() float64</td>
<td align="center">将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td>
</tr>

<tr>
<td align="center">Bool() bool</td>
<td align="center">将值以 bool 类型返回</td>
</tr>

<tr>
<td align="center">Bytes() []bytes</td>
<td align="center">将值以字节数组 []bytes 类型返回</td>
</tr>

<tr>
<td align="center">String() string</td>
<td align="center">将值以字符串类型返回</td>
</tr>
</tbody>
</table>

<h4 id="通过反射获取值">通过反射获取值</h4>

<pre><code class="language-go">func reflectValue(x interface{}) {
	v := reflect.ValueOf(x)
	k := v.Kind()
	switch k {
	case reflect.Int64:
		// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换
		fmt.Printf(&quot;type is int64, value is %d\n&quot;, int64(v.Int()))
	case reflect.Float32:
		// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换
		fmt.Printf(&quot;type is float32, value is %f\n&quot;, float32(v.Float()))
	case reflect.Float64:
		// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换
		fmt.Printf(&quot;type is float64, value is %f\n&quot;, float64(v.Float()))
	}
}
func main() {
	var a float32 = 3.14
	var b int64 = 100
	reflectValue(a) // type is float32, value is 3.140000
	reflectValue(b) // type is int64, value is 100
	// 将int类型的原始值转换为reflect.Value类型
	c := reflect.ValueOf(10)
	fmt.Printf(&quot;type c :%T\n&quot;, c) // type c :reflect.Value
}
</code></pre>

<h4 id="通过反射设置变量的值">通过反射设置变量的值</h4>

<p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的<code>Elem()</code>方法来获取指针对应的值。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func reflectSetValue1(x interface{}) {
	v := reflect.ValueOf(x)
	if v.Kind() == reflect.Int64 {
		v.SetInt(200) //修改的是副本，reflect包会引发panic
	}
}
func reflectSetValue2(x interface{}) {
	v := reflect.ValueOf(x)
	// 反射中使用 Elem()方法获取指针对应的值
	if v.Elem().Kind() == reflect.Int64 {
		v.Elem().SetInt(200)
	}
}
func main() {
	var a int64 = 100
	// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value
	reflectSetValue2(&amp;a)
	fmt.Println(a)
}
</code></pre>

<h4 id="isnil-和isvalid">isNil()和isValid()</h4>

<h5 id="isnil">isNil()</h5>

<pre><code class="language-go">func (v Value) IsNil() bool
</code></pre>

<p><code>IsNil()</code>报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p>

<h5 id="isvalid">isValid()</h5>

<pre><code class="language-go">func (v Value) IsValid() bool
</code></pre>

<p><code>IsValid()</code>返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。</p>

<h5 id="举个例子-2">举个例子</h5>

<p><code>IsNil()</code>常被用于判断指针是否为空；<code>IsValid()</code>常被用于判定返回值是否有效。</p>

<pre><code class="language-go">func main() {
	// *int类型空指针
	var a *int
	fmt.Println(&quot;var a *int IsNil:&quot;, reflect.ValueOf(a).IsNil())
	// nil值
	fmt.Println(&quot;nil IsValid:&quot;, reflect.ValueOf(nil).IsValid())
	// 实例化一个匿名结构体
	b := struct{}{}
	// 尝试从结构体中查找&quot;abc&quot;字段
	fmt.Println(&quot;不存在的结构体成员:&quot;, reflect.ValueOf(b).FieldByName(&quot;abc&quot;).IsValid())
	// 尝试从结构体中查找&quot;abc&quot;方法
	fmt.Println(&quot;不存在的结构体方法:&quot;, reflect.ValueOf(b).MethodByName(&quot;abc&quot;).IsValid())
	// map
	c := map[string]int{}
	// 尝试从map中查找一个不存在的键
	fmt.Println(&quot;map中不存在的键：&quot;, reflect.ValueOf(c).MapIndex(reflect.ValueOf(&quot;娜扎&quot;)).IsValid())
}
</code></pre>

<h2 id="结构体反射">结构体反射</h2>

<h3 id="与结构体相关的方法">与结构体相关的方法</h3>

<p>任意值通过<code>reflect.TypeOf()</code>获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（<code>reflect.Type</code>）的<code>NumField()</code>和<code>Field()</code>方法获得结构体成员的详细信息。</p>

<p><code>reflect.Type</code>中与获取结构体成员相关的的方法如下表所示。</p>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">Field(i int) StructField</td>
<td align="center">根据索引，返回索引对应的结构体字段的信息。</td>
</tr>

<tr>
<td align="center">NumField() int</td>
<td align="center">返回结构体成员字段数量。</td>
</tr>

<tr>
<td align="center">FieldByName(name string) (StructField, bool)</td>
<td align="center">根据给定字符串返回字符串对应的结构体字段的信息。</td>
</tr>

<tr>
<td align="center">FieldByIndex(index []int) StructField</td>
<td align="center">多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。</td>
</tr>

<tr>
<td align="center">FieldByNameFunc(match func(string) bool) (StructField,bool)</td>
<td align="center">根据传入的匹配函数匹配需要的字段。</td>
</tr>

<tr>
<td align="center">NumMethod() int</td>
<td align="center">返回该类型的方法集中方法的数目</td>
</tr>

<tr>
<td align="center">Method(int) Method</td>
<td align="center">返回该类型方法集中的第i个方法</td>
</tr>

<tr>
<td align="center">MethodByName(string)(Method, bool)</td>
<td align="center">根据方法名返回该类型方法集中的方法</td>
</tr>
</tbody>
</table>

<h3 id="structfield类型">StructField类型</h3>

<p><code>StructField</code>类型用来描述结构体中的一个字段的信息。</p>

<p><code>StructField</code>的定义如下：</p>

<pre><code class="language-go">type StructField struct {
    // Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。
    // 参见http://golang.org/ref/spec#Uniqueness_of_identifiers
    Name    string
    PkgPath string
    Type      Type      // 字段的类型
    Tag       StructTag // 字段的标签
    Offset    uintptr   // 字段在结构体中的字节偏移量
    Index     []int     // 用于Type.FieldByIndex时的索引切片
    Anonymous bool      // 是否匿名字段
}
</code></pre>

<h3 id="结构体反射示例">结构体反射示例</h3>

<p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</p>

<pre><code class="language-go">type student struct {
	Name  string `json:&quot;name&quot;`
	Score int    `json:&quot;score&quot;`
}

func main() {
	stu1 := student{
		Name:  &quot;小王子&quot;,
		Score: 90,
	}

	t := reflect.TypeOf(stu1)
	fmt.Println(t.Name(), t.Kind()) // student struct
	// 通过for循环遍历结构体的所有字段信息
	for i := 0; i &lt; t.NumField(); i++ {
		field := t.Field(i)
		fmt.Printf(&quot;name:%s index:%d type:%v json tag:%v\n&quot;, field.Name, field.Index, field.Type, field.Tag.Get(&quot;json&quot;))
	}

	// 通过字段名获取指定结构体字段信息
	if scoreField, ok := t.FieldByName(&quot;Score&quot;); ok {
		fmt.Printf(&quot;name:%s index:%d type:%v json tag:%v\n&quot;, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(&quot;json&quot;))
	}
}
</code></pre>

<p>接下来编写一个函数<code>printMethod(s interface{})</code>来遍历打印s包含的方法。</p>

<pre><code class="language-go">// 给student添加两个方法 Study和Sleep(注意首字母大写)
func (s student) Study() string {
	msg := &quot;好好学习，天天向上。&quot;
	fmt.Println(msg)
	return msg
}

func (s student) Sleep() string {
	msg := &quot;好好睡觉，快快长大。&quot;
	fmt.Println(msg)
	return msg
}

func printMethod(x interface{}) {
	t := reflect.TypeOf(x)
	v := reflect.ValueOf(x)

	fmt.Println(t.NumMethod())
	for i := 0; i &lt; v.NumMethod(); i++ {
		methodType := v.Method(i).Type()
		fmt.Printf(&quot;method name:%s\n&quot;, t.Method(i).Name)
		fmt.Printf(&quot;method:%s\n&quot;, methodType)
		// 通过反射调用方法传递的参数必须是 []reflect.Value 类型
		var args = []reflect.Value{}
		v.Method(i).Call(args)
	}
}
</code></pre>

<h2 id="反射是把双刃剑">反射是把双刃剑</h2>

<p>反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码。但是反射不应该被滥用，原因有以下三个。</p>

<ol>
<li>基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。</li>
<li>大量使用反射的代码通常难以理解。</li>
<li>反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。</li>
</ol>

<h2 id="练习题-8">练习题</h2>

<ol>
<li>编写代码利用反射实现一个ini文件的解析器程序。</li>
</ol>

<h1 id="go语言常用标准库">Go语言常用标准库</h1>

<h2 id="go语言fmt-printf使用指南">Go语言fmt.Printf使用指南</h2>

<p>fmt标准库是我们在学习Go语言过程中接触最早最频繁的一个了，本文介绍了fmtb包的一些常用函数。</p>

<h2 id="fmt">fmt</h2>

<p>fmt包实现了类似C语言printf和scanf的格式化I/O。主要分为向外输出内容和获取输入内容两大部分。</p>

<h3 id="向外输出">向外输出</h3>

<p>标准库<code>fmt</code>提供了以下几种输出相关函数。</p>

<h4 id="print">Print</h4>

<p><code>Print</code>系列函数会将内容输出到系统的标准输出，区别在于<code>Print</code>函数直接输出内容，<code>Printf</code>函数支持格式化输出字符串，<code>Println</code>函数会在输出内容的结尾添加一个换行符。</p>

<pre><code class="language-go">func Print(a ...interface{}) (n int, err error)
func Printf(format string, a ...interface{}) (n int, err error)
func Println(a ...interface{}) (n int, err error)
</code></pre>

<p>举个简单的例子：</p>

<pre><code class="language-go">func main() {
	fmt.Print(&quot;在终端打印该信息。&quot;)
	name := &quot;沙河小王子&quot;
	fmt.Printf(&quot;我是：%s\n&quot;, name)
	fmt.Println(&quot;在终端打印单独一行显示&quot;)
}
</code></pre>

<p>执行上面的代码输出：</p>

<pre><code class="language-go">在终端打印该信息。我是：沙河小王子
在终端打印单独一行显示
</code></pre>

<h4 id="fprint">Fprint</h4>

<p><code>Fprint</code>系列函数会将内容输出到一个<code>io.Writer</code>接口类型的变量<code>w</code>中，我们通常用这个函数往文件中写入内容。</p>

<pre><code class="language-go">func Fprint(w io.Writer, a ...interface{}) (n int, err error)
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)
</code></pre>

<p>举个例子：</p>

<pre><code class="language-go">// 向标准输出写入内容
fmt.Fprintln(os.Stdout, &quot;向标准输出写入内容&quot;)
fileObj, err := os.OpenFile(&quot;./xx.txt&quot;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
if err != nil {
	fmt.Println(&quot;打开文件出错，err:&quot;, err)
	return
}
name := &quot;沙河小王子&quot;
// 向打开的文件句柄中写入内容
fmt.Fprintf(fileObj, &quot;往文件中写如信息：%s&quot;, name)
</code></pre>

<p>注意，只要满足<code>io.Writer</code>接口的类型都支持写入。</p>

<h4 id="sprint">Sprint</h4>

<p><code>Sprint</code>系列函数会把传入的数据生成并返回一个字符串。</p>

<pre><code class="language-go">func Sprint(a ...interface{}) string
func Sprintf(format string, a ...interface{}) string
func Sprintln(a ...interface{}) string
</code></pre>

<p>简单的示例代码如下：</p>

<pre><code class="language-go">s1 := fmt.Sprint(&quot;沙河小王子&quot;)
name := &quot;沙河小王子&quot;
age := 18
s2 := fmt.Sprintf(&quot;name:%s,age:%d&quot;, name, age)
s3 := fmt.Sprintln(&quot;沙河小王子&quot;)
fmt.Println(s1, s2, s3)
</code></pre>

<h4 id="errorf">Errorf</h4>

<p><code>Errorf</code>函数根据format参数生成格式化字符串并返回一个包含该字符串的错误。</p>

<pre><code class="language-go">func Errorf(format string, a ...interface{}) error
</code></pre>

<p>通常使用这种方式来自定义错误类型，例如：</p>

<pre><code class="language-go">err := fmt.Errorf(&quot;这是一个错误&quot;)
</code></pre>

<p>Go1.13版本为<code>fmt.Errorf</code>函数新加了一个<code>%w</code>占位符用来生成一个可以包裹Error的Wrapping Error。</p>

<pre><code class="language-go">e := errors.New(&quot;原始错误e&quot;)
w := fmt.Errorf(&quot;Wrap了一个错误%w&quot;, e)
</code></pre>

<h3 id="格式化占位符">格式化占位符</h3>

<p><code>*printf</code>系列函数都支持format格式化参数，在这里我们按照占位符将被替换的变量类型划分，方便查询和记忆。</p>

<h4 id="通用占位符">通用占位符</h4>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">%v</td>
<td align="center">值的默认格式表示</td>
</tr>

<tr>
<td align="center">%+v</td>
<td align="center">类似%v，但输出结构体时会添加字段名</td>
</tr>

<tr>
<td align="center">%#v</td>
<td align="center">值的Go语法表示</td>
</tr>

<tr>
<td align="center">%T</td>
<td align="center">打印值的类型</td>
</tr>

<tr>
<td align="center">%%</td>
<td align="center">百分号</td>
</tr>
</tbody>
</table>

<p>示例代码如下：</p>

<pre><code class="language-go">fmt.Printf(&quot;%v\n&quot;, 100)
fmt.Printf(&quot;%v\n&quot;, false)
o := struct{ name string }{&quot;小王子&quot;}
fmt.Printf(&quot;%v\n&quot;, o)
fmt.Printf(&quot;%#v\n&quot;, o)
fmt.Printf(&quot;%T\n&quot;, o)
fmt.Printf(&quot;100%%\n&quot;)
</code></pre>

<p>输出结果如下：</p>

<pre><code class="language-bash">100
false
{小王子}
struct { name string }{name:&quot;小王子&quot;}
struct { name string }
100%
</code></pre>

<h4 id="布尔型">布尔型</h4>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">%t</td>
<td align="center">true或false</td>
</tr>
</tbody>
</table>

<h4 id="整型-1">整型</h4>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">%b</td>
<td align="center">表示为二进制</td>
</tr>

<tr>
<td align="center">%c</td>
<td align="center">该值对应的unicode码值</td>
</tr>

<tr>
<td align="center">%d</td>
<td align="center">表示为十进制</td>
</tr>

<tr>
<td align="center">%o</td>
<td align="center">表示为八进制</td>
</tr>

<tr>
<td align="center">%x</td>
<td align="center">表示为十六进制，使用a-f</td>
</tr>

<tr>
<td align="center">%X</td>
<td align="center">表示为十六进制，使用A-F</td>
</tr>

<tr>
<td align="center">%U</td>
<td align="center">表示为Unicode格式：U+1234，等价于”U+%04X”</td>
</tr>

<tr>
<td align="center">%q</td>
<td align="center">该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示</td>
</tr>
</tbody>
</table>

<p>示例代码如下：</p>

<pre><code class="language-go">n := 65
fmt.Printf(&quot;%b\n&quot;, n)
fmt.Printf(&quot;%c\n&quot;, n)
fmt.Printf(&quot;%d\n&quot;, n)
fmt.Printf(&quot;%o\n&quot;, n)
fmt.Printf(&quot;%x\n&quot;, n)
fmt.Printf(&quot;%X\n&quot;, n)
</code></pre>

<p>输出结果如下：</p>

<pre><code class="language-bash">1000001
A
65
101
41
41
</code></pre>

<h4 id="浮点数与复数">浮点数与复数</h4>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">%b</td>
<td align="center">无小数部分、二进制指数的科学计数法，如-123456p-78</td>
</tr>

<tr>
<td align="center">%e</td>
<td align="center">科学计数法，如-1234.456e+78</td>
</tr>

<tr>
<td align="center">%E</td>
<td align="center">科学计数法，如-1234.456E+78</td>
</tr>

<tr>
<td align="center">%f</td>
<td align="center">有小数部分但无指数部分，如123.456</td>
</tr>

<tr>
<td align="center">%F</td>
<td align="center">等价于%f</td>
</tr>

<tr>
<td align="center">%g</td>
<td align="center">根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）</td>
</tr>

<tr>
<td align="center">%G</td>
<td align="center">根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）</td>
</tr>
</tbody>
</table>

<p>示例代码如下：</p>

<pre><code class="language-go">f := 12.34
fmt.Printf(&quot;%b\n&quot;, f)
fmt.Printf(&quot;%e\n&quot;, f)
fmt.Printf(&quot;%E\n&quot;, f)
fmt.Printf(&quot;%f\n&quot;, f)
fmt.Printf(&quot;%g\n&quot;, f)
fmt.Printf(&quot;%G\n&quot;, f)
</code></pre>

<p>输出结果如下：</p>

<pre><code class="language-bash">6946802425218990p-49
1.234000e+01
1.234000E+01
12.340000
12.34
12.34
</code></pre>

<h4 id="字符串和-byte">字符串和[]byte</h4>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">%s</td>
<td align="center">直接输出字符串或者[]byte</td>
</tr>

<tr>
<td align="center">%q</td>
<td align="center">该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示</td>
</tr>

<tr>
<td align="center">%x</td>
<td align="center">每个字节用两字符十六进制数表示（使用a-f</td>
</tr>

<tr>
<td align="center">%X</td>
<td align="center">每个字节用两字符十六进制数表示（使用A-F）</td>
</tr>
</tbody>
</table>

<p>示例代码如下：</p>

<pre><code class="language-go">s := &quot;小王子&quot;
fmt.Printf(&quot;%s\n&quot;, s)
fmt.Printf(&quot;%q\n&quot;, s)
fmt.Printf(&quot;%x\n&quot;, s)
fmt.Printf(&quot;%X\n&quot;, s)
</code></pre>

<p>输出结果如下：</p>

<pre><code class="language-bash">小王子
&quot;小王子&quot;
e5b08fe78e8be5ad90
E5B08FE78E8BE5AD90
</code></pre>

<h4 id="指针">指针</h4>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">%p</td>
<td align="center">表示为十六进制，并加上前导的0x</td>
</tr>
</tbody>
</table>

<p>示例代码如下：</p>

<pre><code class="language-go">a := 10
fmt.Printf(&quot;%p\n&quot;, &amp;a)
fmt.Printf(&quot;%#p\n&quot;, &amp;a)
</code></pre>

<p>输出结果如下：</p>

<pre><code class="language-bash">0xc000094000
c000094000
</code></pre>

<h4 id="宽度标识符">宽度标识符</h4>

<p>宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下：</p>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">%f</td>
<td align="center">默认宽度，默认精度</td>
</tr>

<tr>
<td align="center">%9f</td>
<td align="center">宽度9，默认精度</td>
</tr>

<tr>
<td align="center">%.2f</td>
<td align="center">默认宽度，精度2</td>
</tr>

<tr>
<td align="center">%9.2f</td>
<td align="center">宽度9，精度2</td>
</tr>

<tr>
<td align="center">%9.f</td>
<td align="center">宽度9，精度0</td>
</tr>
</tbody>
</table>

<p>示例代码如下：</p>

<pre><code class="language-go">n := 12.34
fmt.Printf(&quot;%f\n&quot;, n)
fmt.Printf(&quot;%9f\n&quot;, n)
fmt.Printf(&quot;%.2f\n&quot;, n)
fmt.Printf(&quot;%9.2f\n&quot;, n)
fmt.Printf(&quot;%9.f\n&quot;, n)
</code></pre>

<p>输出结果如下：</p>

<pre><code class="language-bash">12.340000
12.340000
12.34
    12.34
       12
</code></pre>

<h4 id="其他flag">其他flag</h4>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">’+’</td>
<td align="center">总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）；</td>
</tr>

<tr>
<td align="center">’ ‘</td>
<td align="center">对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格</td>
</tr>

<tr>
<td align="center">’-’</td>
<td align="center">在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）；</td>
</tr>

<tr>
<td align="center">’#’</td>
<td align="center">八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值；</td>
</tr>

<tr>
<td align="center">‘0’</td>
<td align="center">使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面；</td>
</tr>
</tbody>
</table>

<p>举个例子：</p>

<pre><code class="language-go">s := &quot;小王子&quot;
fmt.Printf(&quot;%s\n&quot;, s)
fmt.Printf(&quot;%5s\n&quot;, s)
fmt.Printf(&quot;%-5s\n&quot;, s)
fmt.Printf(&quot;%5.7s\n&quot;, s)
fmt.Printf(&quot;%-5.7s\n&quot;, s)
fmt.Printf(&quot;%5.2s\n&quot;, s)
fmt.Printf(&quot;%05s\n&quot;, s)
</code></pre>

<p>输出结果如下：</p>

<pre><code class="language-bash">小王子
  小王子
小王子  
  小王子
小王子  
   小王
00小王子
</code></pre>

<h3 id="获取输入">获取输入</h3>

<p>Go语言<code>fmt</code>包下有<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，可以在程序运行过程中从标准输入获取用户的输入。</p>

<h4 id="fmt-scan">fmt.Scan</h4>

<p>函数定签名如下：</p>

<pre><code class="language-go">func Scan(a ...interface{}) (n int, err error)
</code></pre>

<ul>
<li>Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。</li>
<li>本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。</li>
</ul>

<p>具体代码示例如下：</p>

<pre><code class="language-go">func main() {
	var (
		name    string
		age     int
		married bool
	)
	fmt.Scan(&amp;name, &amp;age, &amp;married)
	fmt.Printf(&quot;扫描结果 name:%s age:%d married:%t \n&quot;, name, age, married)
}
</code></pre>

<p>将上面的代码编译后在终端执行，在终端依次输入<code>小王子</code>、<code>28</code>和<code>false</code>使用空格分隔。</p>

<pre><code class="language-bash">$ ./scan_demo 
小王子 28 false
扫描结果 name:小王子 age:28 married:false 
</code></pre>

<p><code>fmt.Scan</code>从标准输入中扫描用户输入的数据，将以空白符分隔的数据分别存入指定的参数。</p>

<h4 id="fmt-scanf">fmt.Scanf</h4>

<p>函数签名如下：</p>

<pre><code class="language-go">func Scanf(format string, a ...interface{}) (n int, err error)
</code></pre>

<ul>
<li>Scanf从标准输入扫描文本，根据format参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。</li>
<li>本函数返回成功扫描的数据个数和遇到的任何错误。</li>
</ul>

<p>代码示例如下：</p>

<pre><code class="language-go">func main() {
	var (
		name    string
		age     int
		married bool
	)
	fmt.Scanf(&quot;1:%s 2:%d 3:%t&quot;, &amp;name, &amp;age, &amp;married)
	fmt.Printf(&quot;扫描结果 name:%s age:%d married:%t \n&quot;, name, age, married)
}
</code></pre>

<p>将上面的代码编译后在终端执行，在终端按照指定的格式依次输入<code>小王子</code>、<code>28</code>和<code>false</code>。</p>

<pre><code class="language-bash">$ ./scan_demo 
1:小王子 2:28 3:false
扫描结果 name:小王子 age:28 married:false 
</code></pre>

<p><code>fmt.Scanf</code>不同于<code>fmt.Scan</code>简单的以空格作为输入数据的分隔符，<code>fmt.Scanf</code>为输入数据指定了具体的输入内容格式，只有按照格式输入数据才会被扫描并存入对应变量。</p>

<p>例如，我们还是按照上个示例中以空格分隔的方式输入，<code>fmt.Scanf</code>就不能正确扫描到输入的数据。</p>

<pre><code class="language-bash">$ ./scan_demo 
小王子 28 false
扫描结果 name: age:0 married:false 
</code></pre>

<h4 id="fmt-scanln">fmt.Scanln</h4>

<p>函数签名如下：</p>

<pre><code class="language-go">func Scanln(a ...interface{}) (n int, err error)
</code></pre>

<ul>
<li>Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。</li>
<li>本函数返回成功扫描的数据个数和遇到的任何错误。</li>
</ul>

<p>具体代码示例如下：</p>

<pre><code class="language-go">func main() {
	var (
		name    string
		age     int
		married bool
	)
	fmt.Scanln(&amp;name, &amp;age, &amp;married)
	fmt.Printf(&quot;扫描结果 name:%s age:%d married:%t \n&quot;, name, age, married)
}
</code></pre>

<p>将上面的代码编译后在终端执行，在终端依次输入<code>小王子</code>、<code>28</code>和<code>false</code>使用空格分隔。</p>

<pre><code class="language-bash">$ ./scan_demo 
小王子 28 false
扫描结果 name:小王子 age:28 married:false 
</code></pre>

<p><code>fmt.Scanln</code>遇到回车就结束扫描了，这个比较常用。</p>

<h4 id="bufio-newreader">bufio.NewReader</h4>

<p>有时候我们想完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用<code>bufio</code>包来实现。示例代码如下：</p>

<pre><code class="language-go">func bufioDemo() {
	reader := bufio.NewReader(os.Stdin) // 从标准输入生成读对象
	fmt.Print(&quot;请输入内容：&quot;)
	text, _ := reader.ReadString('\n') // 读到换行
	text = strings.TrimSpace(text)
	fmt.Printf(&quot;%#v\n&quot;, text)
}
</code></pre>

<h4 id="fscan系列">Fscan系列</h4>

<p>这几个函数功能分别类似于<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，只不过它们不是从标准输入中读取数据而是从<code>io.Reader</code>中读取数据。</p>

<pre><code class="language-go">func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
</code></pre>

<h4 id="sscan系列">Sscan系列</h4>

<p>这几个函数功能分别类似于<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，只不过它们不是从标准输入中读取数据而是从指定字符串中读取数据。</p>

<pre><code class="language-go">func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
</code></pre>

<h2 id="go语言基础之time包">Go语言基础之time包</h2>

<p>我们在编程中经常会用到时间和日期数据，本文主要介绍了Go语言内置的time包的基本用法。</p>

<h2 id="time包">time包</h2>

<p>时间和日期是我们编程中经常会用到的，本文主要介绍了 Go 语言内置的 time 包的基本用法。time 包提供了一些关于时间显示和测量用的函数。time 包中日历的计算采用的是公历，不考虑润秒。</p>

<h3 id="时间类型">时间类型</h3>

<p>Go 语言中使用<code>time.Time</code>类型表示时间。我们可以通过<code>time.Now</code>函数获取当前的时间对象，然后从时间对象中可以获取到年、月、日、时、分、秒等信息。</p>

<pre><code class="language-go">// timeDemo 时间对象的年月日时分秒
func timeDemo() {
	now := time.Now() // 获取当前时间
	fmt.Printf(&quot;current time:%v\n&quot;, now)

	year := now.Year()     // 年
	month := now.Month()   // 月
	day := now.Day()       // 日
	hour := now.Hour()     // 小时
	minute := now.Minute() // 分钟
	second := now.Second() // 秒
	fmt.Println(year, month, day, hour, minute, second)
}
</code></pre>

<h3 id="location和time-zone">Location和time zone</h3>

<p>Go 语言中使用 location 来映射具体的时区。时区（Time Zone）是根据世界各国家与地区不同的经度而划分的时间定义，全球共分为24个时区。中国差不多跨5个时区，但为了使用方便只用东八时区的标准时即北京时间为准。</p>

<p>下面的示例代码中使用<code>beijing</code>来表示东八区8小时的偏移量，其中time.FixedZone<code>和</code>time.LoadLocation`这两个函数则是用来获取location信息。</p>

<pre><code class="language-go">// timezoneDemo 时区示例
func timezoneDemo() {
	// 中国没有夏令时，使用一个固定的8小时的UTC时差。
	// 对于很多其他国家需要考虑夏令时。
	secondsEastOfUTC := int((8 * time.Hour).Seconds())
	// FixedZone 返回始终使用给定区域名称和偏移量(UTC 以东秒)的 Location。
	beijing := time.FixedZone(&quot;Beijing Time&quot;, secondsEastOfUTC)

	// 如果当前系统有时区数据库，则可以加载一个位置得到对应的时区
	// 例如，加载纽约所在的时区
	newYork, err := time.LoadLocation(&quot;America/New_York&quot;) // UTC-05:00
	if err != nil {
		fmt.Println(&quot;load America/New_York location failed&quot;, err)
		return
	}
	fmt.Println()
	// 加载上海所在的时区
	//shanghai, err := time.LoadLocation(&quot;Asia/Shanghai&quot;) // UTC+08:00
	// 加载东京所在的时区
	//tokyo, err := time.LoadLocation(&quot;Asia/Tokyo&quot;) // UTC+09:00

	// 创建时间对象需要指定位置。常用的位置是 time.Local（当地时间） 和 time.UTC（UTC时间）。
	//timeInLocal := time.Date(2009, 1, 1, 20, 0, 0, 0, time.Local)  // 系统本地时间
	timeInUTC := time.Date(2009, 1, 1, 12, 0, 0, 0, time.UTC)
	sameTimeInBeijing := time.Date(2009, 1, 1, 20, 0, 0, 0, beijing)
	sameTimeInNewYork := time.Date(2009, 1, 1, 7, 0, 0, 0, newYork)

	// 北京时间（东八区）比UTC早8小时，所以上面两个时间看似差了8小时，但表示的是同一个时间
	timesAreEqual := timeInUTC.Equal(sameTimeInBeijing)
	fmt.Println(timesAreEqual)

	// 纽约（西五区）比UTC晚5小时，所以上面两个时间看似差了5小时，但表示的是同一个时间
	timesAreEqual = timeInUTC.Equal(sameTimeInNewYork)
	fmt.Println(timesAreEqual)
}
</code></pre>

<p>在日常编码过程中使用时间对象的时候一定要注意其时区信息。</p>

<h3 id="unix-time">Unix Time</h3>

<p>Unix Time是自1970年1月1日 00:00:00 UTC 至当前时间经过的总秒数。下面的代码片段演示了如何基于时间对象获取到Unix 时间。</p>

<pre><code class="language-go">// timestampDemo 时间戳
func timestampDemo() {
	now := time.Now()        // 获取当前时间
	timestamp := now.Unix()  // 秒级时间戳
	milli := now.UnixMilli() // 毫秒时间戳 Go1.17+
	micro := now.UnixMicro() // 微秒时间戳 Go1.17+
	nano := now.UnixNano()   // 纳秒时间戳
	fmt.Println(timestamp, milli, micro, nano)
}
</code></pre>

<p>time 包还提供了一系列将 int64 类型的时间戳转换为时间对象的方法。</p>

<pre><code class="language-go">// timestamp2Time 将时间戳转为时间对象
func timestamp2Time() {
	// 获取北京时间所在的东八区时区对象
	secondsEastOfUTC := int((8 * time.Hour).Seconds())
	beijing := time.FixedZone(&quot;Beijing Time&quot;, secondsEastOfUTC)

	// 北京时间 2022-02-22 22:22:22.000000022 +0800 CST
	t := time.Date(2022, 02, 22, 22, 22, 22, 22, beijing)

	var (
		sec  = t.Unix()
		msec = t.UnixMilli()
		usec = t.UnixMicro()
	)

	// 将秒级时间戳转为时间对象（第二个参数为不足1秒的纳秒数）
	timeObj := time.Unix(sec, 22)
	fmt.Println(timeObj)           // 2022-02-22 22:22:22.000000022 +0800 CST
	timeObj = time.UnixMilli(msec) // 毫秒级时间戳转为时间对象
	fmt.Println(timeObj)           // 2022-02-22 22:22:22 +0800 CST
	timeObj = time.UnixMicro(usec) // 微秒级时间戳转为时间对象
	fmt.Println(timeObj)           // 2022-02-22 22:22:22 +0800 CST
}
</code></pre>

<h3 id="时间间隔">时间间隔</h3>

<p><code>time.Duration</code>是<code>time</code>包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。<code>time.Duration</code>表示一段时间间隔，可表示的最长时间段大约290年。</p>

<p>time 包中定义的时间间隔类型的常量如下：</p>

<pre><code class="language-go">const (
    Nanosecond  Duration = 1
    Microsecond          = 1000 * Nanosecond
    Millisecond          = 1000 * Microsecond
    Second               = 1000 * Millisecond
    Minute               = 60 * Second
    Hour                 = 60 * Minute
)
</code></pre>

<p>例如：<code>time.Duration</code>表示1纳秒，<code>time.Second</code>表示1秒。</p>

<h4 id="时间操作">时间操作</h4>

<h4 id="add">Add</h4>

<p>Go语言的时间对象有提供Add方法如下：</p>

<pre><code class="language-go">func (t Time) Add(d Duration) Time
</code></pre>

<p>举个例子，求一个小时之后的时间：</p>

<pre><code class="language-go">func main() {
	now := time.Now()
	later := now.Add(time.Hour) // 当前时间加1小时后的时间
	fmt.Println(later)
}
</code></pre>

<h4 id="sub">Sub</h4>

<p>求两个时间之间的差值：</p>

<pre><code class="language-go">func (t Time) Sub(u Time) Duration
</code></pre>

<p>返回一个时间段t-u。如果结果超出了Duration可以表示的最大值/最小值，将返回最大值/最小值。要获取时间点t-d（d为Duration），可以使用t.Add(-d)。</p>

<h4 id="equal">Equal</h4>

<pre><code class="language-go">func (t Time) Equal(u Time) bool
</code></pre>

<p>判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较。本方法和用t==u不同，这种方法还会比较地点和时区信息。</p>

<h4 id="before">Before</h4>

<pre><code class="language-go">func (t Time) Before(u Time) bool
</code></pre>

<p>如果t代表的时间点在u之前，返回真；否则返回假。</p>

<h4 id="after">After</h4>

<pre><code class="language-go">func (t Time) After(u Time) bool
</code></pre>

<p>如果t代表的时间点在u之后，返回真；否则返回假。</p>

<h3 id="定时器">定时器</h3>

<p>使用<code>time.Tick(时间间隔)</code>来设置定时器，定时器的本质上是一个通道（channel）。</p>

<pre><code class="language-go">func tickDemo() {
	ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器
	for i := range ticker {
		fmt.Println(i)//每秒都会执行的任务
	}
}
</code></pre>

<h3 id="时间格式化">时间格式化</h3>

<p><code>time.Format</code>函数能够将一个时间对象格式化输出为指定布局的文本表示形式，需要注意的是 Go 语言中时间格式化的布局不是常见的<code>Y-m-d H:M:S</code>，而是使用 <code>2006-01-02 15:04:05.000</code>（记忆口诀为2006 1 2 3 4 5）。</p>

<p>其中：</p>

<ul>
<li>2006：年（Y）</li>
<li>01：月（m）</li>
<li>02：日（d）</li>
<li>15：时（H）</li>
<li>04：分（M）</li>
<li>05：秒（S）</li>
</ul>

<p><strong>补充</strong></p>

<ul>
<li>如果想格式化为12小时格式，需在格式化布局中添加<code>PM</code>。</li>

<li><p>小数部分想保留指定位数就写0，如果想省略末尾可能的0就写 9。</p>

<pre><code class="language-go">// formatDemo 时间格式化
func formatDemo() {
	now := time.Now()
	// 格式化的模板为 2006-01-02 15:04:05

	// 24小时制
	fmt.Println(now.Format(&quot;2006-01-02 15:04:05.000 Mon Jan&quot;))
	// 12小时制
	fmt.Println(now.Format(&quot;2006-01-02 03:04:05.000 PM Mon Jan&quot;))

	// 小数点后写0，因为有3个0所以格式化输出的结果也保留3位小数
	fmt.Println(now.Format(&quot;2006/01/02 15:04:05.000&quot;)) // 2022/02/27 00:10:42.960
	// 小数点后写9，会省略末尾可能出现的0
	fmt.Println(now.Format(&quot;2006/01/02 15:04:05.999&quot;)) // 2022/02/27 00:10:42.96

	// 只格式化时分秒部分
	fmt.Println(now.Format(&quot;15:04:05&quot;))
	// 只格式化日期部分
	fmt.Println(now.Format(&quot;2006.01.02&quot;))
}
</code></pre></li>
</ul>

<h3 id="解析字符串格式的时间">解析字符串格式的时间</h3>

<p>对于从文本的时间表示中解析出时间对象，<code>time</code>包中提供了<code>time.Parse</code>和<code>time.ParseInLocation</code>两个函数。</p>

<p>其中<code>time.Parse</code>在解析时不需要额外指定时区信息。</p>

<pre><code class="language-go">// parseDemo 指定时区解析时间
func parseDemo() {
	// 在没有时区指示符的情况下，time.Parse 返回UTC时间
	timeObj, err := time.Parse(&quot;2006/01/02 15:04:05&quot;, &quot;2022/10/05 11:25:20&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(timeObj) // 2022-10-05 11:25:20 +0000 UTC

	// 在有时区指示符的情况下，time.Parse 返回对应时区的时间表示
	// RFC3339     = &quot;2006-01-02T15:04:05Z07:00&quot;
	timeObj, err = time.Parse(time.RFC3339, &quot;2022-10-05T11:25:20+08:00&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(timeObj) // 2022-10-05 11:25:20 +0800 CST
}
</code></pre>

<p><code>time.ParseInLocation</code>函数需要在解析时额外指定时区信息。</p>

<pre><code class="language-go">// parseDemo 解析时间
func parseDemo() {
	now := time.Now()
	fmt.Println(now)
	// 加载时区
	loc, err := time.LoadLocation(&quot;Asia/Shanghai&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	// 按照指定时区和指定格式解析字符串时间
	timeObj, err := time.ParseInLocation(&quot;2006/01/02 15:04:05&quot;, &quot;2022/10/05 11:25:20&quot;, loc)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(timeObj)
	fmt.Println(timeObj.Sub(now))
}
</code></pre>

<h3 id="练习题-9">练习题</h3>

<ol>
<li>获取当前时间，格式化输出为<code>2017/06/19 20:30:05</code>格式。</li>
<li>编写程序统计一段代码的执行耗时时间，单位精确到微秒。</li>
</ol>

<h2 id="go语言标准库flag基本使用">Go语言标准库flag基本使用</h2>

<p>Go语言内置的<code>flag</code>包实现了命令行参数的解析，<code>flag</code>包使得开发命令行工具更为简单。</p>

<h2 id="os-args">os.Args</h2>

<p>如果你只是简单的想要获取命令行参数，可以像下面的代码示例一样使用<code>os.Args</code>来获取命令行参数。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
)

//os.Args demo
func main() {
	//os.Args是一个[]string
	if len(os.Args) &gt; 0 {
		for index, arg := range os.Args {
			fmt.Printf(&quot;args[%d]=%v\n&quot;, index, arg)
		}
	}
}
</code></pre>

<p>将上面的代码执行<code>go build -o &quot;args_demo&quot;</code>编译之后，执行：</p>

<pre><code class="language-bash">$ ./args_demo a b c d
args[0]=./args_demo
args[1]=a
args[2]=b
args[3]=c
args[4]=d
</code></pre>

<p><code>os.Args</code>是一个存储命令行参数的字符串切片，它的第一个元素是执行文件的名称。</p>

<h2 id="flag包基本使用">flag包基本使用</h2>

<p>本文介绍了flag包的常用函数和基本用法，更详细的内容请查看<a href="https://studygolang.com/pkgdoc">官方文档</a>。</p>

<h3 id="导入flag包">导入flag包</h3>

<pre><code class="language-go">import flag
</code></pre>

<h3 id="flag参数类型">flag参数类型</h3>

<p>flag包支持的命令行参数类型有<code>bool</code>、<code>int</code>、<code>int64</code>、<code>uint</code>、<code>uint64</code>、<code>float</code> <code>float64</code>、<code>string</code>、<code>duration</code>。</p>

<table>
<thead>
<tr>
<th align="center">flag参数</th>
<th align="center">有效值</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">字符串flag</td>
<td align="center">合法字符串</td>
</tr>

<tr>
<td align="center">整数flag</td>
<td align="center">1234、0664、0x1234等类型，也可以是负数。</td>
</tr>

<tr>
<td align="center">浮点数flag</td>
<td align="center">合法浮点数</td>
</tr>

<tr>
<td align="center">bool类型flag</td>
<td align="center">1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。</td>
</tr>

<tr>
<td align="center">时间段flag</td>
<td align="center">任何合法的时间段字符串。如”300ms”、”-1.5h”、”2h45m”。 合法的单位有”ns”、”us” /“µs”、”ms”、”s”、”m”、”h”。</td>
</tr>
</tbody>
</table>

<h3 id="定义命令行flag参数">定义命令行flag参数</h3>

<p>有以下两种常用的定义命令行<code>flag</code>参数的方法。</p>

<h4 id="flag-type">flag.Type()</h4>

<p>基本格式如下：</p>

<p><code>flag.Type(flag名, 默认值, 帮助信息)*Type</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p>

<pre><code class="language-go">name := flag.String(&quot;name&quot;, &quot;张三&quot;, &quot;姓名&quot;)
age := flag.Int(&quot;age&quot;, 18, &quot;年龄&quot;)
married := flag.Bool(&quot;married&quot;, false, &quot;婚否&quot;)
delay := flag.Duration(&quot;d&quot;, 0, &quot;时间间隔&quot;)
</code></pre>

<p>需要注意的是，此时<code>name</code>、<code>age</code>、<code>married</code>、<code>delay</code>均为对应类型的指针。</p>

<h4 id="flag-typevar">flag.TypeVar()</h4>

<p>基本格式如下： <code>flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p>

<pre><code class="language-go">var name string
var age int
var married bool
var delay time.Duration
flag.StringVar(&amp;name, &quot;name&quot;, &quot;张三&quot;, &quot;姓名&quot;)
flag.IntVar(&amp;age, &quot;age&quot;, 18, &quot;年龄&quot;)
flag.BoolVar(&amp;married, &quot;married&quot;, false, &quot;婚否&quot;)
flag.DurationVar(&amp;delay, &quot;d&quot;, 0, &quot;时间间隔&quot;)
</code></pre>

<h3 id="flag-parse">flag.Parse()</h3>

<p>通过以上两种方法定义好命令行flag参数后，需要通过调用<code>flag.Parse()</code>来对命令行参数进行解析。</p>

<p>支持的命令行参数格式有以下几种：</p>

<ul>
<li><code>-flag xxx</code> （使用空格，一个<code>-</code>符号）</li>
<li><code>--flag xxx</code> （使用空格，两个<code>-</code>符号）</li>
<li><code>-flag=xxx</code> （使用等号，一个<code>-</code>符号）</li>
<li><code>--flag=xxx</code> （使用等号，两个<code>-</code>符号）</li>
</ul>

<p>其中，布尔类型的参数必须使用等号的方式指定。</p>

<p>Flag解析在第一个非flag参数（单个”-“不是flag参数）之前停止，或者在终止符”–“之后停止。</p>

<h3 id="flag其他函数">flag其他函数</h3>

<pre><code class="language-go">flag.Args()  ////返回命令行参数后的其他参数，以[]string类型
flag.NArg()  //返回命令行参数后的其他参数个数
flag.NFlag() //返回使用的命令行参数个数
</code></pre>

<h3 id="完整示例">完整示例</h3>

<h4 id="定义">定义</h4>

<pre><code class="language-go">func main() {
	//定义命令行参数方式1
	var name string
	var age int
	var married bool
	var delay time.Duration
	flag.StringVar(&amp;name, &quot;name&quot;, &quot;张三&quot;, &quot;姓名&quot;)
	flag.IntVar(&amp;age, &quot;age&quot;, 18, &quot;年龄&quot;)
	flag.BoolVar(&amp;married, &quot;married&quot;, false, &quot;婚否&quot;)
	flag.DurationVar(&amp;delay, &quot;d&quot;, 0, &quot;延迟的时间间隔&quot;)

	//解析命令行参数
	flag.Parse()
	fmt.Println(name, age, married, delay)
	//返回命令行参数后的其他参数
	fmt.Println(flag.Args())
	//返回命令行参数后的其他参数个数
	fmt.Println(flag.NArg())
	//返回使用的命令行参数个数
	fmt.Println(flag.NFlag())
}
</code></pre>

<h4 id="使用">使用</h4>

<p>命令行参数使用提示：</p>

<pre><code class="language-bash">$ ./flag_demo -help
Usage of ./flag_demo:
  -age int
        年龄 (default 18)
  -d duration
        时间间隔
  -married
        婚否
  -name string
        姓名 (default &quot;张三&quot;)
</code></pre>

<p>正常使用命令行flag参数：</p>

<pre><code class="language-bash">$ ./flag_demo -name 沙河娜扎 --age 28 -married=false -d=1h30m
沙河娜扎 28 false 1h30m0s
[]
0
4
</code></pre>

<p>使用非flag命令行参数：</p>

<pre><code class="language-bash">$ ./flag_demo a b c
张三 18 false 0s
[a b c]
3
0
</code></pre>

<h2 id="go语言标准库log介绍">Go语言标准库log介绍</h2>

<p>无论是软件开发的调试阶段还是软件上线之后的运行阶段，日志一直都是非常重要的一个环节，我们也应该养成在程序中记录日志的好习惯。</p>

<h2 id="log">log</h2>

<p>Go语言内置的<code>log</code>包实现了简单的日志服务。本文介绍了标准库<code>log</code>的基本使用。</p>

<h3 id="使用logger">使用Logger</h3>

<p>log包定义了Logger类型，该类型提供了一些格式化输出的方法。本包也提供了一个预定义的“标准”logger，可以通过调用函数<code>Print系列</code>(Print|Printf|Println）、<code>Fatal系列</code>（Fatal|Fatalf|Fatalln）、和<code>Panic系列</code>（Panic|Panicf|Panicln）来使用，比自行创建一个logger对象更容易使用。</p>

<p>例如，我们可以像下面的代码一样直接通过<code>log</code>包来调用上面提到的方法，默认它们会将日志信息打印到终端界面：</p>

<pre><code class="language-go">package main

import (
	&quot;log&quot;
)

func main() {
	log.Println(&quot;这是一条很普通的日志。&quot;)
	v := &quot;很普通的&quot;
	log.Printf(&quot;这是一条%s日志。\n&quot;, v)
	log.Fatalln(&quot;这是一条会触发fatal的日志。&quot;)
	log.Panicln(&quot;这是一条会触发panic的日志。&quot;)
}
</code></pre>

<p>编译并执行上面的代码会得到如下输出：</p>

<pre><code class="language-bash">2017/06/19 14:04:17 这是一条很普通的日志。
2017/06/19 14:04:17 这是一条很普通的日志。
2017/06/19 14:04:17 这是一条会触发fatal的日志。
</code></pre>

<p>logger会打印每条日志信息的日期、时间，默认输出到系统的标准错误。Fatal系列函数会在写入日志信息后调用os.Exit(1)。Panic系列函数会在写入日志信息后panic。</p>

<h3 id="配置logger">配置logger</h3>

<h4 id="标准logger的配置">标准logger的配置</h4>

<p>默认情况下的logger只会提供日志的时间信息，但是很多情况下我们希望得到更多信息，比如记录该日志的文件名和行号等。<code>log</code>标准库中为我们提供了定制这些设置的方法。</p>

<p><code>log</code>标准库中的<code>Flags</code>函数会返回标准logger的输出配置，而<code>SetFlags</code>函数用来设置标准logger的输出配置。</p>

<pre><code class="language-go">func Flags() int
func SetFlags(flag int)
</code></pre>

<h4 id="flag选项">flag选项</h4>

<p><code>log</code>标准库提供了如下的flag选项，它们是一系列定义好的常量。</p>

<pre><code class="language-go">const (
    // 控制输出日志信息的细节，不能控制输出的顺序和格式。
    // 输出的日志在每一项后会有一个冒号分隔：例如2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    Ldate         = 1 &lt;&lt; iota     // 日期：2009/01/23
    Ltime                         // 时间：01:23:23
    Lmicroseconds                 // 微秒级别的时间：01:23:23.123123（用于增强Ltime位）
    Llongfile                     // 文件全路径名+行号： /a/b/c/d.go:23
    Lshortfile                    // 文件名+行号：d.go:23（会覆盖掉Llongfile）
    LUTC                          // 使用UTC时间
    LstdFlags     = Ldate | Ltime // 标准logger的初始值
)
</code></pre>

<p>下面我们在记录日志之前先设置一下标准logger的输出选项如下：</p>

<pre><code class="language-go">func main() {
	log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)
	log.Println(&quot;这是一条很普通的日志。&quot;)
}
</code></pre>

<p>编译执行后得到的输出结果如下：</p>

<pre><code class="language-go">2017/06/19 14:05:17.494943 .../log_demo/main.go:11: 这是一条很普通的日志。
</code></pre>

<h4 id="配置日志前缀">配置日志前缀</h4>

<p><code>log</code>标准库中还提供了关于日志信息前缀的两个方法：</p>

<pre><code class="language-go">func Prefix() string
func SetPrefix(prefix string)
</code></pre>

<p>其中<code>Prefix</code>函数用来查看标准logger的输出前缀，<code>SetPrefix</code>函数用来设置输出前缀。</p>

<pre><code class="language-go">func main() {
	log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)
	log.Println(&quot;这是一条很普通的日志。&quot;)
	log.SetPrefix(&quot;[小王子]&quot;)
	log.Println(&quot;这是一条很普通的日志。&quot;)
}
</code></pre>

<p>上面的代码输出如下：</p>

<pre><code class="language-bash">[小王子]2017/06/19 14:05:57.940542 .../log_demo/main.go:13: 这是一条很普通的日志。
</code></pre>

<p>这样我们就能够在代码中为我们的日志信息添加指定的前缀，方便之后对日志信息进行检索和处理。</p>

<h4 id="配置日志输出位置">配置日志输出位置</h4>

<pre><code class="language-go">func SetOutput(w io.Writer)
</code></pre>

<p><code>SetOutput</code>函数用来设置标准logger的输出目的地，默认是标准错误输出。</p>

<p>例如，下面的代码会把日志输出到同目录下的<code>xx.log</code>文件中。</p>

<pre><code class="language-go">func main() {
	logFile, err := os.OpenFile(&quot;./xx.log&quot;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		fmt.Println(&quot;open log file failed, err:&quot;, err)
		return
	}
	log.SetOutput(logFile)
	log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)
	log.Println(&quot;这是一条很普通的日志。&quot;)
	log.SetPrefix(&quot;[小王子]&quot;)
	log.Println(&quot;这是一条很普通的日志。&quot;)
}
</code></pre>

<p>如果你要使用标准的logger，我们通常会把上面的配置操作写到<code>init</code>函数中。</p>

<pre><code class="language-go">func init() {
	logFile, err := os.OpenFile(&quot;./xx.log&quot;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		fmt.Println(&quot;open log file failed, err:&quot;, err)
		return
	}
	log.SetOutput(logFile)
	log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)
}
</code></pre>

<h3 id="创建logger">创建logger</h3>

<p><code>log</code>标准库中还提供了一个创建新logger对象的构造函数–<code>New</code>，支持我们创建自己的logger示例。<code>New</code>函数的签名如下：</p>

<pre><code class="language-go">func New(out io.Writer, prefix string, flag int) *Logger
</code></pre>

<p>New创建一个Logger对象。其中，参数out设置日志信息写入的目的地。参数prefix会添加到生成的每一条日志前面。参数flag定义日志的属性（时间、文件等等）。</p>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	logger := log.New(os.Stdout, &quot;&lt;New&gt;&quot;, log.Lshortfile|log.Ldate|log.Ltime)
	logger.Println(&quot;这是自定义的logger记录的日志。&quot;)
}
</code></pre>

<p>将上面的代码编译执行之后，得到结果如下：</p>

<pre><code class="language-bash">&lt;New&gt;2017/06/19 14:06:51 main.go:34: 这是自定义的logger记录的日志。
</code></pre>

<h3 id="总结">总结</h3>

<p>Go内置的log库功能有限，例如无法满足记录不同级别日志的情况，我们在实际的项目中根据自己的需要选择使用第三方的日志库，如<a href="https://github.com/sirupsen/logrus">logrus</a>、<a href="https://github.com/uber-go/zap">zap</a>等。</p>

<h2 id="go语言文件操作">Go语言文件操作</h2>

<p>本文主要介绍了Go语言中文件读写的相关操作。</p>

<p>文件是什么？</p>

<p>计算机中的文件是存储在外部介质（通常是磁盘）上的数据集合，文件分为文本文件和二进制文件。</p>

<h2 id="打开和关闭文件">打开和关闭文件</h2>

<p><code>os.Open()</code>函数能够打开一个文件，返回一个<code>*File</code>和一个<code>err</code>。对得到的文件实例调用<code>close()</code>方法能够关闭文件。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	// 只读方式打开当前目录下的main.go文件
	file, err := os.Open(&quot;./main.go&quot;)
	if err != nil {
		fmt.Println(&quot;open file failed!, err:&quot;, err)
		return
	}
	// 关闭文件
	file.Close()
}
</code></pre>

<p>为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句。</p>

<h2 id="读取文件">读取文件</h2>

<h3 id="file-read">file.Read()</h3>

<h4 id="基本使用">基本使用</h4>

<p>Read方法定义如下：</p>

<pre><code class="language-go">func (f *File) Read(b []byte) (n int, err error)
</code></pre>

<p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回<code>0</code>和<code>io.EOF</code>。 举个例子：</p>

<pre><code class="language-go">func main() {
	// 只读方式打开当前目录下的main.go文件
	file, err := os.Open(&quot;./main.go&quot;)
	if err != nil {
		fmt.Println(&quot;open file failed!, err:&quot;, err)
		return
	}
	defer file.Close()
	// 使用Read方法读取数据
	var tmp = make([]byte, 128)
	n, err := file.Read(tmp)
	if err == io.EOF {
		fmt.Println(&quot;文件读完了&quot;)
		return
	}
	if err != nil {
		fmt.Println(&quot;read file failed, err:&quot;, err)
		return
	}
	fmt.Printf(&quot;读取了%d字节数据\n&quot;, n)
	fmt.Println(string(tmp[:n]))
}
</code></pre>

<h4 id="循环读取">循环读取</h4>

<p>使用for循环读取文件中的所有数据。</p>

<pre><code class="language-go">func main() {
	// 只读方式打开当前目录下的main.go文件
	file, err := os.Open(&quot;./main.go&quot;)
	if err != nil {
		fmt.Println(&quot;open file failed!, err:&quot;, err)
		return
	}
	defer file.Close()
	// 循环读取文件
	var content []byte
	var tmp = make([]byte, 128)
	for {
		n, err := file.Read(tmp)
		if err == io.EOF {
			fmt.Println(&quot;文件读完了&quot;)
			break
		}
		if err != nil {
			fmt.Println(&quot;read file failed, err:&quot;, err)
			return
		}
		content = append(content, tmp[:n]...)
	}
	fmt.Println(string(content))
}
</code></pre>

<h3 id="bufio读取文件">bufio读取文件</h3>

<p>bufio是在file的基础上封装了一层API，支持更多的功能。</p>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
)

// bufio按行读取示例
func main() {
	file, err := os.Open(&quot;./xx.txt&quot;)
	if err != nil {
		fmt.Println(&quot;open file failed, err:&quot;, err)
		return
	}
	defer file.Close()
	reader := bufio.NewReader(file)
	for {
		line, err := reader.ReadString('\n') //注意是字符
		if err == io.EOF {
			if len(line) != 0 {
				fmt.Println(line)
			}
			fmt.Println(&quot;文件读完了&quot;)
			break
		}
		if err != nil {
			fmt.Println(&quot;read file failed, err:&quot;, err)
			return
		}
		fmt.Print(line)
	}
}
</code></pre>

<h3 id="ioutil读取整个文件">ioutil读取整个文件</h3>

<p><code>io/ioutil</code>包的<code>ReadFile</code>方法能够读取完整的文件，只需要将文件名作为参数传入。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
)

// ioutil.ReadFile读取整个文件
func main() {
	content, err := ioutil.ReadFile(&quot;./main.go&quot;)
	if err != nil {
		fmt.Println(&quot;read file failed, err:&quot;, err)
		return
	}
	fmt.Println(string(content))
}
</code></pre>

<h2 id="文件写入操作">文件写入操作</h2>

<p><code>os.OpenFile()</code>函数能够以指定模式打开文件，从而实现文件写入相关功能。</p>

<pre><code class="language-go">func OpenFile(name string, flag int, perm FileMode) (*File, error) {
	...
}
</code></pre>

<p>其中：</p>

<p><code>name</code>：要打开的文件名 <code>flag</code>：打开文件的模式。 模式有以下几种：</p>

<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">含义</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><code>os.O_WRONLY</code></td>
<td align="center">只写</td>
</tr>

<tr>
<td align="center"><code>os.O_CREATE</code></td>
<td align="center">创建文件</td>
</tr>

<tr>
<td align="center"><code>os.O_RDONLY</code></td>
<td align="center">只读</td>
</tr>

<tr>
<td align="center"><code>os.O_RDWR</code></td>
<td align="center">读写</td>
</tr>

<tr>
<td align="center"><code>os.O_TRUNC</code></td>
<td align="center">清空</td>
</tr>

<tr>
<td align="center"><code>os.O_APPEND</code></td>
<td align="center">追加</td>
</tr>
</tbody>
</table>

<p><code>perm</code>：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。</p>

<h3 id="write和writestring">Write和WriteString</h3>

<pre><code class="language-go">func main() {
	file, err := os.OpenFile(&quot;xx.txt&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		fmt.Println(&quot;open file failed, err:&quot;, err)
		return
	}
	defer file.Close()
	str := &quot;hello 沙河&quot;
	file.Write([]byte(str))       //写入字节切片数据
	file.WriteString(&quot;hello 小王子&quot;) //直接写入字符串数据
}
</code></pre>

<h3 id="bufio-newwriter">bufio.NewWriter</h3>

<pre><code class="language-go">func main() {
	file, err := os.OpenFile(&quot;xx.txt&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		fmt.Println(&quot;open file failed, err:&quot;, err)
		return
	}
	defer file.Close()
	writer := bufio.NewWriter(file)
	for i := 0; i &lt; 10; i++ {
		writer.WriteString(&quot;hello沙河\n&quot;) //将数据先写入缓存
	}
	writer.Flush() //将缓存中的内容写入文件
}
</code></pre>

<h3 id="ioutil-writefile">ioutil.WriteFile</h3>

<pre><code class="language-go">func main() {
	str := &quot;hello 沙河&quot;
	err := ioutil.WriteFile(&quot;./xx.txt&quot;, []byte(str), 0666)
	if err != nil {
		fmt.Println(&quot;write file failed, err:&quot;, err)
		return
	}
}
</code></pre>

<h2 id="练习">练习</h2>

<h3 id="copyfile">copyFile</h3>

<p>借助<code>io.Copy()</code>实现一个拷贝文件函数。</p>

<pre><code class="language-go">// CopyFile 拷贝文件函数
func CopyFile(dstName, srcName string) (written int64, err error) {
	// 以读方式打开源文件
	src, err := os.Open(srcName)
	if err != nil {
		fmt.Printf(&quot;open %s failed, err:%v.\n&quot;, srcName, err)
		return
	}
	defer src.Close()
	// 以写|创建的方式打开目标文件
	dst, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, 0644)
	if err != nil {
		fmt.Printf(&quot;open %s failed, err:%v.\n&quot;, dstName, err)
		return
	}
	defer dst.Close()
	return io.Copy(dst, src) //调用io.Copy()拷贝内容
}
func main() {
	_, err := CopyFile(&quot;dst.txt&quot;, &quot;src.txt&quot;)
	if err != nil {
		fmt.Println(&quot;copy file failed, err:&quot;, err)
		return
	}
	fmt.Println(&quot;copy done!&quot;)
}
</code></pre>

<h3 id="实现一个cat命令">实现一个cat命令</h3>

<p>使用文件操作相关知识，模拟实现linux平台<code>cat</code>命令的功能。</p>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
)

// cat命令实现
func cat(r *bufio.Reader) {
	for {
		buf, err := r.ReadBytes('\n') //注意是字符
		if err == io.EOF {
			// 退出之前将已读到的内容输出
			fmt.Fprintf(os.Stdout, &quot;%s&quot;, buf)
			break
		}
		fmt.Fprintf(os.Stdout, &quot;%s&quot;, buf)
	}
}

func main() {
	flag.Parse() // 解析命令行参数
	if flag.NArg() == 0 {
		// 如果没有参数默认从标准输入读取内容
		cat(bufio.NewReader(os.Stdin))
	}
	// 依次读取每个指定文件的内容并打印到终端
	for i := 0; i &lt; flag.NArg(); i++ {
		f, err := os.Open(flag.Arg(i))
		if err != nil {
			fmt.Fprintf(os.Stdout, &quot;reading from %s failed, err:%v\n&quot;, flag.Arg(i), err)
			continue
		}
		cat(bufio.NewReader(f))
	}
}
</code></pre>

<h2 id="go语言内置包之strconv">Go语言内置包之strconv</h2>

<p>Go语言中<code>strconv</code>包实现了基本数据类型和其字符串表示的相互转换。</p>

<h2 id="strconv包">strconv包</h2>

<p>strconv包实现了基本数据类型与其字符串表示的转换，主要有以下常用函数： <code>Atoi()</code>、<code>Itoa()</code>、parse系列、format系列、append系列。</p>

<p>更多函数请查看<a href="https://golang.org/pkg/strconv/">官方文档</a>。</p>

<h3 id="string与int类型转换">string与int类型转换</h3>

<p>这一组函数是我们平时编程中用的最多的。</p>

<h4 id="atoi">Atoi()</h4>

<p><code>Atoi()</code>函数用于将字符串类型的整数转换为int类型，函数签名如下。</p>

<pre><code class="language-go">func Atoi(s string) (i int, err error)
</code></pre>

<p>如果传入的字符串参数无法转换为int类型，就会返回错误。</p>

<pre><code class="language-go">s1 := &quot;100&quot;
i1, err := strconv.Atoi(s1)
if err != nil {
	fmt.Println(&quot;can't convert to int&quot;)
} else {
	fmt.Printf(&quot;type:%T value:%#v\n&quot;, i1, i1) //type:int value:100
}
</code></pre>

<h4 id="itoa">Itoa()</h4>

<p><code>Itoa()</code>函数用于将int类型数据转换为对应的字符串表示，具体的函数签名如下。</p>

<pre><code class="language-go">func Itoa(i int) string
</code></pre>

<p>示例代码如下：</p>

<pre><code class="language-go">i2 := 200
s2 := strconv.Itoa(i2)
fmt.Printf(&quot;type:%T value:%#v\n&quot;, s2, s2) //type:string value:&quot;200&quot;
</code></pre>

<h4 id="a的典故">a的典故</h4>

<p>【扩展阅读】这是C语言遗留下的典故。C语言中没有string类型而是用字符数组(array)表示字符串，所以<code>Itoa</code>对很多C系的程序员很好理解。</p>

<h3 id="parse系列函数">Parse系列函数</h3>

<p>Parse类函数用于转换字符串为给定类型的值：ParseBool()、ParseFloat()、ParseInt()、ParseUint()。</p>

<h4 id="parsebool">ParseBool()</h4>

<pre><code class="language-go">func ParseBool(str string) (value bool, err error)
</code></pre>

<p>返回字符串表示的bool值。它接受1、0、t、f、T、F、true、false、True、False、TRUE、FALSE；否则返回错误。</p>

<h4 id="parseint">ParseInt()</h4>

<pre><code class="language-go">func ParseInt(s string, base int, bitSize int) (i int64, err error)
</code></pre>

<p>返回字符串表示的整数值，接受正负号。</p>

<p>base指定进制（2到36），如果base为0，则会从字符串前置判断，”0x”是16进制，”0”是8进制，否则是10进制；</p>

<p>bitSize指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64；</p>

<p>返回的err是*NumErr类型的，如果语法有误，err.Error = ErrSyntax；如果结果超出类型范围err.Error = ErrRange。</p>

<h4 id="parseunit">ParseUnit()</h4>

<pre><code class="language-go">func ParseUint(s string, base int, bitSize int) (n uint64, err error)
</code></pre>

<p><code>ParseUint</code>类似<code>ParseInt</code>但不接受正负号，用于无符号整型。</p>

<h4 id="parsefloat">ParseFloat()</h4>

<pre><code class="language-go">func ParseFloat(s string, bitSize int) (f float64, err error)
</code></pre>

<p>解析一个表示浮点数的字符串并返回其值。</p>

<p>如果s合乎语法规则，函数会返回最为接近s表示值的一个浮点数（使用IEEE754规范舍入）。</p>

<p>bitSize指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64；</p>

<p>返回值err是*NumErr类型的，语法有误的，err.Error=ErrSyntax；结果超出表示范围的，返回值f为±Inf，err.Error= ErrRange。</p>

<h4 id="代码示例">代码示例</h4>

<pre><code class="language-go">b, err := strconv.ParseBool(&quot;true&quot;)
f, err := strconv.ParseFloat(&quot;3.1415&quot;, 64)
i, err := strconv.ParseInt(&quot;-2&quot;, 10, 64)
u, err := strconv.ParseUint(&quot;2&quot;, 10, 64)
</code></pre>

<p>这些函数都有两个返回值，第一个返回值是转换后的值，第二个返回值为转化失败的错误信息。</p>

<h3 id="format系列函数">Format系列函数</h3>

<p>Format系列函数实现了将给定类型数据格式化为string类型数据的功能。</p>

<h4 id="formatbool">FormatBool()</h4>

<pre><code class="language-go">func FormatBool(b bool) string
</code></pre>

<p>根据b的值返回”true”或”false”。</p>

<h4 id="formatint">FormatInt()</h4>

<pre><code class="language-go">func FormatInt(i int64, base int) string
</code></pre>

<p>返回i的base进制的字符串表示。base 必须在2到36之间，结果中会使用小写字母’a’到’z’表示大于10的数字。</p>

<h4 id="formatuint">FormatUint()</h4>

<pre><code class="language-go">func FormatUint(i uint64, base int) string
</code></pre>

<p>是FormatInt的无符号整数版本。</p>

<h4 id="formatfloat">FormatFloat()</h4>

<pre><code class="language-go">func FormatFloat(f float64, fmt byte, prec, bitSize int) string
</code></pre>

<p>函数将浮点数表示为字符串并返回。</p>

<p>bitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。</p>

<p>fmt表示格式：’f’（-ddd.dddd）、’b’（-ddddp±ddd，指数为二进制）、’e’（-d.dddde±dd，十进制指数）、’E’（-d.ddddE±dd，十进制指数）、’g’（指数很大时用’e’格式，否则’f’格式）、’G’（指数很大时用’E’格式，否则’f’格式）。</p>

<p>prec控制精度（排除指数部分）：对’f’、’e’、’E’，它表示小数点后的数字个数；对’g’、’G’，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。</p>

<h4 id="代码示例-1">代码示例</h4>

<pre><code class="language-go">s1 := strconv.FormatBool(true)
s2 := strconv.FormatFloat(3.1415, 'E', -1, 64)
s3 := strconv.FormatInt(-2, 16)
s4 := strconv.FormatUint(2, 16)
</code></pre>

<h3 id="其他">其他</h3>

<h4 id="isprint">isPrint()</h4>

<pre><code class="language-go">func IsPrint(r rune) bool
</code></pre>

<p>返回一个字符是否是可打印的，和<code>unicode.IsPrint</code>一样，r必须是：字母（广义）、数字、标点、符号、ASCII空格。</p>

<h4 id="canbackquote">CanBackquote()</h4>

<pre><code class="language-go">func CanBackquote(s string) bool
</code></pre>

<p>返回字符串s是否可以不被修改的表示为一个单行的、没有空格和tab之外控制字符的反引号字符串。</p>

<h4 id="其他-1">其他</h4>

<p>除上文列出的函数外，<code>strconv</code>包中还有Append系列、Quote系列等函数。具体用法可查看<a href="https://golang.org/pkg/strconv/">官方文档</a>。</p>

<h2 id="go语言基础之net-http">Go语言基础之net/http</h2>

<p>Go语言内置的<code>net/http</code>包十分的优秀，提供了HTTP客户端和服务端的实现。</p>

<h3 id="net-http介绍">net/http介绍</h3>

<p>Go语言内置的<code>net/http</code>包提供了HTTP客户端和服务端的实现。</p>

<h4 id="http协议">HTTP协议</h4>

<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>

<h3 id="http客户端">HTTP客户端</h3>

<h4 id="基本的http-https请求">基本的HTTP/HTTPS请求</h4>

<p>Get、Head、Post和PostForm函数发出HTTP/HTTPS请求。</p>

<pre><code class="language-go">resp, err := http.Get(&quot;http://example.com/&quot;)
...
resp, err := http.Post(&quot;http://example.com/upload&quot;, &quot;image/jpeg&quot;, &amp;buf)
...
resp, err := http.PostForm(&quot;http://example.com/form&quot;,
	url.Values{&quot;key&quot;: {&quot;Value&quot;}, &quot;id&quot;: {&quot;123&quot;}})
</code></pre>

<p>程序在使用完response后必须关闭回复的主体。</p>

<pre><code class="language-go">resp, err := http.Get(&quot;http://example.com/&quot;)
if err != nil {
	// handle error
}
defer resp.Body.Close()
body, err := ioutil.ReadAll(resp.Body)
// ...
</code></pre>

<h4 id="get请求示例">GET请求示例</h4>

<p>使用<code>net/http</code>包编写一个简单的发送HTTP请求的Client端，代码如下：</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
)

func main() {
	resp, err := http.Get(&quot;https://www.liwenzhou.com/&quot;)
	if err != nil {
		fmt.Printf(&quot;get failed, err:%v\n&quot;, err)
		return
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf(&quot;read from resp.Body failed, err:%v\n&quot;, err)
		return
	}
	fmt.Print(string(body))
}
</code></pre>

<p>将上面的代码保存之后编译成可执行文件，执行之后就能在终端打印<code>liwenzhou.com</code>网站首页的内容了，我们的浏览器其实就是一个发送和接收HTTP协议数据的客户端，我们平时通过浏览器访问网页其实就是从网站的服务器接收HTTP数据，然后浏览器会按照HTML、CSS等规则将网页渲染展示出来。</p>

<h4 id="带参数的get请求示例">带参数的GET请求示例</h4>

<p>关于GET请求的参数需要使用Go语言内置的<code>net/url</code>这个标准库来处理。</p>

<pre><code class="language-go">func main() {
	apiUrl := &quot;http://127.0.0.1:9090/get&quot;
	// URL param
	data := url.Values{}
	data.Set(&quot;name&quot;, &quot;小王子&quot;)
	data.Set(&quot;age&quot;, &quot;18&quot;)
	u, err := url.ParseRequestURI(apiUrl)
	if err != nil {
		fmt.Printf(&quot;parse url requestUrl failed, err:%v\n&quot;, err)
	}
	u.RawQuery = data.Encode() // URL encode
	fmt.Println(u.String())
	resp, err := http.Get(u.String())
	if err != nil {
		fmt.Printf(&quot;post failed, err:%v\n&quot;, err)
		return
	}
	defer resp.Body.Close()
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf(&quot;get resp failed, err:%v\n&quot;, err)
		return
	}
	fmt.Println(string(b))
}
</code></pre>

<p>对应的Server端HandlerFunc如下：</p>

<pre><code class="language-go">func getHandler(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	data := r.URL.Query()
	fmt.Println(data.Get(&quot;name&quot;))
	fmt.Println(data.Get(&quot;age&quot;))
	answer := `{&quot;status&quot;: &quot;ok&quot;}`
	w.Write([]byte(answer))
}
</code></pre>

<h4 id="post请求示例">Post请求示例</h4>

<p>上面演示了使用<code>net/http</code>包发送<code>GET</code>请求的示例，发送<code>POST</code>请求的示例代码如下：</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
	&quot;strings&quot;
)

// net/http post demo

func main() {
	url := &quot;http://127.0.0.1:9090/post&quot;
	// 表单数据
	//contentType := &quot;application/x-www-form-urlencoded&quot;
	//data := &quot;name=小王子&amp;age=18&quot;
	// json
	contentType := &quot;application/json&quot;
	data := `{&quot;name&quot;:&quot;小王子&quot;,&quot;age&quot;:18}`
	resp, err := http.Post(url, contentType, strings.NewReader(data))
	if err != nil {
		fmt.Printf(&quot;post failed, err:%v\n&quot;, err)
		return
	}
	defer resp.Body.Close()
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf(&quot;get resp failed, err:%v\n&quot;, err)
		return
	}
	fmt.Println(string(b))
}
</code></pre>

<p>对应的Server端HandlerFunc如下：</p>

<pre><code class="language-go">func postHandler(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	// 1. 请求类型是application/x-www-form-urlencoded时解析form数据
	r.ParseForm()
	fmt.Println(r.PostForm) // 打印form数据
	fmt.Println(r.PostForm.Get(&quot;name&quot;), r.PostForm.Get(&quot;age&quot;))
	// 2. 请求类型是application/json时从r.Body读取数据
	b, err := ioutil.ReadAll(r.Body)
	if err != nil {
		fmt.Printf(&quot;read request.Body failed, err:%v\n&quot;, err)
		return
	}
	fmt.Println(string(b))
	answer := `{&quot;status&quot;: &quot;ok&quot;}`
	w.Write([]byte(answer))
}
</code></pre>

<h4 id="自定义client">自定义Client</h4>

<p>要管理HTTP客户端的头域、重定向策略和其他设置，创建一个Client：</p>

<pre><code class="language-go">client := &amp;http.Client{
	CheckRedirect: redirectPolicyFunc,
}
resp, err := client.Get(&quot;http://example.com&quot;)
// ...
req, err := http.NewRequest(&quot;GET&quot;, &quot;http://example.com&quot;, nil)
// ...
req.Header.Add(&quot;If-None-Match&quot;, `W/&quot;wyzzy&quot;`)
resp, err := client.Do(req)
// ...
</code></pre>

<h4 id="自定义transport">自定义Transport</h4>

<p>要管理代理、TLS配置、keep-alive、压缩和其他设置，创建一个Transport：</p>

<pre><code class="language-go">tr := &amp;http.Transport{
	TLSClientConfig:    &amp;tls.Config{RootCAs: pool},
	DisableCompression: true,
}
client := &amp;http.Client{Transport: tr}
resp, err := client.Get(&quot;https://example.com&quot;)
</code></pre>

<p>Client和Transport类型都可以安全的被多个goroutine同时使用。出于效率考虑，应该一次建立、尽量重用。</p>

<h3 id="服务端">服务端</h3>

<h4 id="默认的server">默认的Server</h4>

<p>ListenAndServe使用指定的监听地址和处理器启动一个HTTP服务端。处理器参数通常是nil，这表示采用包变量DefaultServeMux作为处理器。</p>

<p>Handle和HandleFunc函数可以向DefaultServeMux添加处理器。</p>

<pre><code class="language-go">http.Handle(&quot;/foo&quot;, fooHandler)
http.HandleFunc(&quot;/bar&quot;, func(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;Hello, %q&quot;, html.EscapeString(r.URL.Path))
})
log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
</code></pre>

<h4 id="默认的server示例">默认的Server示例</h4>

<p>使用Go语言中的<code>net/http</code>包来编写一个简单的接收HTTP请求的Server端示例，<code>net/http</code>包是对net包的进一步封装，专门用来处理HTTP协议的数据。具体的代码如下：</p>

<pre><code class="language-go">// http server

func sayHello(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, &quot;Hello 沙河！&quot;)
}

func main() {
	http.HandleFunc(&quot;/&quot;, sayHello)
	err := http.ListenAndServe(&quot;:9090&quot;, nil)
	if err != nil {
		fmt.Printf(&quot;http server failed, err:%v\n&quot;, err)
		return
	}
}
</code></pre>

<p>将上面的代码编译之后执行，打开你电脑上的浏览器在地址栏输入<code>127.0.0.1:9090</code>回车，此时就能够看到如下页面了。<img src="/resources/技术收录/golang/hello.png" alt="hello页面" /></p>

<h4 id="自定义server">自定义Server</h4>

<p>要管理服务端的行为，可以创建一个自定义的Server：</p>

<pre><code class="language-go">s := &amp;http.Server{
	Addr:           &quot;:8080&quot;,
	Handler:        myHandler,
	ReadTimeout:    10 * time.Second,
	WriteTimeout:   10 * time.Second,
	MaxHeaderBytes: 1 &lt;&lt; 20,
}
log.Fatal(s.ListenAndServe())
</code></pre>

<h2 id="go标准库context">Go标准库Context</h2>

<p>在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源。</p>

<h3 id="为什么需要context">为什么需要Context</h3>

<h4 id="基本示例">基本示例</h4>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;

	&quot;time&quot;
)

var wg sync.WaitGroup

// 初始的例子

func worker() {
	for {
		fmt.Println(&quot;worker&quot;)
		time.Sleep(time.Second)
	}
	// 如何接收外部命令实现退出
	wg.Done()
}

func main() {
	wg.Add(1)
	go worker()
	// 如何优雅的实现结束子goroutine
	wg.Wait()
	fmt.Println(&quot;over&quot;)
}
</code></pre>

<h4 id="全局变量方式">全局变量方式</h4>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;

	&quot;time&quot;
)

var wg sync.WaitGroup
var exit bool

// 全局变量方式存在的问题：
// 1. 使用全局变量在跨包调用时不容易统一
// 2. 如果worker中再启动goroutine，就不太好控制了。

func worker() {
	for {
		fmt.Println(&quot;worker&quot;)
		time.Sleep(time.Second)
		if exit {
			break
		}
	}
	wg.Done()
}

func main() {
	wg.Add(1)
	go worker()
	time.Sleep(time.Second * 3) // sleep3秒以免程序过快退出
	exit = true                 // 修改全局变量实现子goroutine的退出
	wg.Wait()
	fmt.Println(&quot;over&quot;)
}
</code></pre>

<h4 id="通道方式">通道方式</h4>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;

	&quot;time&quot;
)

var wg sync.WaitGroup

// 管道方式存在的问题：
// 1. 使用全局变量在跨包调用时不容易实现规范和统一，需要维护一个共用的channel

func worker(exitChan chan struct{}) {
LOOP:
	for {
		fmt.Println(&quot;worker&quot;)
		time.Sleep(time.Second)
		select {
		case &lt;-exitChan: // 等待接收上级通知
			break LOOP
		default:
		}
	}
	wg.Done()
}

func main() {
	var exitChan = make(chan struct{})
	wg.Add(1)
	go worker(exitChan)
	time.Sleep(time.Second * 3) // sleep3秒以免程序过快退出
	exitChan &lt;- struct{}{}      // 给子goroutine发送退出信号
	close(exitChan)
	wg.Wait()
	fmt.Println(&quot;over&quot;)
}
</code></pre>

<h4 id="官方版的方案">官方版的方案</h4>

<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;sync&quot;

	&quot;time&quot;
)

var wg sync.WaitGroup

func worker(ctx context.Context) {
LOOP:
	for {
		fmt.Println(&quot;worker&quot;)
		time.Sleep(time.Second)
		select {
		case &lt;-ctx.Done(): // 等待上级通知
			break LOOP
		default:
		}
	}
	wg.Done()
}

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	wg.Add(1)
	go worker(ctx)
	time.Sleep(time.Second * 3)
	cancel() // 通知子goroutine结束
	wg.Wait()
	fmt.Println(&quot;over&quot;)
}
</code></pre>

<p>当子goroutine又开启另外一个goroutine时，只需要将ctx传入即可：</p>

<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;sync&quot;

	&quot;time&quot;
)

var wg sync.WaitGroup

func worker(ctx context.Context) {
	go worker2(ctx)
LOOP:
	for {
		fmt.Println(&quot;worker&quot;)
		time.Sleep(time.Second)
		select {
		case &lt;-ctx.Done(): // 等待上级通知
			break LOOP
		default:
		}
	}
	wg.Done()
}

func worker2(ctx context.Context) {
LOOP:
	for {
		fmt.Println(&quot;worker2&quot;)
		time.Sleep(time.Second)
		select {
		case &lt;-ctx.Done(): // 等待上级通知
			break LOOP
		default:
		}
	}
}
func main() {
	ctx, cancel := context.WithCancel(context.Background())
	wg.Add(1)
	go worker(ctx)
	time.Sleep(time.Second * 3)
	cancel() // 通知子goroutine结束
	wg.Wait()
	fmt.Println(&quot;over&quot;)
}
</code></pre>

<h3 id="context初识">Context初识</h3>

<p>Go1.7加入了一个新的标准库<code>context</code>，它定义了<code>Context</code>类型，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。</p>

<p>对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用<code>WithCancel</code>、<code>WithDeadline</code>、<code>WithTimeout</code>或<code>WithValue</code>创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。</p>

<h3 id="context接口">Context接口</h3>

<p><code>context.Context</code>是一个接口，该接口定义了四个需要实现的方法。具体签名如下：</p>

<pre><code class="language-go">type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() &lt;-chan struct{}
    Err() error
    Value(key interface{}) interface{}
}
</code></pre>

<p>其中：</p>

<ul>
<li><p><code>Deadline</code>方法需要返回当前<code>Context</code>被取消的时间，也就是完成工作的截止时间（deadline）；</p></li>

<li><p><code>Done</code>方法需要返回一个<code>Channel</code>，这个Channel会在当前工作完成或者上下文被取消之后关闭，多次调用<code>Done</code>方法会返回同一个Channel；</p></li>

<li><pre><code>Err
</code></pre>

<p>方法会返回当前</p>

<pre><code>Context
</code></pre>

<p>结束的原因，它只会在</p>

<pre><code>Done
</code></pre>

<p>返回的Channel被关闭时才会返回非空的值；</p>

<ul>
<li>如果当前<code>Context</code>被取消就会返回<code>Canceled</code>错误；</li>
<li>如果当前<code>Context</code>超时就会返回<code>DeadlineExceeded</code>错误；</li>
</ul></li>

<li><p><code>Value</code>方法会从<code>Context</code>中返回键对应的值，对于同一个上下文来说，多次调用<code>Value</code> 并传入相同的<code>Key</code>会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域的数据；</p></li>
</ul>

<h4 id="background-和todo">Background()和TODO()</h4>

<p>Go内置两个函数：<code>Background()</code>和<code>TODO()</code>，这两个函数分别返回一个实现了<code>Context</code>接口的<code>background</code>和<code>todo</code>。我们代码中最开始都是以这两个内置的上下文对象作为最顶层的<code>partent context</code>，衍生出更多的子上下文对象。</p>

<p><code>Background()</code>主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context。</p>

<p><code>TODO()</code>，它目前还不知道具体的使用场景，如果我们不知道该使用什么Context的时候，可以使用这个。</p>

<p><code>background</code>和<code>todo</code>本质上都是<code>emptyCtx</code>结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。</p>

<h3 id="with系列函数">With系列函数</h3>

<p>此外，<code>context</code>包中还定义了四个With系列函数。</p>

<h4 id="withcancel">WithCancel</h4>

<p><code>WithCancel</code>的函数签名如下：</p>

<pre><code class="language-go">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
</code></pre>

<p><code>WithCancel</code>返回带有新Done通道的父节点的副本。当调用返回的cancel函数或当关闭父上下文的Done通道时，将关闭返回上下文的Done通道，无论先发生什么情况。</p>

<p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。</p>

<pre><code class="language-go">func gen(ctx context.Context) &lt;-chan int {
		dst := make(chan int)
		n := 1
		go func() {
			for {
				select {
				case &lt;-ctx.Done():
					return // return结束该goroutine，防止泄露
				case dst &lt;- n:
					n++
				}
			}
		}()
		return dst
	}
func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel() // 当我们取完需要的整数后调用cancel

	for n := range gen(ctx) {
		fmt.Println(n)
		if n == 5 {
			break
		}
	}
}
</code></pre>

<p>上面的示例代码中，<code>gen</code>函数在单独的goroutine中生成整数并将它们发送到返回的通道。 gen的调用者在使用生成的整数之后需要取消上下文，以免<code>gen</code>启动的内部goroutine发生泄漏。</p>

<h4 id="withdeadline">WithDeadline</h4>

<p><code>WithDeadline</code>的函数签名如下：</p>

<pre><code class="language-go">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)
</code></pre>

<p>返回父上下文的副本，并将deadline调整为不迟于d。如果父上下文的deadline已经早于d，则WithDeadline(parent, d)在语义上等同于父上下文。当截止日过期时，当调用返回的cancel函数时，或者当父上下文的Done通道关闭时，返回上下文的Done通道将被关闭，以最先发生的情况为准。</p>

<p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。</p>

<pre><code class="language-go">func main() {
	d := time.Now().Add(50 * time.Millisecond)
	ctx, cancel := context.WithDeadline(context.Background(), d)

	// 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。
	// 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。
	defer cancel()

	select {
	case &lt;-time.After(1 * time.Second):
		fmt.Println(&quot;overslept&quot;)
	case &lt;-ctx.Done():
		fmt.Println(ctx.Err())
	}
}
</code></pre>

<p>上面的代码中，定义了一个50毫秒之后过期的deadline，然后我们调用<code>context.WithDeadline(context.Background(), d)</code>得到一个上下文（ctx）和一个取消函数（cancel），然后使用一个select让主程序陷入等待：等待1秒后打印<code>overslept</code>退出或者等待ctx过期后退出。</p>

<p>在上面的示例代码中，因为ctx 50毫秒后就会过期，所以<code>ctx.Done()</code>会先接收到context到期通知，并且会打印ctx.Err()的内容。</p>

<h4 id="withtimeout">WithTimeout</h4>

<p><code>WithTimeout</code>的函数签名如下：</p>

<pre><code class="language-go">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
</code></pre>

<p><code>WithTimeout</code>返回<code>WithDeadline(parent, time.Now().Add(timeout))</code>。</p>

<p>取消此上下文将释放与其相关的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel，通常用于数据库或者网络连接的超时控制。具体示例如下：</p>

<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;sync&quot;

	&quot;time&quot;
)

// context.WithTimeout

var wg sync.WaitGroup

func worker(ctx context.Context) {
LOOP:
	for {
		fmt.Println(&quot;db connecting ...&quot;)
		time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒
		select {
		case &lt;-ctx.Done(): // 50毫秒后自动调用
			break LOOP
		default:
		}
	}
	fmt.Println(&quot;worker done!&quot;)
	wg.Done()
}

func main() {
	// 设置一个50毫秒的超时
	ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50)
	wg.Add(1)
	go worker(ctx)
	time.Sleep(time.Second * 5)
	cancel() // 通知子goroutine结束
	wg.Wait()
	fmt.Println(&quot;over&quot;)
}
</code></pre>

<h4 id="withvalue">WithValue</h4>

<p><code>WithValue</code>函数能够将请求作用域的数据与 Context 对象建立关系。声明如下：</p>

<pre><code class="language-go">func WithValue(parent Context, key, val interface{}) Context
</code></pre>

<p><code>WithValue</code>返回父节点的副本，其中与key关联的值为val。</p>

<p>仅对API和进程间传递请求域的数据使用上下文值，而不是使用它来传递可选参数给函数。</p>

<p>所提供的键必须是可比较的，并且不应该是<code>string</code>类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。<code>WithValue</code>的用户应该为键定义自己的类型。为了避免在分配给interface{}时进行分配，上下文键通常具有具体类型<code>struct{}</code>。或者，导出的上下文关键变量的静态类型应该是指针或接口。</p>

<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;sync&quot;

	&quot;time&quot;
)

// context.WithValue

type TraceCode string

var wg sync.WaitGroup

func worker(ctx context.Context) {
	key := TraceCode(&quot;TRACE_CODE&quot;)
	traceCode, ok := ctx.Value(key).(string) // 在子goroutine中获取trace code
	if !ok {
		fmt.Println(&quot;invalid trace code&quot;)
	}
LOOP:
	for {
		fmt.Printf(&quot;worker, trace code:%s\n&quot;, traceCode)
		time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒
		select {
		case &lt;-ctx.Done(): // 50毫秒后自动调用
			break LOOP
		default:
		}
	}
	fmt.Println(&quot;worker done!&quot;)
	wg.Done()
}

func main() {
	// 设置一个50毫秒的超时
	ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50)
	// 在系统的入口中设置trace code传递给后续启动的goroutine实现日志数据聚合
	ctx = context.WithValue(ctx, TraceCode(&quot;TRACE_CODE&quot;), &quot;12512312234&quot;)
	wg.Add(1)
	go worker(ctx)
	time.Sleep(time.Second * 5)
	cancel() // 通知子goroutine结束
	wg.Wait()
	fmt.Println(&quot;over&quot;)
}
</code></pre>

<h3 id="使用context的注意事项">使用Context的注意事项</h3>

<ul>
<li>推荐以参数的方式显示传递Context</li>
<li>以Context作为参数的函数方法，应该把Context作为第一个参数。</li>
<li>给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO()</li>
<li>Context的Value相关方法应该传递请求域的必要数据，不应该用于传递可选参数</li>
<li>Context是线程安全的，可以放心的在多个goroutine中传递</li>
</ul>

<h3 id="客户端超时取消示例">客户端超时取消示例</h3>

<p>调用服务端API时如何在客户端实现超时控制？</p>

<h4 id="server端">server端</h4>

<pre><code class="language-go">// context_timeout/server/main.go
package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
	&quot;net/http&quot;

	&quot;time&quot;
)

// server端，随机出现慢响应

func indexHandler(w http.ResponseWriter, r *http.Request) {
	number := rand.Intn(2)
	if number == 0 {
		time.Sleep(time.Second * 10) // 耗时10秒的慢响应
		fmt.Fprintf(w, &quot;slow response&quot;)
		return
	}
	fmt.Fprint(w, &quot;quick response&quot;)
}

func main() {
	http.HandleFunc(&quot;/&quot;, indexHandler)
	err := http.ListenAndServe(&quot;:8000&quot;, nil)
	if err != nil {
		panic(err)
	}
}
</code></pre>

<h4 id="client端">client端</h4>

<pre><code class="language-go">// context_timeout/client/main.go
package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

// 客户端

type respData struct {
	resp *http.Response
	err  error
}

func doCall(ctx context.Context) {
	transport := http.Transport{
	   // 请求频繁可定义全局的client对象并启用长链接
	   // 请求不频繁使用短链接
	   DisableKeepAlives: true, 	}
	client := http.Client{
		Transport: &amp;transport,
	}

	respChan := make(chan *respData, 1)
	req, err := http.NewRequest(&quot;GET&quot;, &quot;http://127.0.0.1:8000/&quot;, nil)
	if err != nil {
		fmt.Printf(&quot;new requestg failed, err:%v\n&quot;, err)
		return
	}
	req = req.WithContext(ctx) // 使用带超时的ctx创建一个新的client request
	var wg sync.WaitGroup
	wg.Add(1)
	defer wg.Wait()
	go func() {
		resp, err := client.Do(req)
		fmt.Printf(&quot;client.do resp:%v, err:%v\n&quot;, resp, err)
		rd := &amp;respData{
			resp: resp,
			err:  err,
		}
		respChan &lt;- rd
		wg.Done()
	}()

	select {
	case &lt;-ctx.Done():
		//transport.CancelRequest(req)
		fmt.Println(&quot;call api timeout&quot;)
	case result := &lt;-respChan:
		fmt.Println(&quot;call server api success&quot;)
		if result.err != nil {
			fmt.Printf(&quot;call server api failed, err:%v\n&quot;, result.err)
			return
		}
		defer result.resp.Body.Close()
		data, _ := ioutil.ReadAll(result.resp.Body)
		fmt.Printf(&quot;resp:%v\n&quot;, string(data))
	}
}

func main() {
	// 定义一个100毫秒的超时
	ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*100)
	defer cancel() // 调用cancel释放子goroutine资源
	doCall(ctx)
}
</code></pre>

    </div>
    <div class="article-footer">
<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接: </strong>
      <a href="https://mumulx.gitee.io/2022/10/golang/" title="Golang" target="_blank" rel="external">https://mumulx.gitee.io/2022/10/golang/</a>
    </li>
    <li class="post-copyright-license">
      <strong>License：</strong><a href="https://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN</a>
    </li>
  </ul>
</blockquote>

<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gitee.com/mumulx" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="https://mumulx.gitee.io/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://gitee.com/mumulx" target="_blank"><span class="text-dark">木木就是两个木</span><small class="ml-1x">木木</small></a></h3>
        <div>愿生活不太拥挤，愿笑容不必刻意。</div>
      </div>
    </figure>
  </div>
</div>
    </div>
  </article>
<section id="comments">
</section>

</div><nav class="bar bar-footer clearfix" data-stick-bottom>
    <div class="bar-inner">
        <ul class="pager pull-left">
            <li class="prev">
                <a href="https://mumulx.gitee.io/2022/06/springbatch/" title="SpringBatch中文文档"><i
                        class="icon icon-angle-left"
                        aria-hidden="true"></i><span>&nbsp;&nbsp;下一篇</span></a>
            </li>
            
            <li class="toggle-toc">
                <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false"
                    title="文章目录" role="button">
                    <span>[&nbsp;</span><span>文章目录</span>
                    <i class="text-collapsed icon icon-anchor"></i>
                    <i class="text-in icon icon-close"></i>
                    <span>]</span>
                </a>
            </li>
        </ul>
        
        <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal"
            data-target="#donateModal"><span>赏</span></button>
        
        <div class="bar-right">
            <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter"
                data-mobile-sites="weibo,qq,qzone"></div>
        </div>
    </div>
</nav>


<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content donate">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                    aria-hidden="true">&times;</span></button>
            <div class="modal-body">
                <div class="donate-box">
                    <div class="donate-head">
                        <p>感谢您的支持,我会继续努力的!</p>
                    </div>
                    <div class="tab-content">
                        <div role="tabpanel" class="tab-pane fade active in" id="alipay">
                            <div class="donate-payimg">
                                <img src="https://mumulx.gitee.io/donate/alipayimg.png"
                                    alt="扫码支持" title="扫一扫" />
                            </div>
                            <p class="text-muted mv">扫码打赏, 多少你说了算~</p>
                            <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦~</p>
                        </div>
                        <div role="tabpanel" class="tab-pane fade" id="wechatpay">
                            <div class="donate-payimg">
                                <img src="https://mumulx.gitee.io/donate/wechatpayimg.png"
                                    alt="扫码支持" title="扫一扫" />
                            </div>
                            <p class="text-muted mv">扫码打赏, 多少你说了算~</p>
                            <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
                        </div>
                    </div>
                    <div class="donate-footer">
                        <ul class="nav nav-tabs nav-justified" role="tablist">
                            <li role="presentation" class="active">
                                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay"
                                    aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
                            </li>
                            <li role="presentation" class="">
                                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab"
                                    aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i>
                                    微信支付</a>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
</main><footer class="footer" itemscope itemtype="https://schema.org/WPFooter">
<ul class="social-links">
    <li><a href="https://github.com/mumulx" target="_blank" title="github" data-toggle=tooltip data-placement=top >
            <i class="icon icon-github"></i></a></li>
    <li><a href="https://mumulx.gitee.io/index.xml" target="_blank" title="rss" data-toggle=tooltip data-placement=top >
            <i class="icon icon-rss"></i></a></li>
    <li><a href="https://weibo.com/u/5459389722" target="_blank" title="weibo" data-toggle=tooltip data-placement=top >
            <i class="icon icon-weibo"></i></a></li>
</ul>
  <div class="copyright">
    &copy;2019  -
    2022
    <div class="publishby">
        联系邮箱：<a target="_blank" title="木木的邮箱"> 1819778796@qq.com </a>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script>
   window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/highlight.min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/rust.min.js"></script>
<script type="text/javascript"
   src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script>
hljs.configure({
  tabReplace: '    ', 
  classPrefix: ''     
                      
})
hljs.initHighlightingOnLoad();
</script>
<script type="text/javascript" src="https://mumulx.gitee.io/js/application.js"></script>
<script type="text/javascript" src="https://mumulx.gitee.io/js/plugin.js"></script>
<script>
      (function (window) {
          var INSIGHT_CONFIG = {
              TRANSLATION: {
                  POSTS: '文章',
                  PAGES: '页面',
                  CATEGORIES: '分类',
                  TAGS: '标签',
                  UNTITLED: '(未命名)',
              },
              ROOT_URL: 'https:\/\/mumulx.gitee.io\/',
              CONTENT_URL: 'https:\/\/mumulx.gitee.io\/\/searchindex.json ',
          };
          window.INSIGHT_CONFIG = INSIGHT_CONFIG;
      })(window);
      </script>
<script type="text/javascript" src="https://mumulx.gitee.io/js/insight.js"></script>

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '1ccf8dc9e86b3575cfb2',
        clientSecret: '048ae422c4a6207a4e89c58ba1d4ebf820136bb0',
        repo: 'gittalk',
        owner: 'mumulx',
        admin: ['mumulx'],
        id: md5(location.pathname),
        distractionFreeMode: true
    });
    gitalk.render('comments');
</script>

  </body>
</html>
