<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>
        Golang - 木木的个人博客
      </title>
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  
  <meta name="theme-color" content="#000000" />
  
  <meta http-equiv="window-target" content="_top" />
  
  
  <meta name="description" content="Golang" />
  <meta name="generator" content="Hugo 0.59.1 with theme pure" />
  <title>Golang - 木木的个人博客</title>
  

  <link rel="stylesheet" href="https://mumulx.gitee.io/css/style.css">
  <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.15.10/styles/github.min.css"> 
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <meta property="og:title" content="Golang" />
<meta property="og:description" content="Golang" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mumulx.gitee.io/2022/10/golang/" />
<meta property="article:published_time" content="2022-10-24T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-10-24T00:00:00+00:00" />

<meta itemprop="name" content="Golang">
<meta itemprop="description" content="Golang">


<meta itemprop="datePublished" content="2022-10-24T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2022-10-24T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="95926">



<meta itemprop="keywords" content="Golang," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Golang"/>
<meta name="twitter:description" content="Golang"/>

  <!--[if lte IE 9]>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
    <![endif]-->

  <!--[if lt IE 9]>
      <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
    <![endif]-->

</head>
  </head>
  

  <body class="main-center" itemscope itemtype="https://schema.org/WebPage"><header class="header" itemscope itemtype="https://schema.org/WPHeader">
    <div class="slimContent">
      <div class="navbar-header">
        <div class="profile-block text-center">
          <a id="avatar" href="https://gitee.com/mumulx" target="_blank">
            <img class="img-circle img-rotate" src="https://mumulx.gitee.io/avatar.png" width="200" height="200">
          </a>
          <h2 id="name" class="hidden-xs hidden-sm">木木就是两个木</h2>
          <h3 id="title" class="hidden-xs hidden-sm hidden-md">木木</h3>
          <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i>xuzhou, China</small>
        </div><div class="search" id="search-form-wrap">
    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i
                        class="icon icon-search"></i></button>
            </span>
        </div>
        <div class="ins-search">
            <div class="ins-search-mask"></div>
            <div class="ins-search-container">
                <div class="ins-input-wrapper">
                    <input type="text" class="ins-search-input" placeholder="想要查找什么..."
                        x-webkit-speech />
                    <button type="button" class="close ins-close ins-selectable" data-dismiss="modal"
                        aria-label="Close"><span aria-hidden="true">×</span></button>
                </div>
                <div class="ins-section-wrapper">
                    <div class="ins-section-container"></div>
                </div>
            </div>
        </div>
    </form>
</div>
        <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
      <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="https://schema.org/SiteNavigationElement" role="navigation">
        <ul class="nav navbar-nav main-nav">
            <li class="menu-item menu-item-home">
                <a href="/">
                    <i class="icon icon-home-fill"></i>
                  <span class="menu-title">主页</span>
                </a>
            </li>
            <li class="menu-item menu-item-archives">
                <a href="/posts">
                    <i class="icon icon-archives-fill"></i>
                  <span class="menu-title">归档</span>
                </a>
            </li>
            <li class="menu-item menu-item-categories">
                <a href="/categories">
                    <i class="icon icon-folder"></i>
                  <span class="menu-title">分类</span>
                </a>
            </li>
            <li class="menu-item menu-item-tags">
                <a href="/tags">
                    <i class="icon icon-tags"></i>
                  <span class="menu-title">标签</span>
                </a>
            </li>
            <li class="menu-item menu-item-about">
                <a href="/about">
                    <i class="icon icon-cup-fill"></i>
                  <span class="menu-title">关于</span>
                </a>
            </li>
        </ul>
      </nav>
    </div>
  </header>
  <aside class="sidebar" itemscope itemtype="https://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content"><p>我们的征途是星辰大海！</p>
            </div>
        </div>
    </div>
</div>

      <div class="widget">
    <h3 class="widget-title"> 分类</h3>
    <div class="widget-body">
        <ul class="category-list">
            <li class="category-list-item"><a href="https://mumulx.gitee.io/categories/golang/" class="category-list-link">golang</a><span class="category-list-count">3</span></li>
            <li class="category-list-item"><a href="https://mumulx.gitee.io/categories/java%E9%9D%A2%E8%AF%95/" class="category-list-link">java面试</a><span class="category-list-count">5</span></li>
            <li class="category-list-item"><a href="https://mumulx.gitee.io/categories/python/" class="category-list-link">python</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://mumulx.gitee.io/categories/%E6%8A%80%E6%9C%AF%E6%94%B6%E5%BD%95/" class="category-list-link">技术收录</a><span class="category-list-count">37</span></li>
            <li class="category-list-item"><a href="https://mumulx.gitee.io/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/" class="category-list-link">技术框架</a><span class="category-list-count">17</span></li>
            <li class="category-list-item"><a href="https://mumulx.gitee.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" class="category-list-link">杂七杂八</a><span class="category-list-count">7</span></li>
        </ul>
    </div>
</div>
      <div class="widget">
    <h3 class="widget-title"> 标签</h3>
    <div class="widget-body">
        <ul class="tag-list">
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/golang/" class="tag-list-link">golang</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/java/" class="tag-list-link">java</a><span
                    class="tag-list-count">10</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/java%E5%B9%B6%E5%8F%91/" class="tag-list-link">java并发</a><span
                    class="tag-list-count">5</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/java%E5%BA%95%E5%B1%82/" class="tag-list-link">java底层</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/linux/" class="tag-list-link">linux</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/python/" class="tag-list-link">python</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/spring%E5%AE%B6%E6%97%8F/" class="tag-list-link">spring家族</a><span
                    class="tag-list-count">15</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="tag-list-link">中间件</a><span
                    class="tag-list-count">6</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" class="tag-list-link">分布式</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" class="tag-list-link">前端框架</a><span
                    class="tag-list-count">7</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" class="tag-list-link">开发工具</a><span
                    class="tag-list-count">4</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="tag-list-link">数据库</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" class="tag-list-link">杂七杂八</a><span
                    class="tag-list-count">5</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E6%9D%83%E9%99%90/" class="tag-list-link">权限</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="tag-list-link">面试题</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.gitee.io/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/" class="tag-list-link">项目实战</a><span
                    class="tag-list-count">1</span></li>
            
        </ul>

    </div>
</div>
      
<div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
        <ul class="recent-post-list list-unstyled no-thumbnail">
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.gitee.io/2023/01/vue3%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" class="title">vue3必知必会</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2023-01-13 00:00:00 &#43;0000 UTC" itemprop="datePublished">2023-01-13</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.gitee.io/2022/11/python/" class="title">Python</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-11-24 00:00:00 &#43;0000 UTC" itemprop="datePublished">2022-11-24</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.gitee.io/2022/10/gin/" class="title">Gin</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-10-30 00:00:00 &#43;0000 UTC" itemprop="datePublished">2022-10-30</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.gitee.io/2022/10/gorm/" class="title">GORM</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-10-30 00:00:00 &#43;0000 UTC" itemprop="datePublished">2022-10-30</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.gitee.io/2022/10/golang/" class="title">Golang</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-10-24 00:00:00 &#43;0000 UTC" itemprop="datePublished">2022-10-24</time>
                    </p>
                </div>
            </li>
        </ul>
    </div>
</div>
  </div>
</aside>

    
    
  <aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="https://schema.org/WPSideBar">
    <div class="slimContent">
      <nav id="toc" class="article-toc">
        <h3 class="toc-title">文章目录</h3>
        <div class="toc-content always-active"><nav id="TableOfContents">
<ul>
<li><a href="#golang">Golang</a>
<ul>
<li><a href="#为什么你应该学习go语言">为什么你应该学习Go语言？</a></li>
<li><a href="#为什么互联网世界需要go语言">为什么互联网世界需要Go语言</a>
<ul>
<li><a href="#硬件限制-摩尔定律已然失效">硬件限制：摩尔定律已然失效</a></li>
<li><a href="#go语言为并发而生">Go语言为并发而生</a></li>
<li><a href="#go性能强悍">Go性能强悍</a></li>
<li><a href="#go语言简单易学">Go语言简单易学</a>
<ul>
<li><a href="#语法简洁">语法简洁</a></li>
<li><a href="#代码风格统一">代码风格统一</a></li>
<li><a href="#开发效率高">开发效率高</a></li>
</ul></li>
</ul></li>
<li><a href="#学习go语言的前景">学习Go语言的前景</a></li>
</ul></li>
<li><a href="#开发环境准备">开发环境准备</a>
<ul>
<li><a href="#从零开始搭建go语言开发环境-新">从零开始搭建Go语言开发环境（新）</a>
<ul>
<li><a href="#安装go语言及搭建go语言开发环境">安装Go语言及搭建Go语言开发环境</a></li>
<li><a href="#下载">下载</a>
<ul>
<li><a href="#下载地址">下载地址</a></li>
<li><a href="#版本的选择">版本的选择</a></li>
</ul></li>
<li><a href="#安装">安装</a>
<ul>
<li><a href="#windows安装">Windows安装</a></li>
<li><a href="#linux下安装">Linux下安装</a></li>
<li><a href="#mac下安装">Mac下安装</a></li>
<li><a href="#检查">检查</a></li>
</ul></li>
<li><a href="#goroot和gopath">GOROOT和GOPATH</a>
<ul>
<li><a href="#goproxy-非常重要">GOPROXY 非常重要</a></li>
</ul></li>
<li><a href="#go开发编辑器">Go开发编辑器</a>
<ul>
<li><a href="#vs-code介绍">VS Code介绍</a></li>
<li><a href="#下载与安装">下载与安装</a></li>
<li><a href="#配置">配置</a>
<ul>
<li><a href="#安装中文简体插件">安装中文简体插件</a></li>
<li><a href="#安装go扩展">安装go扩展</a></li>
</ul></li>
</ul></li>
<li><a href="#第一个go程序">第一个Go程序</a>
<ul>
<li><a href="#hello-world">Hello World</a>
<ul>
<li><a href="#go-mod-init">go mod init</a></li>
<li><a href="#编写代码">编写代码</a></li>
</ul></li>
<li><a href="#编译">编译</a></li>
<li><a href="#windows下vscode切换cmd-exe作为默认终端">Windows下VSCode切换cmd.exe作为默认终端</a></li>
<li><a href="#go-run">go run</a></li>
<li><a href="#go-install">go install</a></li>
<li><a href="#跨平台编译">跨平台编译</a>
<ul>
<li><a href="#mac编译linux可执行文件">Mac编译Linux可执行文件</a></li>
<li><a href="#mac编译windows可执行文件">Mac编译Windows可执行文件</a></li>
<li><a href="#linux编译mac可执行文件">Linux编译Mac可执行文件</a></li>
<li><a href="#linux编译windows可执行文件">Linux编译Windows可执行文件</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#vs-code配置go语言开发环境">VS Code配置Go语言开发环境</a>
<ul>
<li><a href="#下载与安装-1">下载与安装</a></li>
<li><a href="#安装中文简体插件-1">安装中文简体插件</a></li>
<li><a href="#安装go开发扩展">安装Go开发扩展</a></li>
<li><a href="#变更编辑器主题">变更编辑器主题</a></li>
<li><a href="#安装go语言开发工具包">安装Go语言开发工具包</a></li>
<li><a href="#配置vscode开启自动保存">配置VSCode开启自动保存</a></li>
<li><a href="#配置代码片段快捷键">配置代码片段快捷键</a></li>
</ul></li>
<li><a href="#go语言之依赖管理">Go语言之依赖管理</a>
<ul>
<li><a href="#为什么需要依赖管理">为什么需要依赖管理</a>
<ul>
<li><a href="#godep">godep</a></li>
<li><a href="#安装-1">安装</a></li>
<li><a href="#基本命令">基本命令</a></li>
<li><a href="#使用godep">使用godep</a></li>
<li><a href="#vender机制">vender机制</a></li>
<li><a href="#godep开发流程">godep开发流程</a></li>
</ul></li>
<li><a href="#go-module">go module</a>
<ul>
<li><a href="#go111module">GO111MODULE</a></li>
<li><a href="#goproxy">GOPROXY</a></li>
<li><a href="#go-mod命令">go mod命令</a></li>
<li><a href="#go-mod">go.mod</a>
<ul>
<li><a href="#依赖的版本">依赖的版本</a></li>
<li><a href="#replace">replace</a></li>
<li><a href="#go-get">go get</a></li>
<li><a href="#整理依赖">整理依赖</a></li>
</ul></li>
<li><a href="#go-mod-edit">go mod edit</a>
<ul>
<li><a href="#格式化">格式化</a></li>
<li><a href="#添加依赖项">添加依赖项</a></li>
<li><a href="#移除依赖项">移除依赖项</a></li>
</ul></li>
</ul></li>
<li><a href="#在项目中使用go-module">在项目中使用go module</a>
<ul>
<li><a href="#既有项目">既有项目</a></li>
<li><a href="#新项目">新项目</a></li>
</ul></li>
</ul></li>
<li><a href="#如何使用go-module导入本地包">如何使用go module导入本地包</a>
<ul>
<li><a href="#前提">前提</a></li>
<li><a href="#在同一个项目下">在同一个项目下</a>
<ul>
<li><a href="#目录结构">目录结构</a></li>
<li><a href="#导入包">导入包</a></li>
<li><a href="#举个例子">举个例子</a></li>
</ul></li>
<li><a href="#不在同一个项目下">不在同一个项目下</a>
<ul>
<li><a href="#目录结构-1">目录结构</a></li>
<li><a href="#导入包-1">导入包</a></li>
<li><a href="#举个例子-1">举个例子</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础">Go语言基础</a>
<ul>
<li><a href="#go语言基础之变量和常量">Go语言基础之变量和常量</a>
<ul>
<li><a href="#标识符与关键字">标识符与关键字</a>
<ul>
<li><a href="#标识符">标识符</a></li>
<li><a href="#关键字">关键字</a></li>
</ul></li>
<li><a href="#变量">变量</a>
<ul>
<li><a href="#变量的来历">变量的来历</a></li>
<li><a href="#变量类型">变量类型</a></li>
<li><a href="#变量声明">变量声明</a>
<ul>
<li><a href="#标准声明">标准声明</a></li>
<li><a href="#批量声明">批量声明</a></li>
<li><a href="#变量的初始化">变量的初始化</a></li>
<li><a href="#类型推导">类型推导</a></li>
<li><a href="#短变量声明">短变量声明</a></li>
<li><a href="#匿名变量">匿名变量</a></li>
</ul></li>
</ul></li>
<li><a href="#常量">常量</a>
<ul>
<li><a href="#iota">iota</a></li>
<li><a href="#几个常见的-iota-示例">几个常见的<code>iota</code>示例:</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之基本数据类型">Go语言基础之基本数据类型</a>
<ul>
<li><a href="#基本数据类型">基本数据类型</a>
<ul>
<li><a href="#整型">整型</a>
<ul>
<li><a href="#特殊整型">特殊整型</a></li>
<li><a href="#数字字面量语法-number-literals-syntax">数字字面量语法（Number literals syntax）</a></li>
</ul></li>
<li><a href="#浮点型">浮点型</a></li>
<li><a href="#复数">复数</a></li>
<li><a href="#布尔值">布尔值</a></li>
<li><a href="#字符串">字符串</a>
<ul>
<li><a href="#字符串转义符">字符串转义符</a></li>
<li><a href="#多行字符串">多行字符串</a></li>
<li><a href="#字符串的常用操作">字符串的常用操作</a></li>
</ul></li>
<li><a href="#byte和rune类型">byte和rune类型</a>
<ul>
<li><a href="#修改字符串">修改字符串</a></li>
</ul></li>
<li><a href="#类型转换">类型转换</a></li>
</ul></li>
<li><a href="#练习题">练习题</a></li>
</ul></li>
<li><a href="#go语言基础之运算符">Go语言基础之运算符</a>
<ul>
<li><a href="#算术运算符">算术运算符</a></li>
<li><a href="#关系运算符">关系运算符</a></li>
<li><a href="#逻辑运算符">逻辑运算符</a></li>
<li><a href="#位运算符">位运算符</a></li>
<li><a href="#赋值运算符">赋值运算符</a>
<ul>
<li><a href="#练习题-1">练习题</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之流程控制">Go语言基础之流程控制</a>
<ul>
<li><a href="#if-else-分支结构">if else(分支结构)</a>
<ul>
<li><a href="#if条件判断基本写法">if条件判断基本写法</a></li>
<li><a href="#if条件判断特殊写法">if条件判断特殊写法</a></li>
</ul></li>
<li><a href="#for-循环结构">for(循环结构)</a>
<ul>
<li><a href="#无限循环">无限循环</a></li>
</ul></li>
<li><a href="#for-range-键值循环">for range(键值循环)</a></li>
<li><a href="#switch-case">switch case</a></li>
<li><a href="#goto-跳转到指定标签">goto(跳转到指定标签)</a></li>
<li><a href="#break-跳出循环">break(跳出循环)</a></li>
<li><a href="#continue-继续下次循环">continue(继续下次循环)</a>
<ul>
<li><a href="#练习题-2">练习题</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之数组">Go语言基础之数组</a>
<ul>
<li><a href="#数组定义">数组定义：</a></li>
<li><a href="#数组的初始化">数组的初始化</a>
<ul>
<li><a href="#方法一">方法一</a></li>
<li><a href="#方法二">方法二</a></li>
<li><a href="#方法三">方法三</a></li>
</ul></li>
<li><a href="#数组的遍历">数组的遍历</a></li>
<li><a href="#多维数组">多维数组</a>
<ul>
<li><a href="#二维数组的定义">二维数组的定义</a></li>
<li><a href="#二维数组的遍历">二维数组的遍历</a></li>
</ul></li>
<li><a href="#数组是值类型">数组是值类型</a></li>
<li><a href="#练习题-3">练习题</a></li>
</ul></li>
<li><a href="#go语言基础之切片">Go语言基础之切片</a>
<ul>
<li><a href="#引子">引子</a></li>
<li><a href="#切片">切片</a>
<ul>
<li><a href="#切片的定义">切片的定义</a>
<ul>
<li><a href="#切片的长度和容量">切片的长度和容量</a></li>
<li><a href="#切片表达式">切片表达式</a>
<ul>
<li><a href="#简单切片表达式">简单切片表达式</a></li>
<li><a href="#完整切片表达式">完整切片表达式</a></li>
</ul></li>
<li><a href="#使用make-函数构造切片">使用make()函数构造切片</a></li>
<li><a href="#切片的本5质">切片的本5质</a></li>
<li><a href="#判断切片是否为空">判断切片是否为空</a></li>
</ul></li>
<li><a href="#切片不能直接比较">切片不能直接比较</a></li>
<li><a href="#切片的赋值拷贝">切片的赋值拷贝</a></li>
<li><a href="#切片遍历">切片遍历</a></li>
<li><a href="#切片的扩容策略">切片的扩容策略</a></li>
<li><a href="#使用copy-函数复制切片">使用copy()函数复制切片</a></li>
<li><a href="#从切片中删除元素">从切片中删除元素</a></li>
</ul></li>
<li><a href="#练习题-4">练习题</a></li>
</ul></li>
<li><a href="#go语言基础之map">Go语言基础之map</a>
<ul>
<li><a href="#map定义">map定义</a></li>
<li><a href="#map基本使用">map基本使用</a></li>
<li><a href="#判断某个键是否存在">判断某个键是否存在</a></li>
<li><a href="#map的遍历">map的遍历</a></li>
<li><a href="#使用delete-函数删除键值对">使用delete()函数删除键值对</a></li>
<li><a href="#按照指定顺序遍历map">按照指定顺序遍历map</a></li>
<li><a href="#元素为map类型的切片">元素为map类型的切片</a></li>
<li><a href="#值为切片类型的map">值为切片类型的map</a>
<ul>
<li><a href="#练习题-5">练习题</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之函数">Go语言基础之函数</a>
<ul>
<li><a href="#函数定义">函数定义</a></li>
<li><a href="#函数的调用">函数的调用</a></li>
<li><a href="#参数">参数</a>
<ul>
<li><a href="#类型简写">类型简写</a></li>
<li><a href="#可变参数">可变参数</a></li>
</ul></li>
<li><a href="#返回值">返回值</a>
<ul>
<li><a href="#多返回值">多返回值</a></li>
<li><a href="#返回值命名">返回值命名</a></li>
<li><a href="#返回值补充">返回值补充</a></li>
</ul></li>
<li><a href="#函数进阶">函数进阶</a>
<ul>
<li><a href="#变量作用域">变量作用域</a>
<ul>
<li><a href="#全局变量">全局变量</a></li>
<li><a href="#局部变量">局部变量</a></li>
</ul></li>
<li><a href="#函数类型与变量">函数类型与变量</a>
<ul>
<li><a href="#定义函数类型">定义函数类型</a></li>
<li><a href="#函数类型变量">函数类型变量</a></li>
</ul></li>
<li><a href="#高阶函数">高阶函数</a>
<ul>
<li><a href="#函数作为参数">函数作为参数</a></li>
<li><a href="#函数作为返回值">函数作为返回值</a></li>
</ul></li>
<li><a href="#匿名函数和闭包">匿名函数和闭包</a>
<ul>
<li><a href="#匿名函数">匿名函数</a></li>
<li><a href="#闭包">闭包</a></li>
</ul></li>
<li><a href="#defer语句">defer语句</a>
<ul>
<li><a href="#defer执行时机">defer执行时机</a></li>
<li><a href="#defer经典案例">defer经典案例</a></li>
</ul></li>
<li><a href="#defer面试题">defer面试题</a></li>
</ul></li>
<li><a href="#内置函数介绍">内置函数介绍</a>
<ul>
<li><a href="#panic-recover">panic/recover</a></li>
<li><a href="#练习题-6">练习题</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之指针">Go语言基础之指针</a>
<ul>
<li><a href="#指针地址和指针类型">指针地址和指针类型</a></li>
<li><a href="#指针取值">指针取值</a></li>
<li><a href="#new和make">new和make</a>
<ul>
<li><a href="#new">new</a></li>
<li><a href="#make">make</a></li>
<li><a href="#new与make的区别">new与make的区别</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之包">Go语言基础之包</a>
<ul>
<li><a href="#包与依赖管理">包与依赖管理</a></li>
<li><a href="#包-package">包（package）</a>
<ul>
<li><a href="#包介绍">包介绍</a></li>
<li><a href="#定义包">定义包</a></li>
<li><a href="#标识符可见性">标识符可见性</a></li>
<li><a href="#包的引入">包的引入</a></li>
<li><a href="#init初始化函数">init初始化函数</a></li>
<li><a href="#go-module-1">go module</a></li>
<li><a href="#go-module介绍">go module介绍</a></li>
<li><a href="#使用go-module引入包">使用go module引入包</a></li>
<li><a href="#使用go-module发布包">使用go module发布包</a></li>
</ul></li>
<li><a href="#练习题-7">练习题</a></li>
</ul></li>
<li><a href="#go语言基础之结构体">Go语言基础之结构体</a>
<ul>
<li><a href="#类型别名和自定义类型">类型别名和自定义类型</a>
<ul>
<li><a href="#自定义类型">自定义类型</a></li>
<li><a href="#类型别名">类型别名</a></li>
<li><a href="#类型定义和类型别名的区别">类型定义和类型别名的区别</a></li>
</ul></li>
<li><a href="#结构体">结构体</a>
<ul>
<li><a href="#结构体的定义">结构体的定义</a></li>
<li><a href="#结构体实例化">结构体实例化</a>
<ul>
<li><a href="#基本实例化">基本实例化</a></li>
<li><a href="#匿名结构体">匿名结构体</a></li>
<li><a href="#创建指针类型结构体">创建指针类型结构体</a></li>
<li><a href="#取结构体的地址实例化">取结构体的地址实例化</a></li>
</ul></li>
<li><a href="#结构体初始化">结构体初始化</a>
<ul>
<li><a href="#使用键值对初始化">使用键值对初始化</a></li>
<li><a href="#使用值的列表初始化">使用值的列表初始化</a></li>
</ul></li>
<li><a href="#结构体内存布局">结构体内存布局</a>
<ul>
<li><a href="#空结构体">空结构体</a></li>
</ul></li>
<li><a href="#面试题">面试题</a></li>
</ul></li>
<li><a href="#构造函数">构造函数</a></li>
<li><a href="#方法和接收者">方法和接收者</a>
<ul>
<li><a href="#指针类型的接收者">指针类型的接收者</a></li>
<li><a href="#值类型的接收者">值类型的接收者</a></li>
<li><a href="#什么时候应该使用指针类型接收者">什么时候应该使用指针类型接收者</a></li>
</ul></li>
<li><a href="#任意类型添加方法">任意类型添加方法</a></li>
<li><a href="#结构体的匿名字段">结构体的匿名字段</a></li>
<li><a href="#嵌套结构体">嵌套结构体</a>
<ul>
<li><a href="#嵌套匿名字段">嵌套匿名字段</a></li>
<li><a href="#嵌套结构体的字段名冲突">嵌套结构体的字段名冲突</a></li>
</ul></li>
<li><a href="#结构体的-继承">结构体的“继承”</a></li>
<li><a href="#结构体字段的可见性">结构体字段的可见性</a></li>
<li><a href="#结构体与json序列化">结构体与JSON序列化</a></li>
<li><a href="#结构体标签-tag">结构体标签（Tag）</a></li>
<li><a href="#结构体和方法补充知识点">结构体和方法补充知识点</a></li>
<li><a href="#练习题-8">练习题</a></li>
</ul></li>
<li><a href="#go语言基础之接口">Go语言基础之接口</a>
<ul>
<li><a href="#接口类型">接口类型</a>
<ul>
<li><a href="#接口的定义">接口的定义</a></li>
<li><a href="#实现接口的条件">实现接口的条件</a></li>
<li><a href="#为什么要使用接口">为什么要使用接口？</a></li>
<li><a href="#面向接口编程">面向接口编程</a></li>
<li><a href="#接口类型变量">接口类型变量</a></li>
</ul></li>
<li><a href="#值接收者和指针接收者">值接收者和指针接收者</a>
<ul>
<li><a href="#值接收者实现接口">值接收者实现接口</a></li>
<li><a href="#指针接收者实现接口">指针接收者实现接口</a></li>
</ul></li>
<li><a href="#类型与接口的关系">类型与接口的关系</a>
<ul>
<li><a href="#一个类型实现多个接口">一个类型实现多个接口</a></li>
<li><a href="#多种类型实现同一接口">多种类型实现同一接口</a></li>
</ul></li>
<li><a href="#接口组合">接口组合</a></li>
<li><a href="#空接口">空接口</a>
<ul>
<li><a href="#空接口的定义">空接口的定义</a></li>
<li><a href="#空接口的应用">空接口的应用</a>
<ul>
<li><a href="#空接口作为函数的参数">空接口作为函数的参数</a></li>
<li><a href="#空接口作为map的值">空接口作为map的值</a></li>
</ul></li>
</ul></li>
<li><a href="#接口值">接口值</a></li>
<li><a href="#类型断言">类型断言</a></li>
<li><a href="#练习题-9">练习题</a></li>
</ul></li>
<li><a href="#error接口和错误处理">Error接口和错误处理</a>
<ul>
<li><a href="#error-接口">Error 接口</a></li>
<li><a href="#error-接口-1">Error 接口</a>
<ul>
<li><a href="#创建错误">创建错误</a>
<ul>
<li><a href="#errors-new">errors.New</a></li>
</ul></li>
<li><a href="#fmt-errorf">fmt.Errorf</a></li>
<li><a href="#错误结构体类型">错误结构体类型</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之反射">Go语言基础之反射</a>
<ul>
<li><a href="#变量的内在机制">变量的内在机制</a></li>
<li><a href="#反射介绍">反射介绍</a></li>
<li><a href="#reflect包">reflect包</a>
<ul>
<li><a href="#typeof">TypeOf</a>
<ul>
<li><a href="#type-name和type-kind">type name和type kind</a></li>
</ul></li>
<li><a href="#valueof">ValueOf</a>
<ul>
<li><a href="#通过反射获取值">通过反射获取值</a></li>
<li><a href="#通过反射设置变量的值">通过反射设置变量的值</a></li>
<li><a href="#isnil-和isvalid">isNil()和isValid()</a>
<ul>
<li><a href="#isnil">isNil()</a></li>
<li><a href="#isvalid">isValid()</a></li>
<li><a href="#举个例子-2">举个例子</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#结构体反射">结构体反射</a>
<ul>
<li><a href="#与结构体相关的方法">与结构体相关的方法</a></li>
<li><a href="#structfield类型">StructField类型</a></li>
<li><a href="#结构体反射示例">结构体反射示例</a></li>
</ul></li>
<li><a href="#反射是把双刃剑">反射是把双刃剑</a></li>
<li><a href="#练习题-10">练习题</a></li>
</ul></li>
<li><a href="#处理并发错误">处理并发错误</a>
<ul>
<li><a href="#recover-goroutine中的panic">recover goroutine中的panic</a></li>
<li><a href="#errgroup">errgroup</a></li>
</ul></li>
<li><a href="#go语言基础之网络编程">Go语言基础之网络编程</a>
<ul>
<li><a href="#互联网协议介绍">互联网协议介绍</a>
<ul>
<li><a href="#互联网分层模型">互联网分层模型</a></li>
<li><a href="#物理层">物理层</a></li>
<li><a href="#数据链路层">数据链路层</a></li>
<li><a href="#网络层">网络层</a></li>
<li><a href="#传输层">传输层</a></li>
<li><a href="#应用层">应用层</a></li>
</ul></li>
<li><a href="#socket编程">socket编程</a>
<ul>
<li><a href="#socket图解">socket图解</a></li>
</ul></li>
<li><a href="#go语言实现tcp通信">Go语言实现TCP通信</a>
<ul>
<li><a href="#tcp协议">TCP协议</a></li>
<li><a href="#tcp服务端">TCP服务端</a></li>
<li><a href="#tcp客户端">TCP客户端</a></li>
</ul></li>
<li><a href="#tcp黏包">TCP黏包</a>
<ul>
<li><a href="#黏包示例">黏包示例</a></li>
<li><a href="#为什么会出现粘包">为什么会出现粘包</a></li>
<li><a href="#解决办法">解决办法</a></li>
</ul></li>
<li><a href="#go语言实现udp通信">Go语言实现UDP通信</a>
<ul>
<li><a href="#udp协议">UDP协议</a></li>
<li><a href="#udp服务端">UDP服务端</a></li>
<li><a href="#udp客户端">UDP客户端</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之单元测试">Go语言基础之单元测试</a>
<ul>
<li><a href="#go-test工具">go test工具</a></li>
<li><a href="#测试函数">测试函数</a>
<ul>
<li><a href="#测试函数的格式">测试函数的格式</a></li>
<li><a href="#测试函数示例">测试函数示例</a></li>
<li><a href="#测试组">测试组</a></li>
<li><a href="#子测试">子测试</a></li>
<li><a href="#测试覆盖率">测试覆盖率</a></li>
</ul></li>
<li><a href="#基准测试">基准测试</a>
<ul>
<li><a href="#基准测试函数格式">基准测试函数格式</a></li>
<li><a href="#基准测试示例">基准测试示例</a></li>
<li><a href="#性能比较函数">性能比较函数</a></li>
<li><a href="#重置时间">重置时间</a></li>
<li><a href="#并行测试">并行测试</a></li>
</ul></li>
<li><a href="#setup与teardown">Setup与TearDown</a>
<ul>
<li><a href="#testmain">TestMain</a></li>
<li><a href="#子测试的setup与teardown">子测试的Setup与Teardown</a></li>
</ul></li>
<li><a href="#示例函数">示例函数</a>
<ul>
<li><a href="#示例函数的格式">示例函数的格式</a></li>
<li><a href="#示例函数示例">示例函数示例</a></li>
</ul></li>
<li><a href="#练习题-11">练习题</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言常用标准库">Go语言常用标准库</a>
<ul>
<li><a href="#go语言标准库之fmt与格式化占位符">Go语言标准库之fmt与格式化占位符</a>
<ul>
<li><a href="#fmt">fmt</a>
<ul>
<li><a href="#向外输出">向外输出</a>
<ul>
<li><a href="#print">Print</a></li>
<li><a href="#fprint">Fprint</a></li>
<li><a href="#sprint">Sprint</a></li>
<li><a href="#errorf">Errorf</a></li>
</ul></li>
<li><a href="#格式化占位符">格式化占位符</a>
<ul>
<li><a href="#通用占位符">通用占位符</a></li>
<li><a href="#布尔型">布尔型</a></li>
<li><a href="#整型-1">整型</a></li>
<li><a href="#浮点数与复数">浮点数与复数</a></li>
<li><a href="#字符串和-byte">字符串和[]byte</a></li>
</ul></li>
<li><a href="#指针">指针</a>
<ul>
<li><a href="#宽度标识符">宽度标识符</a></li>
<li><a href="#其他flag">其他flag</a></li>
</ul></li>
<li><a href="#获取输入">获取输入</a>
<ul>
<li><a href="#fmt-scan">fmt.Scan</a></li>
<li><a href="#fmt-scanf">fmt.Scanf</a></li>
<li><a href="#fmt-scanln">fmt.Scanln</a></li>
<li><a href="#bufio-newreader">bufio.NewReader</a></li>
<li><a href="#fscan系列">Fscan系列</a></li>
<li><a href="#sscan系列">Sscan系列</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之time包">Go语言基础之time包</a>
<ul>
<li><a href="#时间类型">时间类型</a></li>
<li><a href="#location和time-zone">Location和time zone</a></li>
<li><a href="#unix-time">Unix Time</a></li>
<li><a href="#时间间隔">时间间隔</a>
<ul>
<li><a href="#时间操作">时间操作</a></li>
<li><a href="#add">Add</a></li>
<li><a href="#sub">Sub</a></li>
<li><a href="#equal">Equal</a></li>
<li><a href="#before">Before</a></li>
<li><a href="#after">After</a></li>
</ul></li>
<li><a href="#定时器">定时器</a></li>
<li><a href="#时间格式化">时间格式化</a></li>
<li><a href="#解析字符串格式的时间">解析字符串格式的时间</a></li>
<li><a href="#练习题-12">练习题</a></li>
</ul></li>
<li><a href="#go语言标准库flag基本使用">Go语言标准库flag基本使用</a>
<ul>
<li><a href="#os-args">os.Args</a></li>
<li><a href="#flag包基本使用">flag包基本使用</a>
<ul>
<li><a href="#导入flag包">导入flag包</a></li>
<li><a href="#flag参数类型">flag参数类型</a></li>
<li><a href="#定义命令行flag参数">定义命令行flag参数</a>
<ul>
<li><a href="#flag-type">flag.Type()</a></li>
<li><a href="#flag-typevar">flag.TypeVar()</a></li>
</ul></li>
<li><a href="#flag-parse">flag.Parse()</a></li>
<li><a href="#flag其他函数">flag其他函数</a></li>
<li><a href="#完整示例">完整示例</a>
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#使用">使用</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#go语言标准库log介绍">Go语言标准库log介绍</a>
<ul>
<li><a href="#使用logger">使用Logger</a></li>
<li><a href="#配置logger">配置logger</a>
<ul>
<li><a href="#标准logger的配置">标准logger的配置</a></li>
<li><a href="#flag选项">flag选项</a></li>
<li><a href="#配置日志前缀">配置日志前缀</a></li>
<li><a href="#配置日志输出位置">配置日志输出位置</a></li>
</ul></li>
<li><a href="#创建logger">创建logger</a></li>
<li><a href="#总结">总结</a></li>
</ul></li>
<li><a href="#go语言文件操作">Go语言文件操作</a>
<ul>
<li><a href="#打开和关闭文件">打开和关闭文件</a></li>
<li><a href="#读取文件">读取文件</a>
<ul>
<li><a href="#file-read">file.Read()</a>
<ul>
<li><a href="#基本使用">基本使用</a></li>
<li><a href="#循环读取">循环读取</a></li>
</ul></li>
<li><a href="#bufio读取文件">bufio读取文件</a></li>
<li><a href="#ioutil读取整个文件">ioutil读取整个文件</a></li>
</ul></li>
<li><a href="#文件写入操作">文件写入操作</a>
<ul>
<li><a href="#write和writestring">Write和WriteString</a></li>
<li><a href="#bufio-newwriter">bufio.NewWriter</a></li>
<li><a href="#ioutil-writefile">ioutil.WriteFile</a></li>
</ul></li>
<li><a href="#练习">练习</a></li>
<li><a href="#copyfile">copyFile</a></li>
<li><a href="#实现一个cat命令">实现一个cat命令</a></li>
</ul></li>
<li><a href="#go语言内置包之strconv">Go语言内置包之strconv</a>
<ul>
<li><a href="#string与int类型转换">string与int类型转换</a>
<ul>
<li><a href="#atoi">Atoi()</a></li>
<li><a href="#itoa">Itoa()</a></li>
<li><a href="#a的典故">a的典故</a></li>
</ul></li>
<li><a href="#parse系列函数">Parse系列函数</a>
<ul>
<li><a href="#parsebool">ParseBool()</a></li>
<li><a href="#parseint">ParseInt()</a></li>
<li><a href="#parseunit">ParseUnit()</a></li>
<li><a href="#parsefloat">ParseFloat()</a></li>
<li><a href="#代码示例">代码示例</a></li>
</ul></li>
<li><a href="#format系列函数">Format系列函数</a>
<ul>
<li><a href="#formatbool">FormatBool()</a></li>
<li><a href="#formatint">FormatInt()</a></li>
<li><a href="#formatuint">FormatUint()</a></li>
<li><a href="#formatfloat">FormatFloat()</a></li>
<li><a href="#代码示例-1">代码示例</a></li>
</ul></li>
<li><a href="#其他">其他</a>
<ul>
<li><a href="#isprint">isPrint()</a></li>
<li><a href="#canbackquote">CanBackquote()</a></li>
<li><a href="#其他-1">其他</a></li>
</ul></li>
</ul></li>
<li><a href="#go语言基础之net-http">Go语言基础之net/http</a>
<ul>
<li><a href="#net-http介绍">net/http介绍</a>
<ul>
<li><a href="#http协议">HTTP协议</a></li>
</ul></li>
<li><a href="#http客户端">HTTP客户端</a>
<ul>
<li><a href="#基本的http-https请求">基本的HTTP/HTTPS请求</a></li>
<li><a href="#get请求示例">GET请求示例</a></li>
<li><a href="#带参数的get请求示例">带参数的GET请求示例</a></li>
<li><a href="#post请求示例">Post请求示例</a></li>
<li><a href="#自定义client">自定义Client</a></li>
<li><a href="#自定义transport">自定义Transport</a></li>
</ul></li>
<li><a href="#服务端">服务端</a>
<ul>
<li><a href="#默认的server">默认的Server</a></li>
<li><a href="#默认的server示例">默认的Server示例</a></li>
<li><a href="#自定义server">自定义Server</a></li>
</ul></li>
</ul></li>
<li><a href="#go标准库context">Go标准库Context</a>
<ul>
<li><a href="#为什么需要context">为什么需要Context</a>
<ul>
<li><a href="#基本示例">基本示例</a></li>
<li><a href="#全局变量方式">全局变量方式</a></li>
<li><a href="#通道方式">通道方式</a></li>
<li><a href="#官方版的方案">官方版的方案</a></li>
</ul></li>
<li><a href="#context初识">Context初识</a></li>
<li><a href="#context接口">Context接口</a>
<ul>
<li><a href="#background-和todo">Background()和TODO()</a></li>
</ul></li>
<li><a href="#with系列函数">With系列函数</a>
<ul>
<li><a href="#withcancel">WithCancel</a></li>
<li><a href="#withdeadline">WithDeadline</a></li>
<li><a href="#withtimeout">WithTimeout</a></li>
<li><a href="#withvalue">WithValue</a></li>
</ul></li>
<li><a href="#使用context的注意事项">使用Context的注意事项</a></li>
<li><a href="#客户端超时取消示例">客户端超时取消示例</a>
<ul>
<li><a href="#server端">server端</a></li>
<li><a href="#client端">client端</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
        </div>
      </nav>
    </div>
  </aside>
<main class="main" role="main"><div class="content">
  <article id="-" class="article article-type-" itemscope
    itemtype="https://schema.org/BlogPosting">
    
    <div class="article-header">
      <h1 itemprop="name">
  <a
    class="article-title"
    href="/2022/10/golang/"
    >Golang</a
  >
</h1>

      <div class="article-meta">
        <span class="article-date">
  <i class="icon icon-calendar-check"></i>
<a href="https://mumulx.gitee.io/2022/10/golang/" class="article-date">
  <time datetime="2022-10-24 00:00:00 &#43;0000 UTC" itemprop="datePublished">2022-10-24</time>
</a>
</span><span class="article-category">
  <i class="icon icon-folder"></i>
  <a class="article-category-link" href="/categories/golang/"> Golang </a>
</span>  
  <span class="article-tag">
    <i class="icon icon-tags"></i>
    <a class="article-tag-link" href="/tags/golang/"> Golang </a>
  </span>

	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>
        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/10/golang/#comments"
            class="article-comment-link">评论</a></span>
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计:95926字</span>
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长:192分 </span>
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      

<h1 id="golang">Golang</h1>

<h2 id="为什么你应该学习go语言">为什么你应该学习Go语言？</h2>

<p>终于等到你！Go语言——让你用写Python代码的开发效率编写C语言代码。</p>

<h2 id="为什么互联网世界需要go语言">为什么互联网世界需要Go语言</h2>

<p>世界上已经有太多太多的编程语言了，为什么又出来一个Go语言？</p>

<p><a href="https://www.liwenzhou.com/posts/Go/golang-menu/">李文周的博客</a></p>

<h3 id="硬件限制-摩尔定律已然失效">硬件限制：摩尔定律已然失效</h3>

<blockquote>
<p>摩尔定律：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。 换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。</p>
</blockquote>

<p><img src="/resources/技术收录/golang/15511542807193.jpg" alt="img" /></p>

<p>从上面的图表可以看出，近十年单线程性能和处理器频率保持稳定。我们不能像之前一样把添加更多晶体管当成是解决方案，因为在较小规模上一些量子特性开始出现（如隧道效应），并且因为在同样小的空间里放置更多晶体管的代价非常昂贵，每1美元可以添加的晶体管数量开始下降。</p>

<p>制造商开始从其他方面提高处理器的性能：</p>

<ol>
<li>向处理器添加越来越多的内核，如四核和八核CPU。</li>
<li>发明了超线程技术。</li>
<li>为处理器添加了更多缓存以提高性能。</li>
</ol>

<p>但上述解决方案也有其自身的局限性。因为成本原因我们不能无限制的为计算机添加内核，也无法无限制的添加缓存来提高性能，因为缓存越大，取值的性能越低。</p>

<p>我们没有办法在硬件上一直取得突破，我们需要提高软件的性能或者说我们需要高性能的软件。</p>

<h3 id="go语言为并发而生">Go语言为并发而生</h3>

<p>如上所述，硬件制造商正在为处理器添加越来越多的内核以提高性能。所有数据中心都在这些处理器上运行，更重要的是，今天的应用程序使用多个微服务来维护数据库连接，消息队列和维护缓存。因此，开发的软件和编程语言应该可以轻松地支持并发性，并且应该能够随着CPU核心数量的增加而可扩展。</p>

<p>但是，大多数现代编程语言（如Java，Python等）都来自90年代的单线程环境。虽然一些编程语言的框架在不断地提高多核资源使用效率，例如 Java 的 Netty 等，但仍然需要开发人员花费大量的时间和精力搞懂这些框架的运行原理后才能熟练掌握。</p>

<p>Go于2009年发布，当时多核处理器已经上市。Go语言在多核并发上拥有原生的设计优势，Go语言从底层原生支持并发，无须第三方库、开发者的编程技巧和开发经验。</p>

<p>很多公司，特别是中国的互联网公司，即将或者已经完成了使用 Go 语言改造旧系统的过程。经过 Go 语言重构的系统能使用更少的硬件资源获得更高的并发和I/O吞吐表现。充分挖掘硬件设备的潜力也满足当前精细化运营的市场大环境。</p>

<p>Go语言的并发是基于 <code>goroutine</code> 的，<code>goroutine</code> 类似于线程，但并非线程。可以将 <code>goroutine</code> 理解为一种虚拟线程。Go 语言运行时会参与调度 <code>goroutine</code>，并将 <code>goroutine</code> 合理地分配到每个 CPU 中，最大限度地使用CPU性能。开启一个<code>goroutine</code>的消耗非常小（大约2KB的内存），你可以轻松创建数百万个<code>goroutine</code>。</p>

<p><code>goroutine</code>的特点：</p>

<ol>
<li><code>goroutine</code>具有可增长的分段堆栈。这意味着它们只在需要时才会使用更多内存。</li>
<li><code>goroutine</code>的启动时间比线程快。</li>
<li><code>goroutine</code>原生支持利用channel安全地进行通信。</li>
<li><code>goroutine</code>共享数据结构时无需使用互斥锁。</li>
</ol>

<h3 id="go性能强悍">Go性能强悍</h3>

<p>与其他现代高级语言（如Java/Python）相比，使用C，C++的最大好处是它们的性能。因为C/ C++是编译型语言而不是解释的语言。 处理器只能理解二进制文件，Java和Python这种高级语言在运行的时候需要先将人类可读的代码翻译成字节码，然后由专门的解释器再转变成处理器可以理解的二进制文件。<img src="/resources/技术收录/golang/15511649241043.jpg" alt="-w839" />同C,C++一样，Go语言也是编译型的语言，它直接将人类可读的代码编译成了处理器可以直接运行的二进制文件，执行效率更高，性能更好。<img src="/resources/技术收录/golang/15511709770708.jpg" alt="-w1112" />数据来源：<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/">https://benchmarksgame-team.pages.debian.net/benchmarksgame/</a></p>

<p>可以看出，Go 语言在性能上更接近于 Java 语言，虽然在某些测试用例上不如经过多年优化的 Java 语言，但毕竟 Java 语言已经经历了多年的积累和优化。Go 语言在未来的版本中会通过不断的版本优化提高单核运行性能。</p>

<h3 id="go语言简单易学">Go语言简单易学</h3>

<h4 id="语法简洁">语法简洁</h4>

<p>Go 语言简单易学，学习曲线平缓，不需要像 C/C++ 语言动辄需要两到三年的学习期。Go 语言被称为“互联网时代的C语言”。Go 语言的风格类似于C语言。其语法在C语言的基础上进行了大幅的简化，去掉了不需要的表达式括号，循环也只有 for 一种表示方法，就可以实现数值、键值等各种遍历。</p>

<h4 id="代码风格统一">代码风格统一</h4>

<p>Go 语言提供了一套格式化工具——<code>go fmt</code>。一些 Go 语言的开发环境或者编辑器在保存时，都会使用格式化工具进行修改代码的格式化，这样就保证了不同开发者提交的代码都是统一的格式。(吐槽下：再也不用担心那些看不懂的黑魔法了…)</p>

<h4 id="开发效率高">开发效率高</h4>

<p><img src="/resources/技术收录/golang/15511721724188.jpg" alt="img" />Go语言实现了开发效率与执行效率的完美结合，让你像写Python代码（效率）一样编写C代码（性能）。</p>

<h2 id="学习go语言的前景">学习Go语言的前景</h2>

<p>目前Go语言已经⼴泛应用于人工智能、云计算开发、容器虚拟化、⼤数据开发、数据分析及科学计算、运维开发、爬虫开发、游戏开发等领域。</p>

<p>Go语言简单易学，天生支持并发，完美契合当下高并发的互联网生态。Go语言的岗位需求持续高涨，目前的Go程序员数量少，待遇好。</p>

<p>抓住趋势，要学会做一个领跑者而不是跟随者。</p>

<p>国内Go语言的需求潜力巨大，目前无论是国内大厂还是新兴互联网公司基本上都会有Go语言的岗位需求。</p>

<p>下图是应用Go语言的公司举例：</p>

<p><img src="/resources/技术收录/golang/image-20190203135218456.png" alt="image-20190203135218456" /></p>

<p>除了上面列出的大厂外，很多小型公司或创业公司也开始使用Go语言，并且很多公司把Go语言作为其主要开发语言。</p>

<p>现在就开始你的Go语言学习之旅吧！人生苦短，let’s Go.</p>

<p><a href="https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65">参考链接</a></p>

<h1 id="开发环境准备">开发环境准备</h1>

<h2 id="从零开始搭建go语言开发环境-新">从零开始搭建Go语言开发环境（新）</h2>

<p>Go1.14版本，一步一步，从零搭建Go语言开发环境。</p>

<p><strong>因为Go语言及相关编辑工具的更新迭代，本文已于2021/05/12更新，可能会和视频有所出入，请以更新后的本文为准。</strong></p>

<h3 id="安装go语言及搭建go语言开发环境">安装Go语言及搭建Go语言开发环境</h3>

<p><strong>注意：</strong>Go语言1.14版本之后推荐使用go modules管理依赖，也不再需要把代码写在GOPATH目录下了，之前旧版本的教程戳这个<a href="https://www.liwenzhou.com/posts/Go/install_go_dev_old/">链接</a>。</p>

<h3 id="下载">下载</h3>

<h4 id="下载地址">下载地址</h4>

<p>Go官网下载地址：<a href="https://golang.org/dl/">https://golang.org/dl/</a></p>

<p>Go官方镜像站（推荐）：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p>

<h4 id="版本的选择">版本的选择</h4>

<p>Windows平台和Mac平台推荐下载可执行文件版，Linux平台下载压缩文件版。</p>

<p><strong>下图中的版本号可能并不是最新的，但总体来说安装教程是类似的。Go语言更新迭代比较快，推荐使用较新版本，体验最新特性。</strong></p>

<p><img src="/resources/技术收录/golang/download1.png" alt="download1" /></p>

<h3 id="安装">安装</h3>

<h4 id="windows安装">Windows安装</h4>

<p>此安装实例以 <code>64位Win10</code>系统安装 <code>Go1.14.1可执行文件版本</code>为例。</p>

<p>将上一步选好的安装包下载到本地。</p>

<p><img src="/resources/技术收录/golang/download2.png" alt="download2" /></p>

<p>双击下载好的文件，然后按照下图的步骤安装即可。</p>

<p><img src="/resources/技术收录/golang/install01.png" alt="install01" /><img src="/resources/技术收录/golang/install02.png" alt="install02" /><img src="/resources/技术收录/golang/install03.png" alt="install03" /><img src="/resources/技术收录/golang/install04.png" alt="install04" /><img src="/resources/技术收录/golang/install05.png" alt="install05" /></p>

<h4 id="linux下安装">Linux下安装</h4>

<p>如果不是要在Linux平台敲go代码就不需要在Linux平台安装Go，我们开发机上写好的go代码只需要跨平台编译（详见文章末尾的跨平台编译）好之后就可以拷贝到Linux服务器上运行了，这也是go程序跨平台易部署的优势。</p>

<p>我们在版本选择页面选择并下载好<code>go1.14.1.linux-amd64.tar.gz</code>文件：</p>

<pre><code class="language-bash">wget https://dl.google.com/go/go1.14.1.linux-amd64.tar.gz
</code></pre>

<p>将下载好的文件解压到<code>/usr/local</code>目录下：</p>

<pre><code class="language-bash">tar -zxvf go1.14.1.linux-amd64.tar.gz -C /usr/local  # 解压
</code></pre>

<p>如果提示没有权限，加上<code>sudo</code>以root用户的身份再运行。执行完就可以在<code>/usr/local/</code>下看到<code>go</code>目录了。</p>

<p>配置环境变量： Linux下有两个文件可以配置环境变量，其中<code>/etc/profile</code>是对所有用户生效的；<code>$HOME/.profile</code>是对当前用户生效的，根据自己的情况自行选择一个文件打开，添加如下两行代码，保存退出。</p>

<pre><code class="language-bash">export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
</code></pre>

<p>修改<code>/etc/profile</code>后要重启生效，修改<code>$HOME/.profile</code>后使用source命令加载<code>$HOME/.profile</code>文件即可生效。 检查：</p>

<pre><code class="language-bash">~ go version
go version go1.14.1 linux/amd64
</code></pre>

<h4 id="mac下安装">Mac下安装</h4>

<p>下载可执行文件版，直接点击<strong>下一步</strong>安装即可，默认会将go安装到<code>/usr/local/go</code>目录下。<img src="/resources/技术收录/golang/mac_install_go.png" alt="Mac安装Go" /></p>

<h4 id="检查">检查</h4>

<p>上一步安装过程执行完毕后，可以打开终端窗口，输入<code>go version</code>命令，查看安装的Go版本。<img src="/resources/技术收录/golang/install06.png" alt="install06" /></p>

<h3 id="goroot和gopath">GOROOT和GOPATH</h3>

<p><code>GOROOT</code>和<code>GOPATH</code>都是环境变量，其中<code>GOROOT</code>是我们安装go开发包的路径，而从Go 1.8版本开始，Go开发包在安装完成后会为<code>GOPATH</code>设置一个默认目录，并且在Go1.14及之后的版本中启用了Go Module模式之后，不一定非要将代码写到GOPATH目录下，所以也就<strong>不需要我们再自己配置GOPATH</strong>了，使用默认的即可。</p>

<h4 id="goproxy-非常重要">GOPROXY 非常重要</h4>

<p>Go1.14版本之后，都推荐使用<code>go mod</code>模式来管理依赖环境了，也不再强制我们把代码必须写在<code>GOPATH</code>下面的src目录了，你可以在你电脑的任意位置编写go代码。（网上有些教程适用于1.11版本之前。）</p>

<p>默认GoPROXY配置是：<code>GOPROXY=https://proxy.golang.org,direct</code>，由于国内访问不到<code>https://proxy.golang.org</code>，所以我们需要换一个PROXY，这里推荐使用<code>https://goproxy.io</code>或<code>https://goproxy.cn</code>。</p>

<p>可以执行下面的命令修改GOPROXY：</p>

<pre><code class="language-bash">go env -w GOPROXY=https://goproxy.cn,direct
</code></pre>

<h3 id="go开发编辑器">Go开发编辑器</h3>

<p>Go采用的是UTF-8编码的文本文件存放源代码，理论上使用任何一款文本编辑器都可以做Go语言开发，这里推荐使用<code>VS Code</code>和<code>Goland</code>。 <code>VS Code</code>是微软开源的编辑器，而<code>Goland</code>是jetbrains出品的付费IDE。</p>

<p>我们这里使用<code>VS Code</code> 加插件做为go语言的开发工具。</p>

<h4 id="vs-code介绍">VS Code介绍</h4>

<p><code>VS Code</code>全称<code>Visual Studio Code</code>，是微软公司开源的一款<strong>免费</strong>现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，支持 Win、Mac 以及 Linux平台。</p>

<p>虽然不如某些IDE功能强大，但是它添加Go扩展插件后已经足够胜任我们日常的Go开发。</p>

<h4 id="下载与安装">下载与安装</h4>

<p><code>VS Code</code>官方下载地址：<a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></p>

<p>三大主流平台都支持，请根据自己的电脑平台选择对应的安装包。<img src="/resources/技术收录/golang/vscode_home.png" alt="vscode_home" />双击下载好的安装文件，双击安装即可。</p>

<h4 id="配置">配置</h4>

<h5 id="安装中文简体插件">安装中文简体插件</h5>

<p>点击左侧菜单栏最后一项<code>管理扩展</code>，在<code>搜索框</code>中输入<code>chinese</code> ，选中结果列表第一项，点击<code>install</code>安装。</p>

<p>安装完毕后右下角会提示<code>重启VS Code</code>，重启之后你的VS Code就显示中文啦！<img src="https://www.liwenzhou.com/images/Go/install_go_dev/vscode1.gif" alt="安装简体中文插件" /><code>VSCode</code>主界面介绍：<img src="/resources/技术收录/golang/vscode_menu.png" alt="vscode_menu" /></p>

<h5 id="安装go扩展">安装go扩展</h5>

<p>现在我们要为我们的VS Code编辑器安装<code>Go</code>扩展插件，让它支持Go语言开发。<img src="/resources/技术收录/golang/vscode_plugin.png" alt="安装go扩展图" /></p>

<h3 id="第一个go程序">第一个Go程序</h3>

<h4 id="hello-world">Hello World</h4>

<p>现在我们来创建第一个Go项目——<code>hello</code>。在我们桌面创建一个<code>hello</code>目录。</p>

<h5 id="go-mod-init">go mod init</h5>

<p>使用go module模式新建项目时，我们需要通过<code>go mod init 项目名</code>命令对项目进行初始化，该命令会在项目根目录下生成<code>go.mod</code>文件。例如，我们使用<code>hello</code>作为我们第一个Go项目的名称，执行如下命令。</p>

<pre><code class="language-bash">go mod init hello
</code></pre>

<h5 id="编写代码">编写代码</h5>

<p>接下来在该目录中创建一个<code>main.go</code>文件：</p>

<pre><code class="language-go">package main  // 声明 main 包，表明当前是一个可执行程序

import &quot;fmt&quot;  // 导入内置 fmt 包

func main(){  // main函数，是程序执行的入口
	fmt.Println(&quot;Hello World!&quot;)  // 在终端打印 Hello World!
}
</code></pre>

<p><strong>非常重要！！！</strong> 如果此时VS Code右下角弹出提示让你安装插件，务必点 <strong>install all</strong> 进行安装。</p>

<h4 id="编译">编译</h4>

<p><code>go build</code>命令表示将源代码编译成可执行文件。</p>

<p>在hello目录下执行：</p>

<pre><code class="language-bash">go build
</code></pre>

<p>或者在其他目录执行以下命令：</p>

<pre><code class="language-bash">go build hello
</code></pre>

<p>go编译器会去 <code>GOPATH</code>的src目录下查找你要编译的<code>hello</code>项目</p>

<p>编译得到的可执行文件会保存在执行编译命令的当前目录下，如果是windows平台会在当前目录下找到<code>hello.exe</code>可执行文件。</p>

<p>可在终端直接执行该<code>hello.exe</code>文件：</p>

<pre><code class="language-bash">c:\desktop\hello&gt;hello.exe
Hello World!
</code></pre>

<p>我们还可以使用<code>-o</code>参数来指定编译后得到的可执行文件的名字。</p>

<pre><code class="language-bash">go build -o heiheihei.exe
</code></pre>

<h4 id="windows下vscode切换cmd-exe作为默认终端">Windows下VSCode切换cmd.exe作为默认终端</h4>

<p>如果你打开VS Code的终端界面出现如下图场景（注意观察红框圈中部分），那么你的<code>VS Code</code>此时正使用<code>powershell</code>作为默认终端：<img src="/resources/技术收录/golang/vscode_shell1.png" alt="vscode shell配置1" />十分推荐你按照下面的步骤，选择<code>cmd.exe</code>作为默认的终端工具：<img src="/resources/技术收录/golang/vscode_shell2.png" alt="vscode shell配置2" />此时，VS Code正上方中间位置会弹出如下界面，参照下图挪动鼠标使光标选中后缀为<code>cmd.exe</code>的那一个，然后点击鼠标左键。</p>

<p>最后<strong>重启VS Code中已经打开的终端</strong>或者<strong>直接重启VS Code</strong>就可以了。<img src="/resources/技术收录/golang/vscode_shell3.png" alt="vscode shell配置3" />如果没有出现下拉三角，也没有关系，按下<code>Ctrl+Shift+P</code>，VS Code正上方会出现一个框，你按照下图输入<code>shell</code>，然后点击指定选项即可出现上面的界面了。<img src="/resources/技术收录/golang/vscode_shell4.png" alt="vscode shell配置4" /></p>

<h4 id="go-run">go run</h4>

<p><code>go run main.go</code>也可以执行程序，该命令本质上也是先编译再执行。</p>

<h4 id="go-install">go install</h4>

<p><code>go install</code>表示安装的意思，它先编译源代码得到可执行文件，然后将可执行文件移动到<code>GOPATH</code>的bin目录下。因为我们的环境变量中配置了<code>GOPATH</code>下的bin目录，所以我们就可以在任意地方直接执行可执行文件了。</p>

<h4 id="跨平台编译">跨平台编译</h4>

<p>默认我们<code>go build</code>的可执行文件都是当前操作系统可执行的文件，Go语言支持跨平台编译——在当前平台（例如Windows）下编译其他平台（例如Linux）的可执行文件。</p>

<p>Windows编译Linux可执行文件</p>

<p>如果我想在Windows下编译一个Linux下可执行文件，那需要怎么做呢？只需要在编译时指定目标操作系统的平台和处理器架构即可。</p>

<blockquote>
<p>注意：无论你在Windows电脑上使用VsCode编辑器还是Goland编辑器，都要注意你使用的终端类型，因为不同的终端下命令不一样！！！目前的Windows通常默认使用的是<code>PowerShell</code>终端。</p>
</blockquote>

<p>如果你的<code>Windows</code>使用的是<code>cmd</code>，那么按如下方式指定环境变量。</p>

<pre><code class="language-bash">SET CGO_ENABLED=0  // 禁用CGO
SET GOOS=linux  // 目标平台是linux
SET GOARCH=amd64  // 目标处理器架构是amd64
</code></pre>

<p>如果你的<code>Windows</code>使用的是<code>PowerShell</code>终端，那么设置环境变量的语法为</p>

<pre><code class="language-bash">$ENV:CGO_ENABLED=0
$ENV:GOOS=&quot;linux&quot;
$ENV:GOARCH=&quot;amd64&quot;
</code></pre>

<p>在你的<code>Windows</code>终端下执行完上述命令后，再执行下面的命令，得到的就是能够在Linux平台运行的可执行文件了。</p>

<pre><code class="language-bash">go build
</code></pre>

<p>Windows编译Mac可执行文件</p>

<p>Windows下编译Mac平台64位可执行程序：</p>

<p>cmd终端下执行：</p>

<pre><code class="language-bash">SET CGO_ENABLED=0
SET GOOS=darwin
SET GOARCH=amd64
go build
</code></pre>

<p>PowerShell终端下执行：</p>

<pre><code class="language-bash">$ENV:CGO_ENABLED=0
$ENV:GOOS=&quot;darwin&quot;
$ENV:GOARCH=&quot;amd64&quot;
go build
</code></pre>

<h5 id="mac编译linux可执行文件">Mac编译Linux可执行文件</h5>

<p>Mac电脑编译得到Linux平台64位可执行程序：</p>

<pre><code class="language-bash">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build
</code></pre>

<h5 id="mac编译windows可执行文件">Mac编译Windows可执行文件</h5>

<p>Mac电脑编译得到Windows平台64位可执行程序：</p>

<pre><code class="language-bash">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build
</code></pre>

<h5 id="linux编译mac可执行文件">Linux编译Mac可执行文件</h5>

<p>Linux平台下编译Mac平台64位可执行程序：</p>

<pre><code class="language-bash">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build
</code></pre>

<h5 id="linux编译windows可执行文件">Linux编译Windows可执行文件</h5>

<p>Linux平台下编译Windows平台64位可执行程序：</p>

<pre><code class="language-bash">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build
</code></pre>

<p>现在，开启你的Go语言学习之旅吧。人生苦短，let’s Go.</p>

<h2 id="vs-code配置go语言开发环境">VS Code配置Go语言开发环境</h2>

<p>VS Code是微软开源的一款编辑器，插件系统十分的丰富。本文就介绍了如何使用VS Code搭建Go语言开发环境。</p>

<p><strong>因为Go语言及相关编辑工具的更新迭代，本文已于2020/03/25更新，可能会和视频有所出入，请以更新后的本文为准。</strong></p>

<p>说在前面的话，Go语言是采用UTF8编码的，理论上使用任何文本编辑器都能做Go语言开发。大家可以根据自己的喜好自行选择。编辑器/IDE没有最好只有最适合。</p>

<h3 id="下载与安装-1">下载与安装</h3>

<p><code>VS Code</code>官方下载地址：<a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></p>

<p>三大主流平台都支持，请根据自己的电脑平台选择对应的安装包。<img src="/resources/技术收录/golang/vscode_home-166659257246841.png" alt="vscode_home" />双击下载好的安装文件，双击安装即可。</p>

<h3 id="安装中文简体插件-1">安装中文简体插件</h3>

<p>点击左侧菜单栏最后一项<code>管理扩展</code>，在<code>搜索框</code>中输入<code>chinese</code> ，选中结果列表第一项，点击<code>install</code>安装。</p>

<p>安装完毕后右下角会提示<code>重启VS Code</code>，重启之后你的VS Code就显示中文啦！<img src="https://www.liwenzhou.com/images/Go/install_go_dev/vscode1.gif" alt="安装简体中文插件" /><code>VSCode</code>主界面介绍：<img src="/resources/技术收录/golang/vscode_menu-166659257246844.png" alt="vscode_menu" /></p>

<h3 id="安装go开发扩展">安装Go开发扩展</h3>

<p>现在我们要为我们的VS Code编辑器安装<code>Go</code>扩展插件，让它支持Go语言开发。<img src="/resources/技术收录/golang/vscode_plugin-166659257246846.png" alt="安装go扩展图" /></p>

<h3 id="变更编辑器主题">变更编辑器主题</h3>

<p>依次点击<code>设置-&gt;颜色主题</code>，<img src="/resources/技术收录/golang/vscode_theme01.png" alt="vscode_theme" />会弹出如下窗口：<img src="/resources/技术收录/golang/vscode_theme02.png" alt="vscode_theme" />可以根据自己的喜好选择相应的主题。</p>

<h3 id="安装go语言开发工具包">安装Go语言开发工具包</h3>

<p>在座Go语言开发的时候为我们提供诸如代码提示、代码自动补全等功能。</p>

<p>在此之前请先设置<code>GOPROXY</code>，打开终端执行以下命令：</p>

<pre><code class="language-bash">go env -w GOPROXY=https://goproxy.cn,direct
</code></pre>

<p>Windows平台按下<code>Ctrl+Shift+P</code>，Mac平台按<code>Command+Shift+P</code>，这个时候VS Code界面会弹出一个输入框，如下图：<img src="/resources/技术收录/golang/vscode09.png" alt="vscode09" /></p>

<p>我们在这个输入框中输入<code>&gt;go:install</code>，下面会自动搜索相关命令，我们选择<code>Go:Install/Update Tools</code>这个命令，按下图选中并会回车执行该命令（或者使用鼠标点击该命令）<img src="/resources/技术收录/golang/vscode10.png" alt="vscode10" />在弹出的窗口选中所有，并点击“确定”按钮，进行安装。<img src="/resources/技术收录/golang/vscode11.png" alt="vscode11" /></p>

<p>然后会弹出如下窗口，开始安装工具：<img src="/resources/技术收录/golang/vscode12.png" alt="vscode12" /></p>

<p>喝口水，等待所有工具都安装成功，如下图所示:<img src="/resources/技术收录/golang/vscode14.png" alt="vscode14" /></p>

<h3 id="配置vscode开启自动保存">配置VSCode开启自动保存</h3>

<p>按下图依次点击 <code>文件-&gt;首选项-&gt;设置</code>，<img src="/resources/技术收录/golang/vscode15.png" alt="vscode15" />打开设置页面就能看到自动保存相关配置如下图，可以根据自己的喜好选择自动保存的方式：<img src="/resources/技术收录/golang/vscode16.png" alt="vscode16" /></p>

<h3 id="配置代码片段快捷键">配置代码片段快捷键</h3>

<p>还是按<code>Ctrl/Command+Shift+P</code>,按下图输入<code>&gt;snippets</code>，选择命令并执行：<img src="/resources/技术收录/golang/vscode17.png" alt="vscode16" /></p>

<p>然后在弹出的窗口点击选择<code>go</code>选项：<img src="/resources/技术收录/golang/vscode18.png" alt="vscode18" />然后弹出如下页面：<img src="/resources/技术收录/golang/vscode19.png" alt="vscode19" /></p>

<p>大家可以简单看下上面的注释，介绍了主要用法：</p>

<pre><code class="language-js">“这里放个名字”:{
    &quot;prefix&quot;: &quot;这个是快捷键&quot;,
    &quot;body&quot;: &quot;这里是按快捷键插入的代码片段&quot;,
    &quot;description&quot;: &quot;这里放提示信息的描述&quot;
}
</code></pre>

<p>其中<code>$0</code>表示最终光标提留的位置。 举个例子，我这里创建了两个快捷方式，一个是输入<code>pln</code>就会在编辑器中插入<code>fmt.Println()</code>代码；输入<code>plf</code>，就会插入<code>fmt.Printf(&quot;&quot;)</code>代码。</p>

<pre><code class="language-json">{
	&quot;println&quot;:{
		&quot;prefix&quot;: &quot;pln&quot;,
		&quot;body&quot;:&quot;fmt.Println($0)&quot;,
		&quot;description&quot;: &quot;println&quot;
	},
	&quot;printf&quot;:{
		&quot;prefix&quot;: &quot;plf&quot;,
		&quot;body&quot;: &quot;fmt.Printf(\&quot;$0\&quot;)&quot;,
		&quot;description&quot;: &quot;printf&quot;
	}
}
</code></pre>

<p>把上面的代码，按下图方式粘贴到配置文件中，保存并关闭配置文件即可。<img src="/resources/技术收录/golang/vscode20.png" alt="vscode20" />添加如上配置后，保存。 我们打开一个go文件，测试一下效果：<img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/vscode21.gif" alt="demo1" /></p>

<h2 id="go语言之依赖管理">Go语言之依赖管理</h2>

<p>Go语言的依赖管理随着版本的更迭正逐渐完善起来。</p>

<p><strong>依赖管理</strong></p>

<h3 id="为什么需要依赖管理">为什么需要依赖管理</h3>

<p>最早的时候，Go所依赖的所有的第三方库都放在GOPATH这个目录下面。这就导致了同一个库只能保存一个版本的代码。如果不同的项目依赖同一个第三方的库的不同版本，应该怎么解决？</p>

<h4 id="godep">godep</h4>

<p>Go语言从v1.5开始开始引入<code>vendor</code>模式，如果项目目录下有vendor目录，那么go工具链会优先使用<code>vendor</code>内的包进行编译、测试等。</p>

<p><code>godep</code>是一个通过vender模式实现的Go语言的第三方依赖管理工具，类似的还有由社区维护准官方包管理工具<code>dep</code>。</p>

<h4 id="安装-1">安装</h4>

<p>执行以下命令安装<code>godep</code>工具。</p>

<pre><code class="language-go">go get github.com/tools/godep
</code></pre>

<h4 id="基本命令">基本命令</h4>

<p>安装好godep之后，在终端输入<code>godep</code>查看支持的所有命令。</p>

<pre><code class="language-bash">godep save     将依赖项输出并复制到Godeps.json文件中
godep go       使用保存的依赖项运行go工具
godep get      下载并安装具有指定依赖项的包
godep path     打印依赖的GOPATH路径
godep restore  在GOPATH中拉取依赖的版本
godep update   更新选定的包或go版本
godep diff     显示当前和以前保存的依赖项集之间的差异
godep version  查看版本信息
</code></pre>

<p>使用<code>godep help [command]</code>可以看看具体命令的帮助信息。</p>

<h4 id="使用godep">使用godep</h4>

<p>在项目目录下执行<code>godep save</code>命令，会在当前项目中创建<code>Godeps</code>和<code>vender</code>两个文件夹。</p>

<p>其中<code>Godeps</code>文件夹下有一个<code>Godeps.json</code>的文件，里面记录了项目所依赖的包信息。 <code>vender</code>文件夹下是项目依赖的包的源代码文件。</p>

<h4 id="vender机制">vender机制</h4>

<p>Go1.5版本之后开始支持，能够控制Go语言程序编译时依赖包搜索路径的优先级。</p>

<p>例如查找项目的某个依赖包，首先会在项目根目录下的<code>vender</code>文件夹中查找，如果没有找到就会去<code>$GOAPTH/src</code>目录下查找。</p>

<h4 id="godep开发流程">godep开发流程</h4>

<ol>
<li>保证程序能够正常编译</li>
<li>执行<code>godep save</code>保存当前项目的所有第三方依赖的版本信息和代码</li>
<li>提交Godeps目录和vender目录到代码库。</li>
<li>如果要更新依赖的版本，可以直接修改<code>Godeps.json</code>文件中的对应项</li>
</ol>

<h3 id="go-module">go module</h3>

<p><code>go module</code>是Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，<code>go module</code>将是Go语言默认的依赖管理工具。</p>

<h4 id="go111module">GO111MODULE</h4>

<p>要启用<code>go module</code>支持首先要设置环境变量<code>GO111MODULE</code>，通过它可以开启或关闭模块支持，它有三个可选值：<code>off</code>、<code>on</code>、<code>auto</code>，默认值是<code>auto</code>。</p>

<ol>
<li><code>GO111MODULE=off</code>禁用模块支持，编译时会从<code>GOPATH</code>和<code>vendor</code>文件夹中查找包。</li>
<li><code>GO111MODULE=on</code>启用模块支持，编译时会忽略<code>GOPATH</code>和<code>vendor</code>文件夹，只根据 <code>go.mod</code>下载依赖。</li>
<li><code>GO111MODULE=auto</code>，当项目在<code>$GOPATH/src</code>外且项目根目录有<code>go.mod</code>文件时，开启模块支持。</li>
</ol>

<p>简单来说，设置<code>GO111MODULE=on</code>之后就可以使用<code>go module</code>了，以后就没有必要在GOPATH中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。</p>

<p>使用 go module 管理依赖后会在项目根目录下生成两个文件<code>go.mod</code>和<code>go.sum</code>。</p>

<h4 id="goproxy">GOPROXY</h4>

<p>Go1.11之后设置GOPROXY命令为：</p>

<pre><code class="language-bash">export GOPROXY=https://goproxy.cn
</code></pre>

<p>Go1.13之后<code>GOPROXY</code>默认值为<code>https://proxy.golang.org</code>，在国内是无法访问的，所以十分建议大家设置GOPROXY，这里我推荐使用<a href="https://studygolang.com/topics/10014">goproxy.cn</a>。</p>

<pre><code class="language-bash">go env -w GOPROXY=https://goproxy.cn,direct
</code></pre>

<h4 id="go-mod命令">go mod命令</h4>

<p>常用的<code>go mod</code>命令如下：</p>

<pre><code>go mod download    下载依赖的module到本地cache（默认为$GOPATH/pkg/mod目录）
go mod edit        编辑go.mod文件
go mod graph       打印模块依赖图
go mod init        初始化当前文件夹, 创建go.mod文件
go mod tidy        增加缺少的module，删除无用的module
go mod vendor      将依赖复制到vendor下
go mod verify      校验依赖
go mod why         解释为什么需要依赖
</code></pre>

<h4 id="go-mod">go.mod</h4>

<p>go.mod文件记录了项目所有的依赖信息，其结构大致如下：</p>

<pre><code class="language-sh">module github.com/Q1mi/studygo/blogger

go 1.12

require (
	github.com/DeanThompson/ginpprof v0.0.0-20190408063150-3be636683586
	github.com/gin-gonic/gin v1.4.0
	github.com/go-sql-driver/mysql v1.4.1
	github.com/jmoiron/sqlx v1.2.0
	github.com/satori/go.uuid v1.2.0
	google.golang.org/appengine v1.6.1 // indirect
)
</code></pre>

<p>其中，</p>

<ul>
<li><code>module</code>用来定义包名</li>
<li><code>require</code>用来定义依赖包及版本</li>
<li><code>indirect</code>表示间接引用</li>
</ul>

<h5 id="依赖的版本">依赖的版本</h5>

<p>go mod支持语义化版本号，比如<code>go get foo@v1.2.3</code>，也可以跟git的分支或tag，比如<code>go get foo@master</code>，当然也可以跟git提交哈希，比如<code>go get foo@e3702bed2</code>。关于依赖的版本支持以下几种格式：</p>

<pre><code class="language-go">gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7
gopkg.in/vmihailenco/msgpack.v2 v2.9.1
gopkg.in/yaml.v2 &lt;=v2.2.1
github.com/tatsushid/go-fastping v0.0.0-20160109021039-d7bb493dee3e
latest
</code></pre>

<h5 id="replace">replace</h5>

<p>在国内访问golang.org/x的各个包都需要翻墙，你可以在go.mod中使用replace替换成github上对应的库。</p>

<pre><code class="language-go">replace (
	golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac =&gt; github.com/golang/crypto v0.0.0-20180820150726-614d502a4dac
	golang.org/x/net v0.0.0-20180821023952-922f4815f713 =&gt; github.com/golang/net v0.0.0-20180826012351-8a410e7b638d
	golang.org/x/text v0.3.0 =&gt; github.com/golang/text v0.3.0
)
</code></pre>

<h5 id="go-get">go get</h5>

<p>在项目中执行<code>go get</code>命令可以下载依赖包，并且还可以指定下载的版本。</p>

<ol>
<li>运行<code>go get -u</code>将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</li>
<li>运行<code>go get -u=patch</code>将会升级到最新的修订版本</li>
<li>运行<code>go get package@version</code>将会升级到指定的版本号version</li>
</ol>

<p>如果下载所有依赖可以使用<code>go mod download</code>命令。</p>

<h5 id="整理依赖">整理依赖</h5>

<p>我们在代码中删除依赖代码后，相关的依赖库并不会在<code>go.mod</code>文件中自动移除。这种情况下我们可以使用<code>go mod tidy</code>命令更新<code>go.mod</code>中的依赖关系。</p>

<h4 id="go-mod-edit">go mod edit</h4>

<h5 id="格式化">格式化</h5>

<p>因为我们可以手动修改go.mod文件，所以有些时候需要格式化该文件。Go提供了一下命令：</p>

<pre><code class="language-bash">go mod edit -fmt
</code></pre>

<h5 id="添加依赖项">添加依赖项</h5>

<pre><code class="language-bash">go mod edit -require=golang.org/x/text
</code></pre>

<h5 id="移除依赖项">移除依赖项</h5>

<p>如果只是想修改<code>go.mod</code>文件中的内容，那么可以运行<code>go mod edit -droprequire=package path</code>，比如要在<code>go.mod</code>中移除<code>golang.org/x/text</code>包，可以使用如下命令：</p>

<pre><code class="language-bash">go mod edit -droprequire=golang.org/x/text
</code></pre>

<p>关于<code>go mod edit</code>的更多用法可以通过<code>go help mod edit</code>查看。</p>

<h3 id="在项目中使用go-module">在项目中使用go module</h3>

<h4 id="既有项目">既有项目</h4>

<p>如果需要对一个已经存在的项目启用<code>go module</code>，可以按照以下步骤操作：</p>

<ol>
<li>在项目目录下执行<code>go mod init</code>，生成一个<code>go.mod</code>文件。</li>
<li>执行<code>go get</code>，查找并记录当前项目的依赖，同时生成一个<code>go.sum</code>记录每个依赖库的版本和哈希值。</li>
</ol>

<h4 id="新项目">新项目</h4>

<p>对于一个新创建的项目，我们可以在项目文件夹下按照以下步骤操作：</p>

<ol>
<li>执行<code>go mod init 项目名</code>命令，在当前项目文件夹下创建一个<code>go.mod</code>文件。</li>
<li>手动编辑<code>go.mod</code>中的require依赖项或执行<code>go get</code>自动发现、维护依赖。</li>
</ol>

<h2 id="如何使用go-module导入本地包">如何使用go module导入本地包</h2>

<p><code>go module</code>是Go1.11版本之后官方推出的版本管理工具，并且从<code>Go1.13</code>版本开始，<code>go module</code>将是Go语言默认的依赖管理工具。到今天<code>Go1.14</code>版本推出之后<code>Go modules</code> 功能已经被正式推荐在生产环境下使用了。</p>

<p>这几天已经有很多教程讲解如何使用<code>go module</code>，以及如何使用<code>go module</code>导入gitlab私有仓库，我这里就不再啰嗦了。但是最近我发现很多小伙伴在群里问如何使用<code>go module</code>导入本地包，作为初学者大家刚开始接触package的时候肯定都是先在本地创建一个包，然后本地调用一下，然后就被卡住了。。。</p>

<p>这里就详细介绍下如何使用<code>go module</code>导入本地包。</p>

<h3 id="前提">前提</h3>

<p>假设我们现在有<code>moduledemo</code>和<code>mypackage</code>两个包，其中<code>moduledemo</code>包中会导入<code>mypackage</code>包并使用它的<code>New</code>方法。</p>

<p><code>mypackage/mypackage.go</code>内容如下：</p>

<pre><code class="language-go">package mypackage

import &quot;fmt&quot;

func New(){
	fmt.Println(&quot;mypackage.New&quot;)
}
</code></pre>

<p>我们现在分两种情况讨论：</p>

<h3 id="在同一个项目下">在同一个项目下</h3>

<p><strong>注意</strong>：在一个项目（project）下我们是可以定义多个包（package）的。</p>

<h4 id="目录结构">目录结构</h4>

<p>现在的情况是，我们在<code>moduledemo/main.go</code>中调用了<code>mypackage</code>这个包。</p>

<pre><code class="language-bash">moduledemo
├── go.mod
├── main.go
└── mypackage
    └── mypackage.go
</code></pre>

<h4 id="导入包">导入包</h4>

<p>这个时候，我们需要在<code>moduledemo/go.mod</code>中按如下定义：</p>

<pre><code class="language-go">module moduledemo

go 1.14
</code></pre>

<p>然后在<code>moduledemo/main.go</code>中按如下方式导入<code>mypackage</code></p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;moduledemo/mypackage&quot;  // 导入同一项目下的mypackage包
)
func main() {
	mypackage.New()
	fmt.Println(&quot;main&quot;)
}
</code></pre>

<h4 id="举个例子">举个例子</h4>

<p>举一反三，假设我们现在有文件目录结构如下：</p>

<pre><code class="language-bash">└── bubble
    ├── dao
    │   └── mysql.go
    ├── go.mod
    └── main.go
</code></pre>

<p>其中<code>bubble/go.mod</code>内容如下：</p>

<pre><code class="language-go">module github.com/q1mi/bubble

go 1.14
</code></pre>

<p><code>bubble/dao/mysql.go</code>内容如下：</p>

<pre><code class="language-go">package dao

import &quot;fmt&quot;

func New(){
	fmt.Println(&quot;mypackage.New&quot;)
}
</code></pre>

<p><code>bubble/main.go</code>内容如下：</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;github.com/q1mi/bubble/dao&quot;
)
func main() {
	dao.New()
	fmt.Println(&quot;main&quot;)
}
</code></pre>

<h3 id="不在同一个项目下">不在同一个项目下</h3>

<h4 id="目录结构-1">目录结构</h4>

<pre><code class="language-bash">├── moduledemo
│   ├── go.mod
│   └── main.go
└── mypackage
    ├── go.mod
    └── mypackage.go
</code></pre>

<h4 id="导入包-1">导入包</h4>

<p>这个时候，<code>mypackage</code>也需要进行module初始化，即拥有一个属于自己的<code>go.mod</code>文件，内容如下：</p>

<pre><code class="language-go">module mypackage

go 1.14
</code></pre>

<p>然后我们在<code>moduledemo/main.go</code>中按如下方式导入：</p>

<pre><code class="language-go">import (
	&quot;fmt&quot;
	&quot;mypackage&quot;
)
func main() {
	mypackage.New()
	fmt.Println(&quot;main&quot;)
}
</code></pre>

<p>因为这两个包不在同一个项目路径下，你想要导入本地包，并且这些包也没有发布到远程的github或其他代码仓库地址。这个时候我们就需要在<code>go.mod</code>文件中使用<code>replace</code>指令。</p>

<p>在调用方也就是<code>moduledemo/go.mod</code>中按如下方式指定使用相对路径来寻找<code>mypackage</code>这个包。</p>

<pre><code class="language-go">module moduledemo

go 1.14


require &quot;mypackage&quot; v0.0.0
replace &quot;mypackage&quot; =&gt; &quot;../mypackage&quot;
</code></pre>

<h4 id="举个例子-1">举个例子</h4>

<p>最后我们再举个例子巩固下上面的内容。</p>

<p>我们现在有文件目录结构如下：</p>

<pre><code class="language-bash">├── p1
│   ├── go.mod
│   └── main.go
└── p2
    ├── go.mod
    └── p2.go
</code></pre>

<p><code>p1/main.go</code>中想要导入<code>p2.go</code>中定义的函数。</p>

<p><code>p2/go.mod</code>内容如下：</p>

<pre><code class="language-go">module liwenzhou.com/q1mi/p2

go 1.14
</code></pre>

<p><code>p1/main.go</code>中按如下方式导入</p>

<pre><code class="language-go">import (
	&quot;fmt&quot;
	&quot;liwenzhou.com/q1mi/p2&quot;
)
func main() {
	p2.New()
	fmt.Println(&quot;main&quot;)
}
</code></pre>

<p>因为我并没有把<code>liwenzhou.com/q1mi/p2</code>这个包上传到<code>liwenzhou.com</code>这个网站，我们只是想导入本地的包，这个时候就需要用到<code>replace</code>这个指令了。</p>

<p><code>p1/go.mod</code>内容如下：</p>

<pre><code class="language-go">module github.com/q1mi/p1

go 1.14


require &quot;liwenzhou.com/q1mi/p2&quot; v0.0.0
replace &quot;liwenzhou.com/q1mi/p2&quot; =&gt; &quot;../p2&quot;
</code></pre>

<p>此时，我们就可以正常编译<code>p1</code>这个项目了。</p>

<p>说再多也没用，自己动手试试吧。</p>

<h1 id="go语言基础">Go语言基础</h1>

<h2 id="go语言基础之变量和常量">Go语言基础之变量和常量</h2>

<p>变量和常量是编程中必不可少的部分，也是很好理解的一部分。</p>

<h3 id="标识符与关键字">标识符与关键字</h3>

<h4 id="标识符">标识符</h4>

<p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头。 举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code>。</p>

<h4 id="关键字">关键字</h4>

<p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。</p>

<p>Go语言中有25个关键字：</p>

<pre><code class="language-go">    break        default      func         interface    select
    case         defer        go           map          struct
    chan         else         goto         package      switch
    const        fallthrough  if           range        type
    continue     for          import       return       var
</code></pre>

<p>此外，Go语言中还有37个保留字。</p>

<pre><code class="language-go">    Constants:    true  false  iota  nil

        Types:    int  int8  int16  int32  int64  
                  uint  uint8  uint16  uint32  uint64  uintptr
                  float32  float64  complex128  complex64
                  bool  byte  rune  string  error

    Functions:   make  len  cap  new  append  copy  close  delete
                 complex  real  imag
                 panic  recover
</code></pre>

<h3 id="变量">变量</h3>

<h4 id="变量的来历">变量的来历</h4>

<p>程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。</p>

<h4 id="变量类型">变量类型</h4>

<p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。</p>

<p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p>

<h4 id="变量声明">变量声明</h4>

<p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。</p>

<h5 id="标准声明">标准声明</h5>

<p>Go语言的变量声明格式为：</p>

<pre><code class="language-go">var 变量名 变量类型
</code></pre>

<p>变量声明以关键字<code>var</code>开头，变量类型放在变量的后面，行尾无需分号。 举个例子：</p>

<pre><code class="language-go">var name string
var age int
var isOk bool
</code></pre>

<h5 id="批量声明">批量声明</h5>

<p>每声明一个变量就需要写<code>var</code>关键字会比较繁琐，go语言中还支持批量变量声明：</p>

<pre><code class="language-go">var (
    a string
    b int
    c bool
    d float32
)
</code></pre>

<h5 id="变量的初始化">变量的初始化</h5>

<p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为<code>0</code>。 字符串变量的默认值为<code>空字符串</code>。 布尔型变量默认为<code>false</code>。 切片、函数、指针变量的默认为<code>nil</code>。</p>

<p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p>

<pre><code class="language-go">var 变量名 类型 = 表达式
</code></pre>

<p>举个例子：</p>

<pre><code class="language-go">var name string = &quot;Q1mi&quot;
var age int = 18
</code></pre>

<p>或者一次初始化多个变量</p>

<pre><code class="language-go">var name, age = &quot;Q1mi&quot;, 20
</code></pre>

<h5 id="类型推导">类型推导</h5>

<p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p>

<pre><code class="language-go">var name = &quot;Q1mi&quot;
var age = 18
</code></pre>

<h5 id="短变量声明">短变量声明</h5>

<p>在函数内部，可以使用更简略的 <code>:=</code> 方式声明并初始化变量。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)
// 全局变量m
var m = 100

func main() {
	n := 10
	m := 200 // 此处声明局部变量m
	fmt.Println(m, n)
}
</code></pre>

<h5 id="匿名变量">匿名变量</h5>

<p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code>表示，例如：</p>

<pre><code class="language-go">func foo() (int, string) {
	return 10, &quot;Q1mi&quot;
}
func main() {
	x, _ := foo()
	_, y := foo()
	fmt.Println(&quot;x=&quot;, x)
	fmt.Println(&quot;y=&quot;, y)
}
</code></pre>

<p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在<code>Lua</code>等编程语言里，匿名变量也被叫做哑元变量。)</p>

<p>注意事项：</p>

<ol>
<li>函数外的每个语句都必须以关键字开始（var、const、func等）</li>
<li><code>:=</code>不能使用在函数外。</li>
<li><code>_</code>多用于占位，表示忽略值。</li>
</ol>

<h3 id="常量">常量</h3>

<p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p>

<pre><code class="language-go">const pi = 3.1415
const e = 2.7182
</code></pre>

<p>声明了<code>pi</code>和<code>e</code>这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p>

<p>多个常量也可以一起声明：</p>

<pre><code class="language-go">const (
    pi = 3.1415
    e = 2.7182
)
</code></pre>

<p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p>

<pre><code class="language-go">const (
    n1 = 100
    n2
    n3
)
</code></pre>

<p>上面示例中，常量<code>n1</code>、<code>n2</code>、<code>n3</code>的值都是100。</p>

<h4 id="iota">iota</h4>

<p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p>

<p><code>iota</code>在const关键字出现时将被重置为0。const中每新增一行常量声明将使<code>iota</code>计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p>

<p>举个例子：</p>

<pre><code class="language-go">const (
		n1 = iota //0
		n2        //1
		n3        //2
		n4        //3
	)
</code></pre>

<h4 id="几个常见的-iota-示例">几个常见的<code>iota</code>示例:</h4>

<p>使用<code>_</code>跳过某些值</p>

<pre><code class="language-go">const (
		n1 = iota //0
		n2        //1
		_
		n4        //3
	)
</code></pre>

<p><code>iota</code>声明中间插队</p>

<pre><code class="language-go">const (
		n1 = iota //0
		n2 = 100  //100
		n3 = iota //2
		n4        //3
	)
	const n5 = iota //0
</code></pre>

<p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p>

<pre><code class="language-go">const (
		_  = iota
		KB = 1 &lt;&lt; (10 * iota)
		MB = 1 &lt;&lt; (10 * iota)
		GB = 1 &lt;&lt; (10 * iota)
		TB = 1 &lt;&lt; (10 * iota)
		PB = 1 &lt;&lt; (10 * iota)
	)
</code></pre>

<p>多个<code>iota</code>定义在一行</p>

<pre><code class="language-go">const (
		a, b = iota + 1, iota + 2 //1,2
		c, d                      //2,3
		e, f                      //3,4
	)
</code></pre>

<h2 id="go语言基础之基本数据类型">Go语言基础之基本数据类型</h2>

<p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</p>

<h3 id="基本数据类型">基本数据类型</h3>

<h4 id="整型">整型</h4>

<p>整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64</p>

<p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型，<code>int16</code>对应C语言中的<code>short</code>型，<code>int64</code>对应C语言中的<code>long</code>型。</p>

<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">uint8</td>
<td align="center">无符号 8位整型 (0 到 255)</td>
</tr>

<tr>
<td align="center">uint16</td>
<td align="center">无符号 16位整型 (0 到 65535)</td>
</tr>

<tr>
<td align="center">uint32</td>
<td align="center">无符号 32位整型 (0 到 4294967295)</td>
</tr>

<tr>
<td align="center">uint64</td>
<td align="center">无符号 64位整型 (0 到 18446744073709551615)</td>
</tr>

<tr>
<td align="center">int8</td>
<td align="center">有符号 8位整型 (-128 到 127)</td>
</tr>

<tr>
<td align="center">int16</td>
<td align="center">有符号 16位整型 (-32768 到 32767)</td>
</tr>

<tr>
<td align="center">int32</td>
<td align="center">有符号 32位整型 (-2147483648 到 2147483647)</td>
</tr>

<tr>
<td align="center">int64</td>
<td align="center">有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td>
</tr>
</tbody>
</table>

<h5 id="特殊整型">特殊整型</h5>

<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">uint</td>
<td align="center">32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td>
</tr>

<tr>
<td align="center">int</td>
<td align="center">32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td>
</tr>

<tr>
<td align="center">uintptr</td>
<td align="center">无符号整型，用于存放一个指针</td>
</tr>
</tbody>
</table>

<p><strong>注意：</strong> 在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平台上的差异。</p>

<p><strong>注意事项</strong> 获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p>

<h5 id="数字字面量语法-number-literals-syntax">数字字面量语法（Number literals syntax）</h5>

<p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p>

<p><code>v := 0b00101101</code>， 代表二进制的 101101，相当于十进制的 45。 <code>v := 0o377</code>，代表八进制的 377，相当于十进制的 255。 <code>v := 0x1p-2</code>，代表十六进制的 1 除以 2²，也就是 0.25。</p>

<p>而且还允许我们用 <code>_</code> 来分隔数字，比如说： <code>v := 123_456</code> 表示 v 的值等于 123456。</p>

<p>我们可以借助fmt函数来将一个整数以不同进制形式展示。</p>

<pre><code class="language-go">package main
 
import &quot;fmt&quot;
 
func main(){
	// 十进制
	var a int = 10
	fmt.Printf(&quot;%d \n&quot;, a)  // 10
	fmt.Printf(&quot;%b \n&quot;, a)  // 1010  占位符%b表示二进制
 
	// 八进制  以0开头
	var b int = 077
	fmt.Printf(&quot;%o \n&quot;, b)  // 77
 
	// 十六进制  以0x开头
	var c int = 0xff
	fmt.Printf(&quot;%x \n&quot;, c)  // ff
	fmt.Printf(&quot;%X \n&quot;, c)  // FF
}
</code></pre>

<h4 id="浮点型">浮点型</h4>

<p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code>标准： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p>

<p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p>

<pre><code class="language-go">package main
import (
        &quot;fmt&quot;
        &quot;math&quot;
)
func main() {
        fmt.Printf(&quot;%f\n&quot;, math.Pi)
        fmt.Printf(&quot;%.2f\n&quot;, math.Pi)
}
</code></pre>

<h4 id="复数">复数</h4>

<p>complex64和complex128</p>

<pre><code class="language-go">var c1 complex64
c1 = 1 + 2i
var c2 complex128
c2 = 2 + 3i
fmt.Println(c1)
fmt.Println(c2)
</code></pre>

<p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p>

<h4 id="布尔值">布尔值</h4>

<p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p>

<p><strong>注意：</strong></p>

<ol>
<li>布尔类型变量的默认值为<code>false</code>。</li>
<li>Go 语言中不允许将整型强制转换为布尔型.</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li>
</ol>

<h4 id="字符串">字符串</h4>

<p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码。 字符串的值为<code>双引号(&quot;)</code>中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p>

<pre><code class="language-go">s1 := &quot;hello&quot;
s2 := &quot;你好&quot;
</code></pre>

<h5 id="字符串转义符">字符串转义符</h5>

<p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p>

<table>
<thead>
<tr>
<th align="center">转义符</th>
<th align="center">含义</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><code>\r</code></td>
<td align="center">回车符（返回行首）</td>
</tr>

<tr>
<td align="center"><code>\n</code></td>
<td align="center">换行符（直接跳到下一行的同列位置）</td>
</tr>

<tr>
<td align="center"><code>\t</code></td>
<td align="center">制表符</td>
</tr>

<tr>
<td align="center"><code>\'</code></td>
<td align="center">单引号</td>
</tr>

<tr>
<td align="center"><code>\&quot;</code></td>
<td align="center">双引号</td>
</tr>

<tr>
<td align="center"><code>\\</code></td>
<td align="center">反斜杠</td>
</tr>
</tbody>
</table>

<p>举个例子，我们要打印一个Windows平台下的一个文件路径：</p>

<pre><code class="language-go">package main
import (
    &quot;fmt&quot;
)
func main() {
    fmt.Println(&quot;str := \&quot;c:\\Code\\lesson1\\go.exe\&quot;&quot;)
}
</code></pre>

<h5 id="多行字符串">多行字符串</h5>

<p>Go语言中要定义一个多行字符串时，就必须使用<code>反引号</code>字符：</p>

<pre><code class="language-go">s1 := `第一行
第二行
第三行
`
fmt.Println(s1)
</code></pre>

<p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p>

<h5 id="字符串的常用操作">字符串的常用操作</h5>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">介绍</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">len(str)</td>
<td align="center">求长度</td>
</tr>

<tr>
<td align="center">+或fmt.Sprintf</td>
<td align="center">拼接字符串</td>
</tr>

<tr>
<td align="center">strings.Split</td>
<td align="center">分割</td>
</tr>

<tr>
<td align="center">strings.contains</td>
<td align="center">判断是否包含</td>
</tr>

<tr>
<td align="center">strings.HasPrefix,strings.HasSuffix</td>
<td align="center">前缀/后缀判断</td>
</tr>

<tr>
<td align="center">strings.Index(),strings.LastIndex()</td>
<td align="center">子串出现的位置</td>
</tr>

<tr>
<td align="center">strings.Join(a[]string, sep string)</td>
<td align="center">join操作</td>
</tr>
</tbody>
</table>

<h4 id="byte和rune类型">byte和rune类型</h4>

<p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p>

<pre><code class="language-go">var a = '中'
var b = 'x'
</code></pre>

<p>Go 语言的字符有以下两种：</p>

<ol>
<li><code>uint8</code>类型，或者叫 byte 型，代表一个<code>ASCII码</code>字符。</li>
<li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li>
</ol>

<p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p>

<p>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p>

<pre><code class="language-go">// 遍历字符串
func traversalString() {
	s := &quot;hello沙河&quot;
	for i := 0; i &lt; len(s); i++ { //byte
		fmt.Printf(&quot;%v(%c) &quot;, s[i], s[i])
	}
	fmt.Println()
	for _, r := range s { //rune
		fmt.Printf(&quot;%v(%c) &quot;, r, r)
	}
	fmt.Println()
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) 
104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河) 
</code></pre>

<p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p>

<p>字符串底层是一个byte数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p>

<h5 id="修改字符串">修改字符串</h5>

<p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p>

<pre><code class="language-go">func changeString() {
	s1 := &quot;big&quot;
	// 强制类型转换
	byteS1 := []byte(s1)
	byteS1[0] = 'p'
	fmt.Println(string(byteS1))

	s2 := &quot;白萝卜&quot;
	runeS2 := []rune(s2)
	runeS2[0] = '红'
	fmt.Println(string(runeS2))
}
</code></pre>

<h4 id="类型转换">类型转换</h4>

<p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p>

<p>强制类型转换的基本语法如下：</p>

<pre><code class="language-bash">T(表达式)
</code></pre>

<p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p>

<p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p>

<pre><code class="language-go">func sqrtDemo() {
	var a, b = 3, 4
	var c int
	// math.Sqrt()接收的参数是float64类型，需要强制转换
	c = int(math.Sqrt(float64(a*a + b*b)))
	fmt.Println(c)
}
</code></pre>

<h3 id="练习题">练习题</h3>

<ol>
<li>编写代码分别定义一个整型、浮点型、布尔型、字符串型变量，使用<code>fmt.Printf()</code>搭配<code>%T</code>分别打印出上述变量的值和类型。</li>
<li>编写代码统计出字符串<code>&quot;hello沙河小王子&quot;</code>中汉字的数量。</li>
</ol>

<h2 id="go语言基础之运算符">Go语言基础之运算符</h2>

<p>运算符用于在程序运行时执行数学或逻辑运算。</p>

<p>Go 语言内置的运算符有：</p>

<ol>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
</ol>

<h3 id="算术运算符">算术运算符</h3>

<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">+</td>
<td align="center">相加</td>
</tr>

<tr>
<td align="center">-</td>
<td align="center">相减</td>
</tr>

<tr>
<td align="center">*</td>
<td align="center">相乘</td>
</tr>

<tr>
<td align="center">/</td>
<td align="center">相除</td>
</tr>

<tr>
<td align="center">%</td>
<td align="center">求余</td>
</tr>
</tbody>
</table>

<p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p>

<h3 id="关系运算符">关系运算符</h3>

<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">==</td>
<td align="center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td>
</tr>

<tr>
<td align="center">!=</td>
<td align="center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td>
</tr>

<tr>
<td align="center">&gt;</td>
<td align="center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td>
</tr>

<tr>
<td align="center">&gt;=</td>
<td align="center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>

<tr>
<td align="center">&lt;</td>
<td align="center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td>
</tr>

<tr>
<td align="center">&lt;=</td>
<td align="center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
</tbody>
</table>

<h3 id="逻辑运算符">逻辑运算符</h3>

<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">&amp;&amp;</td>
<td align="center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td>
</tr>

<tr>
<td align="center">||</td>
<td align="center">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td>
</tr>

<tr>
<td align="center">!</td>
<td align="center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td>
</tr>
</tbody>
</table>

<h3 id="位运算符">位运算符</h3>

<p>位运算符对整数在内存中的二进制位进行操作。</p>

<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">&amp;</td>
<td align="center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td>
</tr>

<tr>
<td align="center">|</td>
<td align="center">参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td>
</tr>

<tr>
<td align="center">^</td>
<td align="center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td>
</tr>

<tr>
<td align="center">&lt;&lt;</td>
<td align="center">左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td>
</tr>

<tr>
<td align="center">&gt;&gt;</td>
<td align="center">右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td>
</tr>
</tbody>
</table>

<h3 id="赋值运算符">赋值运算符</h3>

<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">=</td>
<td align="center">简单的赋值运算符，将一个表达式的值赋给一个左值</td>
</tr>

<tr>
<td align="center">+=</td>
<td align="center">相加后再赋值</td>
</tr>

<tr>
<td align="center">-=</td>
<td align="center">相减后再赋值</td>
</tr>

<tr>
<td align="center">*=</td>
<td align="center">相乘后再赋值</td>
</tr>

<tr>
<td align="center">/=</td>
<td align="center">相除后再赋值</td>
</tr>

<tr>
<td align="center">%=</td>
<td align="center">求余后再赋值</td>
</tr>

<tr>
<td align="center">&lt;&lt;=</td>
<td align="center">左移后赋值</td>
</tr>

<tr>
<td align="center">&gt;&gt;=</td>
<td align="center">右移后赋值</td>
</tr>

<tr>
<td align="center">&amp;=</td>
<td align="center">按位与后赋值</td>
</tr>

<tr>
<td align="center">|=</td>
<td align="center">按位或后赋值</td>
</tr>

<tr>
<td align="center">^=</td>
<td align="center">按位异或后赋值</td>
</tr>
</tbody>
</table>

<h4 id="练习题-1">练习题</h4>

<p>有一堆数字，如果除了一个数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？</p>

<h2 id="go语言基础之流程控制">Go语言基础之流程控制</h2>

<p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。</p>

<p>Go语言中最常用的流程控制有<code>if</code>和<code>for</code>，而<code>switch</code>和<code>goto</code>主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>

<h3 id="if-else-分支结构">if else(分支结构)</h3>

<h4 id="if条件判断基本写法">if条件判断基本写法</h4>

<p>Go语言中<code>if</code>条件判断的格式如下：</p>

<pre><code class="language-go">if 表达式1 {
    分支1
} else if 表达式2 {
    分支2
} else{
    分支3
}
</code></pre>

<p>当表达式1的结果为<code>true</code>时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 if判断中的<code>else if</code>和<code>else</code>都是可选的，可以根据实际需要进行选择。</p>

<p>Go语言规定与<code>if</code>匹配的左括号<code>{</code>必须与<code>if和表达式</code>放在同一行，<code>{</code>放在其他位置会触发编译错误。 同理，与<code>else</code>匹配的<code>{</code>也必须与<code>else</code>写在同一行，<code>else</code>也必须与上一个<code>if</code>或<code>else if</code>右边的大括号在同一行。</p>

<p>举个例子：</p>

<pre><code class="language-go">func ifDemo1() {
	score := 65
	if score &gt;= 90 {
		fmt.Println(&quot;A&quot;)
	} else if score &gt; 75 {
		fmt.Println(&quot;B&quot;)
	} else {
		fmt.Println(&quot;C&quot;)
	}
}
</code></pre>

<h4 id="if条件判断特殊写法">if条件判断特殊写法</h4>

<p>if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：</p>

<pre><code class="language-go">func ifDemo2() {
	if score := 65; score &gt;= 90 {
		fmt.Println(&quot;A&quot;)
	} else if score &gt; 75 {
		fmt.Println(&quot;B&quot;)
	} else {
		fmt.Println(&quot;C&quot;)
	}
}
</code></pre>

<p><strong>思考题：</strong> 上下两种写法的区别在哪里？</p>

<h3 id="for-循环结构">for(循环结构)</h3>

<p>Go 语言中的所有循环类型均可以使用<code>for</code>关键字来完成。</p>

<p>for循环的基本格式如下：</p>

<pre><code class="language-bash">for 初始语句;条件表达式;结束语句{
    循环体语句
}
</code></pre>

<p>条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p>

<pre><code class="language-go">func forDemo() {
	for i := 0; i &lt; 10; i++ {
		fmt.Println(i)
	}
}
</code></pre>

<p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p>

<pre><code class="language-go">func forDemo2() {
	i := 0
	for ; i &lt; 10; i++ {
		fmt.Println(i)
	}
}
</code></pre>

<p>for循环的初始语句和结束语句都可以省略，例如：</p>

<pre><code class="language-go">func forDemo3() {
	i := 0
	for i &lt; 10 {
		fmt.Println(i)
		i++
	}
}
</code></pre>

<p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p>

<h4 id="无限循环">无限循环</h4>

<pre><code class="language-go">for {
    循环体语句
}
</code></pre>

<p>for循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code>语句强制退出循环。</p>

<h3 id="for-range-键值循环">for range(键值循环)</h3>

<p>Go语言中可以使用<code>for range</code>遍历数组、切片、字符串、map 及通道（channel）。 通过<code>for range</code>遍历的返回值有以下规律：</p>

<ol>
<li>数组、切片、字符串返回索引和值。</li>
<li>map返回键和值。</li>
<li>通道（channel）只返回通道内的值。</li>
</ol>

<h3 id="switch-case">switch case</h3>

<p>使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p>

<pre><code class="language-go">func switchDemo1() {
	finger := 3
	switch finger {
	case 1:
		fmt.Println(&quot;大拇指&quot;)
	case 2:
		fmt.Println(&quot;食指&quot;)
	case 3:
		fmt.Println(&quot;中指&quot;)
	case 4:
		fmt.Println(&quot;无名指&quot;)
	case 5:
		fmt.Println(&quot;小拇指&quot;)
	default:
		fmt.Println(&quot;无效的输入！&quot;)
	}
}
</code></pre>

<p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p>

<p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p>

<pre><code class="language-go">func testSwitch3() {
	switch n := 7; n {
	case 1, 3, 5, 7, 9:
		fmt.Println(&quot;奇数&quot;)
	case 2, 4, 6, 8:
		fmt.Println(&quot;偶数&quot;)
	default:
		fmt.Println(n)
	}
}
</code></pre>

<p>分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p>

<pre><code class="language-go">func switchDemo4() {
	age := 30
	switch {
	case age &lt; 25:
		fmt.Println(&quot;好好学习吧&quot;)
	case age &gt; 25 &amp;&amp; age &lt; 35:
		fmt.Println(&quot;好好工作吧&quot;)
	case age &gt; 60:
		fmt.Println(&quot;好好享受吧&quot;)
	default:
		fmt.Println(&quot;活着真好&quot;)
	}
}
</code></pre>

<p><code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p>

<pre><code class="language-go">func switchDemo5() {
	s := &quot;a&quot;
	switch {
	case s == &quot;a&quot;:
		fmt.Println(&quot;a&quot;)
		fallthrough
	case s == &quot;b&quot;:
		fmt.Println(&quot;b&quot;)
	case s == &quot;c&quot;:
		fmt.Println(&quot;c&quot;)
	default:
		fmt.Println(&quot;...&quot;)
	}
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">a
b
</code></pre>

<h3 id="goto-跳转到指定标签">goto(跳转到指定标签)</h3>

<p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：</p>

<pre><code class="language-go">func gotoDemo1() {
	var breakFlag bool
	for i := 0; i &lt; 10; i++ {
		for j := 0; j &lt; 10; j++ {
			if j == 2 {
				// 设置退出标签
				breakFlag = true
				break
			}
			fmt.Printf(&quot;%v-%v\n&quot;, i, j)
		}
		// 外层for循环判断
		if breakFlag {
			break
		}
	}
}
</code></pre>

<p>使用<code>goto</code>语句能简化代码：</p>

<pre><code class="language-go">func gotoDemo2() {
	for i := 0; i &lt; 10; i++ {
		for j := 0; j &lt; 10; j++ {
			if j == 2 {
				// 设置退出标签
				goto breakTag
			}
			fmt.Printf(&quot;%v-%v\n&quot;, i, j)
		}
	}
	return
	// 标签
breakTag:
	fmt.Println(&quot;结束for循环&quot;)
}
</code></pre>

<h3 id="break-跳出循环">break(跳出循环)</h3>

<p><code>break</code>语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>的代码块。</p>

<p><code>break</code>语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和 <code>select</code>的代码块上。 举个例子：</p>

<pre><code class="language-go">func breakDemo1() {
BREAKDEMO1:
	for i := 0; i &lt; 10; i++ {
		for j := 0; j &lt; 10; j++ {
			if j == 2 {
				break BREAKDEMO1
			}
			fmt.Printf(&quot;%v-%v\n&quot;, i, j)
		}
	}
	fmt.Println(&quot;...&quot;)
}
</code></pre>

<h3 id="continue-继续下次循环">continue(继续下次循环)</h3>

<p><code>continue</code>语句可以结束当前循环，开始下一次的循环迭代过程，仅限在<code>for</code>循环内使用。</p>

<p>在 <code>continue</code>语句后添加标签时，表示开始标签对应的循环。例如：</p>

<pre><code class="language-go">func continueDemo() {
forloop1:
	for i := 0; i &lt; 5; i++ {
		// forloop2:
		for j := 0; j &lt; 5; j++ {
			if i == 2 &amp;&amp; j == 2 {
				continue forloop1
			}
			fmt.Printf(&quot;%v-%v\n&quot;, i, j)
		}
	}
}
</code></pre>

<h4 id="练习题-2">练习题</h4>

<ol>
<li>编写代码打印9*9乘法表。</li>
</ol>

<h2 id="go语言基础之数组">Go语言基础之数组</h2>

<p>本文主要介绍Go语言中数组（array）及它的基本使用。</p>

<p><strong>Array</strong>(数组)</p>

<p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p>

<pre><code class="language-go">// 定义一个长度为3元素类型为int的数组a
var a [3]int
</code></pre>

<h3 id="数组定义">数组定义：</h3>

<pre><code class="language-bash">var 数组变量名 [元素数量]T
</code></pre>

<p>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 <code>[5]int</code>和<code>[10]int</code>是不同的类型。</p>

<pre><code class="language-go">var a [3]int
var b [4]int
a = b //不可以这样做，因为此时a和b是不同的类型
</code></pre>

<p>数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p>

<h3 id="数组的初始化">数组的初始化</h3>

<p>数组的初始化也有很多方式。</p>

<h4 id="方法一">方法一</h4>

<p>初始化数组时可以使用初始化列表来设置数组元素的值。</p>

<pre><code class="language-go">func main() {
	var testArray [3]int                        //数组会初始化为int类型的零值
	var numArray = [3]int{1, 2}                 //使用指定的初始值完成初始化
	var cityArray = [3]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;} //使用指定的初始值完成初始化
	fmt.Println(testArray)                      //[0 0 0]
	fmt.Println(numArray)                       //[1 2 0]
	fmt.Println(cityArray)                      //[北京 上海 深圳]
}
</code></pre>

<h4 id="方法二">方法二</h4>

<p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p>

<pre><code class="language-go">func main() {
	var testArray [3]int
	var numArray = [...]int{1, 2}
	var cityArray = [...]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;}
	fmt.Println(testArray)                          //[0 0 0]
	fmt.Println(numArray)                           //[1 2]
	fmt.Printf(&quot;type of numArray:%T\n&quot;, numArray)   //type of numArray:[2]int
	fmt.Println(cityArray)                          //[北京 上海 深圳]
	fmt.Printf(&quot;type of cityArray:%T\n&quot;, cityArray) //type of cityArray:[3]string
}
</code></pre>

<h4 id="方法三">方法三</h4>

<p>我们还可以使用指定索引值的方式来初始化数组，例如:</p>

<pre><code class="language-go">func main() {
	a := [...]int{1: 1, 3: 5}
	fmt.Println(a)                  // [0 1 0 5]
	fmt.Printf(&quot;type of a:%T\n&quot;, a) //type of a:[4]int
}
</code></pre>

<h3 id="数组的遍历">数组的遍历</h3>

<p>遍历数组a有以下两种方法：</p>

<pre><code class="language-go">func main() {
	var a = [...]string{&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;}
	// 方法1：for循环遍历
	for i := 0; i &lt; len(a); i++ {
		fmt.Println(a[i])
	}

	// 方法2：for range遍历
	for index, value := range a {
		fmt.Println(index, value)
	}
}
</code></pre>

<h3 id="多维数组">多维数组</h3>

<p>Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。</p>

<h4 id="二维数组的定义">二维数组的定义</h4>

<pre><code class="language-go">func main() {
	a := [3][2]string{
		{&quot;北京&quot;, &quot;上海&quot;},
		{&quot;广州&quot;, &quot;深圳&quot;},
		{&quot;成都&quot;, &quot;重庆&quot;},
	}
	fmt.Println(a) //[[北京 上海] [广州 深圳] [成都 重庆]]
	fmt.Println(a[2][1]) //支持索引取值:重庆
}
</code></pre>

<h4 id="二维数组的遍历">二维数组的遍历</h4>

<pre><code class="language-go">func main() {
	a := [3][2]string{
		{&quot;北京&quot;, &quot;上海&quot;},
		{&quot;广州&quot;, &quot;深圳&quot;},
		{&quot;成都&quot;, &quot;重庆&quot;},
	}
	for _, v1 := range a {
		for _, v2 := range v1 {
			fmt.Printf(&quot;%s\t&quot;, v2)
		}
		fmt.Println()
	}
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">北京	上海	
广州	深圳	
成都	重庆	
</code></pre>

<p><strong>注意：</strong> 多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。例如：</p>

<pre><code class="language-go">//支持的写法
a := [...][2]string{
	{&quot;北京&quot;, &quot;上海&quot;},
	{&quot;广州&quot;, &quot;深圳&quot;},
	{&quot;成都&quot;, &quot;重庆&quot;},
}
//不支持多维数组的内层使用...
b := [3][...]string{
	{&quot;北京&quot;, &quot;上海&quot;},
	{&quot;广州&quot;, &quot;深圳&quot;},
	{&quot;成都&quot;, &quot;重庆&quot;},
}
</code></pre>

<h3 id="数组是值类型">数组是值类型</h3>

<p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p>

<pre><code class="language-go">func modifyArray(x [3]int) {
	x[0] = 100
}

func modifyArray2(x [3][2]int) {
	x[2][0] = 100
}
func main() {
	a := [3]int{10, 20, 30}
	modifyArray(a) //在modify中修改的是a的副本x
	fmt.Println(a) //[10 20 30]
	b := [3][2]int{
		{1, 1},
		{1, 1},
		{1, 1},
	}
	modifyArray2(b) //在modify中修改的是b的副本x
	fmt.Println(b)  //[[1 1] [1 1] [1 1]]
}
</code></pre>

<p><strong>注意：</strong></p>

<ol>
<li>数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。</li>
<li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 。</li>
</ol>

<h3 id="练习题-3">练习题</h3>

<ol>
<li>求数组<code>[1, 3, 5, 7, 8]</code>所有元素的和</li>
<li>找出数组中和为指定值的两个元素的下标，比如从数组<code>[1, 3, 5, 7, 8]</code>中找出和为8的两个元素的下标分别为<code>(0,3)</code>和<code>(1,2)</code>。</li>
</ol>

<h2 id="go语言基础之切片">Go语言基础之切片</h2>

<p>本文主要介绍Go语言中切片（slice）及它的基本使用。</p>

<h3 id="引子">引子</h3>

<p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p>

<pre><code class="language-go">func arraySum(x [3]int) int{
    sum := 0
    for _, v := range x{
        sum = sum + v
    }
    return sum
}
</code></pre>

<p>这个求和函数只能接受<code>[3]int</code>类型，其他的都不支持。 再比如，</p>

<pre><code class="language-go">a := [3]int{1, 2, 3}
</code></pre>

<p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。</p>

<h3 id="切片">切片</h3>

<p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p>

<p>切片是一个引用类型，它的内部结构包含<code>地址</code>、<code>长度</code>和<code>容量</code>。切片一般用于快速地操作一块数据集合。</p>

<h4 id="切片的定义">切片的定义</h4>

<p>声明切片类型的基本语法如下：</p>

<pre><code class="language-go">var name []T
</code></pre>

<p>其中，</p>

<ul>
<li>name:表示变量名</li>
<li>T:表示切片中的元素类型</li>
</ul>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	// 声明切片类型
	var a []string              //声明一个字符串切片
	var b = []int{}             //声明一个整型切片并初始化
	var c = []bool{false, true} //声明一个布尔切片并初始化
	var d = []bool{false, true} //声明一个布尔切片并初始化
	fmt.Println(a)              //[]
	fmt.Println(b)              //[]
	fmt.Println(c)              //[false true]
	fmt.Println(a == nil)       //true
	fmt.Println(b == nil)       //false
	fmt.Println(c == nil)       //false
	// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较
}
</code></pre>

<h5 id="切片的长度和容量">切片的长度和容量</h5>

<p>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</p>

<h5 id="切片表达式">切片表达式</h5>

<p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p>

<h6 id="简单切片表达式">简单切片表达式</h6>

<p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的<code>low</code>和<code>high</code>表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出<code>1&lt;=索引值&lt;4</code>的元素组成切片s，得到的切片<code>长度=high-low</code>，容量等于得到的切片的底层数组的容量。</p>

<pre><code class="language-go">func main() {
	a := [5]int{1, 2, 3, 4, 5}
	s := a[1:3]  // s := a[low:high]
	fmt.Printf(&quot;s:%v len(s):%v cap(s):%v\n&quot;, s, len(s), cap(s))
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">s:[2 3] len(s):2 cap(s):4
</code></pre>

<p>为了方便起见，可以省略切片表达式中的任何索引。省略了<code>low</code>则默认为0；省略了<code>high</code>则默认为切片操作数的长度:</p>

<pre><code class="language-go">a[2:]  // 等同于 a[2:len(a)]
a[:3]  // 等同于 a[0:3]
a[:]   // 等同于 a[0:len(a)]
</code></pre>

<p><strong>注意：</strong></p>

<p>对于数组或字符串，如果<code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界（out of range）。</p>

<p>对切片再执行切片表达式时（切片再切片），<code>high</code>的上限边界是切片的容量<code>cap(a)</code>，而不是长度。<strong>常量索引</strong>必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果<code>low</code>和<code>high</code>两个指标都是常数，它们必须满足<code>low &lt;= high</code>。如果索引在运行时超出范围，就会发生运行时<code>panic</code>。</p>

<pre><code class="language-go">func main() {
	a := [5]int{1, 2, 3, 4, 5}
	s := a[1:3]  // s := a[low:high]
	fmt.Printf(&quot;s:%v len(s):%v cap(s):%v\n&quot;, s, len(s), cap(s))
	s2 := s[3:4]  // 索引的上限是cap(s)而不是len(s)
	fmt.Printf(&quot;s2:%v len(s2):%v cap(s2):%v\n&quot;, s2, len(s2), cap(s2))
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">s:[2 3] len(s):2 cap(s):4
s2:[5] len(s2):1 cap(s2):1
</code></pre>

<h6 id="完整切片表达式">完整切片表达式</h6>

<p>对于数组，指向数组的指针，或切片a(<strong>注意不能是字符串</strong>)支持完整切片表达式：</p>

<pre><code class="language-go">a[low : high : max]
</code></pre>

<p>上面的代码会构造与简单切片表达式<code>a[low: high]</code>相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为<code>max-low</code>。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。</p>

<pre><code class="language-go">func main() {
	a := [5]int{1, 2, 3, 4, 5}
	t := a[1:3:5]
	fmt.Printf(&quot;t:%v len(t):%v cap(t):%v\n&quot;, t, len(t), cap(t))
}
</code></pre>

<p>输出结果：</p>

<pre><code class="language-bash">t:[2 3] len(t):2 cap(t):4
</code></pre>

<p>完整切片表达式需要满足的条件是<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>，其他条件和简单切片表达式相同。</p>

<h5 id="使用make-函数构造切片">使用make()函数构造切片</h5>

<p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p>

<pre><code class="language-bash">make([]T, size, cap)
</code></pre>

<p>其中：</p>

<ul>
<li>T:切片的元素类型</li>
<li>size:切片中元素的数量</li>
<li>cap:切片的容量</li>
</ul>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	a := make([]int, 2, 10)
	fmt.Println(a)      //[0 0]
	fmt.Println(len(a)) //2
	fmt.Println(cap(a)) //10
}
</code></pre>

<p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p>

<h5 id="切片的本5质">切片的本5质</h5>

<p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p>

<p>举个例子，现在有一个数组<code>a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。<img src="/resources/技术收录/golang/slice_01.png" alt="slice_01" />切片<code>s2 := a[3:6]</code>，相应示意图如下：<img src="/resources/技术收录/golang/slice_02.png" alt="slice_02" /></p>

<h5 id="判断切片是否为空">判断切片是否为空</h5>

<p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p>

<h4 id="切片不能直接比较">切片不能直接比较</h4>

<p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p>

<pre><code class="language-go">var s1 []int         //len(s1)=0;cap(s1)=0;s1==nil
s2 := []int{}        //len(s2)=0;cap(s2)=0;s2!=nil
s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil
</code></pre>

<p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p>

<h4 id="切片的赋值拷贝">切片的赋值拷贝</h4>

<p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p>

<pre><code class="language-go">func main() {
	s1 := make([]int, 3) //[0 0 0]
	s2 := s1             //将s1直接赋值给s2，s1和s2共用一个底层数组
	s2[0] = 100
	fmt.Println(s1) //[100 0 0]
	fmt.Println(s2) //[100 0 0]
}
</code></pre>

<h4 id="切片遍历">切片遍历</h4>

<p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p>

<pre><code class="language-go">func main() {
	s := []int{1, 3, 5}

	for i := 0; i &lt; len(s); i++ {
		fmt.Println(i, s[i])
	}

	for index, value := range s {
		fmt.Println(index, value)
	}
}
</code></pre>

<p>append()方法为切片添加元素</p>

<p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p>

<pre><code class="language-go">func main(){
	var s []int
	s = append(s, 1)        // [1]
	s = append(s, 2, 3, 4)  // [1 2 3 4]
	s2 := []int{5, 6, 7}  
	s = append(s, s2...)    // [1 2 3 4 5 6 7]
}
</code></pre>

<p><strong>注意：</strong>通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p>

<pre><code class="language-go">var s []int
s = append(s, 1, 2, 3)
</code></pre>

<p>没有必要像下面的代码一样初始化一个切片再传入<code>append()</code>函数使用，</p>

<pre><code class="language-go">s := []int{}  // 没有必要初始化
s = append(s, 1, 2, 3)

var s = make([]int)  // 没有必要初始化
s = append(s, 1, 2, 3)
</code></pre>

<p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	//append()添加元素和切片扩容
	var numSlice []int
	for i := 0; i &lt; 10; i++ {
		numSlice = append(numSlice, i)
		fmt.Printf(&quot;%v  len:%d  cap:%d  ptr:%p\n&quot;, numSlice, len(numSlice), cap(numSlice), numSlice)
	}
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">[0]  len:1  cap:1  ptr:0xc0000a8000
[0 1]  len:2  cap:2  ptr:0xc0000a8040
[0 1 2]  len:3  cap:4  ptr:0xc0000b2020
[0 1 2 3]  len:4  cap:4  ptr:0xc0000b2020
[0 1 2 3 4]  len:5  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5]  len:6  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6]  len:7  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6 7]  len:8  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6 7 8]  len:9  cap:16  ptr:0xc0000b8000
[0 1 2 3 4 5 6 7 8 9]  len:10  cap:16  ptr:0xc0000b8000
</code></pre>

<p>从上面的结果可以看出：</p>

<ol>
<li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li>
<li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li>
</ol>

<p>append()函数还支持一次性追加多个元素。 例如：</p>

<pre><code class="language-go">var citySlice []string
// 追加一个元素
citySlice = append(citySlice, &quot;北京&quot;)
// 追加多个元素
citySlice = append(citySlice, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;)
// 追加切片
a := []string{&quot;成都&quot;, &quot;重庆&quot;}
citySlice = append(citySlice, a...)
fmt.Println(citySlice) //[北京 上海 广州 深圳 成都 重庆]
</code></pre>

<h4 id="切片的扩容策略">切片的扩容策略</h4>

<p>可以通过查看<code>$GOROOT/src/runtime/slice.go</code>源码，其中扩容相关代码如下：</p>

<pre><code class="language-go">newcap := old.cap
doublecap := newcap + newcap
if cap &gt; doublecap {
	newcap = cap
} else {
	if old.len &lt; 1024 {
		newcap = doublecap
	} else {
		// Check 0 &lt; newcap to detect overflow
		// and prevent an infinite loop.
		for 0 &lt; newcap &amp;&amp; newcap &lt; cap {
			newcap += newcap / 4
		}
		// Set newcap to the requested cap when
		// the newcap calculation overflowed.
		if newcap &lt;= 0 {
			newcap = cap
		}
	}
}
</code></pre>

<p>从上面的代码可以看出以下内容：</p>

<ul>
<li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），</li>
<li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li>
</ul>

<p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</p>

<h4 id="使用copy-函数复制切片">使用copy()函数复制切片</h4>

<p>首先我们来看一个问题：</p>

<pre><code class="language-go">func main() {
	a := []int{1, 2, 3, 4, 5}
	b := a
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(b) //[1 2 3 4 5]
	b[0] = 1000
	fmt.Println(a) //[1000 2 3 4 5]
	fmt.Println(b) //[1000 2 3 4 5]
}
</code></pre>

<p>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</p>

<p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p>

<pre><code class="language-bash">copy(destSlice, srcSlice []T)
</code></pre>

<p>其中：</p>

<ul>
<li>srcSlice: 数据来源切片</li>
<li>destSlice: 目标切片</li>
</ul>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	// copy()复制切片
	a := []int{1, 2, 3, 4, 5}
	c := make([]int, 5, 5)
	copy(c, a)     //使用copy()函数将切片a中的元素复制到切片c
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1 2 3 4 5]
	c[0] = 1000
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1000 2 3 4 5]
}
</code></pre>

<h4 id="从切片中删除元素">从切片中删除元素</h4>

<p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p>

<pre><code class="language-go">func main() {
	// 从切片中删除元素
	a := []int{30, 31, 32, 33, 34, 35, 36, 37}
	// 要删除索引为2的元素
	a = append(a[:2], a[3:]...)
	fmt.Println(a) //[30 31 33 34 35 36 37]
}
</code></pre>

<p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p>

<h3 id="练习题-4">练习题</h3>

<p>1.请写出下面代码的输出结果。</p>

<pre><code class="language-go">func main() {
	var a = make([]string, 5, 10)
	for i := 0; i &lt; 10; i++ {
		a = append(a, fmt.Sprintf(&quot;%v&quot;, i))
	}
	fmt.Println(a)
}
</code></pre>

<p>2.请使用内置的<code>sort</code>包对数组<code>var a = [...]int{3, 7, 8, 9, 1}</code>进行排序（附加题，自行查资料解答）。</p>

<h2 id="go语言基础之map">Go语言基础之map</h2>

<p>Go语言中提供的映射关系容器为<code>map</code>，其内部使用<code>散列表（hash）</code>实现。</p>

<p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p>

<h3 id="map定义">map定义</h3>

<p>Go语言中 <code>map</code>的定义语法如下：</p>

<pre><code class="language-go">map[KeyType]ValueType
</code></pre>

<p>其中，</p>

<ul>
<li>KeyType:表示键的类型。</li>
<li>ValueType:表示键对应的值的类型。</li>
</ul>

<p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p>

<pre><code class="language-go">make(map[KeyType]ValueType, [cap])
</code></pre>

<p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p>

<h3 id="map基本使用">map基本使用</h3>

<p>map中的数据都是成对出现的，map的基本使用示例代码如下：</p>

<pre><code class="language-go">func main() {
	scoreMap := make(map[string]int, 8)
	scoreMap[&quot;张三&quot;] = 90
	scoreMap[&quot;小明&quot;] = 100
	fmt.Println(scoreMap)
	fmt.Println(scoreMap[&quot;小明&quot;])
	fmt.Printf(&quot;type of a:%T\n&quot;, scoreMap)
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">map[小明:100 张三:90]
100
type of a:map[string]int
</code></pre>

<p>map也支持在声明的时候填充元素，例如：</p>

<pre><code class="language-go">func main() {
	userInfo := map[string]string{
		&quot;username&quot;: &quot;沙河小王子&quot;,
		&quot;password&quot;: &quot;123456&quot;,
	}
	fmt.Println(userInfo) //
}
</code></pre>

<h3 id="判断某个键是否存在">判断某个键是否存在</h3>

<p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p>

<pre><code class="language-go">value, ok := map[key]
</code></pre>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	scoreMap := make(map[string]int)
	scoreMap[&quot;张三&quot;] = 90
	scoreMap[&quot;小明&quot;] = 100
	// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值
	v, ok := scoreMap[&quot;张三&quot;]
	if ok {
		fmt.Println(v)
	} else {
		fmt.Println(&quot;查无此人&quot;)
	}
}
</code></pre>

<h3 id="map的遍历">map的遍历</h3>

<p>Go语言中使用<code>for range</code>遍历map。</p>

<pre><code class="language-go">func main() {
	scoreMap := make(map[string]int)
	scoreMap[&quot;张三&quot;] = 90
	scoreMap[&quot;小明&quot;] = 100
	scoreMap[&quot;娜扎&quot;] = 60
	for k, v := range scoreMap {
		fmt.Println(k, v)
	}
}
</code></pre>

<p>但我们只想遍历key的时候，可以按下面的写法：</p>

<pre><code class="language-go">func main() {
	scoreMap := make(map[string]int)
	scoreMap[&quot;张三&quot;] = 90
	scoreMap[&quot;小明&quot;] = 100
	scoreMap[&quot;娜扎&quot;] = 60
	for k := range scoreMap {
		fmt.Println(k)
	}
}
</code></pre>

<p><strong>注意：</strong> 遍历map时的元素顺序与添加键值对的顺序无关。</p>

<h3 id="使用delete-函数删除键值对">使用delete()函数删除键值对</h3>

<p>使用<code>delete()</code>内建函数从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p>

<pre><code class="language-go">delete(map, key)
</code></pre>

<p>其中，</p>

<ul>
<li>map:表示要删除键值对的map</li>
<li>key:表示要删除的键值对的键</li>
</ul>

<p>示例代码如下：</p>

<pre><code class="language-go">func main(){
	scoreMap := make(map[string]int)
	scoreMap[&quot;张三&quot;] = 90
	scoreMap[&quot;小明&quot;] = 100
	scoreMap[&quot;娜扎&quot;] = 60
	delete(scoreMap, &quot;小明&quot;)//将小明:100从map中删除
	for k,v := range scoreMap{
		fmt.Println(k, v)
	}
}
</code></pre>

<h3 id="按照指定顺序遍历map">按照指定顺序遍历map</h3>

<pre><code class="language-go">func main() {
	rand.Seed(time.Now().UnixNano()) //初始化随机数种子

	var scoreMap = make(map[string]int, 200)

	for i := 0; i &lt; 100; i++ {
		key := fmt.Sprintf(&quot;stu%02d&quot;, i) //生成stu开头的字符串
		value := rand.Intn(100)          //生成0~99的随机整数
		scoreMap[key] = value
	}
	//取出map中的所有key存入切片keys
	var keys = make([]string, 0, 200)
	for key := range scoreMap {
		keys = append(keys, key)
	}
	//对切片进行排序
	sort.Strings(keys)
	//按照排序后的key遍历map
	for _, key := range keys {
		fmt.Println(key, scoreMap[key])
	}
}
</code></pre>

<h3 id="元素为map类型的切片">元素为map类型的切片</h3>

<p>下面的代码演示了切片中的元素为map类型时的操作：</p>

<pre><code class="language-go">func main() {
	var mapSlice = make([]map[string]string, 3)
	for index, value := range mapSlice {
		fmt.Printf(&quot;index:%d value:%v\n&quot;, index, value)
	}
	fmt.Println(&quot;after init&quot;)
	// 对切片中的map元素进行初始化
	mapSlice[0] = make(map[string]string, 10)
	mapSlice[0][&quot;name&quot;] = &quot;小王子&quot;
	mapSlice[0][&quot;password&quot;] = &quot;123456&quot;
	mapSlice[0][&quot;address&quot;] = &quot;沙河&quot;
	for index, value := range mapSlice {
		fmt.Printf(&quot;index:%d value:%v\n&quot;, index, value)
	}
}
</code></pre>

<h3 id="值为切片类型的map">值为切片类型的map</h3>

<p>下面的代码演示了map中值为切片类型的操作：</p>

<pre><code class="language-go">func main() {
	var sliceMap = make(map[string][]string, 3)
	fmt.Println(sliceMap)
	fmt.Println(&quot;after init&quot;)
	key := &quot;中国&quot;
	value, ok := sliceMap[key]
	if !ok {
		value = make([]string, 0, 2)
	}
	value = append(value, &quot;北京&quot;, &quot;上海&quot;)
	sliceMap[key] = value
	fmt.Println(sliceMap)
}
</code></pre>

<h4 id="练习题-5">练习题</h4>

<ol>
<li>写一个程序，统计一个字符串中每个单词出现的次数。比如：”how do you do”中how=1 do=2 you=1。</li>

<li><p>观察下面代码，写出最终的打印结果。</p>

<pre><code class="language-go">func main() {
	type Map map[string][]int
	m := make(Map)
	s := []int{1, 2}
	s = append(s, 3)
	fmt.Printf(&quot;%+v\n&quot;, s)
	m[&quot;q1mi&quot;] = s
	s = append(s[:1], s[2:]...)
	fmt.Printf(&quot;%+v\n&quot;, s)
	fmt.Printf(&quot;%+v\n&quot;, m[&quot;q1mi&quot;])
}
</code></pre></li>
</ol>

<h2 id="go语言基础之函数">Go语言基础之函数</h2>

<p>函数是组织好的、可重复使用的、用于执行指定任务的代码块。本文介绍了Go语言中函数的相关内容。</p>

<p>Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”。</p>

<h3 id="函数定义">函数定义</h3>

<p>Go语言中定义函数使用<code>func</code>关键字，具体格式如下：</p>

<pre><code class="language-go">func 函数名(参数)(返回值){
    函数体
}
</code></pre>

<p>其中：</p>

<ul>
<li>函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名（包的概念详见后文）。</li>
<li>参数：参数由参数变量和参数变量的类型组成，多个参数之间使用<code>,</code>分隔。</li>
<li>返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用<code>()</code>包裹，并用<code>,</code>分隔。</li>
<li>函数体：实现指定功能的代码块。</li>
</ul>

<p>我们先来定义一个求两个数之和的函数：</p>

<pre><code class="language-go">func intSum(x int, y int) int {
	return x + y
}
</code></pre>

<p>函数的参数和返回值都是可选的，例如我们可以实现一个既不需要参数也没有返回值的函数：</p>

<pre><code class="language-go">func sayHello() {
	fmt.Println(&quot;Hello 沙河&quot;)
}
</code></pre>

<h3 id="函数的调用">函数的调用</h3>

<p>定义了函数之后，我们可以通过<code>函数名()</code>的方式调用函数。 例如我们调用上面定义的两个函数，代码如下：</p>

<pre><code class="language-go">func main() {
	sayHello()
	ret := intSum(10, 20)
	fmt.Println(ret)
}
</code></pre>

<p>注意，调用有返回值的函数时，可以不接收其返回值。</p>

<h3 id="参数">参数</h3>

<h4 id="类型简写">类型简写</h4>

<p>函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：</p>

<pre><code class="language-go">func intSum(x, y int) int {
	return x + y
}
</code></pre>

<p>上面的代码中，<code>intSum</code>函数有两个参数，这两个参数的类型均为<code>int</code>，因此可以省略<code>x</code>的类型，因为<code>y</code>后面有类型说明，<code>x</code>参数也是该类型。</p>

<h4 id="可变参数">可变参数</h4>

<p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加<code>...</code>来标识。</p>

<p>注意：可变参数通常要作为函数的最后一个参数。</p>

<p>举个例子：</p>

<pre><code class="language-go">func intSum2(x ...int) int {
	fmt.Println(x) //x是一个切片
	sum := 0
	for _, v := range x {
		sum = sum + v
	}
	return sum
}
</code></pre>

<p>调用上面的函数：</p>

<pre><code class="language-go">ret1 := intSum2()
ret2 := intSum2(10)
ret3 := intSum2(10, 20)
ret4 := intSum2(10, 20, 30)
fmt.Println(ret1, ret2, ret3, ret4) //0 10 30 60
</code></pre>

<p>固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下：</p>

<pre><code class="language-go">func intSum3(x int, y ...int) int {
	fmt.Println(x, y)
	sum := x
	for _, v := range y {
		sum = sum + v
	}
	return sum
}
</code></pre>

<p>调用上述函数：</p>

<pre><code class="language-go">ret5 := intSum3(100)
ret6 := intSum3(100, 10)
ret7 := intSum3(100, 10, 20)
ret8 := intSum3(100, 10, 20, 30)
fmt.Println(ret5, ret6, ret7, ret8) //100 110 130 160
</code></pre>

<p>本质上，函数的可变参数是通过切片来实现的。</p>

<h3 id="返回值">返回值</h3>

<p>Go语言中通过<code>return</code>关键字向外输出返回值。</p>

<h4 id="多返回值">多返回值</h4>

<p>Go语言中函数支持多返回值，函数如果有多个返回值时必须用<code>()</code>将所有返回值包裹起来。</p>

<p>举个例子：</p>

<pre><code class="language-go">func calc(x, y int) (int, int) {
	sum := x + y
	sub := x - y
	return sum, sub
}
</code></pre>

<h4 id="返回值命名">返回值命名</h4>

<p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。</p>

<p>返回值命名的作用就是，再return第一步赋值的步骤中，将返回值赋值给我们定义的变量后续再defer中可以拿到我们的返回值对象，也就是拿到了返回值，我们可以通过改变这个变量的值,来改变返回值</p>

<p>例如：</p>

<pre><code class="language-go">func calc(x, y int) (sum, sub int) {
	sum = x + y
	sub = x - y
	return
}
</code></pre>

<h4 id="返回值补充">返回值补充</h4>

<p>当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。</p>

<pre><code class="language-go">func someFunc(x string) []int {
	if x == &quot;&quot; {
		return nil // 没必要返回[]int{}
	}
	...
}
</code></pre>

<h3 id="函数进阶">函数进阶</h3>

<h4 id="变量作用域">变量作用域</h4>

<h5 id="全局变量">全局变量</h5>

<p>全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

//定义全局变量num
var num int64 = 10

func testGlobalVar() {
	fmt.Printf(&quot;num=%d\n&quot;, num) //函数中可以访问全局变量num
}
func main() {
	testGlobalVar() //num=10
}
</code></pre>

<h5 id="局部变量">局部变量</h5>

<p>局部变量又分为两种： 函数内定义的变量无法在该函数外使用，例如下面的示例代码main函数中无法使用testLocalVar函数中定义的变量x：</p>

<pre><code class="language-go">func testLocalVar() {
	//定义一个函数局部变量x,仅在该函数内生效
	var x int64 = 100
	fmt.Printf(&quot;x=%d\n&quot;, x)
}

func main() {
	testLocalVar()
	fmt.Println(x) // 此时无法使用变量x
}
</code></pre>

<p>如果局部变量和全局变量重名，优先访问局部变量。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

//定义全局变量num
var num int64 = 10

func testNum() {
	num := 100
	fmt.Printf(&quot;num=%d\n&quot;, num) // 函数中优先使用局部变量
}
func main() {
	testNum() // num=100
}
</code></pre>

<p>接下来我们来看一下语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式。</p>

<pre><code class="language-go">func testLocalVar2(x, y int) {
	fmt.Println(x, y) //函数的参数也是只在本函数中生效
	if x &gt; 0 {
		z := 100 //变量z只在if语句块生效
		fmt.Println(z)
	}
	//fmt.Println(z)//此处无法使用变量z
}
</code></pre>

<p>还有我们之前讲过的for循环语句中定义的变量，也是只在for语句块中生效：</p>

<pre><code class="language-go">func testLocalVar3() {
	for i := 0; i &lt; 10; i++ {
		fmt.Println(i) //变量i只在当前for语句块中生效
	}
	//fmt.Println(i) //此处无法使用变量i
}
</code></pre>

<h4 id="函数类型与变量">函数类型与变量</h4>

<h5 id="定义函数类型">定义函数类型</h5>

<p>我们可以使用<code>type</code>关键字来定义一个函数类型，具体格式如下：</p>

<pre><code class="language-go">type calculation func(int, int) int
</code></pre>

<p>上面语句定义了一个<code>calculation</code>类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p>

<p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p>

<pre><code class="language-go">func add(x, y int) int {
	return x + y
}

func sub(x, y int) int {
	return x - y
}
</code></pre>

<p>add和sub都能赋值给calculation类型的变量。</p>

<pre><code class="language-go">var c calculation
c = add
</code></pre>

<h5 id="函数类型变量">函数类型变量</h5>

<p>我们可以声明函数类型的变量并且为该变量赋值：</p>

<pre><code class="language-go">func main() {
	var c calculation               // 声明一个calculation类型的变量c
	c = add                         // 把add赋值给c
	fmt.Printf(&quot;type of c:%T\n&quot;, c) // type of c:main.calculation
	fmt.Println(c(1, 2))            // 像调用add一样调用c

	f := add                        // 将函数add赋值给变量f
	fmt.Printf(&quot;type of f:%T\n&quot;, f) // type of f:func(int, int) int
	fmt.Println(f(10, 20))          // 像调用add一样调用f
}
</code></pre>

<h4 id="高阶函数">高阶函数</h4>

<p>高阶函数分为函数作为参数和函数作为返回值两部分。</p>

<h5 id="函数作为参数">函数作为参数</h5>

<p>函数可以作为参数：</p>

<pre><code class="language-go">func add(x, y int) int {
	return x + y
}
func calc(x, y int, op func(int, int) int) int {
	return op(x, y)
}
func main() {
	ret2 := calc(10, 20, add)
	fmt.Println(ret2) //30
}
</code></pre>

<h5 id="函数作为返回值">函数作为返回值</h5>

<p>函数也可以作为返回值：</p>

<pre><code class="language-go">func do(s string) (func(int, int) int, error) {
	switch s {
	case &quot;+&quot;:
		return add, nil
	case &quot;-&quot;:
		return sub, nil
	default:
		err := errors.New(&quot;无法识别的操作符&quot;)
		return nil, err
	}
}
</code></pre>

<h4 id="匿名函数和闭包">匿名函数和闭包</h4>

<h5 id="匿名函数">匿名函数</h5>

<p>函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p>

<pre><code class="language-go">func(参数)(返回值){
    函数体
}
</code></pre>

<p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:</p>

<pre><code class="language-go">func main() {
	// 将匿名函数保存到变量
	add := func(x, y int) {
		fmt.Println(x + y)
	}
	add(10, 20) // 通过变量调用匿名函数

	//自执行函数：匿名函数定义完加()直接执行
	func(x, y int) {
		fmt.Println(x + y)
	}(10, 20)
}
</code></pre>

<p>匿名函数多用于实现回调函数和闭包。</p>

<h5 id="闭包">闭包</h5>

<p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，<code>闭包=函数+引用环境</code>。 首先我们来看一个例子：</p>

<pre><code class="language-go">func adder() func(int) int {
	var x int
	return func(y int) int {
		x += y
		return x
	}
}
func main() {
	var f = adder()
	fmt.Println(f(10)) //10
	fmt.Println(f(20)) //30
	fmt.Println(f(30)) //60

	f1 := adder()
	fmt.Println(f1(40)) //40
	fmt.Println(f1(50)) //90
}
</code></pre>

<p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。 闭包进阶示例1：</p>

<pre><code class="language-go">func adder2(x int) func(int) int {
	return func(y int) int {
		x += y
		return x
	}
}
func main() {
	var f = adder2(10)
	fmt.Println(f(10)) //20
	fmt.Println(f(20)) //40
	fmt.Println(f(30)) //70

	f1 := adder2(20)
	fmt.Println(f1(40)) //60
	fmt.Println(f1(50)) //110
}
</code></pre>

<p>闭包进阶示例2：</p>

<pre><code class="language-go">func makeSuffixFunc(suffix string) func(string) string {
	return func(name string) string {
		if !strings.HasSuffix(name, suffix) {
			return name + suffix
		}
		return name
	}
}

func main() {
	jpgFunc := makeSuffixFunc(&quot;.jpg&quot;)
	txtFunc := makeSuffixFunc(&quot;.txt&quot;)
	fmt.Println(jpgFunc(&quot;test&quot;)) //test.jpg
	fmt.Println(txtFunc(&quot;test&quot;)) //test.txt
}
</code></pre>

<p>闭包进阶示例3：</p>

<pre><code class="language-go">func calc(base int) (func(int) int, func(int) int) {
	add := func(i int) int {
		base += i
		return base
	}

	sub := func(i int) int {
		base -= i
		return base
	}
	return add, sub
}

func main() {
	f1, f2 := calc(10)
	fmt.Println(f1(1), f2(2)) //11 9
	fmt.Println(f1(3), f2(4)) //12 8
	fmt.Println(f1(5), f2(6)) //13 7
}
</code></pre>

<p>闭包其实并不复杂，只要牢记<code>闭包=函数+引用环境</code>。</p>

<h4 id="defer语句">defer语句</h4>

<p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	fmt.Println(&quot;start&quot;)
	defer fmt.Println(1)
	defer fmt.Println(2)
	defer fmt.Println(3)
	fmt.Println(&quot;end&quot;)
}
</code></pre>

<p>输出结果：</p>

<pre><code class="language-go">start
end
3
2
1
</code></pre>

<p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p>

<h5 id="defer执行时机">defer执行时机</h5>

<p>在Go语言的函数中<code>return</code>语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而<code>defer</code>语句执行的时机就在返回值赋值操作后，RET指令执行前。具体如下图所示：<img src="/resources/技术收录/golang/defer.png" alt="defer执行时机" /></p>

<h5 id="defer经典案例">defer经典案例</h5>

<p>阅读下面的代码，写出最后的打印结果。</p>

<pre><code class="language-go">func f1() int {
	x := 5
	defer func() {
		x++
	}()
	return x
}

func f2() (x int) {
	defer func() {
		x++
	}()
	return 5
}

func f3() (y int) {
	x := 5
	defer func() {
		x++
	}()
	return x
}
func f4() (x int) {
	defer func(x int) {
		x++
	}(x)
	return 5
}
func main() {
	fmt.Println(f1())
	fmt.Println(f2())
	fmt.Println(f3())
	fmt.Println(f4())
}
</code></pre>

<h4 id="defer面试题">defer面试题</h4>

<pre><code class="language-go">func calc(index string, a, b int) int {
	ret := a + b
	fmt.Println(index, a, b, ret)
	return ret
}

func main() {
	x := 1
	y := 2
	defer calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))
	x = 10
	defer calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))
	y = 20
}
</code></pre>

<p>问，上面代码的输出结果是？（提示：defer注册要延迟执行的函数时该函数所有的参数都需要确定其值）</p>

<h3 id="内置函数介绍">内置函数介绍</h3>

<table>
<thead>
<tr>
<th align="center">内置函数</th>
<th align="center">介绍</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">close</td>
<td align="center">主要用来关闭channel</td>
</tr>

<tr>
<td align="center">len</td>
<td align="center">用来求长度，比如string、array、slice、map、channel</td>
</tr>

<tr>
<td align="center">new</td>
<td align="center">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td>
</tr>

<tr>
<td align="center">make</td>
<td align="center">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td>
</tr>

<tr>
<td align="center">append</td>
<td align="center">用来追加元素到数组、slice中</td>
</tr>

<tr>
<td align="center">panic和recover</td>
<td align="center">用来做错误处理</td>
</tr>
</tbody>
</table>

<h4 id="panic-recover">panic/recover</h4>

<p>Go语言中目前（Go1.12）是没有异常机制，但是使用<code>panic/recover</code>模式来处理错误。 <code>panic</code>可以在任何地方引发，但<code>recover</code>只有在<code>defer</code>调用的函数中有效。 首先来看一个例子：</p>

<pre><code class="language-go">func funcA() {
	fmt.Println(&quot;func A&quot;)
}

func funcB() {
	panic(&quot;panic in B&quot;)
}

func funcC() {
	fmt.Println(&quot;func C&quot;)
}
func main() {
	funcA()
	funcB()
	funcC()
}
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">func A
panic: panic in B

goroutine 1 [running]:
main.funcB(...)
        .../code/func/main.go:12
main.main()
        .../code/func/main.go:20 +0x98
</code></pre>

<p>程序运行期间<code>funcB</code>中引发了<code>panic</code>导致程序崩溃，异常退出了。这个时候我们就可以通过<code>recover</code>将程序恢复回来，继续往后执行。</p>

<pre><code class="language-go">func funcA() {
	fmt.Println(&quot;func A&quot;)
}

func funcB() {
	defer func() {
		err := recover()
		//如果程序出出现了panic错误,可以通过recover恢复过来
		if err != nil {
			fmt.Println(&quot;recover in B&quot;)
		}
	}()
	panic(&quot;panic in B&quot;)
}

func funcC() {
	fmt.Println(&quot;func C&quot;)
}
func main() {
	funcA()
	funcB()
	funcC()
}
</code></pre>

<p><strong>注意：</strong></p>

<ol>
<li><code>recover()</code>必须搭配<code>defer</code>使用。</li>
<li><code>defer</code>一定要在可能引发<code>panic</code>的语句之前定义。</li>
</ol>

<h4 id="练习题-6">练习题</h4>

<ol>
<li><p>分金币</p>

<pre><code class="language-go">/*
你有50枚金币，需要分配给以下几个人：Matthew,Sarah,Augustus,Heidi,Emilie,Peter,Giana,Adriano,Aaron,Elizabeth。
分配规则如下：
a. 名字中每包含1个'e'或'E'分1枚金币
b. 名字中每包含1个'i'或'I'分2枚金币
c. 名字中每包含1个'o'或'O'分3枚金币
d: 名字中每包含1个'u'或'U'分4枚金币
写一个程序，计算每个用户分到多少金币，以及最后剩余多少金币？
程序结构如下，请实现 ‘dispatchCoin’ 函数
*/
var (
	coins = 50
	users = []string{
		&quot;Matthew&quot;, &quot;Sarah&quot;, &quot;Augustus&quot;, &quot;Heidi&quot;, &quot;Emilie&quot;, &quot;Peter&quot;, &quot;Giana&quot;, &quot;Adriano&quot;, &quot;Aaron&quot;, &quot;Elizabeth&quot;,
	}
	distribution = make(map[string]int, len(users))
)

func main() {
	left := dispatchCoin()
	fmt.Println(&quot;剩下：&quot;, left)
}
</code></pre></li>
</ol>

<h2 id="go语言基础之指针">Go语言基础之指针</h2>

<p>区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。</p>

<p>要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。</p>

<p><strong>Go语言中的指针</strong></p>

<p>任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p>

<p>比如，“永远不要高估自己”这句话是我的座右铭，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），我在程序中把这段话赋值给变量<code>A</code>，把内存地址赋值给变量<code>B</code>。这时候变量<code>B</code>就是一个指针变量。通过变量<code>A</code>和变量<code>B</code>都能找到我的座右铭。</p>

<p>Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：<code>&amp;</code>（取地址）和<code>*</code>（根据地址取值）。</p>

<h3 id="指针地址和指针类型">指针地址和指针类型</h3>

<p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用<code>&amp;</code>字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：<code>*int</code>、<code>*int64</code>、<code>*string</code>等。</p>

<p>取变量指针的语法如下：</p>

<pre><code class="language-go">ptr := &amp;v    // v的类型为T
</code></pre>

<p>其中：</p>

<ul>
<li>v:代表被取地址的变量，类型为<code>T</code></li>
<li>ptr:用于接收地址的变量，ptr的类型就为<code>*T</code>，称做T的指针类型。*代表指针。</li>
</ul>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	a := 10
	b := &amp;a
	fmt.Printf(&quot;a:%d ptr:%p\n&quot;, a, &amp;a) // a:10 ptr:0xc00001a078
	fmt.Printf(&quot;b:%p type:%T\n&quot;, b, b) // b:0xc00001a078 type:*int
	fmt.Println(&amp;b)                    // 0xc00000e018
}
</code></pre>

<p>我们来看一下<code>b := &amp;a</code>的图示：<img src="/resources/技术收录/golang/ptr.png" alt="取变量地址图示" /></p>

<h3 id="指针取值">指针取值</h3>

<p>在对普通变量使用&amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。</p>

<pre><code class="language-go">func main() {
	//指针取值
	a := 10
	b := &amp;a // 取变量a的地址，将指针保存到b中
	fmt.Printf(&quot;type of b:%T\n&quot;, b)
	c := *b // 指针取值（根据指针去内存取值）
	fmt.Printf(&quot;type of c:%T\n&quot;, c)
	fmt.Printf(&quot;value of c:%v\n&quot;, c)
}
</code></pre>

<p>输出如下：</p>

<pre><code class="language-go">type of b:*int
type of c:int
value of c:10
</code></pre>

<p><strong>总结：</strong> 取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</p>

<p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p>

<ul>
<li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li>
<li>指针变量的值是指针地址。</li>
<li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li>
</ul>

<p><strong>指针传值示例：</strong></p>

<pre><code class="language-go">func modify1(x int) {
	x = 100
}

func modify2(x *int) {
	*x = 100
}

func main() {
	a := 10
	modify1(a)
	fmt.Println(a) // 10
	modify2(&amp;a)
	fmt.Println(a) // 100
}
</code></pre>

<h3 id="new和make">new和make</h3>

<p>我们先来看一个例子：</p>

<pre><code class="language-go">func main() {
	var a *int
	*a = 100
	fmt.Println(*a)

	var b map[string]int
	b[&quot;沙河娜扎&quot;] = 100
	fmt.Println(b)
}
</code></pre>

<p>执行上面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。</p>

<h4 id="new">new</h4>

<p>new是一个内置的函数，它的函数签名如下：</p>

<pre><code class="language-go">func new(Type) *Type
</code></pre>

<p>其中，</p>

<ul>
<li>Type表示类型，new函数只接受一个参数，这个参数是一个类型</li>
<li>*Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</li>
</ul>

<p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：</p>

<pre><code class="language-go">func main() {
	a := new(int)
	b := new(bool)
	fmt.Printf(&quot;%T\n&quot;, a) // *int
	fmt.Printf(&quot;%T\n&quot;, b) // *bool
	fmt.Println(*a)       // 0
	fmt.Println(*b)       // false
}	
</code></pre>

<p>本节开始的示例代码中<code>var a *int</code>只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：</p>

<pre><code class="language-go">func main() {
	var a *int
	a = new(int)
	*a = 10
	fmt.Println(*a)
}
</code></pre>

<h4 id="make">make</h4>

<p>make也是用于内存分配的，区别于new，它只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：</p>

<pre><code class="language-go">func make(t Type, size ...IntegerType) Type
</code></pre>

<p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。</p>

<p>本节开始的示例中<code>var b map[string]int</code>只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：</p>

<pre><code class="language-go">func main() {
	var b map[string]int
	b = make(map[string]int, 10)
	b[&quot;沙河娜扎&quot;] = 100
	fmt.Println(b)
}
</code></pre>

<h4 id="new与make的区别">new与make的区别</h4>

<ol>
<li>二者都是用来做内存分配的。</li>
<li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li>
<li>而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li>
</ol>

<h2 id="go语言基础之包">Go语言基础之包</h2>

<p>在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的。本文介绍了Go语言中如何定义包、如何导出包的内容及如何导入其他包。</p>

<h3 id="包与依赖管理">包与依赖管理</h3>

<p><strong>本章学习目标</strong></p>

<ul>
<li>掌握包的定义和使用</li>
<li>掌握init初始化函数的使用</li>
<li>掌握依赖管理工具go module的使用</li>
</ul>

<p>在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的。本文介绍了Go语言中如何定义包、如何导出包的内容及如何引入其他包。同时也将介绍如何在项目中使用go module管理依赖。</p>

<h3 id="包-package">包（package）</h3>

<h4 id="包介绍">包介绍</h4>

<p>Go语言中支持模块化的开发理念，在Go语言中使用<code>包（package）</code>来支持代码模块化和代码复用。一个包是由一个或多个Go源码文件（.go结尾的文件）组成，是一种高级的代码复用方案，Go语言为我们提供了很多内置包，如<code>fmt</code>、<code>os</code>、<code>io</code>等。</p>

<p>例如，在之前的章节中我们频繁使用了<code>fmt</code>这个内置包。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main(){
  fmt.Println(&quot;Hello world!&quot;)
}
</code></pre>

<p>上面短短的几行代码就涉及到了如何定义包以及如何引入其它包两个内容，接下来我们依次介绍一下它们。</p>

<h4 id="定义包">定义包</h4>

<p>我们可以根据自己的需要创建自定义包。一个包可以简单理解为一个存放<code>.go</code>文件的文件夹。该文件夹下面的所有<code>.go</code>文件都要在非注释的第一行添加如下声明，声明该文件归属的包。</p>

<pre><code class="language-go">package packagename
</code></pre>

<p>其中：</p>

<ul>
<li>package：声明包的关键字</li>
<li>packagename：包名，可以不与文件夹的名称一致，不能包含 <code>-</code> 符号，最好与其实现的功能相对应。</li>
</ul>

<p>另外需要注意一个文件夹下面直接包含的文件只能归属一个包，同一个包的文件不能在多个文件夹下。包名为<code>main</code>的包是应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含<code>main</code>包的源代码则不会得到可执行文件。</p>

<h4 id="标识符可见性">标识符可见性</h4>

<p>在同一个包内部声明的标识符都位于同一个命名空间下，在不同的包内部声明的标识符就属于不同的命名空间。想要在包的外部使用包内部的标识符就需要添加包名前缀，例如<code>fmt.Println(&quot;Hello world!&quot;)</code>，就是指调用<code>fmt</code>包中的<code>Println</code>函数。</p>

<p>如果想让一个包中的标识符（如变量、常量、类型、函数等）能被外部的包使用，那么标识符必须是对外可见的（public）。在Go语言中是通过标识符的首字母大/小写来控制标识符的对外可见（public）/不可见（private）的。在一个包内部只有首字母大写的标识符才是对外可见的。</p>

<p>例如我们定义一个名为<code>demo</code>的包，在其中定义了若干标识符。在另外一个包中并不是所有的标识符都能通过<code>demo.</code>前缀访问到，因为只有那些首字母是大写的标识符才是对外可见的。</p>

<pre><code class="language-go">package demo

import &quot;fmt&quot;

// 包级别标识符的可见性

// num 定义一个全局整型变量
// 首字母小写，对外不可见(只能在当前包内使用)
var num = 100

// Mode 定义一个常量
// 首字母大写，对外可见(可在其它包中使用)
const Mode = 1

// person 定义一个代表人的结构体
// 首字母小写，对外不可见(只能在当前包内使用)
type person struct {
	name string
	Age  int
}

// Add 返回两个整数和的函数
// 首字母大写，对外可见(可在其它包中使用)
func Add(x, y int) int {
	return x + y
}

// sayHi 打招呼的函数
// 首字母小写，对外不可见(只能在当前包内使用)
func sayHi() {
	var myName = &quot;七米&quot; // 函数局部变量，只能在当前函数内使用
	fmt.Println(myName)
}
</code></pre>

<p>同样的规则也适用于结构体，结构体中可导出字段的字段名称必须首字母大写。</p>

<pre><code class="language-go">type Student struct {
	Name  string // 可在包外访问的方法
	class string // 仅限包内访问的字段
}
</code></pre>

<h4 id="包的引入">包的引入</h4>

<p>要在当前包中使用另外一个包的内容就需要使用<code>import</code>关键字引入这个包，并且import语句通常放在文件的开头，<code>package</code>声明语句的下方。完整的引入声明语句格式如下:</p>

<pre><code class="language-go">import importname &quot;path/to/package&quot;
</code></pre>

<p>其中：</p>

<ul>
<li>importname：引入的包名，通常都省略。默认值为引入包的包名。</li>
<li>path/to/package：引入包的路径名称，必须使用双引号包裹起来。</li>
<li>Go语言中禁止循环导入包。</li>
</ul>

<p>一个Go源码文件中可以同时引入多个包，例如：</p>

<pre><code class="language-go">import &quot;fmt&quot;
import &quot;net/http&quot;
import &quot;os&quot;
</code></pre>

<p>当然可以使用批量引入的方式。</p>

<pre><code class="language-go">import (
    &quot;fmt&quot;
  	&quot;net/http&quot;
    &quot;os&quot;
)
</code></pre>

<p>当引入的多个包中存在相同的包名或者想自行为某个引入的包设置一个新包名时，都需要通过<code>importname</code>指定一个在当前文件中使用的新包名。例如，在引入<code>fmt</code>包时为其指定一个新包名<code>f</code>。</p>

<pre><code class="language-go">import f &quot;fmt&quot;
</code></pre>

<p>这样在当前这个文件中就可以通过使用<code>f</code>来调用<code>fmt</code>包中的函数了。</p>

<pre><code class="language-go">f.Println(&quot;Hello world!&quot;)
</code></pre>

<p>如果引入一个包的时候为其设置了一个特殊<code>_</code>作为包名，那么这个包的引入方式就称为匿名引入。一个包被匿名引入的目的主要是为了加载这个包，从而使得这个包中的资源得以初始化。 被匿名引入的包中的<code>init</code>函数将被执行并且仅执行一遍。</p>

<pre><code class="language-go">import _ &quot;github.com/go-sql-driver/mysql&quot;
</code></pre>

<p>匿名引入的包与其他方式导入的包一样都会被编译到可执行文件中。</p>

<p>需要注意的是，Go语言中不允许引入包却不在代码中使用这个包的内容，如果引入了未使用的包则会触发编译错误。</p>

<h4 id="init初始化函数">init初始化函数</h4>

<p>在每一个Go源文件中，都可以定义任意个如下格式的特殊函数：</p>

<pre><code class="language-go">func init(){
  // ...
}
</code></pre>

<p>这种特殊的函数不接收任何参数也没有任何返回值，我们也不能在代码中主动调用它。当程序启动的时候，init函数会按照它们声明的顺序自动执行。</p>

<p>一个包的初始化过程是按照代码中引入的顺序来进行的，所有在该包中声明的<code>init</code>函数都将被串行调用并且仅调用执行一次。每一个包初始化的时候都是先执行依赖的包中声明的<code>init</code>函数再执行当前包中声明的<code>init</code>函数。确保在程序的<code>main</code>函数开始执行时所有的依赖包都已初始化完成。<img src="/resources/技术收录/golang/package01.png" alt="包初始化函数执行顺序示意图" /></p>

<p>每一个包的初始化是先从初始化包级别变量开始的。例如从下面的示例中我们就可以看出包级别变量的初始化会先于<code>init</code>初始化函数。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

var x int8 = 10

const pi = 3.14

func init() {
  fmt.Println(&quot;x:&quot;, x)
  fmt.Println(&quot;pi:&quot;, pi)
  sayHi()
}

func sayHi() {
	fmt.Println(&quot;Hello World!&quot;)
}

func main() {
	fmt.Println(&quot;你好，世界！&quot;)
}
</code></pre>

<p>输出结果：</p>

<pre><code class="language-bash">x: 10
pi: 3.14
Hello World!
你好，世界！
</code></pre>

<p>在上面的代码中，我们了解了Go语言中包的定义及包的初始化过程，这让我们能够在开发时按照自己的需要定义包。同时我们还学到了如何在我们的代码中引入其它的包，不过在本小节的所有示例中我们都是引入Go内置的包。现代编程语言大多都允许开发者对外发布包/库，也支持开发者在自己的代码中引入第三方库。这样的设计能够让广大开发者一起参与到语言的生态环境建设当中，把生态建设的更加完善。</p>

<h4 id="go-module-1">go module</h4>

<p>在Go语言的早期版本中，我们编写Go项目代码时所依赖的所有第三方包都需要保存在GOPATH这个目录下面。这样的依赖管理方式存在一个致命的缺陷，那就是不支持版本管理，同一个依赖包只能存在一个版本的代码。可是我们本地的多个项目完全可能分别依赖同一个第三方包的不同版本。</p>

<h4 id="go-module介绍">go module介绍</h4>

<p>Go module 是 Go1.11 版本发布的依赖管理方案，从 Go1.14 版本开始推荐在生产环境使用，于Go1.16版本默认开启。Go module 提供了以下命令供我们使用：</p>

<p>go module相关命令</p>

<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">介绍</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">go mod init</td>
<td align="center">初始化项目依赖，生成go.mod文件</td>
</tr>

<tr>
<td align="center">go mod download</td>
<td align="center">根据go.mod文件下载依赖</td>
</tr>

<tr>
<td align="center">go mod tidy</td>
<td align="center">比对项目文件中引入的依赖与go.mod进行比对</td>
</tr>

<tr>
<td align="center">go mod graph</td>
<td align="center">输出依赖关系图</td>
</tr>

<tr>
<td align="center">go mod edit</td>
<td align="center">编辑go.mod文件</td>
</tr>

<tr>
<td align="center">go mod vendor</td>
<td align="center">将项目的所有依赖导出至vendor目录</td>
</tr>

<tr>
<td align="center">go mod verify</td>
<td align="center">检验一个依赖包是否被篡改过</td>
</tr>

<tr>
<td align="center">go mod why</td>
<td align="center">解释为什么需要某个依赖</td>
</tr>
</tbody>
</table>

<p>Go语言在 go module 的过渡阶段提供了 <code>GO111MODULE</code> 这个环境变量来作为是否启用 go module 功能的开关，考虑到 Go1.16 之后 go module 已经默认开启，所以本书不再介绍该配置，对于刚接触Go语言的读者而言完全没有必要了解这个历史包袱。</p>

<p><strong>GOPROXY</strong></p>

<p>这个环境变量主要是用于设置 Go 模块代理（Go module proxy），其作用是用于使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式，直接通过镜像站点来快速拉取。</p>

<p>GOPROXY 的默认值是：<code>https://proxy.golang.org,direct</code>，由于某些原因国内无法正常访问该地址，所以我们通常需要配置一个可访问的地址。目前社区使用比较多的有两个<code>https://goproxy.cn</code>和<code>https://goproxy.io</code>，当然如果你的公司有提供GOPROXY地址那么就直接使用。设置GOPAROXY的命令如下：</p>

<pre><code class="language-bash">go env -w GOPROXY=https://goproxy.cn,direct
</code></pre>

<p>GOPROXY 允许设置多个代理地址，多个地址之间需使用英文逗号 “,” 分隔。最后的 “direct” 是一个特殊指示符，用于指示 Go 回源到源地址去抓取（比如 GitHub 等）。当配置有多个代理地址时，如果第一个代理地址返回 404 或 410 错误时，Go 会自动尝试下一个代理地址，当遇见 “direct” 时触发回源，也就是回到源地址去抓取。</p>

<p><strong>GOPRIVATE</strong></p>

<p>设置了GOPROXY 之后，go 命令就会从配置的代理地址拉取和校验依赖包。当我们在项目中引入了非公开的包（公司内部git仓库或 github 私有仓库等），此时便无法正常从代理拉取到这些非公开的依赖包，这个时候就需要配置 GOPRIVATE 环境变量。GOPRIVATE用来告诉 go 命令哪些仓库属于私有仓库，不必通过代理服务器拉取和校验。</p>

<p>GOPRIVATE 的值也可以设置多个，多个地址之间使用英文逗号 “,” 分隔。我们通常会把自己公司内部的代码仓库设置到 GOPRIVATE 中，例如：</p>

<pre><code class="language-bash">$ go env -w GOPRIVATE=&quot;git.mycompany.com&quot;
</code></pre>

<p>这样在拉取以<code>git.mycompany.com</code>为路径前缀的依赖包时就能正常拉取了。</p>

<p>此外，如果公司内部自建了 GOPROXY 服务，那么我们可以通过设置 <code>GONOPROXY=none</code>，允许通内部代理拉取私有仓库的包。</p>

<h4 id="使用go-module引入包">使用go module引入包</h4>

<p>接下来我们将通过一个示例来演示如何在开发项目时使用 go module 拉取和管理项目依赖。</p>

<p><strong>初始化项目</strong> 我们在本地新建一个名为<code>holiday</code>项目，按如下方式创建一个名为<code>holiday</code>的文件夹并切换到该目录下：</p>

<pre><code class="language-bash">$ mkdir holiday
$ cd holiday
</code></pre>

<p>目前我们位于<code>holiday</code>文件夹下，接下来执行下面的命令初始化项目。</p>

<pre><code class="language-bash">$ go mod init holiday
go: creating new go.mod: module holiday
</code></pre>

<p>该命令会自动在项目目录下创建一个<code>go.mod</code>文件，其内容如下。</p>

<pre><code class="language-go">module holiday

go 1.16
</code></pre>

<p>其中：</p>

<ul>
<li>module holiday：定义当前项目的导入路径</li>
<li>go 1.16：标识当前项目使用的 Go 版本</li>
</ul>

<p><code>go.mod</code>文件会记录项目使用的第三方依赖包信息，包括包名和版本，由于我们的<code>holiday</code>项目目前还没有使用到第三方依赖包，所以<code>go.mod</code>文件暂时还没有记录任何依赖包信息，只有当前项目的一些信息。</p>

<p>接下来，我们在项目目录下新建一个<code>main.go</code>文件，其内容如下：</p>

<pre><code class="language-go">// holiday/main.go

package main

import &quot;fmt&quot;

func main() {
	fmt.Println(&quot;现在是假期时间...&quot;)
}
</code></pre>

<p>然后，我们的<code>holiday</code>项目现在需要引入一个第三方包<code>github.com/q1mi/hello</code>来实现一些必要的功能。类似这样的场景在我们的日常开发中是很常见的。我们需要先将依赖包下载到本地同时在<code>go.mod</code>中记录依赖信息，然后才能在我们的代码中引入并使用这个包。下载依赖包主要有两种方法。</p>

<p>第一种方法是在项目目录下执行<code>go get</code>命令手动下载依赖的包：</p>

<pre><code class="language-bash">holiday $ go get -u github.com/q1mi/hello
go get: added github.com/q1mi/hello v0.1.1
</code></pre>

<p>这样默认会下载最新的发布版本，你也可以指定想要下载指定的版本号的。</p>

<pre><code class="language-bash">holiday $ go get -u github.com/q1mi/hello@v0.1.0
go: downloading github.com/q1mi/hello v0.1.0
go get: downgraded github.com/q1mi/hello v0.1.1 =&gt; v0.1.0
</code></pre>

<p>如果依赖包没有发布任何版本则会拉取最新的提交，最终<code>go.mod</code>中的依赖信息会变成类似下面这种由默认v0.0.0的版本号和最新一次commit的时间和hash组成的版本格式：</p>

<pre><code class="language-go">require github.com/q1mi/hello v0.0.0-20210218074646-139b0bcd549d
</code></pre>

<p>如果想指定下载某个commit对应的代码，可以直接指定commit hash，不过没有必要写出完整的commit hash，一般前7位即可。例如：</p>

<pre><code class="language-bash">holiday $ go get github.com/q1mi/hello@2ccfadd
go: downloading github.com/q1mi/hello v0.1.2-0.20210219092711-2ccfaddad6a3
go get: added github.com/q1mi/hello v0.1.2-0.20210219092711-2ccfaddad6a3
</code></pre>

<p>此时，我们打开<code>go.mod</code>文件就可以看到下载的依赖包及版本信息都已经被记录下来了。</p>

<pre><code class="language-go">module holiday

go 1.16

require github.com/q1mi/hello v0.1.0 // indirect
</code></pre>

<p>行尾的<code>indirect</code>表示该依赖包为间接依赖，说明在当前程序中的所有 import 语句中没有发现引入这个包。</p>

<p>另外在执行<code>go get</code>命令下载一个新的依赖包时一般会额外添加<code>-u</code>参数，强制更新现有依赖。</p>

<p>第二种方式是我们直接编辑<code>go.mod</code>文件，将依赖包和版本信息写入该文件。例如我们修改<code>holiday/go.mod</code>文件内容如下：</p>

<pre><code class="language-go">module holiday

go 1.16

require github.com/q1mi/hello latest
</code></pre>

<p>表示当前项目需要使用<code>github.com/q1mi/hello</code>库的最新版本，然后在项目目录下执行<code>go mod download</code>下载依赖包。</p>

<pre><code class="language-bash">holiday $ go mod download
</code></pre>

<p>如果不输出其它提示信息就说明依赖已经下载成功，此时<code>go.mod</code>文件已经变成如下内容。</p>

<pre><code class="language-go">module holiday

go 1.16

require github.com/q1mi/hello v0.1.1
</code></pre>

<p>从中我们可以知道最新的版本号是<code>v0.1.1</code>。如果事先知道依赖包的具体版本号，可以直接在<code>go.mod</code>中指定需要的版本然后再执行<code>go mod download</code>下载。</p>

<p>这种方法同样支持指定想要下载的commit进行下载，例如直接在<code>go.mod</code>文件中按如下方式指定commit hash，这里只写出来了commit hash的前7位。</p>

<pre><code class="language-go">require github.com/q1mi/hello 2ccfadda
</code></pre>

<p>执行<code>go mod download</code>下载完依赖后，<code>go.mod</code>文件中对应的版本信息会自动更新为类似下面的格式。</p>

<pre><code class="language-go">module holiday

go 1.16

require github.com/q1mi/hello v0.1.2-0.20210219092711-2ccfaddad6a3
</code></pre>

<p>下载好要使用的依赖包之后，我们现在就可以在<code>holiday/main.go</code>文件中使用这个包了。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;

	&quot;github.com/q1mi/hello&quot;
)

func main() {
	fmt.Println(&quot;现在是假期时间...&quot;)

	hello.SayHi() // 调用hello包的SayHi函数
}
</code></pre>

<p>将上述代码编译执行，就能看到执行结果了。</p>

<pre><code class="language-bash">holiday $ go build
holiday $ ./holiday
现在是假期时间...
你好，我是七米。很高兴认识你。
</code></pre>

<p>当我们的项目功能越做越多，代码越来越多的时候，通常会选择在项目内部按功能或业务划分成多个不同包。Go语言支持在一个项目（project）下定义多个包（package）。</p>

<p>例如，我们在<code>holiday</code>项目内部创建一个新的package——<code>summer</code>，此时新的项目目录结构如下：</p>

<pre><code class="language-bash">holidy
├── go.mod
├── go.sum
├── main.go
└── summer
    └── summer.go
</code></pre>

<p>其中<code>holiday/summer/summer.go</code>文件内容如下：</p>

<pre><code class="language-go">package summer

import &quot;fmt&quot;

// Diving 潜水...
func Diving() {
	fmt.Println(&quot;夏天去诗巴丹潜水...&quot;)
}
</code></pre>

<p>此时想要在当前项目目录下的其他包或者<code>main.go</code>中调用这个<code>Diving</code>函数需要如何引入呢？这里以在<code>main.go</code>中演示详细的调用过程为例，在项目内其他包的引入方式类似。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;

	&quot;holiday/summer&quot; // 导入当前项目下的包

	&quot;github.com/q1mi/hello&quot; // 导入github上第三方包
)

func main() {
	fmt.Println(&quot;现在是假期时间...&quot;)
	hello.SayHi()

	summer.Diving()
}
</code></pre>

<p>从上面的示例可以看出，项目中定义的包都会以项目的导入路径为前缀。</p>

<p>如果你想要导入本地的一个包，并且这个包也没有发布到到其他任何代码仓库，这时候你可以在<code>go.mod</code>文件中使用<code>replace</code>语句将依赖临时替换为本地的代码包。例如在我的电脑上有另外一个名为<code>liwenzhou.com/overtime</code>的项目，它位于<code>holiday</code>项目同级目录下：</p>

<pre><code class="language-bash">├── holiday
│   ├── go.mod
│   ├── go.sum
│   ├── main.go
│   └── summer
│       └── summer.go
└── overtime
    ├── go.mod
    └── overtime.go
</code></pre>

<p>由于<code>liwenzhou.com/overtime</code>包只存在于我本地，并不能通过网络获取到这个代码包，这个时候应该如何在<code>holidy</code>项目中引入它呢？</p>

<p>我们可以在<code>holidy/go.mod</code>文件中正常引入<code>liwenzhou.com/overtime</code>包，然后像下面的示例那样使用<code>replace</code>语句将这个依赖替换为使用相对路径表示的本地包。</p>

<pre><code class="language-go">module holiday

go 1.16

require github.com/q1mi/hello v0.1.1
require liwenzhou.com/overtime v0.0.0

replace liwenzhou.com/overtime  =&gt; ../overtime
</code></pre>

<p>这样，我们就可以在<code>holiday/main.go</code>下正常引入并使用<code>overtime</code>包了。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;

	&quot;holiday/summer&quot; // 导入当前项目下的包

	&quot;liwenzhou.com/overtime&quot; // 通过replace导入的本地包

	&quot;github.com/q1mi/hello&quot; // 导入github上第三方包
)

func main() {
	fmt.Println(&quot;现在是假期时间...&quot;)
	hello.SayHi()

	summer.Diving()

	overtime.Do()
}
</code></pre>

<p>我们也经常使用<code>replace</code>将项目依赖中的某个包，替换为其他版本的代码包或我们自己修改后的代码包。</p>

<p><strong>go.mod文件</strong></p>

<p><code>go.mod</code>文件中记录了当前项目中所有依赖包的相关信息，声明依赖的格式如下：</p>

<pre><code class="language-bash">require module/path v1.2.3
</code></pre>

<p>其中：</p>

<ul>
<li>require：声明依赖的关键字</li>
<li>module/path：依赖包的引入路径</li>
<li>v1.2.3：依赖包的版本号。支持以下几种格式：

<ul>
<li>latest：最新版本</li>
<li>v1.0.0：详细版本号</li>
<li>commit hash：指定某次commit hash</li>
</ul></li>
</ul>

<p>引入某些没有发布过<code>tag</code>版本标识的依赖包时，<code>go.mod</code>中记录的依赖版本信息就会出现类似<code>v0.0.0-20210218074646-139b0bcd549d</code>的格式，由版本号、commit时间和commit的hash值组成。</p>

<p><img src="/resources/技术收录/golang/module_version_info.png" alt="go module生成的版本信息组成示意图" /></p>

<p><strong>go.sum文件</strong></p>

<p>使用go module下载了依赖后，项目目录下还会生成一个<code>go.sum</code>文件，这个文件中详细记录了当前项目中引入的依赖包的信息及其hash 值。<code>go.sum</code>文件内容通常是以类似下面的格式出现。</p>

<pre><code class="language-go">&lt;module&gt; &lt;version&gt;/go.mod &lt;hash&gt;
</code></pre>

<p>或者</p>

<pre><code class="language-go">&lt;module&gt; &lt;version&gt; &lt;hash&gt;
&lt;module&gt; &lt;version&gt;/go.mod &lt;hash&gt;
</code></pre>

<p>不同于其他语言提供的基于中心的包管理机制，例如 npm 和 pypi等，Go并没有提供一个中央仓库来管理所有依赖包，而是采用分布式的方式来管理包。为了防止依赖包被非法篡改，Go module 引入了<code>go.sum</code>机制来对依赖包进行校验。</p>

<p><strong>依赖保存位置</strong></p>

<p>Go module 会把下载到本地的依赖包会以类似下面的形式保存在 <code>$GOPATH/pkg/mod</code>目录下，每个依赖包都会带有版本号进行区分，这样就允许在本地存在同一个包的多个不同版本。</p>

<pre><code class="language-bash">mod
├── cache
├── cloud.google.com
├── github.com
    	└──q1mi
          ├── hello@v0.0.0-20210218074646-139b0bcd549d
          ├── hello@v0.1.1
          └── hello@v0.1.0
...
</code></pre>

<p>如果想清除所有本地已缓存的依赖包数据，可以执行 <code>go clean -modcache</code> 命令。</p>

<h4 id="使用go-module发布包">使用go module发布包</h4>

<p>在上面的小节中我们学习了如何在项目中引入别人提供的依赖包，那么当我们想要在社区发布一个自己编写的代码包或者在公司内部编写一个供内部使用的公用组件时，我们该怎么做呢？接下来，我们就一起编写一个代码包并将它发布到<code>github.com</code>仓库，让它能够被全球的Go语言开发者使用。</p>

<p>我们首先在自己的 github 账号下新建一个项目，并把它下载到本地。我这里就以创建和发布一个名为<code>hello</code>的项目为例进行演示。这个<code>hello</code>包将对外提供一个名为<code>SayHi</code>的函数，它的作用非常简单就是向调用者发去问候。</p>

<pre><code class="language-bash">$ git clone https://github.com/q1mi/hello
$ cd hello
</code></pre>

<p>我们当前位于<code>hello</code>项目目录下，执行下面的命令初始化项目，创建<code>go.mod</code>文件。需要注意的是这里定义项目的引入路径为<code>github.com/q1mi/hello</code>，读者在自行测试时需要将这部分替换为自己的仓库路径。</p>

<pre><code class="language-bash">hello $ go mod init github.com/q1mi/hello
go: creating new go.mod: module github.com/q1mi/hello
</code></pre>

<p>接下来我们在该项目根目录下创建 <code>hello.go</code> 文件，添加下面的内容：</p>

<pre><code class="language-go">package hello

import &quot;fmt&quot;

func SayHi() {
	fmt.Println(&quot;你好，我是七米。很高兴认识你。&quot;)
}
</code></pre>

<p>然后将该项目的代码 push 到仓库的远端分支，这样就对外发布了一个Go包。其他的开发者可以通过<code>github.com/q1mi/hello</code>这个引入路径下载并使用这个包了。</p>

<p>一个设计完善的包应该包含开源许可证及文档等内容，并且我们还应该尽心维护并适时发布适当的版本。github 上发布版本号使用git tag为代码包打上标签即可。</p>

<pre><code class="language-bash">hello $ git tag -a v0.1.0 -m &quot;release version v0.1.0&quot;
hello $ git push origin v0.1.0
</code></pre>

<p>经过上面的操作我们就发布了一个版本号为<code>v0.1.0</code>的版本。</p>

<p>Go modules中建议使用语义化版本控制，其建议的版本号格式如下：</p>

<p><img src="/resources/技术收录/golang/version_number.png" alt="语义化版本号示意图" /></p>

<p>其中：</p>

<ul>
<li>主版本号：发布了不兼容的版本迭代时递增（breaking changes）。</li>
<li>次版本号：发布了功能性更新时递增。</li>
<li>修订号：发布了bug修复类更新时递增。</li>
</ul>

<p><strong>发布新的主版本</strong></p>

<p>现在我们的<code>hello</code>项目要进行与之前版本不兼容的更新，我们计划让<code>SayHi</code>函数支持向指定人发出问候。更新后的<code>SayHi</code>函数内容如下：</p>

<pre><code class="language-go">package hello

import &quot;fmt&quot;

// SayHi 向指定人打招呼的函数
func SayHi(name string) {
	fmt.Printf(&quot;你好%s，我是七米。很高兴认识你。\n&quot;, name)
}
</code></pre>

<p>由于这次改动巨大（修改了函数之前的调用规则），对之前使用该包作为依赖的用户影响巨大。因此我们需要发布一个主版本号递增的<code>v2</code>版本。在这种情况下，我们通常会修改当前包的引入路径，像下面的示例一样为引入路径添加版本后缀。</p>

<pre><code class="language-go">// hello/go.mod

module github.com/q1mi/hello/v2

go 1.16
</code></pre>

<p>把修改后的代码提交：</p>

<pre><code class="language-bash">hello $ git add .
hello $ git commit -m &quot;feat: SayHi现在支持给指定人打招呼啦&quot;
hello $ git push
</code></pre>

<p>打好 tag 推送到远程仓库。</p>

<pre><code class="language-bash">hello $ git tag -a v2.0.0 -m &quot;release version v2.0.0&quot;
hello $ git push origin v2.0.0
</code></pre>

<p>这样在不影响使用旧版本的用户的前提下，我们新的版本也发布出去了。想要使用<code>v2</code>版本的代码包的用户只需按修改后的引入路径下载即可。</p>

<pre><code class="language-bash">go get github.com/q1mi/hello/v2@v2.0.0
</code></pre>

<p>在代码中使用的过程与之前类似，只是需要注意引入路径要添加 v2 版本后缀。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;

	&quot;github.com/q1mi/hello/v2&quot; // 引入v2版本
)

func main() {
	fmt.Println(&quot;现在是假期时间...&quot;)

	hello.SayHi(&quot;张三&quot;) // v2版本的SayHi函数需要传入字符串参数
}
</code></pre>

<p><strong>废弃已发布版本</strong></p>

<p>如果某个发布的版本存在致命缺陷不再想让用户使用时，我们可以使用<code>retract</code>声明废弃的版本。例如我们在<code>hello/go.mod</code>文件中按如下方式声明即可对外废弃<code>v0.1.2</code>版本。</p>

<pre><code class="language-go">module github.com/q1mi/hello

go 1.16


retract v0.1.2
</code></pre>

<p>用户使用go get下载<code>v0.1.2</code>版本时就会收到提示，催促其升级到其他版本。</p>

<h3 id="练习题-7">练习题</h3>

<ol>
<li>编写一个<code>calc</code>包实现加减乘除四个功能函数，在<code>snow</code>这个包中引入<code>calc</code>包并调用其加减乘除四个函数实现数学运算。</li>
</ol>

<h2 id="go语言基础之结构体">Go语言基础之结构体</h2>

<p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p>

<h3 id="类型别名和自定义类型">类型别名和自定义类型</h3>

<h4 id="自定义类型">自定义类型</h4>

<p>在Go语言中有一些基本的数据类型，如<code>string</code>、<code>整型</code>、<code>浮点型</code>、<code>布尔</code>等数据类型， Go语言中可以使用<code>type</code>关键字来定义自定义类型。</p>

<p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p>

<pre><code class="language-go">//将MyInt定义为int类型
type MyInt int
</code></pre>

<p>通过<code>type</code>关键字的定义，<code>MyInt</code>就是一种新的类型，它具有<code>int</code>的特性。</p>

<h4 id="类型别名">类型别名</h4>

<p>类型别名是<code>Go1.9</code>版本添加的新功能。</p>

<p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p>

<pre><code class="language-go">type TypeAlias = Type
</code></pre>

<p>我们之前见过的<code>rune</code>和<code>byte</code>就是类型别名，他们的定义如下：</p>

<pre><code class="language-go">type byte = uint8
type rune = int32
</code></pre>

<h4 id="类型定义和类型别名的区别">类型定义和类型别名的区别</h4>

<p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p>

<pre><code class="language-go">//类型定义
type NewInt int

//类型别名
type MyInt = int

func main() {
	var a NewInt
	var b MyInt
	
	fmt.Printf(&quot;type of a:%T\n&quot;, a) //type of a:main.NewInt
	fmt.Printf(&quot;type of b:%T\n&quot;, b) //type of b:int
}
</code></pre>

<p>结果显示a的类型是<code>main.NewInt</code>，表示main包下定义的<code>NewInt</code>类型。b的类型是<code>int</code>。<code>MyInt</code>类型只会在代码中存在，编译完成时并不会有<code>MyInt</code>类型。</p>

<h3 id="结构体">结构体</h3>

<p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称<code>struct</code>。 也就是我们可以通过<code>struct</code>来定义自己的类型了。</p>

<p>Go语言中通过<code>struct</code>来实现面向对象。</p>

<h4 id="结构体的定义">结构体的定义</h4>

<p>使用<code>type</code>和<code>struct</code>关键字来定义结构体，具体代码格式如下：</p>

<pre><code class="language-go">type 类型名 struct {
    字段名 字段类型
    字段名 字段类型
    …
}
</code></pre>

<p>其中：</p>

<ul>
<li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li>
<li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li>
<li>字段类型：表示结构体字段的具体类型。</li>
</ul>

<p>举个例子，我们定义一个<code>Person</code>（人）结构体，代码如下：</p>

<pre><code class="language-go">type person struct {
	name string
	city string
	age  int8
}
</code></pre>

<p>同样类型的字段也可以写在一行，</p>

<pre><code class="language-go">type person1 struct {
	name, city string
	age        int8
}
</code></pre>

<p>这样我们就拥有了一个<code>person</code>的自定义类型，它有<code>name</code>、<code>city</code>、<code>age</code>三个字段，分别表示姓名、城市和年龄。这样我们使用这个<code>person</code>结构体就能够很方便的在程序中表示和存储人信息了。</p>

<p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</p>

<h4 id="结构体实例化">结构体实例化</h4>

<p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p>

<p>结构体本身也是一种类型，我们可以像声明内置类型一样使用<code>var</code>关键字声明结构体类型。</p>

<pre><code class="language-go">var 结构体实例 结构体类型
</code></pre>

<h5 id="基本实例化">基本实例化</h5>

<p>举个例子：</p>

<pre><code class="language-go">type person struct {
	name string
	city string
	age  int8
}

func main() {
	var p1 person
	p1.name = &quot;沙河娜扎&quot;
	p1.city = &quot;北京&quot;
	p1.age = 18
	fmt.Printf(&quot;p1=%v\n&quot;, p1)  //p1={沙河娜扎 北京 18}
	fmt.Printf(&quot;p1=%#v\n&quot;, p1) //p1=main.person{name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:18}
}
</code></pre>

<p>我们通过<code>.</code>来访问结构体的字段（成员变量）,例如<code>p1.name</code>和<code>p1.age</code>等。</p>

<h5 id="匿名结构体">匿名结构体</h5>

<p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p>

<pre><code class="language-go">package main
     
import (
    &quot;fmt&quot;
)
     
func main() {
    var user struct{Name string; Age int}
    user.Name = &quot;小王子&quot;
    user.Age = 18
    fmt.Printf(&quot;%#v\n&quot;, user)
}
</code></pre>

<h5 id="创建指针类型结构体">创建指针类型结构体</h5>

<p>我们还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p>

<pre><code class="language-go">var p2 = new(person)
fmt.Printf(&quot;%T\n&quot;, p2)     //*main.person
fmt.Printf(&quot;p2=%#v\n&quot;, p2) //p2=&amp;main.person{name:&quot;&quot;, city:&quot;&quot;, age:0}
</code></pre>

<p>从打印的结果中我们可以看出<code>p2</code>是一个结构体指针。</p>

<p>需要注意的是在Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员。</p>

<pre><code class="language-go">var p2 = new(person)
p2.name = &quot;小王子&quot;
p2.age = 28
p2.city = &quot;上海&quot;
fmt.Printf(&quot;p2=%#v\n&quot;, p2) //p2=&amp;main.person{name:&quot;小王子&quot;, city:&quot;上海&quot;, age:28}
</code></pre>

<h5 id="取结构体的地址实例化">取结构体的地址实例化</h5>

<p>使用<code>&amp;</code>对结构体进行取地址操作相当于对该结构体类型进行了一次<code>new</code>实例化操作。</p>

<pre><code class="language-go">p3 := &amp;person{}
fmt.Printf(&quot;%T\n&quot;, p3)     //*main.person
fmt.Printf(&quot;p3=%#v\n&quot;, p3) //p3=&amp;main.person{name:&quot;&quot;, city:&quot;&quot;, age:0}
p3.name = &quot;七米&quot;
p3.age = 30
p3.city = &quot;成都&quot;
fmt.Printf(&quot;p3=%#v\n&quot;, p3) //p3=&amp;main.person{name:&quot;七米&quot;, city:&quot;成都&quot;, age:30}
</code></pre>

<p><code>p3.name = &quot;七米&quot;</code>其实在底层是<code>(*p3).name = &quot;七米&quot;</code>，这是Go语言帮我们实现的语法糖。</p>

<h4 id="结构体初始化">结构体初始化</h4>

<p>没有初始化的结构体，其成员变量都是对应其类型的零值。</p>

<pre><code class="language-go">type person struct {
	name string
	city string
	age  int8
}

func main() {
	var p4 person
	fmt.Printf(&quot;p4=%#v\n&quot;, p4) //p4=main.person{name:&quot;&quot;, city:&quot;&quot;, age:0}
}
</code></pre>

<h5 id="使用键值对初始化">使用键值对初始化</h5>

<p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p>

<pre><code class="language-go">p5 := person{
	name: &quot;小王子&quot;,
	city: &quot;北京&quot;,
	age:  18,
}
fmt.Printf(&quot;p5=%#v\n&quot;, p5) //p5=main.person{name:&quot;小王子&quot;, city:&quot;北京&quot;, age:18}
</code></pre>

<p>也可以对结构体指针进行键值对初始化，例如：</p>

<pre><code class="language-go">p6 := &amp;person{
	name: &quot;小王子&quot;,
	city: &quot;北京&quot;,
	age:  18,
}
fmt.Printf(&quot;p6=%#v\n&quot;, p6) //p6=&amp;main.person{name:&quot;小王子&quot;, city:&quot;北京&quot;, age:18}
</code></pre>

<p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p>

<pre><code class="language-go">p7 := &amp;person{
	city: &quot;北京&quot;,
}
fmt.Printf(&quot;p7=%#v\n&quot;, p7) //p7=&amp;main.person{name:&quot;&quot;, city:&quot;北京&quot;, age:0}
</code></pre>

<h5 id="使用值的列表初始化">使用值的列表初始化</h5>

<p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p>

<pre><code class="language-go">p8 := &amp;person{
	&quot;沙河娜扎&quot;,
	&quot;北京&quot;,
	28,
}
fmt.Printf(&quot;p8=%#v\n&quot;, p8) //p8=&amp;main.person{name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:28}
</code></pre>

<p>使用这种格式初始化时，需要注意：</p>

<ol>
<li>必须初始化结构体的所有字段。</li>
<li>初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li>
<li>该方式不能和键值初始化方式混用。</li>
</ol>

<h4 id="结构体内存布局">结构体内存布局</h4>

<p>结构体占用一块连续的内存。</p>

<pre><code class="language-go">type test struct {
	a int8
	b int8
	c int8
	d int8
}
n := test{
	1, 2, 3, 4,
}
fmt.Printf(&quot;n.a %p\n&quot;, &amp;n.a)
fmt.Printf(&quot;n.b %p\n&quot;, &amp;n.b)
fmt.Printf(&quot;n.c %p\n&quot;, &amp;n.c)
fmt.Printf(&quot;n.d %p\n&quot;, &amp;n.d)
</code></pre>

<p>输出：</p>

<pre><code class="language-bash">n.a 0xc0000a0060
n.b 0xc0000a0061
n.c 0xc0000a0062
n.d 0xc0000a0063
</code></pre>

<p>【进阶知识点】关于Go语言中的内存对齐推荐阅读:<a href="https://www.liwenzhou.com/posts/Go/struct-memory-layout/">Go结构体的内存对齐</a></p>

<h5 id="空结构体">空结构体</h5>

<p>空结构体是不占用空间的。</p>

<pre><code class="language-go">var v struct{}
fmt.Println(unsafe.Sizeof(v))  // 0
</code></pre>

<h4 id="面试题">面试题</h4>

<p>请问下面代码的执行结果是什么？</p>

<pre><code class="language-go">type student struct {
	name string
	age  int
}

func main() {
	m := make(map[string]*student)
	stus := []student{
		{name: &quot;小王子&quot;, age: 18},
		{name: &quot;娜扎&quot;, age: 23},
		{name: &quot;大王八&quot;, age: 9000},
	}

	for _, stu := range stus {
		m[stu.name] = &amp;stu
	}
	for k, v := range m {
		fmt.Println(k, &quot;=&gt;&quot;, v.name)
	}
}
</code></pre>

<h3 id="构造函数">构造函数</h3>

<p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个<code>person</code>的构造函数。 因为<code>struct</code>是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p>

<pre><code class="language-go">func newPerson(name, city string, age int8) *person {
	return &amp;person{
		name: name,
		city: city,
		age:  age,
	}
}
</code></pre>

<p>调用构造函数</p>

<pre><code class="language-go">p9 := newPerson(&quot;张三&quot;, &quot;沙河&quot;, 90)
fmt.Printf(&quot;%#v\n&quot;, p9) //&amp;main.person{name:&quot;张三&quot;, city:&quot;沙河&quot;, age:90}
</code></pre>

<h3 id="方法和接收者">方法和接收者</h3>

<p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p>

<p>方法的定义格式如下：</p>

<pre><code class="language-go">func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) {
    函数体
}
</code></pre>

<p>其中，</p>

<ul>
<li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li>
<li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li>
<li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li>
</ul>

<p>举个例子：</p>

<pre><code class="language-go">//Person 结构体
type Person struct {
	name string
	age  int8
}

//NewPerson 构造函数
func NewPerson(name string, age int8) *Person {
	return &amp;Person{
		name: name,
		age:  age,
	}
}

//Dream Person做梦的方法
func (p Person) Dream() {
	fmt.Printf(&quot;%s的梦想是学好Go语言！\n&quot;, p.name)
}

func main() {
	p1 := NewPerson(&quot;小王子&quot;, 25)
	p1.Dream()
}
</code></pre>

<p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p>

<h4 id="指针类型的接收者">指针类型的接收者</h4>

<p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的<code>this</code>或者<code>self</code>。 例如我们为<code>Person</code>添加一个<code>SetAge</code>方法，来修改实例变量的年龄。</p>

<pre><code class="language-go">// SetAge 设置p的年龄
// 使用指针接收者
func (p *Person) SetAge(newAge int8) {
	p.age = newAge
}
</code></pre>

<p>调用该方法：</p>

<pre><code class="language-go">func main() {
	p1 := NewPerson(&quot;小王子&quot;, 25)
	fmt.Println(p1.age) // 25
	p1.SetAge(30)
	fmt.Println(p1.age) // 30
}
</code></pre>

<h4 id="值类型的接收者">值类型的接收者</h4>

<p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p>

<pre><code class="language-go">// SetAge2 设置p的年龄
// 使用值接收者
func (p Person) SetAge2(newAge int8) {
	p.age = newAge
}

func main() {
	p1 := NewPerson(&quot;小王子&quot;, 25)
	p1.Dream()
	fmt.Println(p1.age) // 25
	p1.SetAge2(30) // (*p1).SetAge2(30)
	fmt.Println(p1.age) // 25
}
</code></pre>

<h4 id="什么时候应该使用指针类型接收者">什么时候应该使用指针类型接收者</h4>

<ol>
<li>需要修改接收者中的值</li>
<li>接收者是拷贝代价比较大的大对象</li>
<li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li>
</ol>

<h3 id="任意类型添加方法">任意类型添加方法</h3>

<p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的<code>int</code>类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p>

<pre><code class="language-go">//MyInt 将int定义为自定义MyInt类型
type MyInt int

//SayHello 为MyInt添加一个SayHello的方法
func (m MyInt) SayHello() {
	fmt.Println(&quot;Hello, 我是一个int。&quot;)
}
func main() {
	var m1 MyInt
	m1.SayHello() //Hello, 我是一个int。
	m1 = 100
	fmt.Printf(&quot;%#v  %T\n&quot;, m1, m1) //100  main.MyInt
}
</code></pre>

<p><strong>注意事项：</strong> 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p>

<h3 id="结构体的匿名字段">结构体的匿名字段</h3>

<p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p>

<pre><code class="language-go">//Person 结构体Person类型
type Person struct {
	string
	int
}

func main() {
	p1 := Person{
		&quot;小王子&quot;,
		18,
	}
	fmt.Printf(&quot;%#v\n&quot;, p1)        //main.Person{string:&quot;北京&quot;, int:18}
	fmt.Println(p1.string, p1.int) //北京 18
}
</code></pre>

<p><strong>注意：</strong>这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p>

<h3 id="嵌套结构体">嵌套结构体</h3>

<p>一个结构体中可以嵌套包含另一个结构体或结构体指针，就像下面的示例代码那样。</p>

<pre><code class="language-go">//Address 地址结构体
type Address struct {
	Province string
	City     string
}

//User 用户结构体
type User struct {
	Name    string
	Gender  string
	Address Address
}

func main() {
	user1 := User{
		Name:   &quot;小王子&quot;,
		Gender: &quot;男&quot;,
		Address: Address{
			Province: &quot;山东&quot;,
			City:     &quot;威海&quot;,
		},
	}
	fmt.Printf(&quot;user1=%#v\n&quot;, user1)//user1=main.User{Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address{Province:&quot;山东&quot;, City:&quot;威海&quot;}}
}
</code></pre>

<h4 id="嵌套匿名字段">嵌套匿名字段</h4>

<p>上面user结构体中嵌套的<code>Address</code>结构体也可以采用匿名字段的方式，例如：</p>

<pre><code class="language-go">//Address 地址结构体
type Address struct {
	Province string
	City     string
}

//User 用户结构体
type User struct {
	Name    string
	Gender  string
	Address //匿名字段
}

func main() {
	var user2 User
	user2.Name = &quot;小王子&quot;
	user2.Gender = &quot;男&quot;
	user2.Address.Province = &quot;山东&quot;    // 匿名字段默认使用类型名作为字段名
	user2.City = &quot;威海&quot;                // 匿名字段可以省略
	fmt.Printf(&quot;user2=%#v\n&quot;, user2) //user2=main.User{Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address{Province:&quot;山东&quot;, City:&quot;威海&quot;}}
}
</code></pre>

<p>当访问结构体成员时会先在结构体中查找该字段，找不到再去嵌套的匿名字段中查找。</p>

<h4 id="嵌套结构体的字段名冲突">嵌套结构体的字段名冲突</h4>

<p>嵌套结构体内部可能存在相同的字段名。在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。</p>

<pre><code class="language-go">//Address 地址结构体
type Address struct {
	Province   string
	City       string
	CreateTime string
}

//Email 邮箱结构体
type Email struct {
	Account    string
	CreateTime string
}

//User 用户结构体
type User struct {
	Name   string
	Gender string
	Address
	Email
}

func main() {
	var user3 User
	user3.Name = &quot;沙河娜扎&quot;
	user3.Gender = &quot;男&quot;
	// user3.CreateTime = &quot;2019&quot; //ambiguous selector user3.CreateTime
	user3.Address.CreateTime = &quot;2000&quot; //指定Address结构体中的CreateTime
	user3.Email.CreateTime = &quot;2000&quot;   //指定Email结构体中的CreateTime
}
</code></pre>

<h3 id="结构体的-继承">结构体的“继承”</h3>

<p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p>

<pre><code class="language-go">//Animal 动物
type Animal struct {
	name string
}

func (a *Animal) move() {
	fmt.Printf(&quot;%s会动！\n&quot;, a.name)
}

//Dog 狗
type Dog struct {
	Feet    int8
	*Animal //通过嵌套匿名结构体实现继承
}

func (d *Dog) wang() {
	fmt.Printf(&quot;%s会汪汪汪~\n&quot;, d.name)
}

func main() {
	d1 := &amp;Dog{
		Feet: 4,
		Animal: &amp;Animal{ //注意嵌套的是结构体指针
			name: &quot;乐乐&quot;,
		},
	}
	d1.wang() //乐乐会汪汪汪~
	d1.move() //乐乐会动！
}
</code></pre>

<h3 id="结构体字段的可见性">结构体字段的可见性</h3>

<p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p>

<h3 id="结构体与json序列化">结构体与JSON序列化</h3>

<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号<code>&quot;&quot;</code>包裹，使用冒号<code>:</code>分隔，然后紧接着值；多个键值之间使用英文<code>,</code>分隔。</p>

<pre><code class="language-go">//Student 学生
type Student struct {
	ID     int
	Gender string
	Name   string
}

//Class 班级
type Class struct {
	Title    string
	Students []*Student
}

func main() {
	c := &amp;Class{
		Title:    &quot;101&quot;,
		Students: make([]*Student, 0, 200),
	}
	for i := 0; i &lt; 10; i++ {
		stu := &amp;Student{
			Name:   fmt.Sprintf(&quot;stu%02d&quot;, i),
			Gender: &quot;男&quot;,
			ID:     i,
		}
		c.Students = append(c.Students, stu)
	}
	//JSON序列化：结构体--&gt;JSON格式的字符串
	data, err := json.Marshal(c)
	if err != nil {
		fmt.Println(&quot;json marshal failed&quot;)
		return
	}
	fmt.Printf(&quot;json:%s\n&quot;, data)
	//JSON反序列化：JSON格式的字符串--&gt;结构体
	str := `{&quot;Title&quot;:&quot;101&quot;,&quot;Students&quot;:[{&quot;ID&quot;:0,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu00&quot;},{&quot;ID&quot;:1,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu01&quot;},{&quot;ID&quot;:2,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu02&quot;},{&quot;ID&quot;:3,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu03&quot;},{&quot;ID&quot;:4,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu04&quot;},{&quot;ID&quot;:5,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu05&quot;},{&quot;ID&quot;:6,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu06&quot;},{&quot;ID&quot;:7,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu07&quot;},{&quot;ID&quot;:8,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu08&quot;},{&quot;ID&quot;:9,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu09&quot;}]}`
	c1 := &amp;Class{}
	err = json.Unmarshal([]byte(str), c1)
	if err != nil {
		fmt.Println(&quot;json unmarshal failed!&quot;)
		return
	}
	fmt.Printf(&quot;%#v\n&quot;, c1)
}
</code></pre>

<h3 id="结构体标签-tag">结构体标签（Tag）</h3>

<p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对<strong>反引号</strong>包裹起来，具体的格式如下：</p>

<pre><code class="language-bash">`key1:&quot;value1&quot; key2:&quot;value2&quot;`
</code></pre>

<p>结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</p>

<p><strong>注意事项：</strong> 为结构体编写<code>Tag</code>时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p>

<p>例如我们为<code>Student</code>结构体的每个字段定义json序列化时使用的Tag：</p>

<pre><code class="language-go">//Student 学生
type Student struct {
	ID     int    `json:&quot;id&quot;` //通过指定tag实现json序列化该字段时的key
	Gender string //json序列化是默认使用字段名作为key
	name   string //私有不能被json包访问
}

func main() {
	s1 := Student{
		ID:     1,
		Gender: &quot;男&quot;,
		name:   &quot;沙河娜扎&quot;,
	}
	data, err := json.Marshal(s1)
	if err != nil {
		fmt.Println(&quot;json marshal failed!&quot;)
		return
	}
	fmt.Printf(&quot;json str:%s\n&quot;, data) //json str:{&quot;id&quot;:1,&quot;Gender&quot;:&quot;男&quot;}
}
</code></pre>

<h3 id="结构体和方法补充知识点">结构体和方法补充知识点</h3>

<p>因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意。我们来看下面的例子：</p>

<pre><code class="language-go">type Person struct {
	name   string
	age    int8
	dreams []string
}

func (p *Person) SetDreams(dreams []string) {
	p.dreams = dreams
}

func main() {
	p1 := Person{name: &quot;小王子&quot;, age: 18}
	data := []string{&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;打豆豆&quot;}
	p1.SetDreams(data)

	// 你真的想要修改 p1.dreams 吗？
	data[1] = &quot;不睡觉&quot;
	fmt.Println(p1.dreams)  // ?
}
</code></pre>

<p>正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值。</p>

<pre><code class="language-go">func (p *Person) SetDreams(dreams []string) {
	p.dreams = make([]string, len(dreams))
	copy(p.dreams, dreams)
}
</code></pre>

<p>同样的问题也存在于返回值slice和map的情况，在实际编码过程中一定要注意这个问题。</p>

<h3 id="练习题-8">练习题</h3>

<ol>
<li>使用“面向对象”的思维方式编写一个学生信息管理系统。

<ol>
<li>学生有id、姓名、年龄、分数等信息</li>
<li>程序提供展示学生列表、添加学生、编辑学生信息、删除学生等功能</li>
</ol></li>
</ol>

<h2 id="go语言基础之接口">Go语言基础之接口</h2>

<p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p>

<p><strong>本章学习目标</strong></p>

<ul>
<li>了解为什么需要接口以及接口的特点</li>
<li>掌握接口的声明和使用</li>
<li>掌握接口值的概念</li>
<li>掌握空接口的特点及其使用场景</li>
</ul>

<p>在Go语言中接口（interface）是一种类型，一种抽象的类型。相较于之前章节中讲到的那些具体类型（字符串、切片、结构体等）更注重“我是谁”，接口类型更注重“我能做什么”的问题。接口类型就像是一种约定——概括了一种类型应该具备哪些方法，在Go语言中提倡使用面向接口的编程方式实现解耦。</p>

<h3 id="接口类型">接口类型</h3>

<p>接口是一种由程序员来定义的类型，一个接口类型就是一组方法的集合，它规定了需要实现的所有方法。</p>

<p>相较于使用结构体类型，当我们使用接口类型说明相比于它是什么更关心它能做什么。</p>

<h4 id="接口的定义">接口的定义</h4>

<p>每个接口类型由任意个方法签名组成，接口的定义格式如下：</p>

<pre><code class="language-go">type 接口类型名 interface{
    方法名1( 参数列表1 ) 返回值列表1
    方法名2( 参数列表2 ) 返回值列表2
    …
}
</code></pre>

<p>其中：</p>

<ul>
<li>接口类型名：Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有关闭操作的接口叫<code>closer</code>等。接口名最好要能突出该接口的类型含义。</li>
<li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li>
<li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li>
</ul>

<p>举个例子，定义一个包含<code>Write</code>方法的<code>Writer</code>接口。</p>

<pre><code class="language-go">type Writer interface{
    Write([]byte) error
}
</code></pre>

<p>当你看到一个<code>Writer</code>接口类型的值时，你不知道它是什么，唯一知道的就是可以通过调用它的<code>Write</code>方法来做一些事情。</p>

<h4 id="实现接口的条件">实现接口的条件</h4>

<p>接口就是规定了一个<strong>需要实现的方法列表</strong>，在 Go 语言中一个类型只要实现了接口中规定的所有方法，那么我们就称它实现了这个接口。</p>

<p>我们定义的<code>Singer</code>接口类型，它包含一个<code>Sing</code>方法。</p>

<pre><code class="language-go">// Singer 接口
type Singer interface {
	Sing()
}
</code></pre>

<p>我们有一个<code>Bird</code>结构体类型如下。</p>

<pre><code class="language-go">type Bird struct {}
</code></pre>

<p>因为<code>Singer</code>接口只包含一个<code>Sing</code>方法，所以只需要给<code>Bird</code>结构体添加一个<code>Sing</code>方法就可以满足<code>Singer</code>接口的要求。</p>

<pre><code class="language-go">// Sing Bird类型的Sing方法
func (b Bird) Sing() {
	fmt.Println(&quot;汪汪汪&quot;)
}
</code></pre>

<p>这样就称为<code>Bird</code>实现了<code>Singer</code>接口。</p>

<h4 id="为什么要使用接口">为什么要使用接口？</h4>

<p>现在假设我们的代码世界里有很多小动物，下面的代码片段定义了猫和狗，它们饿了都会叫。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Cat struct{}

func (c Cat) Say() {
	fmt.Println(&quot;喵喵喵~&quot;)
}

type Dog struct{}

func (d Dog) Say() {
	fmt.Println(&quot;汪汪汪~&quot;)
}

func main() {
	c := Cat{}
	c.Say()
	d := Dog{}
	d.Say()
}
</code></pre>

<p>这个时候又跑来了一只羊，羊饿了也会发出叫声。</p>

<pre><code class="language-go">type Sheep struct{}

func (s Sheep) Say() {
	fmt.Println(&quot;咩咩咩~&quot;)
}
</code></pre>

<p>我们接下来定义一个饿肚子的场景。</p>

<pre><code class="language-go">// MakeCatHungry 猫饿了会喵喵喵~
func MakeCatHungry(c Cat) {
	c.Say()
}

// MakeSheepHungry 羊饿了会咩咩咩~
func MakeSheepHungry(s Sheep) {
	s.Say()
}
</code></pre>

<p>接下来会有越来越多的小动物跑过来，我们的代码世界该怎么拓展呢？</p>

<p>在饿肚子这个场景下，我们可不可以把所有动物都当成一个“会叫的类型”来处理呢？当然可以！使用接口类型就可以实现这个目标。 我们的代码其实并不关心究竟是什么动物在叫，我们只是在代码中调用它的<code>Say()</code>方法，这就足够了。</p>

<p>我们可以约定一个<code>Sayer</code>类型，它必须实现一个<code>Say()</code>方法，只要饿肚子了，我们就调用<code>Say()</code>方法。</p>

<pre><code class="language-go">type Sayer interface {
    Say()
}
</code></pre>

<p>然后我们定义一个通用的<code>MakeHungry</code>函数，接收<code>Sayer</code>类型的参数。</p>

<pre><code class="language-go">// MakeHungry 饿肚子了...
func MakeHungry(s Sayer) {
	s.Say()
}
</code></pre>

<p>我们通过使用接口类型，把所有会叫的动物当成<code>Sayer</code>类型来处理，只要实现了<code>Say()</code>方法都能当成<code>Sayer</code>类型的变量来处理。</p>

<pre><code class="language-go">var c cat
MakeHungry(c)
var d dog
MakeHungry(d)
</code></pre>

<p>在电商系统中我们允许用户使用多种支付方式（支付宝支付、微信支付、银联支付等），我们的交易流程中可能不太在乎用户究竟使用什么支付方式，只要它能提供一个实现支付功能的<code>Pay</code>方法让调用方调用就可以了。</p>

<p>再比如我们需要在某个程序中添加一个将某些指标数据向外输出的功能，根据不同的需求可能要将数据输出到终端、写入到文件或者通过网络连接发送出去。在这个场景下我们可以不关注最终输出的目的地是什么，只需要它能提供一个<code>Write</code>方法让我们把内容写入就可以了。</p>

<p>Go语言中为了解决类似上面的问题引入了接口的概念，接口类型区别于我们之前章节中介绍的那些具体类型，让我们专注于该类型提供的方法，而不是类型本身。使用接口类型通常能够让我们写出更加通用和灵活的代码。</p>

<h4 id="面向接口编程">面向接口编程</h4>

<p>PHP、Java等语言中也有接口的概念，不过在PHP和Java语言中需要显式声明一个类实现了哪些接口，在Go语言中使用隐式声明的方式实现接口。只要一个类型实现了接口中规定的所有方法，那么它就实现了这个接口。</p>

<p>Go语言中的这种设计符合程序开发中抽象的一般规律，例如在下面的代码示例中，我们的电商系统最开始只设计了支付宝一种支付方式：</p>

<pre><code class="language-go">type ZhiFuBao struct {
	// 支付宝
}

// Pay 支付宝的支付方法
func (z *ZhiFuBao) Pay(amount int64) {
  fmt.Printf(&quot;使用支付宝付款：%.2f元。\n&quot;, float64(amount/100))
}

// Checkout 结账
func Checkout(obj *ZhiFuBao) {
	// 支付100元
	obj.Pay(100)
}

func main() {
	Checkout(&amp;ZhiFuBao{})
}
</code></pre>

<p>随着业务的发展，根据用户需求添加支持微信支付。</p>

<pre><code class="language-go">type WeChat struct {
	// 微信
}

// Pay 微信的支付方法
func (w *WeChat) Pay(amount int64) {
	fmt.Printf(&quot;使用微信付款：%.2f元。\n&quot;, float64(amount/100))
}
</code></pre>

<p>在实际的交易流程中，我们可以根据用户选择的支付方式来决定最终调用支付宝的Pay方法还是微信支付的Pay方法。</p>

<pre><code class="language-go">// Checkout 支付宝结账
func CheckoutWithZFB(obj *ZhiFuBao) {
	// 支付100元
	obj.Pay(100)
}

// Checkout 微信支付结账
func CheckoutWithWX(obj *WeChat) {
	// 支付100元
	obj.Pay(100)
}
</code></pre>

<p>实际上，从上面的代码示例中我们可以看出，我们其实并不怎么关心用户选择的是什么支付方式，我们只关心调用Pay方法时能否正常运行。这就是典型的“不关心它是什么，只关心它能做什么”的场景。</p>

<p>在这种场景下我们可以将具体的支付方式抽象为一个名为<code>Payer</code>的接口类型，即任何实现了<code>Pay</code>方法的都可以称为<code>Payer</code>类型。</p>

<pre><code class="language-go">// Payer 包含支付方法的接口类型
type Payer interface {
	Pay(int64)
}
</code></pre>

<p>此时只需要修改下原始的<code>Checkout</code>函数，它接收一个<code>Payer</code>类型的参数。这样就能够在不修改既有函数调用的基础上，支持新的支付方式。</p>

<pre><code class="language-go">// Checkout 结账
func Checkout(obj Payer) {
	// 支付100元
	obj.Pay(100)
}

func main() {
	Checkout(&amp;ZhiFuBao{}) // 之前调用支付宝支付

	Checkout(&amp;WeChat{}) // 现在支持使用微信支付
}
</code></pre>

<p>像类似的例子在我们编程过程中会经常遇到：</p>

<ul>
<li>比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？</li>
<li>比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？</li>
<li>比如满减券、立减券、打折券都属于电商场景下常见的优惠方式，我们能不能把它们当成“优惠券”来处理呢？</li>
</ul>

<p>接口类型是Go语言提供的一种工具，在实际的编码过程中是否使用它由你自己决定，但是通常使用接口类型可以使代码更清晰易读。</p>

<h4 id="接口类型变量">接口类型变量</h4>

<p>那实现了接口又有什么用呢？一个接口类型的变量能够存储所有实现了该接口的类型变量。</p>

<p>例如在上面的示例中，<code>Dog</code>和<code>Cat</code>类型均实现了<code>Sayer</code>接口，此时一个<code>Sayer</code>类型的变量就能够接收<code>Cat</code>和<code>Dog</code>类型的变量。</p>

<pre><code class="language-go">var x Sayer // 声明一个Sayer类型的变量x
a := Cat{}  // 声明一个Cat类型变量a
b := Dog{}  // 声明一个Dog类型变量b
x = a       // 可以把Cat类型变量直接赋值给x
x.Say()     // 喵喵喵
x = b       // 可以把Dog类型变量直接赋值给x
x.Say()     // 汪汪汪
</code></pre>

<h3 id="值接收者和指针接收者">值接收者和指针接收者</h3>

<p>在结构体那一章节中，我们介绍了在定义结构体方法时既可以使用值接收者也可以使用指针接收者。那么对于实现接口来说使用值接收者和使用指针接收者有什么区别呢？接下来我们通过一个例子看一下其中的区别。</p>

<p>我们定义一个<code>Mover</code>接口，它包含一个<code>Move</code>方法。</p>

<pre><code class="language-go">// Mover 定义一个接口类型
type Mover interface {
	Move()
}
</code></pre>

<h4 id="值接收者实现接口">值接收者实现接口</h4>

<p>我们定义一个<code>Dog</code>结构体类型，并使用值接收者为其定义一个<code>Move</code>方法。</p>

<pre><code class="language-go">// Dog 狗结构体类型
type Dog struct{}

// Move 使用值接收者定义Move方法实现Mover接口
func (d Dog) Move() {
	fmt.Println(&quot;狗会动&quot;)
}
</code></pre>

<p>此时实现<code>Mover</code>接口的是<code>Dog</code>类型。</p>

<pre><code class="language-go">var x Mover    // 声明一个Mover类型的变量x

var d1 = Dog{} // d1是Dog类型
x = d1         // 可以将d1赋值给变量x
x.Move()

var d2 = &amp;Dog{} // d2是Dog指针类型
x = d2          // 也可以将d2赋值给变量x
x.Move()
</code></pre>

<p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是结构体类型还是对应的结构体指针类型的变量都可以赋值给该接口变量。</p>

<h4 id="指针接收者实现接口">指针接收者实现接口</h4>

<p>我们再来测试一下使用指针接收者实现接口有什么区别。</p>

<pre><code class="language-go">// Cat 猫结构体类型
type Cat struct{}

// Move 使用指针接收者定义Move方法实现Mover接口
func (c *Cat) Move() {
	fmt.Println(&quot;猫会动&quot;)
}
</code></pre>

<p>此时实现<code>Mover</code>接口的是<code>*Cat</code>类型，我们可以将<code>*Cat</code>类型的变量直接赋值给<code>Mover</code>接口类型的变量<code>x</code>。</p>

<pre><code class="language-go">var c1 = &amp;Cat{} // c1是*Cat类型
x = c1          // 可以将c1当成Mover类型
x.Move()
</code></pre>

<p>但是不能给将<code>Cat</code>类型的变量赋值给<code>Mover</code>接口类型的变量<code>x</code>。</p>

<pre><code class="language-go">// 下面的代码无法通过编译
var c2 = Cat{} // c2是Cat类型
x = c2         // 不能将c2当成Mover类型
</code></pre>

<p>由于Go语言中有对指针求值的语法糖，对于值接收者实现的接口，无论使用值类型还是指针类型都没有问题。但是我们并不总是能对一个值求址，所以对于指针接收者实现的接口要额外注意。</p>

<h3 id="类型与接口的关系">类型与接口的关系</h3>

<h4 id="一个类型实现多个接口">一个类型实现多个接口</h4>

<p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。例如狗不仅可以叫，还可以动。我们完全可以分别定义<code>Sayer</code>接口和<code>Mover</code>接口，具体代码示例如下。</p>

<pre><code class="language-go">// Sayer 接口
type Sayer interface {
	Say()
}

// Mover 接口
type Mover interface {
	Move()
}
</code></pre>

<p><code>Dog</code>既可以实现<code>Sayer</code>接口，也可以实现<code>Mover</code>接口。</p>

<pre><code class="language-go">type Dog struct {
	Name string
}

// 实现Sayer接口
func (d Dog) Say() {
	fmt.Printf(&quot;%s会叫汪汪汪\n&quot;, d.Name)
}

// 实现Mover接口
func (d Dog) Move() {
	fmt.Printf(&quot;%s会动\n&quot;, d.Name)
}
</code></pre>

<p>同一个类型实现不同的接口互相不影响使用。</p>

<pre><code class="language-go">var d = Dog{Name: &quot;旺财&quot;}

var s Sayer = d
var m Mover = d

s.Say()  // 对Sayer类型调用Say方法
m.Move() // 对Mover类型调用Move方法
</code></pre>

<h4 id="多种类型实现同一接口">多种类型实现同一接口</h4>

<p>Go语言中不同的类型还可以实现同一接口。例如在我们的代码世界中不仅狗可以动，汽车也可以动。我们可以使用如下代码体现这个关系。</p>

<pre><code class="language-go">// 实现Mover接口
func (d Dog) Move() {
	fmt.Printf(&quot;%s会动\n&quot;, d.Name)
}

// Car 汽车结构体类型
type Car struct {
	Brand string
}

// Move Car类型实现Mover接口
func (c Car) Move() {
	fmt.Printf(&quot;%s速度70迈\n&quot;, c.Brand)
}
</code></pre>

<p>这样我们在代码中就可以把狗和汽车当成一个会动的类型来处理，不必关注它们具体是什么，只需要调用它们的<code>Move</code>方法就可以了。</p>

<pre><code class="language-go">var obj Mover

obj = Dog{Name: &quot;旺财&quot;}
obj.Move()

obj = Car{Brand: &quot;宝马&quot;}
obj.Move()
</code></pre>

<p>上面的代码执行结果如下：</p>

<pre><code class="language-go">旺财会跑
宝马速度70迈
</code></pre>

<p>一个接口的所有方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p>

<pre><code class="language-go">// WashingMachine 洗衣机
type WashingMachine interface {
	wash()
	dry()
}

// 甩干器
type dryer struct{}

// 实现WashingMachine接口的dry()方法
func (d dryer) dry() {
	fmt.Println(&quot;甩一甩&quot;)
}

// 海尔洗衣机
type haier struct {
	dryer //嵌入甩干器
}

// 实现WashingMachine接口的wash()方法
func (h haier) wash() {
	fmt.Println(&quot;洗刷刷&quot;)
}
</code></pre>

<h3 id="接口组合">接口组合</h3>

<p>接口与接口之间可以通过互相嵌套形成新的接口类型，例如Go标准库<code>io</code>源码中就有很多接口之间互相组合的示例。</p>

<pre><code class="language-go">// src/io/io.go

type Reader interface {
	Read(p []byte) (n int, err error)
}

type Writer interface {
	Write(p []byte) (n int, err error)
}

type Closer interface {
	Close() error
}

// ReadWriter 是组合Reader接口和Writer接口形成的新接口类型
type ReadWriter interface {
	Reader
	Writer
}

// ReadCloser 是组合Reader接口和Closer接口形成的新接口类型
type ReadCloser interface {
	Reader
	Closer
}

// WriteCloser 是组合Writer接口和Closer接口形成的新接口类型
type WriteCloser interface {
	Writer
	Closer
}
</code></pre>

<p>对于这种由多个接口类型组合形成的新接口类型，同样只需要实现新接口类型中规定的所有方法就算实现了该接口类型。</p>

<p>接口也可以作为结构体的一个字段，我们来看一段Go标准库<code>sort</code>源码中的示例。</p>

<pre><code class="language-go">// src/sort/sort.go

// Interface 定义通过索引对元素排序的接口类型
type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}


// reverse 结构体中嵌入了Interface接口
type reverse struct {
    Interface
}
</code></pre>

<p>通过在结构体中嵌入一个接口类型，从而让该结构体类型实现了该接口类型，并且还可以改写该接口的方法。</p>

<pre><code class="language-go">// Less 为reverse类型添加Less方法，重写原Interface接口类型的Less方法
func (r reverse) Less(i, j int) bool {
	return r.Interface.Less(j, i)
}
</code></pre>

<p><code>Interface</code>类型原本的<code>Less</code>方法签名为<code>Less(i, j int) bool</code>，此处重写为<code>r.Interface.Less(j, i)</code>，即通过将索引参数交换位置实现反转。</p>

<p>在这个示例中还有一个需要注意的地方是<code>reverse</code>结构体本身是不可导出的（结构体类型名称首字母小写），<code>sort.go</code>中通过定义一个可导出的<code>Reverse</code>函数来让使用者创建<code>reverse</code>结构体实例。</p>

<pre><code class="language-go">func Reverse(data Interface) Interface {
	return &amp;reverse{data}
}
</code></pre>

<p>这样做的目的是保证得到的<code>reverse</code>结构体中的<code>Interface</code>属性一定不为<code>nil</code>，否者<code>r.Interface.Less(j, i)</code>就会出现空指针panic。</p>

<p>此外在Go内置标准库<code>database/sql</code>中也有很多类似的结构体内嵌接口类型的使用示例，各位读者可自行查阅。</p>

<h3 id="空接口">空接口</h3>

<h4 id="空接口的定义">空接口的定义</h4>

<p>空接口是指没有定义任何方法的接口类型。因此任何类型都可以视为实现了空接口。也正是因为空接口类型的这个特性，空接口类型的变量可以存储任意类型的值。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

// 空接口

// Any 不包含任何方法的空接口类型
type Any interface{}

// Dog 狗结构体
type Dog struct{}

func main() {
	var x Any

	x = &quot;你好&quot; // 字符串型
	fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)
	x = 100 // int型
	fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)
	x = true // 布尔型
	fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)
	x = Dog{} // 结构体类型
	fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)
}
</code></pre>

<p>通常我们在使用空接口类型时不必使用<code>type</code>关键字声明，可以像下面的代码一样直接使用<code>interface{}</code>。</p>

<pre><code class="language-go">var x interface{}  // 声明一个空接口类型变量x
</code></pre>

<h4 id="空接口的应用">空接口的应用</h4>

<h5 id="空接口作为函数的参数">空接口作为函数的参数</h5>

<p>使用空接口实现可以接收任意类型的函数参数。</p>

<pre><code class="language-go">// 空接口作为函数参数
func show(a interface{}) {
	fmt.Printf(&quot;type:%T value:%v\n&quot;, a, a)
}
</code></pre>

<h5 id="空接口作为map的值">空接口作为map的值</h5>

<p>使用空接口实现可以保存任意值的字典。</p>

<pre><code class="language-go">// 空接口作为map值
	var studentInfo = make(map[string]interface{})
	studentInfo[&quot;name&quot;] = &quot;沙河娜扎&quot;
	studentInfo[&quot;age&quot;] = 18
	studentInfo[&quot;married&quot;] = false
	fmt.Println(studentInfo)
</code></pre>

<h3 id="接口值">接口值</h3>

<p>由于接口类型的值可以是任意一个实现了该接口的类型值，所以接口值除了需要记录具体<strong>值</strong>之外，还需要记录这个值属于的<strong>类型</strong>。也就是说接口值由“类型”和“值”组成，鉴于这两部分会根据存入值的不同而发生变化，我们称之为接口的<code>动态类型</code>和<code>动态值</code>。</p>

<p><img src="/resources/技术收录/golang/interface01.png" alt="接口值示例" /></p>

<p>我们接下来通过一个示例来加深对接口值的理解。</p>

<p>下面的示例代码中，定义了一个<code>Mover</code>接口类型和两个实现了该接口的<code>Dog</code>和<code>Car</code>结构体类型。</p>

<pre><code class="language-go">type Mover interface {
	Move()
}

type Dog struct {
	Name string
}

func (d *Dog) Move() {
	fmt.Println(&quot;狗在跑~&quot;)
}

type Car struct {
	Brand string
}

func (c *Car) Move() {
	fmt.Println(&quot;汽车在跑~&quot;)
}
</code></pre>

<p>首先，我们创建一个<code>Mover</code>接口类型的变量<code>m</code>。</p>

<pre><code class="language-go">var m Mover
</code></pre>

<p>此时，接口变量<code>m</code>是接口类型的零值，也就是它的类型和值部分都是<code>nil</code>，就如下图所示。</p>

<p><img src="/resources/技术收录/golang/interface02.png" alt="接口值示例" /></p>

<p>我们可以使用<code>m == nil</code>来判断此时的接口值是否为空。</p>

<pre><code class="language-go">fmt.Println(m == nil)  // true
</code></pre>

<p><strong>注意：</strong>我们不能对一个空接口值调用任何方法，否则会产生panic。</p>

<pre><code class="language-go">m.Move() // panic: runtime error: invalid memory address or nil pointer dereference
</code></pre>

<p>接下来，我们将一个<code>*Dog</code>结构体指针赋值给变量<code>m</code>。</p>

<pre><code class="language-go">m = &amp;Dog{Name: &quot;旺财&quot;}
</code></pre>

<p>此时，接口值<code>m</code>的动态类型会被设置为<code>*Dog</code>，动态值为结构体变量的拷贝。</p>

<p><img src="/resources/技术收录/golang/interface03.png" alt="接口值示例" /></p>

<p>然后，我们给接口变量<code>m</code>赋值为一个<code>*Car</code>类型的值。</p>

<pre><code class="language-go">var c *Car
m = c
</code></pre>

<p>这一次，接口值<code>m</code>的动态类型为<code>*Car</code>，动态值为<code>nil</code>。</p>

<p><img src="/resources/技术收录/golang/interface04.png" alt="接口值示例" /></p>

<p><strong>注意：</strong>此时接口变量<code>m</code>与<code>nil</code>并不相等，因为它只是动态值的部分为<code>nil</code>，而动态类型部分保存着对应值的类型。</p>

<pre><code class="language-go">fmt.Println(m == nil) // false
</code></pre>

<p>接口值是支持相互比较的，当且仅当接口值的动态类型和动态值都相等时才相等。</p>

<pre><code class="language-go">var (
	x Mover = new(Dog)
	y Mover = new(Car)
)
fmt.Println(x == y) // false
</code></pre>

<p>但是有一种特殊情况需要特别注意，如果接口值保存的动态类型相同，但是这个动态类型不支持互相比较（比如切片），那么对它们相互比较时就会引发panic。</p>

<pre><code class="language-go">var z interface{} = []int{1, 2, 3}
fmt.Println(z == z) // panic: runtime error: comparing uncomparable type []int
</code></pre>

<h3 id="类型断言">类型断言</h3>

<p>接口值可能赋值为任意类型的值，那我们如何从接口值获取其存储的具体数据呢？</p>

<p>我们可以借助标准库<code>fmt</code>包的格式化打印获取到接口值的动态类型。</p>

<pre><code class="language-go">var m Mover

m = &amp;Dog{Name: &quot;旺财&quot;}
fmt.Printf(&quot;%T\n&quot;, m) // *main.Dog

m = new(Car)
fmt.Printf(&quot;%T\n&quot;, m) // *main.Car
</code></pre>

<p>而<code>fmt</code>包内部其实是使用反射的机制在程序运行时获取到动态类型的名称。关于反射的内容我们会在后续章节详细介绍。</p>

<p>而想要从接口值中获取到对应的实际值需要使用类型断言，其语法格式如下。</p>

<pre><code class="language-go">x.(T)
</code></pre>

<p>其中：</p>

<ul>
<li>x：表示接口类型的变量</li>
<li>T：表示断言<code>x</code>可能是的类型。</li>
</ul>

<p>该语法返回两个参数，第一个参数是<code>x</code>转化为<code>T</code>类型后的变量，第二个值是一个布尔值，若为<code>true</code>则表示断言成功，为<code>false</code>则表示断言失败。</p>

<p>举个例子：</p>

<pre><code class="language-go">var n Mover = &amp;Dog{Name: &quot;旺财&quot;}
v, ok := n.(*Dog)
if ok {
	fmt.Println(&quot;类型断言成功&quot;)
	v.Name = &quot;富贵&quot; // 变量v是*Dog类型
} else {
	fmt.Println(&quot;类型断言失败&quot;)
}
</code></pre>

<p>如果对一个接口值有多个实际类型需要判断，推荐使用<code>switch</code>语句来实现。</p>

<pre><code class="language-go">// justifyType 对传入的空接口类型变量x进行类型断言
func justifyType(x interface{}) {
	switch v := x.(type) {
	case string:
		fmt.Printf(&quot;x is a string，value is %v\n&quot;, v)
	case int:
		fmt.Printf(&quot;x is a int is %v\n&quot;, v)
	case bool:
		fmt.Printf(&quot;x is a bool is %v\n&quot;, v)
	default:
		fmt.Println(&quot;unsupport type！&quot;)
	}
}
</code></pre>

<p>由于接口类型变量能够动态存储不同类型值的特点，所以很多初学者会滥用接口类型（特别是空接口）来实现编码过程中的便捷。只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。切记不要为了使用接口类型而增加不必要的抽象，导致不必要的运行时损耗。</p>

<p>在 Go 语言中接口是一个非常重要的概念和特性，使用接口类型能够实现代码的抽象和解耦，也可以隐藏某个功能的内部实现，但是缺点就是在查看源码的时候，不太方便查找到具体实现接口的类型。</p>

<p>相信很多读者在刚接触到接口类型时都会有很多疑惑，请牢记接口是一种类型，一种抽象的类型。区别于我们在之前章节提到的那些具体类型（整型、数组、结构体类型等），它是一个只要求实现特定方法的抽象类型。</p>

<p><strong>小技巧：</strong> 下面的代码可以在程序编译阶段验证某一结构体是否满足特定的接口类型。</p>

<pre><code class="language-go">// 摘自gin框架routergroup.go
type IRouter interface{ ... }

type RouterGroup struct { ... }

var _ IRouter = &amp;RouterGroup{}  // 确保RouterGroup实现了接口IRouter
</code></pre>

<p>上面的代码中也可以使用<code>var _ IRouter = (*RouterGroup)(nil)</code>进行验证。</p>

<h3 id="练习题-9">练习题</h3>

<ol>
<li>使用接口的方式实现一个既可以往终端写日志也可以往文件写日志的简易日志库。</li>
</ol>

<h2 id="error接口和错误处理">Error接口和错误处理</h2>

<p>Go 语言中的错误处理与其他语言不太一样，它把错误当成一种值来处理，更强调判断错误、处理错误，而不是一股脑的 catch 捕获异常。</p>

<p><strong>Error</strong>接口和错误处理</p>

<h3 id="error-接口">Error 接口</h3>

<p>Go 语言中把错误当成一种特殊的值来处理，不支持其他语言中使用<code>try/catch</code>捕获异常的方式。</p>

<h3 id="error-接口-1">Error 接口</h3>

<p>Go 语言中使用一个名为 <code>error</code> 接口来表示错误类型。</p>

<pre><code class="language-go">type error interface {
    Error() string
}
</code></pre>

<p><code>error</code> 接口只包含一个方法——<code>Error</code>，这个函数需要返回一个描述错误信息的字符串。</p>

<p>当一个函数或方法需要返回错误时，我们通常是把错误作为最后一个返回值。例如下面标准库 os 中打开文件的函数。</p>

<pre><code class="language-go">func Open(name string) (*File, error) {
	return OpenFile(name, O_RDONLY, 0)
}
</code></pre>

<p>由于 error 是一个接口类型，默认零值为<code>nil</code>。所以我们通常将调用函数返回的错误与<code>nil</code>进行比较，以此来判断函数是否返回错误。例如你会经常看到类似下面的错误判断代码。</p>

<pre><code class="language-go">file, err := os.Open(&quot;./xx.go&quot;)
if err != nil {
	fmt.Println(&quot;打开文件失败,err:&quot;, err)
	return
}
</code></pre>

<p><strong>注意</strong></p>

<p>当我们使用<code>fmt</code>包打印错误时会自动调用 error 类型的 Error 方法，也就是会打印出错误的描述信息。</p>

<h4 id="创建错误">创建错误</h4>

<p>我们可以根据需求自定义 error，最简单的方式是使用<code>errors</code> 包提供的<code>New</code>函数创建一个错误。</p>

<h5 id="errors-new">errors.New</h5>

<p>函数签名如下，</p>

<pre><code class="language-go">func New(text string) error
</code></pre>

<p>它接收一个字符串参数返回包含该字符串的错误。我们可以在函数返回时快速创建一个错误。</p>

<pre><code class="language-go">func queryById(id int64) (*Info, error) {
	if id &lt;= 0 {
		return nil, errors.New(&quot;无效的id&quot;)
	}

	// ...
}
</code></pre>

<p>或者用来定义一个错误变量，例如标准库<code>io.EOF</code>错误定义如下。</p>

<pre><code class="language-go">var EOF = errors.New(&quot;EOF&quot;)
</code></pre>

<h4 id="fmt-errorf">fmt.Errorf</h4>

<p>当我们需要传入格式化的错误描述信息时，使用<code>fmt.Errorf</code>是个更好的选择。</p>

<pre><code class="language-go">fmt.Errorf(&quot;查询数据库失败，err:%v&quot;, err)
</code></pre>

<p>但是上面的方式会丢失原有的错误类型，只拿到错误描述的文本信息。</p>

<p>为了不丢失函数调用的错误链，使用<code>fmt.Errorf</code>时搭配使用特殊的格式化动词<code>%w</code>，可以实现基于已有的错误再包装得到一个新的错误。</p>

<pre><code class="language-go">fmt.Errorf(&quot;查询数据库失败，err:%w&quot;, err)
</code></pre>

<p>对于这种二次包装的错误，<code>errors</code>包中提供了以下三个方法。</p>

<pre><code class="language-go">func Unwrap(err error) error                 // 获得err包含下一层错误
func Is(err, target error) bool              // 判断err是否包含target
func As(err error, target interface{}) bool  // 判断err是否为target类型
</code></pre>

<h4 id="错误结构体类型">错误结构体类型</h4>

<p>此外我们还可以自己定义结构体类型，实现`<code>error</code>接口。</p>

<pre><code class="language-go">// OpError 自定义结构体类型
type OpError struct {
	Op string
}

// Error OpError 类型实现error接口
func (e *OpError) Error() string {
	return fmt.Sprintf(&quot;无权执行%s操作&quot;, e.Op)
}
</code></pre>

<h2 id="go语言基础之反射">Go语言基础之反射</h2>

<p>本文介绍了Go语言反射的意义和基本使用。</p>

<h3 id="变量的内在机制">变量的内在机制</h3>

<p>Go语言中的变量是分为两部分的:</p>

<ul>
<li>类型信息：预先定义好的元信息。</li>
<li>值信息：程序运行过程中可动态变化的。</li>
</ul>

<h3 id="反射介绍">反射介绍</h3>

<p>反射是指在程序运行期间对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p>

<p>支持反射的语言可以在程序编译期间将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期间获取类型的反射信息，并且有能力修改它们。</p>

<p>Go程序在运行期间使用reflect包访问程序的反射信息。</p>

<p>在上一篇博客中我们介绍了空接口。 空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？ 反射就是在运行时动态的获取一个变量的类型信息和值信息。</p>

<h3 id="reflect包">reflect包</h3>

<p>在Go语言的反射机制中，任何接口值都由是<code>一个具体类型</code>和<code>具体类型的值</code>两部分组成的(我们在上一篇接口的博客中有介绍相关概念)。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由<code>reflect.Type</code>和<code>reflect.Value</code>两部分组成，并且reflect包提供了<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>两个函数来获取任意对象的Value和Type。</p>

<h4 id="typeof">TypeOf</h4>

<p>在Go语言中，使用<code>reflect.TypeOf()</code>函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func reflectType(x interface{}) {
	v := reflect.TypeOf(x)
	fmt.Printf(&quot;type:%v\n&quot;, v)
}
func main() {
	var a float32 = 3.14
	reflectType(a) // type:float32
	var b int64 = 100
	reflectType(b) // type:int64
}
</code></pre>

<h5 id="type-name和type-kind">type name和type kind</h5>

<p>在反射中关于类型还划分为两种：<code>类型（Type）</code>和<code>种类（Kind）</code>。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而<code>种类（Kind）</code>就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到<code>种类（Kind）</code>。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

type myInt int64

func reflectType(x interface{}) {
	t := reflect.TypeOf(x)
	fmt.Printf(&quot;type:%v kind:%v\n&quot;, t.Name(), t.Kind())
}

func main() {
	var a *float32 // 指针
	var b myInt    // 自定义类型
	var c rune     // 类型别名
	reflectType(a) // type: kind:ptr
	reflectType(b) // type:myInt kind:int64
	reflectType(c) // type:int32 kind:int32

	type person struct {
		name string
		age  int
	}
	type book struct{ title string }
	var d = person{
		name: &quot;沙河小王子&quot;,
		age:  18,
	}
	var e = book{title: &quot;《跟小王子学Go语言》&quot;}
	reflectType(d) // type:person kind:struct
	reflectType(e) // type:book kind:struct
}
</code></pre>

<p>Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的<code>.Name()</code>都是返回<code>空</code>。</p>

<p>在<code>reflect</code>包中定义的Kind类型如下：</p>

<pre><code class="language-go">type Kind uint
const (
    Invalid Kind = iota  // 非法类型
    Bool                 // 布尔型
    Int                  // 有符号整型
    Int8                 // 有符号8位整型
    Int16                // 有符号16位整型
    Int32                // 有符号32位整型
    Int64                // 有符号64位整型
    Uint                 // 无符号整型
    Uint8                // 无符号8位整型
    Uint16               // 无符号16位整型
    Uint32               // 无符号32位整型
    Uint64               // 无符号64位整型
    Uintptr              // 指针
    Float32              // 单精度浮点数
    Float64              // 双精度浮点数
    Complex64            // 64位复数类型
    Complex128           // 128位复数类型
    Array                // 数组
    Chan                 // 通道
    Func                 // 函数
    Interface            // 接口
    Map                  // 映射
    Ptr                  // 指针
    Slice                // 切片
    String               // 字符串
    Struct               // 结构体
    UnsafePointer        // 底层指针
)
</code></pre>

<h4 id="valueof">ValueOf</h4>

<p><code>reflect.ValueOf()</code>返回的是<code>reflect.Value</code>类型，其中包含了原始值的值信息。<code>reflect.Value</code>与原始值之间可以互相转换。</p>

<p><code>reflect.Value</code>类型提供的获取原始值的方法如下：</p>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">Interface() interface {}</td>
<td align="center">将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td>
</tr>

<tr>
<td align="center">Int() int64</td>
<td align="center">将值以 int 类型返回，所有有符号整型均可以此方式返回</td>
</tr>

<tr>
<td align="center">Uint() uint64</td>
<td align="center">将值以 uint 类型返回，所有无符号整型均可以此方式返回</td>
</tr>

<tr>
<td align="center">Float() float64</td>
<td align="center">将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td>
</tr>

<tr>
<td align="center">Bool() bool</td>
<td align="center">将值以 bool 类型返回</td>
</tr>

<tr>
<td align="center">Bytes() []bytes</td>
<td align="center">将值以字节数组 []bytes 类型返回</td>
</tr>

<tr>
<td align="center">String() string</td>
<td align="center">将值以字符串类型返回</td>
</tr>
</tbody>
</table>

<h5 id="通过反射获取值">通过反射获取值</h5>

<pre><code class="language-go">func reflectValue(x interface{}) {
	v := reflect.ValueOf(x)
	k := v.Kind()
	switch k {
	case reflect.Int64:
		// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换
		fmt.Printf(&quot;type is int64, value is %d\n&quot;, int64(v.Int()))
	case reflect.Float32:
		// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换
		fmt.Printf(&quot;type is float32, value is %f\n&quot;, float32(v.Float()))
	case reflect.Float64:
		// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换
		fmt.Printf(&quot;type is float64, value is %f\n&quot;, float64(v.Float()))
	}
}
func main() {
	var a float32 = 3.14
	var b int64 = 100
	reflectValue(a) // type is float32, value is 3.140000
	reflectValue(b) // type is int64, value is 100
	// 将int类型的原始值转换为reflect.Value类型
	c := reflect.ValueOf(10)
	fmt.Printf(&quot;type c :%T\n&quot;, c) // type c :reflect.Value
}
</code></pre>

<h5 id="通过反射设置变量的值">通过反射设置变量的值</h5>

<p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的<code>Elem()</code>方法来获取指针对应的值。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func reflectSetValue1(x interface{}) {
	v := reflect.ValueOf(x)
	if v.Kind() == reflect.Int64 {
		v.SetInt(200) //修改的是副本，reflect包会引发panic
	}
}
func reflectSetValue2(x interface{}) {
	v := reflect.ValueOf(x)
	// 反射中使用 Elem()方法获取指针对应的值
	if v.Elem().Kind() == reflect.Int64 {
		v.Elem().SetInt(200)
	}
}
func main() {
	var a int64 = 100
	// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value
	reflectSetValue2(&amp;a)
	fmt.Println(a)
}
</code></pre>

<h5 id="isnil-和isvalid">isNil()和isValid()</h5>

<h6 id="isnil">isNil()</h6>

<pre><code class="language-go">func (v Value) IsNil() bool
</code></pre>

<p><code>IsNil()</code>报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p>

<h6 id="isvalid">isValid()</h6>

<pre><code class="language-go">func (v Value) IsValid() bool
</code></pre>

<p><code>IsValid()</code>返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。</p>

<h6 id="举个例子-2">举个例子</h6>

<p><code>IsNil()</code>常被用于判断指针是否为空；<code>IsValid()</code>常被用于判定返回值是否有效。</p>

<pre><code class="language-go">func main() {
	// *int类型空指针
	var a *int
	fmt.Println(&quot;var a *int IsNil:&quot;, reflect.ValueOf(a).IsNil())
	// nil值
	fmt.Println(&quot;nil IsValid:&quot;, reflect.ValueOf(nil).IsValid())
	// 实例化一个匿名结构体
	b := struct{}{}
	// 尝试从结构体中查找&quot;abc&quot;字段
	fmt.Println(&quot;不存在的结构体成员:&quot;, reflect.ValueOf(b).FieldByName(&quot;abc&quot;).IsValid())
	// 尝试从结构体中查找&quot;abc&quot;方法
	fmt.Println(&quot;不存在的结构体方法:&quot;, reflect.ValueOf(b).MethodByName(&quot;abc&quot;).IsValid())
	// map
	c := map[string]int{}
	// 尝试从map中查找一个不存在的键
	fmt.Println(&quot;map中不存在的键：&quot;, reflect.ValueOf(c).MapIndex(reflect.ValueOf(&quot;娜扎&quot;)).IsValid())
}
</code></pre>

<h3 id="结构体反射">结构体反射</h3>

<h4 id="与结构体相关的方法">与结构体相关的方法</h4>

<p>任意值通过<code>reflect.TypeOf()</code>获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（<code>reflect.Type</code>）的<code>NumField()</code>和<code>Field()</code>方法获得结构体成员的详细信息。</p>

<p><code>reflect.Type</code>中与获取结构体成员相关的的方法如下表所示。</p>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">Field(i int) StructField</td>
<td align="center">根据索引，返回索引对应的结构体字段的信息。</td>
</tr>

<tr>
<td align="center">NumField() int</td>
<td align="center">返回结构体成员字段数量。</td>
</tr>

<tr>
<td align="center">FieldByName(name string) (StructField, bool)</td>
<td align="center">根据给定字符串返回字符串对应的结构体字段的信息。</td>
</tr>

<tr>
<td align="center">FieldByIndex(index []int) StructField</td>
<td align="center">多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。</td>
</tr>

<tr>
<td align="center">FieldByNameFunc(match func(string) bool) (StructField,bool)</td>
<td align="center">根据传入的匹配函数匹配需要的字段。</td>
</tr>

<tr>
<td align="center">NumMethod() int</td>
<td align="center">返回该类型的方法集中方法的数目</td>
</tr>

<tr>
<td align="center">Method(int) Method</td>
<td align="center">返回该类型方法集中的第i个方法</td>
</tr>

<tr>
<td align="center">MethodByName(string)(Method, bool)</td>
<td align="center">根据方法名返回该类型方法集中的方法</td>
</tr>
</tbody>
</table>

<h4 id="structfield类型">StructField类型</h4>

<p><code>StructField</code>类型用来描述结构体中的一个字段的信息。</p>

<p><code>StructField</code>的定义如下：</p>

<pre><code class="language-go">type StructField struct {
    // Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。
    // 参见http://golang.org/ref/spec#Uniqueness_of_identifiers
    Name    string
    PkgPath string
    Type      Type      // 字段的类型
    Tag       StructTag // 字段的标签
    Offset    uintptr   // 字段在结构体中的字节偏移量
    Index     []int     // 用于Type.FieldByIndex时的索引切片
    Anonymous bool      // 是否匿名字段
}
</code></pre>

<h4 id="结构体反射示例">结构体反射示例</h4>

<p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</p>

<pre><code class="language-go">type student struct {
	Name  string `json:&quot;name&quot;`
	Score int    `json:&quot;score&quot;`
}

func main() {
	stu1 := student{
		Name:  &quot;小王子&quot;,
		Score: 90,
	}

	t := reflect.TypeOf(stu1)
	fmt.Println(t.Name(), t.Kind()) // student struct
	// 通过for循环遍历结构体的所有字段信息
	for i := 0; i &lt; t.NumField(); i++ {
		field := t.Field(i)
		fmt.Printf(&quot;name:%s index:%d type:%v json tag:%v\n&quot;, field.Name, field.Index, field.Type, field.Tag.Get(&quot;json&quot;))
	}

	// 通过字段名获取指定结构体字段信息
	if scoreField, ok := t.FieldByName(&quot;Score&quot;); ok {
		fmt.Printf(&quot;name:%s index:%d type:%v json tag:%v\n&quot;, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(&quot;json&quot;))
	}
}
</code></pre>

<p>接下来编写一个函数<code>printMethod(s interface{})</code>来遍历打印s包含的方法。</p>

<pre><code class="language-go">// 给student添加两个方法 Study和Sleep(注意首字母大写)
func (s student) Study() string {
	msg := &quot;好好学习，天天向上。&quot;
	fmt.Println(msg)
	return msg
}

func (s student) Sleep() string {
	msg := &quot;好好睡觉，快快长大。&quot;
	fmt.Println(msg)
	return msg
}

func printMethod(x interface{}) {
	t := reflect.TypeOf(x)
	v := reflect.ValueOf(x)

	fmt.Println(t.NumMethod())
	for i := 0; i &lt; v.NumMethod(); i++ {
		methodType := v.Method(i).Type()
		fmt.Printf(&quot;method name:%s\n&quot;, t.Method(i).Name)
		fmt.Printf(&quot;method:%s\n&quot;, methodType)
		// 通过反射调用方法传递的参数必须是 []reflect.Value 类型
		var args = []reflect.Value{}
		v.Method(i).Call(args)
	}
}
</code></pre>

<h3 id="反射是把双刃剑">反射是把双刃剑</h3>

<p>反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码。但是反射不应该被滥用，原因有以下三个。</p>

<ol>
<li>基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。</li>
<li>大量使用反射的代码通常难以理解。</li>
<li>反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。</li>
</ol>

<h3 id="练习题-10">练习题</h3>

<ol>
<li>编写代码利用反射实现一个ini文件的解析器程序。</li>
</ol>

<h2 id="处理并发错误">处理并发错误</h2>

<p>我们可以在Go语言中十分便捷地开启goroutine去并发地执行任务，但是如何有效的处理并发过程中的错误则是一个很棘手的问题，本文介绍了一些处理并发错误的方法。</p>

<h3 id="recover-goroutine中的panic">recover goroutine中的panic</h3>

<p>我们知道可以在代码中使用 recover 来会恢复程序中意想不到的 panic，而 panic 只会触发当前 goroutine 中的 defer 操作。</p>

<p>例如在下面的示例代码中，无法在 main 函数中 recover 另一个goroutine中引发的 panic。</p>

<pre><code class="language-go">func f1() {
	defer func() {
		if e := recover(); e != nil {
			fmt.Printf(&quot;recover panic:%v\n&quot;, e)
		}
	}()
	// 开启一个goroutine执行任务
	go func() {
		fmt.Println(&quot;in goroutine....&quot;)
		// 只能触发当前goroutine中的defer
		panic(&quot;panic in goroutine&quot;)
	}()

	time.Sleep(time.Second)
	fmt.Println(&quot;exit&quot;)
}
</code></pre>

<p>执行上面的 f1 函数会得到如下结果：</p>

<pre><code class="language-bash">in goroutine....
panic: panic in goroutine

goroutine 6 [running]:
main.f1.func2()
        /Users/liwenzhou/workspace/github/the-road-to-learn-golang/ch12/goroutine_recover.go:20 +0x65
created by main.f1
        /Users/liwenzhou/workspace/github/the-road-to-learn-golang/ch12/goroutine_recover.go:17 +0x48

Process finished with exit code 2
</code></pre>

<p>从输出结果可以看到程序并没有正常退出，而是由于 panic 异常退出了（exit code 2）。</p>

<p>正如上面示例演示的那样，在启用 goroutine 去执行任务的场景下，如果想要 recover goroutine中可能出现的 panic 就需要在 goroutine 中使用 recover。就像下面的 f2 函数那样。</p>

<pre><code class="language-go">func f2() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Printf(&quot;recover outer panic:%v\n&quot;, r)
		}
	}()
	// 开启一个goroutine执行任务
	go func() {
		defer func() {
			if r := recover(); r != nil {
				fmt.Printf(&quot;recover inner panic:%v\n&quot;, r)
			}
		}()
		fmt.Println(&quot;in goroutine....&quot;)
		// 只能触发当前goroutine中的defer
		panic(&quot;panic in goroutine&quot;)
	}()

	time.Sleep(time.Second)
	fmt.Println(&quot;exit&quot;)
}
</code></pre>

<p>执行 f2 函数会得到如下输出结果。</p>

<pre><code class="language-go">in goroutine....
recover inner panic:panic in goroutine
exit
</code></pre>

<p>程序中的 panic 被 recover 成功捕获，程序最终正常退出。</p>

<h3 id="errgroup">errgroup</h3>

<p>在以往演示的并发示例中，我们通常像下面的示例代码那样在 go 关键字后，调用一个函数或匿名函数。</p>

<pre><code class="language-go">go func(){
  // ...
}

go foo()
</code></pre>

<p>在之前讲解并发的代码示例中我们默认被并发的那些函数都不会返回错误，但真实的情况往往是事与愿违。</p>

<p>当我们想要将一个任务拆分成多个子任务交给多个 goroutine 去运行，这时我们该如何获取到子任务可能返回的错误呢？</p>

<p>假设我们有多个网址需要并发去获取它们的内容，这时候我们会写出类似下面的代码。</p>

<pre><code class="language-go">// fetchUrlDemo 并发获取url内容
func fetchUrlDemo() {
	wg := sync.WaitGroup{}
	var urls = []string{
		&quot;http://pkg.go.dev&quot;,
		&quot;http://www.liwenzhou.com&quot;,
		&quot;http://www.yixieqitawangzhi.com&quot;,
	}

	for _, url := range urls {
		wg.Add(1)
		go func(url string) {
			defer wg.Done()
			resp, err := http.Get(url)
			if err == nil {
				fmt.Printf(&quot;获取%s成功\n&quot;, url)
				resp.Body.Close()
			}
			return // 如何将错误返回呢？
		}(url)
	}
	wg.Wait()
	// 如何获取goroutine中可能出现的错误呢？
}
</code></pre>

<p>执行上述<code>fetchUrlDemo</code>函数得到如下输出结果，由于 <a href="http://www.yixieqitawangzhi.com/">http://www.yixieqitawangzhi.com</a> 是我随意编造的一个并不真实存在的 url，所以对它的 HTTP 请求会返回错误。</p>

<pre><code class="language-bash">获取http://pkg.go.dev成功
获取http://www.liwenzhou.com成功
</code></pre>

<p>在上面的示例代码中，我们开启了 3 个 goroutine 分别去获取3个 url 的内容。类似这种将任务分为若干个子任务的场景会有很多，那么我们如何获取子任务中可能出现的错误呢？</p>

<p>errgroup 包就是为了解决这类问题而开发的，它能为处理公共任务的子任务而开启的一组 goroutine 提供同步、error 传播和基于context 的取消功能。</p>

<p>errgroup 包中定义了一个 Group 类型，它包含了若干个不可导出的字段。</p>

<pre><code class="language-go">type Group struct {
	cancel func()

	wg sync.WaitGroup

	errOnce sync.Once
	err     error
}
</code></pre>

<p>errgroup.Group 提供了<code>Go</code>和<code>Wait</code>两个方法。</p>

<pre><code class="language-go">func (g *Group) Go(f func() error)
</code></pre>

<ul>
<li>Go 函数会在新的 goroutine 中调用传入的函数f。</li>

<li><p>第一个返回非零错误的调用将取消该Group；下面的Wait方法会返回该错误</p>

<pre><code class="language-go">func (g *Group) Wait() error
</code></pre></li>

<li><p>Wait 会阻塞直至由上述 Go 方法调用的所有函数都返回，然后从它们返回第一个非nil的错误（如果有）。</p></li>
</ul>

<p>下面的示例代码演示了如何使用 errgroup 包来处理多个子任务 goroutine 中可能返回的 error。</p>

<pre><code class="language-go">// fetchUrlDemo2 使用errgroup并发获取url内容
func fetchUrlDemo2() error {
	g := new(errgroup.Group) // 创建等待组（类似sync.WaitGroup）
	var urls = []string{
		&quot;http://pkg.go.dev&quot;,
		&quot;http://www.liwenzhou.com&quot;,
		&quot;http://www.yixieqitawangzhi.com&quot;,
	}
	for _, url := range urls {
		url := url // 注意此处声明新的变量
		// 启动一个goroutine去获取url内容
		g.Go(func() error {
			resp, err := http.Get(url)
			if err == nil {
				fmt.Printf(&quot;获取%s成功\n&quot;, url)
				resp.Body.Close()
			}
			return err // 返回错误
		})
	}
	if err := g.Wait(); err != nil {
		// 处理可能出现的错误
		fmt.Println(err)
		return err
	}
	fmt.Println(&quot;所有goroutine均成功&quot;)
	return nil
}
</code></pre>

<p>执行上面的<code>fetchUrlDemo2</code>函数会得到如下输出结果。</p>

<pre><code class="language-bash">获取http://pkg.go.dev成功
获取http://www.liwenzhou.com成功
Get &quot;http://www.yixieqitawangzhi.com&quot;: dial tcp: lookup www.yixieqitawangzhi.com: no such host
</code></pre>

<p>当子任务的 goroutine 中对<code>http://www.yixieqitawangzhi.com</code> 发起 HTTP 请求时会返回一个错误，这个错误会由 errgroup.Group 的 Wait 方法返回。</p>

<p>通过阅读下方 errgroup.Group 的 Go 方法源码，我们可以看到当任意一个函数 f 返回错误时，会通过<code>g.errOnce.Do</code>只将第一个返回的错误记录，并且如果存在 cancel 方法则会调用cancel。</p>

<pre><code class="language-go">func (g *Group) Go(f func() error) {
	g.wg.Add(1)

	go func() {
		defer g.wg.Done()

		if err := f(); err != nil {
			g.errOnce.Do(func() {
				g.err = err
				if g.cancel != nil {
					g.cancel()
				}
			})
		}
	}()
}
</code></pre>

<p>那么如何创建带有 cancel 方法的 errgroup.Group 呢？</p>

<p>答案是通过 errorgroup 包提供的 WithContext 函数。</p>

<pre><code class="language-go">func WithContext(ctx context.Context) (*Group, context.Context)
</code></pre>

<p>WithContext 函数接收一个父 context，返回一个新的 Group 对象和一个关联的子 context 对象。下面的代码片段是一个官方文档给出的示例。</p>

<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;crypto/md5&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;log&quot;
	&quot;os&quot;
	&quot;path/filepath&quot;

	&quot;golang.org/x/sync/errgroup&quot;
)

// Pipeline demonstrates the use of a Group to implement a multi-stage
// pipeline: a version of the MD5All function with bounded parallelism from
// https://blog.golang.org/pipelines.
func main() {
	m, err := MD5All(context.Background(), &quot;.&quot;)
	if err != nil {
		log.Fatal(err)
	}

	for k, sum := range m {
		fmt.Printf(&quot;%s:\t%x\n&quot;, k, sum)
	}
}

type result struct {
	path string
	sum  [md5.Size]byte
}

// MD5All reads all the files in the file tree rooted at root and returns a map
// from file path to the MD5 sum of the file's contents. If the directory walk
// fails or any read operation fails, MD5All returns an error.
func MD5All(ctx context.Context, root string) (map[string][md5.Size]byte, error) {
	// ctx is canceled when g.Wait() returns. When this version of MD5All returns
	// - even in case of error! - we know that all of the goroutines have finished
	// and the memory they were using can be garbage-collected.
	g, ctx := errgroup.WithContext(ctx)
	paths := make(chan string)

	g.Go(func() error {

		return filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if !info.Mode().IsRegular() {
				return nil
			}
			select {
			case paths &lt;- path:
			case &lt;-ctx.Done():
				return ctx.Err()
			}
			return nil
		})
	})

	// Start a fixed number of goroutines to read and digest files.
	c := make(chan result)
	const numDigesters = 20
	for i := 0; i &lt; numDigesters; i++ {
		g.Go(func() error {
			for path := range paths {
				data, err := ioutil.ReadFile(path)
				if err != nil {
					return err
				}
				select {
				case c &lt;- result{path, md5.Sum(data)}:
				case &lt;-ctx.Done():
					return ctx.Err()
				}
			}
			return nil
		})
	}
	go func() {
		g.Wait()
		close(c)
	}()

	m := make(map[string][md5.Size]byte)
	for r := range c {
		m[r.path] = r.sum
	}
	// Check whether any of the goroutines failed. Since g is accumulating the
	// errors, we don't need to send them (or check for them) in the individual
	// results sent on the channel.
	if err := g.Wait(); err != nil {
		return nil, err
	}
	return m, nil
}
</code></pre>

<p>或者这里有另外一个示例。</p>

<pre><code class="language-go">func GetFriends(ctx context.Context, user int64) (map[string]*User, error) {
  g, ctx := errgroup.WithContext(ctx)
  friendIds := make(chan int64)

  // Produce
  g.Go(func() error {
     defer close(friendIds)
     for it := GetFriendIds(user); ; {
        if id, err := it.Next(ctx); err != nil {
           if err == io.EOF {
              return nil
           }
           return fmt.Errorf(&quot;GetFriendIds %d: %s&quot;, user, err)
        } else {
           select {
           case &lt;-ctx.Done():
              return ctx.Err()
           case friendIds &lt;- id:
           }
        }
     }
  })

  friends := make(chan *User)

  // Map
  workers := int32(nWorkers)
  for i := 0; i &lt; nWorkers; i++ {
     g.Go(func() error {
        defer func() {
           // Last one out closes shop
           if atomic.AddInt32(&amp;workers, -1) == 0 {
              close(friends)
           }
        }()

        for id := range friendIds {
           if friend, err := GetUserProfile(ctx, id); err != nil {
              return fmt.Errorf(&quot;GetUserProfile %d: %s&quot;, user, err)
           } else {
              select {
              case &lt;-ctx.Done():
                 return ctx.Err()
              case friends &lt;- friend:
              }
           }
        }
        return nil
     })
  }

  // Reduce
  ret := map[string]*User{}
  g.Go(func() error {
     for friend := range friends {
        ret[friend.Name] = friend
     }
     return nil
  })

  return ret, g.Wait()
}
</code></pre>

<p>可惜这两个示例不太好理解。。。</p>

<h2 id="go语言基础之网络编程">Go语言基础之网络编程</h2>

<p>现在我们几乎每天都在使用互联网，我们前面已经学习了如何编写Go语言程序，但是如何才能让我们的程序通过网络互相通信呢？本章我们就一起来学习下Go语言中的网络编程。 关于网络编程其实是一个很庞大的领域，本文只是简单的演示了如何使用net包进行TCP和UDP通信。如需了解更详细的网络编程请自行检索和阅读专业资料。</p>

<h3 id="互联网协议介绍">互联网协议介绍</h3>

<p>互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite），正是这一些协议规定了电脑如何连接和组网。我们理解了这些协议，就理解了互联网的原理。由于这些协议太过庞大和复杂，没有办法在这里一概而全，只能介绍一下我们日常开发中接触较多的几个协议。</p>

<h4 id="互联网分层模型">互联网分层模型</h4>

<p>互联网的逻辑实现被分为好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。用户接触到的只是最上面的那一层，根本不会感觉到下面的几层。要理解互联网就需要自下而上理解每一层的实现的功能。<img src="/resources/技术收录/golang/osi.png" alt="osi七层模型" />如上图所示，互联网按照不同的模型划分会有不用的分层，但是不论按照什么模型去划分，越往上的层越靠近用户，越往下的层越靠近硬件。在软件开发中我们使用最多的是上图中将互联网划分为五个分层的模型。</p>

<p>接下来我们一层一层的自底向上介绍一下每一层。</p>

<h4 id="物理层">物理层</h4>

<p>我们的电脑要与外界互联网通信，需要先把电脑连接网络，我们可以用双绞线、光纤、无线电波等方式。这就叫做”实物理层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</p>

<h4 id="数据链路层">数据链路层</h4>

<p>单纯的0和1没有任何意义，所以我们使用者会为其赋予一些特定的含义，规定解读电信号的方式：例如：多少个电信号算一组？每个信号位有何意义？这就是”数据链接层”的功能，它在”物理层”的上方，确定了物理层传输的0和1的分组方式及代表的意义。早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</p>

<p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。其中”标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。”标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p>

<p>那么，发送者和接受者是如何标识呢？以太网规定，连入网络的所有设备都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p>

<p>我们会通过ARP协议来获取接受方的MAC地址，有了MAC地址之后，如何把数据准确的发送给接收方呢？其实这里以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机都发送，让每台计算机读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p>

<h4 id="网络层">网络层</h4>

<p>按照以太网协议的规则我们可以依靠MAC地址来向外发送数据。理论上依靠MAC地址，你电脑的网卡就可以找到身在世界另一个角落的某台电脑的网卡了，但是这种做法有一个重大缺陷就是以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且发送的数据只能局限在发送者所在的子网络。也就是说如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理且必要的，因为如果互联网上每一台计算机都会收到互联网上收发的所有数据包，那是不现实的。</p>

<p>因此，必须找到一种方法区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</p>

<p>“网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是网络管理员分配的。网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p>

<p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。目前，广泛采用的是IP协议第四版，简称IPv4。IPv4这个版本规定，网络地址由32个二进制位组成，我们通常习惯用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p>

<p>根据IP协议发送的数据，就叫做IP数据包。IP数据包也分为”标头”和”数据”两个部分：”标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65535字节。</p>

<h4 id="传输层">传输层</h4>

<p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。但问题是同一台主机上会有许多程序都需要用网络收发数据，比如QQ和浏览器这两个程序都需要连接互联网并收发数据，我们如何区分某个数据包到底是归哪个程序的呢？也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>

<p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。有了IP和端口我们就能实现唯一确定互联网上一个程序，进而实现网络间的程序通信。</p>

<p>我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。UDP数据包，也是由”标头”和”数据”两部分组成：”标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p>

<p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP协议就诞生了。TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p>

<h4 id="应用层">应用层</h4>

<p>应用程序收到”传输层”的数据，接下来就要对数据进行解包。由于互联网是开放架构，数据来源五花八门，必须事先规定好通信的数据格式，否则接收方根本无法获得真正发送的数据内容。”应用层”的作用就是规定应用程序使用的数据格式，例如我们TCP协议之上常见的Email、HTTP、FTP等协议，这些协议就组成了互联网协议的应用层。</p>

<p>如下图所示，发送方的HTTP数据经过互联网的传输过程中会依次添加各层协议的标头信息，接收方收到数据包之后再依次根据协议解包得到数据。</p>

<p><img src="/resources/技术收录/golang/httptcpip.png" alt="HTTP数据传输图解" /></p>

<h3 id="socket编程">socket编程</h3>

<p>Socket是BSD UNIX的进程通信机制，通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。Socket可以理解为TCP/IP网络的API，它定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。电脑上运行的应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</p>

<h4 id="socket图解">socket图解</h4>

<p><code>Socket</code>是应用层与TCP/IP协议族通信的中间软件抽象层。在设计模式中，<code>Socket</code>其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在<code>Socket</code>后面，对用户来说只需要调用Socket规定的相关函数，让<code>Socket</code>去组织符合指定的协议数据然后进行通信。</p>

<p><img src="/resources/技术收录/golang/socket.png" alt="socket图解" /></p>

<h3 id="go语言实现tcp通信">Go语言实现TCP通信</h3>

<h4 id="tcp协议">TCP协议</h4>

<p>TCP/IP(Transmission Control Protocol/Internet Protocol) 即传输控制协议/网间协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议，数据像水流一样传输，会存在黏包问题。</p>

<h4 id="tcp服务端">TCP服务端</h4>

<p>一个TCP服务端可以同时连接很多个客户端，例如世界各地的用户使用自己电脑上的浏览器访问淘宝网。因为Go语言中创建多个goroutine实现并发非常方便和高效，所以我们可以每建立一次链接就创建一个goroutine去处理。</p>

<p>TCP服务端程序的处理流程：</p>

<ol>
<li>监听端口</li>
<li>接收客户端请求建立链接</li>
<li>创建goroutine处理链接。</li>
</ol>

<p>我们使用Go语言的net包实现的TCP服务端代码如下：</p>

<pre><code class="language-go">// tcp/server/main.go

// TCP server端

// 处理函数
func process(conn net.Conn) {
	defer conn.Close() // 关闭连接
	for {
		reader := bufio.NewReader(conn)
		var buf [128]byte
		n, err := reader.Read(buf[:]) // 读取数据
		if err != nil {
			fmt.Println(&quot;read from client failed, err:&quot;, err)
			break
		}
		recvStr := string(buf[:n])
		fmt.Println(&quot;收到client端发来的数据：&quot;, recvStr)
		conn.Write([]byte(recvStr)) // 发送数据
	}
}

func main() {
	listen, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:20000&quot;)
	if err != nil {
		fmt.Println(&quot;listen failed, err:&quot;, err)
		return
	}
	for {
		conn, err := listen.Accept() // 建立连接
		if err != nil {
			fmt.Println(&quot;accept failed, err:&quot;, err)
			continue
		}
		go process(conn) // 启动一个goroutine处理连接
	}
}
</code></pre>

<p>将上面的代码保存之后编译成<code>server</code>或<code>server.exe</code>可执行文件。</p>

<h4 id="tcp客户端">TCP客户端</h4>

<p>一个TCP客户端进行TCP通信的流程如下：</p>

<ol>
<li>建立与服务端的链接</li>
<li>进行数据收发</li>
<li>关闭链接</li>
</ol>

<p>使用Go语言的net包实现的TCP客户端代码如下：</p>

<pre><code class="language-go">// tcp/client/main.go

// 客户端
func main() {
	conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:20000&quot;)
	if err != nil {
		fmt.Println(&quot;err :&quot;, err)
		return
	}
	defer conn.Close() // 关闭连接
	inputReader := bufio.NewReader(os.Stdin)
	for {
		input, _ := inputReader.ReadString('\n') // 读取用户输入
		inputInfo := strings.Trim(input, &quot;\r\n&quot;)
		if strings.ToUpper(inputInfo) == &quot;Q&quot; { // 如果输入q就退出
			return
		}
		_, err = conn.Write([]byte(inputInfo)) // 发送数据
		if err != nil {
			return
		}
		buf := [512]byte{}
		n, err := conn.Read(buf[:])
		if err != nil {
			fmt.Println(&quot;recv failed, err:&quot;, err)
			return
		}
		fmt.Println(string(buf[:n]))
	}
}
</code></pre>

<p>将上面的代码编译成<code>client</code>或<code>client.exe</code>可执行文件，先启动server端再启动client端，在client端输入任意内容回车之后就能够在server端看到client端发送的数据，从而实现TCP通信。</p>

<h3 id="tcp黏包">TCP黏包</h3>

<h4 id="黏包示例">黏包示例</h4>

<p>服务端代码如下：</p>

<pre><code class="language-go">// socket_stick/server/main.go

func process(conn net.Conn) {
	defer conn.Close()
	reader := bufio.NewReader(conn)
	var buf [1024]byte
	for {
		n, err := reader.Read(buf[:])
		if err == io.EOF {
			break
		}
		if err != nil {
			fmt.Println(&quot;read from client failed, err:&quot;, err)
			break
		}
		recvStr := string(buf[:n])
		fmt.Println(&quot;收到client发来的数据：&quot;, recvStr)
	}
}

func main() {

	listen, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:30000&quot;)
	if err != nil {
		fmt.Println(&quot;listen failed, err:&quot;, err)
		return
	}
	defer listen.Close()
	for {
		conn, err := listen.Accept()
		if err != nil {
			fmt.Println(&quot;accept failed, err:&quot;, err)
			continue
		}
		go process(conn)
	}
}
</code></pre>

<p>客户端代码如下：</p>

<pre><code class="language-go">// socket_stick/client/main.go

func main() {
	conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:30000&quot;)
	if err != nil {
		fmt.Println(&quot;dial failed, err&quot;, err)
		return
	}
	defer conn.Close()
	for i := 0; i &lt; 20; i++ {
		msg := `Hello, Hello. How are you?`
		conn.Write([]byte(msg))
	}
}
</code></pre>

<p>将上面的代码保存后，分别编译。先启动服务端再启动客户端，可以看到服务端输出结果如下：</p>

<pre><code class="language-bash">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?
收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?
收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?
收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?
收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?
</code></pre>

<p>客户端分10次发送的数据，在服务端并没有成功的输出10次，而是多条数据“粘”到了一起。</p>

<h4 id="为什么会出现粘包">为什么会出现粘包</h4>

<p>主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。</p>

<p>“粘包”可发生在发送端也可发生在接收端：</p>

<ol>
<li>由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。</li>
<li>接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。</li>
</ol>

<h4 id="解决办法">解决办法</h4>

<p>出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。</p>

<p>封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。</p>

<p>我们可以自己定义一个协议，比如数据包的前4个字节为包头，里面存储的是发送的数据的长度。</p>

<pre><code class="language-go">// socket_stick/proto/proto.go
package proto

import (
	&quot;bufio&quot;
	&quot;bytes&quot;
	&quot;encoding/binary&quot;
)

// Encode 将消息编码
func Encode(message string) ([]byte, error) {
	// 读取消息的长度，转换成int32类型（占4个字节）
	var length = int32(len(message))
	var pkg = new(bytes.Buffer)
	// 写入消息头
	err := binary.Write(pkg, binary.LittleEndian, length)
	if err != nil {
		return nil, err
	}
	// 写入消息实体
	err = binary.Write(pkg, binary.LittleEndian, []byte(message))
	if err != nil {
		return nil, err
	}
	return pkg.Bytes(), nil
}

// Decode 解码消息
func Decode(reader *bufio.Reader) (string, error) {
	// 读取消息的长度
	lengthByte, _ := reader.Peek(4) // 读取前4个字节的数据
	lengthBuff := bytes.NewBuffer(lengthByte)
	var length int32
	err := binary.Read(lengthBuff, binary.LittleEndian, &amp;length)
	if err != nil {
		return &quot;&quot;, err
	}
	// Buffered返回缓冲中现有的可读取的字节数。
	if int32(reader.Buffered()) &lt; length+4 {
		return &quot;&quot;, err
	}

	// 读取真正的消息数据
	pack := make([]byte, int(4+length))
	_, err = reader.Read(pack)
	if err != nil {
		return &quot;&quot;, err
	}
	return string(pack[4:]), nil
}
</code></pre>

<p>接下来在服务端和客户端分别使用上面定义的<code>proto</code>包的<code>Decode</code>和<code>Encode</code>函数处理数据。</p>

<p>服务端代码如下：</p>

<pre><code class="language-go">// socket_stick/server2/main.go

func process(conn net.Conn) {
	defer conn.Close()
	reader := bufio.NewReader(conn)
	for {
		msg, err := proto.Decode(reader)
		if err == io.EOF {
			return
		}
		if err != nil {
			fmt.Println(&quot;decode msg failed, err:&quot;, err)
			return
		}
		fmt.Println(&quot;收到client发来的数据：&quot;, msg)
	}
}

func main() {

	listen, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:30000&quot;)
	if err != nil {
		fmt.Println(&quot;listen failed, err:&quot;, err)
		return
	}
	defer listen.Close()
	for {
		conn, err := listen.Accept()
		if err != nil {
			fmt.Println(&quot;accept failed, err:&quot;, err)
			continue
		}
		go process(conn)
	}
}
</code></pre>

<p>客户端代码如下：</p>

<pre><code class="language-go">// socket_stick/client2/main.go

func main() {
	conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:30000&quot;)
	if err != nil {
		fmt.Println(&quot;dial failed, err&quot;, err)
		return
	}
	defer conn.Close()
	for i := 0; i &lt; 20; i++ {
		msg := `Hello, Hello. How are you?`
		data, err := proto.Encode(msg)
		if err != nil {
			fmt.Println(&quot;encode msg failed, err:&quot;, err)
			return
		}
		conn.Write(data)
	}
}
</code></pre>

<h3 id="go语言实现udp通信">Go语言实现UDP通信</h3>

<h4 id="udp协议">UDP协议</h4>

<p>UDP协议（User Datagram Protocol）中文名称是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联）参考模型中一种<strong>无连接</strong>的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域。</p>

<h4 id="udp服务端">UDP服务端</h4>

<p>使用Go语言的<code>net</code>包实现的UDP服务端代码如下：</p>

<pre><code class="language-go">// UDP/server/main.go

// UDP server端
func main() {
	listen, err := net.ListenUDP(&quot;udp&quot;, &amp;net.UDPAddr{
		IP:   net.IPv4(0, 0, 0, 0),
		Port: 30000,
	})
	if err != nil {
		fmt.Println(&quot;listen failed, err:&quot;, err)
		return
	}
	defer listen.Close()
	for {
		var data [1024]byte
		n, addr, err := listen.ReadFromUDP(data[:]) // 接收数据
		if err != nil {
			fmt.Println(&quot;read udp failed, err:&quot;, err)
			continue
		}
		fmt.Printf(&quot;data:%v addr:%v count:%v\n&quot;, string(data[:n]), addr, n)
		_, err = listen.WriteToUDP(data[:n], addr) // 发送数据
		if err != nil {
			fmt.Println(&quot;write to udp failed, err:&quot;, err)
			continue
		}
	}
}
</code></pre>

<h4 id="udp客户端">UDP客户端</h4>

<p>使用Go语言的<code>net</code>包实现的UDP客户端代码如下：</p>

<pre><code class="language-go">// UDP 客户端
func main() {
	socket, err := net.DialUDP(&quot;udp&quot;, nil, &amp;net.UDPAddr{
		IP:   net.IPv4(0, 0, 0, 0),
		Port: 30000,
	})
	if err != nil {
		fmt.Println(&quot;连接服务端失败，err:&quot;, err)
		return
	}
	defer socket.Close()
	sendData := []byte(&quot;Hello server&quot;)
	_, err = socket.Write(sendData) // 发送数据
	if err != nil {
		fmt.Println(&quot;发送数据失败，err:&quot;, err)
		return
	}
	data := make([]byte, 4096)
	n, remoteAddr, err := socket.ReadFromUDP(data) // 接收数据
	if err != nil {
		fmt.Println(&quot;接收数据失败，err:&quot;, err)
		return
	}
	fmt.Printf(&quot;recv:%v addr:%v count:%v\n&quot;, string(data[:n]), remoteAddr, n)
}
</code></pre>

<hr />

<h2 id="go语言基础之单元测试">Go语言基础之单元测试</h2>

<p>不写测试的开发不是好程序员。我个人非常崇尚TDD（Test Driven Development）的，然而可惜的是国内的程序员都不太关注测试这一部分。 这篇文章主要介绍下在Go语言中如何做单元测试和基准测试。</p>

<h3 id="go-test工具">go test工具</h3>

<p>Go语言中的测试依赖<code>go test</code>命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。</p>

<p>go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以<code>_test.go</code>为后缀名的源代码文件都是<code>go test</code>测试的一部分，不会被<code>go build</code>编译到最终的可执行文件中。</p>

<p>在<code>*_test.go</code>文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p>

<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">格式</th>
<th align="center">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">测试函数</td>
<td align="center">函数名前缀为Test</td>
<td align="center">测试程序的一些逻辑行为是否正确</td>
</tr>

<tr>
<td align="center">基准函数</td>
<td align="center">函数名前缀为Benchmark</td>
<td align="center">测试函数的性能</td>
</tr>

<tr>
<td align="center">示例函数</td>
<td align="center">函数名前缀为Example</td>
<td align="center">为文档提供示例文档</td>
</tr>
</tbody>
</table>

<p><code>go test</code>命令会遍历所有的<code>*_test.go</code>文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p>

<h3 id="测试函数">测试函数</h3>

<h4 id="测试函数的格式">测试函数的格式</h4>

<p>每个测试函数必须导入<code>testing</code>包，测试函数的基本格式（签名）如下：</p>

<pre><code class="language-go">func TestName(t *testing.T){
    // ...
}
</code></pre>

<p>测试函数的名字必须以<code>Test</code>开头，可选的后缀名必须以大写字母开头，举几个例子：</p>

<pre><code class="language-go">func TestAdd(t *testing.T){ ... }
func TestSum(t *testing.T){ ... }
func TestLog(t *testing.T){ ... }
</code></pre>

<p>其中参数<code>t</code>用于报告测试失败和附加的日志信息。 <code>testing.T</code>的拥有的方法如下：</p>

<pre><code class="language-go">func (c *T) Error(args ...interface{})
func (c *T) Errorf(format string, args ...interface{})
func (c *T) Fail()
func (c *T) FailNow()
func (c *T) Failed() bool
func (c *T) Fatal(args ...interface{})
func (c *T) Fatalf(format string, args ...interface{})
func (c *T) Log(args ...interface{})
func (c *T) Logf(format string, args ...interface{})
func (c *T) Name() string
func (t *T) Parallel()
func (t *T) Run(name string, f func(t *T)) bool
func (c *T) Skip(args ...interface{})
func (c *T) SkipNow()
func (c *T) Skipf(format string, args ...interface{})
func (c *T) Skipped() bool
</code></pre>

<h4 id="测试函数示例">测试函数示例</h4>

<p>就像细胞是构成我们身体的基本单位，一个软件程序也是由很多单元组件构成的。单元组件可以是函数、结构体、方法和最终用户可能依赖的任意东西。总之我们需要确保这些组件是能够正常运行的。单元测试是一些利用各种方法测试单元组件的程序，它会将结果与预期输出进行比较。</p>

<p>接下来，我们定义一个<code>split</code>的包，包中定义了一个<code>Split</code>函数，具体实现如下：</p>

<pre><code class="language-go">// split/split.go

package split

import &quot;strings&quot;

// split package with a single split function.

// Split slices s into all substrings separated by sep and
// returns a slice of the substrings between those separators.
func Split(s, sep string) (result []string) {
	i := strings.Index(s, sep)

	for i &gt; -1 {
		result = append(result, s[:i])
		s = s[i+1:]
		i = strings.Index(s, sep)
	}
	result = append(result, s)
	return
}
</code></pre>

<p>在当前目录下，我们创建一个<code>split_test.go</code>的测试文件，并定义一个测试函数如下：</p>

<pre><code class="language-go">// split/split_test.go

package split

import (
	&quot;reflect&quot;
	&quot;testing&quot;
)

func TestSplit(t *testing.T) { // 测试函数名必须以Test开头，必须接收一个*testing.T类型参数
	got := Split(&quot;a🅱c&quot;, &quot;:&quot;)         // 程序输出的结果
	want := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}    // 期望的结果
	if !reflect.DeepEqual(want, got) { // 因为slice不能比较直接，借助反射包中的方法比较
		t.Errorf(&quot;expected:%v, got:%v&quot;, want, got) // 测试失败输出错误提示
	}
}
</code></pre>

<p>此时<code>split</code>这个包中的文件如下：</p>

<pre><code class="language-bash">split $ ls -l
total 16
-rw-r--r--  1 liwenzhou  staff  408  4 29 15:50 split.go
-rw-r--r--  1 liwenzhou  staff  466  4 29 16:04 split_test.go
</code></pre>

<p>在<code>split</code>包路径下，执行<code>go test</code>命令，可以看到输出结果如下：</p>

<pre><code class="language-bash">split $ go test
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s
</code></pre>

<p>一个测试用例有点单薄，我们再编写一个测试使用多个字符切割字符串的例子，在<code>split_test.go</code>中添加如下测试函数：</p>

<pre><code class="language-go">func TestMoreSplit(t *testing.T) {
	got := Split(&quot;abcd&quot;, &quot;bc&quot;)
	want := []string{&quot;a&quot;, &quot;d&quot;}
	if !reflect.DeepEqual(want, got) {
		t.Errorf(&quot;expected:%v, got:%v&quot;, want, got)
	}
}
</code></pre>

<p>再次运行<code>go test</code>命令，输出结果如下：</p>

<pre><code class="language-bash">split $ go test
--- FAIL: TestMultiSplit (0.00s)
    split_test.go:20: expected:[a d], got:[a cd]
FAIL
exit status 1
FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s
</code></pre>

<p>这一次，我们的测试失败了。我们可以为<code>go test</code>命令添加<code>-v</code>参数，查看测试函数名称和运行时间：</p>

<pre><code class="language-bash">split $ go test -v
=== RUN   TestSplit
--- PASS: TestSplit (0.00s)
=== RUN   TestMoreSplit
--- FAIL: TestMoreSplit (0.00s)
    split_test.go:21: expected:[a d], got:[a cd]
FAIL
exit status 1
FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s
</code></pre>

<p>这一次我们能清楚的看到是<code>TestMoreSplit</code>这个测试没有成功。 还可以在<code>go test</code>命令后添加<code>-run</code>参数，它对应一个正则表达式，只有函数名匹配上的测试函数才会被<code>go test</code>命令执行。</p>

<pre><code class="language-bash">split $ go test -v -run=&quot;More&quot;
=== RUN   TestMoreSplit
--- FAIL: TestMoreSplit (0.00s)
    split_test.go:21: expected:[a d], got:[a cd]
FAIL
exit status 1
FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s
</code></pre>

<p>现在我们回过头来解决我们程序中的问题。很显然我们最初的<code>split</code>函数并没有考虑到sep为多个字符的情况，我们来修复下这个Bug：</p>

<pre><code class="language-go">package split

import &quot;strings&quot;

// split package with a single split function.

// Split slices s into all substrings separated by sep and
// returns a slice of the substrings between those separators.
func Split(s, sep string) (result []string) {
	i := strings.Index(s, sep)

	for i &gt; -1 {
		result = append(result, s[:i])
		s = s[i+len(sep):] // 这里使用len(sep)获取sep的长度
		i = strings.Index(s, sep)
	}
	result = append(result, s)
	return
}
</code></pre>

<p>这一次我们再来测试一下，我们的程序。注意，当我们修改了我们的代码之后不要仅仅执行那些失败的测试函数，我们应该完整的运行所有的测试，保证不会因为修改代码而引入了新的问题。</p>

<pre><code class="language-bash">split $ go test -v
=== RUN   TestSplit
--- PASS: TestSplit (0.00s)
=== RUN   TestMoreSplit
--- PASS: TestMoreSplit (0.00s)
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s
</code></pre>

<p>这一次我们的测试都通过了。</p>

<h4 id="测试组">测试组</h4>

<p>我们现在还想要测试一下<code>split</code>函数对中文字符串的支持，这个时候我们可以再编写一个<code>TestChineseSplit</code>测试函数，但是我们也可以使用如下更友好的一种方式来添加更多的测试用例。</p>

<pre><code class="language-go">func TestSplit(t *testing.T) {
   // 定义一个测试用例类型
	type test struct {
		input string
		sep   string
		want  []string
	}
	// 定义一个存储测试用例的切片
	tests := []test{
		{input: &quot;a🅱c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},
		{input: &quot;a🅱c&quot;, sep: &quot;,&quot;, want: []string{&quot;a🅱c&quot;}},
		{input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},
		{input: &quot;沙河有沙又有河&quot;, sep: &quot;沙&quot;, want: []string{&quot;河有&quot;, &quot;又有河&quot;}},
	}
	// 遍历切片，逐一执行测试用例
	for _, tc := range tests {
		got := Split(tc.input, tc.sep)
		if !reflect.DeepEqual(got, tc.want) {
			t.Errorf(&quot;expected:%v, got:%v&quot;, tc.want, got)
		}
	}
}
</code></pre>

<p>我们通过上面的代码把多个测试用例合到一起，再次执行<code>go test</code>命令。</p>

<pre><code class="language-bash">split $ go test -v
=== RUN   TestSplit
--- FAIL: TestSplit (0.00s)
    split_test.go:42: expected:[河有 又有河], got:[ 河有 又有河]
FAIL
exit status 1
FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s
</code></pre>

<p>我们的测试出现了问题，仔细看打印的测试失败提示信息：<code>expected:[河有 又有河], got:[ 河有 又有河]</code>，你会发现<code>[ 河有 又有河]</code>中有个不明显的空串，这种情况下十分推荐使用<code>%#v</code>的格式化方式。</p>

<p>我们修改下测试用例的格式化输出错误提示部分：</p>

<pre><code class="language-go">func TestSplit(t *testing.T) {
   ...
   
	for _, tc := range tests {
		got := Split(tc.input, tc.sep)
		if !reflect.DeepEqual(got, tc.want) {
			t.Errorf(&quot;expected:%#v, got:%#v&quot;, tc.want, got)
		}
	}
}
</code></pre>

<p>此时运行<code>go test</code>命令后就能看到比较明显的提示信息了：</p>

<pre><code class="language-bash">split $ go test -v
=== RUN   TestSplit
--- FAIL: TestSplit (0.00s)
    split_test.go:42: expected:[]string{&quot;河有&quot;, &quot;又有河&quot;}, got:[]string{&quot;&quot;, &quot;河有&quot;, &quot;又有河&quot;}
FAIL
exit status 1
FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s
</code></pre>

<h4 id="子测试">子测试</h4>

<p>看起来都挺不错的，但是如果测试用例比较多的时候，我们是没办法一眼看出来具体是哪个测试用例失败了。我们可能会想到下面的解决办法：</p>

<pre><code class="language-go">func TestSplit(t *testing.T) {
	type test struct { // 定义test结构体
		input string
		sep   string
		want  []string
	}
	tests := map[string]test{ // 测试用例使用map存储
		&quot;simple&quot;:      {input: &quot;a🅱c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},
		&quot;wrong sep&quot;:   {input: &quot;a🅱c&quot;, sep: &quot;,&quot;, want: []string{&quot;a🅱c&quot;}},
		&quot;more sep&quot;:    {input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},
		&quot;leading sep&quot;: {input: &quot;沙河有沙又有河&quot;, sep: &quot;沙&quot;, want: []string{&quot;河有&quot;, &quot;又有河&quot;}},
	}
	for name, tc := range tests {
		got := Split(tc.input, tc.sep)
		if !reflect.DeepEqual(got, tc.want) {
			t.Errorf(&quot;name:%s expected:%#v, got:%#v&quot;, name, tc.want, got) // 将测试用例的name格式化输出
		}
	}
}
</code></pre>

<p>上面的做法是能够解决问题的。同时Go1.7+中新增了子测试，我们可以按照如下方式使用<code>t.Run</code>执行子测试：</p>

<pre><code class="language-go">func TestSplit(t *testing.T) {
	type test struct { // 定义test结构体
		input string
		sep   string
		want  []string
	}
	tests := map[string]test{ // 测试用例使用map存储
		&quot;simple&quot;:      {input: &quot;a🅱c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},
		&quot;wrong sep&quot;:   {input: &quot;a🅱c&quot;, sep: &quot;,&quot;, want: []string{&quot;a🅱c&quot;}},
		&quot;more sep&quot;:    {input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},
		&quot;leading sep&quot;: {input: &quot;沙河有沙又有河&quot;, sep: &quot;沙&quot;, want: []string{&quot;河有&quot;, &quot;又有河&quot;}},
	}
	for name, tc := range tests {
		t.Run(name, func(t *testing.T) { // 使用t.Run()执行子测试
			got := Split(tc.input, tc.sep)
			if !reflect.DeepEqual(got, tc.want) {
				t.Errorf(&quot;expected:%#v, got:%#v&quot;, tc.want, got)
			}
		})
	}
}
</code></pre>

<p>此时我们再执行<code>go test</code>命令就能够看到更清晰的输出内容了：</p>

<pre><code class="language-bash">split $ go test -v
=== RUN   TestSplit
=== RUN   TestSplit/leading_sep
=== RUN   TestSplit/simple
=== RUN   TestSplit/wrong_sep
=== RUN   TestSplit/more_sep
--- FAIL: TestSplit (0.00s)
    --- FAIL: TestSplit/leading_sep (0.00s)
        split_test.go:83: expected:[]string{&quot;河有&quot;, &quot;又有河&quot;}, got:[]string{&quot;&quot;, &quot;河有&quot;, &quot;又有河&quot;}
    --- PASS: TestSplit/simple (0.00s)
    --- PASS: TestSplit/wrong_sep (0.00s)
    --- PASS: TestSplit/more_sep (0.00s)
FAIL
exit status 1
FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s
</code></pre>

<p>这个时候我们要把测试用例中的错误修改回来：</p>

<pre><code class="language-go">func TestSplit(t *testing.T) {
	...
	tests := map[string]test{ // 测试用例使用map存储
		&quot;simple&quot;:      {input: &quot;a🅱c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},
		&quot;wrong sep&quot;:   {input: &quot;a🅱c&quot;, sep: &quot;,&quot;, want: []string{&quot;a🅱c&quot;}},
		&quot;more sep&quot;:    {input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},
		&quot;leading sep&quot;: {input: &quot;沙河有沙又有河&quot;, sep: &quot;沙&quot;, want: []string{&quot;&quot;, &quot;河有&quot;, &quot;又有河&quot;}},
	}
	...
}
</code></pre>

<p>我们都知道可以通过<code>-run=RegExp</code>来指定运行的测试用例，还可以通过<code>/</code>来指定要运行的子测试用例，例如：<code>go test -v -run=Split/simple</code>只会运行<code>simple</code>对应的子测试用例。</p>

<h4 id="测试覆盖率">测试覆盖率</h4>

<p>测试覆盖率是你的代码被测试套件覆盖的百分比。通常我们使用的都是语句的覆盖率，也就是在测试中至少被运行一次的代码占总代码的比例。</p>

<p>Go提供内置功能来检查你的代码覆盖率。我们可以使用<code>go test -cover</code>来查看测试覆盖率。例如：</p>

<pre><code class="language-bash">split $ go test -cover
PASS
coverage: 100.0% of statements
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s
</code></pre>

<p>从上面的结果可以看到我们的测试用例覆盖了100%的代码。</p>

<p>Go还提供了一个额外的<code>-coverprofile</code>参数，用来将覆盖率相关的记录信息输出到一个文件。例如：</p>

<pre><code class="language-bash">split $ go test -cover -coverprofile=c.out
PASS
coverage: 100.0% of statements
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s
</code></pre>

<p>上面的命令会将覆盖率相关的信息输出到当前文件夹下面的<code>c.out</code>文件中，然后我们执行<code>go tool cover -html=c.out</code>，使用<code>cover</code>工具来处理生成的记录信息，该命令会打开本地的浏览器窗口生成一个HTML报告。<img src="/resources/技术收录/golang/cover.png" alt="Go test cover" />上图中每个用绿色标记的语句块表示被覆盖了，而红色的表示没有被覆盖。</p>

<h3 id="基准测试">基准测试</h3>

<h4 id="基准测试函数格式">基准测试函数格式</h4>

<p>基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下：</p>

<pre><code class="language-go">func BenchmarkName(b *testing.B){
    // ...
}
</code></pre>

<p>基准测试以<code>Benchmark</code>为前缀，需要一个<code>*testing.B</code>类型的参数b，基准测试必须要执行<code>b.N</code>次，这样的测试才有对照性，<code>b.N</code>的值是系统根据实际情况去调整的，从而保证测试的稳定性。 <code>testing.B</code>拥有的方法如下：</p>

<pre><code class="language-go">func (c *B) Error(args ...interface{})
func (c *B) Errorf(format string, args ...interface{})
func (c *B) Fail()
func (c *B) FailNow()
func (c *B) Failed() bool
func (c *B) Fatal(args ...interface{})
func (c *B) Fatalf(format string, args ...interface{})
func (c *B) Log(args ...interface{})
func (c *B) Logf(format string, args ...interface{})
func (c *B) Name() string
func (b *B) ReportAllocs()
func (b *B) ResetTimer()
func (b *B) Run(name string, f func(b *B)) bool
func (b *B) RunParallel(body func(*PB))
func (b *B) SetBytes(n int64)
func (b *B) SetParallelism(p int)
func (c *B) Skip(args ...interface{})
func (c *B) SkipNow()
func (c *B) Skipf(format string, args ...interface{})
func (c *B) Skipped() bool
func (b *B) StartTimer()
func (b *B) StopTimer()
</code></pre>

<h4 id="基准测试示例">基准测试示例</h4>

<p>我们为split包中的<code>Split</code>函数编写基准测试如下：</p>

<pre><code class="language-go">func BenchmarkSplit(b *testing.B) {
	for i := 0; i &lt; b.N; i++ {
		Split(&quot;沙河有沙又有河&quot;, &quot;沙&quot;)
	}
}
</code></pre>

<p>基准测试并不会默认执行，需要增加<code>-bench</code>参数，所以我们通过执行<code>go test -bench=Split</code>命令执行基准测试，输出结果如下：</p>

<pre><code class="language-bash">split $ go test -bench=Split
goos: darwin
goarch: amd64
pkg: github.com/Q1mi/studygo/code_demo/test_demo/split
BenchmarkSplit-8        10000000               203 ns/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       2.255s
</code></pre>

<p>其中<code>BenchmarkSplit-8</code>表示对Split函数进行基准测试，数字<code>8</code>表示<code>GOMAXPROCS</code>的值，这个对于并发基准测试很重要。<code>10000000</code>和<code>203ns/op</code>表示每次调用<code>Split</code>函数耗时<code>203ns</code>，这个结果是<code>10000000</code>次调用的平均值。</p>

<p>我们还可以为基准测试添加<code>-benchmem</code>参数，来获得内存分配的统计数据。</p>

<pre><code class="language-bash">split $ go test -bench=Split -benchmem
goos: darwin
goarch: amd64
pkg: github.com/Q1mi/studygo/code_demo/test_demo/split
BenchmarkSplit-8        10000000               215 ns/op             112 B/op          3 allocs/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       2.394s
</code></pre>

<p>其中，<code>112 B/op</code>表示每次操作内存分配了112字节，<code>3 allocs/op</code>则表示每次操作进行了3次内存分配。 我们将我们的<code>Split</code>函数优化如下：</p>

<pre><code class="language-go">func Split(s, sep string) (result []string) {
	result = make([]string, 0, strings.Count(s, sep)+1)
	i := strings.Index(s, sep)
	for i &gt; -1 {
		result = append(result, s[:i])
		s = s[i+len(sep):] // 这里使用len(sep)获取sep的长度
		i = strings.Index(s, sep)
	}
	result = append(result, s)
	return
}
</code></pre>

<p>这一次我们提前使用make函数将result初始化为一个容量足够大的切片，而不再像之前一样通过调用append函数来追加。我们来看一下这个改进会带来多大的性能提升：</p>

<pre><code class="language-bash">split $ go test -bench=Split -benchmem
goos: darwin
goarch: amd64
pkg: github.com/Q1mi/studygo/code_demo/test_demo/split
BenchmarkSplit-8        10000000               127 ns/op              48 B/op          1 allocs/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       1.423s
</code></pre>

<p>这个使用make函数提前分配内存的改动，减少了2/3的内存分配次数，并且减少了一半的内存分配。</p>

<h4 id="性能比较函数">性能比较函数</h4>

<p>上面的基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是发生在两个不同操作之间的相对耗时，比如同一个函数处理1000个元素的耗时与处理1万甚至100万个元素的耗时的差别是多少？再或者对于同一个任务究竟使用哪种算法性能最佳？我们通常需要对两个不同算法的实现使用相同的输入来进行基准比较测试。</p>

<p>性能比较函数通常是一个带有参数的函数，被多个不同的Benchmark函数传入不同的值来调用。举个例子如下：</p>

<pre><code class="language-go">func benchmark(b *testing.B, size int){/* ... */}
func Benchmark10(b *testing.B){ benchmark(b, 10) }
func Benchmark100(b *testing.B){ benchmark(b, 100) }
func Benchmark1000(b *testing.B){ benchmark(b, 1000) }
</code></pre>

<p>例如我们编写了一个计算斐波那契数列的函数如下：</p>

<pre><code class="language-go">// fib.go

// Fib 是一个计算第n个斐波那契数的函数
func Fib(n int) int {
	if n &lt; 2 {
		return n
	}
	return Fib(n-1) + Fib(n-2)
}
</code></pre>

<p>我们编写的性能比较函数如下：</p>

<pre><code class="language-go">// fib_test.go

func benchmarkFib(b *testing.B, n int) {
	for i := 0; i &lt; b.N; i++ {
		Fib(n)
	}
}

func BenchmarkFib1(b *testing.B)  { benchmarkFib(b, 1) }
func BenchmarkFib2(b *testing.B)  { benchmarkFib(b, 2) }
func BenchmarkFib3(b *testing.B)  { benchmarkFib(b, 3) }
func BenchmarkFib10(b *testing.B) { benchmarkFib(b, 10) }
func BenchmarkFib20(b *testing.B) { benchmarkFib(b, 20) }
func BenchmarkFib40(b *testing.B) { benchmarkFib(b, 40) }
</code></pre>

<p>运行基准测试：</p>

<pre><code class="language-bash">split $ go test -bench=.
goos: darwin
goarch: amd64
pkg: github.com/Q1mi/studygo/code_demo/test_demo/fib
BenchmarkFib1-8         1000000000               2.03 ns/op
BenchmarkFib2-8         300000000                5.39 ns/op
BenchmarkFib3-8         200000000                9.71 ns/op
BenchmarkFib10-8         5000000               325 ns/op
BenchmarkFib20-8           30000             42460 ns/op
BenchmarkFib40-8               2         638524980 ns/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/fib 12.944s
</code></pre>

<p>这里需要注意的是，默认情况下，每个基准测试至少运行1秒。如果在Benchmark函数返回时没有到1秒，则b.N的值会按1,2,5,10,20,50，…增加，并且函数再次运行。</p>

<p>最终的BenchmarkFib40只运行了两次，每次运行的平均值只有不到一秒。像这种情况下我们应该可以使用<code>-benchtime</code>标志增加最小基准时间，以产生更准确的结果。例如：</p>

<pre><code class="language-bash">split $ go test -bench=Fib40 -benchtime=20s
goos: darwin
goarch: amd64
pkg: github.com/Q1mi/studygo/code_demo/test_demo/fib
BenchmarkFib40-8              50         663205114 ns/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/fib 33.849s
</code></pre>

<p>这一次<code>BenchmarkFib40</code>函数运行了50次，结果就会更准确一些了。</p>

<p>使用性能比较函数做测试的时候一个容易犯的错误就是把<code>b.N</code>作为输入的大小，例如以下两个例子都是错误的示范：</p>

<pre><code class="language-go">// 错误示范1
func BenchmarkFibWrong(b *testing.B) {
	for n := 0; n &lt; b.N; n++ {
		Fib(n)
	}
}

// 错误示范2
func BenchmarkFibWrong2(b *testing.B) {
	Fib(b.N)
}
</code></pre>

<h4 id="重置时间">重置时间</h4>

<p><code>b.ResetTimer</code>之前的处理不会放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作。例如：</p>

<pre><code class="language-go">func BenchmarkSplit(b *testing.B) {
	time.Sleep(5 * time.Second) // 假设需要做一些耗时的无关操作
	b.ResetTimer()              // 重置计时器
	for i := 0; i &lt; b.N; i++ {
		Split(&quot;沙河有沙又有河&quot;, &quot;沙&quot;)
	}
}
</code></pre>

<h4 id="并行测试">并行测试</h4>

<p><code>func (b *B) RunParallel(body func(*PB))</code>会以并行的方式执行给定的基准测试。</p>

<p><code>RunParallel</code>会创建出多个<code>goroutine</code>，并将<code>b.N</code>分配给这些<code>goroutine</code>执行， 其中<code>goroutine</code>数量的默认值为<code>GOMAXPROCS</code>。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在<code>RunParallel</code>之前调用<code>SetParallelism</code> 。<code>RunParallel</code>通常会与<code>-cpu</code>标志一同使用。</p>

<pre><code class="language-go">func BenchmarkSplitParallel(b *testing.B) {
	// b.SetParallelism(1) // 设置使用的CPU数
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			Split(&quot;沙河有沙又有河&quot;, &quot;沙&quot;)
		}
	})
}
</code></pre>

<p>执行一下基准测试：</p>

<pre><code class="language-bash">split $ go test -bench=.
goos: darwin
goarch: amd64
pkg: github.com/Q1mi/studygo/code_demo/test_demo/split
BenchmarkSplit-8                10000000               131 ns/op
BenchmarkSplitParallel-8        50000000                36.1 ns/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       3.308s
</code></pre>

<p>还可以通过在测试命令后添加<code>-cpu</code>参数如<code>go test -bench=. -cpu 1</code>来指定使用的CPU数量。</p>

<h3 id="setup与teardown">Setup与TearDown</h3>

<p>测试程序有时需要在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）。</p>

<h4 id="testmain">TestMain</h4>

<p>通过在<code>*_test.go</code>文件中定义<code>TestMain</code>函数来可以在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）操作。</p>

<p>如果测试文件包含函数:<code>func TestMain(m *testing.M)</code>那么生成的测试会先调用 TestMain(m)，然后再运行具体测试。<code>TestMain</code>运行在主<code>goroutine</code>中, 可以在调用 <code>m.Run</code>前后做任何设置（setup）和拆卸（teardown）。退出测试的时候应该使用<code>m.Run</code>的返回值作为参数调用<code>os.Exit</code>。</p>

<p>一个使用<code>TestMain</code>来设置Setup和TearDown的示例如下：</p>

<pre><code class="language-go">func TestMain(m *testing.M) {
	fmt.Println(&quot;write setup code here...&quot;) // 测试之前的做一些设置
	// 如果 TestMain 使用了 flags，这里应该加上flag.Parse()
	retCode := m.Run()                         // 执行测试
	fmt.Println(&quot;write teardown code here...&quot;) // 测试之后做一些拆卸工作
	os.Exit(retCode)                           // 退出测试
}
</code></pre>

<p>需要注意的是：在调用<code>TestMain</code>时, <code>flag.Parse</code>并没有被调用。所以如果<code>TestMain</code> 依赖于command-line标志 (包括 testing 包的标记), 则应该显示的调用<code>flag.Parse</code>。</p>

<h4 id="子测试的setup与teardown">子测试的Setup与Teardown</h4>

<p>有时候我们可能需要为每个测试集设置Setup与Teardown，也有可能需要为每个子测试设置Setup与Teardown。下面我们定义两个函数工具函数如下：</p>

<pre><code class="language-go">// 测试集的Setup与Teardown
func setupTestCase(t *testing.T) func(t *testing.T) {
	t.Log(&quot;如有需要在此执行:测试之前的setup&quot;)
	return func(t *testing.T) {
		t.Log(&quot;如有需要在此执行:测试之后的teardown&quot;)
	}
}

// 子测试的Setup与Teardown
func setupSubTest(t *testing.T) func(t *testing.T) {
	t.Log(&quot;如有需要在此执行:子测试之前的setup&quot;)
	return func(t *testing.T) {
		t.Log(&quot;如有需要在此执行:子测试之后的teardown&quot;)
	}
}
</code></pre>

<p>使用方式如下：</p>

<pre><code class="language-go">func TestSplit(t *testing.T) {
	type test struct { // 定义test结构体
		input string
		sep   string
		want  []string
	}
	tests := map[string]test{ // 测试用例使用map存储
		&quot;simple&quot;:      {input: &quot;a🅱c&quot;, sep: &quot;:&quot;, want: []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}},
		&quot;wrong sep&quot;:   {input: &quot;a🅱c&quot;, sep: &quot;,&quot;, want: []string{&quot;a🅱c&quot;}},
		&quot;more sep&quot;:    {input: &quot;abcd&quot;, sep: &quot;bc&quot;, want: []string{&quot;a&quot;, &quot;d&quot;}},
		&quot;leading sep&quot;: {input: &quot;沙河有沙又有河&quot;, sep: &quot;沙&quot;, want: []string{&quot;&quot;, &quot;河有&quot;, &quot;又有河&quot;}},
	}
	teardownTestCase := setupTestCase(t) // 测试之前执行setup操作
	defer teardownTestCase(t)            // 测试之后执行testdoen操作

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) { // 使用t.Run()执行子测试
			teardownSubTest := setupSubTest(t) // 子测试之前执行setup操作
			defer teardownSubTest(t)           // 测试之后执行testdoen操作
			got := Split(tc.input, tc.sep)
			if !reflect.DeepEqual(got, tc.want) {
				t.Errorf(&quot;expected:%#v, got:%#v&quot;, tc.want, got)
			}
		})
	}
}
</code></pre>

<p>测试结果如下：</p>

<pre><code class="language-bash">split $ go test -v
=== RUN   TestSplit
=== RUN   TestSplit/simple
=== RUN   TestSplit/wrong_sep
=== RUN   TestSplit/more_sep
=== RUN   TestSplit/leading_sep
--- PASS: TestSplit (0.00s)
    split_test.go:71: 如有需要在此执行:测试之前的setup
    --- PASS: TestSplit/simple (0.00s)
        split_test.go:79: 如有需要在此执行:子测试之前的setup
        split_test.go:81: 如有需要在此执行:子测试之后的teardown
    --- PASS: TestSplit/wrong_sep (0.00s)
        split_test.go:79: 如有需要在此执行:子测试之前的setup
        split_test.go:81: 如有需要在此执行:子测试之后的teardown
    --- PASS: TestSplit/more_sep (0.00s)
        split_test.go:79: 如有需要在此执行:子测试之前的setup
        split_test.go:81: 如有需要在此执行:子测试之后的teardown
    --- PASS: TestSplit/leading_sep (0.00s)
        split_test.go:79: 如有需要在此执行:子测试之前的setup
        split_test.go:81: 如有需要在此执行:子测试之后的teardown
    split_test.go:73: 如有需要在此执行:测试之后的teardown
=== RUN   ExampleSplit
--- PASS: ExampleSplit (0.00s)
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s
</code></pre>

<h3 id="示例函数">示例函数</h3>

<h4 id="示例函数的格式">示例函数的格式</h4>

<p>被<code>go test</code>特殊对待的第三种函数就是示例函数，它们的函数名以<code>Example</code>为前缀。它们既没有参数也没有返回值。标准格式如下：</p>

<pre><code class="language-go">func ExampleName() {
    // ...
}
</code></pre>

<h4 id="示例函数示例">示例函数示例</h4>

<p>下面的代码是我们为<code>Split</code>函数编写的一个示例函数：</p>

<pre><code class="language-go">func ExampleSplit() {
	fmt.Println(split.Split(&quot;a🅱c&quot;, &quot;:&quot;))
	fmt.Println(split.Split(&quot;沙河有沙又有河&quot;, &quot;沙&quot;))
	// Output:
	// [a b c]
	// [ 河有 又有河]
}
</code></pre>

<p>为你的代码编写示例代码有如下三个用处：</p>

<ol>
<li><p>示例函数能够作为文档直接使用，例如基于web的godoc中能把示例函数与对应的函数或包相关联。</p></li>

<li><p>示例函数只要包含了<code>// Output:</code>也是可以通过<code>go test</code>运行的可执行测试。</p>

<pre><code class="language-bash">split $ go test -run Example
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s
</code></pre></li>

<li><p>示例函数提供了可以直接运行的示例代码，可以直接在<code>golang.org</code>的<code>godoc</code>文档服务器上使用<code>Go Playground</code>运行示例代码。下图为<code>strings.ToUpper</code>函数在Playground的示例函数效果。<img src="/resources/技术收录/golang/example.png" alt="Go Playground" /></p></li>
</ol>

<h3 id="练习题-11">练习题</h3>

<ol>
<li>编写一个回文检测函数，并为其编写单元测试和基准测试，根据测试的结果逐步对其进行优化。（回文：一个字符串正序和逆序一样，如“Madam,I’mAdam”、“油灯少灯油”等。）</li>
</ol>

<h1 id="go语言常用标准库">Go语言常用标准库</h1>

<h2 id="go语言标准库之fmt与格式化占位符">Go语言标准库之fmt与格式化占位符</h2>

<p><strong>Go语言fmt.Printf使用指南</strong></p>

<p>fmt标准库是我们在学习Go语言过程中接触最早最频繁的一个了，本文介绍了fmtb包的一些常用函数。</p>

<h3 id="fmt">fmt</h3>

<p>fmt包实现了类似C语言printf和scanf的格式化I/O。主要分为向外输出内容和获取输入内容两大部分。</p>

<h4 id="向外输出">向外输出</h4>

<p>标准库<code>fmt</code>提供了以下几种输出相关函数。</p>

<h5 id="print">Print</h5>

<p><code>Print</code>系列函数会将内容输出到系统的标准输出，区别在于<code>Print</code>函数直接输出内容，<code>Printf</code>函数支持格式化输出字符串，<code>Println</code>函数会在输出内容的结尾添加一个换行符。</p>

<pre><code class="language-go">func Print(a ...interface{}) (n int, err error)
func Printf(format string, a ...interface{}) (n int, err error)
func Println(a ...interface{}) (n int, err error)
</code></pre>

<p>举个简单的例子：</p>

<pre><code class="language-go">func main() {
	fmt.Print(&quot;在终端打印该信息。&quot;)
	name := &quot;沙河小王子&quot;
	fmt.Printf(&quot;我是：%s\n&quot;, name)
	fmt.Println(&quot;在终端打印单独一行显示&quot;)
}
</code></pre>

<p>执行上面的代码输出：</p>

<pre><code class="language-go">在终端打印该信息。我是：沙河小王子
在终端打印单独一行显示
</code></pre>

<h5 id="fprint">Fprint</h5>

<p><code>Fprint</code>系列函数会将内容输出到一个<code>io.Writer</code>接口类型的变量<code>w</code>中，我们通常用这个函数往文件中写入内容。</p>

<pre><code class="language-go">func Fprint(w io.Writer, a ...interface{}) (n int, err error)
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)
</code></pre>

<p>举个例子：</p>

<pre><code class="language-go">// 向标准输出写入内容
fmt.Fprintln(os.Stdout, &quot;向标准输出写入内容&quot;)
fileObj, err := os.OpenFile(&quot;./xx.txt&quot;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
if err != nil {
	fmt.Println(&quot;打开文件出错，err:&quot;, err)
	return
}
name := &quot;沙河小王子&quot;
// 向打开的文件句柄中写入内容
fmt.Fprintf(fileObj, &quot;往文件中写如信息：%s&quot;, name)
</code></pre>

<p>注意，只要满足<code>io.Writer</code>接口的类型都支持写入。</p>

<h5 id="sprint">Sprint</h5>

<p><code>Sprint</code>系列函数会把传入的数据生成并返回一个字符串。</p>

<pre><code class="language-go">func Sprint(a ...interface{}) string
func Sprintf(format string, a ...interface{}) string
func Sprintln(a ...interface{}) string
</code></pre>

<p>简单的示例代码如下：</p>

<pre><code class="language-go">s1 := fmt.Sprint(&quot;沙河小王子&quot;)
name := &quot;沙河小王子&quot;
age := 18
s2 := fmt.Sprintf(&quot;name:%s,age:%d&quot;, name, age)
s3 := fmt.Sprintln(&quot;沙河小王子&quot;)
fmt.Println(s1, s2, s3)
</code></pre>

<h5 id="errorf">Errorf</h5>

<p><code>Errorf</code>函数根据format参数生成格式化字符串并返回一个包含该字符串的错误。</p>

<pre><code class="language-go">func Errorf(format string, a ...interface{}) error
</code></pre>

<p>通常使用这种方式来自定义错误类型，例如：</p>

<pre><code class="language-go">err := fmt.Errorf(&quot;这是一个错误&quot;)
</code></pre>

<p>Go1.13版本为<code>fmt.Errorf</code>函数新加了一个<code>%w</code>占位符用来生成一个可以包裹Error的Wrapping Error。</p>

<pre><code class="language-go">e := errors.New(&quot;原始错误e&quot;)
w := fmt.Errorf(&quot;Wrap了一个错误%w&quot;, e)
</code></pre>

<h4 id="格式化占位符">格式化占位符</h4>

<p><code>*printf</code>系列函数都支持format格式化参数，在这里我们按照占位符将被替换的变量类型划分，方便查询和记忆。</p>

<h5 id="通用占位符">通用占位符</h5>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">%v</td>
<td align="center">值的默认格式表示</td>
</tr>

<tr>
<td align="center">%+v</td>
<td align="center">类似%v，但输出结构体时会添加字段名</td>
</tr>

<tr>
<td align="center">%#v</td>
<td align="center">值的Go语法表示</td>
</tr>

<tr>
<td align="center">%T</td>
<td align="center">打印值的类型</td>
</tr>

<tr>
<td align="center">%%</td>
<td align="center">百分号</td>
</tr>
</tbody>
</table>

<p>示例代码如下：</p>

<pre><code class="language-go">fmt.Printf(&quot;%v\n&quot;, 100)
fmt.Printf(&quot;%v\n&quot;, false)
o := struct{ name string }{&quot;小王子&quot;}
fmt.Printf(&quot;%v\n&quot;, o)
fmt.Printf(&quot;%#v\n&quot;, o)
fmt.Printf(&quot;%T\n&quot;, o)
fmt.Printf(&quot;100%%\n&quot;)
</code></pre>

<p>输出结果如下：</p>

<pre><code class="language-bash">100
false
{小王子}
struct { name string }{name:&quot;小王子&quot;}
struct { name string }
100%
</code></pre>

<h5 id="布尔型">布尔型</h5>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">%t</td>
<td align="center">true或false</td>
</tr>
</tbody>
</table>

<h5 id="整型-1">整型</h5>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">%b</td>
<td align="center">表示为二进制</td>
</tr>

<tr>
<td align="center">%c</td>
<td align="center">该值对应的unicode码值</td>
</tr>

<tr>
<td align="center">%d</td>
<td align="center">表示为十进制</td>
</tr>

<tr>
<td align="center">%o</td>
<td align="center">表示为八进制</td>
</tr>

<tr>
<td align="center">%x</td>
<td align="center">表示为十六进制，使用a-f</td>
</tr>

<tr>
<td align="center">%X</td>
<td align="center">表示为十六进制，使用A-F</td>
</tr>

<tr>
<td align="center">%U</td>
<td align="center">表示为Unicode格式：U+1234，等价于”U+%04X”</td>
</tr>

<tr>
<td align="center">%q</td>
<td align="center">该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示</td>
</tr>
</tbody>
</table>

<p>示例代码如下：</p>

<pre><code class="language-go">n := 65
fmt.Printf(&quot;%b\n&quot;, n)
fmt.Printf(&quot;%c\n&quot;, n)
fmt.Printf(&quot;%d\n&quot;, n)
fmt.Printf(&quot;%o\n&quot;, n)
fmt.Printf(&quot;%x\n&quot;, n)
fmt.Printf(&quot;%X\n&quot;, n)
</code></pre>

<p>输出结果如下：</p>

<pre><code class="language-bash">1000001
A
65
101
41
41
</code></pre>

<h5 id="浮点数与复数">浮点数与复数</h5>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">%b</td>
<td align="center">无小数部分、二进制指数的科学计数法，如-123456p-78</td>
</tr>

<tr>
<td align="center">%e</td>
<td align="center">科学计数法，如-1234.456e+78</td>
</tr>

<tr>
<td align="center">%E</td>
<td align="center">科学计数法，如-1234.456E+78</td>
</tr>

<tr>
<td align="center">%f</td>
<td align="center">有小数部分但无指数部分，如123.456</td>
</tr>

<tr>
<td align="center">%F</td>
<td align="center">等价于%f</td>
</tr>

<tr>
<td align="center">%g</td>
<td align="center">根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）</td>
</tr>

<tr>
<td align="center">%G</td>
<td align="center">根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）</td>
</tr>
</tbody>
</table>

<p>示例代码如下：</p>

<pre><code class="language-go">f := 12.34
fmt.Printf(&quot;%b\n&quot;, f)
fmt.Printf(&quot;%e\n&quot;, f)
fmt.Printf(&quot;%E\n&quot;, f)
fmt.Printf(&quot;%f\n&quot;, f)
fmt.Printf(&quot;%g\n&quot;, f)
fmt.Printf(&quot;%G\n&quot;, f)
</code></pre>

<p>输出结果如下：</p>

<pre><code class="language-bash">6946802425218990p-49
1.234000e+01
1.234000E+01
12.340000
12.34
12.34
</code></pre>

<h5 id="字符串和-byte">字符串和[]byte</h5>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">%s</td>
<td align="center">直接输出字符串或者[]byte</td>
</tr>

<tr>
<td align="center">%q</td>
<td align="center">该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示</td>
</tr>

<tr>
<td align="center">%x</td>
<td align="center">每个字节用两字符十六进制数表示（使用a-f</td>
</tr>

<tr>
<td align="center">%X</td>
<td align="center">每个字节用两字符十六进制数表示（使用A-F）</td>
</tr>
</tbody>
</table>

<p>示例代码如下：</p>

<pre><code class="language-go">s := &quot;小王子&quot;
fmt.Printf(&quot;%s\n&quot;, s)
fmt.Printf(&quot;%q\n&quot;, s)
fmt.Printf(&quot;%x\n&quot;, s)
fmt.Printf(&quot;%X\n&quot;, s)
</code></pre>

<p>输出结果如下：</p>

<pre><code class="language-bash">小王子
&quot;小王子&quot;
e5b08fe78e8be5ad90
E5B08FE78E8BE5AD90
</code></pre>

<h4 id="指针">指针</h4>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">%p</td>
<td align="center">表示为十六进制，并加上前导的0x</td>
</tr>
</tbody>
</table>

<p>示例代码如下：</p>

<pre><code class="language-go">a := 10
fmt.Printf(&quot;%p\n&quot;, &amp;a)
fmt.Printf(&quot;%#p\n&quot;, &amp;a)
</code></pre>

<p>输出结果如下：</p>

<pre><code class="language-bash">0xc000094000
c000094000
</code></pre>

<h5 id="宽度标识符">宽度标识符</h5>

<p>宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下：</p>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">%f</td>
<td align="center">默认宽度，默认精度</td>
</tr>

<tr>
<td align="center">%9f</td>
<td align="center">宽度9，默认精度</td>
</tr>

<tr>
<td align="center">%.2f</td>
<td align="center">默认宽度，精度2</td>
</tr>

<tr>
<td align="center">%9.2f</td>
<td align="center">宽度9，精度2</td>
</tr>

<tr>
<td align="center">%9.f</td>
<td align="center">宽度9，精度0</td>
</tr>
</tbody>
</table>

<p>示例代码如下：</p>

<pre><code class="language-go">n := 12.34
fmt.Printf(&quot;%f\n&quot;, n)
fmt.Printf(&quot;%9f\n&quot;, n)
fmt.Printf(&quot;%.2f\n&quot;, n)
fmt.Printf(&quot;%9.2f\n&quot;, n)
fmt.Printf(&quot;%9.f\n&quot;, n)
</code></pre>

<p>输出结果如下：</p>

<pre><code class="language-bash">12.340000
12.340000
12.34
    12.34
       12
</code></pre>

<h5 id="其他flag">其他flag</h5>

<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">’+’</td>
<td align="center">总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）；</td>
</tr>

<tr>
<td align="center">’ ‘</td>
<td align="center">对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格</td>
</tr>

<tr>
<td align="center">’-’</td>
<td align="center">在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）；</td>
</tr>

<tr>
<td align="center">’#’</td>
<td align="center">八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值；</td>
</tr>

<tr>
<td align="center">‘0’</td>
<td align="center">使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面；</td>
</tr>
</tbody>
</table>

<p>举个例子：</p>

<pre><code class="language-go">s := &quot;小王子&quot;
fmt.Printf(&quot;%s\n&quot;, s)
fmt.Printf(&quot;%5s\n&quot;, s)
fmt.Printf(&quot;%-5s\n&quot;, s)
fmt.Printf(&quot;%5.7s\n&quot;, s)
fmt.Printf(&quot;%-5.7s\n&quot;, s)
fmt.Printf(&quot;%5.2s\n&quot;, s)
fmt.Printf(&quot;%05s\n&quot;, s)
</code></pre>

<p>输出结果如下：</p>

<pre><code class="language-bash">小王子
  小王子
小王子  
  小王子
小王子  
   小王
00小王子
</code></pre>

<h4 id="获取输入">获取输入</h4>

<p>Go语言<code>fmt</code>包下有<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，可以在程序运行过程中从标准输入获取用户的输入。</p>

<h5 id="fmt-scan">fmt.Scan</h5>

<p>函数定签名如下：</p>

<pre><code class="language-go">func Scan(a ...interface{}) (n int, err error)
</code></pre>

<ul>
<li>Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。</li>
<li>本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。</li>
</ul>

<p>具体代码示例如下：</p>

<pre><code class="language-go">func main() {
	var (
		name    string
		age     int
		married bool
	)
	fmt.Scan(&amp;name, &amp;age, &amp;married)
	fmt.Printf(&quot;扫描结果 name:%s age:%d married:%t \n&quot;, name, age, married)
}
</code></pre>

<p>将上面的代码编译后在终端执行，在终端依次输入<code>小王子</code>、<code>28</code>和<code>false</code>使用空格分隔。</p>

<pre><code class="language-bash">$ ./scan_demo 
小王子 28 false
扫描结果 name:小王子 age:28 married:false 
</code></pre>

<p><code>fmt.Scan</code>从标准输入中扫描用户输入的数据，将以空白符分隔的数据分别存入指定的参数。</p>

<h5 id="fmt-scanf">fmt.Scanf</h5>

<p>函数签名如下：</p>

<pre><code class="language-go">func Scanf(format string, a ...interface{}) (n int, err error)
</code></pre>

<ul>
<li>Scanf从标准输入扫描文本，根据format参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。</li>
<li>本函数返回成功扫描的数据个数和遇到的任何错误。</li>
</ul>

<p>代码示例如下：</p>

<pre><code class="language-go">func main() {
	var (
		name    string
		age     int
		married bool
	)
	fmt.Scanf(&quot;1:%s 2:%d 3:%t&quot;, &amp;name, &amp;age, &amp;married)
	fmt.Printf(&quot;扫描结果 name:%s age:%d married:%t \n&quot;, name, age, married)
}
</code></pre>

<p>将上面的代码编译后在终端执行，在终端按照指定的格式依次输入<code>小王子</code>、<code>28</code>和<code>false</code>。</p>

<pre><code class="language-bash">$ ./scan_demo 
1:小王子 2:28 3:false
扫描结果 name:小王子 age:28 married:false 
</code></pre>

<p><code>fmt.Scanf</code>不同于<code>fmt.Scan</code>简单的以空格作为输入数据的分隔符，<code>fmt.Scanf</code>为输入数据指定了具体的输入内容格式，只有按照格式输入数据才会被扫描并存入对应变量。</p>

<p>例如，我们还是按照上个示例中以空格分隔的方式输入，<code>fmt.Scanf</code>就不能正确扫描到输入的数据。</p>

<pre><code class="language-bash">$ ./scan_demo 
小王子 28 false
扫描结果 name: age:0 married:false 
</code></pre>

<h5 id="fmt-scanln">fmt.Scanln</h5>

<p>函数签名如下：</p>

<pre><code class="language-go">func Scanln(a ...interface{}) (n int, err error)
</code></pre>

<ul>
<li>Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。</li>
<li>本函数返回成功扫描的数据个数和遇到的任何错误。</li>
</ul>

<p>具体代码示例如下：</p>

<pre><code class="language-go">func main() {
	var (
		name    string
		age     int
		married bool
	)
	fmt.Scanln(&amp;name, &amp;age, &amp;married)
	fmt.Printf(&quot;扫描结果 name:%s age:%d married:%t \n&quot;, name, age, married)
}
</code></pre>

<p>将上面的代码编译后在终端执行，在终端依次输入<code>小王子</code>、<code>28</code>和<code>false</code>使用空格分隔。</p>

<pre><code class="language-bash">$ ./scan_demo 
小王子 28 false
扫描结果 name:小王子 age:28 married:false 
</code></pre>

<p><code>fmt.Scanln</code>遇到回车就结束扫描了，这个比较常用。</p>

<h5 id="bufio-newreader">bufio.NewReader</h5>

<p>有时候我们想完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用<code>bufio</code>包来实现。示例代码如下：</p>

<pre><code class="language-go">func bufioDemo() {
	reader := bufio.NewReader(os.Stdin) // 从标准输入生成读对象
	fmt.Print(&quot;请输入内容：&quot;)
	text, _ := reader.ReadString('\n') // 读到换行
	text = strings.TrimSpace(text)
	fmt.Printf(&quot;%#v\n&quot;, text)
}
</code></pre>

<h5 id="fscan系列">Fscan系列</h5>

<p>这几个函数功能分别类似于<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，只不过它们不是从标准输入中读取数据而是从<code>io.Reader</code>中读取数据。</p>

<pre><code class="language-go">func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
</code></pre>

<h5 id="sscan系列">Sscan系列</h5>

<p>这几个函数功能分别类似于<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，只不过它们不是从标准输入中读取数据而是从指定字符串中读取数据。</p>

<pre><code class="language-go">func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
</code></pre>

<h2 id="go语言基础之time包">Go语言基础之time包</h2>

<p>我们在编程中经常会用到时间和日期数据，本文主要介绍了Go语言内置的time包的基本用法。</p>

<p><strong>time包</strong></p>

<p>时间和日期是我们编程中经常会用到的，本文主要介绍了 Go 语言内置的 time 包的基本用法。time 包提供了一些关于时间显示和测量用的函数。time 包中日历的计算采用的是公历，不考虑润秒。</p>

<h3 id="时间类型">时间类型</h3>

<p>Go 语言中使用<code>time.Time</code>类型表示时间。我们可以通过<code>time.Now</code>函数获取当前的时间对象，然后从时间对象中可以获取到年、月、日、时、分、秒等信息。</p>

<pre><code class="language-go">// timeDemo 时间对象的年月日时分秒
func timeDemo() {
	now := time.Now() // 获取当前时间
	fmt.Printf(&quot;current time:%v\n&quot;, now)

	year := now.Year()     // 年
	month := now.Month()   // 月
	day := now.Day()       // 日
	hour := now.Hour()     // 小时
	minute := now.Minute() // 分钟
	second := now.Second() // 秒
	fmt.Println(year, month, day, hour, minute, second)
}
</code></pre>

<h3 id="location和time-zone">Location和time zone</h3>

<p>Go 语言中使用 location 来映射具体的时区。时区（Time Zone）是根据世界各国家与地区不同的经度而划分的时间定义，全球共分为24个时区。中国差不多跨5个时区，但为了使用方便只用东八时区的标准时即北京时间为准。</p>

<p>下面的示例代码中使用<code>beijing</code>来表示东八区8小时的偏移量，其中time.FixedZone<code>和</code>time.LoadLocation`这两个函数则是用来获取location信息。</p>

<pre><code class="language-go">// timezoneDemo 时区示例
func timezoneDemo() {
	// 中国没有夏令时，使用一个固定的8小时的UTC时差。
	// 对于很多其他国家需要考虑夏令时。
	secondsEastOfUTC := int((8 * time.Hour).Seconds())
	// FixedZone 返回始终使用给定区域名称和偏移量(UTC 以东秒)的 Location。
	beijing := time.FixedZone(&quot;Beijing Time&quot;, secondsEastOfUTC)

	// 如果当前系统有时区数据库，则可以加载一个位置得到对应的时区
	// 例如，加载纽约所在的时区
	newYork, err := time.LoadLocation(&quot;America/New_York&quot;) // UTC-05:00
	if err != nil {
		fmt.Println(&quot;load America/New_York location failed&quot;, err)
		return
	}
	fmt.Println()
	// 加载上海所在的时区
	//shanghai, err := time.LoadLocation(&quot;Asia/Shanghai&quot;) // UTC+08:00
	// 加载东京所在的时区
	//tokyo, err := time.LoadLocation(&quot;Asia/Tokyo&quot;) // UTC+09:00

	// 创建时间对象需要指定位置。常用的位置是 time.Local（当地时间） 和 time.UTC（UTC时间）。
	//timeInLocal := time.Date(2009, 1, 1, 20, 0, 0, 0, time.Local)  // 系统本地时间
	timeInUTC := time.Date(2009, 1, 1, 12, 0, 0, 0, time.UTC)
	sameTimeInBeijing := time.Date(2009, 1, 1, 20, 0, 0, 0, beijing)
	sameTimeInNewYork := time.Date(2009, 1, 1, 7, 0, 0, 0, newYork)

	// 北京时间（东八区）比UTC早8小时，所以上面两个时间看似差了8小时，但表示的是同一个时间
	timesAreEqual := timeInUTC.Equal(sameTimeInBeijing)
	fmt.Println(timesAreEqual)

	// 纽约（西五区）比UTC晚5小时，所以上面两个时间看似差了5小时，但表示的是同一个时间
	timesAreEqual = timeInUTC.Equal(sameTimeInNewYork)
	fmt.Println(timesAreEqual)
}
</code></pre>

<p>在日常编码过程中使用时间对象的时候一定要注意其时区信息。</p>

<h3 id="unix-time">Unix Time</h3>

<p>Unix Time是自1970年1月1日 00:00:00 UTC 至当前时间经过的总秒数。下面的代码片段演示了如何基于时间对象获取到Unix 时间。</p>

<pre><code class="language-go">// timestampDemo 时间戳
func timestampDemo() {
	now := time.Now()        // 获取当前时间
	timestamp := now.Unix()  // 秒级时间戳
	milli := now.UnixMilli() // 毫秒时间戳 Go1.17+
	micro := now.UnixMicro() // 微秒时间戳 Go1.17+
	nano := now.UnixNano()   // 纳秒时间戳
	fmt.Println(timestamp, milli, micro, nano)
}
</code></pre>

<p>time 包还提供了一系列将 int64 类型的时间戳转换为时间对象的方法。</p>

<pre><code class="language-go">// timestamp2Time 将时间戳转为时间对象
func timestamp2Time() {
	// 获取北京时间所在的东八区时区对象
	secondsEastOfUTC := int((8 * time.Hour).Seconds())
	beijing := time.FixedZone(&quot;Beijing Time&quot;, secondsEastOfUTC)

	// 北京时间 2022-02-22 22:22:22.000000022 +0800 CST
	t := time.Date(2022, 02, 22, 22, 22, 22, 22, beijing)

	var (
		sec  = t.Unix()
		msec = t.UnixMilli()
		usec = t.UnixMicro()
	)

	// 将秒级时间戳转为时间对象（第二个参数为不足1秒的纳秒数）
	timeObj := time.Unix(sec, 22)
	fmt.Println(timeObj)           // 2022-02-22 22:22:22.000000022 +0800 CST
	timeObj = time.UnixMilli(msec) // 毫秒级时间戳转为时间对象
	fmt.Println(timeObj)           // 2022-02-22 22:22:22 +0800 CST
	timeObj = time.UnixMicro(usec) // 微秒级时间戳转为时间对象
	fmt.Println(timeObj)           // 2022-02-22 22:22:22 +0800 CST
}
</code></pre>

<h3 id="时间间隔">时间间隔</h3>

<p><code>time.Duration</code>是<code>time</code>包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。<code>time.Duration</code>表示一段时间间隔，可表示的最长时间段大约290年。</p>

<p>time 包中定义的时间间隔类型的常量如下：</p>

<pre><code class="language-go">const (
    Nanosecond  Duration = 1
    Microsecond          = 1000 * Nanosecond
    Millisecond          = 1000 * Microsecond
    Second               = 1000 * Millisecond
    Minute               = 60 * Second
    Hour                 = 60 * Minute
)
</code></pre>

<p>例如：<code>time.Duration</code>表示1纳秒，<code>time.Second</code>表示1秒。</p>

<h4 id="时间操作">时间操作</h4>

<h4 id="add">Add</h4>

<p>Go语言的时间对象有提供Add方法如下：</p>

<pre><code class="language-go">func (t Time) Add(d Duration) Time
</code></pre>

<p>举个例子，求一个小时之后的时间：</p>

<pre><code class="language-go">func main() {
	now := time.Now()
	later := now.Add(time.Hour) // 当前时间加1小时后的时间
	fmt.Println(later)
}
</code></pre>

<h4 id="sub">Sub</h4>

<p>求两个时间之间的差值：</p>

<pre><code class="language-go">func (t Time) Sub(u Time) Duration
</code></pre>

<p>返回一个时间段t-u。如果结果超出了Duration可以表示的最大值/最小值，将返回最大值/最小值。要获取时间点t-d（d为Duration），可以使用t.Add(-d)。</p>

<h4 id="equal">Equal</h4>

<pre><code class="language-go">func (t Time) Equal(u Time) bool
</code></pre>

<p>判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较。本方法和用t==u不同，这种方法还会比较地点和时区信息。</p>

<h4 id="before">Before</h4>

<pre><code class="language-go">func (t Time) Before(u Time) bool
</code></pre>

<p>如果t代表的时间点在u之前，返回真；否则返回假。</p>

<h4 id="after">After</h4>

<pre><code class="language-go">func (t Time) After(u Time) bool
</code></pre>

<p>如果t代表的时间点在u之后，返回真；否则返回假。</p>

<h3 id="定时器">定时器</h3>

<p>使用<code>time.Tick(时间间隔)</code>来设置定时器，定时器的本质上是一个通道（channel）。</p>

<pre><code class="language-go">func tickDemo() {
	ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器
	for i := range ticker {
		fmt.Println(i)//每秒都会执行的任务
	}
}
</code></pre>

<h3 id="时间格式化">时间格式化</h3>

<p><code>time.Format</code>函数能够将一个时间对象格式化输出为指定布局的文本表示形式，需要注意的是 Go 语言中时间格式化的布局不是常见的<code>Y-m-d H:M:S</code>，而是使用 <code>2006-01-02 15:04:05.000</code>（记忆口诀为2006 1 2 3 4 5）。</p>

<p>其中：</p>

<ul>
<li>2006：年（Y）</li>
<li>01：月（m）</li>
<li>02：日（d）</li>
<li>15：时（H）</li>
<li>04：分（M）</li>
<li>05：秒（S）</li>
</ul>

<p><strong>补充</strong></p>

<ul>
<li>如果想格式化为12小时格式，需在格式化布局中添加<code>PM</code>。</li>

<li><p>小数部分想保留指定位数就写0，如果想省略末尾可能的0就写 9。</p>

<pre><code class="language-go">// formatDemo 时间格式化
func formatDemo() {
	now := time.Now()
	// 格式化的模板为 2006-01-02 15:04:05

	// 24小时制
	fmt.Println(now.Format(&quot;2006-01-02 15:04:05.000 Mon Jan&quot;))
	// 12小时制
	fmt.Println(now.Format(&quot;2006-01-02 03:04:05.000 PM Mon Jan&quot;))

	// 小数点后写0，因为有3个0所以格式化输出的结果也保留3位小数
	fmt.Println(now.Format(&quot;2006/01/02 15:04:05.000&quot;)) // 2022/02/27 00:10:42.960
	// 小数点后写9，会省略末尾可能出现的0
	fmt.Println(now.Format(&quot;2006/01/02 15:04:05.999&quot;)) // 2022/02/27 00:10:42.96

	// 只格式化时分秒部分
	fmt.Println(now.Format(&quot;15:04:05&quot;))
	// 只格式化日期部分
	fmt.Println(now.Format(&quot;2006.01.02&quot;))
}
</code></pre></li>
</ul>

<h3 id="解析字符串格式的时间">解析字符串格式的时间</h3>

<p>对于从文本的时间表示中解析出时间对象，<code>time</code>包中提供了<code>time.Parse</code>和<code>time.ParseInLocation</code>两个函数。</p>

<p>其中<code>time.Parse</code>在解析时不需要额外指定时区信息。</p>

<pre><code class="language-go">// parseDemo 指定时区解析时间
func parseDemo() {
	// 在没有时区指示符的情况下，time.Parse 返回UTC时间
	timeObj, err := time.Parse(&quot;2006/01/02 15:04:05&quot;, &quot;2022/10/05 11:25:20&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(timeObj) // 2022-10-05 11:25:20 +0000 UTC

	// 在有时区指示符的情况下，time.Parse 返回对应时区的时间表示
	// RFC3339     = &quot;2006-01-02T15:04:05Z07:00&quot;
	timeObj, err = time.Parse(time.RFC3339, &quot;2022-10-05T11:25:20+08:00&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(timeObj) // 2022-10-05 11:25:20 +0800 CST
}
</code></pre>

<p><code>time.ParseInLocation</code>函数需要在解析时额外指定时区信息。</p>

<pre><code class="language-go">// parseDemo 解析时间
func parseDemo() {
	now := time.Now()
	fmt.Println(now)
	// 加载时区
	loc, err := time.LoadLocation(&quot;Asia/Shanghai&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	// 按照指定时区和指定格式解析字符串时间
	timeObj, err := time.ParseInLocation(&quot;2006/01/02 15:04:05&quot;, &quot;2022/10/05 11:25:20&quot;, loc)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(timeObj)
	fmt.Println(timeObj.Sub(now))
}
</code></pre>

<h3 id="练习题-12">练习题</h3>

<ol>
<li>获取当前时间，格式化输出为<code>2017/06/19 20:30:05</code>格式。</li>
<li>编写程序统计一段代码的执行耗时时间，单位精确到微秒。</li>
</ol>

<h2 id="go语言标准库flag基本使用">Go语言标准库flag基本使用</h2>

<p>Go语言内置的<code>flag</code>包实现了命令行参数的解析，<code>flag</code>包使得开发命令行工具更为简单。</p>

<h3 id="os-args">os.Args</h3>

<p>如果你只是简单的想要获取命令行参数，可以像下面的代码示例一样使用<code>os.Args</code>来获取命令行参数。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
)

//os.Args demo
func main() {
	//os.Args是一个[]string
	if len(os.Args) &gt; 0 {
		for index, arg := range os.Args {
			fmt.Printf(&quot;args[%d]=%v\n&quot;, index, arg)
		}
	}
}
</code></pre>

<p>将上面的代码执行<code>go build -o &quot;args_demo&quot;</code>编译之后，执行：</p>

<pre><code class="language-bash">$ ./args_demo a b c d
args[0]=./args_demo
args[1]=a
args[2]=b
args[3]=c
args[4]=d
</code></pre>

<p><code>os.Args</code>是一个存储命令行参数的字符串切片，它的第一个元素是执行文件的名称。</p>

<h3 id="flag包基本使用">flag包基本使用</h3>

<p>本文介绍了flag包的常用函数和基本用法，更详细的内容请查看<a href="https://studygolang.com/pkgdoc">官方文档</a>。</p>

<h4 id="导入flag包">导入flag包</h4>

<pre><code class="language-go">import flag
</code></pre>

<h4 id="flag参数类型">flag参数类型</h4>

<p>flag包支持的命令行参数类型有<code>bool</code>、<code>int</code>、<code>int64</code>、<code>uint</code>、<code>uint64</code>、<code>float</code> <code>float64</code>、<code>string</code>、<code>duration</code>。</p>

<table>
<thead>
<tr>
<th align="center">flag参数</th>
<th align="center">有效值</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">字符串flag</td>
<td align="center">合法字符串</td>
</tr>

<tr>
<td align="center">整数flag</td>
<td align="center">1234、0664、0x1234等类型，也可以是负数。</td>
</tr>

<tr>
<td align="center">浮点数flag</td>
<td align="center">合法浮点数</td>
</tr>

<tr>
<td align="center">bool类型flag</td>
<td align="center">1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。</td>
</tr>

<tr>
<td align="center">时间段flag</td>
<td align="center">任何合法的时间段字符串。如”300ms”、”-1.5h”、”2h45m”。 合法的单位有”ns”、”us” /“µs”、”ms”、”s”、”m”、”h”。</td>
</tr>
</tbody>
</table>

<h4 id="定义命令行flag参数">定义命令行flag参数</h4>

<p>有以下两种常用的定义命令行<code>flag</code>参数的方法。</p>

<h5 id="flag-type">flag.Type()</h5>

<p>基本格式如下：</p>

<p><code>flag.Type(flag名, 默认值, 帮助信息)*Type</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p>

<pre><code class="language-go">name := flag.String(&quot;name&quot;, &quot;张三&quot;, &quot;姓名&quot;)
age := flag.Int(&quot;age&quot;, 18, &quot;年龄&quot;)
married := flag.Bool(&quot;married&quot;, false, &quot;婚否&quot;)
delay := flag.Duration(&quot;d&quot;, 0, &quot;时间间隔&quot;)
</code></pre>

<p>需要注意的是，此时<code>name</code>、<code>age</code>、<code>married</code>、<code>delay</code>均为对应类型的指针。</p>

<h5 id="flag-typevar">flag.TypeVar()</h5>

<p>基本格式如下： <code>flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p>

<pre><code class="language-go">var name string
var age int
var married bool
var delay time.Duration
flag.StringVar(&amp;name, &quot;name&quot;, &quot;张三&quot;, &quot;姓名&quot;)
flag.IntVar(&amp;age, &quot;age&quot;, 18, &quot;年龄&quot;)
flag.BoolVar(&amp;married, &quot;married&quot;, false, &quot;婚否&quot;)
flag.DurationVar(&amp;delay, &quot;d&quot;, 0, &quot;时间间隔&quot;)
</code></pre>

<h4 id="flag-parse">flag.Parse()</h4>

<p>通过以上两种方法定义好命令行flag参数后，需要通过调用<code>flag.Parse()</code>来对命令行参数进行解析。</p>

<p>支持的命令行参数格式有以下几种：</p>

<ul>
<li><code>-flag xxx</code> （使用空格，一个<code>-</code>符号）</li>
<li><code>--flag xxx</code> （使用空格，两个<code>-</code>符号）</li>
<li><code>-flag=xxx</code> （使用等号，一个<code>-</code>符号）</li>
<li><code>--flag=xxx</code> （使用等号，两个<code>-</code>符号）</li>
</ul>

<p>其中，布尔类型的参数必须使用等号的方式指定。</p>

<p>Flag解析在第一个非flag参数（单个”-“不是flag参数）之前停止，或者在终止符”–“之后停止。</p>

<h4 id="flag其他函数">flag其他函数</h4>

<pre><code class="language-go">flag.Args()  ////返回命令行参数后的其他参数，以[]string类型
flag.NArg()  //返回命令行参数后的其他参数个数
flag.NFlag() //返回使用的命令行参数个数
</code></pre>

<h4 id="完整示例">完整示例</h4>

<h5 id="定义">定义</h5>

<pre><code class="language-go">func main() {
	//定义命令行参数方式1
	var name string
	var age int
	var married bool
	var delay time.Duration
	flag.StringVar(&amp;name, &quot;name&quot;, &quot;张三&quot;, &quot;姓名&quot;)
	flag.IntVar(&amp;age, &quot;age&quot;, 18, &quot;年龄&quot;)
	flag.BoolVar(&amp;married, &quot;married&quot;, false, &quot;婚否&quot;)
	flag.DurationVar(&amp;delay, &quot;d&quot;, 0, &quot;延迟的时间间隔&quot;)

	//解析命令行参数
	flag.Parse()
	fmt.Println(name, age, married, delay)
	//返回命令行参数后的其他参数
	fmt.Println(flag.Args())
	//返回命令行参数后的其他参数个数
	fmt.Println(flag.NArg())
	//返回使用的命令行参数个数
	fmt.Println(flag.NFlag())
}
</code></pre>

<h5 id="使用">使用</h5>

<p>命令行参数使用提示：</p>

<pre><code class="language-bash">$ ./flag_demo -help
Usage of ./flag_demo:
  -age int
        年龄 (default 18)
  -d duration
        时间间隔
  -married
        婚否
  -name string
        姓名 (default &quot;张三&quot;)
</code></pre>

<p>正常使用命令行flag参数：</p>

<pre><code class="language-bash">$ ./flag_demo -name 沙河娜扎 --age 28 -married=false -d=1h30m
沙河娜扎 28 false 1h30m0s
[]
0
4
</code></pre>

<p>使用非flag命令行参数：</p>

<pre><code class="language-bash">$ ./flag_demo a b c
张三 18 false 0s
[a b c]
3
0
</code></pre>

<h2 id="go语言标准库log介绍">Go语言标准库log介绍</h2>

<p>无论是软件开发的调试阶段还是软件上线之后的运行阶段，日志一直都是非常重要的一个环节，我们也应该养成在程序中记录日志的好习惯。</p>

<p><strong>log</strong></p>

<p>Go语言内置的<code>log</code>包实现了简单的日志服务。本文介绍了标准库<code>log</code>的基本使用。</p>

<h3 id="使用logger">使用Logger</h3>

<p>log包定义了Logger类型，该类型提供了一些格式化输出的方法。本包也提供了一个预定义的“标准”logger，可以通过调用函数<code>Print系列</code>(Print|Printf|Println）、<code>Fatal系列</code>（Fatal|Fatalf|Fatalln）、和<code>Panic系列</code>（Panic|Panicf|Panicln）来使用，比自行创建一个logger对象更容易使用。</p>

<p>例如，我们可以像下面的代码一样直接通过<code>log</code>包来调用上面提到的方法，默认它们会将日志信息打印到终端界面：</p>

<pre><code class="language-go">package main

import (
	&quot;log&quot;
)

func main() {
	log.Println(&quot;这是一条很普通的日志。&quot;)
	v := &quot;很普通的&quot;
	log.Printf(&quot;这是一条%s日志。\n&quot;, v)
	log.Fatalln(&quot;这是一条会触发fatal的日志。&quot;)
	log.Panicln(&quot;这是一条会触发panic的日志。&quot;)
}
</code></pre>

<p>编译并执行上面的代码会得到如下输出：</p>

<pre><code class="language-bash">2017/06/19 14:04:17 这是一条很普通的日志。
2017/06/19 14:04:17 这是一条很普通的日志。
2017/06/19 14:04:17 这是一条会触发fatal的日志。
</code></pre>

<p>logger会打印每条日志信息的日期、时间，默认输出到系统的标准错误。Fatal系列函数会在写入日志信息后调用os.Exit(1)。Panic系列函数会在写入日志信息后panic。</p>

<h3 id="配置logger">配置logger</h3>

<h4 id="标准logger的配置">标准logger的配置</h4>

<p>默认情况下的logger只会提供日志的时间信息，但是很多情况下我们希望得到更多信息，比如记录该日志的文件名和行号等。<code>log</code>标准库中为我们提供了定制这些设置的方法。</p>

<p><code>log</code>标准库中的<code>Flags</code>函数会返回标准logger的输出配置，而<code>SetFlags</code>函数用来设置标准logger的输出配置。</p>

<pre><code class="language-go">func Flags() int
func SetFlags(flag int)
</code></pre>

<h4 id="flag选项">flag选项</h4>

<p><code>log</code>标准库提供了如下的flag选项，它们是一系列定义好的常量。</p>

<pre><code class="language-go">const (
    // 控制输出日志信息的细节，不能控制输出的顺序和格式。
    // 输出的日志在每一项后会有一个冒号分隔：例如2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    Ldate         = 1 &lt;&lt; iota     // 日期：2009/01/23
    Ltime                         // 时间：01:23:23
    Lmicroseconds                 // 微秒级别的时间：01:23:23.123123（用于增强Ltime位）
    Llongfile                     // 文件全路径名+行号： /a/b/c/d.go:23
    Lshortfile                    // 文件名+行号：d.go:23（会覆盖掉Llongfile）
    LUTC                          // 使用UTC时间
    LstdFlags     = Ldate | Ltime // 标准logger的初始值
)
</code></pre>

<p>下面我们在记录日志之前先设置一下标准logger的输出选项如下：</p>

<pre><code class="language-go">func main() {
	log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)
	log.Println(&quot;这是一条很普通的日志。&quot;)
}
</code></pre>

<p>编译执行后得到的输出结果如下：</p>

<pre><code class="language-go">2017/06/19 14:05:17.494943 .../log_demo/main.go:11: 这是一条很普通的日志。
</code></pre>

<h4 id="配置日志前缀">配置日志前缀</h4>

<p><code>log</code>标准库中还提供了关于日志信息前缀的两个方法：</p>

<pre><code class="language-go">func Prefix() string
func SetPrefix(prefix string)
</code></pre>

<p>其中<code>Prefix</code>函数用来查看标准logger的输出前缀，<code>SetPrefix</code>函数用来设置输出前缀。</p>

<pre><code class="language-go">func main() {
	log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)
	log.Println(&quot;这是一条很普通的日志。&quot;)
	log.SetPrefix(&quot;[小王子]&quot;)
	log.Println(&quot;这是一条很普通的日志。&quot;)
}
</code></pre>

<p>上面的代码输出如下：</p>

<pre><code class="language-bash">[小王子]2017/06/19 14:05:57.940542 .../log_demo/main.go:13: 这是一条很普通的日志。
</code></pre>

<p>这样我们就能够在代码中为我们的日志信息添加指定的前缀，方便之后对日志信息进行检索和处理。</p>

<h4 id="配置日志输出位置">配置日志输出位置</h4>

<pre><code class="language-go">func SetOutput(w io.Writer)
</code></pre>

<p><code>SetOutput</code>函数用来设置标准logger的输出目的地，默认是标准错误输出。</p>

<p>例如，下面的代码会把日志输出到同目录下的<code>xx.log</code>文件中。</p>

<pre><code class="language-go">func main() {
	logFile, err := os.OpenFile(&quot;./xx.log&quot;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		fmt.Println(&quot;open log file failed, err:&quot;, err)
		return
	}
	log.SetOutput(logFile)
	log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)
	log.Println(&quot;这是一条很普通的日志。&quot;)
	log.SetPrefix(&quot;[小王子]&quot;)
	log.Println(&quot;这是一条很普通的日志。&quot;)
}
</code></pre>

<p>如果你要使用标准的logger，我们通常会把上面的配置操作写到<code>init</code>函数中。</p>

<pre><code class="language-go">func init() {
	logFile, err := os.OpenFile(&quot;./xx.log&quot;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		fmt.Println(&quot;open log file failed, err:&quot;, err)
		return
	}
	log.SetOutput(logFile)
	log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)
}
</code></pre>

<h3 id="创建logger">创建logger</h3>

<p><code>log</code>标准库中还提供了一个创建新logger对象的构造函数–<code>New</code>，支持我们创建自己的logger示例。<code>New</code>函数的签名如下：</p>

<pre><code class="language-go">func New(out io.Writer, prefix string, flag int) *Logger
</code></pre>

<p>New创建一个Logger对象。其中，参数out设置日志信息写入的目的地。参数prefix会添加到生成的每一条日志前面。参数flag定义日志的属性（时间、文件等等）。</p>

<p>举个例子：</p>

<pre><code class="language-go">func main() {
	logger := log.New(os.Stdout, &quot;&lt;New&gt;&quot;, log.Lshortfile|log.Ldate|log.Ltime)
	logger.Println(&quot;这是自定义的logger记录的日志。&quot;)
}
</code></pre>

<p>将上面的代码编译执行之后，得到结果如下：</p>

<pre><code class="language-bash">&lt;New&gt;2017/06/19 14:06:51 main.go:34: 这是自定义的logger记录的日志。
</code></pre>

<h3 id="总结">总结</h3>

<p>Go内置的log库功能有限，例如无法满足记录不同级别日志的情况，我们在实际的项目中根据自己的需要选择使用第三方的日志库，如<a href="https://github.com/sirupsen/logrus">logrus</a>、<a href="https://github.com/uber-go/zap">zap</a>等。</p>

<h2 id="go语言文件操作">Go语言文件操作</h2>

<p>本文主要介绍了Go语言中文件读写的相关操作。</p>

<p>文件是什么？</p>

<p>计算机中的文件是存储在外部介质（通常是磁盘）上的数据集合，文件分为文本文件和二进制文件。</p>

<h3 id="打开和关闭文件">打开和关闭文件</h3>

<p><code>os.Open()</code>函数能够打开一个文件，返回一个<code>*File</code>和一个<code>err</code>。对得到的文件实例调用<code>close()</code>方法能够关闭文件。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	// 只读方式打开当前目录下的main.go文件
	file, err := os.Open(&quot;./main.go&quot;)
	if err != nil {
		fmt.Println(&quot;open file failed!, err:&quot;, err)
		return
	}
	// 关闭文件
	file.Close()
}
</code></pre>

<p>为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句。</p>

<h3 id="读取文件">读取文件</h3>

<h4 id="file-read">file.Read()</h4>

<h5 id="基本使用">基本使用</h5>

<p>Read方法定义如下：</p>

<pre><code class="language-go">func (f *File) Read(b []byte) (n int, err error)
</code></pre>

<p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回<code>0</code>和<code>io.EOF</code>。 举个例子：</p>

<pre><code class="language-go">func main() {
	// 只读方式打开当前目录下的main.go文件
	file, err := os.Open(&quot;./main.go&quot;)
	if err != nil {
		fmt.Println(&quot;open file failed!, err:&quot;, err)
		return
	}
	defer file.Close()
	// 使用Read方法读取数据
	var tmp = make([]byte, 128)
	n, err := file.Read(tmp)
	if err == io.EOF {
		fmt.Println(&quot;文件读完了&quot;)
		return
	}
	if err != nil {
		fmt.Println(&quot;read file failed, err:&quot;, err)
		return
	}
	fmt.Printf(&quot;读取了%d字节数据\n&quot;, n)
	fmt.Println(string(tmp[:n]))
}
</code></pre>

<h5 id="循环读取">循环读取</h5>

<p>使用for循环读取文件中的所有数据。</p>

<pre><code class="language-go">func main() {
	// 只读方式打开当前目录下的main.go文件
	file, err := os.Open(&quot;./main.go&quot;)
	if err != nil {
		fmt.Println(&quot;open file failed!, err:&quot;, err)
		return
	}
	defer file.Close()
	// 循环读取文件
	var content []byte
	var tmp = make([]byte, 128)
	for {
		n, err := file.Read(tmp)
		if err == io.EOF {
			fmt.Println(&quot;文件读完了&quot;)
			break
		}
		if err != nil {
			fmt.Println(&quot;read file failed, err:&quot;, err)
			return
		}
		content = append(content, tmp[:n]...)
	}
	fmt.Println(string(content))
}
</code></pre>

<h4 id="bufio读取文件">bufio读取文件</h4>

<p>bufio是在file的基础上封装了一层API，支持更多的功能。</p>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
)

// bufio按行读取示例
func main() {
	file, err := os.Open(&quot;./xx.txt&quot;)
	if err != nil {
		fmt.Println(&quot;open file failed, err:&quot;, err)
		return
	}
	defer file.Close()
	reader := bufio.NewReader(file)
	for {
		line, err := reader.ReadString('\n') //注意是字符
		if err == io.EOF {
			if len(line) != 0 {
				fmt.Println(line)
			}
			fmt.Println(&quot;文件读完了&quot;)
			break
		}
		if err != nil {
			fmt.Println(&quot;read file failed, err:&quot;, err)
			return
		}
		fmt.Print(line)
	}
}
</code></pre>

<h4 id="ioutil读取整个文件">ioutil读取整个文件</h4>

<p><code>io/ioutil</code>包的<code>ReadFile</code>方法能够读取完整的文件，只需要将文件名作为参数传入。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
)

// ioutil.ReadFile读取整个文件
func main() {
	content, err := ioutil.ReadFile(&quot;./main.go&quot;)
	if err != nil {
		fmt.Println(&quot;read file failed, err:&quot;, err)
		return
	}
	fmt.Println(string(content))
}
</code></pre>

<h3 id="文件写入操作">文件写入操作</h3>

<p><code>os.OpenFile()</code>函数能够以指定模式打开文件，从而实现文件写入相关功能。</p>

<pre><code class="language-go">func OpenFile(name string, flag int, perm FileMode) (*File, error) {
	...
}
</code></pre>

<p>其中：</p>

<p><code>name</code>：要打开的文件名 <code>flag</code>：打开文件的模式。 模式有以下几种：</p>

<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">含义</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><code>os.O_WRONLY</code></td>
<td align="center">只写</td>
</tr>

<tr>
<td align="center"><code>os.O_CREATE</code></td>
<td align="center">创建文件</td>
</tr>

<tr>
<td align="center"><code>os.O_RDONLY</code></td>
<td align="center">只读</td>
</tr>

<tr>
<td align="center"><code>os.O_RDWR</code></td>
<td align="center">读写</td>
</tr>

<tr>
<td align="center"><code>os.O_TRUNC</code></td>
<td align="center">清空</td>
</tr>

<tr>
<td align="center"><code>os.O_APPEND</code></td>
<td align="center">追加</td>
</tr>
</tbody>
</table>

<p><code>perm</code>：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。</p>

<h4 id="write和writestring">Write和WriteString</h4>

<pre><code class="language-go">func main() {
	file, err := os.OpenFile(&quot;xx.txt&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		fmt.Println(&quot;open file failed, err:&quot;, err)
		return
	}
	defer file.Close()
	str := &quot;hello 沙河&quot;
	file.Write([]byte(str))       //写入字节切片数据
	file.WriteString(&quot;hello 小王子&quot;) //直接写入字符串数据
}
</code></pre>

<h4 id="bufio-newwriter">bufio.NewWriter</h4>

<pre><code class="language-go">func main() {
	file, err := os.OpenFile(&quot;xx.txt&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		fmt.Println(&quot;open file failed, err:&quot;, err)
		return
	}
	defer file.Close()
	writer := bufio.NewWriter(file)
	for i := 0; i &lt; 10; i++ {
		writer.WriteString(&quot;hello沙河\n&quot;) //将数据先写入缓存
	}
	writer.Flush() //将缓存中的内容写入文件
}
</code></pre>

<h4 id="ioutil-writefile">ioutil.WriteFile</h4>

<pre><code class="language-go">func main() {
	str := &quot;hello 沙河&quot;
	err := ioutil.WriteFile(&quot;./xx.txt&quot;, []byte(str), 0666)
	if err != nil {
		fmt.Println(&quot;write file failed, err:&quot;, err)
		return
	}
}
</code></pre>

<h3 id="练习">练习</h3>

<h3 id="copyfile">copyFile</h3>

<p>借助<code>io.Copy()</code>实现一个拷贝文件函数。</p>

<pre><code class="language-go">// CopyFile 拷贝文件函数
func CopyFile(dstName, srcName string) (written int64, err error) {
	// 以读方式打开源文件
	src, err := os.Open(srcName)
	if err != nil {
		fmt.Printf(&quot;open %s failed, err:%v.\n&quot;, srcName, err)
		return
	}
	defer src.Close()
	// 以写|创建的方式打开目标文件
	dst, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, 0644)
	if err != nil {
		fmt.Printf(&quot;open %s failed, err:%v.\n&quot;, dstName, err)
		return
	}
	defer dst.Close()
	return io.Copy(dst, src) //调用io.Copy()拷贝内容
}
func main() {
	_, err := CopyFile(&quot;dst.txt&quot;, &quot;src.txt&quot;)
	if err != nil {
		fmt.Println(&quot;copy file failed, err:&quot;, err)
		return
	}
	fmt.Println(&quot;copy done!&quot;)
}
</code></pre>

<h3 id="实现一个cat命令">实现一个cat命令</h3>

<p>使用文件操作相关知识，模拟实现linux平台<code>cat</code>命令的功能。</p>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
)

// cat命令实现
func cat(r *bufio.Reader) {
	for {
		buf, err := r.ReadBytes('\n') //注意是字符
		if err == io.EOF {
			// 退出之前将已读到的内容输出
			fmt.Fprintf(os.Stdout, &quot;%s&quot;, buf)
			break
		}
		fmt.Fprintf(os.Stdout, &quot;%s&quot;, buf)
	}
}

func main() {
	flag.Parse() // 解析命令行参数
	if flag.NArg() == 0 {
		// 如果没有参数默认从标准输入读取内容
		cat(bufio.NewReader(os.Stdin))
	}
	// 依次读取每个指定文件的内容并打印到终端
	for i := 0; i &lt; flag.NArg(); i++ {
		f, err := os.Open(flag.Arg(i))
		if err != nil {
			fmt.Fprintf(os.Stdout, &quot;reading from %s failed, err:%v\n&quot;, flag.Arg(i), err)
			continue
		}
		cat(bufio.NewReader(f))
	}
}
</code></pre>

<h2 id="go语言内置包之strconv">Go语言内置包之strconv</h2>

<p>Go语言中<code>strconv</code>包实现了基本数据类型和其字符串表示的相互转换。</p>

<p><strong>strconv包</strong></p>

<p>strconv包实现了基本数据类型与其字符串表示的转换，主要有以下常用函数： <code>Atoi()</code>、<code>Itoa()</code>、parse系列、format系列、append系列。</p>

<p>更多函数请查看<a href="https://golang.org/pkg/strconv/">官方文档</a>。</p>

<h3 id="string与int类型转换">string与int类型转换</h3>

<p>这一组函数是我们平时编程中用的最多的。</p>

<h4 id="atoi">Atoi()</h4>

<p><code>Atoi()</code>函数用于将字符串类型的整数转换为int类型，函数签名如下。</p>

<pre><code class="language-go">func Atoi(s string) (i int, err error)
</code></pre>

<p>如果传入的字符串参数无法转换为int类型，就会返回错误。</p>

<pre><code class="language-go">s1 := &quot;100&quot;
i1, err := strconv.Atoi(s1)
if err != nil {
	fmt.Println(&quot;can't convert to int&quot;)
} else {
	fmt.Printf(&quot;type:%T value:%#v\n&quot;, i1, i1) //type:int value:100
}
</code></pre>

<h4 id="itoa">Itoa()</h4>

<p><code>Itoa()</code>函数用于将int类型数据转换为对应的字符串表示，具体的函数签名如下。</p>

<pre><code class="language-go">func Itoa(i int) string
</code></pre>

<p>示例代码如下：</p>

<pre><code class="language-go">i2 := 200
s2 := strconv.Itoa(i2)
fmt.Printf(&quot;type:%T value:%#v\n&quot;, s2, s2) //type:string value:&quot;200&quot;
</code></pre>

<h4 id="a的典故">a的典故</h4>

<p>【扩展阅读】这是C语言遗留下的典故。C语言中没有string类型而是用字符数组(array)表示字符串，所以<code>Itoa</code>对很多C系的程序员很好理解。</p>

<h3 id="parse系列函数">Parse系列函数</h3>

<p>Parse类函数用于转换字符串为给定类型的值：ParseBool()、ParseFloat()、ParseInt()、ParseUint()。</p>

<h4 id="parsebool">ParseBool()</h4>

<pre><code class="language-go">func ParseBool(str string) (value bool, err error)
</code></pre>

<p>返回字符串表示的bool值。它接受1、0、t、f、T、F、true、false、True、False、TRUE、FALSE；否则返回错误。</p>

<h4 id="parseint">ParseInt()</h4>

<pre><code class="language-go">func ParseInt(s string, base int, bitSize int) (i int64, err error)
</code></pre>

<p>返回字符串表示的整数值，接受正负号。</p>

<p>base指定进制（2到36），如果base为0，则会从字符串前置判断，”0x”是16进制，”0”是8进制，否则是10进制；</p>

<p>bitSize指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64；</p>

<p>返回的err是*NumErr类型的，如果语法有误，err.Error = ErrSyntax；如果结果超出类型范围err.Error = ErrRange。</p>

<h4 id="parseunit">ParseUnit()</h4>

<pre><code class="language-go">func ParseUint(s string, base int, bitSize int) (n uint64, err error)
</code></pre>

<p><code>ParseUint</code>类似<code>ParseInt</code>但不接受正负号，用于无符号整型。</p>

<h4 id="parsefloat">ParseFloat()</h4>

<pre><code class="language-go">func ParseFloat(s string, bitSize int) (f float64, err error)
</code></pre>

<p>解析一个表示浮点数的字符串并返回其值。</p>

<p>如果s合乎语法规则，函数会返回最为接近s表示值的一个浮点数（使用IEEE754规范舍入）。</p>

<p>bitSize指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64；</p>

<p>返回值err是*NumErr类型的，语法有误的，err.Error=ErrSyntax；结果超出表示范围的，返回值f为±Inf，err.Error= ErrRange。</p>

<h4 id="代码示例">代码示例</h4>

<pre><code class="language-go">b, err := strconv.ParseBool(&quot;true&quot;)
f, err := strconv.ParseFloat(&quot;3.1415&quot;, 64)
i, err := strconv.ParseInt(&quot;-2&quot;, 10, 64)
u, err := strconv.ParseUint(&quot;2&quot;, 10, 64)
</code></pre>

<p>这些函数都有两个返回值，第一个返回值是转换后的值，第二个返回值为转化失败的错误信息。</p>

<h3 id="format系列函数">Format系列函数</h3>

<p>Format系列函数实现了将给定类型数据格式化为string类型数据的功能。</p>

<h4 id="formatbool">FormatBool()</h4>

<pre><code class="language-go">func FormatBool(b bool) string
</code></pre>

<p>根据b的值返回”true”或”false”。</p>

<h4 id="formatint">FormatInt()</h4>

<pre><code class="language-go">func FormatInt(i int64, base int) string
</code></pre>

<p>返回i的base进制的字符串表示。base 必须在2到36之间，结果中会使用小写字母’a’到’z’表示大于10的数字。</p>

<h4 id="formatuint">FormatUint()</h4>

<pre><code class="language-go">func FormatUint(i uint64, base int) string
</code></pre>

<p>是FormatInt的无符号整数版本。</p>

<h4 id="formatfloat">FormatFloat()</h4>

<pre><code class="language-go">func FormatFloat(f float64, fmt byte, prec, bitSize int) string
</code></pre>

<p>函数将浮点数表示为字符串并返回。</p>

<p>bitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。</p>

<p>fmt表示格式：’f’（-ddd.dddd）、’b’（-ddddp±ddd，指数为二进制）、’e’（-d.dddde±dd，十进制指数）、’E’（-d.ddddE±dd，十进制指数）、’g’（指数很大时用’e’格式，否则’f’格式）、’G’（指数很大时用’E’格式，否则’f’格式）。</p>

<p>prec控制精度（排除指数部分）：对’f’、’e’、’E’，它表示小数点后的数字个数；对’g’、’G’，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。</p>

<h4 id="代码示例-1">代码示例</h4>

<pre><code class="language-go">s1 := strconv.FormatBool(true)
s2 := strconv.FormatFloat(3.1415, 'E', -1, 64)
s3 := strconv.FormatInt(-2, 16)
s4 := strconv.FormatUint(2, 16)
</code></pre>

<h3 id="其他">其他</h3>

<h4 id="isprint">isPrint()</h4>

<pre><code class="language-go">func IsPrint(r rune) bool
</code></pre>

<p>返回一个字符是否是可打印的，和<code>unicode.IsPrint</code>一样，r必须是：字母（广义）、数字、标点、符号、ASCII空格。</p>

<h4 id="canbackquote">CanBackquote()</h4>

<pre><code class="language-go">func CanBackquote(s string) bool
</code></pre>

<p>返回字符串s是否可以不被修改的表示为一个单行的、没有空格和tab之外控制字符的反引号字符串。</p>

<h4 id="其他-1">其他</h4>

<p>除上文列出的函数外，<code>strconv</code>包中还有Append系列、Quote系列等函数。具体用法可查看<a href="https://golang.org/pkg/strconv/">官方文档</a>。</p>

<h2 id="go语言基础之net-http">Go语言基础之net/http</h2>

<p>Go语言内置的<code>net/http</code>包十分的优秀，提供了HTTP客户端和服务端的实现。</p>

<h3 id="net-http介绍">net/http介绍</h3>

<p>Go语言内置的<code>net/http</code>包提供了HTTP客户端和服务端的实现。</p>

<h4 id="http协议">HTTP协议</h4>

<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>

<h3 id="http客户端">HTTP客户端</h3>

<h4 id="基本的http-https请求">基本的HTTP/HTTPS请求</h4>

<p>Get、Head、Post和PostForm函数发出HTTP/HTTPS请求。</p>

<pre><code class="language-go">resp, err := http.Get(&quot;http://example.com/&quot;)
...
resp, err := http.Post(&quot;http://example.com/upload&quot;, &quot;image/jpeg&quot;, &amp;buf)
...
resp, err := http.PostForm(&quot;http://example.com/form&quot;,
	url.Values{&quot;key&quot;: {&quot;Value&quot;}, &quot;id&quot;: {&quot;123&quot;}})
</code></pre>

<p>程序在使用完response后必须关闭回复的主体。</p>

<pre><code class="language-go">resp, err := http.Get(&quot;http://example.com/&quot;)
if err != nil {
	// handle error
}
defer resp.Body.Close()
body, err := ioutil.ReadAll(resp.Body)
// ...
</code></pre>

<h4 id="get请求示例">GET请求示例</h4>

<p>使用<code>net/http</code>包编写一个简单的发送HTTP请求的Client端，代码如下：</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
)

func main() {
	resp, err := http.Get(&quot;https://www.liwenzhou.com/&quot;)
	if err != nil {
		fmt.Printf(&quot;get failed, err:%v\n&quot;, err)
		return
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf(&quot;read from resp.Body failed, err:%v\n&quot;, err)
		return
	}
	fmt.Print(string(body))
}
</code></pre>

<p>将上面的代码保存之后编译成可执行文件，执行之后就能在终端打印<code>liwenzhou.com</code>网站首页的内容了，我们的浏览器其实就是一个发送和接收HTTP协议数据的客户端，我们平时通过浏览器访问网页其实就是从网站的服务器接收HTTP数据，然后浏览器会按照HTML、CSS等规则将网页渲染展示出来。</p>

<h4 id="带参数的get请求示例">带参数的GET请求示例</h4>

<p>关于GET请求的参数需要使用Go语言内置的<code>net/url</code>这个标准库来处理。</p>

<pre><code class="language-go">func main() {
	apiUrl := &quot;http://127.0.0.1:9090/get&quot;
	// URL param
	data := url.Values{}
	data.Set(&quot;name&quot;, &quot;小王子&quot;)
	data.Set(&quot;age&quot;, &quot;18&quot;)
	u, err := url.ParseRequestURI(apiUrl)
	if err != nil {
		fmt.Printf(&quot;parse url requestUrl failed, err:%v\n&quot;, err)
	}
	u.RawQuery = data.Encode() // URL encode
	fmt.Println(u.String())
	resp, err := http.Get(u.String())
	if err != nil {
		fmt.Printf(&quot;post failed, err:%v\n&quot;, err)
		return
	}
	defer resp.Body.Close()
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf(&quot;get resp failed, err:%v\n&quot;, err)
		return
	}
	fmt.Println(string(b))
}
</code></pre>

<p>对应的Server端HandlerFunc如下：</p>

<pre><code class="language-go">func getHandler(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	data := r.URL.Query()
	fmt.Println(data.Get(&quot;name&quot;))
	fmt.Println(data.Get(&quot;age&quot;))
	answer := `{&quot;status&quot;: &quot;ok&quot;}`
	w.Write([]byte(answer))
}
</code></pre>

<h4 id="post请求示例">Post请求示例</h4>

<p>上面演示了使用<code>net/http</code>包发送<code>GET</code>请求的示例，发送<code>POST</code>请求的示例代码如下：</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
	&quot;strings&quot;
)

// net/http post demo

func main() {
	url := &quot;http://127.0.0.1:9090/post&quot;
	// 表单数据
	//contentType := &quot;application/x-www-form-urlencoded&quot;
	//data := &quot;name=小王子&amp;age=18&quot;
	// json
	contentType := &quot;application/json&quot;
	data := `{&quot;name&quot;:&quot;小王子&quot;,&quot;age&quot;:18}`
	resp, err := http.Post(url, contentType, strings.NewReader(data))
	if err != nil {
		fmt.Printf(&quot;post failed, err:%v\n&quot;, err)
		return
	}
	defer resp.Body.Close()
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf(&quot;get resp failed, err:%v\n&quot;, err)
		return
	}
	fmt.Println(string(b))
}
</code></pre>

<p>对应的Server端HandlerFunc如下：</p>

<pre><code class="language-go">func postHandler(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	// 1. 请求类型是application/x-www-form-urlencoded时解析form数据
	r.ParseForm()
	fmt.Println(r.PostForm) // 打印form数据
	fmt.Println(r.PostForm.Get(&quot;name&quot;), r.PostForm.Get(&quot;age&quot;))
	// 2. 请求类型是application/json时从r.Body读取数据
	b, err := ioutil.ReadAll(r.Body)
	if err != nil {
		fmt.Printf(&quot;read request.Body failed, err:%v\n&quot;, err)
		return
	}
	fmt.Println(string(b))
	answer := `{&quot;status&quot;: &quot;ok&quot;}`
	w.Write([]byte(answer))
}
</code></pre>

<h4 id="自定义client">自定义Client</h4>

<p>要管理HTTP客户端的头域、重定向策略和其他设置，创建一个Client：</p>

<pre><code class="language-go">client := &amp;http.Client{
	CheckRedirect: redirectPolicyFunc,
}
resp, err := client.Get(&quot;http://example.com&quot;)
// ...
req, err := http.NewRequest(&quot;GET&quot;, &quot;http://example.com&quot;, nil)
// ...
req.Header.Add(&quot;If-None-Match&quot;, `W/&quot;wyzzy&quot;`)
resp, err := client.Do(req)
// ...
</code></pre>

<h4 id="自定义transport">自定义Transport</h4>

<p>要管理代理、TLS配置、keep-alive、压缩和其他设置，创建一个Transport：</p>

<pre><code class="language-go">tr := &amp;http.Transport{
	TLSClientConfig:    &amp;tls.Config{RootCAs: pool},
	DisableCompression: true,
}
client := &amp;http.Client{Transport: tr}
resp, err := client.Get(&quot;https://example.com&quot;)
</code></pre>

<p>Client和Transport类型都可以安全的被多个goroutine同时使用。出于效率考虑，应该一次建立、尽量重用。</p>

<h3 id="服务端">服务端</h3>

<h4 id="默认的server">默认的Server</h4>

<p>ListenAndServe使用指定的监听地址和处理器启动一个HTTP服务端。处理器参数通常是nil，这表示采用包变量DefaultServeMux作为处理器。</p>

<p>Handle和HandleFunc函数可以向DefaultServeMux添加处理器。</p>

<pre><code class="language-go">http.Handle(&quot;/foo&quot;, fooHandler)
http.HandleFunc(&quot;/bar&quot;, func(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;Hello, %q&quot;, html.EscapeString(r.URL.Path))
})
log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
</code></pre>

<h4 id="默认的server示例">默认的Server示例</h4>

<p>使用Go语言中的<code>net/http</code>包来编写一个简单的接收HTTP请求的Server端示例，<code>net/http</code>包是对net包的进一步封装，专门用来处理HTTP协议的数据。具体的代码如下：</p>

<pre><code class="language-go">// http server

func sayHello(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, &quot;Hello 沙河！&quot;)
}

func main() {
	http.HandleFunc(&quot;/&quot;, sayHello)
	err := http.ListenAndServe(&quot;:9090&quot;, nil)
	if err != nil {
		fmt.Printf(&quot;http server failed, err:%v\n&quot;, err)
		return
	}
}
</code></pre>

<p>将上面的代码编译之后执行，打开你电脑上的浏览器在地址栏输入<code>127.0.0.1:9090</code>回车，此时就能够看到如下页面了。<img src="/resources/技术收录/golang/hello.png" alt="hello页面" /></p>

<h4 id="自定义server">自定义Server</h4>

<p>要管理服务端的行为，可以创建一个自定义的Server：</p>

<pre><code class="language-go">s := &amp;http.Server{
	Addr:           &quot;:8080&quot;,
	Handler:        myHandler,
	ReadTimeout:    10 * time.Second,
	WriteTimeout:   10 * time.Second,
	MaxHeaderBytes: 1 &lt;&lt; 20,
}
log.Fatal(s.ListenAndServe())
</code></pre>

<h2 id="go标准库context">Go标准库Context</h2>

<p>在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源。</p>

<h3 id="为什么需要context">为什么需要Context</h3>

<h4 id="基本示例">基本示例</h4>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;

	&quot;time&quot;
)

var wg sync.WaitGroup

// 初始的例子

func worker() {
	for {
		fmt.Println(&quot;worker&quot;)
		time.Sleep(time.Second)
	}
	// 如何接收外部命令实现退出
	wg.Done()
}

func main() {
	wg.Add(1)
	go worker()
	// 如何优雅的实现结束子goroutine
	wg.Wait()
	fmt.Println(&quot;over&quot;)
}
</code></pre>

<h4 id="全局变量方式">全局变量方式</h4>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;

	&quot;time&quot;
)

var wg sync.WaitGroup
var exit bool

// 全局变量方式存在的问题：
// 1. 使用全局变量在跨包调用时不容易统一
// 2. 如果worker中再启动goroutine，就不太好控制了。

func worker() {
	for {
		fmt.Println(&quot;worker&quot;)
		time.Sleep(time.Second)
		if exit {
			break
		}
	}
	wg.Done()
}

func main() {
	wg.Add(1)
	go worker()
	time.Sleep(time.Second * 3) // sleep3秒以免程序过快退出
	exit = true                 // 修改全局变量实现子goroutine的退出
	wg.Wait()
	fmt.Println(&quot;over&quot;)
}
</code></pre>

<h4 id="通道方式">通道方式</h4>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;

	&quot;time&quot;
)

var wg sync.WaitGroup

// 管道方式存在的问题：
// 1. 使用全局变量在跨包调用时不容易实现规范和统一，需要维护一个共用的channel

func worker(exitChan chan struct{}) {
LOOP:
	for {
		fmt.Println(&quot;worker&quot;)
		time.Sleep(time.Second)
		select {
		case &lt;-exitChan: // 等待接收上级通知
			break LOOP
		default:
		}
	}
	wg.Done()
}

func main() {
	var exitChan = make(chan struct{})
	wg.Add(1)
	go worker(exitChan)
	time.Sleep(time.Second * 3) // sleep3秒以免程序过快退出
	exitChan &lt;- struct{}{}      // 给子goroutine发送退出信号
	close(exitChan)
	wg.Wait()
	fmt.Println(&quot;over&quot;)
}
</code></pre>

<h4 id="官方版的方案">官方版的方案</h4>

<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;sync&quot;

	&quot;time&quot;
)

var wg sync.WaitGroup

func worker(ctx context.Context) {
LOOP:
	for {
		fmt.Println(&quot;worker&quot;)
		time.Sleep(time.Second)
		select {
		case &lt;-ctx.Done(): // 等待上级通知
			break LOOP
		default:
		}
	}
	wg.Done()
}

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	wg.Add(1)
	go worker(ctx)
	time.Sleep(time.Second * 3)
	cancel() // 通知子goroutine结束
	wg.Wait()
	fmt.Println(&quot;over&quot;)
}
</code></pre>

<p>当子goroutine又开启另外一个goroutine时，只需要将ctx传入即可：</p>

<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;sync&quot;

	&quot;time&quot;
)

var wg sync.WaitGroup

func worker(ctx context.Context) {
	go worker2(ctx)
LOOP:
	for {
		fmt.Println(&quot;worker&quot;)
		time.Sleep(time.Second)
		select {
		case &lt;-ctx.Done(): // 等待上级通知
			break LOOP
		default:
		}
	}
	wg.Done()
}

func worker2(ctx context.Context) {
LOOP:
	for {
		fmt.Println(&quot;worker2&quot;)
		time.Sleep(time.Second)
		select {
		case &lt;-ctx.Done(): // 等待上级通知
			break LOOP
		default:
		}
	}
}
func main() {
	ctx, cancel := context.WithCancel(context.Background())
	wg.Add(1)
	go worker(ctx)
	time.Sleep(time.Second * 3)
	cancel() // 通知子goroutine结束
	wg.Wait()
	fmt.Println(&quot;over&quot;)
}
</code></pre>

<h3 id="context初识">Context初识</h3>

<p>Go1.7加入了一个新的标准库<code>context</code>，它定义了<code>Context</code>类型，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。</p>

<p>对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用<code>WithCancel</code>、<code>WithDeadline</code>、<code>WithTimeout</code>或<code>WithValue</code>创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。</p>

<h3 id="context接口">Context接口</h3>

<p><code>context.Context</code>是一个接口，该接口定义了四个需要实现的方法。具体签名如下：</p>

<pre><code class="language-go">type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() &lt;-chan struct{}
    Err() error
    Value(key interface{}) interface{}
}
</code></pre>

<p>其中：</p>

<ul>
<li><p><code>Deadline</code>方法需要返回当前<code>Context</code>被取消的时间，也就是完成工作的截止时间（deadline）；</p></li>

<li><p><code>Done</code>方法需要返回一个<code>Channel</code>，这个Channel会在当前工作完成或者上下文被取消之后关闭，多次调用<code>Done</code>方法会返回同一个Channel；</p></li>

<li><pre><code>Err
</code></pre>

<p>方法会返回当前</p>

<pre><code>Context
</code></pre>

<p>结束的原因，它只会在</p>

<pre><code>Done
</code></pre>

<p>返回的Channel被关闭时才会返回非空的值；</p>

<ul>
<li>如果当前<code>Context</code>被取消就会返回<code>Canceled</code>错误；</li>
<li>如果当前<code>Context</code>超时就会返回<code>DeadlineExceeded</code>错误；</li>
</ul></li>

<li><p><code>Value</code>方法会从<code>Context</code>中返回键对应的值，对于同一个上下文来说，多次调用<code>Value</code> 并传入相同的<code>Key</code>会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域的数据；</p></li>
</ul>

<h4 id="background-和todo">Background()和TODO()</h4>

<p>Go内置两个函数：<code>Background()</code>和<code>TODO()</code>，这两个函数分别返回一个实现了<code>Context</code>接口的<code>background</code>和<code>todo</code>。我们代码中最开始都是以这两个内置的上下文对象作为最顶层的<code>partent context</code>，衍生出更多的子上下文对象。</p>

<p><code>Background()</code>主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context。</p>

<p><code>TODO()</code>，它目前还不知道具体的使用场景，如果我们不知道该使用什么Context的时候，可以使用这个。</p>

<p><code>background</code>和<code>todo</code>本质上都是<code>emptyCtx</code>结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。</p>

<h3 id="with系列函数">With系列函数</h3>

<p>此外，<code>context</code>包中还定义了四个With系列函数。</p>

<h4 id="withcancel">WithCancel</h4>

<p><code>WithCancel</code>的函数签名如下：</p>

<pre><code class="language-go">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
</code></pre>

<p><code>WithCancel</code>返回带有新Done通道的父节点的副本。当调用返回的cancel函数或当关闭父上下文的Done通道时，将关闭返回上下文的Done通道，无论先发生什么情况。</p>

<p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。</p>

<pre><code class="language-go">func gen(ctx context.Context) &lt;-chan int {
		dst := make(chan int)
		n := 1
		go func() {
			for {
				select {
				case &lt;-ctx.Done():
					return // return结束该goroutine，防止泄露
				case dst &lt;- n:
					n++
				}
			}
		}()
		return dst
	}
func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel() // 当我们取完需要的整数后调用cancel

	for n := range gen(ctx) {
		fmt.Println(n)
		if n == 5 {
			break
		}
	}
}
</code></pre>

<p>上面的示例代码中，<code>gen</code>函数在单独的goroutine中生成整数并将它们发送到返回的通道。 gen的调用者在使用生成的整数之后需要取消上下文，以免<code>gen</code>启动的内部goroutine发生泄漏。</p>

<h4 id="withdeadline">WithDeadline</h4>

<p><code>WithDeadline</code>的函数签名如下：</p>

<pre><code class="language-go">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)
</code></pre>

<p>返回父上下文的副本，并将deadline调整为不迟于d。如果父上下文的deadline已经早于d，则WithDeadline(parent, d)在语义上等同于父上下文。当截止日过期时，当调用返回的cancel函数时，或者当父上下文的Done通道关闭时，返回上下文的Done通道将被关闭，以最先发生的情况为准。</p>

<p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。</p>

<pre><code class="language-go">func main() {
	d := time.Now().Add(50 * time.Millisecond)
	ctx, cancel := context.WithDeadline(context.Background(), d)

	// 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。
	// 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。
	defer cancel()

	select {
	case &lt;-time.After(1 * time.Second):
		fmt.Println(&quot;overslept&quot;)
	case &lt;-ctx.Done():
		fmt.Println(ctx.Err())
	}
}
</code></pre>

<p>上面的代码中，定义了一个50毫秒之后过期的deadline，然后我们调用<code>context.WithDeadline(context.Background(), d)</code>得到一个上下文（ctx）和一个取消函数（cancel），然后使用一个select让主程序陷入等待：等待1秒后打印<code>overslept</code>退出或者等待ctx过期后退出。</p>

<p>在上面的示例代码中，因为ctx 50毫秒后就会过期，所以<code>ctx.Done()</code>会先接收到context到期通知，并且会打印ctx.Err()的内容。</p>

<h4 id="withtimeout">WithTimeout</h4>

<p><code>WithTimeout</code>的函数签名如下：</p>

<pre><code class="language-go">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
</code></pre>

<p><code>WithTimeout</code>返回<code>WithDeadline(parent, time.Now().Add(timeout))</code>。</p>

<p>取消此上下文将释放与其相关的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel，通常用于数据库或者网络连接的超时控制。具体示例如下：</p>

<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;sync&quot;

	&quot;time&quot;
)

// context.WithTimeout

var wg sync.WaitGroup

func worker(ctx context.Context) {
LOOP:
	for {
		fmt.Println(&quot;db connecting ...&quot;)
		time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒
		select {
		case &lt;-ctx.Done(): // 50毫秒后自动调用
			break LOOP
		default:
		}
	}
	fmt.Println(&quot;worker done!&quot;)
	wg.Done()
}

func main() {
	// 设置一个50毫秒的超时
	ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50)
	wg.Add(1)
	go worker(ctx)
	time.Sleep(time.Second * 5)
	cancel() // 通知子goroutine结束
	wg.Wait()
	fmt.Println(&quot;over&quot;)
}
</code></pre>

<h4 id="withvalue">WithValue</h4>

<p><code>WithValue</code>函数能够将请求作用域的数据与 Context 对象建立关系。声明如下：</p>

<pre><code class="language-go">func WithValue(parent Context, key, val interface{}) Context
</code></pre>

<p><code>WithValue</code>返回父节点的副本，其中与key关联的值为val。</p>

<p>仅对API和进程间传递请求域的数据使用上下文值，而不是使用它来传递可选参数给函数。</p>

<p>所提供的键必须是可比较的，并且不应该是<code>string</code>类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。<code>WithValue</code>的用户应该为键定义自己的类型。为了避免在分配给interface{}时进行分配，上下文键通常具有具体类型<code>struct{}</code>。或者，导出的上下文关键变量的静态类型应该是指针或接口。</p>

<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;sync&quot;

	&quot;time&quot;
)

// context.WithValue

type TraceCode string

var wg sync.WaitGroup

func worker(ctx context.Context) {
	key := TraceCode(&quot;TRACE_CODE&quot;)
	traceCode, ok := ctx.Value(key).(string) // 在子goroutine中获取trace code
	if !ok {
		fmt.Println(&quot;invalid trace code&quot;)
	}
LOOP:
	for {
		fmt.Printf(&quot;worker, trace code:%s\n&quot;, traceCode)
		time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒
		select {
		case &lt;-ctx.Done(): // 50毫秒后自动调用
			break LOOP
		default:
		}
	}
	fmt.Println(&quot;worker done!&quot;)
	wg.Done()
}

func main() {
	// 设置一个50毫秒的超时
	ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50)
	// 在系统的入口中设置trace code传递给后续启动的goroutine实现日志数据聚合
	ctx = context.WithValue(ctx, TraceCode(&quot;TRACE_CODE&quot;), &quot;12512312234&quot;)
	wg.Add(1)
	go worker(ctx)
	time.Sleep(time.Second * 5)
	cancel() // 通知子goroutine结束
	wg.Wait()
	fmt.Println(&quot;over&quot;)
}
</code></pre>

<h3 id="使用context的注意事项">使用Context的注意事项</h3>

<ul>
<li>推荐以参数的方式显示传递Context</li>
<li>以Context作为参数的函数方法，应该把Context作为第一个参数。</li>
<li>给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO()</li>
<li>Context的Value相关方法应该传递请求域的必要数据，不应该用于传递可选参数</li>
<li>Context是线程安全的，可以放心的在多个goroutine中传递</li>
</ul>

<h3 id="客户端超时取消示例">客户端超时取消示例</h3>

<p>调用服务端API时如何在客户端实现超时控制？</p>

<h4 id="server端">server端</h4>

<pre><code class="language-go">// context_timeout/server/main.go
package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
	&quot;net/http&quot;

	&quot;time&quot;
)

// server端，随机出现慢响应

func indexHandler(w http.ResponseWriter, r *http.Request) {
	number := rand.Intn(2)
	if number == 0 {
		time.Sleep(time.Second * 10) // 耗时10秒的慢响应
		fmt.Fprintf(w, &quot;slow response&quot;)
		return
	}
	fmt.Fprint(w, &quot;quick response&quot;)
}

func main() {
	http.HandleFunc(&quot;/&quot;, indexHandler)
	err := http.ListenAndServe(&quot;:8000&quot;, nil)
	if err != nil {
		panic(err)
	}
}
</code></pre>

<h4 id="client端">client端</h4>

<pre><code class="language-go">// context_timeout/client/main.go
package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

// 客户端

type respData struct {
	resp *http.Response
	err  error
}

func doCall(ctx context.Context) {
	transport := http.Transport{
	   // 请求频繁可定义全局的client对象并启用长链接
	   // 请求不频繁使用短链接
	   DisableKeepAlives: true, 	}
	client := http.Client{
		Transport: &amp;transport,
	}

	respChan := make(chan *respData, 1)
	req, err := http.NewRequest(&quot;GET&quot;, &quot;http://127.0.0.1:8000/&quot;, nil)
	if err != nil {
		fmt.Printf(&quot;new requestg failed, err:%v\n&quot;, err)
		return
	}
	req = req.WithContext(ctx) // 使用带超时的ctx创建一个新的client request
	var wg sync.WaitGroup
	wg.Add(1)
	defer wg.Wait()
	go func() {
		resp, err := client.Do(req)
		fmt.Printf(&quot;client.do resp:%v, err:%v\n&quot;, resp, err)
		rd := &amp;respData{
			resp: resp,
			err:  err,
		}
		respChan &lt;- rd
		wg.Done()
	}()

	select {
	case &lt;-ctx.Done():
		//transport.CancelRequest(req)
		fmt.Println(&quot;call api timeout&quot;)
	case result := &lt;-respChan:
		fmt.Println(&quot;call server api success&quot;)
		if result.err != nil {
			fmt.Printf(&quot;call server api failed, err:%v\n&quot;, result.err)
			return
		}
		defer result.resp.Body.Close()
		data, _ := ioutil.ReadAll(result.resp.Body)
		fmt.Printf(&quot;resp:%v\n&quot;, string(data))
	}
}

func main() {
	// 定义一个100毫秒的超时
	ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*100)
	defer cancel() // 调用cancel释放子goroutine资源
	doCall(ctx)
}
</code></pre>

    </div>
    <div class="article-footer">
<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接: </strong>
      <a href="https://mumulx.gitee.io/2022/10/golang/" title="Golang" target="_blank" rel="external">https://mumulx.gitee.io/2022/10/golang/</a>
    </li>
    <li class="post-copyright-license">
      <strong>License：</strong><a href="https://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN</a>
    </li>
  </ul>
</blockquote>

<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gitee.com/mumulx" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="https://mumulx.gitee.io/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://gitee.com/mumulx" target="_blank"><span class="text-dark">木木就是两个木</span><small class="ml-1x">木木</small></a></h3>
        <div>愿生活不太拥挤，愿笑容不必刻意。</div>
      </div>
    </figure>
  </div>
</div>
    </div>
  </article>
<section id="comments">
</section>

</div><nav class="bar bar-footer clearfix" data-stick-bottom>
    <div class="bar-inner">
        <ul class="pager pull-left">
            <li class="prev">
                <a href="https://mumulx.gitee.io/2022/06/springbatch/" title="SpringBatch中文文档"><i
                        class="icon icon-angle-left"
                        aria-hidden="true"></i><span>&nbsp;&nbsp;下一篇</span></a>
            </li>
            <li class="next">
                <a href="https://mumulx.gitee.io/2022/10/gorm/"
                    title="GORM"><span>上一篇&nbsp;&nbsp;</span><i
                        class="icon icon-angle-right" aria-hidden="true"></i></a>
            </li>
            
            <li class="toggle-toc">
                <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false"
                    title="文章目录" role="button">
                    <span>[&nbsp;</span><span>文章目录</span>
                    <i class="text-collapsed icon icon-anchor"></i>
                    <i class="text-in icon icon-close"></i>
                    <span>]</span>
                </a>
            </li>
        </ul>
        
        <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal"
            data-target="#donateModal"><span>赏</span></button>
        
        <div class="bar-right">
            <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter"
                data-mobile-sites="weibo,qq,qzone"></div>
        </div>
    </div>
</nav>


<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content donate">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                    aria-hidden="true">&times;</span></button>
            <div class="modal-body">
                <div class="donate-box">
                    <div class="donate-head">
                        <p>感谢您的支持,我会继续努力的!</p>
                    </div>
                    <div class="tab-content">
                        <div role="tabpanel" class="tab-pane fade active in" id="alipay">
                            <div class="donate-payimg">
                                <img src="https://mumulx.gitee.io/donate/alipayimg.png"
                                    alt="扫码支持" title="扫一扫" />
                            </div>
                            <p class="text-muted mv">扫码打赏, 多少你说了算~</p>
                            <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦~</p>
                        </div>
                        <div role="tabpanel" class="tab-pane fade" id="wechatpay">
                            <div class="donate-payimg">
                                <img src="https://mumulx.gitee.io/donate/wechatpayimg.png"
                                    alt="扫码支持" title="扫一扫" />
                            </div>
                            <p class="text-muted mv">扫码打赏, 多少你说了算~</p>
                            <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
                        </div>
                    </div>
                    <div class="donate-footer">
                        <ul class="nav nav-tabs nav-justified" role="tablist">
                            <li role="presentation" class="active">
                                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay"
                                    aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
                            </li>
                            <li role="presentation" class="">
                                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab"
                                    aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i>
                                    微信支付</a>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
</main><footer class="footer" itemscope itemtype="https://schema.org/WPFooter">
<ul class="social-links">
    <li><a href="https://github.com/mumulx" target="_blank" title="github" data-toggle=tooltip data-placement=top >
            <i class="icon icon-github"></i></a></li>
    <li><a href="https://mumulx.gitee.io/index.xml" target="_blank" title="rss" data-toggle=tooltip data-placement=top >
            <i class="icon icon-rss"></i></a></li>
    <li><a href="https://weibo.com/u/5459389722" target="_blank" title="weibo" data-toggle=tooltip data-placement=top >
            <i class="icon icon-weibo"></i></a></li>
</ul>
  <div class="copyright">
    &copy;2019  -
    2023
    <div class="publishby">
        联系邮箱：<a target="_blank" title="木木的邮箱"> 1819778796@qq.com </a>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script>
   window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/highlight.min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/rust.min.js"></script>
<script type="text/javascript"
   src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script>
hljs.configure({
  tabReplace: '    ', 
  classPrefix: ''     
                      
})
hljs.initHighlightingOnLoad();
</script>
<script type="text/javascript" src="https://mumulx.gitee.io/js/application.js"></script>
<script type="text/javascript" src="https://mumulx.gitee.io/js/plugin.js"></script>
<script>
      (function (window) {
          var INSIGHT_CONFIG = {
              TRANSLATION: {
                  POSTS: '文章',
                  PAGES: '页面',
                  CATEGORIES: '分类',
                  TAGS: '标签',
                  UNTITLED: '(未命名)',
              },
              ROOT_URL: 'https:\/\/mumulx.gitee.io\/',
              CONTENT_URL: 'https:\/\/mumulx.gitee.io\/\/searchindex.json ',
          };
          window.INSIGHT_CONFIG = INSIGHT_CONFIG;
      })(window);
      </script>
<script type="text/javascript" src="https://mumulx.gitee.io/js/insight.js"></script>

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '1ccf8dc9e86b3575cfb2',
        clientSecret: '048ae422c4a6207a4e89c58ba1d4ebf820136bb0',
        repo: 'gittalk',
        owner: 'mumulx',
        admin: ['mumulx'],
        id: md5(location.pathname),
        distractionFreeMode: true
    });
    gitalk.render('comments');
</script>

  </body>
</html>
