{"categories":[{"title":"技术收录","uri":"https://mumulx.github.io/categories/%E6%8A%80%E6%9C%AF%E6%94%B6%E5%BD%95/"},{"title":"技术框架","uri":"https://mumulx.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"title":"杂七杂八","uri":"https://mumulx.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"title":"私人博客","uri":"https://mumulx.github.io/categories/%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"问题收录","uri":"https://mumulx.github.io/categories/%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95/"}],"posts":[{"content":" 搭建ssm环境  jar 表和类 配置数据库db.properties,log4j.properties 加载spring配置文件applicationContext.xml 加载springmvc配置文件applicationContext-controller.xml spring加载数据库文件 配置mybatis的sqlSessionFactory 配置psringmvc视图解析器  数据库设计 用户: 学号,登录密码,所在学院,姓名,性别,学生照片,出生日期,联系电话,家庭地址 学院: 学院id,学院名称 寻物启事: 寻物id,标题,丢失物品,物品照片,丢失时间,丢失地点,物品描述,报酬,联系电话,学生,发布时间 失物招领: 招领id,标题,物品名称,捡得时间,拾得地点,描述说明,联系人,联系电话,发布时间 认领: 认领id,招领信息,认领人,认领时间,描述说明,发布时间 表扬: 表扬id,招领信息,标题,表扬内容,表扬时间 站内通知: 通知id,标题,内容,发布时间  springmvc处理静态文件 添加配置\n\u0026lt;!-- SPringMVC基础配置、标配 --\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt; \u0026lt;!-- 处理静态资源 --\u0026gt; \u0026lt;mvc:default-servlet-handler\u0026gt;\u0026lt;/mvc:default-servlet-handler\u0026gt;  上传文件 \u0026lt;bean id=\u0026quot;multipartResolver\u0026quot; class=\u0026quot;org.springframework.web.multipart.commons.CommonsMultipartResolver\u0026quot;\u0026gt; \u0026lt;!-- 设置编码 --\u0026gt; \u0026lt;property name=\u0026quot;defaultEncoding\u0026quot; value=\u0026quot;UTF-8\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 设置上传文件的最大尺寸为2MB --\u0026gt; \u0026lt;property name=\u0026quot;maxUploadSize\u0026quot;\u0026gt; \u0026lt;value\u0026gt;2097152\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  ","id":0,"section":"posts","summary":"搭建ssm环境 jar 表和类 配置数据库db.properties,log4j.properties 加载spring配置文件applicationC","tags":["其他问题"],"title":"校园失物招领项目实战","uri":"https://mumulx.github.io/2020/02/%E6%A0%A1%E5%9B%AD%E5%A4%B1%E7%89%A9%E6%8B%9B%E9%A2%86%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/","year":"2020"},{"content":" 简介 Quartz：定时任务\nQuartz ：定时异步任务\nQuartz官网\n概念 任务：做什么事情\u0026hellip;. StudentService\n触发器：定义时间\n调度器：将任务、触发器 一一对应】\n实现步骤：（独立使用） jar jar 在quartz-2.2.1-distribution的lib中\n编写 任务\npublic class MeetingService { public void calClassMeeting(){ System.out.println(\u0026quot;需要提醒的任务(召开会议....)\u0026quot;); // try { // Thread.sleep(5000); // } catch (InterruptedException e) { // e.printStackTrace(); // } // System.out.println(\u0026quot;end.....\u0026quot;); } }  Job\n public class PlanJob implements Job { MeetingService meetingService = new MeetingService(); //jobExecutionContext可以获取 设置的各种参数值 @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { TriggerKey triggerkey = jobExecutionContext.getTrigger().getKey(); JobKey jobKey = jobExecutionContext.getJobDetail().getKey(); System.out.println(\u0026quot;----\u0026quot;); System.out.println(triggerkey+\u0026quot;\\n\u0026quot;+jobKey); JobDataMap jobDataMap = jobExecutionContext.getJobDetail().getJobDataMap(); List\u0026lt;String\u0026gt; infos = (List\u0026lt;String\u0026gt;)jobDataMap.get(\u0026quot;infos\u0026quot;); System.out.println(infos); //存放 计划执行的任务... meetingService.calClassMeeting(); } }  3.测试方法：Job 、 触发器 、调度器\n public class TestQuartz { //XxxBuilder -\u0026gt;withIdentity（）--\u0026gt;Xxx public static void main(String[] args) throws SchedulerException, InterruptedException, ParseException { // PlanJob JobBuilder jobBuilder = JobBuilder.newJob(PlanJob.class);//PlanJob PlanJob PlanJob //产生实际使用的Job JobDetail jobDetail = jobBuilder.withIdentity(\u0026quot;meeting Job\u0026quot;, \u0026quot;group1\u0026quot;).build(); //向Job的execute()中传入一些参数。。。 // JobDatMap JobDataMap jobDataMap = jobDetail.getJobDataMap(); List\u0026lt;String\u0026gt; names = Arrays.asList(new String[]{\u0026quot;zs\u0026quot;,\u0026quot;ls\u0026quot;,\u0026quot;ww\u0026quot;}); jobDataMap.put(\u0026quot;infos\u0026quot;,names); // 触发器(Trigger)：时间规则 ，依赖2个对象(TriggerBuilder ,Scheduel) TriggerBuilder\u0026lt;Trigger\u0026gt; triggerBuilder = TriggerBuilder.newTrigger(); triggerBuilder = triggerBuilder.withIdentity(\u0026quot;meeting trigger\u0026quot;, \u0026quot;group1\u0026quot;); triggerBuilder.startNow();//当满足条件时 立刻执行 // 2019-03-13 09:46:30 -- // 2019-03-13 09:46:45 SimpleDateFormat sdf = new SimpleDateFormat(\u0026quot;yyyy-MM-dd HH:mm:ss\u0026quot;); Date start = sdf.parse(\u0026quot;2019-03-13 09:46:30\u0026quot;); Date end = sdf.parse(\u0026quot;2019-03-13 09:46:45\u0026quot;); // triggerBuilder.startAt(start); // triggerBuilder.endAt(end); //scheduelBuilder：定执行的周期（时机） // SimpleScheduleBuilder scheduelBuilder = SimpleScheduleBuilder.simpleSchedule(); // scheduelBuilder.withIntervalInSeconds(1) ;//每隔1秒执行一次 // scheduelBuilder.withRepeatCount(300) ;//重复执行3次 CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(\u0026quot;5,10,15,30,45 * * * * ? *\u0026quot;); //产生触发器 CronTrigger trigger = triggerBuilder.withSchedule(cronScheduleBuilder).build(); // 调度器（工厂产生调度器） SchedulerFactory secheduleFacotry = new StdSchedulerFactory(); //产生调度器 Scheduler scheduler = secheduleFacotry.getScheduler(); //通过调度器 将 任务 和 触发器一一对应 scheduler.scheduleJob(jobDetail,trigger) ; scheduler.start(); // scheduler.shutdown(true); } }  scheduler.shutdown()：立刻关闭 scheduler.shutdown(false)：shutdown()立刻关闭 scheduler.shutdown(true)：将当前任务执行完毕后 再关闭  异步任务\n触发器：CronScheduleBuilder\nCron表达式：\n6-7个个参数，以空格隔开\n秒 分 时 天(月) 月 天（周） (年)  源码git地址\nSpring整合Quartz jar spring基础包(spring-context-support.jar/spring-tx.jar)+quartz  编写 将Job信息封装到一个 实体类中 public class ScheduleJob { //id private String jobId ; private String jobName ; private String jobGroup ; private String jobStatus ;//0:禁用 1启用 2删除 private String cronExpression ; private String desc ; public String getJobId() { return jobId; } public void setJobId(String jobId) { this.jobId = jobId; } public String getJobName() { return jobName; } public void setJobName(String jobName) { this.jobName = jobName; } public String getJobGroup() { return jobGroup; } public void setJobGroup(String jobGroup) { this.jobGroup = jobGroup; } public String getJobStatus() { return jobStatus; } public void setJobStatus(String jobStatus) { this.jobStatus = jobStatus; } public String getCronExpression() { return cronExpression; } public void setCronExpression(String cronExpression) { this.cronExpression = cronExpression; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } }  spring配置文件 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026quot;\u0026gt; \u0026lt;bean id=\u0026quot;scheduleJobEntity\u0026quot; class=\u0026quot;com.yanqun.entity.ScheduleJob\u0026quot; \u0026gt; \u0026lt;property name=\u0026quot;jobId\u0026quot; value=\u0026quot;j001\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jobName\u0026quot; value=\u0026quot;任务1\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jobGroup\u0026quot; value=\u0026quot;任务组1\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jobStatus\u0026quot; value=\u0026quot;1\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;cronExpression\u0026quot; value=\u0026quot;5,10,30,50 * * * * ? *\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;desc\u0026quot; value=\u0026quot;描述...\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026quot;jobDetail\u0026quot; class=\u0026quot;org.springframework.scheduling.quartz.JobDetailFactoryBean\u0026quot; \u0026gt; \u0026lt;property name=\u0026quot;jobClass\u0026quot; value=\u0026quot;com.yanqun.job.PlanJob\u0026quot;\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jobDataAsMap\u0026quot;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026quot;scheduleJob\u0026quot;\u0026gt; \u0026lt;ref bean=\u0026quot;scheduleJobEntity\u0026quot;\u0026gt;\u0026lt;/ref\u0026gt; \u0026lt;/entry\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 触发器：定义时间规则 \u0026lt;bean id=\u0026quot;cronTrigger\u0026quot; class=\u0026quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;jobDetail\u0026quot; ref=\u0026quot;jobDetail\u0026quot; \u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;cronExpression\u0026quot; value=\u0026quot;#{scheduleJobEntity.cronExpression}\u0026quot;\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; --\u0026gt; \u0026lt;!--SimpleTrigger--\u0026gt; \u0026lt;bean id=\u0026quot;simpleTrigger\u0026quot; class=\u0026quot;org.springframework.scheduling.quartz.SimpleTriggerFactoryBean\u0026quot; \u0026gt; \u0026lt;property name=\u0026quot;repeatInterval\u0026quot; value=\u0026quot;2000\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;repeatCount\u0026quot; value=\u0026quot;10\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;startDelay\u0026quot; value=\u0026quot;3\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jobDetail\u0026quot; ref=\u0026quot;jobDetail\u0026quot; \u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026quot;schedulerFactoryBean\u0026quot; class=\u0026quot;org.springframework.scheduling.quartz.SchedulerFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;triggers\u0026quot;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;ref bean=\u0026quot;simpleTrigger\u0026quot; /\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;  要做的事情\npublic class PlanJob implements Job { private MeetingService meetingService = new MeetingService() ; @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { meetingService.remindMeeting(); ; JobDataMap jobDataMap = jobExecutionContext.getJobDetail().getJobDataMap(); ScheduleJob job = (ScheduleJob)jobDataMap.get(\u0026quot;scheduleJob\u0026quot;); System.out.println(job.getJobId()); System.out.println(job.getJobName()); } }  测试\npublic class TestQuartzSpring { public static void main(String[] args) throws SchedulerException { //singleton:容器初始化时 ApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;applicationContext.xml\u0026quot;); // StdScheduler scheduler = (StdScheduler)context.getBean(\u0026quot;schedulerFactoryBean\u0026quot;); // scheduler.start();SchedulerFactoryBean默认会在实例化时自动启动(singleton的bean会会在ioc容器初始化时 自动加载) } }  调度器 -\u0026gt;触发器（Job、执行时间）\n源码\n","id":1,"section":"posts","summary":"简介 Quartz：定时任务 Quartz ：定时异步任务 Quartz官网 概念 任务：做什么事情\u0026hellip;. StudentService 触发器：定义时间 调度器：将任务、触发器 一一","tags":["Spring家族"],"title":"Quartz框架","uri":"https://mumulx.github.io/2020/01/quartz%E6%A1%86%E6%9E%B6/","year":"2020"},{"content":" 软件发展史  All In One\n所有代码在一个类/模块中编写容易造成代码混乱\n MVC/三层架构\n将各个功能根据层次进行了划分，但是所有代码任然在同一台计算机中编写，并发能力有限\n RPC\n使用RPC，可以让一个项目部署在不同的计算机中但是此种模式的ip+是端口号比较分散，有一定的维护难度\n SOA：面向服务的架构\n客户端服务端注册中心\n  dubbo（阿里巴巴产品）\n 运行提供方提供的服务 发布服务 订阅服务 推送服务(notify)\n实施监听服务方是否发生改变\n 调用\n  开发dubbo程序 准备环境 linux中安装注册中心zookeeper  linux中安装jdk\n下载jdk-8u171-linux-x64.rpm\n安装\nrpm -ivh jdk-8u171-linux-x64.rpm  会自动安装到usr目录中的java中，\n通过pwd命令，查看jdk安装路径：/usr/java/jdk1.8.0_171-amd64  配置环境变量：\nvi /etc/profile，在文件最后追加： export JAVA_HOME=/usr/java/jdk1.8.0_171-amd64 export CLASSPATH=$JAVA_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$PATH  刷新环境变量\nsource /etc/profile  安装zookeeper\n下载zookeeper，官网\n解压\ntar -zxvf zookeeper-3.4.14.tar.gz  重命名zookeeper的配置文件：\ncd zookeeper-3.4.14/conf/ mv zoo_sample.cfg zoo.cfg  在zoo.cfg中：可以发现\nzookeeper的端口号是 clientPort=2181  设置zookeeper存放数据的目录：\ndataDir=/app/zookeeper-3.4.14/data  启动zookeeper：\ncd /app/zookeeper-3.4.14/ bin/zkServer.sh start bin/zkServer.sh start 启动 bin/zkServer.sh stop 关闭 bin/zkServer.sh status 查看状态   ### 新建服务端\nsts新建maven工程\n添加WEB-INF/web.xml文件\n添加依赖pom.xml\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;org.dubbo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;students-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;!-- 统一版本号 --\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;spring.version\u0026gt;4.3.17.RELEASE\u0026lt;/spring.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-beans\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-aspects\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jms\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context-support\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- dubbo组件 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- zookeeper --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.zookeeper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zookeeper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- zookeeper客户端 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.sgroschupf\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zkclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.javassist\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javassist\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.21.0-GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.7.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;encoding\u0026gt;UTF8\u0026lt;/encoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- 给maven项目 内置一个tomcat，之后 可以直接运行 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat7-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;port\u0026gt;8881\u0026lt;/port\u0026gt; \u0026lt;path\u0026gt;/\u0026lt;/path\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt;  接口及实现类：（具体的服务）\npublic interface StudentServer { public String server(String name);//zs } @Service//阿里巴巴提供的@Service注解 public class StudentServerImpl implements StudentServer{ public String server(String name) { return \u0026quot;server:\u0026quot; +name; } }  配置工作：\n继承spring:web.xml\n\t\u0026lt;web-app xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns=\u0026quot;http://java.sun.com/xml/ns/javaee\u0026quot; xsi:schemaLocation=\u0026quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\u0026quot; id=\u0026quot;WebApp_ID\u0026quot; version=\u0026quot;2.5\u0026quot;\u0026gt; \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;org.springframework.web.context.ContextLoaderListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; \u0026lt;/web-app\u0026gt;  配置spring: applicationContext.xml\n\t\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot; xmlns:dubbo=\u0026quot;http://code.alibabatech.com/schema/dubbo\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\u0026quot;\u0026gt; \u0026lt;!-- \u0026lt;bean id=\u0026quot;\u0026quot; class=\u0026quot;org.students.server.impl.StudentServerImpl\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; --\u0026gt; \u0026lt;!-- 配置dubbo的应用名称 --\u0026gt; \u0026lt;dubbo:application name=\u0026quot;students-server\u0026quot; /\u0026gt; \u0026lt;!-- 配置注册中心地址 --\u0026gt; \u0026lt;dubbo:registry protocol=\u0026quot;zookeeper\u0026quot; address=\u0026quot;zookeeper://192.168.2.128:2181\u0026quot; /\u0026gt; \u0026lt;!-- 配置dubbo扫描包 ：将@Service所在包 放入 dubbo扫描中，供后续 dubbo在rpc时使用--\u0026gt; \u0026lt;dubbo:annotation package=\u0026quot;org.students.server.impl\u0026quot; /\u0026gt; \u0026lt;!-- 将@Service所在包 放入springIOC容器中，供后续 依赖注入时使用 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;org.student.service.impl\u0026quot;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;/beans\u0026gt;  消费方代码：  引入依赖(jar)\npom.xml (与服务方pom.xml一致，改端口号；并设置客户端自己的gav)\n 补齐web工程需要的 WEB-INF/web.xml\n\u0026lt;web-app xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns=\u0026quot;http://java.sun.com/xml/ns/javaee\u0026quot; xsi:schemaLocation=\u0026quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\u0026quot; id=\u0026quot;WebApp_ID\u0026quot; version=\u0026quot;2.5\u0026quot;\u0026gt; \u0026lt;!-- 解决post乱码 --\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;CharacterEncodingfilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;foreEncoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CharacterEncodingfilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;*.action\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt;  配置springmvc（通过springmvc 来访问 提供方）\n\t\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns:mvc=\u0026quot;http://www.springframework.org/schema/mvc\u0026quot; xmlns:dubbo=\u0026quot;http://code.alibabatech.com/schema/dubbo\u0026quot; xmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\u0026quot;\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;!-- 此配置的目的：将Controller中的内容 直接打印到 浏览器中 --\u0026gt; \u0026lt;mvc:message-converters register-defaults=\u0026quot;false\u0026quot;\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.http.converter.StringHttpMessageConverter\u0026quot;\u0026gt; \u0026lt;constructor-arg value=\u0026quot;UTF-8\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; \u0026lt;!-- 配置dubbo的应用名称 --\u0026gt; \u0026lt;dubbo:application name=\u0026quot;students-consumer\u0026quot;/\u0026gt; \u0026lt;!-- 配置注册中心地址 --\u0026gt; \u0026lt;dubbo:registry address=\u0026quot;zookeeper://192.168.2.128:2181\u0026quot; /\u0026gt; \u0026lt;!-- 配置dubbo扫描包 --\u0026gt; \u0026lt;dubbo:annotation package=\u0026quot;org.controller\u0026quot;/\u0026gt; \u0026lt;!-- 将控制器@Controller所在包 加入IOC容器 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;org.controller\u0026quot;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;/beans\u0026gt;   编写控制器代码：用于访问 服务方提供的服务代码\npackage org.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.students.server.StudentServer; import com.alibaba.dubbo.config.annotation.Reference; //@Controller //@ResponseBody @RestController @RequestMapping(\u0026quot;controller\u0026quot;) public class StudentController { @Reference private StudentServer stuServer ; @RequestMapping(\u0026quot;rpcSerer\u0026quot;) public String rpcSerer() { String result = stuServer.server(\u0026quot;zs\u0026quot;) ; return result ;//将结果显示在控制台 } }  浏览器访问\nhttp://localhost:8882/controller/rpcServer.action  ","id":2,"section":"posts","summary":"软件发展史 All In One 所有代码在一个类/模块中编写容易造成代码混乱 MVC/三层架构 将各个功能根据层次进行了划分，但是所有代码任然在同一台计算机中编","tags":["杂七杂八"],"title":"Dubbo自学笔记","uri":"https://mumulx.github.io/2020/01/dubbo%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","year":"2020"},{"content":" 系统使用的Linux Centos6\nMySQL版本： 5.x:\n5.0-5.1:早期产品的延续，升级维护\n5.4 - 5.x : MySQL整合了三方公司的新存储引擎 （推荐5.5） 本次使用的是 * MySQL-client-5.5.58-1.el6.x86_64.rpm * MySQL-server-5.5.58-1.el6.x86_64.rpm\n安装：rpm -ivh rpm软件名\nrpm -ivh MySQL-server-5.5.58-1.el6.x86_64.rpm  如果安装时 与某个软件 xxx冲突，则需要将冲突的软件卸载掉：\nyum -y remove xxx yum -y remove mysql-libs-5.1.73-8.el6*  安装时 有日志提示我们可以修改密码：\nPLEASE REMEMBER TO SET A PASSWORD FOR THE MySQL root USER ! To do so, start the server, then issue the following commands: /usr/bin/mysqladmin -u root password 'new-password' /usr/bin/mysqladmin -u root -h localhost.centos6 password 'new-password'  rpm -ivh MySQL-client-5.5.58-1.el6.x86_64.rpm  注意：\n如果提示“GPG keys\u0026hellip;”安装失败，解决方案：\n rpm -ivh rpm软件名 --force --nodoeps  验证：\nmysqladmin --version  启动mysql应用： service mysql start 关闭： service mysql stop 重启： service mysql restart  在计算机reboot后 登陆MySQL :\n mysql  退出mysql\nexit  可能会报错：\n \u0026quot;/var/lib/mysql/mysql.sock不存在\u0026quot;  \u0026ndash;原因：是Mysql服务没有启动\n解决 ：\n启动服务： 1. 每次使用前 手动启动服务\n /etc/init.d/mysql start   开机自启\nchkconfig mysql on 开启开机自启 chkconfig mysql off 关闭开机自启 ntsysv 检查开机是否自动启动：   给mysql 的超级管理员root 增加密码：\n/usr/bin/mysqladmin -u root password root  登陆：\nmysql -u root -p 回车之后输入密码  数据库存放目录：\nps -ef|grep mysql 可以看到： 数据库目录： datadir=/var/lib/mysql pid文件目录： --pid-file=/var/lib/mysql/bigdata01.pid  MySQL核心目录：\n/var/lib/mysql :mysql 安装目录 /usr/share/mysql: 配置文件 /usr/bin：命令目录（mysqladmin、mysqldump等） /etc/init.d/mysql启停脚本  MySQL配置文件\nmy-huge.cnf 高端服务器 1-2G内存 my-large.cnf 中等规模 my-medium.cnf 一般 my-small.cnf 较小  但是，以上配置文件mysql默认不能识别，默认只能识别\n/etc/my.cnf  因此需要将上面四个文件之一复制到默认配置文件中\n采用 my-huge.cnf ：\ncp /usr/share/mysql/my-huge.cnf /etc/my.cnf  注意 mysql5.5默认配置文件\n/etc/my.cnf；  Mysql5.6 默认配置文件\n/etc/mysql-default.cnf  默认端口 3306\nmysql字符编码：\nsql :\nshow variables like '%char%';  可以发现部分编码是 latin,需要统一设置为utf-8\n设置编码：\nvi /etc/my.cnf [mysql] default-character-set=utf8 [client] default-character-set=utf8 [mysqld] character_set_server=utf8 character_set_client=utf8 collation_server=utf8_general_ci  重启Mysql:\nservice mysql restart  sql :\nshow variables like '%char%' ;  注意事项：修改编码 只对“之后”创建的数据库生效，因此 我们建议 在mysql安装完毕后，第一时间 统一编码。\nmysql:清屏\nctrl+L system clear  原理 MYSQL逻辑分层 ：连接层 服务层 引擎层 存储层\nInnoDB(默认) ：事务优先 （适合高并发操作；行锁）\nMyISAM ：性能优先 （表锁）\n查询数据库引擎： 支持哪些引擎？\nshow engines ;  查看当前使用的引擎\nshow variables like '%storage_engine%' ;  指定数据库对象的引擎：\ncreate table tb( id int(4) auto_increment , name varchar(5), dept varchar(5) , primary key(id) )ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ;  由Welcome to the MySQL monitor. Commands end with ; or \\g.可知sql语句的结尾符有两种;和\\g\nSQL优化 原因：性能低、执行时间太长、等待时间太长、SQL语句欠佳（连接查询）、索引失效、服务器参数设置不合理（缓冲、线程数）\n参考文章\nSQL ： 编写过程：\nselect dinstinct ..from ..join ..on ..where ..group by ...having ..order by ..limit ..  解析过程：\nfrom .. on.. join ..where ..group by ....having ...select dinstinct ..order by limit ...  SQL优化， 主要就是 在优化索引 索引： 相当于书的目录\n索引： index是帮助MYSQL高效获取数据的数据结构。索引是数据结构（树：B树(默认)、Hash树\u0026hellip;）\n索引的弊端：\n 索引本身很大， 可以存放在内存/硬盘（通常为 硬盘） 索引不是所有情况均适用： a.少量数据 b.频繁更新的字段 c.很少使用的字段 索引会降低增删改的效率，提高查询的效率（增删改 查）  优势：\n 提高查询效率（降低IO使用率）\n 降低CPU使用率 （\u0026hellip;order by age desc,因为 B树索引 本身就是一个 好排序的结构，因此在排序时 可以直接使用）\n  三层Btree可以存放上百万条的数据\nBtree：一般指B+树，数据全部存放在叶结点中\nB+树中查询任意的数据的次数：n次(B+树的高度)\n索引 分类： 主键索引： 不能重复。id 不能是null\n唯一索引 ：不能重复。id 可以是null\n单值索引 ： 单列， age ;一个表可以多个单值索引,name。\n复合索引 ：多个列构成的索引 （相当于 二级目录 ： z: zhao） (name,age) (a,b,c,d,\u0026hellip;,n)\n创建索引： 方式一：\ncreate 索引类型 索引名 on 表(字段) 单值： create index dept_index on tb(dept); 唯一： create unique index name_index on tb(name) ; 复合索引 create index dept_name_index on tb(dept,name);  方式二：\nalter table 表名 索引类型 索引名（字段） 单值： alter table tb add index dept_index(dept) ; 唯一： alter table tb add unique index name_index(name); 复合索引 alter table tb add index dept_name_index(dept,name);  注意：如果一个字段是primary key，则改字段默认就是 主键索引\n此时的语句是DDL，会自动提交，因此不需要commit;\nDML语句需要自己commit，增删改\n删除索引：\ndrop index 索引名 on 表名 ; drop index name_index on tb ;  查询索引：\nshow index from 表名 ; show index from 表名 \\G  注意：结尾符需要写成\\G,结果以行的顺序以列的形式显示出来\nSQL性能问题  分析SQL的执行计划 : explain ，可以模拟SQL优化器执行SQL语句，从而让开发人员 知道自己编写的SQL状况 MySQL查询优化器会干扰我们的优化  优化方法，官网\n查询执行计划：\nexplain +SQL语句 explain select * from tb ;   id : 编号\tselect_type ： 查询类型 table ： 表 type ： 类型 possible_keys ： 预测用到的索引 key ： 实际使用的索引 key_len ： 实际使用索引的长度 ref : 表之间的引用 rows ： 通过索引查询到的数据量 Extra: 额外的信息  准备数据： create table course ( cid int(3), cname varchar(20), tid int(3) ); create table teacher ( tid int(3), tname varchar(20), tcid int(3) ); create table teacherCard ( tcid int(3), tcdesc varchar(200) ); insert into course values(1,'java',1); insert into course values(2,'html',1); insert into course values(3,'sql',2); insert into course values(4,'web',3); insert into teacher values(1,'tz',1); insert into teacher values(2,'tw',2); insert into teacher values(3,'tl',3); insert into teacherCard values(1,'tzdesc') ; insert into teacherCard values(2,'twdesc') ; insert into teacherCard values(3,'tldesc') ;  查询课程编号为2 或 教师证编号为3 的老师信息\nSQL语句\nselect t.* from teacherCard tc,course c,teacher t where c.tid = t.tid and t.tcid = tc.tcid and (c.cid = 2 or tc.tcid=3);  explain +sql:  id:  id值相同，从上往下 顺序执行。\nt(3)-tc(3)-c(4)  t表中添加数据后在执行\ntc（3）--c（4）-（t6）  表的执行顺序 因数量的个数改变而改变的原因： 笛卡儿积\n a b c 2 3 4 = 2*3=6 * 4 =24 3 4 2 = 3*4=12* 2 =24  虽然结果最终的结果相同但是中间的过程是不同的，程序喜欢数据越小越好。\n数据小的表 优先查询；\n id值不同：id值越大越优先查询 (本质：在嵌套子查询时，先查内层 再查外层)\n查询教授SQL课程的老师的描述（desc）\n explain select tc.tcdesc from teacherCard tc,course c,teacher t where c.tid = t.tid and t.tcid = tc.tcid and c.cname = 'sql' ;  将以上 多表查询 转为子查询形式：\nexplain select tc.tcdesc from teacherCard tc where tc.tcid = (select t.tcid from teacher t where t.tid = (select c.tid from course c where c.cname = 'sql') );  子查询+多表：\nexplain select t.tname ,tc.tcdesc from teacher t,teacherCard tc where t.tcid= tc.tcid and t.tid = (select c.tid from course c where cname = 'sql') ;   结论: id值有相同，又有不同： id值越大越优先；id值相同，从上往下 顺序执行\nselect_type:查询类型 PRIMARY:包含子查询SQL中的 主查询 （最外层）\nSUBQUERY：包含子查询SQL中的 子查询 （非最外层）\nsimple:简单查询（不包含子查询、union）\nderived:衍生查询(使用到了临时表)\n 在from子查询中只有一张表\nexplain select cr.cname from ( select * from course where tid in (1,2) ) cr ;  在from子查询中， 如果有table1 union table2 ，则table1 就是derived,table2就是union\nexplain select cr.cname from ( select * from course where tid = 1 union select * from course where tid = 2 ) cr ;   union:上例\nunion result :告知开发人员，那些表之间存union查询\nsystem \u0026gt; const \u0026gt; eq_ref \u0026gt; ref \u0026gt; fulltext \u0026gt; ref_or_null \u0026gt; index_merge \u0026gt; unique_subquery \u0026gt; index_subquery \u0026gt; range \u0026gt; index \u0026gt; ALL  type:索引类型、类型 system\u0026gt;const\u0026gt;eq_ref\u0026gt;ref\u0026gt;range\u0026gt;index\u0026gt;all ，要对type进行优化的前提：有索引  越往左边性能越高\n其中：system,const只是理想情况；实际能达到 ref\u0026gt;range\nsystem（忽略，不切实际。。）: 只有一条数据的系统表 ；或 衍生表只有一条数据的主查询\ncreate table test01 ( tid int(3), tname varchar(20) ); insert into test01 values(1,'a') ; commit;  增加索引（主键索引）\nalter table test01 add constraint tid_pk primary key(tid) ; explain select * from (select * from test01 )t where tid =1 ;  const:仅仅能查到一条数据的SQL ,用于Primary key 或unique索引 （类型 与索引类型有关）\nexplain select tid from test01 where tid =1 ;  删除主键索引，创建一个一般索引\nalter table test01 drop primary key ; create index test01_index on test01(tid) ;  则不行\neq_ref:唯一性索引：对于每个索引键的查询，返回匹配唯一行数据（有且只有1个，不能多 、不能0） select \u0026hellip; from ..where name = \u0026hellip; .常见于唯一索引 和主键索引。\n增加主键\nalter table teacherCard add constraint pk_tcid primary key(tcid); alter table teacher add constraint uk_tcid unique index(tcid) ; explain select t.tcid from teacher t,teacherCard tc where t.tcid = tc.tcid ;  以上SQL，用到的索引是 t.tcid,即teacher表中的tcid字段；如果teacher表的数据个数 和 连接查询的数据个数一致（都是3条数据），则有可能满足eq_ref级别；否则无法满足。\nref：非唯一性索引，对于每个索引键的查询，返回匹配的所有行（0，多）\n准备数据：\ninsert into teacher values(4,'tz',4) ; insert into teacherCard values(4,'tz222');  测试：\nalter table teacher add index index_name (tname) ; explain select * from teacher where tname = 'tz';  range：检索指定范围的行 ,where后面是一个范围查询(between ,\u0026gt; \u0026lt; \u0026gt;=, 特殊:in有时候会失效 ，从而转为 无索引all)\nalter table teacher add index tid_index (tid) ; explain select t.* from teacher t where t.tid in (1,2) ; explain select t.* from teacher t where t.tid \u0026lt;3 ;  index：查询全部索引中数据\nexplain select tid from teacher ;  \u0026ndash;tid 是索引，只需要扫描索引表，不需要查询所有表中的所有数据\nall：查询全部表中的数据\nexplain select cid from course ;  \u0026ndash;cid不是索引，需要全表扫描，即需要查询所有表中的所有数据\n小结 system/const: 结果只有一条数据\neq_ref:结果多条；但是每条数据是唯一的 ；\nref：结果多条；但是每条数据是是0或多条 ；\npossible_keys ：可能用到的索引，是一种预测，不准。 alter table course add index cname_index (cname); explain select t.tname ,tc.tcdesc from teacher t,teacherCard tc where t.tcid= tc.tcid and t.tid = (select c.tid from course c where cname = 'sql') ;  如果 possible_key/key是NULL，则说明没用索引\nexplain select tc.tcdesc from teacherCard tc,course c,teacher t where c.tid = t.tid and t.tcid = tc.tcid and c.cname = 'sql' ;  key ：实际使用到的索引 key_len ：索引的长度 ; 作用：用于判断复合索引是否被完全使用\ncreate table test_kl ( name char(20) not null default '' ); alter table test_kl add index index_name(name) ; explain select * from test_kl where name ='' ;  \u0026ndash; key_len :60\n在utf8：1个字符站3个字节\nalter table test_kl add column name1 char(20) ; --name1可以为null alter table test_kl add index index_name1(name1) ; explain select * from test_kl where name1 ='' ;  \u0026ndash;如果索引字段可以为Null,则会使用1个字节用于标识。\ndrop index index_name on test_kl ; drop index index_name1 on test_kl ;  增加一个复合索引\nalter table test_kl add index name_name1_index (name,name1) ; explain select * from test_kl where name1 = '' ;  \u0026ndash;121；用到了name1，但是name1和name符合起来了，因此两者都被使用。20*3+20*3+1=121\nexplain select * from test_kl where name = '' ;  \u0026ndash;60；只用到了name，20*3=60\nvarchar(20)\nalter table test_kl add column name2 varchar(20) ;  \u0026ndash;可以为Null\nalter table test_kl add index name2_index (name2) ; explain select * from test_kl where name2 = '' ;  \u0026ndash;63\n20*3=60 + 1(null) +2(用2个字节 标识可变长度) =63\nutf8:1个字符3个字节\ngbk:1个字符2个字节\nlatin:1个字符1个字节\nref : 注意与type中的ref值区分。 作用： 指明当前表所参照的字段。\nselect ....where a.c = b.x ;(其中b.x可以是常量，const a表中c字段引用了b表中的x字段) alter table course add index tid_index (tid) ; explain select * from course c,teacher t where c.tid = t.tid and t.tname ='tw' ;  rows: 被索引优化查询的 数据个数 (实际通过索引而查询到的 数据个数) explain select * from course c,teacher t where c.tid = t.tid and t.tname = 'tz' ;  Extra： using filesort ： 性能消耗大；需要“额外”的一次排序（查询） 。常见于 order by 语句中。\n排序之前要先查询\ncreate table test02 ( a1 char(3), a2 char(3), a3 char(3), index idx_a1(a1), index idx_a2(a2), index idx_a3(a3) ); explain select * from test02 where a1 ='' order by a1 ; explain select * from test02 where a1 ='' order by a2 ;  \u0026ndash;using filesort 根据a2排序但是a2没查，因此需要额外的一次查询\n小结：对于单索引， 如果排序和查找是同一个字段，则不会出现using filesort；如果排序和查找不是同一个字段，则会出现using filesort；\n避免： where哪些字段，就order by那些字段\n复合索引：不能跨列（最佳左前缀）\ndrop index idx_a1 on test02; drop index idx_a2 on test02; drop index idx_a3 on test02; alter table test02 add index idx_a1_a2_a3 (a1,a2,a3) ; explain select *from test02 where a1='' order by a3 ;  \u0026ndash;using filesort\nexplain select *from test02 where a2='' order by a3 ;  \u0026ndash;using filesort\nexplain select *from test02 where a1='' order by a2 ;  没有\u0026ndash;using filesort\nexplain select *from test02 where a2='' order by a1 ;  \u0026ndash;using filesort\n小结：避免： where和order by 按照复合索引的顺序使用，不要跨列或无序使用。\nusing temporary: 性能损耗大 ，用到了临时表。一般出现在group by 语句中。\nexplain select a1 from test02 where a1 in ('1','2','3') group by a1 ;  没有\u0026ndash;using temporary\nexplain select a1 from test02 where a1 in ('1','2','3') group by a2 ;  \u0026ndash;using temporary\n避免：查询那些列，就根据那些列 group by .\nusing temporary:需要额外再多使用一张表. 一般出现在group by语句中；已经有表了，但不适用，必须再来一张表。\n解析过程：\nfrom .. on.. join ..where ..group by ....having ...select dinstinct ..order by limit ...   explain select * from test03 where a2=2 and a4=4 group by a2,a4 ;  \u0026ndash;没有using temporary；先where a2\\a4在group by a2\\a4,在原先的基础上在分组，因此没有用到额外的一张表 * explain select * from test03 where a2=2 and a4=4 group by a3 ; \u0026ndash;using temporary；先where a2\\a4在group by a3，在原先的基础上按照a3进行分组，因此用到额外的一张表a3\n  using index : 性能提升; 索引覆盖（覆盖索引）。\n原因：不读取原文件，只从索引文件中获取数据 （不需要回表查询）\n只要使用到的列 全部都在索引中，就是索引覆盖using index\n例如：test02表中有一个复合索引(a1,a2,a3)\nexplain select a1,a2 from test02 where a1='' or a2= '' ;  \u0026ndash;using index\ndrop index idx_a1_a2_a3 on test02; alter table test02 add index idx_a1_a2(a1,a2) ; explain select a1,a3 from test02 where a1='' or a3= '' ;  没有\u0026ndash;using index\n如果用到了索引覆盖(using index时)，会对 possible_keys和key造成影响：\n 如果没有where，则索引只出现在key中；\n 如果有where，则索引 出现在key和possible_keys中。\nexplain select a1,a2 from test02 where a1='' or a2= '' ; explain select a1,a2 from test02 ;   using where （需要回表查询） 假设age是索引列，但查询语句select age,name from \u0026hellip;where age =\u0026hellip;,此语句中必须回原表查Name，因此会显示using where.\nexplain select a1,a3 from test02 where a3 = '' ;  \u0026ndash;a3需要回原表查询\nimpossible where ： where子句永远为false explain select * from test02 where a1='x' and a1='y' ;  优化实例 create table test03( a1 int(4) not null, a2 int(4) not null, a3 int(4) not null, a4 int(4) not null ); alter table test03 add index idx_a1_a2_a3_a4(a1,a2,a3,a4);  explain select a1,a2,a3,a4 from test03 where a1=1 and a2=1 and a3=1 and a4=1;  \u0026ndash;推荐写法，因为索引的使用属性顺序（where）后面的顺序和复合索引的顺序一致\nexplain select a1,a2,a3,a4 from test03 where a4=1 and a3=1 and a2=1 and a1=1;  虽然编写的顺序和索引的顺序不一致，但是我们发现两者结果一致：是因为mysql的服务层的sql优化器对该语句进行了优化\n以上2个sql，使用了全部的符合索引\nexplain select a1,a2,a3,a4 from test03 where a1=1 and a2=1 and a4=1 order by a3;  以上sql用到了a1，a2两个索引\na1,a2按顺序，显示using index，不需要回表查询\na4:无效索引，因为跨列使用会回表查询显示using where\n可以通过key_len校验 ：8\nexplain select a1,a2,a3,a4 from test03 where a1=1 and a4=1 order by a3;  \u0026ndash;using filesort(文件内排序，“多了一次额外的查找、排序”) 不要跨列使用(where和order by拼起来不要跨列使用)\n上面\na1\u0026ndash;a2\u0026ndash;（a4失效）\u0026ndash;a3\n1-2-3\n结果没有跨列\n现在\na1\u0026ndash;(a4无效)\u0026ndash;a3\n1-3结果跨列\nexplain select a1,a2,a3,a4 from test03 where a1=1 and a4=1 order by a2,a3;  结果没有\u0026ndash;using filesort，没有进行跨列使用\n小结：\n如果（a,b,c,d）复合索引和使用的顺序一致（且不跨列使用），则复合索引全部使用。如果部分一致，则使用部分索引\nwhere和order by拼起来，不要跨列使用\nusing temporary:需要额外再多使用一张表. 一般出现在group by语句中；已经有表了，但不适用，必须再来一张表。\n解析过程：\nfrom .. on.. join ..where ..group by \u0026hellip;.having \u0026hellip;select dinstinct ..order by limit \u0026hellip;\n* explain select * from test03 where a2=2 and a4=4 group by a2,a4 ;\u0026ndash;没有using temporary * explain select * from test03 where a2=2 and a4=4 group by a3 ;\n优化案例 单表优化、两表优化、三表优化\n单表优化 create table book ( bid int(4) primary key, name varchar(20) not null, authorid int(4) not null, publicid int(4) not null, typeid int(4) not null ); insert into book values(1,'tjava',1,1,2) ; insert into book values(2,'tc',2,1,2) ; insert into book values(3,'wx',3,2,1) ; insert into book values(4,'math',4,2,3) ; commit;  查询authorid=1且 typeid为2或3的 bid\nexplain select bid from book where typeid in(2,3) and authorid=1 order by typeid desc ;  优化：加索引\nalter table book add index idx_bta (bid,typeid,authorid);  索引一旦进行 升级优化，需要将之前废弃的索引删掉，防止干扰。\ndrop index idx_bta on book;  根据SQL实际解析的顺序，调整索引的顺序：\nalter table book add index idx_tab (typeid,authorid,bid);  \u0026ndash;虽然可以回表查询bid，但是将bid放到索引中 可以提升使用using index ;\n再次优化（之前是index级别）：思路,因为范围查询in有时会实现，因此交换 索引的顺序，将typeid in(2,3) 放到最后。\ndrop index idx_tab on book; alter table book add index idx_atb (authorid,typeid,bid); explain select bid from book where authorid=1 and typeid in(2,3) order by typeid desc ;  \u0026ndash;小结：\n 最佳左前缀，保持索引的定义和使用的顺序一致性\n 索引需要逐步优化\n 将含In的范围查询 放到where条件的最后，防止失效。  本例中同时出现了Using where（需要回原表）; Using index（不需要回原表）：\n原因，where authorid=1 and typeid in(2,3)中authorid在索引(authorid,typeid,bid)中，因此不需要回原表（直接在索引表中能查到）；\n而typeid虽然也在索引(authorid,typeid,bid)中，但是含in的范围查询已经使该typeid索引失效，因此相当于没有typeid这个索引，所以需要回原表（using where）；\n例如以下没有了In，则不会出现using where\nexplain select bid from book where authorid=1 and typeid =3 order by typeid desc ;  还可以通过key_len证明in可以使索引失效。\n两表优化 create table teacher2 ( tid int(4) primary key, cid int(4) not null ); insert into teacher2 values(1,2); insert into teacher2 values(2,1); insert into teacher2 values(3,3); create table course2 ( cid int(4) , cname varchar(20) ); insert into course2 values(1,'java'); insert into course2 values(2,'python'); insert into course2 values(3,'kotlin'); commit;  左连接：\nexplain select *from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname='java';  索引往哪张表加？\n 小表驱动大表 (where 小表.x = 大表.y) 索引建立经常使用的字段上 （本题 t.cid=c.cid可知，t.cid字段使用频繁，因此给该字段加索引）,一般情况对于左外连接，给左表加索引；右外连接，给右表加索引\n 小表:10 大表:300 select ...where 小表.x10=大表.x300 ; for(int i=0;i\u0026lt;小表.length10;i++) { for(int j=0;j\u0026lt;大表.length300;j++) { ... } } select ...where 大表.x300=小表.x10 ; for(int i=0;i\u0026lt;大表.length300;i++) { for(int j=0;j\u0026lt;小表.length10;j++) { ... } }   以上2个FOR循环，最终都会循环3000次；但是 对于双层循环来说：一般建议 将数据小的循环 放外层；数据大的循环放内层。小表驱动大表\n 当编写 ..on t.cid=c.cid 时，将数据量小的表 放左边（假设此时t表数据量小） 优化\n\talter table teacher2 add index index_teacher2_cid(cid) ; alter table course2 add index index_course2_cname(cname);  \texplain select *from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname='java';    Using join buffer:extra中的一个选项，作用：Mysql引擎使用了 连接缓存。\n左连接（left join）即为两张表进行连接时,是以处于left join语句左侧的表为基准去匹配left join语句右边的表，如果左表中的一条数据在右表中能找到与之对应的一条数据，那么就会出现在以虚表形式存在的结果表中，如果没有找到，那么会以null来代替右表中的数据去匹配左表。这样会有一个鲜明的对比，左表中的每一条数据中的对象在右表中的某个属性的存在性是一目了然的。同时在使用on 进行连接时，on的作用仅仅是进行两张表的上诉连接，发挥匹配的功能，它选出来的是满足这种匹配的所有结果，而并不一定是用户所需要的，这时候就要使用where进行条件判断，从而筛选出真正需要的信息。\n右连接（right join）本质上是相当于将上述的左连接的这个过程反过来，以连接语句right join右侧的表为基准去匹配左边的表，剩下的道理是一样的，不再赘述。\n内连接（inner join）就是在用两张表进行匹配的时候，如果表中任意一条数据在另一张表中都是找不到对应数据的话，那么在结果表中是不会有这一条数据的。也就是说必须是两张表中任意两条能够互相对应着的数据才能被存入到结果表中，有点类似于取交集的味道。这种适用于一旦某条数据为空便没有意义的场景，这时给它设成null也就毫无意义了。表中的数据也因此显得简练很多。\n外链接（outer join）与内连接是相反的，就是说，如果某张表中的数据在另一张中找不到对应的条目并不影响它依然出现在查询的结果中，这对于两张表都是满足的，两边都有出现null的可能，这就有一点数学里的并集的意思。\n自连接(self join)可能看起来有点晦涩难懂，但是实际上换个角度你就会豁然开朗，你可以把它这个过程想象成两张一样的表进行左连接或右连接，这样就会简单多了，其中一张表通过设别名的方式成为了虚表，但是共享原标中的信息。应用场景是这样的，就是表的一个字段和另一个字段是相同性质的东西，譬如员工与上司，他们本质也都是员工，在员工表中，员工的直接上司编号会以另一个字段的形式出现，但是他的上司的编号也是会出现在员工编号这个字段里。那么在这种情况下，假如需要去查询某一位员工的上司的信息，在已知该员工编号的条件下，可以根据他的编号去获得上司的编号，进而通过上司的编号去获得上司的信息。\n三张表优化A B C  小表驱动大表\n 索引建立在经常查询的字段上  避免索引失效的一些原则 复合索引  复合索引，不要跨列或无序使用（最佳左前缀）\n 复合索引，尽量使用全索引匹配\n  不要在索引上进行任何操作（计算、函数、类型转换），否则索引失效 select ..where A.x = .. ; --假设A.x是索引 不要：select ..where A.x*3 = .. ; explain select * from book where authorid = 1 and typeid = 2 ;--用到了at2个索引 explain select * from book where authorid = 1 and typeid*2 = 2 ;--用到了a1个索引 explain select * from book where authorid*2 = 1 and typeid*2 = 2 ;----用到了0个索引 explain select * from book where authorid*2 = 1 and typeid = 2 ;----用到了0个索引,  原因：对于复合索引，如果左边失效，右侧全部失效。(a,b,c)，例如如果 b失效，则b c同时失效。\ndrop index idx_atb on book ; alter table book add index idx_authroid (authorid) ; alter table book add index idx_typeid (typeid) ;  独立索引，不影响\nexplain select * from book where authorid*2 = 1 and typeid = 2 ;  复合索引不能使用不等于（!= \u0026lt;\u0026gt;）或is null (is not null)，否则自身以及右侧所有全部失效。 复合索引中如果有\u0026gt;，则自身和右侧索引全部失效。\nexplain select * from book where authorid = 1 and typeid =2 ;  \u0026ndash; SQL优化，是一种概率层面的优化。至于是否实际使用了我们的优化，需要通过explain进行推测。\nexplain select * from book where authorid != 1 and typeid =2 ; explain select * from book where authorid != 1 and typeid !=2 ;  体验概率情况(\u0026lt; \u0026gt; =)：\n原因是服务层中有SQL优化器，可能会影响我们的优化。\ndrop index idx_typeid on book; drop index idx_authroid on book; alter table book add index idx_book_at (authorid,typeid); explain select * from book where authorid = 1 and typeid =2 ;  \u0026ndash;复合索引at全部使用\nexplain select * from book where authorid \u0026gt; 1 and typeid =2 ;  \u0026ndash;复合索引中如果有\u0026gt;，则自身和右侧索引全部失效。\nexplain select * from book where authorid = 1 and typeid \u0026gt;2 ;  \u0026ndash;复合索引at全部使用\n明显的概率问题 explain select * from book where authorid \u0026lt; 1 and typeid =2 ;  \u0026ndash;复合索引at只用到了1个索引\nexplain select * from book where authorid \u0026lt; 4 and typeid =2 ;  \u0026ndash;复合索引全部失效\n\u0026ndash;我们学习的索引优化 ，是一个大部分情况适用的结论，但由于SQL优化器等原因 该结论不是100%正确。\n\u0026ndash;一般而言， 范围查询（\u0026gt; \u0026lt; in），之后的索引失效。\n补救。尽量使用索引覆盖（using index） 不会出错\n（a,b,c） select a,b,c from xx..where a= .. and b =.. ;  like尽量以“常量”开头，不要以\u0026rsquo;%\u0026lsquo;开头，否则索引失效 select * from xx where name like '%x%' ;  \u0026ndash;name索引失效\nexplain select * from teacher where tname like '%x%';  \u0026ndash;tname索引失效\nexplain select * from teacher where tname like 'x%';  \u0026ndash;使用name索引\nexplain select tname from teacher where tname like '%x%';  \u0026ndash;如果必须使用like \u0026lsquo;%x%\u0026lsquo;进行模糊查询，可以使用索引覆盖 挽救一部分。\n尽量不要使用类型转换（显示、隐式），否则索引失效 explain select * from teacher where tname = 'abc' ; explain select * from teacher where tname = 123 ;//程序底层将 123 -\u0026gt; '123'，即进行了类型转换，因此索引失效  尽量不要使用or，否则索引失效 explain select * from teacher where tname ='' or tcid \u0026gt;1 ; --将or左侧的tname 失效。  一些其他的优化方法 exist和in select ..from table where exist (子查询) ; select ..from table where 字段 in (子查询) ;  如果主查询的数据集大，则使用In ,效率高。\n如果子查询的数据集大，则使用exist,效率高。\nexist语法： 将主查询的结果，放到子查询结果中进行条件校验（看子查询是否有数据，如果有数据则校验成功） ，如果符合校验，则保留数据；\nselect tname from teacher where exists (select * from teacher) ;  \u0026ndash;等价于select tname from teacher\nselect tname from teacher where exists (select * from teacher where tid =9999) ;  子查询没数据\nin:\nselect ..from table where tid in (1,3,5) ;  order by 优化 using filesort 有两种算法：双路排序、单路排序 （根据IO（访问硬盘）的次数）\nMySQL4.1之前 默认使用 双路排序；\n双路：扫描2次磁盘\n 从磁盘读取排序字段 ,对排序字段进行排序（在buffer(缓冲区)中进行的排序）\n 扫描其他字段\n\u0026ndash;IO较消耗性能\n  MySQL4.1之后 默认使用 单路排序 ：\n只读取一次（全部字段），在buffer中进行排序。\n但种单路排序 会有一定的隐患 （不一定真的是“单路|1次IO”，有可能多次IO）。\n原因：如果数据量特别大，则无法 将所有字段的数据 一次性读取完毕，因此 会进行“分片读取、多次读取”。\n注意：单路排序 比双路排序 会占用更多的buffer。\n单路排序在使用时，如果数据大，可以考虑调大buffer的容量大小： sql命令\nset max_length_for_sort_data = 1024 单位byte  如果max_length_for_sort_data值太低，则mysql会自动从 单路-\u0026gt;双路 （太低：需要排序的列的总大小超过了max_length_for_sort_data定义的字节数）\n提高order by查询的策略：\n 选择使用单路、双路 ；调整buffer的容量大小；\n 避免select * \u0026hellip; 用什么查什么\n 复合索引 不要跨列使用 ，避免using filesort\n 保证全部的排序字段 排序的一致性（都是升序 或 降序）\n  SQL排查 - 慢查询日志: MySQL提供的一种日志记录，用于记录MySQL种响应时间超过阀值的SQL语句 （long_query_time，默认10秒）\n慢查询日志默认是关闭的；\n建议：开发调优是 打开，而 最终部署时关闭。\n检查是否开启了 慢查询日志 ：\nshow variables like '%slow_query_log%' ;  临时开启：mysql退出重启服务后关闭\nset global slow_query_log = 1 ; --在内存中开启 exit service mysql restart  永久开启：\n/etc/my.cnf 中追加配置：\nvi /etc/my.cnf [mysqld] slow_query_log=1 slow_query_log_file=/var/lib/mysql/localhost-slow.log  慢查询阀值：\nshow variables like '%long_query_time%' ;  临时设置阀值：\nset global long_query_time = 5 ; --设置完毕后，重新登陆后起效 （不需要重启服务）  永久设置阀值：\n/etc/my.cnf 中追加配置：\nvi /etc/my.cnf [mysqld] long_query_time=3  实例\nselect sleep(4); select sleep(5); select sleep(3); select sleep(3);  \u0026ndash;查询超过阀值的SQL：\n show global status like '%slow_queries%' ;   慢查询的sql被记录在了日志中，因此可以通过日志 查看具体的慢SQL。\ncat /var/lib/mysql/localhost-slow.log  通过mysqldumpslow工具查看慢SQL,可以通过一些过滤条件 快速查找出需要定位的慢SQL\nmysqldumpslow --help s：排序方式 r:逆序 l:锁定时间 g:正则匹配模式   linux命令\n获取返回记录最多的3个SQL\nmysqldumpslow -s r -t 3 /var/lib/mysql/localhost-slow.log  获取访问次数最多的3个SQL\nmysqldumpslow -s c -t 3 /var/lib/mysql/localhost-slow.log  按照时间排序，前10条包含left join查询语句的SQL\nmysqldumpslow -s t -t 10 -g \u0026quot;left join\u0026quot; /var/lib/mysql/localhost-slow.log  语法：\nmysqldumpslow 各种参数 慢查询日志的文件  分析海量数据 模拟海量数据 存储过程（无return）/存储函数（有return） create database testdata ; use testdata create table dept ( dno int(5) primary key default 0, dname varchar(20) not null default '', loc varchar(30) default '' )engine=innodb default charset=utf8; create table emp ( eid int(5) primary key, ename varchar(20) not null default '', job varchar(20) not null default '', deptno int(5) not null default 0 )engine=innodb default charset=utf8;  通过存储函数 插入海量数据：  创建存储函数：\nrandstring(6) -\u0026gt;aXiayx 用于模拟员工名称 delimiter $ create function randstring(n int) returns varchar(255) begin declare all_str varchar(100) default 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ; declare return_str varchar(255) default '' ; declare i int default 0 ; while i\u0026lt;n do set return_str = concat( return_str, substring(all_str, FLOOR(1+rand()*52) ,1) ); set i=i+1 ; end while ; return return_str; end $   \u0026ndash;如果报错：You have an error in your SQL syntax，说明SQL语句语法有错，需要修改SQL语句；\n如果报错This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable) 是因为 存储过程/存储函数在创建时 与之前的 开启慢查询日志冲突了\n解决冲突：\n临时解决( 开启log_bin_trust_function_creators )\n show variables like '%log_bin_trust_function_creators%'; set global log_bin_trust_function_creators = 1;  永久解决：\n/etc/my.cnf [mysqld] log_bin_trust_function_creators = 1  创建产生随机整数存储函数（0-99） create function ran_num() returns int(5) begin declare i int default 0; set i =floor( rand()*100 ) ; return i ; end $  通过存储过程插入海量数据： emp表中，从eid_start开始插入data_times条数据\ncreate procedure insert_emp( in eid_start int(10),in data_times int(10)) begin declare i int default 0; set autocommit = 0 ; repeat insert into emp values(eid_start + i, randstring(5) ,'other' ,ran_num()) ; set i=i+1 ; until i=data_times end repeat ; commit ; end $  \u0026ndash;通过存储过程插入海量数据：dept表中 create procedure insert_dept(in dno_start int(10) ,in data_times int(10)) begin declare i int default 0; set autocommit = 0 ; repeat insert into dept values(dno_start+i ,randstring(6),randstring(8)) ; set i=i+1 ; until i=data_times end repeat ; commit ; end$  \u0026ndash;插入数据  delimiter ; call insert_emp(1000,800000) ; call insert_dept(10,30) ;  分析海量数据: profiles show profiles ; --默认关闭 show variables like '%profiling%'; set profiling = on ; show profiles ：会记录所有profiling打开之后的 全部SQL查询语句所花费的时间。缺点：不够精确，只能看到 总共消费的时间，不能看到各个硬件消费的时间（cpu io ）  \u0026ndash;精确分析:sql诊断  show profile all for query 上一步查询的的Query_Id show profile cpu,block io for query 上一步查询的的Query_Id  全局查询日志 ： 记录开启之后的 全部SQL语句。 （这次全局的记录操作 仅仅在调优、开发过程中打开即可，在最终的部署实施时 一定关闭）\nshow variables like '%general_log%';   \u0026ndash;执行的所有SQL记录在表中\nset global general_log = 1 ;--开启全局日志 set global log_output='table' ; --设置 将全部的SQL 记录在表中  \u0026ndash;执行的所有SQL记录在文件中\nset global log_output='file' ; set global general_log = on ; set global general_log_file='/tmp/general.log' ;   开启后，会记录所有SQL ： 会被记录mysql.general_log表中。\nselect * from mysql.general_log ;  锁机制 ：解决因资源共享 而造成的并发问题。 示例：买最后一件衣服X\nA: X 买 ： X加锁 -\u0026gt;试衣服...下单..付款..打包 -\u0026gt;X解锁 B: X 买：发现X已被加锁，等待X解锁， X已售空  分类：\n 操作类型：\n 读锁（共享锁）： 对同一个数据（衣服），多个读操作可以同时进行，互不干扰。\n 写锁（互斥锁）： 如果当前写操作没有完毕（买衣服的一系列操作），则无法进行其他的读操作、写操作\n  操作范围：\n 表锁 ：一次性对一张表整体加锁。如MyISAM存储引擎使用表锁，开销小、加锁快；无死锁；但锁的范围大，容易发生锁冲突、并发度低。\n 行锁 ：一次性对一条数据加锁。如InnoDB存储引擎使用行锁，开销大，加锁慢；容易出现死锁；锁的范围较小，不易发生锁冲突，并发度高（很小概率 发生高并发问题：脏读、幻读、不可重复度、丢失更新等问题）。\n 页锁\n   示例：\n表锁 ： \u0026ndash;自增操作 MYSQL/SQLSERVER 支持；oracle需要借助于序列来实现自增\ncreate table tablelock ( id int primary key auto_increment , name varchar(20) )engine myisam; insert into tablelock(name) values('a1'); insert into tablelock(name) values('a2'); insert into tablelock(name) values('a3'); insert into tablelock(name) values('a4'); insert into tablelock(name) values('a5'); commit;  增加锁：\nlocak table 表1 read/write ,表2 read/write ,...  查看加锁的表：\nshow open tables ;  会话：session :每一个访问数据的dos命令行、数据库客户端工具 都是一个会话\n加读锁：  会话0：\nlock table tablelock read ; select * from tablelock; --读（查），可以 delete from tablelock where id =1 ; --写（增删改），不可以  其他表\nselect * from emp ; --读，不可以 delete from emp where eid = 1; --写，不可以  结论1：\n \u0026ndash;如果某一个会话 对A表加了read锁，则 该会话 可以对A表进行读操作、不能进行写操作：且该会话不能对其他表进行读、写操作。\n \u0026ndash;即如果给A表加了读锁，则当前会话只能对A表进行读操作。\n  会话1（其他会话）：\nselect * from tablelock; --读（查），可以 delete from tablelock where id =1 ; --写，会“等待”会话0将锁释放  会话1（其他会话）：\nselect * from emp ; --读（查），可以 delete from emp where eno = 1; --写，可以  \u0026ndash;总结：\n会话0给A表加了锁；其他会话的操作：\n 可以对其他表（A表以外的表）进行读、写操作 对A表：读-可以； 写-需要等待释放锁。   释放锁:\nunlock tables ;  ===加写锁：  会话0：\nlock table tablelock write ;  当前会话（会话0） 可以对加了写锁的表 进行任何操作（增删改查）；但是不能 操作（增删改查）其他表\n 其他会话：\n对会话0中加写锁的表 可以进行增删改查的前提是：等待会话0释放写锁\n  MySQL表级锁的锁模式 MyISAM\n在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，\n在执行更新操作（DML）前，会自动给涉及的表加写锁。\n所以对MyISAM表进行操作，会有以下情况：\n 对MyISAM表的读操作（加读锁），不会阻塞其他进程（会话）对同一表的读请求， 但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。\n 对MyISAM表的写操作（加写锁），会阻塞其他进程（会话）对同一表的读和写操作， 只有当写锁释放后，才会执行其它进程的读写操作。\n  分析表锁定： 查看哪些表加了锁：\nshow open tables ; 1代表被加了锁  分析表锁定的严重程度：\nshow status like 'table%' ; Table_locks_immediate :即可能获取到的锁数 Table_locks_waited：需要等待的表锁数(如果该值越大，说明存在越大的锁竞争)  一般建议：\nTable_locks_immediate/Table_locks_waited \u0026gt; 5000， 建议采用InnoDB引擎，否则MyISAM引擎\n行锁（InnoDB） create table linelock( id int(5) primary key auto_increment, name varchar(20) )engine=innodb ; insert into linelock(name) values('1') ; insert into linelock(name) values('2') ; insert into linelock(name) values('3') ; insert into linelock(name) values('4') ; insert into linelock(name) values('5') ;  \u0026ndash;mysql默认自动commit; oracle默认不会自动commit ;\n为了研究行锁，暂时将自动commit关闭;\nset autocommit =0 ;  以后需要通过commit\n会话0： 写操作\ninsert into linelock values(6,'a6') ;  会话1： 写操作 同样的数据\nupdate linelock set name='ax' where id = 6;  对行锁情况：\n 如果会话x对某条数据a进行 DML操作（研究时：关闭了自动commit的情况下），则其他会话必须等待会话x结束事务(commit/rollback)后 才能对数据a进行操作。\n 表锁 是通过unlock tables，也可以通过事务解锁 ; 行锁 是通过事务解锁。\n  行锁，操作不同数据：\n会话0： 写操作\ninsert into linelock values(8,'a8') ;  会话1： 写操作， 不同的数据\nupdate linelock set name='ax' where id = 5;  行锁，一次锁一行数据；因此 如果操作的是不同数据，则不干扰。\n行锁的注意事项：\n 如果没有索引，则行锁会转为表锁\nshow index from linelock ; alter table linelock add index idx_linelock_name(name);  会话0： 写操作\nupdate linelock set name = 'ai' where name = '3' ;  会话1： 写操作， 不同的数据\nupdate linelock set name = 'aiX' where name = '4' ;  两者互不干扰\n会话0： 写操作\nupdate linelock set name = 'ai' where name = 3 ;  会话1： 写操作， 不同的数据\nupdate linelock set name = 'aiX' where name = 4 ;  \u0026ndash;可以发现，数据被阻塞了（加锁）\n\u0026ndash; 原因：如果索引类 发生了类型转换，则索引失效。 因此 此次操作，会从行锁 转为表锁。\n 行锁的一种特殊情况：间隙锁：值在范围内，但却不存在\n\u0026ndash;此时linelock表中 没有id=7的数据\nupdate linelock set name ='x' where id \u0026gt;1 and id\u0026lt;9 ;  \u0026ndash;即在此where范围中，没有id=7的数据，则id=7的数据成为间隙。\ninsert into linelock values(7,\u0026quot;zs\u0026quot;);  \u0026ndash;结果被锁住了\n间隙：Mysql会自动给 间隙 加索 -\u0026gt;间隙锁。即 本题 会自动给id=7的数据加 间隙锁（行锁）。\n行锁：如果有where，则实际加锁的范围 就是where后面的范围（不是实际的值）（2-8之间都加上锁）\n  如果仅仅是查询数据，能否加锁？\n可以 for update\n研究学习时，将自动提交关闭：(三种方式)\nset autocommit =0 ; start transaction ; begin ;  \tselect * from linelock where id =2 for update ;  通过for update对query语句进行加锁。\n行锁：\nInnoDB默认采用行锁；\n缺点： 比表锁性能损耗大。\n优点：并发能力强，效率高。\n因此建议，高并发用InnoDB，否则用MyISAM。\n行锁分析：\nshow status like '%innodb_row_lock%' ; Innodb_row_lock_current_waits :当前正在等待锁的数量 Innodb_row_lock_time：等待总时长。从系统启到现在 一共等待的时间 Innodb_row_lock_time_avg ：平均等待时长。从系统启到现在平均等待的时间 Innodb_row_lock_time_max ：最大等待时长。从系统启到现在最大一次等待的时间 Innodb_row_lock_waits ： 等待次数。从系统启到现在一共等待的次数  主从复制 （集群在数据库的一种实现） 集群的优点 1. 负载均衡 2. 失败迁移\nwindows:mysql 主\nlinux:mysql从\n安装windows版mysql:\n如果之前计算机中安装过Mysql，要重新再安装 则需要：先卸载 再安装\n先卸载：  通过电脑自带卸载工具卸载Mysql (电脑管家也可以)\n 删除一个mysql缓存文件夹C:\\ProgramData\\MySQL\n 删除注册表regedit中所有mysql相关配置\n \u0026ndash;重启计算机\n  安装MYSQL： 下载官网\n安装时，如果出现未响应： 则重新打开\nxxx\\bin\\MySQLInstanceConfig.exe  图形化客户端： SQLyog, Navicat\n如果要远程连接数据库，则需要授权远程访问。\n在linux中授权远程访问 :(A-\u0026gt;B,则再B计算机的Mysql中执行以下命令)\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION; FLUSH PRIVILEGES;  如果仍然报错：可能是防火墙没关闭 ： 在B关闭防火墙\nservice iptables stop  实现主从同步（主从复制）：\n主从同步的核心：通过二进制日志\n master将改变的数 记录在本地的 二进制日志中（binary log） ；该过程 称之为：二进制日志事件\n slave将master的binary log拷贝到自己的 relay log（中继日志文件）中\n 中继日志事件，将数据读取到自己的数据库之中 MYSQL主从复制 是异步的，串行化的， 有延迟\n  MYSQL主从复制是异步的，串行化的，有延迟的\nmaster:slave = 1:n  配置：\nwindows(mysql: my.ini)\nlinux(mysql: my.cnf)\n配置前，为了无误，先将权限(远程访问)、防火墙等处理：\n关闭windows/linux防火墙：\n windows：右键“网络”\n linux:\nservice iptables stop   Mysql允许远程连接(windowos/linux)：\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION; FLUSH PRIVILEGES;  window mysql8.0 版本修改允许访问远程权限\nuse mysql; select host, user, authentication_string, plugin from user; update user set host='%' where user='root'; grant all privileges on *.* to root@'%'; flush privileges;  主机（以下代码和操作 全部在主机windows中操作）：my.ini [mysqld] #id server-id=1 #二进制日志文件（注意是/ 不是\\） log-bin=\u0026quot;C:/Program Files/MySQL/MySQL Server 8.0/data/mysql-bin\u0026quot; #错误记录文件 log-error=\u0026quot;C:/Program Files/MySQL/MySQL Server 8.0/data/mysql-error\u0026quot; #主从同步时 忽略的数据库 binlog-ignore-db=mysql #(可选)指定主从同步时，同步哪些数据库 binlog-do-db=test  windows中的数据库 授权哪台计算机中的数据库 是自己的从数据库：\nGRANT REPLICATION slave,reload,super ON *.* TO 'root'@'192.168.2.%' IDENTIFIED BY 'root'; flush privileges ;  查看主数据库的状态（每次在左主从同步前，需要观察 主机状态的最新值）\nshow master status;（mysql-bin.000001、 107）  （mysql-bin.000001、 107）：二进制文件名和位置\n从机（以下代码和操作 全部在从机linux中操作）： my.cnf [mysqld] server-id=2 log-bin=mysql-bin replicate-do-db=test  linux中的数据 授权哪台计算机中的数控 是自己的主计算机\nCHANGE MASTER TO MASTER_HOST = '192.168.2.2', MASTER_USER = 'root', MASTER_PASSWORD = 'root', MASTER_PORT = 3306, master_log_file='mysql-bin.000001', master_log_pos=107;  如果报错：This operation cannot be performed with a running slave; run STOP SLAVE first\n解决：\nSTOP SLAVE ;  再次执行上条授权语句\n开启主从同步： 从机linux:\nstart slave ;  检验\nshow slave status \\G  主要观察： Slave_IO_Running和 Slave_SQL_Running，确保二者都是yes；如果不都是yes，则看下方的 Last_IO_Error。\n本次 通过 Last_IO_Error发现错误的原因是 主从使用了相同的server-id， 检查:在主从中分别查看serverid:\nshow variables like 'server_id' ;  可以发现，在Linux中的my.cnf中设置了server-id=2，但实际执行时 确实server-id=1，原因：可能是 linux版Mysql的一个bug，也可能是 windows和Linux版本不一致造成的兼容性问题。\n解决改bug：\nset global server_id =2 ;  重复执行上面\nstop slave ; set global server_id =2 ; start slave ; show slave status \\G  确保两个是yes\n演示： 主windows =\u0026gt;从\nwindows:\n将表，插入数据  linux\n观察从数据库中该表的数据  ","id":3,"section":"posts","summary":"系统使用的Linux Centos6 MySQL版本： 5.x: 5.0-5.1:早期产品的延续，升级维护 5.4 - 5.x : MySQL整合了三方公司的新存储引擎 （推荐5.5） 本","tags":["数据库"],"title":"SQL优化Mysql版","uri":"https://mumulx.github.io/2020/01/sql%E4%BC%98%E5%8C%96mysql%E7%89%88/","year":"2020"},{"content":" MybatisPlus mubatis plus 官网\nMyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生\nORM（Object Relational Mapping）框架采用元数据来描述对象与关系映射的细节，元数据一般采用XML格式，并且存放在专门的对象一映射文件中。\n只要提供了持久化类与表的映射关系，ORM框架在运行时就能参照映射文件的信息，把对象持久化到数据库中。当前ORM框架主要有五种：Hibernate(Nhibernate)，iBATIS，mybatis，EclipseLink，JFinal。\nORM是通过使用描述对象和数据库之间映射的元数据,在我们想到描述的时候自然就想到了xml和特性(Attribute).目前的ORM框架中,Hibernate就是典型的使用xml文件作为描述实体对象的映射框架,而大名鼎鼎的Linq则是使用特性(Attribute)来描述的。\n开发MyBatis Plus:  jar\n 数据表 类\nstudent Student  MyBatis配置 文件 mybatis.xml (没有具体的配置信息，因为会放入Spring中配置)\n 日志 log4j.xml\n 数据库的连接信息\n Spring配置文件\n  spring boot:自动管理版本\nspring:版本手工 mybatis - plus\n切换到 MyBatis-PLus\n\u0026lt;bean id=\u0026quot;sqlSessionFactoryBean\u0026quot; class=\u0026quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean\u0026quot; \u0026gt;  mybatis 配置文件模板 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026quot;-//mybatis.org//DTD Config 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026quot;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;environment id=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot; /\u0026gt; \u0026lt;!-- 配置数据库连接信息 --\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;oracle.jdbc.OracleDriver\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:XE\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;system\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;sa\u0026quot; /\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!-- 在配置文件（conf.xml）中注册SQL映射文件（studentMapper.xml）--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026quot;org/lanqiao/entity/studentMapper.xml\u0026quot; /\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;  CRUD操作 JDBC: Dao接口 Dao实现类\nMyBatis: Mapper接口- SQL映射文件\nMyBatis-PLus : Mapper接口\nMyBatis-PLus：只写接口不需要写sql语句\n一个接口 extends BaseMapper，之后无需编写 SQL映射文件，该接口的对象全部操作哦Student对象\n 类名\u0026mdash;-表名\n@TableName(\u0026quot;tb_student\u0026quot;)  对象的属性\u0026mdash;表的字段 一一对应关系：\n@TableId、@TableField @TableId(value = \u0026quot;stuno\u0026quot;,type = IdType.AUTO)//指定自增  主键的自增依赖于数据库已经设置好了主键自增\n属性的驼峰命名法会变成下划线命名\n属性：stuName\u0026ndash;\u0026gt;字段：stu_name\n如果不想转换可以在配置文件中设置\n\u0026lt;!--配置属性和字段驼峰命名和下划线命名不互相转换 默认值是true--\u0026gt; \u0026lt;setting name=\u0026quot;mapUnderscoreToCamelCase\u0026quot; value=\u0026quot;false\u0026quot;/\u0026gt;  一般默认表中字段为下划线，类中属性为驼峰\nmybatisplus不需要在像mybatis那样执行后需要commit\n雪花算法\n  MyBatis-plus:\n 更换成MybatisSqlSessionFactoryBean\n 继承一个父接口 extends BaseMapper，之后就可以使用该接口中 已经存在的CRUD方法 操作 。 通过注解 将 表（字段） - 类（属性）  MP： where语句：Warpper实现 ， QueryWarpper(查询) UpdateWrapper（DML）\nMP源码 回顾：\nMappedStatement对象 就是 \u0026lt;select\u0026gt;等标签\nMyBatis/MP都是通过 MappedStatement对象来指向增删改\n预加载：MP启动时，会指定加载所有常见的 CRUD语句 （来自于MP提供的BaseMapper接口），并将这些语句封装到了MappedStatement对象中。\nAR: activeRecoder ,形式 ：通过实体类Student直接进行增删改查操作（不需要借助于Mapper对象） 继承Model类即可\npublic class Student extends Model\u0026lt;Student\u0026gt;  public static void testAR(){ // 必须在IOC容器中进行AR new ClassPathXmlApplicationContext(\u0026quot;applicationContext.xml\u0026quot;); Student student = new Student(\u0026quot;哈哈\u0026quot;, 22); student.insert(); }  注意：使用时 必须先加载IOC容器，目的 是为了让AR知道 要操作的是数据库在哪里\nMP将主键设置为了Serializable，类型。目的 ：可以接受常见的类型：8个基本类型+String -\u0026gt;Serializable\n逆向工程(代码生成器) MyBatis:\nstudent表-\u0026gt;Student类、Mapper接口、mapper.xml\nMyBatis Plus:\nstudent表-\u0026gt;Student类、Mapper接口、mapper.xml、Service、Controller\n区别：\n MyBatis: 模版配置文件 MyBatis Plus:类  具体使用参见官网\nlombok：可以给类的属性生成set get 构造方法等 1. 依赖 2. 配置\n分页 分页：复习\n\u0026lt;select\u0026gt;等标签 -\u0026gt; MappedStatement对象\nboundSql ：将我们写的SQL和参数值进行了拼接后的对象，即最终能被真正执行的SQL\n拦截器：编写拦截器、注入拦截器，放入 \u0026lt;plugins\u0026gt;即可。 作用：对SQL进行“修改”\n分页： MyBatis Plus\n\u0026lt;!-- 拦截器 分页--\u0026gt; \u0026lt;property name=\u0026quot;plugins\u0026quot;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;!-- 分页插件--\u0026gt; \u0026lt;bean class=\u0026quot;com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor\u0026quot;\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt;   public static void testPage() { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;applicationContext.xml\u0026quot;); StudentMapper studentMapper = context.getBean(\u0026quot;studentMapper\u0026quot;, StudentMapper.class); Page\u0026lt;Student\u0026gt; page = new Page\u0026lt;\u0026gt;(2, 2); //select * from student ; 第二个参数来存放where条件 IPage\u0026lt;Student\u0026gt; pages = studentMapper.selectPage(page, null); System.out.println(\u0026quot;当前页得数据++++\u0026quot;+ page.getRecords()); System.out.println(\u0026quot;当前页页码++++\u0026quot;+ page.getCurrent()); System.out.println(\u0026quot;总数据量++++\u0026quot;+ page.getTotal()); System.out.println(\u0026quot;每一页得数据量++++\u0026quot;+ page.getSize()); }  分析分页源码\nselect *from xxx -\u0026gt;PaginationInterceptor select *from xxx LIMIT 2,2  攻击 SQL 阻断解析器 作用！阻止恶意的全表更新删除\n跟分页类一样\n性能分析插件 性能分析拦截器，用于输出每条 SQL 语句及其执行时间\n乐观锁插件 悲观锁：synchorinzed，lock；总以为会冲突，当第一个人访问得时候，把数据加上锁，其他人访问不到该数据，知道第一个人结束访问。并发操作变成串行操作（效率太低严重影响性能） 乐观锁：cvs算法；总以为不冲突；在修改的一瞬间去检验一下\nsql注入器 sql语句的实现方式  mybatis:\nstudentMapper.xml \u0026lt;select id=\u0026quot;queryStudent\u0026quot;\u0026gt; select * from xxx \u0026lt;/select\u0026gt;  mybatis:\n@Select(\u0026quot;select....\u0026quot;)  MP:\nextends BaseMapper\u0026lt;Student\u0026gt;  MP:\n自己写SQL。Sql 注入器，仿照方式“3” 自己编写一个 带SQL的方法 deleteAllStudents();\n 自定义方法 -\u0026gt;写sql语句 + 标签名 MyDelete extends AbstractMethod 自定义Sql 注入器 ： 包含原来17个 + 自己的MyDelete 配置 告知MP,以后使用自定义注入器   逻辑删除 逻辑删除（假删除）：\n@TableLogic private Integer deleted;  在表中增加相应字段\n逻辑删除：为了数据安全\n全局配置： 以 表名加前缀位置\n\u0026lt;property name=\u0026quot;dbConfig\u0026quot; \u0026gt; \u0026lt;bean class=\u0026quot;com.baomidou.mybatisplus.core.config.GlobalConfig$DbConfig\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;logicDeleteValue\u0026quot; value=\u0026quot;1\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;logicNotDeleteValue\u0026quot; value=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;tablePrefix\u0026quot; value=\u0026quot;tb_\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt;  @TableName(value=\u0026quot;student\u0026quot;,keepGlobalPrefix=true)  自动填充插件 Sequence主键 实现oracle数据库的自增\nmvn仓库添加oracle jar  将ojdbc7.jar复制到mvn的本地仓库\n cmd执行\nmvn install:install-file -DgroupId=ojdbc -DartifactId=ojdbc7 -Dversion=7.0.0.1 -Dpackaging=jar -Dfile=ojdbc7.jar   MybatisX 快速开发插件 MybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。\n本插件时针对于mubatis开发的\nMyBatis Plus的源码 github地址\nMapper mapper 码云地址\n与MP时同级的关系都是对mybatis的插件\nmapper github地址\nmybatis/mp:\n\u0026lt;bean id=\u0026quot;configurer\u0026quot; class=\u0026quot;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026quot; \u0026gt; \u0026lt;property name=\u0026quot;basePackage\u0026quot; value=\u0026quot;com.yq.mapper\u0026quot; \u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  Mapper：\n【tk】\\.mybatis.spring.mapper.MapperScannerConfigure  回顾：\nmapper配置：和mybatis基本一致：唯一不同的 org-\u0026gt;tk\nMP:\npublic interface StudentMapper extends baomidou.....BaseMapper\u0026lt;Student\u0026gt; {  Mapper:\npublic interface StudentMapper extends Mapper\u0026lt;Student\u0026gt; {  mapper的核心：\nMapper父接口中 有很多细化的父接口（每个细化的父接口负责一件事情： x）\n主键：包装类Integer/ Long ，不要使用基本类型\n只支持单表操作\n标识@id\nSELECT stu_no,stu_name,stu_age FROM tb_student WHERE stu_no = ?  没有标识@id :默认 将全部字段作为联合主键\nSELECT stu_no,stu_name,stu_age FROM tb_student WHERE stu_no = ? AND stu_name = ? AND stu_age = ?  MP 可以将主键值 会写到 对象中；\nmapper默认不会， 如果要： 配置\n@Id() @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer stuNo ;//stuNo -\u0026gt; stu_no  插入数据时，如果不给主键赋值，是否回写？\nzs 23 -\u0026gt; 18,zs ,23   mysql 或其他自带 “自增功能”的数据库：\n@Id() @GeneratedValue(strategy = GenerationType.IDENTITY)  oracle不带自增：\n@Id() @KeySql(sql = \u0026quot;select SEQ_stu.nextval from dual\u0026quot;, order = ORDER.BEFORE)   通过序列实现自增\nselectOne(stu) stu:查询条件，类似于MP 中的wrapper\n selective\nINSERT INTO tb_student ( stu_no,stu_name ) VALUES( ?,? )  没有selectvie\nINSERT INTO tb_student ( stu_no,stu_name,stu_age ) VALUES( ?,?,? )  selective：对于没有操作的值，不进行任何处理\n没有selective：对于没有操作的值， 赋值为NULL 。可以发现，selective在insert操作 基本没有区别.\n但对于修改，一般建议 加上selective,不用修改的字段会保留原来的值，而不会赋值为null\n  mapper 代码生成器 mapper 自由组合功能 新增方法 mapper 的源码 mapper逆向工程\nmapper\n","id":4,"section":"posts","summary":"MybatisPlus mubatis plus 官网 MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生 ORM（Object","tags":["Spring家族"],"title":"MybatisPlus和Mapper框架","uri":"https://mumulx.github.io/2020/01/mybatisplus%E5%92%8Cmapper%E6%A1%86%E6%9E%B6/","year":"2020"},{"content":" RPC RPC:Remote Procedure Call （远程过程调用）\n \u0026ldquo;HelloService\u0026rdquo;，而服务端需要通过该字符串解析出该字符串代表的接口的一切信息\u0026ndash;》通过反射技术 客户端\u0026ndash;》服务端：socket 服务端需要根据客户端的不同请求，返回不同的接口类型，客户端就要接收到不同的接口类型\u0026mdash;》通过动态代理  客户端 Client.java package com.lx.client; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.OutputStream; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.net.InetSocketAddress; import java.net.Socket; public class Client { // 获取代表服务端接口的动态代理对象 // serviceInterface:请求的接口名 // addr:带请求服务端的ip：端口 @SuppressWarnings(\u0026quot;unchecked\u0026quot;) public static \u0026lt;T\u0026gt; T getRemoteProxyObj(Class serviceInterface, InetSocketAddress addr) { // 动态代理对象 /* * newProxyInstance(a,b,c) a:类加载器：需要代理哪一个类 b:需要代理的对象具有哪些功能(方法) --- 接口（方法在接口中存放 ） */ return (T) Proxy.newProxyInstance(serviceInterface.getClassLoader(), new Class\u0026lt;?\u0026gt;[] {serviceInterface }, new InvocationHandler() { /** * proxy 代理的对象 * * method 对象的哪一个方法 * * args 参数列表 * */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { ObjectInputStream input = null; ObjectOutputStream output = null; Socket socket = new Socket(); try { // 客户端向服务端发送请求：请求某一个具体的接口 // socketAddress:Ip：端口 socket.connect(addr); output = new ObjectOutputStream(socket.getOutputStream());// 发送 通过序列化流(对象流) // 发送：接口名，方法名，方法的参数的类型,方法的参数， output.writeUTF(serviceInterface.getName()); output.writeUTF(method.getName()); output.writeObject(method.getParameterTypes()); output.writeObject(args); // 等待服务端处理 // 接收服务端处理后的返回值 input = new ObjectInputStream(socket.getInputStream()); Object result = input.readObject(); return result; } catch (Exception e) { // TODO: handle exception e.printStackTrace(); return null; } finally { try { if (output != null) { output.close(); } if (input != null) { input.close(); } } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); return null; } } } }); } }  服务端 MyCenter.java package com.lx.center; import java.io.IOException; import java.lang.reflect.InvocationTargetException; //服务中心 public interface MyCenter { public void start(); public void stop(); //注册服务 public void register(Class name,Class serviceImpl); }  MyCenterServer.java package com.lx.center; import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.net.InetSocketAddress; import java.net.ServerSocket; import java.net.Socket; import java.util.HashMap; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import javax.sound.sampled.Port; public class MyCenterServer implements MyCenter { // map:服务端的所有可供客户端访问的接口，都注册到map中 // key:接口的名字 value:真正的接口的实现 private static HashMap\u0026lt;String, Class\u0026gt; serviceRegister = new HashMap\u0026lt;String, Class\u0026gt;(); // 端口 private static int Port;// =9999 // 连接池：连接池中存在多个和连接对象，每一个连接对象都可以处理一个客户请求 // jdk1.5提供 private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); private static boolean isRunning = false; public MyCenterServer(int port) { this.Port = port; } // 开启服务 @Override public void start() { ServerSocket serverSocket = null; try { serverSocket = new ServerSocket(); serverSocket.bind(new InetSocketAddress(Port)); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } isRunning = true; while (true) { // 具体的服务内容；接收客户端请求，处理请求，并返回结果 // TODO Auto-generated method stub // 如果想要让多个客户端请求并发执行 多线程 System.out.println(\u0026quot;start server ... \u0026quot;); // 客户端每次请求一次连接（发送一次请求），则服务端 从连接池中获取一个线程对象去处理 Socket socket = null; try { socket = serverSocket.accept();// 等待客户端连接 } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } executor.execute(new ServiceTask(socket));// .参数是一个多线程对象 } } @Override public void stop() { // TODO Auto-generated method stub isRunning = false; executor.shutdown(); } @Override public void register(Class service, Class serviceImpl) { serviceRegister.put(service.getName(), serviceImpl); } private static class ServiceTask implements Runnable { private Socket socket; public ServiceTask(Socket socket) { this.socket = socket; } public ServiceTask() { } @Override public void run() {// 线程所做的事情 ObjectOutputStream output = null; ObjectInputStream input = null; // 具体的服务内容；接收客户端请求，处理请求，并返回结果 try { // 接收到客户端连接及请求，处理该请求 input = new ObjectInputStream(socket.getInputStream()); // 因为ObjectInputStream对发送数据的顺序严格要求，因此需要参照发送的顺序逐个接收 String serviceName = input.readUTF(); String methodName = input.readUTF(); Class[] parameterTypes = (Class[]) input.readObject();// 参数类型 Object[] arguments = (Object[]) input.readObject();// 方法的参数名 // 根据客户端的请求，找到map中与之对应的具体的接口 Class SerciceClass = serviceRegister.get(serviceName); Method method = SerciceClass.getMethod(methodName, parameterTypes); // 执行该方法 Object result = method.invoke(SerciceClass.newInstance(), arguments); // 向客户端 将执行完毕的返回值 传给客户端 output = new ObjectOutputStream(socket.getOutputStream()); output.writeObject(result); } catch (Exception e) { // TODO: handle exception e.printStackTrace(); } finally { try { if (output != null) { output.close(); } if (input != null) { input.close(); } } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } }  Service HelloService.java package com.lx.service; public interface HelloService { public String sayHi(String name); }  HelloServiceImpl.java package com.lx.service; public class HelloServiceImpl implements HelloService{ @Override public String sayHi(String name) { // TODO Auto-generated method stub System.out.println(\u0026quot;hi\u0026quot;+name); return \u0026quot;hi\u0026quot;+name; } }  Test ClientTest.java package com.lx.test; import java.net.InetSocketAddress; import com.lx.client.Client; import com.lx.service.HelloService; import com.lx.service.HelloServiceImpl; public class ClientTest { public static void main(String[] args) throws ClassNotFoundException { HelloService helloService = Client.getRemoteProxyObj(Class.forName(\u0026quot;com.lx.service.HelloService\u0026quot;), new InetSocketAddress(\u0026quot;127.0.0.1\u0026quot;, 9999)); System.out.println(helloService.sayHi(\u0026quot;zs\u0026quot;)); } }  ServerTest package com.lx.test; import com.lx.center.MyCenter; import com.lx.center.MyCenterServer; import com.lx.service.HelloService; import com.lx.service.HelloServiceImpl; public class ServeTest { public static void main(String[] args) { // 开启一个线程 new Thread(new Runnable() { @Override public void run() { // 服务中心 MyCenter serverCenter = new MyCenterServer(9999); // 将helloService接口及其实现类注册到服务中心 serverCenter.register(HelloService.class, HelloServiceImpl.class); serverCenter.start(); } }).start(); } }  源码地址 github地址\n","id":5,"section":"posts","summary":"RPC RPC:Remote Procedure Call （远程过程调用） \u0026ldquo;HelloService\u0026rdquo;，而服务端需要通过该字符串解析出该字符串代表的接口的一切信息\u0026n","tags":["Java"],"title":"自定义RPC Java","uri":"https://mumulx.github.io/2020/01/%E8%87%AA%E5%AE%9A%E4%B9%89rpc-java/","year":"2020"},{"content":" 使用异或进行加密解密 异或: * 同为0，异为1; * 一个数，两次异或之后，是原数本身\n一个数据异或一次：加密\n一个数据异或两次：解密\n是可逆的\npackage utils; public class SecurityUtil { //通过异或进行加密和解密 传入string(\u0026quot;abc\u0026quot;)---\u0026gt;String(\u0026quot;xyz\u0026quot;) public static String xor(String in) {//\u0026quot;abc\u0026quot;---\u0026gt;{'a','b','c'}字符串变成字符数组 //char 和int之间时可以直接转换的 //String 和int之间时无法进行运算的 char[] chs = in.toCharArray(); for(int i = 0; i \u0026lt; chs.length;i++) { //^ 异或符号 chs[i] = (char)(chs[i]^3000); } return new String(chs); } public static void main(String[] args) { String str = \u0026quot;hello\u0026quot;; str = xor(str);// 第一次异或 加密 System.out.println(str); str = xor(str);// 第二次异或 解密 System.out.println(str); } }  MD5 字符串 \u0026mdash;\u0026gt; 十六进制串\n是不可逆的\n引入jar包 commons-codec-1.10.jar\n代码 import org.apache.commons.codec.digest.DigestUtils; public class MD5 { public static String md5Encode(byte[] input) { return DigestUtils.md5Hex(input);//byte[]---\u0026gt;String } public static void main(String[] args) { // TODO Auto-generated method stub String str = \u0026quot;hello\u0026quot;; str = md5Encode(str.getBytes()); System.out.println(str); } }  SHA256加密 引入jar包 commons-codec-1.10.jar\n代码 import org.apache.commons.codec.digest.DigestUtils; public class MD5 { //SHA256 public static String SHA256Encode(byte[] input) { return DigestUtils.sha256Hex(input);//byte[]---\u0026gt;String }\tpublic static void main(String[] args) { String str = \u0026quot;hello\u0026quot;; str = SHA256Encode(str.getBytes()); System.out.println(str); } }  MD5和SHA256的异同\n 同：\n都是不可逆\n 异\nMD5：速度较快\nSHA256：安全性较高\n  Base64 import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Base { //base64 加密 public static String base64Encode(byte[] input) { String result = null; //反射 try { Class clazz = Class.forName(\u0026quot;com.sun.org.apache.xerces.internal.impl.dv.util.Base64\u0026quot;); Method method = clazz.getMethod(\u0026quot;encode\u0026quot;, byte[].class); result = (String)method.invoke(null, input); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } return result; } //base64解密 public static byte[] base64Decode(String input) { byte[] result = null ; try { Class clazz = Class.forName(\u0026quot;com.sun.org.apache.xerces.internal.impl.dv.util.Base64\u0026quot;); Method method = clazz.getMethod(\u0026quot;decode\u0026quot;, String.class); result = (byte[])method.invoke(null, input); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (NoSuchMethodException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (SecurityException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IllegalAccessException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IllegalArgumentException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (InvocationTargetException e) { // TODO Auto-generated catch block e.printStackTrace(); } return result; } public static void main(String[] args) { String str = \u0026quot;hello\u0026quot;; //加密 str = base64Encode(str.getBytes()); System.out.println(\u0026quot;加密\u0026quot;+str); //解密 byte[] rs = base64Decode(str); System.out.println(\u0026quot;解密\u0026quot;+new String(rs)); } }  可逆\n使用的是jdk自带的一个加密解密\n运用到了反射技术\n加密解密的应用 源码 git地址\n","id":6,"section":"posts","summary":"使用异或进行加密解密 异或: * 同为0，异为1; * 一个数，两次异或之后，是原数本身 一个数据异或一次：加密 一个数据异或两次：解密 是可逆的 package utils; public class SecurityUtil","tags":["Java"],"title":"Java加密解密","uri":"https://mumulx.github.io/2020/01/java%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/","year":"2020"},{"content":" 反射: 反射机制是在[运行状态]中:\n 对于任意一个类，都能够知道这个类的所有属性和方法;\n 对于任意一个对象，都能够调用它的任意一一个方法和属性;\n  反射提供的功能:  在运行时判断任意一个对象所属的类;\n 在运行时构造任意一个类的对象;\n 在运行时判断任意一个类所具有的成员变量和方法;\n 在运行时调用任意\u0026ndash;个对象的方法;\n 生成动态代理。\n  获取反射对象（反射入口）  Class.forName(全类名) xx.class 对象.getClass\n//通过反射获取类 //1. Class.forname() try { Class\u0026lt;?\u0026gt; forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); System.out.println(forName); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } //2. 类名.class Class\u0026lt;?\u0026gt; forName2 =Person.class; System.out.println(forName2); //3. 对象.getClass Person per = new Person(); Class\u0026lt;?\u0026gt; forName3=per.getClass(); System.out.println(forName3);   获取方法 public static void test2() { Class\u0026lt;?\u0026gt; forName = null ; //class try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } //获取所有的公共的方法 /* * 本类以及父类、接口中的所有的方法 * * 符合访问修饰符的规律 * */ Method[] methods = forName.getMethods(); for(Method method:methods) { System.out.println(method); } }  获取所有的方法 // 获取当前类所有方法 //1.只能是当前类 //2.忽略访问修饰符限制 public static void test7() { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Method[] declaredMethods = forName.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) { System.out.println(declaredMethod); } }  获取接口 //获取所有接口 public static void test3() { Class\u0026lt;?\u0026gt; forName = null ; //class try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } // 获取当前类的所有接口 Class\u0026lt;?\u0026gt;[] interfaces = forName.getInterfaces(); for(Class\u0026lt;?\u0026gt; inter:interfaces) { System.out.println(inter); } }  获取父类 //获取所有父类 public static void test4() { Class\u0026lt;?\u0026gt; forName = null ; //class try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } // 获取所有父类 单继承 Class\u0026lt;?\u0026gt; superclass = forName.getSuperclass(); System.out.println(superclass); }  获取所有的构造方法 //获取所有构造方法 public static void test5() { Class\u0026lt;?\u0026gt; forName = null ; //class try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } // 获取所有父类 单继承 Constructor\u0026lt;?\u0026gt;[] constructors = forName.getConstructors(); for(Constructor\u0026lt;?\u0026gt; constructor:constructors) System.out.println(constructor); }\t 获取所有的公共属性 // 获取所有公共属性 public static void test6() { Class\u0026lt;?\u0026gt; forName = null; // class try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } // 获取所有父类 单继承 Field[] fields = forName.getFields(); for (Field field : fields) { System.out.println(field); } }  获取所有属性 // 获取当前类所有属性 //1.只能是当前类 //2.忽略访问修饰符限制 public static void test8() { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Field[] declaredFields = forName.getDeclaredFields(); for (Field declaredField : declaredFields) { System.out.println(declaredField); } }\t 获取当前反射所代表类（接口）的对象 \t// 获取当前反射所代表类（接口）的对象 public static void test9() throws InstantiationException, IllegalAccessException { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Object instance = forName.newInstance(); Person person = (Person)instance; System.out.println(person); }  获取对象的实例，并操作对象 // 获取对象的实例，并操作对象 public static void test1() throws InstantiationException, IllegalAccessException { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Person person = (Person) forName.newInstance(); person.setId(22); person.setName(\u0026quot;zs\u0026quot;); System.out.println(person.getId() + \u0026quot;---\u0026quot; + person.getName()); }  操作属性 // 操作属性 public static void test2() throws InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Person person = (Person) forName.newInstance(); Field idField = forName.getDeclaredField(\u0026quot;id\u0026quot;); //访问的是private修饰的id，但是 peivate是私有 // 因此要修改属性的访问权限，使用反射时，如果是因为访问修饰符限制造成异常，可以通过setAccessible(true)方法解决 // 同理方法也具有setAccessible(true)的方法 idField.setAccessible(true); idField.set(person, 1);//相当于 person.setId(1); System.out.println(person.getId()); }  操作方法 // 操作方法 public static void test3() throws InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Person person = (Person) forName.newInstance(); Method myPrivateMethod= forName.getDeclaredMethod(\u0026quot;privateMethod\u0026quot;, null); // 同理方法也具有setAccessible(true)的方法 myPrivateMethod.setAccessible(true); myPrivateMethod.invoke(person, null); }  操作方法 带参 // 操作方法 带参 public static void test4() throws InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Person person = (Person) forName.newInstance(); Method myPrivateMethod1= forName.getDeclaredMethod(\u0026quot;privateMethod1\u0026quot;, String.class); // 同理方法也具有setAccessible(true)的方法 myPrivateMethod1.setAccessible(true); myPrivateMethod1.invoke(person, \u0026quot;hello\u0026quot;); }  操作构造方法 // 操作构造方法 public static void test5() throws InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } // 在反射中，根据类型获取方法时；基本类型(int\\char) 和包装类（Integer，Character）时不同的类型 Constructor\u0026lt;?\u0026gt; constructor = forName.getConstructor(int.class); System.out.println(constructor); }  获取私有的构造方法 // 操作构造方法 public static void test6() throws InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Constructor\u0026lt;?\u0026gt; constructor = forName.getDeclaredConstructor(String.class); System.out.println(constructor); }  构造方法new对象 // 操作构造方法 new对象 public static void test7() throws InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Constructor\u0026lt;?\u0026gt; constructor = forName.getConstructor(int.class); System.out.println(constructor); Person per = (Person) constructor.newInstance(10); System.out.println(per); }  注意传参\n动态加载类名和方法 class.txt\nclassName=com.lx.myclass.Person methodName = staticMethod  //动态加载类名和方法 public static void test8() throws FileNotFoundException, IOException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException { Properties properties = new Properties(); properties.load(new FileReader(\u0026quot;class.txt\u0026quot;)); String classname = properties.getProperty(\u0026quot;className\u0026quot;); String methodName = properties.getProperty(\u0026quot;methodName\u0026quot;); Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(classname); } catch (ClassNotFoundException e) { e.printStackTrace(); } Method method = forName.getMethod(methodName); method.invoke(forName.newInstance()); }  反射可以越过 泛型检查 //反射可以越过 泛型检查 public static void test9() throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException { //此时只能添加Integer类型 ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); list.add(1); list.add(2); //list.add(\u0026quot;zs\u0026quot;); Class\u0026lt;?\u0026gt; listclass= list.getClass(); Method method = listclass.getMethod(\u0026quot;add\u0026quot;, Object.class); method.invoke(list, \u0026quot;zs\u0026quot;); System.out.println(list); }  不推荐这样做\n就像不推荐反射操作private修饰的东西\n虽然可以通反射访问 private等修饰符不允许访问的属性/方法，也可以忽略掉泛型的约束；但是实际的开发，不建议这样使用，因此可能造成程序的混乱。\n万能set import java.lang.reflect.Field; public class MyProperty { //per.setXxx(value) public static void setProperty(Object obj,String propertyName,Object value) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { Class\u0026lt;?\u0026gt; class1 = obj.getClass(); Field field = class1.getDeclaredField(propertyName); field.setAccessible(true); field.set(obj, value); } }  public static void test10() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException{ Person person = new Person(); MyProperty.setProperty(person, \u0026quot;name\u0026quot;, \u0026quot;zs\u0026quot;); MyProperty.setProperty(person, \u0026quot;age\u0026quot;, 23); Student student = new Student(); MyProperty.setProperty(student, \u0026quot;score\u0026quot;, 98); System.out.println(person); System.out.println(student); }  源码 github地址\n","id":7,"section":"posts","summary":"反射: 反射机制是在[运行状态]中: 对于任意一个类，都能够知道这个类的所有属性和方法; 对于任意一个对象，都能够调用它的任意一一个方法和属性; 反","tags":["Java"],"title":"Java反射技术","uri":"https://mumulx.github.io/2020/01/java%E5%8F%8D%E5%B0%84%E6%8A%80%E6%9C%AF/","year":"2020"},{"content":" 虚拟机启动访问 启动mongodb cd /usr/local/mongodb/bin/ ./mongod --port 27017 --dbpath=/data/mongodb  登录数据库 cd /usr/local/mongodb/bin/ netstat -lanp | grep \u0026quot;27017\u0026quot; ./mongo use admin db.auth(\u0026quot;root\u0026quot;,\u0026quot;135451\u0026quot;)  启动redis cd /data/redis/bin/ redis-server  启动EasyMock cd /app/easyMock/easy-mock/ npm run dev  本机访问 http://centos6:7300/  linux软件安装 使用到的软件有nodejs、mongodb、redis、easy-mock、git\nnodejs安装 cd opt wget https://nodejs.org/dist/v8.11.1/node-v8.11.1-linux-x64.tar.xz xz -d node-v8.11.1-linux-x64.tar.xz tar -xvf node-v8.11.1-linux-x64.tar cd node-v8.11.1-linux-x64/bin pwd ln -s /opt/node-v8.11.1-linux-x64/bin/node /usr/sbin/node ln -s /opt/node-v8.11.1-linux-x64/bin/node /usr/bin/node ln -s /opt/node-v8.11.1-linux-x64/bin/npm /usr/sbin/npm ln -s /opt/node-v8.11.1-linux-x64/bin/npm /usr/bin/npm  测试 node -v npm -v  安装cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org ln -s /opt/node-v8.11.1-linux-x64/bin/cnpm /usr/sbin/cnpm ln -s /opt/node-v8.11.1-linux-x64/bin/cnpm /usr/bin/cnpm  软连接 创建软链接 ln -s [源文件或目录] [目标文件或目录]  例如：\n当前路径创建test 引向/var/www/test 文件夹\nln –s /var/www/test test  创建/var/test 引向/var/www/test 文件夹\nln –s /var/www/test /var/test  删除软链接 和删除普通的文件是一样的，删除都是使用rm来进行操作\nrm –rf 软链接名称（请注意不要在后面加”/”，rm –rf 后面加不加”/” 的区别，可自行去百度下啊）  例如：\n删除test\nrm –rf test  修改软链接 ln –snf [新的源文件或目录] [目标文件或目录]  这将会修改原有的链接地址为新的地址\n例如：\n创建一个软链接\nln –s /var/www/test /var/test  修改指向的新路径\nln –snf /var/www/test1 /var/test  错误解决 python: /lib64/libc.so.6: versionGLIBC_2.14\u0026rsquo; not found (required by /usr/lib64/libpython2.7.so.1.0)，`\nhttp://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz http://ftp.gnu.org/gnu/glibc/glibc-ports-2.14.tar.gz tar -xvf glibc-2.14.tar.gz tar -xvf glibc-ports-2.14.tar.gz mv glibc-ports-2.14 glibc-2.14/ports mkdir glibc-2.14/build cd glibc-2.14/build ../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin make make install  strings /lib64/lib.so.6 |grep GLBC_  查看是否有2.14版本\nMongodb安装 cd /opt wget http://downloads.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.2.10.tgz tar -zxvf mongodb-linux-x86_64-rhel70-3.2.10.tgz.gz mv mongodb-linux-x86_64-rhel70-3.2.10 /usr/local/mongodb mkdir -p /data/mongodb cd /usr/local/mongodb/bin ./mongod --port 27017 --dbpath=/data/mongodb 启动服务  终端在运行，如果想操作的话，换另一个终端\nnetstat -lanp | grep \u0026quot;27017\u0026quot; 检查是否启动 ./mongo 进入数据库 use admin 登录 db.createUser({user:\u0026quot;root\u0026quot;,pwd:\u0026quot;yourpasswd\u0026quot;,roles:[\u0026quot;root\u0026quot;]}); db.auth(\u0026quot;root\u0026quot;,\u0026quot;yourpasswd\u0026quot;)  redis安装 cd /opt wget http://download.redis.io/releases/redis-2.8.0.tar.gz tar zxf redis-2.8.0.tar.gz mv redis-2.8.0 /data/redis yum install gcc cpp binutils glibc glibc-kernheaders glibc-common glibc-devel tcl cd /data/redis cd tests/unit/ vi memefficiency.tcl 找到16384,把后面的0.90改成0.80 cd .. cd .. make \u0026amp;\u0026amp; make test 等待较长时间后 cd src make install cd .. mkdir etc mkdir bin mv redis.conf /data/redis/etc/ cd src mv mkreleasehdr.sh redis-benchmark redis-check-aof redis-cli redis-server /data/redis/bin/ cd .. cd bin redis-server  cd etc/ vim redis.conf daemonize 将no修改为yes 再次启动redis服务，并指定启动服务配置文件 redis-server /data/redis/etc/redis.conf  问题解决 Creating Server TCP listening socket *:6379: bind: Address already in use\nps -ef | grep -i redis  结果\nroot 3086 1 0 Apr24 ? 00:00:07 ./bin/redis-server *:6379 root 3531 3467 0 01:00 pts/0 00:00:00 grep -i redis  杀死指定进程\nkill -9 3086  重新启动服务即可\n安装git  cd /app yum install gcc perl-ExtUtils-MakeMaker 在https://github.com/git/git/releases下载安装包，上传到linux tar -zxvf v2.22.0.tar.gz cd git-2.22.0 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker yum -y remove git make prefix=/usr/local/git all make prefix=/usr/local/git install vi /etc/profile export PATH=$PATH:/usr/local/git/bin source /etc/profile git --version  安装EasyMock cd /app/easymock git clone https://github.com/easy-mock/easy-mock.git cd easy-mock/ cnpm install npm run build npm run start  ","id":8,"section":"posts","summary":"虚拟机启动访问 启动mongodb cd /usr/local/mongodb/bin/ ./mongod --port 27017 --dbpath=/data/mongodb 登录数据库 cd /usr/local/mongodb/bin/ netstat -lanp | grep \u0026quot;27017\u0026quot; ./mongo use admin db.auth(\u0026quot;root\u0026quot;,\u0026quot;135451\u0026quot;) 启动redis cd /data/redis/bin/ redis-server 启动EasyMock cd /app/easyMock/easy-mock/ npm run dev 本机访问 http://centos6:7300/ li","tags":["杂七杂八"],"title":"虚拟机搭建easymock","uri":"https://mumulx.github.io/2020/01/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BAeasymock/","year":"2020"},{"content":" 入门训练 圆的面积 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;iostream\u0026gt; int main (){ int r; scanf(\u0026quot;%d\u0026quot;,\u0026amp;r); double pi = 3.14159265358979323,s; s=pi * r *r; printf(\u0026quot;%.7f\u0026quot;,s); return 0; }  小数点的控制\n%d\t按十进制整型数据的实际长度输出。 %ld\t输出长整型数据。 %lld\t输出长长整型数据。 %md\tm 为指定的输出字段的宽度。如果数据的位数小于 m，则左端补以空格，若大于 m，则按实际位数输出。 %u\t输出无符号整型（unsigned）。输出无符号整型时也可以用 %d，这时是将无符号转换成有符号数，然后输出。但编程的时候最好不要这么写，因为这样要进行一次转换，使 CPU 多做一次无用功。 %c\t用来输出一个字符。 %f\t用来输出实数，包括单精度和双精度，以小数形式输出。不指定字段宽度，由系统自动指定，整数部分全部输出，小数部分输出 6 位，超过 6 位的四舍五入。 %.mf\t输出实数时小数点后保留 m 位，注意 m 前面有个点。 %o\t以八进制整数形式输出，这个就用得很少了，了解一下就行了。 %s\t用来输出字符串。用 %s 输出字符串同前面直接输出字符串是一样的。但是此时要先定义字符数组或字符指针存储或指向字符串，这个稍后再讲。 %x（或 %X 或 %#x 或 %#X）\t以十六进制形式输出整数，这个很重要。  入门训练 序列求和 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;iostream\u0026gt; using namespace std; int main (){ long long int n; scanf(\u0026quot;%d\u0026quot;,\u0026amp;n); long long int count=0; count = n*(n+1)/2; printf(\u0026quot;%lld\u0026quot;,count); return 0; }  注意：long long int的输出格式是%lld\n 短整型short：所占内存大小：2byte=16bit；\n所能表示范围：-32768~32767；(即-2^15~2^15-1)\n 整型int：所占内存大小：4byte=32bit；\n所能表示范围：-2147483648~2147483647；(即-2^31~2^31-1)\nunsigned: 所占内存大小：4byte=32bit；\n所能表示范围：0~4294967295；(即0~2^32-1)\n 长整型long：所占内存大小：4byte=32bit；\n所能表示范围：-2147483648~2147483647；(即-2^31~2^31-1)\nunsigned long: 所占内存大小：4byte=32bit；\n所能表示范围：0~4294967295；(即0~2^32-1)\n  注：上面所说的全部是有符号型的，short，int，long都默认为有符号型，其中long和int都占4个字节的空间大小，他们有什么区别呢？\nC语言规定：无论什么平台都要保证long型占用字节数不小于int型, int型不小于short型。\n 字符型char：所占内存大小：1byte=8bit；\n所能表示范围：不确定！！！！；\nunsigned char：所占内存大小：1byte=8bit；\n所能表示范围：0~255；(0~2^8-1)\nsingned char: 所占内存大小：1byte=8bit；\n所能表示范围：-128~127；(-2^7~2^7-1)\n  char的默认类型不确定有可能是unsigned，也有可能是signed，主要更具编译器而定，可以自己测试一下编译器的默认char的符号类型。\n 布尔类型bool：所占内存大小：1byte=8bit；\n所能表示的范围：只能取两个值false或者true；所以最小值就是：0， 最大值：1.\n 单精度float： 所占内存大小：4byte=32bit；\n所能表示的范围：(1.17549e-038)~(3.40282e+038);\n  注意：浮点数在内存中都是按科学计数法来存储的，浮点数的精度是由尾数的位数决定 的，大家记住即可不 必深究；\n 双精度double：所占内存大小：8byte=32bit；\n所能表示的范围：(2.22507e-308)~(1.79769e+308);\n  注：如何区分和使用这两个浮点类型呢，首先float和double的精度不同，float保留到小数点后面7位，而double保留到小数点后面16位，float能保证6位有效数字，而double能保证15位有效数字，如果在不追求精度的的情况下当然用 float比较好，节省内存，如果需要很高的精度的情况下，最好还是用double，平时我们定义浮点型变量一般都用double，毕竟精度高，一般精度的损失是不能忽略的。\n 字符串string：由于string在c++中属于类类型，不是基本数据类型，类不能计算其在内存中所占大小，非要用sizeof(string)来算的话，一般算出来的结果是 sizeof(string)=4byte， 如果string字符串内容很多，很明显就不是其真实大小，string类里面有计算其字节大小的函数如：size(),length()。  ","id":9,"section":"posts","summary":"入门训练 圆的面积 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;iostream\u0026gt; int main (){ int r; scanf(\u0026quot;%d\u0026quot;,\u0026amp;r); double pi = 3.14159265358979323,s; s=pi * r *r; printf(\u0026quot;%.7f\u0026quot;,s); return 0; } 小数点的控制 %d 按十进制整型数据的实际长度输出。 %ld 输出长整型数据。 %lld 输出长长整型数据。","tags":["杂七杂八"],"title":"蓝桥杯算法笔记","uri":"https://mumulx.github.io/2020/01/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","year":"2020"},{"content":" 学java的时候还是使用的Eclipse，并且使用了很长一段时间。然后学JSP的时候使用的是Eclipse IDE。接着就到了学习Spring家族的时候用的是STS。慢慢就听说了IDEA这个工具，听说要比Eclipse好用一些，第一次使用IDEA的时候是跟着老师学习在IDEA中使用Gradle整合gretty进行Web开发的时候。突然感觉IDEA好像确实名不虚传，这里就记录一下自己的IDEA的简单配置，这些配置有些是Eclipse中有的，有一些是Eclipse中没有的。工欲善其事，必先利其器，好的开发工具能提高自己的开发效率。\n修改配置文件 找到IDEA的安装目录/bin/idea64.exe.vmoptions文件修改\n-Xms500m -Xmx1500m -XX:ReservedCodeCacheSize=500m   -Xms500m \u0026ndash; Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值\n -Xmx1500m \u0026ndash; Java Heap最大值，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定\n -XX:ReservedCodeCacheSize=500m \u0026ndash; 预留保存代码的内存空间大小\n  注意：电脑配置在16G 64位系统时修改，可以提高IDEA的启动速度，代码自动保存的频率，提高开发效率。内存太小，不修改也可以。\n设置文件会放到github上，大家自行导入就行了github地址\n快捷键 直接导入快捷键设置，文件也在上面的github仓库中，采用的是类似Eclipse的快捷键的设置。\n执行(run)\talt+r 提示补全(Class Name Completion) alt+/ 单行注释 ctrl+/ 多行注释 ctrl+shift+/ 向下复制一行(Duplicate Lines) ctrl+alt+downe 删除行或选中行(delete line) ctrl+d 向下移动行(move statement down) alt+down 向上移动行(move statement up) alt+up 向下开始新的一行(start new line) shift+enter 向上开始新的一行 ctrl+shift+entere 如何查看源码(class) ctrl+选中指定的结构或ctrl+shift+t 万能解错/生成返回值变量 alt+enter 退回到前一个编辑的页面(back) alt+left 进入到下一个编辑的页面 alt +right 查看继承关系(type hierarchy) F4. 格式化代码(reformat code) ctrl+shift+F 提示方法参数类型(Parameter Info) ctrl+alt+/ 复制代码 ctrl+C 撤销 ctrl+Z 反撤销 ctrl+y 剪切 ctrl+X 粘贴 ctrl+V 保存 ctrl+S 全选 ctrl+a 选中数行，整体往后移动 tab 选中数行，整体往前移动 shift + tab 查看类的结构:类似Feclipse 的outline ctrl+o 重构:修改交量名与方法名(rename) alt+shift+r 大写转小写/小写转大写(toggle case) ctrl+shift+y 生成构造器/get/set/tostring alt+shift+s 查看文档说明(quick documentation) F2 收起所有的方法(collapse all) alt+shift+C 打开所有方法(expand all) alt+shift+x 打开代码所在硬盘文件夹 ctrl+shift+x 生成try- catch等(surround with) alt+shift+z 局部变量抽取为成员变量 alt+shift+f 查找/替换(当前) ctrl+f 查找(全局) ctrl+h 查找文件 double shift 查看类的继承结构图(Show UML Diagram) ctrl+shift+u 查看方法的多层重写结构(method hierarchy) ctrl+alt+h 添加到收藏(add to favorites) ctrl+alt+f 抽取方法(Extract Method) alt+shift+m 打开最近修改的文件(Recently Files) ctrl+E 关闭当前打开的代码栏(close) ctrl+W 关闭打开的所有代码栏(close all) ctrl+shift+W 快速搜索类中的错误(next highlighted error) ctrl+shift+q 选择要粘贴的内容(Show in Explorer) ctrl+shift+V 查找方法在哪里被调用(Call Hierarchy) ctrl+shift+h 查看 树形 的类层次结构图 F4 结尾符 ctrl+alt+enter 快速添加返回值 ctrl+alt+v 代码格式化 ctrl+alt+l  模板 IDEA中代码模板所处的位置: settings Editor Live Templates/Postfix completion\npsvm public statis void mian(String[] args){ }  sout System.out.println(\u0026quot;\u0026quot;);  soutp System.out.println(\u0026quot;args = [\u0026quot; + args + \u0026quot;]\u0026quot;);  输出形参\nsoutm System.out.println(\u0026quot;test.main\u0026quot;);  输出方法名\nsoutv System.out.println(\u0026quot;a = \u0026quot; + a);  输出变量：就近原则\nxxx.sout a.sout System.out.println(a);  输出变量a\nfori for (int i = 0; i \u0026lt; ; i++) { }  iter for (String arg : args) { }  itar for (int i = 0; i \u0026lt; args.length; i++) { String arg = args[i]; }  list.for for (Object o : list) { }  遍历list\nlist.fori for (int i = 0; i \u0026lt; list.size(); i++) { }  list.forr for (int i = list.size() - 1; i \u0026gt;= 0; i--){ }  ifn if (list == null) { }  inn if (list != null) { }  xxx.nn if (list != null) { }  xxx.null if (list == null) { }  prsf private static final  psf public static final  psfi public static final int  psfs public static final String  ","id":10,"section":"posts","summary":"学java的时候还是使用的Eclipse，并且使用了很长一段时间。然后学JSP的时候使用的是Eclipse IDE。接着就到了学习Spring","tags":["开发软件"],"title":"IntelliJIDEA基础配置","uri":"https://mumulx.github.io/2020/01/intellijidea%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/","year":"2020"},{"content":" 下面来介绍几个我自己用到的vscode的插件\n主题  Atom One Dark Theme  文件图标主题  vscode-icons  代码格式化  Beautify  中文汉化  Chinese (Simplified) Language Pack for Visual Studio Code  与谷歌浏览器的链接  Debugger for Chrome  js语言  ESLint\n JavaScript (ES6) code snippets\n  HTML CSS  HTML CSS Support\n HTML Snippets\n  标签的提示修改  Auto Rename Tag\n  JQuery  jQuery Code Snippets  Vue  Vetur\n Vue 2 Snippets\n  写博客使用的markdown  markdownlint  打开浏览器  open in browser  显示路径文件  Path Intellisense  建议将自动保存选项给勾上，不然\u0026hellip;..血一样的教训。文件\u0026ndash;\u0026gt;自动保存前面打上钩\n以前前端做网页使用JQuery的时候还是比较喜欢HBuilder这个软件的。\n当使用Vue的话，感觉还是vscode更好用一些。\n以前没接触到vscode，学C++的时候还是用的visual studio2010，听到vscode的第一印象是visual studio，就像听到JavaScript和Java的感觉一样。并不很想用，用了之后发现 ,真香!!!!!!!\nvscode是世界上最好的编辑器！！！！！不接受反驳。\n","id":11,"section":"posts","summary":"下面来介绍几个我自己用到的vscode的插件 主题 Atom One Dark Theme 文件图标主题 vscode-icons 代码格式化 Beautify 中文汉化 Chinese (Simplified) Language Pack for Visual Studio Code 与谷歌浏览器的链接 Debugger for Chrome js语言 ESLint","tags":["开发软件"],"title":"VisualStudioCode常用插件","uri":"https://mumulx.github.io/2020/01/visualstudiocode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/","year":"2020"},{"content":" 简介 Web前端技术栈包括\n elementUI Nuxt Vue.js webpack ESLint Node.js axios mock.js ES6 Swagger  核心：Node.js和Vue.js\nwebpack webpack:打包, 可用将js等静态资源进行压缩，从而提高性能 可以打包js\\css\\图片等资源\n使用 下载安装 cnpm install webpack -g cnpm install webpack-cli -g  测试：\nwebpack -v  配置 新建并配置配置文件webpack.config.js\nvar path = require( 'path') ; module. exports = { entry: './src/main.js' ,//入口文件 output: {//输出文件 //_ di rname/.dist/bundle.is path: path. resolve(_ dirname, '.dist'), filename : 'bundle.js } }  运行 cmd到指定目录\nwebpack  webpack不能实现自动更新，修改代码后需要自己重新手动打包\n** 注意**：webpack本身只能打包js文件如果想打包css和图片文件的时候需要安装插件\n安装插件 npm install style-loader css-loader --save-dev  使用插件打包css  配置文件webpack.config.js\nvar path = require( 'path') ; module. exports = { entry: './src/main.js' ,//入口文件 output: {//输出文件 //_ di rname/.dist/bundle.is path: path. resolve(_ dirname, '.dist'), filename : 'bundle.js }, moudle:{ rules:[ { test:/\\.css$/, use:['style-loader','css-loader'] } ] } }  css文件要在主函数(main.js)中引用\nrequire('xxx.css')  使用\n执行cmd\n webpack  小结\n今后要使用css和js只要直接在html中引用bundle.js\n  实现修改css/js后，不打包，直接使得html生效 安装 npm i webpack-dev-server --save-dev  如果直接执行： webpack-dev-server ，会报错误：缺失该命令。\n原因：能够在cmd中执行直接的命令，必须是全局命令。\n全局安装\nnpm i webpack-dev-server -g  启动 cmd执行\nwebpack-dev-server  启动： webpack-dev-server ：自动将打包后的boundle.js -\u0026gt;加载到内存中（boundle.js）\nwebpack-dev-server启动模式，会将boundle.js加载到内存中。使用时，直接在当前目录中引用\u0026lt;script src=\u0026quot;bundle.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 这样好处：\n 热更新，css/js -\u0026gt;html 在内存中，因此速度快  也可以将该命令 配置在package.json中配置scrpit脚本\n{ \u0026quot;scripts\u0026quot;: { \u0026quot;dev\u0026quot; : \u0026quot;webpadk -dev-server \u0026quot; }, \u0026quot;devDependencies\u0026quot;: { \u0026quot;css- loader\u0026quot;: \u0026quot;^3.0. 0\u0026quot;, \u0026quot;style-loader\u0026quot;: \u0026quot;^0.23. 1 \u0026quot;, \u0026quot;webpack\u0026quot;: \u0026quot;^4.35.2\u0026quot;, \u0026quot;webpack-cli \u0026quot;:1 1^3.3.5” \u0026quot;webpack -dev-server\u0026quot;: \u0026quot;^3. 7.2\u0026quot; } }  直接运行\nnpm run dev  即可\n可以改修改启动时的默认文件目录：  修改成目录而不是文件\n 默认的文件名是index.html\n\u0026quot;scripts\u0026quot;:{ \u0026quot;dev\u0026quot; : \u0026quot;webpack-dev-server --contentBase src\u0026quot; },  d:/a/b/c/index.html\nd:/a/b/c/\n  修改端口以及自动启动 \u0026quot;scripts\u0026quot;:{ \u0026quot;dev\u0026quot; : \u0026quot;webpack-dev-server --port 8888 --open\u0026quot; }  注意：\nconsole.log(str);//cmd打印 - 调试窗口 document.write(str);//html  ES6 ESMAScript6.0 是一种规范JavaScript只是它的一个实现\n它有1、2、3、5、6这几个版本，4被废弃了\n ESMAScript6.0 是一套规范（2015年产生）：\n javascript是ESMAScript的具体实现\n NodeJs是javascript的脚本库\n  注意：\nNodeJs支持大部分的ESMAScript6.0 标准， 个别不支持 的需要回退5.0.\n版本回退，NodeJS会通过转换器自动搞定。\n转换器 配置转换器 新建文件并编辑(.babelrc)\n{ \u0026quot;presets\u0026quot;:['es2015'] }  安装转换器 cnpm install babel-preset-es2015 --save-dev  \u0026ndash;save-dev：以dev的方式安装\n安装命令行工具 cnpm install babel-cli -g  使用：  正常\nnode xxx.js  个别：\n如果遇到Nodejs不支持的ES6，则切换使用：\nbabel-node xxx.js   变量自动提升等级 test(); function(){ if(3\u0026lt;2\u0026gt;){ var a = 123; }else{ console.log(a); } }  运行结果：undefined\n没有报错\n原因：当使用a变量的时候发现当前找不到a但是上一级中有a，因此自动将a的等级提升变成\ntest(); function(){ var a； if(3\u0026lt;2\u0026gt;){ a= 123; }else{ console.log(a); } }  这种感觉\n如果不想自动提升则使用关键字let\ntest(); function(){ if(3\u0026lt;2\u0026gt;){ let a = 123; }else{ console.log(a); } }  运行结果：报错\n小结：\n var定义的变量，如果不存在，会自动提升（ 会将之前的局部变量，提升成全局变量 ） let:ES6 定义变量，和java等语言一样 严格控制变量的作用域（ES6新规范）\n const：常量（ES6新规范）\n  占位符/模板字符串 console.log('张三的年龄是：'+age);  可与写成\nconsole.log(`张三的年龄是：${age}`);  注意:占位符的符号是 ` 而不是 \u0026lsquo;\n换行符\n以前想要换行\nconsole.log('张三的年龄是：\\ 100');  现在：\nconsole.log(`张三的年龄是： 100`);  不需要使用\\连接\n函数默认参数 function test(a){ console.log(a); } test()  输出结果：\nundefined  现在\nfunction test(a=99){ console.log(a); } test()  输出结果\n99  箭头函数  不需要function关键字\n 省略return\n 继承this  之前\nfunction test(a,b){ console.log(a+b); }  现在\n(a,b)=\u0026gt; console.log(a+b);  以前\nfunction test(a,b){ return a+b; }  现在\n(a,b)=\u0026gt; (a+b);  对象初始化 以前\nfunction persion(pname,page){ return { name:pname; age:page; } }  现在\nfunction persion(pname,page){ return { pname; page; } }  可以省略属性名\n解构：方便的给对象、数组赋值 以前\nvar person={ name:'zs', age:23 } var pname =persion.name; var page = persion.age; console.log(`$(pname),$(page)`);  现在\nvar person={ name:'zs', age:23 } var {name,age}=persion; console.log(`$(name),$(age)`);  变量名与属性名要相等\n数组赋值\nconst fruit = ['apple','orange'] ; let [one,two] = fruit;  值的顺序与数组的顺序一致\n传播Spread Operator const fruit = ['apple','orange'] ; const fruit1=[...fruit,'pear']  此时fruit1中的前两个值就是fruit中的值\nvar person={ name:'zs', age:23 }; var person2={ ...persion, height:180 };  person2对象前两个属性是person中的属性\n导入导出 exports require()\nexports.fn=function(){ console.log('xx'); } require('./hello.js')  export import\nvar fn=function(){ console.log('xx'); } export{fn}; import{fn} from './hello.js'  使用export import时需要使用bable-node指令执行js文件\n分号结尾 分号 ：风格问题 可以加也可以不加（建议要么加要么不加）\n两个特殊情况 必须加：\n 下一条语句是()或[]开头，则上一条必须加;\n//以()开头 (function(){})() //以[]开头 [\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;].forEach(function(){ })   当都不加时，上一句的分号可以加在下一句的开头，即\n//以()开头 ;(function(){})() //以[]开头 ;[\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;].forEach(function(){ })  数据类型 基本类型  string number boolean undefined ：只定义，没赋值; var a ; null  引用类型  Object：任何对象 Function:函数 Array：数组\n数组和函数 都属于Object\n  判断类型  == / ===\n== 宽松的判断（自带类型转换）\n1==\u0026quot;1\u0026quot; 此时为true  ===严格的判断 （建议使用）\n1===\u0026quot;1\u0026quot; 此时为false  typeof：判断是否是某个类型 ，结果以“字符串形式”体现\nvar num; console.log(num,typeof num === 'undefined');  输出结果：\nundefined true  instanceof ：判断是否某个具体类型\n  prototype 原型 可以向对象 增加属性 或者方法\n每个函数都自带一个prorotype属性 ，默认情况下 指向一个空对象{} (称为原型对象，prototype对象) 原型对象（prototype对象） 都有一个constructor（构造方法）属性，它指向函数本身\nfunction myfun(){ } console . log(myfun. prototype ) console . log( myfun . prototype . constructor )  结果：\nmyfun{} 对象 [Function: myfun] 方法  使用 function Myfun(){ } Myfun.prototype.say=function(){ console.log(\u0026quot;this is a methods\u0026quot;) } var myfun= new Myfun(); myfun.say();  注意：\n 如果一个函数只有定义，即只有右边Myfun(){}，可以直接使用函数名.prototype;\n 如果一个函数有var myfun = function Myfun(){},则只能通过myfun.prototype\n  Restful编程风格  参数格式\nget方式传值\nlocalhost:8080/myproject?name=zs  Restful方式传值\nlocalhost:8080/myproject/zs ，将zs传递给后端  请求方式\npost： 增（查） delete: 删 put： 改 get： 查   get请求方式的地址栏中：\nlocalhost:8080/myproject?name=zs\u0026amp;age=23\u0026amp;hei=xxx\u0026amp;xxx...............  地址栏长度有限制 260-300 如果请求参数太长，超过了地址栏 范围，则只能换用其他请求方式（post）\nswagger Swagger是一款RESTFUL接口的文档在线自动生成+功能测试功能软件。Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化RESTfu风格的web服务。目标是使客户端和文件系统作为服务器一同样的速度来更新文件的方法，参数和模型紧密集成到服务器。这个解释简单点来讲就是说，swagger是一款可以根据restful风格生成的接口开发文档，并且支持做测试的一款中间软件。\n下载安装 swagger官网\n下载swagger Editor\n安装：package.json目录执行：\nnpm install  如果出现以下问题：\nError: Can't find Python executable \u0026quot;python\u0026quot;, you can set the PYTHON env variable  解决：\n * 管理员身份启动cmd * npm install --global --production windows-build-tools  再次执行：\n npm install  或使用在线版\n启动 双击index.html文件\n使用 swagger: '2.0' swagger版本号 info: version: \u0026quot;1.0.0\u0026quot; 文档的版本当 title: School-API 文档名称 host: xxx.xx.xx 项目地址 basePath: /xx 项目名 paths: 项目具体路径 /xx: 第一个访问地址 post: post请求 summary: 新增学校 注释 parameters: 传参 - 第一个参数，一个-代表一个参数 name: body 参数名 in: body 对象 description: 学校实体类 参数描述 required: true 参数是可选还是必须的 schema: 定义对象类型 $ref: '#/definitions/School' 类型是definitions中的School类型，definitions定义在后面 responses: 响应 200: 状态码 description: 成功响应 描述 schema: 响应数据 $ref: '#/definitions/ApiResponse' 数据类型 get: get请求 summary: 返回学校列表 描述 responses: 响应 200: 状态码 description: 成功响应 描述 schema: 数据 $ref: '#/definitions/ApiSchoolListResponse' definitions: 对象类型 School: 名称 type: object 类型 properties: 属性 id: 属性名 type: string 属性类型 description: ID 描述 name: 属性名 type: string 属性类型 description: 学校名称 描述 ApiResponse: 对象名 type: object 对象类型 properties: 属性 flag: 标识是否成功 type: boolean 类型 description: 是否成功 描述 code: 状态码 type: integer format: int32 description: 返回码 message: 返回信息 type: string description: 返回信息 ApiSchoolResponse: type: object properties: flag: type: boolean description: 是否成功 code: type: integer format: int32 description: 返回码 message: type: string description: 返回信息 data: $ref: '#/definitions/School' SchoolList: type: array items: $ref: '#/definitions/School' ApiSchoolListResponse: type: object properties: flag: type: boolean description: 是否成功 code: type: integer format: int32 description: 返回码 message: type: string description: 返回信息 data: $ref: '#/definitions/SchoolList'  in 的类型\nlocalhost: 8080/yq/school?a=b\u0026amp;c=d -query localhost: 8080/yq/school/b/d -path localhost: 8080/yq/school -body 对象类型  等等其他类型\n实例\nswagger: '2.0' info: version: \u0026quot;1.0.0\u0026quot; title: School-API host: xx.xx.xx basePath: /xx paths: /school: post: summary: 新增学校 parameters: - name: body in: body description: 学校实体类 required: true schema: $ref: '#/definitions/School' responses: 200: description: 成功响应 schema: $ref: '#/definitions/ApiResponse' get: summary: 返回学校列表 responses: 200: description: 成功响应 schema: $ref: '#/definitions/ApiSchoolListResponse' /school/{schoolId}: put: summary: 修改学校 parameters: - name: schoolId in: path description: 学校ID required: true type: string - name: body in: body description: 学校实体类 required: true schema: $ref: '#/definitions/School' responses: 200: description: 成功响应 schema: $ref: '#/definitions/ApiResponse' delete: summary: 删除学校 parameters: - name: schoolId in: path description: 学校ID required: true type: string responses: 200: description: 成功响应 schema: $ref: '#/definitions/ApiResponse' get: summary: 根据ID查询学校 parameters: - name: schoolId in: path description: 学校ID required: true type: string responses: 200: description: 成功响应 schema: $ref: '#/definitions/ApiSchoolResponse' /school/search: post: summary: 根据条件查询学校列表 parameters: - name: body in: body description: 学校实体类 required: true schema: $ref: '#/definitions/School' responses: 200: description: 成功响应 schema: $ref: '#/definitions/ApiSchoolListResponse' /school/search/{page}/{size}: post: summary: 根据条件查询学校列表 parameters: - name: page in: path description: 页码 required: true type: integer format: int32 - name: size in: path description: 页大小 required: true type: integer format: int32 - name: body in: body description: 学校实体类 required: true schema: $ref: '#/definitions/School' responses: 200: description: 成功响应 schema: $ref: '#/definitions/ApiSchoolPageResponse' definitions: School: type: object properties: id: type: string description: ID name: type: string description: 学校名称 isPopular: type: string description: 是否热门 ApiResponse: type: object properties: flag: type: boolean description: 是否成功 code: type: integer format: int32 description: 返回码 message: type: string description: 返回信息 ApiSchoolResponse: type: object properties: flag: type: boolean description: 是否成功 code: type: integer format: int32 description: 返回码 message: type: string description: 返回信息 data: $ref: '#/definitions/School' SchoolList: type: array items: $ref: '#/definitions/School' ApiSchoolListResponse: type: object properties: flag: type: boolean description: 是否成功 code: type: integer format: int32 description: 返回码 message: type: string description: 返回信息 data: $ref: '#/definitions/SchoolList' ApiSchoolPageResponse: type: object properties: flag: type: boolean description: 是否成功 code: type: integer format: int32 description: 返回码 message: type: string description: 返回信息 data: properties: total: type: integer format: int32 rows: $ref: '#/definitions/SchoolList'  只给显示界面 下载swagger-ui swagger-ui依赖nginx\n下载nginx 使用 swagger-ui-master.zip,解压，将其中的dist目录中的全部文件，拷贝到nginx中的html目录中\n运行 进入nginx目录cmd\nstart nginx.exe  访问\nlocalhost：80  整合 导出文件 swagger Editor中选择Generate Client中选择swagger-yaml\n导入swagger ui  将yaml文件拷贝到nginx的html目录中即可\n 搜索文件xxx.yaml\n  注意：文件后缀yaml和yml建议改成yml\nmock.js mockjs 可以以无侵入的方式拦截 ajax 请求，通过模拟服务器端响应来返回数据\n安装 cnpm install mockjs  语法  DTD:数据模板定义规范 DPD：数据占位符定义规范  DTD '属性名|规则': 属性值  实例\n'persons|10' :[{ 'id':1, 'name':'zs', 'age':23 }]  规则：\n 属性值是字符串类型\n 字符串重复count次\n属性名|count: 字符串 'name|10':'zs'  字符串重复min-max中任意次\n属性名|min-max: 字符串 'name|2-5':'zs'   \u0026ndash;min-max代表次数\n 属性值是数字类型\n 递增任意数字\n属性名|+1: 数字 'id|+1':1  数字范围\n属性名|min-max: 数字 --min-max代表范围 'id|10-20':0 代表数字类型没有任何意义(可变成任意数字)  数字显示小数\n属性名|min-max.x: 数字 --min-max代表范围 'id|10-20.2':0 10-20中任意数字两个小数位  数字显示任意小数\n属性名|min-max.a-b: 数字 'id|10-20.2-4':0 10-20中任意数字2-4任意的小数   属性值是布尔类型\n 相等出现概率\n'sex|1':true 代表true出现的次数 和false 的概率是 1:1  自定义出现概率\n'sex|2-4':true 代表true出现的概率 是 2/2+4   属性值是对象object类型\n对象类型是通过json格式写的\n 对象出现的个数\n'属性|count':{k:v,k:v,k:v....} 'address|2':{'homeaddress':'西安','schooladdress':'北京','workaddress':'泸州'} 显示其中的任意两个  出现min-max中任意个\n'属性|min-max':{...} 'address|1-3':{'homeaddress':'西安','schooladdress':'北京','workaddress':'泸州'} 显示其中的任意1-3个   属性值是数组类型\n 出现指定次\n '属性|count':[{}] 'persons|3' :[{ ...} }]  出现min-max次\n'属性|min-max':[{}] 'persons|1-6' :[{ ...} }]    DPD 产生随机数据\n类型要加上@符号加上''\n 'name':'@cname', 'xing':'@cfirst', 'exing':'@Last',  注意： 属性名重复的话，后一个的值会覆盖前一个的值，出现的位置是在第一个的位置\n实例 let mymock = require('mockjs'); let pers = mymock.mock({ 'persons|1-6' :[{ 'id|+10':1, 'name':'@cname', 'xing':'@cfirst', 'exing':'@Last', 'desc' : '@string', 'stuno':'@integer', 'birthday':'@date', 'pic':'@image', 'age|18-60':0 , 'brief': '@title', 'content': '@cword(100)', 'height|160-180.2':0 , 'weight|50-100.2-4':0, 'sex|2-3':true , 'address|1-3':{'homeaddress':'西安','schooladdress':'北京','workaddress':'泸州'}, 'url':'@url' , 'ip':\u0026quot;@ip\u0026quot; , 'email':'@email', 'area':'@region', 'address2':'@county(true)' }] /* 'persons|1-6' :[{ 'id|+10':1, 'name|2-5':'zs', 'age|18-60':0 , 'height|160-180.2':0 , 'weight|50-100.2-4':0, 'sex|2-3':true , 'address|1-3':{'homeaddress':'西安','schooladdress':'北京','workaddress':'泸州'} }] */ }); console.log( JSON.stringify(pers ,null, 2) );  Easy mock Easy mock官网\neasy mock:在线Mock.js\n 内置了mock.js并且 暴露了url地址\n 同步swagger  模拟数据： 1. mock.js 模拟数据： 当请求url时，返回mock.js模拟的数据\n swagger模拟数据：根据yml中的请求url设置url,返回 response中定义的数据（类型是swagger定义的，而数据是easymock模拟出来的）-》模拟数据，并且有查询此数据的url【 url -\u0026gt;模拟数据】  使用  进入官网 创建项目 编写接口  使用swagger编写的yaml同步到easymock  获得yaml文件\n 进入easymock项目\n 设置\n Swagger Docs API\n 上传yaml文件\n 保存\n 进入easymock项目点击同步Swagger\n  element ui elementui:前端脚手架,vue组件组\n官网\n很多三方组件 是基础是基于elementui进行了扩展。 举例：\n vue-admin-template  github地址\ngithub上有详细的用法\n根据github提示:\n克隆项目（下载） git clone https://github.com/PanJiaChen/vue-admin-template.git  进入项目目录 cd vue-admin-template  安装依赖 npm install  建议不要直接使用 cnpm 安装以来，会有各种诡异的 bug。可以通过如下操作解决 npm 下载速度慢的问题 npm install --registry=https://registry.npm.taobao.org  启动服务 npm run dev  注意:\n遇见错误Error: Cannot find module 'node-sass'解决办法\ncnpm install node-sass --save  目录结构  build 构建源码 mock 模拟数据 public 首页\n favicon.ico网站图标  src 源码\n api 前后端遵循的api接口\n assets 资源 components 组件 icons 图标 router 路由 utils 工具 views 视图  .env.development 数据来源\n 修改数据来源，来源于easymock\nbase api VUE_APP_BASE_API = \u0026lsquo;https://www.easy-mock.com/mock/5d088992010742640520057f/myeasymock' 修改后需要重启\n   修改语言 进入src/main.js文件，修改成\nimport locale from 'element-ui/lib/locale/lang/zh-CN'  将本地数据 复制到 easymock中一份  修改数据源：.env.development ：VUE_APP_BASE_API\n request\u0026ndash;response\n 先查看本地有什么数据(chrome-F12,network)\n请求\nRequest URL(POST): http://localhost:9528/dev-api/user/login  响应\n{\u0026quot;code\u0026quot;:20000,\u0026quot;data\u0026quot;:{\u0026quot;token\u0026quot;:\u0026quot;admin-token\u0026quot;}}  请求\nRequest URL(GET): http://localhost:9528/dev-api/user/info （注意不要加?token=admin-token，定义接口时不需要传值，在请求时才传值）  响应\n{\u0026quot;code\u0026quot;:20000,\u0026quot;data\u0026quot;:{\u0026quot;roles\u0026quot;:[\u0026quot;admin\u0026quot;],\u0026quot;introduction\u0026quot;:\u0026quot;I am a super administrator\u0026quot;,\u0026quot;avatar\u0026quot;:\u0026quot;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif\u0026quot;,\u0026quot;name\u0026quot;:\u0026quot;lx\u0026quot;}}  复制到easy mock\n  在easy中定义请求和响应\n  源码  router:路由器\n views:视图\n api：调用接口\n  前端开发 请求xxx -\u0026gt;router(\u0026quot;xxx\u0026quot;)-\u0026gt;views(\u0026lt;template\u0026gt;html搭建,\u0026lt;script\u0026gt;js)-\u0026gt;调用（api）-\u0026gt;url(参数)-\u0026gt;Easy Mock[swagger(yml，类型+变量名，String id)+mock.js(DPD @string)] )\n后台开发： 请求xxx-\u0026gt;@RequestMapping(\u0026quot;xxx\u0026quot;)-\u0026gt;service -\u0026gt;dao -\u0026gt;db 动态从数据库中查\n请求xxx-\u0026gt;@RequestMapping(\u0026quot;xxx\u0026quot;)-\u0026gt;service :return \u0026quot;abc\u0026quot; 硬编码\n实例 简单的查询 .vue/.js模块化编程：\nimport .. export  请求xxx -\u0026gt;router(\u0026quot;xxx\u0026quot;)-\u0026gt;views(\u0026lt;template\u0026gt;html搭建,\u0026lt;script\u0026gt;js)-\u0026gt;调用（api）-\u0026gt;url(参数)-\u0026gt;Easy Mock[swagger(yml，类型+变量名，String id)+mock.js(DPD @string)] )\nviews  新建文件夹、文件myactivity/activity.vue\n 编写代码\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-table :data=\u0026quot;activitiesData\u0026quot; stripe style=\u0026quot;width: 100%\u0026quot;\u0026gt; \u0026lt;el-table-column prop=\u0026quot;id\u0026quot; label=\u0026quot;编号\u0026quot; width=\u0026quot;130\u0026quot;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026quot;name\u0026quot; label=\u0026quot;活动名\u0026quot; width=\u0026quot;130\u0026quot;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026quot;starttime\u0026quot; label=\u0026quot;开始时间\u0026quot;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026quot;state\u0026quot; label=\u0026quot;状态\u0026quot;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import activityApi from '@/api/activity' export default{ //获取easy mock中的模拟数据 ;变量 data(){ return { //查询easymock时 传入的参数（活动对象） activityData : {}, //封装活动信息：id, } } , /* created():初始化方法 -\u0026gt; 加载数据 initActivities(); data()：为了给 \u0026lt;templete\u0026gt;里的table填充值 */ //初始化方法 created(){ this.initActivities(); }, methods:{ initActivities(){ activityApi.getActivitis().then(response=\u0026gt;{ //将easy mock中查询的活动数据 赋值给activitiesData this.activitiesData = response.data ; } ); } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt;   api 新建文件activity.js\nimport request from '@/utils/request' //activity export default { //请求easy mock，获取活动列表数据 getActivitis(){ return request({ url: '/yq/activity', method: 'get' }) } }  easymock 编写请求和响应\n{ \u0026quot;code\u0026quot;:20000, \u0026quot;flag\u0026quot;:true 'message\u0026quot; \u0026quot;@string\u0026quot;， \u0026quot;data|10\u0026quot;:[{ \u0026quot;id|+1\u0026quot;: 1， “name\u0026quot;: \u0026quot;@cword\u0026quot; ”summary\u0026quot; : \u0026quot;@cword(6,10)\u0026quot; , \u0026quot;detail\u0026quot;: \u0026quot;@cword(16,20)\u0026quot;， ”sponsor\u0026quot;:' ”@string\u0026quot; , ”image\u0026quot;: \u0026quot;@string\u0026quot; ， 'starttime\u0026quot;: \u0026quot;@date\u0026quot;， ”endtime\u0026quot;:\u0026quot; @date\u0026quot; , \u0026quot;address\u0026quot;: \u0026quot;@string\u0026quot;, enrolltime\u0026quot;: \u0026quot;@string\u0026quot; ， \u0026quot;state\u0026quot;:\u0026quot; @string ， 'school\u0026quot;: \u0026quot;@string\u0026quot; }] }  code的值必须是20000\n编写router路由 { path: '/example', component: Layout, redirect: '/example/table', name: 'Example', meta: { title: '示例', icon: 'example' }, children: [ { path: 'table', name: 'Table', component: () =\u0026gt; import('@/views/myactivity/activity'), meta: { title: '活动', icon: 'table' } }, { path: 'tree', name: 'Tree', component: () =\u0026gt; import('@/views/tree/index'), meta: { title: 'Tree', icon: 'tree' } } ] }  实例\u0026ndash;分页 easymock 'code\u0026quot;: 20000 , \u0026quot;flag\u0026quot;: true, \u0026quot;message\u0026quot;:\u0026quot;带分页的查询\u0026quot;, data\u0026quot;: { \u0026quot;total\u0026quot;: 109, \u0026quot;rows|10\u0026quot;: [{ id|+1\u0026quot;: 1, ”name”: \u0026quot;@cnpme\u0026quot;， summary\u0026quot;: \u0026quot;@string\u0026quot; ， detail\u0026quot;: @string\u0026quot;, \u0026quot;sponsor\u0026quot;: \u0026quot;@string\u0026quot; , ' image\u0026quot;:\u0026quot; @string\u0026quot; , starttime\u0026quot;:' \u0026quot;@string\u0026quot; , ”endtime\u0026quot;:” @string\u0026quot; , ”address\u0026quot;: \u0026quot;@string ”enrolltime\u0026quot;: \u0026quot;@string\u0026quot; , \u0026quot;state\u0026quot;: \u0026quot;@string\u0026quot; , ”school\u0026quot;: \u0026quot;@string }] }  数据的形式：\n response.data.total :总数据量 response.data.rows:每页的数据量  api  initActivitiesByPage(currentPage,pageSize,activityQueryData){ //currentPage:当前第几页 pageSize：每页的数据量 return request({ url: `/yq/activity/queryActivitiesByPage/${currentPage}/${pageSize}`, method: 'post', data: activityQueryData //时间、名称 }) },  Vue  //带分页：查看当前页的数据 initActivitiesByPage(){ activityApi.initActivitiesByPage(this.currentpage,this.pagesize,this.activityData ).then(response=\u0026gt;{ this.total = response.data.total ;//109 this.activitiesData = response.data.rows ; }) }   \u0026lt;div class=\u0026quot;block\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;demonstration\u0026quot;\u0026gt;分页\u0026lt;/span\u0026gt; \u0026lt;el-pagination @current-change =\u0026quot;initActivitiesByPage\u0026quot; @size-change= \u0026quot;initActivitiesByPage\u0026quot; :page-sizes=\u0026quot;[10,20,30]\u0026quot; :page-size=\u0026quot;pagesize\u0026quot; :current-page=\u0026quot;currentpage\u0026quot; layout=\u0026quot;prev, pager, next\u0026quot; :total=\u0026quot;total\u0026quot;\u0026gt; \u0026lt;/el-pagination\u0026gt; \u0026lt;/div\u0026gt;  具体的代码放到百度网盘中了，自行下载；\n网盘地址\n提取码：abnl\nNuxt入门 nuxt官网\nnuxt：服务器渲染技术\najax -\u0026gt;服务端-\u0026gt;ajax\n服务端-\u0026gt;客户端\n服务端渲染优势：SEO ,提高网站的搜索排名 ， 爬虫 ：特点，不认识js（ajax就是js）\n下载运行 下载nuxt的模板代码starter-template github地址\n安装依赖 npm install  修改package.json中的占位符{{name}} \u0026quot;name\u0026quot;: \u0026quot;studynuxt\u0026quot;,  运行 npm run dev  访问 localhost:3000  源码  assets 静态资源 components 组件 static 静态图标 pages 页面 layouts 页面布局  layouts 页面布局三个部分\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;header\u0026gt;头部\u0026lt;/header\u0026gt; \u0026lt;nuxt/\u0026gt; \u0026lt;footer\u0026gt;尾部\u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;  pages 页面\n映射时，默认的文件名：index.vue\n映射目录“/”：代表的 pages目录\n\u0026lt;router-link to=\u0026quot;/userinfo\u0026quot;\u0026gt;  有两种可能： 1. pages/userinfo/index.vue 2. pages/userinfo.vue\n通过axios进行渲染\naxios 下载 cnpm install axios --save  share \u0026ndash;分享 share.js\nsocial-share.min.js\nshare.min.css\ngithub地址\n 引入。\nhttps://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css  编写DIV\n\u0026lt;div class=\u0026quot;social-share\u0026quot; \u0026gt;\u0026lt;/div\u0026gt;  完整性\nhttps://blog.csdn.net/liwenfei123/article/details/78952337 data-title data-description data-sites ：['qzone', 'qq', 'weibo','wechat', 'douban'] data-url data-xxx   代码 百度云\n提取码：a3xs\n","id":12,"section":"posts","summary":"简介 Web前端技术栈包括 elementUI Nuxt Vue.js webpack ESLint Node.js axios mock.js ES6 Swagger 核心：Node.js和Vue.js webpack webpack:打包, 可用将js等静态资源进行压缩，从而提高","tags":["前端框架"],"title":"Web前端技术栈","uri":"https://mumulx.github.io/2020/01/web%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/","year":"2020"},{"content":" vue介绍 vue是一个渐进式的JavaScript框架。渐进式：可插拔式、可扩展。\n我们刚开始只需要使用最核心的核心库，后期可以自己去增加新库。\nvue官网\nvue引入 vue提供了非常详细的官方文档，我们完全可以通过官方文档来学习vue.vue官方文档\nxx.vue文件组成结构： \u0026lt;template\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt;  在chrome中安装vue开发工具 解压文件下载,或者参考网上的解决方案进行安装\n该插件可以在chrome浏览器中充当vue的调试工具\nmvvm简介 html使用vue \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; var vm = new Vue({ el:'', data:{ }, methods:{ }, computed:{ }, directives:{ }, watch:{ }, components:{ }, filters:{ } }) \u0026lt;/script\u0026gt;   var vm = new Vue({});\n创建一个vue的实例\n当我们导入包之后在浏览器的内存中，就多了一个Vue的构造函数\n注意：我们new出来的这个vm对象就是我们mvvm中的vm调度者\n el\n表示，当前我们 new的这个vue实例，要控制页面上的哪一个区域\n data\ndata属性中，存放的时el中索要用到的数据，形式是采用key:value的形式\n这里的data 就是mvvm中的m，专门用来保存页面数据的\n通过 vue提供的指令，很方便的就能把数据渲染到页面上，程序员不需要手动操作dom元素了【前端的vue之类的框架，不提倡我们区手动操作dom元素了】\ndata中定义的变量是全局变量，所有vue对象都可以使用\ncomputed中的返回值也作为data中的一部分\n methods\n定义方法\n computed\n 进行计算，初始时自动加载，和变量是共享的（在data中定义的变量，就不能再在computed中定义）它中方法的返回值，也作为data变量存在：方法名就是变量名，返回值就是它的值。\n 当data数据发生改变时也会执行。\n computed中定义的data变量（类似方法的形式）只会被计算一次，之后会加入缓存中，之后在取值时，直接从缓存中获取。\ncomputed:{ ageAndName(){ return this.name+this.age; }  }\n  directives\n定义局部指令\n watch\n进行监听，将html中的数据放到data中(mvvm中 v\u0026ndash;\u0026gt;m),当数据发生变化时，触发监听\nwatch:{ name:function(value){ this.name1= value; } }  components\n定义组件\n filters\n定义过滤器\n 生命周期的函数\n  语法 插值表达式 {{}} 显示内容，只会替换自己的这个占位符，不会吧整个元素的内容清空\n\u0026lt;h1\u0026gt;{{name}}2222222\u0026lt;/h1\u0026gt; name:\u0026quot;helloword\u0026quot;  输出\nhelloword2222222  v-clock: 能够解决插值表达式闪烁的问题\n出现的原因：跟生命周期有关\nvue会先加载html文件，然后加载js文件，最后进行替换(vue数据)\n解决方案：先将元素隐藏，当加载完毕之后在进行显示\n 定义\n\u0026lt;style\u0026gt; [v-clock] { display: none; } \u0026lt;/style\u0026gt;  使用\n\u0026lt;p v-cloak\u0026gt;{{msg}}\u0026lt;/p\u0026gt;   使用v-clock能够解决插值表达式闪烁的问题，当网络较慢的时候{{msg}}会显示在页面中\nv-text: 显示内容，但是会覆盖元素中的原本内容\n\u0026lt;h1 v-text=\u0026quot;name\u0026quot;\u0026gt;222222\u0026lt;/h1\u0026gt; name:\u0026quot;helloword\u0026quot;  输出\nhelloword  v-html: 带渲染的显示，节点操作\n\u0026lt;h1 v-html=\u0026quot;site\u0026quot;\u0026gt;\u0026lt;/h1\u0026gt; site:\u0026quot;\u0026lt;a href='https://www.baidu.com'\u0026gt;百度\u0026lt;/a\u0026gt;\u0026quot;,  v-bind: 或 : 给html标签的属性绑定值\n他的缩写是 :\n\u0026lt;a v-bind:href=\u0026quot;link\u0026quot;\u0026gt;百度\u0026lt;/a\u0026gt; \u0026lt;a :href=\u0026quot;link\u0026quot;\u0026gt;百度\u0026lt;/a\u0026gt;  v-on: 或 @ 事件的绑定\n\u0026lt;button v-on:click=\u0026quot;sayHello\u0026quot;\u0026gt;sayHello\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026quot;sayHello\u0026quot;\u0026gt;sayHello\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026quot;sayHelloName('ssss')\u0026quot;\u0026gt;sayHelloName\u0026lt;/button\u0026gt;  无参函数中的()可写可不写\n有参函数需要传参的时候需要加上()\nv-model 可以实现 表单元素和model中的数据实现双向绑定\n用户名：\u0026lt;input type=\u0026quot;text\u0026quot; v-model=\u0026quot;name\u0026quot;/\u0026gt;  注意：\n 将data中的数据传到html中 插值表达式 {{}}，v-text:，v-html:，等方式\n 将html中的数据传到data中：\n 通过监听watch\n 通过vue对象\nvm.$watch('name', function(value){ this.age= value; })    vue引入css 通过class  定义css\n\u0026lt;style\u0026gt; .mystyle1{ background-color: blue ; width: 100px; height: 100px; } \u0026lt;/style\u0026gt;  css绑定到data\ncss1 : 'mystyle1'  html元素使用css\n\u0026lt;h3 :class=\u0026quot;mystyle1\u0026quot;\u0026gt;1111111\u0026lt;/h3\u0026gt;   注意\n vue的css样式引入可以与传统的css样式引入共存\n\u0026lt;h3 class=\u0026quot;mystyle3\u0026quot; :class=\u0026quot;css1\u0026quot;\u0026gt;info:{{info}}\u0026lt;/h3\u0026gt;  :class的值 是一个对象{k1:v1,k2:v2...}如果对象中的变量值true，则生效；否则不生效\n\u0026lt;h3 :class=\u0026quot;{mystyle1:istrue, mystyle3:isfalse}\u0026quot; \u0026gt;111111\u0026lt;/h3\u0026gt;  istrue和isfalse在data中定义，根据他们的值来判断样式是否生效，当istrue=true;isfalse=false;时，mystyle1生效，mystyle3不生效\n值可以同时为true或false\n 绑定数组 []\n\u0026lt;h3 :class=\u0026quot;['mystyle1', 'mystyle3']\u0026quot;\u0026gt;11111\u0026lt;/h3\u0026gt;  同时生效\n vue取值有一个特点：取的值是变量，变量名是在data中定义的。\n  通过style 语法：\n:style={样式名:样式值(\u0026lt;从data中获取\u0026gt;),x:x,...}\n\u0026lt;h3 :style=\u0026quot;{backgroundColor:x,color:y}\u0026quot;\u0026gt;info000000:{{info}}\u0026lt;/h3\u0026gt; x:'lightgray' , y:'purple',  注意：\n属性的名字不能使用xxx-yyyy(中间使用-符号)，而需要使用 xxxYyyy(驼峰命名)\n条件渲染 v-if和v-else \u0026lt;h3 v-if=\u0026quot;istrue\u0026quot;\u0026gt;1111\u0026lt;/h3\u0026gt; \u0026lt;h3 v-else\u0026gt;222\u0026lt;/h3\u0026gt;  isture在data中定义，当为真时显示111，为假时显示222\nv-show \u0026lt;h3 v-show=\u0026quot;isture\u0026quot;\u0026gt;111\u0026lt;/h3\u0026gt; \u0026lt;h3 v-show=\u0026quot;!isture\u0026quot;\u0026gt;222\u0026lt;/h3\u0026gt;  注意：v-if和v-show的区别\nv-show可以在源码中追踪到隐藏的元素,即隐藏的元素可以在源码中找到；\nv-if无法追踪，即隐藏的元素，在源码中找不到；\n循环遍历  \u0026lt;!-- 遍历一个具体对象 (一个对象有很多属性：name age )--\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026quot;(value,name) in students[2]\u0026quot; :key=\u0026quot;name\u0026quot; \u0026gt; {{value}} --{{name}} \u0026lt;/li\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;  value：对象属性的值\nname：对象的属性名\nstudents[2]:对象数组中的一个元素(即一个对象)\n遍历对象 遍历对象数组 \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026quot;(s,index) in students\u0026quot; :key=\u0026quot;index\u0026quot; \u0026gt; {{index}} - {{s.name}} - {{s.age}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; students: [ {name:'zs', age:23}, {name:'ls', age:24}, {name:'ww', age:25}, {name:'zl', age:26}, {name:'sq', age:27} ] //对象数组  s:数组的每一个元素\nindex:下标\nstudents:数组\n:key:唯一值\n注意：想要获取data中的数据，需要通过this.来获取\n删除数组元素:splice //删除完毕后，数组元素 会自动重新排序 this.students.splice(index,1);  从下标index起删除1个\n更新数组元素:splice this.students.splice(index,1,stu);  将下标为index的数组元素更新为stu对象\n筛选 组成：查询的条件，新数组\n 定义查询条件(即定义data中数据)\nqueryname: \u0026ldquo; //筛选条件\n 具体实现方法(在computed中定义，函数名就是变量，即新数组)\n//筛选后的新数组 queryStuentsResult(){ // 新数组的值 var queryStudents ;//s //筛选条件 // var queryname = data中定义的queryname ; // var student2 = data中定义的数组students ; var {queryname,students} = this ;//this 就是data //根据查询条件，筛选出新数组 queryStudents = students.filter( stu=\u0026gt;stu.name .indexOf(queryname ) \u0026gt; -1 ) return queryStudents ; }   排序  定义升降序变量(0:升序,1:降序)\n ordered: 0  对queryStudents对象数组中的元素，根据age属性进行排序\n//排序 queryStudents.sort( function(s1,s2) { if(ordered ==0){//升序 return s1.age - s2.age }{//降序 return s2.age -s1.age } })  升序：第一个 - 第二个\n降序：第二个 - 第一个\n别忘了return\n  传播行为与事件 传参当前对象 \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;按钮1\u0026quot; @click=\u0026quot;myclick\u0026quot; /\u0026gt; \u0026lt;!--错误行为--\u0026gt; \u0026lt;!-- \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;按钮\u0026quot; @click=\u0026quot;myclick()\u0026quot; /\u0026gt; --\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;按钮2\u0026quot; @click=\u0026quot;myclick2($event)\u0026quot; /\u0026gt;  传当前对象时，要么不写，要么添加($event)，不能只写()这样会报错\n获取对象 myclick(event){ alert( event.target.value ) }, myclick2(event){ alert(event.target.value ) },  event.target：当前对象\n注意：在vue中结尾符;可写可不写(要么都写，要么都不写)\n事件的传播行为(propogation) \u0026lt;div :class=\u0026quot;css1\u0026quot; @click='myclick3()'\u0026gt; outer \u0026lt;div :class=\u0026quot;css2\u0026quot; @click='myclick4()'\u0026gt; inner \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; myclick4(){ alert('inner' ) }, myclick5(){ alert('link...' ) },  结果：\n点击:inner时，会触发outer的点击事件\n阻止行为：\n\u0026lt;div :class=\u0026quot;css1\u0026quot; @click='myclick3()'\u0026gt; outer \u0026lt;div :class=\u0026quot;css2\u0026quot; @click.stop='myclick4()'\u0026gt; inner \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;  阻止默认行为 \u0026lt;a href=\u0026quot;https://www.baidu.com\u0026quot; @click.prevent='myclick5()'\u0026gt;百度\u0026lt;/a\u0026gt; myclick5(){ alert('link...' ) },  注意:.xxx可以嵌套着使用\n键盘点击事件 keydown 按键 按下事件\n\u0026lt;input @keydown='myclick6'\u0026gt; myclick6(event){ //event.target :当前dom对象 //event.keyCode：按键的值 a : 65 alert( event.keyCode +'--'+ event.target.value ) },  keyup 按键弹上去事件\n指定按键触发事件 \u0026lt;input @keyup.13='myclick6' \u0026gt;  指定的按键按下抬起时才触发的事件\n每一个键盘的按键都对应着一个键码值\n表单输入绑定 \u0026lt;form action=\u0026quot;\u0026quot; @submit.prevent=\u0026quot;mysubmit\u0026quot;\u0026gt; 用户名：\u0026lt;input type=\u0026quot;text\u0026quot; v-model=\u0026quot;user.username\u0026quot; \u0026gt;\u0026lt;br\u0026gt; 密码：\u0026lt;input type=\u0026quot;password\u0026quot; v-model=\u0026quot;user.password\u0026quot; \u0026gt;\u0026lt;br\u0026gt; 性别： \u0026lt;input type=\u0026quot;radio\u0026quot; value=\u0026quot;male\u0026quot; v-model=\u0026quot;user.password\u0026quot;\u0026gt;男\u0026lt;br\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; value=\u0026quot;female\u0026quot; v-model=\u0026quot;user.password\u0026quot;\u0026gt;女\u0026lt;br\u0026gt; 兴趣： \u0026lt;input type=\u0026quot;checkbox\u0026quot; value=\u0026quot;football\u0026quot; v-model=\u0026quot;user.hobbies\u0026quot;\u0026gt;足球， \u0026lt;input type=\u0026quot;checkbox\u0026quot; value=\u0026quot;basketball\u0026quot; v-model=\u0026quot;user.hobbies\u0026quot;\u0026gt;篮球， \u0026lt;input type=\u0026quot;checkbox\u0026quot; value=\u0026quot;pingpang\u0026quot; v-model=\u0026quot;user.hobbies\u0026quot;\u0026gt;乒乓球， 城市： \u0026lt;select name=\u0026quot;\u0026quot; id=\u0026quot;\u0026quot; v-model=\u0026quot;user.city\u0026quot;\u0026gt; \u0026lt;option :value=\u0026quot;c.id\u0026quot; v-for=\u0026quot;c in optionalCities\u0026quot;\u0026gt; {{c.name}} \u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;注册\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  data:{ user:{ username: '' , passowrd: '' , sex: 'male', hobbies: [] , city: '' //选中 }, //可选 optionalCities: [\u0026quot;js\u0026quot;,\u0026quot;bj\u0026quot;,\u0026quot;sh\u0026quot;] },  这里只列出了部分的用法详细的用法参考官网手册(http://doc.vue-js.com/v2/guide/forms.html)\n意义：如果给后台传递一个form表单的数据，不用再 一个一个的获取每个input等元素的值；而可以一次性传递一个对象\n生命周期 作用 生命周期的作用：某个动作 都有一个流程，当执行到该流程的某一个阶段时，会自动触发一些函数\n注意:生命周期函数与methods和el等标签同级\n详细的说明参见官方文档(https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA)\n动画效果 显示：Enter\n隐藏：Leave\n三个阶段： 初始阶段： v-enter/v-leave  过渡阶段： v-enter-active / v-leave-active  结束阶段： v-enter-to/v-leave-to  v- 是这些类名的前缀。使用 \u0026lt;name=\u0026quot;my-transition\u0026quot;\u0026gt; 可以重置前缀，比如 v-enter 替换为 my-transition-enter。\n过滤器 {{ message | filterA | filterB }}\n{{msg | 过滤器1 | 过滤器2 }}\nmoment.js 时间格式化，去官网下载js文件\n引入\n注册过滤器  //过滤：注册-\u0026gt;使用 (西方日期 -\u0026gt;格式) //es6:函数默认参数值 Vue.filter('dateFilter' , function(value, dateFormat='YYYY-MM-DD HH:mm:ss' ){ return moment(value).format(dateFormat) ; })  使用过滤器 {{ now | dateFilter('YYYY-MM-DD')}}  自定义指令 v-text-upper\nv-text-lower\n定义指令的名字是v-是不需要我们写的，只需要写右边的部分即可\n全局指令 与var vm = new Vue({})同级（与全局变量定义类似）\n 注册全局指令\nVue.directive('text-upper',function(el,binding){ el.innerHTML= binding.value.toUpperCase(); })  使用\n\u0026lt;p v-text-upper=\u0026quot;myVariable\u0026quot;\u0026gt;\u0026lt;/p\u0026gt; myVariable : \u0026quot;Hello World\u0026quot;,   局部指令 在var vm = new Vue({})中定义 （与局部变量定义类似）\n 注册局部指令\n//注册局部指令 directives:{ 'text-lower' :{ bind(el,binding){ el.innerHTML= binding.value.toLowerCase(); } } }  使用\n\u0026lt;p v-text-upper=\u0026quot;myVariable\u0026quot;\u0026gt;\u0026lt;/p\u0026gt; myVariable : \u0026quot;Hello World\u0026quot;,   自定义插件 详细参见官方文档\n开发插件 例\n(function(){ const MyPlugin = {} ; MyPlugin.install = function (Vue, options) { // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () { alert('全局方法或属性'); } // 2. 添加全局资源 Vue.directive('my-directive', {//v-text-upper bind (el, binding, vnode, oldVnode) { // 逻辑... } }) // 3. 注入组件选项 .每次实例vue对象中调用一次 Vue.mixin({ created: function () { // 逻辑... alert('mixin'); } }) // 4. 添加实例方法（局部） Vue.prototype.$myMethod = function (methodOptions) { // 逻辑... alert('局部') ; } } //将插件 暴露给外部使用 window.MyPlugin = MyPlugin ; })()  使用插件  引入(js文件)\n 使用插件\nVue.use(MyPlugin); //全局：static //类名.静态方法() Vue.myGlobalMethod(); //对象.方法() vm.$myMethod();   vue脚手架开发 vue脚手架指的是vue-cli，它是一个专门为单页面应用快速搭建繁杂的脚手架，它可以轻松的创建新的应用程序而且可用于自动生成vue和webpack的项目模板。\n安装 npm install -g vue-cli  下载模板 vue init webpack my_vue_cli  需要配置一些基本信息，不配置的话就一路回车\n注意： 根据提示 安装附加组件，安装时输入项目名时不能包含大写字母。安装时，不要随意点鼠标，点击鼠标右键可以恢复。\n根据提示\ncd my_vue_cli npm run dev  打包运行项目  生成dist目录\nnpm run build  安装服务组件(静态服务)\nnpm install -g serve\n 运行 serve dist\n 动态服务(tomcat)\n 配置webpack.prod.conf.js\noutput: { ... publicPath: '/myvue/' --\u0026gt;配置访问时的项目名  打包成dist\n 将dist拷贝到tomcat/webapps中，并且再将dist修改成myvue\n 启动tomcat,运行\n   vuecli源码解读 npm run dev 触发了哪些文件  dev -\u0026gt;package.json -\u0026gt;build/webpack.dev.conf.js -\u0026gt;./webpack.base.conf -\u0026gt;./src/main.js引用时的名字叫app\n 根据web基础知识可知： http://localhost:8080 实际是访问http://localhost:8080/index.html\n index.html:\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; -\u0026gt;会被src/App.vue中的\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;内容注入：\n  src/App.vue中内容\n\u0026lt;router-view/\u0026gt; ：路由，映射关系 localhost:8080/b\u0026ndash;\u0026gt; xxx本项目的映射： localhost:8080/ \u0026ndash;\u0026gt;HelloWorld.vue\n配置路由：\u0026lt;router-view/\u0026gt;: router/index.js 文件\n  小结 npm run dev -\u0026gt; main.js localhost:8080 / :index -\u0026gt; router -\u0026gt; HelloWorld.vue中的内容  app.vue中直接引入helloworld.vue  引入helloworld.vue\n\u0026lt;script\u0026gt; import HelloWorld from './components/HelloWorld'  将引入的文件打成一个组件\nexport default{ xxxxxx, components:{ HelloWorld } }  使用组件\n以标签的形式使用\n\u0026lt;HelloWorld\u0026gt;\u0026lt;/HelloWorld\u0026gt;   ESlint 代码规范检查工具，官网\n可以检测\n 空格个数 空行 变量名 代码是否未被使用 \u0026hellip;  如果不规范，则警告 或报错\n检测规则  \u0026ldquo;off\u0026rdquo; 或 0 - 关闭规则 \u0026ldquo;warn\u0026rdquo; 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出) \u0026ldquo;error\u0026rdquo; 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)  设置某些检查规则：.eslintrc.js文件\n全局设置是否启用ESlint：.eslintignore文件\n注意：\n初学：关闭\n真实的开发项目：打开，帮助规范代码的编写\nvue文件 组成 \u0026lt;template\u0026gt; \u0026lt;script\u0026gt; \u0026lt;style\u0026gt;  export default { name: '名字' , data(){ return msg: 'xxx' }， omputed:{}, methods:{}, components:{//组件} }  vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 vuex中文官网\n根据官网的流程图来理解Vuex\n状态自管理应用包含以下几个部分:\n state, 驱动应用的数据源; view,以声明方式将state映射到视图; actions, 响应在view.上的用户输入导致的状态变化。  他们时单向不可逆的，我们已简单的数字自增来举例，在state中定义一个变量count，显示在view组件上，通过actions来操作state，state变化后，view中也随之改变。\n但实际中vuex还有一个部分 mutations，根据官网的第二张图，我们发现action通过commit调用了Mutations，Mutations通过Mutate调用State，State通过Render来调用view，view通过dispatch来调用Action。此时就有点像mvc模式，actions和Mutations的关系就像service和dao的关系一样，Mutations会执行一些原子性的操作，而actions会做一些带逻辑性的操作；如删除操作，Actions会先判断存不存在，当存在的时候在进行删除，而Mutations则只进行删除操作。\n开发一个简单的状态管理 安装vuex依赖 npm install --save vux  新建./src/store.js文件 import Vue from 'vue' import Vuex from 'vuex' //使用vuex Vue.use(Vuex) //定义共享变量 const state = { count :0 } //直接操作共享变量的对象 const mutations={ mulincreases(state){ state.count++; } } //操作mutations的对象 const actions={ actioncrease({commit}){ commit('mulincreases'); } } //将store.js中的对象暴漏给外界 ，用于其他组件的共享 export default new Vuex.Store({ state, mutations, actions })  封装对象 我们发现要想将对象暴漏给外界，当需要暴漏的对象太多的时候，就会很麻烦，因此我们可以将要暴漏的对象给封装起来。\n在前面我们可知，程序在启动时会自动触发src/main.js文件。因此，思路：可以将store.js中暴露的多个对象，封装到main.js中。\n例：\n //引入准备封装的文件 import store from \u0026quot;./store\u0026quot; new Vue({ //xxxx store//注入store对象 })  此时我们需要引用需要暴漏的对象时只需要使用store.xxx即可使用。\n新建组件使用变量 组件其实就是一个.vue的文件\n我们在app.vue中使用变量\nsrc/main.js -》store -\u0026gt;App.vue\n程序的启动顺序，先main.js(store) -\u0026gt;App.vue 因此，在使用App.vue时，已经加载过了store,因此在App.vue中可以直接使用store,使用方式：$store\n{{$store.state.count}}  通过这种方式使得变量count显示在页面上\n {{$store.state.count}} \u0026lt;button @click=\u0026quot;countinc\u0026quot;\u0026gt;+\u0026lt;/button\u0026gt;   \u0026lt;script\u0026gt; export default{ methods:{ countinc(){ //注意$store是一个全局对象需要使用this来拿 return this.$store.dispatch('actioncrease') } } } \u0026lt;/script\u0026gt;  通过this来获取$store对象\n执行 npm run dev  异步实现自增 acioncrease 只需要添加并使用此方法\n //异步自增 asyncincrease({commit}){ setTimeout(()=\u0026gt;{ commit('mulincreases') },2000) }  两种取值方式  {{$xxx}}方式\n{{$store.state.count}}   数据来自store.js\u0026ndash;\u0026gt;getters\u0026ndash;\u0026gt;isAudlt(){\u0026hellip;}\n 方法取值\n \u0026lt;button @click=\u0026quot;countinc\u0026quot;\u0026gt;+\u0026lt;/button\u0026gt;   数据来自：store.js\u0026ndash;\u0026gt;actions\u0026ndash;\u0026gt;actincrease({commit}){}\n优化取值 直接使用isAudlt(){\u0026hellip;}和actincrease({commit}){}进行取值\nvuex中自带了两个对象\nimport {mapGetters,mapActions} from 'vuex'   mapGetters 可以获取getters中的方法 mapActions 可以获取Actions中的方法  如\ncomputed:mapGetters({ isAudlt : 'isAudlt'//将store.js中getters中的isAudlt()映射成isAudlt对象（前面的是属性，后面的是getters中的方法） })   methods:mapActions(['actioncrease','asyncincrease']),  使用\n{{isAudlt}} \u0026lt;button @click=\u0026quot;actioncrease\u0026quot;\u0026gt;同步+\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026quot;asyncincrease\u0026quot;\u0026gt;异步+\u0026lt;/button\u0026gt;  思路:\n以前需要通过$store获取store. js中的getter方法和actions方法现在可以直接通过mapGetters, mapActi ons获取store. js中的getter方法和actions方法\nvue-resource的使用 官网 相当于ajax、axios\n get(url, [config])\n post(url, [body], [config])\n  请求的方式config的作用，当表单发送请求时，需要加上{emulateJSON:true}，默认不加也行，但是为了防止某些特殊的情况建议还是加上。在前端，表单提交时一般加上:application/x-www.form-urlencoded，两者作用相似\nbody参数时传递的参数值；一般是采用对象的方式进行传参\nthis.$http.get(\u0026quot;请求地址\u0026quot;,{},{emulateJSON:true}).then(reponse=\u0026gt;{ consolg.log(resoonse); })   jsonp(url, [config])  支持跨域\n如果前台和后台的地址、端口、协议不一致(只要任何一个不一致)就称为跨域请求。为了安全，浏览器一般都禁止跨域请求\n解决：使用js技术替代了传统的http请求\n使用node.js搭建服务器\nconst http = require('http') const urlModule = require('url') //localhost:8080/myrequest?cb=myshow //localhost:8080/myrequest2 //创建服务 let server = http.createServer(); //servlet: doGet(request,resposne) server.on('request', function(req,res){ console.log('abcc') const { pathname ,query } = urlModule.parse( req.url ,true) if( pathname == '/myrequest'){ var data = { id : 1, name :\u0026quot;zs\u0026quot;, age :23 } //响应到哪里？ //localhost:8080/myrequest?cb=myshow //myshow(data) //data-\u0026gt;json //响应到：myshow方法，并响应的数据：data var result = `${query.cb}( ${JSON.stringify(data)} )` res.end(result) } }) server.listen(8888,function(){ console.log('sever running...') })  客户端\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;111\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026quot;./js/vue.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;./js/vue-resource.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; function myshow(data){ console.log(data) } \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;http://localhost:8888/myrequest?cb=myshow\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  客户端仅仅是引入了一个文件并没有发送请求\nPromise的使用 将嵌套方式变成链式写法\n读取多个文件的嵌套写法\nconst fs = require('fs') const path = require('path') //读取文件的内容 function myReadFile(fpath,frsuccess,frerror){ //读取文件时，如果由异常：err //数据正常保存data fs.readFile(fpath,\u0026quot;utf-8\u0026quot;,(err,data)=\u0026gt;{ if(err) return frerror(err) frsuccess(data) }) } //调用 js/file1.txt //先读取file1.txt，之后读取file2。txt //读取file1.txt--\u0026gt;成功之后读取--\u0026gt;file2.txt myReadFile(path.join(__dirname,'./file1.txt'),(data)=\u0026gt;{ console.log(data) myReadFile(path.join(__dirname,'./file2.txt'),(data)=\u0026gt;{ console.log(data) },(err)={}) },(err)=\u0026gt;{console.log(err.message)})  读取文件的链式写法\nconst fs = require('fs') const path = require('path') function myReadFile(fpath){ return new Promise((resolve,reject)=\u0026gt;{ fs.readFile(fpath,'utf-8',(err,data)=\u0026gt;{ if(err) return reject(err) resolve(data) }) }) } //调用 // ./代表根目录 myReadFile('./js/file1.txt').then((data)=\u0026gt;{ console.log(data) return myReadFile('./js/file2.txt') },(error)=\u0026gt;{ console.log(error) }).then((data)=\u0026gt;{ console.log(data) }).catch((e)=\u0026gt;{ console.log(e) })  .catch 可以统一处理错误\npromise的核心：return+then跳出递归\nvue组件 vue的三大组成部分\n\u0026lt;template\u0026gt; html(组件) \u0026lt;script\u0026gt; 存放js \u0026lt;style\u0026gt; 存放css  官网使用手册\n定义一个简单的组件 \u0026lt;html\u0026gt;\t\u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026quot;./js/vue.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;div id=\u0026quot;myvue\u0026quot;\u0026gt; \u0026lt;mycom\u0026gt;\u0026lt;/mycom\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component('mycom',{template:\u0026quot;\u0026lt;h1\u0026gt;这是我的组件\u0026lt;/h1\u0026gt;\u0026quot;}) new Vue({ el:'#myvue' }); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  注意：\n组件名不要使用驼峰命名法，如果使用，则使用该组件的时候使用-符号隔开\n组件定义方式\n 官网方式\n Vue.component('mycom',{template:\u0026quot;\u0026lt;h1\u0026gt;这是我的组件\u0026lt;/h1\u0026gt;\u0026quot;})  完整写法\n Vue.component('mycom',Vue.extend({template:\u0026quot;\u0026lt;h1\u0026gt;这是我的组件\u0026lt;/h1\u0026gt;\u0026quot;})  官网方式的id引用的方式\n\u0026lt;template id=\u0026quot;mytemp1\u0026quot;\u0026gt; \u0026lt;h1\u0026gt;这是我的组件\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; Vue.component('mycom',{template:\u0026quot;#mytemp1\u0026quot;})  完整方式的id引用方式\n\u0026lt;template id=\u0026quot;mytemp1\u0026quot;\u0026gt; \u0026lt;h1\u0026gt;这是我的组件\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; Vue.component('mycom',Vue.extend({template:\u0026quot;#mytemp1\u0026quot;})   注意：定义组件时template:\u0026quot;\u0026quot;的值和 \u0026lt;template\u0026gt;\u0026lt;/template\u0026gt;标签中的内容必须是标签，否则会出错\n这种方式定义的组件是全局组件，在所有的Vue对象中都可以使用。\n私有组件/局部组件:只能在选定的Vue对象中使用\nnew Vue({ el:'#myvue2', components:{ 'mycom1':{template:\u0026quot;\u0026lt;h1\u0026gt;这是我的组件\u0026lt;/h1\u0026gt;\u0026quot;} } });  其它的创建方式如上\n除了定义组件内容之外还可以在组件中定义数据，定义数据的方式如下：\ndata:function)(){ return { count:0 } }  注意：定义的数据必须是function，因为function中定义的变量是局部变量，为了防止多个组件之间共享数据，从而使得定义的组件的数据是独立的。\n特殊特性 is vue中自带一个标签\u0026lt;component\u0026gt;\u0026lt;/component\u0026gt;是一个组件标签，占位符\n\u0026lt;component :is=\u0026quot;'comp'\u0026quot;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;!-- 或 --\u0026gt; \u0026lt;component :is=\u0026quot;c\u0026quot;\u0026gt;\u0026lt;/component\u0026gt; data:{ c:'comp' }  一般vue:xx=xxx值一般是变量，而我们定义的组件名是一个常量，要想将一个常量值变成一个变量值，只需要添加''即可。而变量值是在data中定义的，如果不加''只需要在data中定义变量，其值为组件名即可。\n实现动态组件 只需要将:is绑定的值改变，就能实现动态组件。而:is中的值在data中定义，一次只需要改变data中变量的值即可。\n\u0026lt;span @click=\u0026quot;c='coma'\u0026quot;\u0026gt;切换A\u0026lt;/span\u0026gt; \u0026lt;span @click=\u0026quot;b()\u0026quot;\u0026gt;切换A\u0026lt;/span\u0026gt; methods:{ b(){ this.c=\u0026quot;comb\u0026quot; } }  注意：行内写法不需要加this,而函数写法需要加this\n什么时候加this  在Vue对象中除了data之外的所有区域使用data中的数据时，都需要使用this\n 在页面中使用{{}}取data中值是可加this也可不加this\n  一般结论：大多数的情况下，只要获取data中的变量的时候都需要使用this，除了个别特殊的情况，如：行内式写法、\n组件的过渡效果和参数传递的问题  将过度组件放入\u0026lt;transition\u0026gt;\u0026lt;/transition\u0026gt;标签中\n 编写样式在\u0026lt;style\u0026gt;\u0026lt;/style\u0026gt;标签中编写css样式\n\u0026lt;style\u0026gt; .v-enter, .v-leave-to{ opacity: 0 ; transform: translateX(100px) ; } .v-enter-active, .v-leave-active{ transition: all 1s ease ; } \u0026lt;/style\u0026gt;  \u0026lt;transition\u0026gt;的 mode=\u0026quot;out-in\u0026quot;属性可以设置出现的顺序，这样的话能避免重合。\n  传参 \u0026lt;coma :msg=\u0026quot;aname\u0026quot;\u0026gt;\u0026lt;/coma\u0026gt; Vue.component('coma', { template:\u0026quot; \u0026lt;p\u0026gt;这是我的组件A {{msg}}\u0026lt;/p\u0026gt;\u0026quot;, props: ['msg'] } ) data:{ aname :\u0026quot;你好，世界\u0026quot; }  :msg，msg是自己定义的属性名，他的值是一个变量aname,在data中定义。组件在使用msg属性的值的时候不能直接使用，需要借助props中转，然后进行使用。\n注意：组件中参数引用的位置一定要在标签中，否组Vue不认识它。\n组件的简化写法  公有组件\nvar comc = { template: '\u0026lt;p\u0026gt;这是组件C\u0026lt;/p\u0026gt;' } Vue.component('comc',comc) \u0026lt;comc\u0026gt;\u0026lt;/comc\u0026gt;  共有组件与Vue对象同级，在Vue对象的外面写\n 私有组件\nvar mycomc = { template: '\u0026lt;p\u0026gt;这是组件C\u0026lt;/p\u0026gt;' } components:{ 'mycomc': mycomc } \u0026lt;mycomc\u0026gt;\u0026lt;/mycomc\u0026gt;   注意:当组件名和变量名是同一个时可简化，只写组件名或变量民即可。\n例上面可以简化为：\ncomponents:{ mycomc }  小结：简化的核心就是使用var变量保存组件，然后通过引用变量实现自定义组件。\n调用组件内部的方法 普通的方法调用 \u0026lt;button @click=\u0026quot;aa()\u0026quot;\u0026gt;点击事件\u0026lt;/button\u0026gt; methods:{ aa(){ alert(\u0026quot;hahahah\u0026quot;) } }  调用的方法时vue中的methods中定义的方法\n定义的组件的方法的调用 组件常用的定义方式\n 定义组件内容\n\u0026lt;template id=\u0026quot;mytempid\u0026quot;\u0026gt; \u0026lt;button @click=\u0026quot;myclick\u0026quot;\u0026gt;方法调用\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt;  完善组件结构\nvar com = { template : '#mytempid' , data(){//局部变量 ,xx(){return {k:v}} return { comdata:{ num:1 } } }, methods:{ myclick(){ this.$emit('mycomclick',this.comdata.num) //myshow(a) } } }  注册到Vue中\n 公有组件\nVue.component('com',com)  私有组件\ncomponents:{ //com:com com } }   使用\n通过标签使用\n\u0026lt;com @mycomclick='myshow'\u0026gt;\u0026lt;/com\u0026gt;   组件中的单击事件调用的不是Vue中的Methods中定义的方法，而是组件中methods中定义的方法。\n调用组件内部按钮中的方法：单击\u0026ndash;\u0026gt;组件中的method\u0026ndash;\u0026gt;vue中的method\n小结：组件的单击事件\u0026lt;button @click=\u0026quot;myclick\u0026quot;\u0026gt;调用组件中的methods中定义的单击函数myclick;组件中定义的函数通过this.$emit触发组件自定义的事件 \u0026lt;com @mycomclick\u0026gt;, 组件的自定义事件调用Vue中定义的事件函数 myshow，从而实现事件的点击。\n核心思路：\n 普通的Html对象：直接调用Vue中的Methods中定义的函数\n 如果是组件，则调用组件中methods定义的方法，接着通过组件中的methods调用Vue中的methods\n 细节：组件中传递方法时： 发：自定义事件 收：$emit\n  当函数需要传参时this.$emit('mycomclick','hello') hello就是第一个参数，传多个参数时，通过,隔开\nthis所在位置\n当在组件中使用this时，代表当前组件，当需要使用data中的数据时需要通过this.comdata.xxx来获取变量\n当在Vue中使用this代表当前Vue对象，想要使用data中的数据时，需要使用this.xxx来获取变量。\nrefs 相当于jquery中的选择器\n在jquery中：\n定义 id=\u0026quot;myid\u0026quot; 使用 $(\u0026quot;#myid\u0026quot;)  在vue中：\n定义 ref=\u0026quot;myref\u0026quot; 使用 this.$refs.myref  \u0026lt;html\u0026gt;\t\u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026quot;./js/vue.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;div id=\u0026quot;myvue\u0026quot;\u0026gt; \u0026lt;!--普通元素--\u0026gt; \u0026lt;div ref=\u0026quot;mydiv\u0026quot;\u0026gt; 这是div元素... \u0026lt;/div\u0026gt; \u0026lt;!-- 组件--\u0026gt; \u0026lt;com ref=\u0026quot;mycom\u0026quot;\u0026gt;\u0026lt;/com\u0026gt; \u0026lt;button @click='myVueShow'\u0026gt;调用vue中的方法\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026quot;mytempid\u0026quot;\u0026gt; \u0026lt;div\u0026gt;普通组件...\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;\t\u0026lt;script\u0026gt; var com = { template : '#mytempid' , data(){ return { mymsg:'组件内部的数据' } }, methods:{ myComponentShow(){ alert('这是组件中的方法...') } } } const vm = new Vue({ el : \u0026quot;#myvue\u0026quot;, data:{ }, methods:{ myVueShow(){ //alert('myvueshow...'); //alert(this.$refs.mydiv.innerText) //获取组件中定义的mymsg数据 //alert(this.$refs.mycom.mymsg) //调用组件中定义的方法 this.$refs.mycom.myComponentShow() } }, components:{ //com:com com } } ); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  refs的作用：获取某个元素、组件，调用组件中的属性、方法、数据等信息\nrender函数 把组件模板(template)渲染成html（替换之前的内容）\n\u0026lt;html\u0026gt;\t\u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026quot;./js/vue.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;div id=\u0026quot;myvue\u0026quot;\u0026gt; \u0026lt;div\u0026gt; 这是div元素... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026quot;mytempid\u0026quot;\u0026gt; \u0026lt;span\u0026gt;普通组件...\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt;\t\u0026lt;script\u0026gt; var com = { template : '#mytempid' } const vm = new Vue({ el : \u0026quot;#myvue\u0026quot;, data:{ }, methods:{ }, render:function(createElements){ return createElements(com) //该方法的参数，就可以将组件渲染成html } } ); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  ","id":13,"section":"posts","summary":"vue介绍 vue是一个渐进式的JavaScript框架。渐进式：可插拔式、可扩展。 我们刚开始只需要使用最核心的核心库，后期可以自己去增加新库","tags":["前端框架"],"title":"Vue自学笔记","uri":"https://mumulx.github.io/2019/12/vue%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" git源码\n简介 SpringBoot官网\nSpringBoot是由Pivotal团队在2013年开始研发、2014年4月发布第一个版本的全新开源的轻量级框架。它基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。\n微服务 微服务：一个项目 可以由多个 小型服务构成（微服务）\n可更新可替代性比较强\nspring boot可以快速开发 微服务模块\n 简化j2ee开发 整个spring技术栈的整合（整合springmvc spring）\n 整个j2ee技术的整合（整合mybatis redis）  配置java环境变量  JAVA_HOME： jdk根目录 path:%JAVA_HOME%\\bin classpath:.%JAVA_HOME%\\lib%JAVA_HOME%\\lib\\tools.jar  配置maven环境变量  MAVEN_HOME： maven根目录 path: maven根目录\\bin 配置Maven本地仓库： mvn根目录/conf/setting.xml : \u0026lt;localRepository\u0026gt;C:/workplace/jar/mavenrep\u0026lt;/localRepository\u0026gt; 在STS中配置mvn：\nwindow-\u0026gt;preference-\u0026gt;搜maven ,installations/user settings   简单springboot项目  去官网生成springbootxiangmu官网\n STS 导入项目(Existing maven项目)\n 右键运行HelloWorldApplication.java \u0026ndash;run java application\n出现springboot和对应的版本号说明springboot配置好了\n  目录结构  java：java代码 resources/static:静态资源（js css 图片 音频 视频） resources/templates：模板文件（模版引擎freemarker ,thymeleaf；默认不支持jsp） resources/application.properties： 配置文件\nspringboot开发WEB程序  以前：webContext\u0026ndash;web.xml\u0026ndash;war\u0026ndash;tomcat\nspring boot内置了tomcat，并且不需要打成war再执行。\n @Controller public class HelloWorldController { //页面直接打印这些文字 @ResponseBody @RequestMapping(\u0026quot;helloWorld\u0026quot;) public String helloWorld() { return \u0026quot;hello world;hello spring boot\u0026quot;; } }  直接运行HelloWorldApplication.java \u0026ndash;run java\n访问\nhttp://localhost:8080/helloWorld  可以发现此时没有运行tomcat就能运行\n可以在appication.properties对端口号等服务端信息进行配置\nserver.port=8888  spring boot将各个应用/三方框架 设置成了一个个“场景”stater，以后要用哪个，只需要引入那个场景即可。 选完之后，spring boot就会将 该场景所需要的所有依赖 自动注入。\n官方starter介绍\n例如 选择 web,spring boot就会将web相关的依赖（tomcat json） 全部引入本项目\n版本仲裁中心\npom.xml中\n\u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt;  连续进入，就会发现里面配置了各个jar包的版本\n主配置类 HellowordApplication.java中含有注解\n@SpringBootApplication  spring boot的主配置类\n该注解包含了许多注解例：\n @SpringBootConfiguration\n包含@Configuration，表示\u0026rdquo;配置类\u0026rdquo;(用来代替配置文件):\n 该类是一个配置类 加了@Configuration注解的类，会自动纳入Spring 容器 （@Component）\n@Configuration public class A//表示A是一个 用于 配置的类 { }   @EnableAutoConfiguration\n使spring boot可以自动配置 ：（以前做spring，mybatis等项目时需要写很多配置文件，但是这里我们发现我们并没有写配置文件）约定优于配置（之前已经约定好了，所以没有进行配置）\n @AutoConfigurationPackage\n可以找到@SpringBootApplication所在类的包 ，\n作用：就会将该包及所有的子包 全部纳入spring容器\nspring boot自动配置自动将@SpringBootApplication所在类的包及其子包纳入spring容器中\n @Import(AutoConfigurationImportSelector.class\nAutoConfigurationImportSelector类中的selectImports方法在spring boot在启动时，会根据META-INF/spring.factories找到相应的三方依赖，并将这些依赖引入本项目\n   总结：\n编写项目时，一般会 对自己写的代码以及三方依赖 进行配置。但是spring boot可以自动进行配置：\n 自己写的代码\nspring boot通过@SpringBootConfiguration自动帮我们配置；\n 三方依赖\n通过spring-boot-autoconfigure-2.0.3.RELEASE.jar中的META-INF/spring.factories进行声明，然后通过@EnableAutoConfiguration开启使用即可\nspring-boot-autoconfigure-2.0.3.RELEASE.jar包中 包含了 J2EE整合体系中 需要的依赖。\n  如何自动装配 研究\norg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\  通过观察该源码 发现：\n@Configuration  标识此类是一个配置类 、将此类纳入springioc容器\n@EnableConfigurationProperties(HttpEncodingProperties.class)  通过HttpEncodingProperties将编码设置为了UTF_8 (即自动装配为UTF_8）\n如何修改改编码\n通过改HttpEncodingProperties的 predfix+属性名 进行修改 （配置文件中，yml/properties）\nspring.http.encoding.charset=ISO-8859-1  即：该注解给了默认编码utf8，并且提供了prefix+属性名 的方式 供我们修改编码。\n当满足以下条件（@Conditional）时才会被加载\n@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)  当它是一个servlet时成立\n@ConditionalOnClass(CharacterEncodingFilter.class)  当它有CharacterEncodingFilter这个类的时候成立\n@ConditionalOnProperty(prefix = \u0026quot;spring.http.encoding\u0026quot;, value = \u0026quot;enabled\u0026quot;, matchIfMissing = true)  当属性满足要求时，此条件成立 ：要求 ：如果没有配置spring.http.encoding.enabled=xxx, 则成立。\n总结：\n 每一个XxAutoConfiguration都有很多条件@ConditionalOnXxx，当这些条件都满足时，则此配置自动装配生效（utf-8）。\n但是我们可以手工修改改 自动装配：XxxProperties文件中的\nprefix.属性名=value   全局配置文件中的key， 来源于某个Properties文件中的 prefix+属性名\nSpringboot通过XxAutoConfiguration实现自动装配 ，修改默认值 XxxProperties（ prefix+属性名）\n  如何知道 spring boot开启了哪些自动装配、禁止了哪些自动装配：application.properties中添加\ndebug=true   Positive matches列表 表示 spring boot自动开启的装配 Negative matches列表 表示spring boot在此时 并没有启用的自动装配。  配置文件 作用：spring boot 自动配置(约定，8080 ).可以使用配置文件 对默认的配置 进行修改\n默认全局配置文件：\n application.properties\nk=v\n或行内写法(k： v，)\n application.yml\n yaml ain\u0026rsquo;t myarkup language ，不是一个标记文档   yaml：不是一个标记文档\nserver: port: 8882 path: /a/b/c  xml：是一个标记文档\n\u0026lt;server\u0026gt; \u0026lt;port\u0026gt;8882\u0026lt;/port\u0026gt; \u0026lt;path\u0026gt;/a/b/c\u0026lt;/path\u0026gt; \u0026lt;/server\u0026gt;  赋值 通过yaml给对象注入值： 注意： 1. k:空格v\n2. 通过垂直对齐 指定层次关系\n3. 默认可以不写引号； \u0026ldquo;\u0026ldquo;会将其中的转义符进行转义，其他不会\n行内写法\n[Set/List/数组] {map,对象类型的属性}  并且 []可省，{}不能省\n写法一：普通写法\nstudent: name: zs age: 23 sex: true birthday: 2019/02/02 location: province: 陕西1 city: 西安1 zone: 莲湖区1 hobbies: - 足球 - 篮球 skills: - 吃喝 - 玩乐 pet: nickname: wc strain: hsq  写法二：行内写法\nstudent: uname: x name: ${student.user.name2:无名} #age: 23 sex: true birthday: 2019/02/12 location: {province: 陕西,city: 西安, zone: 莲湖区} hobbies: [足球2,篮球22] skills: [编程3,金融33] pet: {nick-name: wc555,strain: hsq} email: 157468995@qq.com  ublic class Pet { private String nickname; private String strain; }  @Component @ConfigurationProperties(prefix = \u0026quot;student\u0026quot;) public class Student { private String name; private int age; private boolean sex; private Date birthday; private Map\u0026lt;String ,Object\u0026gt; location; private List\u0026lt;String\u0026gt; skills; private String[] hobbies; private Pet pet; }  @ConfigurationProperties(prefix=\u0026ldquo;student\u0026rdquo;)下面出现黄色警告时，单击add xxx，会在pom.xml中增加依赖（元数据的提示依赖）\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;  通过application.properties对属性进行赋值 student.name=ls student.age=23  yml与properties两种方式的赋值可以互补使用\n通过@Value赋值 在Student.java中使用@Value注解进行赋值\n@Value(\u0026quot;33\u0026quot;) private int age ;  此时不再需要使用@ConfigurationProperties(prefix=\u0026ldquo;student\u0026rdquo;)注解，该注解是在.yml和.properties文件中赋值时使用\n小结 @ConfigurationProperties(yml/properties[优先级高]) @Value(\u0026quot;xx\u0026quot;) 二者可以互补  \t@ConfigurationProperties) @Value 注值\t批量注入\t单个 松散语法\t支持\t不支持 SpEL\t不支持\t支持 JSR303数据校验\t支持\t不支持 注入复杂类型\t支持\t不支持  松散语法:驼峰命名法与xx-xx命名方式转换stuName--stu-name\nSpEL:LspringEL:\n@Value(\u0026quot;${student.uname}\u0026quot;) private String userName;  在文件中赋值，通过el语法取值\nJSR303数据校验\n@Component //将此Javabean @ConfigurationProperties(prefix=\u0026quot;student\u0026quot;) @Validated//开启jsr303数据校验的注解 public class Student { @Email private String email ; }  简单类型：(8个基本类型/String/Date)\n@PropertySource 默认会加载application.properties/application.yml文件中的数据；如果数据不在这两个文件时，需要借助它指定。\n例如 @Component //将此Javabean @ConfigurationProperties(prefix=\u0026ldquo;student\u0026rdquo;) @PropertySource(value={\u0026ldquo;classpath:conf.yml\u0026rdquo;}) public class Student { @Value(\u0026ldquo;safasd\u0026rdquo;) }\n通过注解@PropertySource(value={\u0026quot;classpath:conf.yml\u0026quot;})加载conf.properties文件中的数据；\n但是，@PropertySource只能加载properties，不能加载yml\n@ImportResource spring boot自动装配/自动配置.\nspring等配置文件 默认会被spring boot自动给配置好。\n如果要自己编写spring等配置文件, spring boot能否识别？\n默认不识别。  如果需要识别，则需要在spring boot主配置类上 通过@ImportResource指定配置文件的路径\n@ImportResource(locations={\u0026quot;classpath:spring.xml\u0026quot;}) @SpringBootApplication public class HelloWorldApplication {  但是不推荐手写spring配置文件。\n配置：xml配置文件，通过注解配置(推荐)。\nspring boot推荐时候用注解方式进行配置：写类，@Configuration @Bean，\n示例：\n//配置类（等价于spring.xml） @Configuration public class AppConfig { @Bean public StudentService stuService(){//\u0026lt;bean id=\u0026quot;xxxxxxxxxxxxx\u0026quot;\u0026gt; 方法名 StudentService stuService = new StudentService(); // StudentDao stuDao = new StudentDao() ; // stuService.setStudentDao(stuDao); return stuService;//返回值 \u0026lt;bean class=\u0026quot;xxxxxxxxxxxxx\u0026quot;\u0026gt; } }  spring boot全局配置文件中的 占位符表达式 $ {random.uuid}:uuid $ {random.value}随机字符串 $ {random.int} ;随机整型数 $ {random.long}:随机长整型数 $ {random.int(10)}:10以内的整型数 $ {random.int[1024,65536]}:指定随机数范围  引用变量值\n.properties文件中\nstudent.user.name=zs  .yml中引用\n${student.user.name} ${student.user.name:ls}可以指定默认值  两个文件中的值可以互相引用\napplication.properties中没有提示的话 在pom.xml中添加\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;  多环境的切换（profile） properties文件 默认spring boot会读取application.properties\n多个：\napplication-环境名.properties application-dev.properties application-test.properties  如果要选择某一个具体的环境： application.properties中指定：（环境名:dev,test）\nspring.profiles.active=环境名  如果将application.properties注释掉，spring boot仍然会读取其他appilcation-环境名.properties中的配置。并且properties的优先级高于yml\nyml 环境与环境之间通过\u0026mdash;隔开\n# 主环境 server: port: 8883 #指定环境 #spring: # profiles: # active: dev --- #环境一 server: port: 8884 spring: profiles: dev --- #环境二 server: port: 8885 spring: profiles: test  动态切换环境  通过运行参数指定环境\n STS(Eclipse) ：\n右键\u0026ndash;Run Configuration - Argument(Java Application中指定项目) - program Argument\n--spring.profiles.active=环境名  命令行方式：\n项目打jar包：\n项目右键\u0026ndash;\u0026gt;run as \u0026ndash;\u0026gt;maven build\u0026hellip;\u0026ndash;\u0026gt; Goals:输入\npackage  \u0026ndash;\u0026gt;run\u0026ndash;\u0026gt;在src同级目录target下会出现jar包\ncmd到文件目录，执行\njava -jar 项目名.jar \u0026ndash;spring.profiles.active=环境名\n  通过jvm参数指定环境\nSTS(Eclipse) ：Run Configuration - Argument - VM arguments\n-Dspring.profiles.active=环境名   配置文件的位置 项目内部的配置文件： properties和yml中的配置，相互补充；如果冲突，则properties优先级高。\nspring boot默认能够读取的application.properties/application.yml，这2个文件 可以存在于以下4个地方：\n file:项目根目录/config\n file:项目根目录\n classpath:项目根目录/config\n classpath:项目根目录\n  注意:\n 如果某项配置冲突，则优先级从上往下 如果不冲突，则互补结合使用  配置项目名： properties文件中\nserver.servlet.context-path=/boot  项目外部的配置文件： (补救) 在项目Run configuration ,argumenets:\n--spring.config.location=D:/application.properties  如果 同一个配置 同时存在于 内部配置文件 和外部配置文件，则外部\u0026gt;内部\n命令行方式\n打包文件\nclean package  先清理后打包\ncmd到jar路径，通过命令行 调用外部配置文件\njava -jar xxx.jar --spring.config.location=D:/application.properties  项目运行参数 (补救)（配置与配置直接可以加空格隔开）\n在项目Run configuration ,argumenets:\n--server.port=8883  通过命令行修改配置参数\ncmd到jar包\njava -jar 项目.jar --server.port=8883  多个地方配置时，如果冲突，优先级：\n命令参数（调用外部的配置文件 \u0026gt; 运行参数 ）\u0026gt;内部文件 (properties\u0026gt;yaml)  官网对多配置时的顺序说明：\n日志 日志框架： UCL 、JUL 、jboss-logging、logback、log4j、log4j2、slf4j\u0026hellip;\nspring boot默认选用slf4j，logback，spring boot默认帮我们配置好了日志，我们直接使用即可。\n使用 Logger logger = LoggerFactory.getLogger(HelloWorldApplicationTests.class );//获取日志对象 @Test public void testLog(){//日志级别 logger.trace(\u0026quot;trace********\u0026quot;); logger.debug(\u0026quot;debug********\u0026quot;); logger.info(\u0026quot;info*******\u0026quot;); logger.warn(\u0026quot;warn******\u0026quot;); logger.error(\u0026quot;error****\u0026quot;); }  日志级别：（LogLevel类中） TRACE\u0026lt; DEBUG\u0026lt; INFO\u0026lt;WARN\u0026lt; ERROR\u0026lt; FATAL\u0026lt;OFF  springboot默认的日志级别是info（即只打印 info及之后级别的信息）；\n也可以自定义级别：全局配置文件中\nlogging.level.主配置类所在包=级别 logging.level.org.yq.HelloWorld=warn  日志存储 可以通过配置 将日志信息 存储到文件中\nlogging.file=springboot.log  存储到了项目的根目录中的springboot.log\n也可以指定 具体的日志路径：\nlogging.file=D:/springboot.log  也可以存储到一个 文件夹中 ，\nlogging.path=D:/log/  并且默认的文件名是spring.log\n指定日志显示格式：  日志显示在console中\nlogging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n  %d: 日期时间 %thread： 线程名 %-5level： 显示日志级别,-5表示从左显示5个字符宽度 %logger{50} : 设置日志长度 %msg： 日志消息 %n ： 回车  日志显示在文件中\nlogging.pattern.file=%d{yyyy-MM-dd} ** [%thread] ** %-5level ** %logger{50}** %msg%n   默认的日志格式，是在spring-boot.jar包中 相应包的xml文件中进行配置。 /org/springframework/boot/logging/\n日志的具体使用规范：官方说明\nspringboot开发Web项目 (静态资源 html css js )\n新建项目（sts） new \u0026ndash; spring starer Project \u0026ndash;设置（选择 需要的场景，web）\n静态资源存放路径 spring boot是一个jar，因此 静态资源就不是再存放到 webapps中，存放在哪里？\n静态资源的存放路径 通过WebMvcAutoConfiguration类-addResourceHandlers()指定为:/webjars/\nspring boot将静态资源存入到jar包中，引入:以后需要引入静态资源时只需要像maven那样去官网找到文件然后添加依赖即可\n\u0026lt;!--以前引入js等静态资源，是将这些资源下载并且手工放入到webapp目录中；而springboot将这些静态资源 直接以jar文件（maven）的形式引入项目--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.webjars\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jquery-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.12.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  webjars官网\n使用\n访问：从Jar目录结构的webjars开始写：http://localhost:8080/webjars/jquery/3.3.1-1/jquery.js\n将自定义静态资源放入项目 如何自己写 静态资源，如何放到如spring boot中？\n 将自己写的 静态资源-\u0026gt;jar,同上（不推荐）；\n 自定扫描方式（推荐）：\n  spring boot约定： spring boot将一些目录结构设置成静态资源存放目录，我们的静态资源直接放入这些目录即可，目录在哪里？\nResourceProperties类中的CLASSPATH_RESOURCE_LOCATIONS中设置：\n{ \u0026quot;classpath:/META-INF/resources/\u0026quot;, \u0026quot;classpath:/resources/\u0026quot;, \u0026quot;classpath:/static/\u0026quot;, \u0026quot;classpath:/public/\u0026quot; }  注意：在以上目录存放资源文件后，访问时 不需要加前缀，直接访问即可：http://localhost:8080/world.html\n设置欢迎页 WebMvcAutoConfiguration类中的welcomePageHandlerMapping() \u0026ndash;\u0026gt;getIndexHtml() \u0026ndash;\u0026gt; location + \u0026quot;index.html\u0026quot; ,即任意一个静态资源目录中的 index.html就是欢迎页\n网站中,网页标签的Logo是固定名字 ： favicon.ico\n自定义 favicon.ico 阅读 源码得知:只需要将 favicon.ico文件放入任意静态资源目录中即可。\n总结：\n 通过源码发现静态资源的目录 用静态资源：只需要将静态资源放入 以上目录即可 其他特定的文件（欢迎页、ico），只需要 根据约定（index.html favicon.ico） 放入该目录即可  自定义静态资源目录 如何自定义静态资源目录（Properties文件中的 prefix+属性） ：\nspring.resources.static-locations=classpath:/res/, classpath:/img/  以上就将静态资源目录设置为了classpath:/res/, classpath:/img/\n注意:自定义静态资源目录后 以前默认的目录会失效\n动态资源： JSP(spring boot默认不支持)\n推荐：模板引擎 thymeleaf\n网页= 模板+数据\n引入thymeleaf 到官网查询 thymeleaf的依赖官网\n使用thymeleaf thymeleaf官网\n代码在哪里写？\n查找自动装配jar包spring-boot-autoconfigure.jar，去里面查找响应的依赖找到XxProperties注解类，查看默认值\n今后查看默认值只需要查看\nXXXAutoCongifutation 、 XxProperties  通过ThymeleafProperties源码得知：\n使用thymeleaf只需要将 文件放入目录：\u0026quot;classpath:/templates/\u0026quot;; 文件的后缀： .html;\n使用 引入命名空间\n\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;  引入标签 \u0026lt;p th:text=\u0026quot;${welcome}\u0026quot;\u0026gt;Welcome to our grocery store!\u0026lt;/p\u0026gt;  控制器传值 @RequestMapping(\u0026quot;/welcome\u0026quot;) public String welcome(Map\u0026lt;String,Object\u0026gt; map) { map.put(\u0026quot;welcome\u0026quot;, \u0026quot;welcome--hahahhaha\u0026quot;); return \u0026quot;welcome\u0026quot;; }  以上，先从${welcome}中取值，如果有 则直接显示；如果没有，则在显示welcome to thymeleaf....\n注意：在以前传统的web项目中：静态资源修改后 是不需要重启的；但是在spring boot项目中，修改后 需要重启。\nth就是替换原有html的值：th:html属性名=值 ;\n\u0026lt;p id=\u0026quot;pid\u0026quot; class=\u0026quot;pclass\u0026quot; th:id=\u0026quot;${welcome}\u0026quot; th:class=\u0026quot;${welcome}\u0026quot; th:text=\u0026quot;${welcome}\u0026quot;\u0026gt;welcome to thymeleaf....\u0026lt;/p\u0026gt;  th:xx (参见第10章 Attrubite Pre....) th:text 获取文本值(不转义) 显示\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt; th:utext 获取文本值 显示 将hello 渲染为h1后的效果  符号\nth:text=\u0026quot;${welcome}\u0026quot;  除了$以外 其他符号？ 查看第四章 Standard Express\u0026hellip;.\n\u0026lt;div th:each=\u0026quot;prod : ${prods}\u0026quot;\u0026gt; \u0026lt;h4 th:text=\u0026quot;${prod.name}\u0026quot;\u0026gt;11\u0026lt;/h4\u0026gt; \u0026lt;h4 th:text=\u0026quot;${prod.price}\u0026quot;\u0026gt;11\u0026lt;/h4\u0026gt; \u0026lt;h4 th:text=\u0026quot;${prod.inStock}\u0026quot;\u0026gt;11\u0026lt;/h4\u0026gt; \u0026lt;/div\u0026gt;  @RequestMapping(\u0026quot;/welcome1\u0026quot;) public String welcome1(Map\u0026lt;String,Object\u0026gt; map) { List\u0026lt;Product\u0026gt; prods = new ArrayList\u0026lt;\u0026gt;(); prods.add(new Product(\u0026quot;a\u0026quot;,1000,100)); prods.add(new Product(\u0026quot;b\u0026quot;,1001,101)); prods.add(new Product(\u0026quot;c\u0026quot;,1002,102)); prods.add(new Product(\u0026quot;d\u0026quot;,1003,103)); map.put(\u0026quot;prods\u0026quot;, prods); return \u0026quot;welcome\u0026quot;; }  Spring boot整合JSP开发 之前spring boot默认 自带一个内置的tomcat，不需要打war包，直接通过Jar即可运行。但是，如果要整合jsp开发，就需要 单独配置一个 外置的tomcat ，需要打war包。\nSpring boot整合JSP开发步骤：  新建spring boot项目，war\n注意：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-tomcat\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  provided：意思是 将项目打包时，不需要将内置的tomcat一起打包。\n 建立基本的web项目所需要的目录结构\nwebapps/WEB-INF(需要) webapps/WEB-INF/web.xml (不需要) webapps/index.jsp  创建tomcat实例、部署项目\n访问：\n域名：端口/项目名/文件名\nhttp://localhost:8080/SbJSP/index.jsp   分析：\n如果是一个war包的spring boot项目，在启动服务器tomcat时， 会自动调用ServletInitializer类中 的configure方法，configure方法会调用spring boot的主配置类 从而启动spring boot;\n即在启动tomcat服务器时 会\n 启动tomcat 启动spring boot  ","id":14,"section":"posts","summary":"git源码 简介 SpringBoot官网 SpringBoot是由Pivotal团队在2013年开始研发、2014年4月发布第一个版本的全新开源","tags":["Spring家族"],"title":"Springboot自学笔记","uri":"https://mumulx.github.io/2019/12/springboot%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" Express 简介 什么是Express express是一个基于node.js的极简、灵活的web开发框架。可以实现非常强大的web服务器功能。\nExpress的特点  可以设置中间件响应或过滤http请求。 可以使用路由实现动态网页，响应不同的http请求。 内置支持ejs模板(默认是jade模板)实现模板渲染生成html。  express-generator生成器 express-generator是express官方团队为开发者准备的一个快速生成工具，可以非常快速的生成一个基本的express开发框架。\nexpress的安装使用 安装express-generator生成器 cnpm install express -gd cnpm i -g express-generator //安装 完成后可以使用express命令，需要安装淘宝镜像 npm i -g express-generator//直接安装，较慢 ln -s /opt/node-v8.11.1-linux-x64/bin/express /usr/sbin/express ln -s /opt/node-v8.11.1-linux-x64/bin/express /usr/bin/express express --version  forever守护nodejs进程 （一直在线访问） 客户端可以正常启动应用，但是如果断开客户端连接，应用也就随之停止了。也就是说这样的启动方式没有给应用一个守护线程\nForever可以解决这个问题！Forever可以守护Node.js应用，客户端断开的情况下，应用也能正常工作\n 安装forever\ncd app npm install forever -g ln -s /opt/node-v8.11.1-linux-x64/bin/forever /usr/sbin/forever ln -s /opt/node-v8.11.1-linux-x64/bin/forever /usr/bin/forever  forever启动进程\ncd bin forever start www   注意:可能需要以管理员身份运行cmd\n创建项目 express xxx 项目名称//自动创建项目目录  安装依赖 cnpm install cnpm i//简写 npm install npm i//简写  开启项目 node app npm start//自动查找当前目录下的package.json文件 node ./bin/www  node app\n需要手动添加监听端口，打开app.js添加以下内容：\napp.listen(80,function(){ console.log(\u0026quot;服务器已运行\u0026quot;); });  监听端口为:80\nnpm start：默认监听端口为:3000\n测试项目 打开浏览器输入localhost或127.0.0.1\n目录说明  bin 可执行文件目录 node_moudles 依赖包的目录 public 静态文件根目录  所有的静态文件都应该放在这个目录的下面(静态html,css,js,图片，字体，视频资源等)  routes 路由模块目录，动态文件的目录  优先找静态文件，如果没有静态存在则找动态路由，如果动态路由也没有就404  views 视图目录  用于存储所有的ejs模板   文件说明  app.js 项目的主文件  对整个项目的所有的字眼进行统筹的安排   var indexRouter = require('./routes/index');//引入处理根目录请求的路由 var usersRouter = require('./routes/users');//引进处理users目录请求的路由 app.use('/', indexRouter);//分配根目录下的请求给index去处理 app.use('/users', usersRouter);//分配users目录下的请求给users模块去处理 app.set('views', path.join(__dirname, 'views'));//设置模板的默认目录 app.set('view engine', 'ejs');//设置模板引擎为ejs模板 app.use(express.static(path.join(__dirname, 'public')));//设置静态文件目录   package.json 项目描述文件  生命项目的名称、版本、依赖包等信息   路由 什么是路由 路由是指接收用户请求，处理用户数据，返回结果给用户的一套程序。可以理解为：生成动态网页的程序。\n后端路由的核心: URL\nexpress对象自带有一个Router类，可以实例化出路由对象，可以在该对象上挂载非常多的路由节点。\n路由的写法 挂载路由线路的写法：\nrouter.请求方式('请求地址',function(req,res){ res.send('数据'); });  创建一个独立的路由模块 需求:创建一个vip路由模块，接收vip目录下的所有请求，响应数据。\n实现步骤：\n 创建一个vip路由模块\n 编写路由模块的代码(在Router文件夹下新建vip.js)\na. 引入express模块\nb. 实例化路由对象\nc. 编写路由线路挂载到路由对象上\nd. 暴露路由对象\n  代码：\nvar express = require('express');//引入express模块 var router = express.Router();//利用Router类创建一个路由的实例 //编写list.html用于展示所有的vip用户 router.get('/list.html', function(req, res, next){ res.send('\u0026lt;h1\u0026gt;张三，李四，王五\u0026lt;/h1\u0026gt;'); }); router.get('/info.html', function(req, res, next){ res.send('\u0026lt;h1\u0026gt;张三:23，李四:23，王五:24\u0026lt;/h1\u0026gt;'); }); module.exports = router;  注意:写请求路径news.html时不需要添加父路径/vip\n 将编写好的路由模块引入到主模块中，由主模块分配对应的请求到该模块中去处理(主模块为app.js)  代码\nvar appRouter = require('./routes/vip');//引入vip模块 app.use('/vip',appRouter);//分配vip目录下的请求给vip路由模块去处理  路由的区分 大路由(总路由) : app.js负责接收所有请求，对请求进行分配\n小路由(分路由) : /routes下面的所有路由模块，只负责处理自己能管理的目录下的所有请求\n响应对象 什么是响应对象 响应对象（res）是指服务器向容户端响应数据的对象，包含了所有要响应的内容\n响应对象的方法 res.send() //返回任意类型的数据 例：\nrouter.get('/',function(req,res){ //res.send('hello world'); //可以返回字符串数据 //var data={\u0026quot;name\u0026quot;:\u0026quot;李白\u0026quot;, \u0026quot;age\u0026quot;:999}; //res.send(data); // 也可以返回一个JSON数据 //res.send(1);//返回数字，即状态码 //res.send('1');//返回数字1 //返回状态码+数据链式调用 // res.status(404).send(\u0026quot;页面不见啦。。。。\u0026quot;); });  注意：\n 如果返回一个数字，就会被当成状态码，容易报错。 send方法能且仅能出现一次，重复无效且会报错，不写的话会挂起  res.json(); 返回JSON数据，自动设置相应头\n和send方法传递JSON数据的区别不大\n例\nrouter.get('/',function(req,res){ //var data={\u0026quot;name\u0026quot;:\u0026quot;李白\u0026quot;, \u0026quot;age\u0026quot;:999}; //res.json(data); // 返回json自动设置响应头 });  自己新建模板文件list.ejs 代码\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;用户列表\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;%for(var i in users){%\u0026gt; \u0026lt;li\u0026gt;姓名：\u0026lt;%=users[i].name%\u0026gt;====年龄:\u0026lt;%=users[i].age%\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;%}%\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  res.render(\u0026ldquo;模板名称\u0026rdquo;,{数据}); 读取模板文件，拼接数据（必须是json数据），自动将结果发送给浏览器\n模板名称直接写，路径在app.js文件中已经配置过了(即views目录下的文件)\n例\nrouter.get('/',function(req,res){ var data = [ {\u0026quot;name\u0026quot;:\u0026quot;aa\u0026quot;,\u0026quot;age\u0026quot;:\u0026quot;11\u0026quot;}, {\u0026quot;name\u0026quot;:\u0026quot;bb\u0026quot;,\u0026quot;age\u0026quot;:\u0026quot;22\u0026quot;}, {\u0026quot;name\u0026quot;:\u0026quot;cc\u0026quot;,\u0026quot;age\u0026quot;:\u0026quot;33\u0026quot;}, {\u0026quot;name\u0026quot;:\u0026quot;dd\u0026quot;,\u0026quot;age\u0026quot;:\u0026quot;44\u0026quot;} ]; //模板渲染 res.render('list.ejs',{users:data}); });  res.download 下载 res.download('./xxx.doc');//下载当前目录下面的xxx.doc文件。 res.download('./xxx doc, 'yyy.doc');//下载当前目录下面的xxx.doc文件，并且重命名为yyy.doc.  res.redirect(\u0026lsquo;目标\u0026rsquo;) 服务器端的跳转\nres.redirect('www.baidu.com');  完整api 1. res.app:同req.app一样 2. res.append():追加指定HTTP头 3. res.set()在res.append()后将重置之前设置的头 4. res.cookie (name,value[,option]) :设置Cookie opition:domain/expires/httpOnly/maxAge/path/secure/signed 5. res.clearCookie():清除Cookie 6. res.download():传送指定路径的文件 7. res.get():返回指定的HTTP头 8. res.json():传送JSON响应 9. res.jsonp():传送JSONP响应 10. res.location():只设置响应的Location HTTP头,不设置状态码或者closeresponse 11. res.redirect():设置响应的Location HTTP头，并且设置状态码302 12. res.send():传送HTTP响应 13. res.sendFile(path[,options][,fn]) :传送指定路的的文件-会自动根据文件extension 设定Content-Type 14.res.set():设置HTTP头，传入object可以一次设置多个头 15. res.status():设置HTTP的状态码 16. res.type():设置Content-type的MIME类型  请求对象 什么是请求对象 客户端向服务器发送数据的对象，包含请求头和请求主体\n接收GRT方式传的值 req.query.参数名  例\nrouter.get('/content.html',function(req,res){ var id=req.query.id; res.send('获取到的ID是:'+id); });  接收POST方式传的值 req.body.参数名\n例：\nrouter.post('/login.html',function(req,res){ var username=req.body.username; var pwd=req.bady.pwd; res .send('你传的用户名是:'+username+',你传的密码是:'+pwd); });  匹配URL网址上的数据 在接请求地方去匹配，再通过语法进行接收，\n语法：\nreq.params.参数名\n请求：\nlocalhost:/news/abc  例：\nrouter.get('/news/:id',function(req,res){ //自动匹配news/后的值作为id的值 var id=req.params.id; res. send('\u0026lt;h1\u0026gt;接收到的参数是: '+id+'\u0026lt;/h1\u0026gt;'); });  完整api 1. req.app:当callback为外部文件时，用req.app访问express的实例 2. req.baseUrl:获取路由当前安装的URL路径 3. req.body/req.cookies:获得「请求主体」/Cookies 4. reg.fresh/req.sale:判断请求是否还「新鲜」 5. req.hostname/req.ip:获取主机名和IP地址 6. req.originalUrl:获取原始请求URL 7. req.params:获取路由的parameters 8. req.path:获取请求路径 9. req.protocol:获取协议类型 10. req-query:获取URL的查询参数串 11. req.route:获取当前匹配的路由 12. req subdomains:获取子域名 13. req.accpets():检查请求的Accept头的请求类型 14. req.acceptsCharsets/req.acceptsEncodings/req.acceptsLanguages 15. req.get():获取指定的HTTP请求头 16. req.is():判断请求头Content-Type的MIME类型  中间件 Express是一个自身功能极简，完全是由路由和中间件构成一个的web开发框架:从本质上来说，一个Express应用就是在调用各种中间件。\n什么是中间件 中间件就是一个函数，位于客户端与路由之间，可以访问请求对象和响应对象，也可以调起下一个中间件。\n自定义中间件 app.use(function(req,res,next){ res.send('我是中间件'); //next(); });  尾函数next 如果在中间件不调用next函数，整个请求响应流程就中止不会再往后面执行。\n调用尾函数相当于调用下一个中间件，执行完以后自己的函数继续执行。\n例：编写一个记录用户访问的中间件\napp.use(function(req,res,next){ var fs=require('fs'); var ip=req.ip; var time=new Date().toLocaleString(); var data=fs.readFileSync('./2019-12-09.1og'); data+='访问时间:'+time+'IP: '+ip+'\\n'; fs.writeFileSync('./2019-12-09.1og',data); next();| });  ","id":15,"section":"posts","summary":"Express 简介 什么是Express express是一个基于node.js的极简、灵活的web开发框架。可以实现非常强大的web服务器功能。 Expre","tags":["node"],"title":"Express框架","uri":"https://mumulx.github.io/2019/12/express%E6%A1%86%E6%9E%B6/","year":"2019"},{"content":" 常见的操作  发布项目（share project）：项目组长将本机的项目第一次发布到中央仓库中\n 下载项目（check out）：（检出项目：check out），组员将中央仓库的项目第一次下载到本机\n 更新（update）：将服务器中的最新的代码，同步到本机 (服务器\u0026ndash;\u0026gt;本机)\n 提交（commit）：将本地修改的内容，同步到服务器中（本地\u0026ndash;\u0026gt;服务器）\n  注意：更新和提交一定要及时，即：\n提交：在编写完某一个小功能，每天下班前提交 更新：编写功能前，每天上班前更新 编写之前先更新，写完之后立刻提交  svn的安装配置 下载 下载地址\nwindow下载地址\n配置 环境变量配置：一般是自动配置，可以进入环境变量(Path)检验一下，如果没有配置的话，则将root/bin目录配置到环境变量。\n验证是否安装成功 win+r\ncmd\nsvn --version\n出现一下代码则安装成功\nsvn，版本 1.8.17 (r1770682) 编译于 Nov 30 2016，13:25:58 在 x86-microsoft-windows Copyright (C) 2016 The Apache Software Foundation. This software consists of contributions made by many people; see the NOTICE file for more information. Subversion is open source software, see http://subversion.apache.org/ 可使用以下的版本库访问模块: * ra_svn : 使用 svn 网络协议访问版本库的模块。 - 使用 Cyrus SASL 认证 - 处理“svn”方案 * ra_local : 访问本地磁盘的版本库模块。 - 处理“file”方案 * ra_serf : Module for accessing a repository via WebDAV protocol using serf. - using serf 1.3.9 - 处理“http”方案 - 处理“https”方案  配置中央仓库 中央仓库：保存项目的各个版本\n使用本地文件夹模拟中央仓库：\n svnadmin create 文件夹目录  例：\nsvnadmin createC:\\\\workplace\\\\svn\\\\svnck  注意：文件夹要为空\n启动svn服务 命令行方式(不推荐) svnserve -d -r 仓库目录  例\nsvnserve -d -r C:\\workplace\\svn\\svnck  注意：此时命令行窗口不能关闭，关闭之后服务就会终止\n注册系统方式(推荐) 在cmd中运行\n注意：cmd要以管理员身份运行\nsc create 服务名 binpath=\u0026quot;安装目录\\bin\\svnserve.exe --service -r 仓库位置\u0026quot; start=auto depend=Tcpip  例：\nsc create mysvn binpath=\u0026quot;C:\\RJ\\svn\\bin\\svnserve.exe --service -r C:\\workplace\\svn\\svnck\u0026quot; start=auto depend=Tcpip  出现以下代码则成功\n[SC] CreateService 成功  启动服务的两种方式 方式一(命令行)： 启动：sc start 服务名\n关闭：sc stop 服务名\n删除 sc delete 服务名\n方式二(服务列表)： 服务列表所在位置：开始-\u0026gt;windows管理工具-\u0026gt;服务\n访问项目 匿名访问 开启匿名访问 打开项目仓库的conf目录下的svnserve.conf文件找到\n# anon-access = read # anon-access = write # anon-access = none  三者者三选一，\n# anon-access = read 表示开启匿名访问后指允许读；\n# anon-access = write 表示开启匿名访问可读可写；\n# anon-access = none 表示什么也不能操作（一般选择）；\n注意：去掉#的时候把空格也要去掉，顶格写，否则可能会出错！\n授权访问 开启授权访问 打开项目仓库的conf目录下的svnserve.conf文件找到\n# auth-access = write # password-db = passwd # authz-db = authz  # password-db = passwd 表示授权人的用户名密码存放在passwd文件（授权文件）中。\n# authz-db = authz 表示授权访问的权限标识符，权限文件存放在authz中。\n注意：去掉#的时候把空格也要去掉，顶格写，否则可能会出错！\n编写用户文件 打开passwd文件（授权文件）在svnserve.conf文件的同级目录，在[users]下面添加用户名密码。采用键值对的形式用户名=密码。\n例如：\naa=123 bb=abc  编写授权文件 在[groups]下面创建分组\n例\ndev=aa,bb  对分组进行权限编写，例\n[/] @dev=rw *=  表示dev组的人员对项目根目录下的文件具有读和写的操作，其他人员没有权限。\n在Eclipse中使用SVN 默认eclipse是不支持svn的\n配置 离线方式 将eclipse_svn_site-1.10.5插件放入eclipse的安装目录的dropins子目录下，需要解压。\n在线方式 打开eclipse\u0026ndash;\u0026gt;help\u0026ndash;\u0026gt;Eclipse Marketplace 搜索：subversion/subeclipse，下载安装即可（可能比较慢）。\n检查 启动eclipse在项目中右键Team\u0026mdash;\u0026gt;Share Project会出现SVN选项。\n使用 发布项目 项目中右键Team\u0026mdash;\u0026gt;Share Project-\u0026gt;SVN\u0026ndash;\u0026gt;创建新的资源库位置\u0026ndash;\u0026gt;ur:svn://127.0.0.1\u0026ndash;\u0026gt;finish\u0026ndash;\u0026gt;右键项目\u0026ndash;\u0026gt;提交;\n需要输入用户名和密码，\n打开项目会发现代码后面有黄色的状态码\n黄色圆柱：本地无未提交代码 */灰色箭头：本地有未提交的代码 红色！：有冲突 蓝色箭头：服务端有最新代码，本地还没有更新  下载项目 file\u0026ndash;\u0026gt;import\u0026ndash;\u0026gt;从svn检出项目\u0026ndash;\u0026gt;next-\u0026gt;ur:svn://127.0.0.1\u0026ndash;\u0026gt;next\u0026ndash;\u0026gt;finsh\n提交代码 单个提交\n代码右键\u0026ndash;\u0026gt;team\u0026ndash;\u0026gt;提交\n多文件提交\n项目右键\u0026ndash;\u0026gt;Team\u0026ndash;\u0026gt;与资源库同步\u0026ndash;\u0026gt;ctrl选中多个文件\u0026ndash;\u0026gt;右键提交\n更新代码 单个文件\n代码右键\u0026ndash;\u0026gt;team\u0026ndash;\u0026gt;更新\n多个文件\n项目右键\u0026ndash;\u0026gt;Team\u0026ndash;\u0026gt;与资源库同步\u0026ndash;\u0026gt;ctrl选中多个文件\u0026ndash;\u0026gt;右键更新\n或\n右键项目\u0026ndash;\u0026gt;Team\u0026ndash;\u0026gt;更新\n注意：当提交项目或下载项目时，点击了保存密码，一但密码出错，很难更改密码，或更换用户；\n更改svn用户密码 进入C:\\Users\\当前用户\\AppData\\Roaming\\Subversion\\auth 删除文件夹中的所有文件即可重新填写用户，密码。\n解决冲突 一般更新或提交时会发现冲突\n右键项目\u0026ndash;\u0026gt;Team\u0026ndash;\u0026gt;与资源库同步\u0026ndash;\u0026gt;红色箭头表示冲突文件\n右键编辑冲突\u0026ndash;\u0026gt;修改\u0026ndash;\u0026gt;右键文件\u0026ndash;\u0026gt;team\u0026ndash;\u0026gt;标记为解决；重新提交。\n查看和恢复历史版本 右键\u0026ndash;\u0026gt;Team\u0026ndash;\u0026gt;显示资源历史记录\n查看版本：双击\n恢复所选版本:右键\u0026ndash;\u0026gt;获取内容\n注意：如果报错，则需要设置svnserve.conf 文件中的anon-access=none\nsvn发布到外网 第一种 当网段不在同一个网段上时，可以借助nat123将局域网ip映射到外网ip；通过访问外网ip来访问中央仓库。\n第二种 租赁服务器，将项目发布到服务器中\n第三种 使用svn托管的网站，\n","id":16,"section":"posts","summary":"常见的操作 发布项目（share project）：项目组长将本机的项目第一次发布到中央仓库中 下载项目（check out）：（检出项目：chec","tags":["版本控制"],"title":"Svn学习笔记","uri":"https://mumulx.github.io/2019/12/svn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" node.js简介 简单来说node.js就是js的一个运行环境，可以运行js代码，用于服务器端编程。\n下载安装 下载node.js\n安装：一路next\n环境变量会自动配置，不放心的话可以自己查看一下。\n验证：\n运行cmd：\nnode -v  node使用 进入项目目录运行cmd\nnode 文件名(.js)  .js可写可不写，因为node能且仅能运行js文件\n或 运行cmd\nnode  编写js代码\n模块组成 node.js提倡我们进行模块化编程\n所有用户编写的代码都放在模块中，模块就是文件(函数)\n用户编写的代码在nodejs运行时都会自动放在一个函数中，所以一个文件就是一个模块\n用户编写的代码都自动封装在一个函数中\nfunction(exports,require,module,_filename,_dirname){}  函数有五个参数:\nexports 暴露对象，可以将模块中的数据暴露给引入的地方 require 引入模块的函数， 用于在一个模块中引入另外一个模块，并且将子模块暴露的数据赋值给变量 module 模块对象， 包含了当前模块的所有信息 __filename 当前模块的文件 名 __dirname 当前模块所在的路径(目录路径〉  nodejs的模块是指所有用户编室的代码都放在函数中，所有定义的函数或变量都是局部的，相互之间不受影响。如果模块之间需要共享数据，则需要使用module.exports是暴漏对象。\nrequire : 作用:在当前模块中加载另外一个模块\n模块分类:\n 自定义模块\n我们自己编写的文件就是一个自定义模块\n注意：\n 子模块没有暴漏数据，返回空对象\n 自定义模块必须加./(指向当前模块)因为在node.js中查找模块默认在node_modules目录中去查找\n  第三方模块\n第三方程序员或公司开发的模块，先安装再使用\n安装可以使用npm包管理工具\nnpm install \u0026lt;包的名字\u0026gt;  引入 require(\u0026ldquo;模块名\u0026rdquo;)\n 系统模块\nnode.js开发团队已经开发好的功能模块，直接引入即可使用，不需要安装也不需要自己写\n例如：\nfs http url path \u0026hellip;.\n引入 require(\u0026ldquo;模块名\u0026rdquo;)\n  require函数的注意事项:\n1) 当引入的模块有语法错误时，会报错。 2) 当引入的模块路径有错时，也会报错。 3) 当一个模块被多次引入时，只执行一次,会将暴露对象直接写入缓存，以后就直接从缓存读取  exports导出对象: 作用:将模块中需要共享给其它模块的数据暴露(导出)到引用处\n语法:\nexports.属性名=值; exports .方法名=函数;  注意:\n1) exports 是module.exports对象的引用 2) exports 是module.exports的引用，不能改指向，只能添加属性和方法S 3) module.exports才是真正的暴漏对象，指向哪里就暴漏哪里  module模块对象: module.exports真正的暴露对象, exports对象只是对它的引用。\nmodule.exports.属性=值; module.exports.方法=函数; module.exports=对象或函数; module.id模块ID， 模块名称 module. parent模块的父级 module. filename模块的文 件名和路径 module.children子模块列表 module. paths模块查找路径，如果当前目录下找不到node_ modules就去上一级目录查找，直到根目录如果配置了NODE_ PATH环境变量， 则会再去环境变量指向的路径查找  控制合命令: console.1og() 普通输出语句 console.dir() 输出对象 console.errar() 警告输出 console.time(标识) 计时开始 console.timeEnd(标识) 计时结束 console.assert(表达式，输出文字) 当表达式为假时，输出文字  node. js的作用域: 由于node.js在执行里会将用户编写的所有代码都封装在函数中，所有用户定义的变量或函数都是局部的。\n要将数据共享给其它模块使用:\n1.暴露对象 module.exports 2.全局对象 global.工性或方法=值; 注意:使用时global关键字可以省略不写  npm 什么是NPM npm(Node Package Manager)是基 于nodejs的包管理工具\n一般node.js自带npm不需要自己在单独配置\n测试：打开cmd\nnpm -v  下载的文件存放的目录一般是node_modules\n什么是包 包===项目 模块===文件\n创建package.json npm init npm init -y //自动以全部为yes的形式生成package.json文件  package.json简介 package.json是node. js项目的包描述文件，以JSON格 式的形式描述项目\npackage.json的常用属性 name 项目名称 version 版本号 description 项目描述 main 主模块（入口文件） dependencies 依赖列表 devDependencies 开发时依赖 scripts 脚本命令， 可以使用npm命令进行执行 license 开源协议 contibutors 包的其他贡献者姓名。  npm的常用命令 安装命令\nnpm install \u0026lt;包的名称\u0026gt; //安装指定的包（package.json文件中指定的依赖dependencies） npm i //自动下载package.json中的依赖 npm i \u0026lt;包的名称\u0026gt; , //效果同上，缩写形式 npm i \u0026lt;包的名称\u0026gt;@版本号 //安装指定版本的包 npm i \u0026lt;包的名称\u0026gt; -g //全局安装 安装位置: C: \\Users \\Administrator\\AppData\\Roaming \\npm\\node_ modules 我的位置已修改C:\\Program Files\\nodejs\\node_global npm i \u0026lt;包的名称\u0026gt; --save //将安装包写入package .json依赖列表 npm i \u0026lt;包的名称\u0026gt; --save-dev //将安装包写入package .json开发时依赖列表 //其它命令 npm search \u0026lt;包的名称\u0026gt; , /搜索包 npm view \u0026lt;包的名称\u0026gt; //查看 包的信息 npm uninstall \u0026lt;包的名称\u0026gt; //卸载包 npm update \u0026lt;包的名称\u0026gt; 更新包  不使用-g只下载在当前目录，只有当前目录可用，使用-g是全局下载，下载到整个电脑，所有目录均可使用，以后在使用就不需要下载\n下载的版本号问题：\nexpress\u0026quot;: \u0026quot;^4.17. 1\u0026quot;\n 4.17.1:指定版本\n ~4.17.1:版本号\u0026gt;=4.17.1，^表示\u0026gt;=4.17.1，但是\u0026lt;4.18.x;即本次下载4.17.99\n4.17.1 4.17. 2 4.17.99 4.18.22  ^4. 17.1: 版本号\u0026gt;= 4.17.1，^表示\u0026gt;=4.17.1，但是\u0026lt;5.x.x,即本次下载4.19.23\n 4.17.1 4.17.2 4.17. 99 4.18.22 4.19.23 5.1.1  lastest:在所有范围内找最大的，即本次下载5.1.1\n 5.1.1 4.17. 1 4.17.2 4.17. 99 4.18.22 4.19.23   cnpm npm 就是一个文件下载工具，默认情况下去 npmjs.com/github. com下载资源\ncnpm 由于在国内下载npmjs. com的数据非常慢，所以淘宝制作了一个npmjs.com的镜像(可以下载，不能上传)，直接访问国内的网站下载较快用法和npm一毛一样。\n安装：\nnpm install -g cnpm --registry=https://registry.npm.taobao.org  之后下载的话就使用cnpm用法跟npm一样\n回调函数 什么是回调函数? 回调函数又称为回调，将a函数作为参数传入b函数中，b函数在执行过程中根据时机或条件决定是否调用a函数，a函数就是回调函数。\n异步的三种实现方式:\n1. 回调函数 回调函数不一定是异步，但是异步定有回调函数 2. 事件 3. promise  回调函数 //异步-定有回调函数\nsetTimeout(function(){ console.1og('....' ); }, 1000);  //回调函数不一定是异步\nconsole. log( '1111'); var arr=[1,2,3,4]; arr.forEach(function(v,i){ console.1og(v); }); console.1og('2222');  事件 事件源.on('事件名称',回调函数)  promise承诺对象:  什么是promise\npromise是ES6中新增的承诺对象，用于对异步的操作进行消息的传递。\n promise的状态\n Pending 等待中 Resolved 成功 Rejected 失败 Pending =\u0026gt; Resolved Pending =\u0026gt; Rejected  promise有什么用?\npromise可以用于传递异步消息\n  缓存区: 什么是缓存区 在内存中开辟-个临时区域用于存 储需要运算的字节码\n创建缓存区 创建指定长度的缓存区 var buf = new Buffer(5);  按指定的数组（编码）创建缓存区 var buf=new Buffer([97,98,99,65,66]);  按指定字符创建缓存区 var buf=new Buffer( '字符串' ) ;  写入缓存区 buf.write('字符串' );  读取缓存区 buf.toString();  缓存区复制 buf.copy(buf2);  文件系统操作 读取文件 由于node.js是服务器端程序，必须要有读写文件操作，在客户端没有这样的功能。\n文字读写有两种方式:\n直接读取 将硬盘上的所有内容全部读入内存以后才触发回调函数\n两种写法:\n异步:\nfs.readFile('./file1.txt',function(err.data){ console.log(data.toString()); });  同步:\nvar data = fs.readFileSync('./file.txt');  注意：一般同步的方法都是在异步的方法后面添加Sync\n流式读取 下面会专门讲。\n写文件: 同步版本  fs.writeFileSync('文件名','数据');  异步版本 fs.writeFile('文件名',数据,function(err){ //写完文件以后执行的代码 });  例\n//文件读取 //如果要读写文件，必须使用文件系统模块(fs) var fs=require('fs'); //直接读取文件---异步 fs.readFile('./file1.txt',function(err.data){ console.log(data.toString()); }); //同步 var data = fs.readFileSync('./file.txt'); console.log(data); console.log(data.toString()); //异步写文件 var hello=\u0026quot;\u0026lt;h1\u0026gt;Hel1o Node.js\u0026lt;/h1\u0026gt;\u0026quot;; fs.writeFile( 'index.html', hello,function(err){ if(err){ throw err; }else{ console.1og('文件写入成功'); } });  读取文件信息 fs.stat(' ./file1.txt',function(err,state){ console.log(state); });  属性解析\nsize 文件大小(字节) mtime 文件修改时间 birthtime 文件创建时间  方法解析\nisFile() 判断当前查看的对就是不是一个文件 isDirectory() 判断是不是一个目录  删除文件 fs.unlink('./jquery.js',function(err){ if(err){ throw err; }else{ console.log( '删除成功') ; });  例\n需求:编写代码实现删除一个非空目录\n使用代码删除某个文件夹，该文件夹不为空。\n使用递归函数实现，逐层查询并清空文件再删除空文件夹\n 定义一个函数，用于实现递归调用。\n 删除空文件夹(删不掉，目录非空)\n 读取文件夹的内容(文件及文件夹列表)\n 遍历数组一个一个获取文件信息\n 判断是否为文件，如果是文件则删除\n 判断是否为目录，如果是目录就调用自己(递归的入口)\n  代码\nfunction deldir(p){ //读取文件央的内容 var list=fs.readdirSync(p); //遍历数组 for(var i in list){ //list[i]是当前目录中每个文件及文件夹的名称 var path=p+'/'+list[i]; //拼接 一个从(05.js)当前目录能查找到的路径 var info=fs.statSync(path); if(info.isFile()){ fs.unlinkSync(path); //如果是文件则删除文件 }else{ arguments.callee(path);//如果不是文件就是目录，则调用自己再删除该目录 } } fs.rmdirSync(p); //删除空文件夹 } deldir('./aa');  文件流 什么是流 所有互联网传输的数据都是以流的方式，流是一组有起点有终点的数据传输方式\n流的操作 流式读取文件 一节一节的读取数据，一节64kb ==\u0026gt; 65536字节\n以流的方式写文件 一节一节的写文件\n例\n读入流\n//创建一个可以读取的流 var stream=fs.createReadStream('./file1.txt'); //绑定data事件，当读取到内容就执行 stream.on( 'data',function(a){ console.log('------------------'); console.log(a.length); }); //读取流的事件: end完成事件 stream.on('end',function(){ console.log('数据读完了'); }); //读取流出错事件: error错误事件 stream.on('error'，function(err){ console.log(\u0026quot;读取出错\u0026quot;); //抛出错误 //throw err; });  写入流\nvar fs=require('fs'); //创建一个可以写入的流 var stream=fs.createWriteStream('./file2.txt' ); //写入数据 stream.write('张三失踪了'); stream.write('李四也失踪了'); stream.write('王小五也疯了'); stream.end(); //以流的方式写入数据 必须显示的声明结束 //on是绑定时事件 //写入流的事件: finish 完成事件 stream.on('finish',function(){ console.log('写完了'); }); //写入流的事件: error 错误事件 stream.on('error',function(err){ console.log( '出错啦'); });  需求:实现大文件的复制\nvar fs=require('fs'); var s1=fs.createReadStream('./file3.txt'); var s2=fs.createWriteStream('./file6.txt'); //以流的方式 //以流的方式实现大文件复制，读取一节存一节 s1.on('data',function(a){ s2.write(a); }); s1.on('end',function(){ s2.end(); console.log(\u0026quot;文件复制已完成!\u0026quot;) ; }); //以管道的形式 s1.pipe(s2);  链式流:\n将多个管道连接起来，实现链式处理。\n需求:使用链式流实现大文件压缩!\n代码\nvar fs=require('fs'); var zlib=require('zlib'); var s1=fs.createReadStream('./file3.txt'); var s2=fs . createWriteStream('./file3.txt.zip'); s1.pipe(zlib.createGzip()).pipe(s2);|  path模块 什么是path模块? path模块是node.js中提供的一个系统模块，用于格式化或拼接一个完整的路径\npath模块的常用方法  path.join() //将多 个字符串拼接成一-个完整的路径 path.dirname() / /返回路径中的文件夹部分 path.basename() / /返回路径中的文件部分(文件名和扩展名) path.extname( ) / /返回路径中的扩展名部分 path.parse()/ / 解析路径:近回一个对象包含路径中的各个部分  URL模块: 什么是URL? url全球统一资源定位符， 对网站资源的一种简洁表达形式，也称为网址。\nURL 的构成 构成：\n协议://用户名:密码@主机名.名.城:端口号/目录名/文件名.扩展名?参数名=参数值\u0026amp;参数名2=参数值2#hash\nhttp协议的URL常见结构:\n协议://主机名.名.域/目录名/文件名.扩展名?参数名=参数值\u0026amp;参数名2=参数值2#hash\nhttps默认的端口号是443\nhttp默认的端口号是80\nnode. js的URL模块 在node.js中提供了两套对于url进行处理的API功能。\n 老的node.js url模块\n 新的url模块 (WHATWG URL标准模块》\n  什么是网络 网络是一个共享、传输信息的虚拟平台。\n什么是网络协议 每天有大量的数据在网络上传输，都需要遵循相应的规则，规则就是网络协议。\n什么是http协议 http (hypertext transfer protocol) 即超文本传输协议，传输超文本内容(文字、图片、视频、音频、动漫\u0026hellip;\nhttp协议规定了数据在服务器与浏览器之间传输数据的格式和过程。\nhttp协议规定 的细节 http协议是一种请求应答形式的协议，一次请求， 一次应答(响应)。\n细节: 1. 定义了浏览器以什么格式向服务器发请求， 2. 定义了服务器以什么格式解析浏览器发送过来的数据， 1. 定义了服务器以什么格式响应数据给浏览器， 1. 定义了浏览器以什么格式解析服务器响应的数据\n软件开发模式  单机软件\n打开电脑就能用，不需要网络，如: HBuilder、Word.西图\u0026hellip;.\n  2) C/S软件\n客户端Client /服务器端 Server 需要下载安装以后，才能连接网络使用，如:迅雷、QQ、微信....  3) B/S软件\n浏览器BrowEr /服务器端 Server 打开网址直接使用，不需要安装，如:百度、淘宝、JD....  注意：所有浏览器发起的请求都是get方式，post请求只能通过表单提交发起\nhttp模块:  get方法  get方法用于模仿客户端从服务器获取数据\nhttp.get('url',function(res){ //res是返回对象，接收到服务器响应的所有内容 });  网络爬虫程序 什么是爬虫? 网络爬虫又被称为网页蜘蛛或网络机器人，是一种按照一定的规则， 自动地抓取万维网信息的程序。\n案例：写一个爬虫程序从nipic. com批量下载图片 url: http://www. nipic. com/ photo/jianzhu/ shinei/index. html\n开发思路:\n1)打开网页查看内容，找图片地址 找规律=\u0026gt;查看网页源代码 小图: http://img90.nipic. com/file/20180110/5792316151721347529 1.jpg 大图: http://pic152.nipic. com/fne/20180110/5792316_ _151721347529_ _2.jpg 2)编写代码实现打开网页，获取所有的html内容 3)通过正则表达式提取出有哪些图片地址 4)遍历图片地址数组，一个一个请求 5)将获取到的图片数据保存在硬盘上  代码：\nvar http=require('http'); http.get('http://www.nipic.com/photo/jianzhu/shinei/index.html',function(res){ var data=''; //定义一个变量用于存放一段一段的HTML数据 //以流的方式读取数据 res.on('data',function(a){ data+=a. toString(); }; //绑定end事件 res.on('end',function(){ //data 就是当前网页的HTML内容 //编写正则表达式提取所有的图片地址 var reg=/\u0026lt;img src=\u0026quot;(.+?)\u0026quot; alt=\u0026quot;.*?\u0026quot;\\/\u0026gt;/img; //exec正则表达式方法，获取匹配到的结果，只能获取一个，指针自动向下移动 var arr =[]; var result=\u0026quot;\u0026quot;; while(result= reg.exec(data)){ arr.push(result[1]); } for(var i in arr){ (function(i){ setTimeout(function(){ getImg(arr[i]); },3000*i); })(i); } }); }); //定义一个函数用于获取图片内容 function getImg(ur1){ //console.log('修改前: ' ,ur1); ur1=ur1.replace(/img\\d\\d/,'pic152').replace('1.jpg','2.jpg'); //console.log('修改后:',url); http.get(ur1, function(res){ var fn=new Date().getTime(); //创建一个可写流 var stream=fs.createwriteStream('./files/'+fn+'.jpg'); res.pipe(stream); });\t}  小结 回调函数 什么是回调函数? 回调函数也称为回调(callback)，其实就是一个普通函数。将该函数作为另外一个函数的参数传入，由另外一个函数根据条件或时机决定调用\n回调函数的实现机制  定义一个普通函数(作为回调函数)\n 将该函数作为一个参数传入另外一个函数(调用者)中\n 调用者函数在具体的时机或条件达到时，调用该函数(回过头再调用的函数)\n  回调函数的作用 如果我们需要在某一个任务完成后，执行一段代码，可以使用回调函数\n异步与同步[重点] 什么是异步与同步? 同步:前一个任务完成以后，后一个任务才能继续执行(会造成阻塞)\n异步:将比较复杂的任务制作成异步模式(回调函数)，后一句代码不需要等待前一.句完成也可以继续执行(不会造成阻塞)\n异步的实现  回调函数 异步一定有回调函数，回调函数不一定是异步(一些同步的情况也会用到回调函数) 事件 触发事件以后执行一个回调函数，就是异步 事件源.on(事件类型,回调函数) ; promise promise (承诺)对象，实现异步的消息传递。  buffer缓存区 什么是缓存区? 缓存区就是在内存中开辟存储空间，用于存储字节码数据。\n缓存区操作 1.创建新的缓存区\nvar buf=new Buffer(10); var buf=new Buffer([97,98]); var buf=new Buffer('张三 ');  1.读取缓存区\nbuf.toString(); //将字节码转换成字符串  1.写缓存区\nbuf.write(\u0026quot;字符串\u0026quot;);  1.复制缓存区\nbuf1. copy(buf2);  文件基本操作(直接操作) 读取文件内容 //异步出错时自己定义抛出异常系统不会报错 fs. readFile('文件路径'，function(err, data){ //err是错误对象，如果有错则有值，没有错则为nu1l //data是数据(字符串) }); //同步:只要在异步的方法名后面加Sync就是同步版本 //出错时系统会自动报错 var data=fs.readFileSync( '文件路径);  读取文件信息 fs.stat('文件路径'，function(err, info){ //info就是文件的信息 .size文件的大小 .ctime文件的创建时间 .mtime文件的修改时间 .atime文件的访问时间 .birthtime文件的创建时间 //方法 .isFile()判断是不是 一个文件 .isDirectory()判断是不是一一个目录  写文件内容(新增、修改) fs .writeFile('文件路径'，数据内容，function(err){ //如果文件存在则修改 //如果文件不存在则新增 });  删除文件 fs.unlink('文件路径',function(err){ });  新增目录 fs.mkdir('目录路径',function(err,list){ //list是读取到的当前文件夹的所有文件及其子文件夹列表 });  读取目录中的文件列表 fs. readdir('目录路径', function(){ });  删除空文件夹 fs . rmdir('目录路径', function(err){ //只能删除空文件夹，不能删除非空文件夹 });  其它操作 改支件名或目录名...  流式读写 什么是流 流是一组有序的、有起点和终点的字节数据的传输方式(流式)。流的内容称为字节流。\n读取流 var stream=fs.createReadStream('文件路径'); //绑定data事件接收数据 stream. on('data',function(data){ console.1og(data); }); //绑定error错误事件 异步的方式 stream.on('error'function(err){ throw err; }); //绑定end结束事件 stream.on('end',function(){ console.log( '数据读取完毕'); });  写入流 var stream=fs.createWriteStream('文件路径'); //写入数据 stream.write('数据1'); stream.write('数据2'); stream.write('数据3'); stream.end(); //流式写入完毕时一 定要-个明确的结束标识 //绑定finish数据写入完成事件 stream. on('finish'，function(){ }); //绑定error出错事件 stream. on('error'，function(err){ });  管道pipe 什么是管道 管道(pipe)是一种输入流与输出流之间传输数据的机制\n管道的写法 输出流.pipe(输入流);  管道的作用 管道可以实现对大文件的操作(文件大小超过内存)\n链式流 将多个管道连接起来，进行链式操作。\n输出流.pipe(中转流). pipe(中转流).pipe(....). pipe(输出渝) ;  远程服务器(使用的是阿里云) 使用window的远程桌面命令:mstsc: 连接远程服务器，操作服务器。\n注意在网页的后面添加robots.txt就可以看到网站（例如：淘宝）的蜘蛛协议，它可以说明此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。\nnode.js服务器创建步骤  引入通信模块 创建服务器 监听request事件 监听端口 访问服务器:\n 打开浏览器 输入网址\n 127.0.0.1 本机地址\n localhost 本地主机，本地域名\n 172.16.3.224 局域网工IP(使用cmd命令行获取ipconfig)\n    例：\nvar http=require('http'); //创建服务器 var server=http.createServer(); //监听request请求事件， 当前请求事件发生时就返回数据 server.on('request',function(req,res){ //都是以流的方式来传送请求 //req: 请求对象，包含了所有客户端请求的数据，请求头、请求主体 //res:响应对象，包含了所有服务器端发送给客户端的数据，响应头、响应主体 res .write('\u0026lt;h1\u0026gt;He11o Node.js\u0026lt;/h1\u0026gt;'); res .write('\u0026lt;p\u0026gt;He1lo 1111\u0026lt;/p\u0026gt;'); res. end(); }); //监听服务器的80端口（默认的就是80，所以访问时不需要加端口号） //可以监听其他端口，但是访问时需要加端口号 server.listen(80, function(){ console.log( '服务器已运行...'); });  //组合写法 require('http').createServer(function(req,res){ res .write('\u0026lt;h1\u0026gt;He1lo world\u0026lt;/h1\u0026gt;'); res.end() ; }).listen(80,function(){ console.log( '服务器已运行...'); });  注意：可能需要的cmd命令\n//查看自己的电脑开了哪些端口 //netstat -a //查看端口被谁占用 //netstat -ab  服务器url 网页响应内容:\n可以根据用户请求的url不同，判断响应不同的数据，实现访问不同的URL得到不同的结果。 核心: req.ur1获取到用户请求的网址\n例\nvar http=require('http'); var server=http.createServer(); server.on('request',function(req,res){ if(req.url==='/'){ res.write(\u0026quot;\u0026lt;h1\u0026gt;HomePage\u0026lt;/h1\u0026gt;\u0026quot;) } if(req.url==='/article.html'){ res.write(\u0026quot;\u0026lt;h1\u0026gt;article.html\u0026lt;/h1\u0026gt;\u0026quot;) } if(req.url==='/about.html'){ res.write(\u0026quot;\u0026lt;h1\u0026gt;about.html\u0026lt;/h1\u0026gt;\u0026quot;) } res.end(); }); server.listen(80, function(){ console.log( '服务器已运行...'); });  http状态码 什么是状态码 http协议规定的服务器响应数据时的状态编码，就是状态码\n常用的状态码 1xx :表示普通消息，没有特殊含义 2xx :表示服务器响应成功 200 成功 3xx :表示重定向 301 永久重定向 302 临时重定向 304 使用缓存(服务器没有更新过) 4xx :无法访问 403 权限不足， 无法访问 404 资源找不到 5xx :服务器有错 500 服务器端代码有错 502 网关错误 503 服务器已崩溃  状态码的使用 res .writeHead(状态码,响应头对象);  例\nvar http=require('http'); var server=http.createServer(); server.on('request',function(req,res){ res.writeHead(200,{\u0026quot;Content-type\u0026quot;:\u0026quot;text/html;charset=utf-8\u0026quot;}); res.write(\u0026quot;\u0026lt;h1\u0026gt;中文乱码解决\u0026lt;/h1\u0026gt;\u0026quot;) res.end(); }); server.listen(80, function(){ console.log( '服务器已运行...'); });  响应头 Content-Type 响应的文件类型 text/html 注意:未指定响应文件类型时，默认就是html,编码默认是系统编码 Content-Length 响应内容的长度 Access -Control-Allow-Origin 设置响应头可以跨域  例\nvar http=require('http'); var server=http.createServer(); server.on('request',function(req,res){ res.writeHead(200,{ \u0026quot;Content-type\u0026quot;:\u0026quot;text/html;charset=utf-8\u0026quot;, \u0026quot;Content-Length\u0026quot;:24 //\u0026quot;Access-Control-Allow-Origin\u0026quot;:\u0026quot;*\u0026quot;//实现跨域 }); res.write(\u0026quot;\u0026lt;h1\u0026gt;中文乱码解决\u0026lt;/h1\u0026gt;\u0026quot;) res.end(); }); server.listen(80, function(){ console.log( '服务器已运行...'); });  MIME类型: 什么是MIME类型 MIME类型可以认为是文件类型的表述\n常用的MIME类型 .txt text/plain .html text/html . CSS text/css .js text/javascript .png image/png .jpg image/jpeg .gif image/gif .json text/json application/json .mp3 dio/mpeg .mp4 video/mpeg .pdf application/pdf .xml text/xm1 .zip application/x-gzip  例\n\u0026quot;Content-Type:\u0026quot;text/html; charset=utf-8\u0026quot;, / /生成一个html网页 \u0026quot;Content-Type\u0026quot;:\u0026quot;text/plain; charset=utf-8\u0026quot;, //生成一个普通文本 \u0026quot;Content-Type\u0026quot;:\u0026quot;inage/png\u0026quot;, //生成一个普通文本 \u0026quot;Content- Type\u0026quot;:\u0026quot;application/x-gzip\u0026quot;, //生成一个压缩包， 浏览器自动下载  静态网页资源服务器实例 node.js静态网页服务器实例\n客户端向服务器传递数据:  GET方式\n 在URL后面添加?写键值对形式就是GET方式传数据 只要可以写url的地方就可以在后面加?传参数 在node.js可以接收到客户端传过来的参数值。  POST方式\n post方式提交数据只能使用表单提交的方式   实例\n接收Get方式传值\n方式一\nvar http=require('http'); var server=http.createServer(); server.on('request',function(req,res){ //Get方式 //通过解析req.url后面参数字符串的解析分析出传递的参数的值 var query = req.url.split(\u0026quot;?\u0026quot;); var value = query[1].split(\u0026quot;=\u0026quot;); res.writeHead(200,{\u0026quot;content-type\u0026quot;:\u0026quot;text/html;charset=utf-8\u0026quot;}); res.write(\u0026quot;\u0026lt;h1\u0026gt;你传递的参数的值是\u0026quot;+value[1]+\u0026quot;\u0026lt;/h1\u0026gt;\u0026quot;) res.end(); }); server.listen(80, function(){ console.log( '服务器已运行...'); });  方式二\nvar http = require(\u0026quot;http\u0026quot;); var http = require(\u0026quot;url\u0026quot;); var serve = http.createServe(function(req,res){ //传参lohost://9999?a=b\u0026amp;c=d var params = url.parse(req.url,true).query; //类型转换为字符串 res.write(params.a+\u0026quot; \u0026quot;); res.write(params.c+\u0026quot; \u0026quot;); res.write(\u0026quot;\u0026lt;p\u0026gt;hello World\u0026lt;/p\u0026gt;\u0026quot;); res.end(\u0026quot;end...\u0026quot;); }); serve.listen(9999,function(){ console.log(\u0026quot;serve is runing...\u0026quot;); });  接收Post方式传值\nvar http=require('http'); var server=http.createServer(); server.on('request',function(req,res){ //判断请求 if(req. ur1==='/action.html'){ //从req请求主体中获取到POST方式提交的数据 var query='';//存储结果 //post请求会触发data事件 req.on('data',function(a){ query+=a.toString(); }); //请求结束会触发end事件 req.on('end'，function(){ res.writeHead(200, {\u0026quot;Content - Type\u0026quot;: \u0026quot;text/html; charset=utf-8\u0026quot;}); res.write('\u0026lt;h1\u0026gt;我们已经收到了请求\u0026lt;/h1\u0026gt;'); res.write(' \u0026lt;h1\u0026gt;接收到的数据是:'+query+*\u0026lt;/h1\u0026gt;' ); res.end( ); }); return; } server.listen(80, function(){ console.log( '服务器已运行...'); });  模板 使用动态网页模板:\n什么是模板\n将一些固定的结构或表现直接以静态文件形式存储，将需要表现成动态数据的地方使用模板语法进行编写，再使用模板引擎读取该静态文件，将动态的数据进行替换进去。最终实现产生出一个动态的网页\n小结 path模块 path模块主要用于对路径进行处理(解析、拼接、格式化等)\npath.join(字符串,字符串2); //将字符串拼 接成一个完整的路径 path.parse(路径); //将路径解析成为各个不同的部分，返回一个对象  url模块 什么是URL url是全球统一资源定位符，也称为网址\nURL的格式  完整的格式\n协议://用户名:密码@主机名.名.域:端口号/路径/文件名.扩展名?参数名=参数值\u0026amp;参数名2=参数值2#hash地址\n 常见的格式\n协议://主机名.名.域:端口号/路径/文件名。扩展名?参数名=参数值#hash地址\n  url模块 在node.js中提供了url模块，用于解析ur1中的各个部分，有两套API功能:\n//传统的node. js的ur1解析 var obj=url.parse(网址); //按WHATWG标准进行解析 var obj=new url . URL (网址);  http协议 什么是http协议 http协议就是超文本传输协议，主要用于规定客户端与服务器端进行数据传输的过程及格式。\nhttp协议以请求、应答形式进行数据交互，必须一次请求对应一次应答(响应)。\nhttp协议的细节 规定了客户端如何向服务器发送数据\n规定了服务器如何向客户端发送数据\n发送过程 客户端向服务器端发送数据称为请求，包含请求头和请求主体;\n服务器端向客户端发送数据称为响应，包含响应头和响应主体;\nhttp模块 什么是http模块 http模块是node. js中的系统模块，用于进行网络通信(服务器、客户端)\n.get()方法 用于获取其它服务器的数据(可以跨域)\n语法:\nhttp. get(url, function(响应对象){ 响应对象.on('data',function(){ }); });  http协议及工作原理 在浏览器中输入网址，回车时，将网址发送到指定的DNS服务器去查询对应的IP地址。\n浏览器获取到IP地址以后，向该IP的服务器发起请求，服务器收到请求，并且读取请求的网页文件，发送给客户端浏览器,浏览器可以直接解析执行html代码将内容渲染出来显示给用户\n如果服务器硬盘中没有该文件，就执行动态程序生成一个(使用node.js引擎读写数据库)生成html网页在发送给浏览器。\n编写网络蜘蛛抓职itsource . cn首页的所有图片 var http=require('http'); var fs=require('fs'); //获取itsource. cn首页的html内容 http. get( 'http://www.itsource.cn/',function(res){ varstr=''; res. on('data',function(a){ str+=a; }); res.on('end',function(){ //fs.writeFileSync('./itsource.html',str); var reg = /url\\((\\/upload.*?)\\)/; var arr,result=[]; while(arr=reg.exec(str)){ result.push(arr[1]); } }); });  ","id":17,"section":"posts","summary":"node.js简介 简单来说node.js就是js的一个运行环境，可以运行js代码，用于服务器端编程。 下载安装 下载node.js 安装：一路ne","tags":["node"],"title":"Node.js学习笔记","uri":"https://mumulx.github.io/2019/12/node/","year":"2019"},{"content":" 关于解决Eclipse导入SpringBoot项目jar包从Maven中下载太慢的问题 只需要在maven安装目录./config/settings.xml中插入下列代码,配置阿里镜像就可以了！\n\u0026lt;mirrors\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;nexus-aliyun\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;Nexus aliyun\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://maven.aliyun.com/nexus/content/groups/public\u0026lt;/url\u0026gt;; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; shshsh  ","id":18,"section":"posts","summary":"关于解决Eclipse导入SpringBoot项目jar包从Maven中下载太慢的问题 只需要在maven安装目录./config/setti","tags":["其他问题"],"title":"Eclipse导入springBoot项目jar包下载太慢的问题","uri":"https://mumulx.github.io/2019/11/eclipse%E5%AF%BC%E5%85%A5springboot/","year":"2019"},{"content":" Git简介 git lab指令\n启动\ngitlab-ctl start  关闭\ngitlab-ctl stop  关闭防火墙\nsystemctl stop firewalld  开启防火墙\nsystemctl start firewalld  Git指令 git init 项目初始化 git status 查看当前状态 git log 查看日志 git log -2 查看最近两次的提交 git log --pretty=oneline 一行 git log --pretty=format:\u0026quot;%h - %an ,%ar : %s\u0026quot; 指定格式 shal值前面的一部分- 作者 ，什么时候提交：提交注释 git add . git commit -m \u0026quot;xx\u0026quot; git push git add remote origin xxx git push origin master git config 查看帮助指令  \u0026emsp;Git是一个分布式版本控制系统。版本控制系统又分为：集群式版本控制系统(常见的有cvs、svn)、分布式版本控制系统(常见的有Git)。Git的官网是 Git，Git起源于Linus系统，因为BitMover公司不再向Linux社区提供BitKeeper软件免费的软件授权，因此有一些Linux大神创建了Git分布式版本控制系统，并且上传了Linux系统的源码。Git是以全量的方式管理版本即每一个版本都包含全部的文件，可以时刻保持数据的完整性。\ngit优势：\n 本地版本控制\n 重写提交说明\n 可以“后悔”\n 分支系统  svn:增量\ngit:全量(每一个版本都包含全部的文件,时刻保持数据的完整性)\nGit内部具有三种状态：  已修改(modified)：表示数据文件已经被修改，但未被保存到Git数据库中。 已暂存(staged)：表示数据文件已经被修改，并会在下次提交时提交到Git数据库中。 已提交(committed)：表示数据文件已经顺利提交到Git数据库中。  三个区 \u0026emsp;Git在管理项目时，文件流转的三个工作区域是：工作区域-\u0026gt;暂存区域-\u0026gt;对象区域。因此，基本的Git工作流程如下：在本地的工作目录对文件进行写操作；然后对修改后的文件进行add（处于 modified 状态），保存到暂存区域(处于 stage 状态)；最后提交更新(处于 commited 状态)，将保存在暂存区域中的文件版本永久转存到Git的本地仓库中。关于Git的安装和环境的配置，这里就不多说了，本篇主要是记录，自学过程中的知识点。\n 工作区 暂存区 对象区  工作区\u0026ndash;\u0026gt;暂存区\ngit add . 将当前目录的所有文件都进行提交 gir add xxx 指提交指定的文件  暂存区-\u0026gt;工作区\ngit rm --cached xxx git teset head xxx  暂存区\u0026ndash;\u0026gt;对象区\ngit commit -m \u0026quot;xxx\u0026quot; xxx为本次提交的注解  对象区\u0026ndash;\u0026gt;服务器\ngit push  对象区\u0026ndash;\u0026gt;工作区\n文件的内容被修改  撤销修改\n如果某个文件已提交，并且对其进行了修改。可以放弃修改（还原到已提交的状态）\ngit checkout -- xxx 放弃工作区中的修改  合并add 和commit：\ngit commit -am '注释' 第一次不能使用，以后可以使用  删除文件  git 删除\ngit rm xxx\n干了两件事情，将本地文件删除，操作命令\u0026ndash;》暂存区\n删除之后文件被放到暂存区,要想彻底删除好需要再提交一次\ngit commit -m \u0026quot;彻底删除\u0026quot;   后悔删除\n 暂存区恢复到工作区\ngit reset HEAD hello.txt  删除动作还原\ngit checkout -- hello.txt    操作系统删除\nrm xxx  删除本地文件\n操作状态在工作区\n  重命名文件 重命名文件涉及了两个文件，将原文件删除，创建新文件\ngit指令\ngit mv aa.txt bb.txt  在暂存区中\n操作系统指令\nmv aa.txt bb.txt  在工作区中\n注意：操作之后调用git status查看状态的提示\n注释重写 注释重写（重写提交说明）\ngit commit --amend -m '修正'  将上一次的提交注释进行重写\nGit的安装 \u0026emsp;网上关于Git的安装有很多的教程，这里就不详细记录了，基本就是一路下一步就可以了。\nGit的使用 Git官网新建仓库 加号\u0026ndash;\u0026gt;new repository\u0026ndash;\u0026gt;填写仓库名，描述\u0026ndash;\u0026gt;create\nGit项目初始化 git init  \u0026emsp;在本地新建一个文件夹，鼠标右键选择 Git Bash Here 输入指令git init 这样的话就将该文件夹纳入到了Git的管理。在本地文件夹会出现一个隐藏的目录.git目录,它是一个版本控制的目录。\n设置邮箱、用户名 \u0026emsp;当我们每次使用git push来将文件推到远程仓库的的时候，会发现每次都需要输入用户名和密码，为了解决它，可以给项目配置用户名，邮箱，这样每次push的时候就不需要再次输入用户名和密码，配置的方式分为三种，分别是：\n git config --global（基本不用）给整个计算机一次性设置  git config \u0026ndash;global user.name \u0026ldquo;mumulx\u0026rdquo;\ngit config \u0026ndash;global user.email \u0026ldquo;2606964863@qq.com\u0026rdquo;\n git config --system（推荐）给当前用户一次性设置\ncd ~ 切换到当前用户得系统文件夹 cat .gitconfig 查看给当前用户设置的用户名和密码 git config --system user.name 'mumulx' git config --system user.email '1819778796@qq.com'  git config --local给当前项目一次性设置\ncd .git/ cat config 查看项目得配置文件 git config --local user.name 'mumulx' git config --local user.email '1819778796@qq.com' git config --local --unset user.name git config --local --unset user.email 删除配置  删除配置\ngit config --local --unset user.name git config --local --unset user.email 删除配置   他们的优先级是3\u0026gt;2\u0026gt;1，也就是说会采用就近的原则进行设置，而且当修改了配置文件时只对修改之后的提交有效。修改之前的提交仍然使用的是之前的配置(用户名、邮箱)\n本地配置的邮箱与用户名并没有实际的意义，可以与远程仓库的用户名邮箱不一样，知识标识一下代码时谁写的。\ncommit的随机数 查看提交日志会发现commit后面又一串字符\ncommit eb125a18e9b9d7ffeb2e30236ce5fbe6d6d110ce  eb125a18e9b9d7ffeb2e30236ce5fbe6d6d110ce：sha1计算的结果\nsha1 、md5 加密算法 、随机数 ，用于区分 是哪一次的提交（并且不重复，理论上会重复，但是几率太小因此认为不会重复）\n忽略文件  创建忽略文件：.gitignore\ntouch .gitignore\n 编辑忽略文件\n  通配符 ：\n* 任意字符 *.properties !b.properties 除了 dir/：忽略dir目录中的所有文件 dir/*.txt dir/*/*.txt :能够忽略 dir/abc/a.txt，dir/xyz/a.txt ,不能 dir/xyz/123/a.txt dir/**/*.txt :任意级别目录 空目录：默认就是忽略的  分支 查看分支 git branch git branch -a git branch -av 创建分支 git branch 分支名 切换分支 git checkout 分支名 删除分支 git branch -d 分支名 (不能删除当前分支) 其他不能删除的情况： 包含 “未合并”的内容，删除分支之前 建议先合并 强行删除 git branch -D 分支名 创建新分支 并切换 ：git checkout -b 分支名 git checkout -b new_branch 合并分支 git merge 分支名 git merge new_branch 分支最近一次提交的shal值 git branch -v  细节：\n 如果在分支A中进行了写操作，但此操作局限在工作区中进行（没add commit）。在master中能够看到该操作。 如果分支A中进行了写操作 进行了commit（对象区），则master中无法观察到此文件\n 如果在分支A中进行了写操作，但此操作局限在工作区中进行（没add commit）。删除分支A 是可以成功的。\n  分支：一个commit链，一条工作记录线\n分支名(master) :指向当前的提交(commit)\nHEAD:指向当前分支（HEAD-\u0026gt;分支名）\n如果一个分支靠前(dev)，另一个落后(master)。则如果不冲突， master可以通过 merge 直接追赶上dev，称为 fast forward。\nfast forward本质就是 分支指针的移动.注意：跳过的中间commit，仍然会保存。\nfast forward：\n 两个分支 fast forward 归于一点commit 没有分支信息（丢失分支信息）  git在merge 时，默认使用fast fast forward ；也可以禁止 :\ngit merge --no-ff   两个分支 fast forward ，不会归于一点commit （主动合并的分支 会前进一步） 分支信息完整（不丢失分支信息）  合并：merge more采用ff.\n合并：如果冲突 ，需要解决冲突。\n解决冲突：\ngit add xxxx git commit -m \u0026quot;xx\u0026quot;  git add xxxx(告知git,冲突已解决)\n注意：master在merge时 如果遇到冲突 并解决，则解决冲突 会进行2次提交： 1次是最终提交，1次是将对方dev的提交信息commit也拿来了\n如果一方落后，另一方前进。则落后放可以直接通过merge合并到前进方，不会冲突。\n当两个分支处在同一个位置时，尝试合并分支会冲突。\n查看日志方法\ngit log --graph git log --graph --pretty=oneline --abbrev-commit  合并add 和commit：\ngit commit -am '注释'  版本穿梭： 在多个commit之间 进行穿梭。 回退、前进\n回退到上二次commit： git reset --hard HEAD^^ 回退到上n次commit： git reset --hard HEAD~n 跳转到任意一次commit: git reset --hard sha1值的前几位 通过sha1值 直接回退 ，需要结合git reflog使用。 git reflog：查看记录，记录所有操作。可以帮助我们 实现“后悔”操作。需要借助于 良好的 注释习惯  checkout的放弃与游离操作 checkout：放弃修改。放弃的是 工作区中的修改。 相对于暂存区或对象区\nreset: 将之前增加到暂存区中的内容 回退到工作区\ncheckout：\ngit checkout shal值  版本穿梭（游离状态）\n 修改后、必须提交 创建分支的好时机\ngit branch mybranch 2735603 创建分支 git chekcout master;切换分支   分支重命名：\ngit branch -m master master2  stash:保存现场  建议（规范） ：在功能未没有开发完毕前，不要commit\n 规定（必须） ： 在没有commit之前，不能chekcout切换分支 （不在同一个commit阶段）\n  如果还没有将某一个功能开发完毕 就要切换分支：建议 1. 保存现场（临时保存，stash）\n2. 切换\n保存现场：\ngit stash 名字随机产生 git stash save \u0026quot;mystash\u0026quot; 自定义名字  查看现场：\ngit stash list  还原现场(默认还原最近一次)：\ngit stash pop (将原来保存的删除， 用于还原内容) git stash apply (还原内容，不删除原保存的内容) git stash apply stash@{1} 指定某一次现场  保存的现场以栈的顺序存储，先进后出\n手工删除现场：\ngit stash drop stash@{0}  （了解即可） 如果不同的分支 在同一个commit阶段在，在commit之前，可以chekcout切换分支；操作的文件的记录是一致的\n当保存现场后忘记还原现场，而对文件进行了修改并am了可能会造成冲突，解决冲突的方法与上面一致\nTag标签 ：适用于整个项目，和具体的分支没关系 创建标签（在commit之后）\ngit tag v1.0 git tag -a xxx -m \u0026quot;xxxx\u0026quot;  查看标签\ngit tag git tag -l 'v1.0' 指定查询 git tag -l 'v*' 模糊查询  删除标签\ngit tag -d 标签名  blame：责任 git blame a.txt 查看a.txt的所有提交commit sha1值，以及每一行的作者  差异性diff linux 命令\ndiff a.txt b.txt 粗略信息，只显示哪些不一样的 diff -u a.txt b.txt 详细信息  @@ -4,4 +4,6 @@ 4:从第4行开始，6 比较6行\n-：原文件\n+：对比的文件\n无符号表示一样\ndiff：比较的是文件本身，源文件-那几行再+那几行就是b文件了\ngit 比较差异\n 暂存区 和工作区的差异\ngit diff  git diff ：比较的区中的文件\ngit diff :暂存区 和工作区的差异\n 工作区 和 某个对象区的差异\ngit diff commit的sha1值： 对象区和 工作区的差异 git diff head：最新 对象区和 工作区的差异  对象区和 暂存区的差异\ngit diff --cached commit的sha1值 : 对象区和 暂存区的差异 git diff --cached HEAD : 最新对象区和 暂存区的差异   push push:本地-\u0026gt;github pull:github-\u0026gt;本地 ， pull = fetch + merge rm -rf * ：当前目录中的文件、子文件目录全部删除（不会删除隐藏文件、不过回收站） .....rm ..... -rf / ......：不要执行，删除整个计算机中的全部文件  github的仓库中，默认的说明文档README.md\n推送：\ngit remote add origin https://github.com:mumulx/xiaochengxu.git  标识，将origin标识为 https://github.com:mumulx/xiaochengxu.git,使用关键字origin代表后面的一串\n(ssh)git remote add origin git@github.com:mumulx/xiaochengxu.git  标识，将origin标识为 git@github.com:mumulx/xiaochengxu.git\n(master) git push -u origin master  推送到master分支中 后续修改推送时 只需要\ngit push  ssh配置： 本地 私钥 ，远程github存放公钥\nssh-keygen 生成：私钥(本机) 公钥（github）  一路回车，生成的文件在当前用户的文件夹/.ssh文件夹中\nid_rsa 私钥 id_rsa_pub 公钥  可以将公钥 存放在github中的两个地方：\n 项目的setting中，只要当前项目可以和 本机 免秘钥登录 账号的settings中， 账户的所有项目 都可以和本机免秘钥  将公钥中的内容粘贴到github中\n注意：远程增加ssh的公钥时\n1. 删除回车符\n2. 可写权限\ngit remote show origin  显示远程仓库的信息\n分支\ndev:开发分支，频繁改变 test：基本开发完毕后，交给测试实施人员的分支 master：生产阶段，，很少变化 bugfix：临时修复bug分支  dev -\u0026gt; test (merge dev) -\u0026gt; master (merge test ) -\u0026gt; \u0026hellip;.\ngit remote show 查看当前的服务器列表 git remote show origin 查看具体的服务器信息  git会在本地维护 origin/master分支，通过该分支 感知远程github的内容\norigin/master一般建议 不要修改，是一个只读分支\n远程到本地\ngit clone git@github.com:mumulx/xiaochengxu.git 会将项目名也下载下载，项目名就是文件夹名 git clone git@github.com:mumulx/ mytest1 指定文件夹名  clone项目时将版本库也下载下来了，操作和原先的一摸一样\npull/push:推送，改变指针\nFast-forward ：更新， 如果发现 更新的内容 比自己先一步（commit 的sh1值 在自己之前），则 会自动合并\n冲突： 根据提示发现有\nfetch first git pull  着两个字段，而\npull = fetch + merge  有冲突：\n 解决冲突\npull =fetch + merge merge： vi 解决冲突 -\u0026gt; git add . -\u0026gt;commit   总结：\npull -\u0026gt; vi -\u0026gt; add -\u0026gt; commit -\u0026gt;push  pull =fetch + merge git pull git fetch 将远程文件拉到本地 git merge 合并和origin/master分支合并  冲突的原因时merge\n图形化工具 git gui ： gitk 、gui 、github desktop\ngitk 命令行输入\ngitk  gui 右键选择\ngit gui here  命令行\ngit gui  日志 本地日志 git log 查看本地日志  查看github分支的日志： git log origin/master git log remotes/origin/master git log refs/remotes/origin/master  分支：就是一个指針，commit的sha1值\n分支：  git branch -av 查看本地分支和本地的远程分支  分支分为： * 本地分支 * 远程分支 * 追踪分支（本地的远程分支）\n本地分支-\u0026gt;远程： 方法一：(本地在dev分支中)\ngit push -u origin dev  方法二：（在本地的test分支中）\ngit push --set-upstream origin test  远程-\u0026gt;本地  pull :远程-\u0026gt;追踪\ngit pull 将远程分支拉到本地的追踪分支  追踪-\u0026gt;本地\n方法一：\ngit checkout -b dev origin/dev 创建一个dev分支，并切换到dev分支，dev分支和origin/dev关联起来  方法二：\ngit checkout -b test --track origin/test git checkout --track origin/aaa   删除分支 删除本地分支\ngit branch -d 分支名  推送分支语法\ngit push origin src:dest  将本地的src分支推送到远端的dest分支\ngit push origin dev:dev2 git push origin HEAD:dev2  head：当前分支\n删除远端分支\ngit push origin :test git push origin --delete dev  git pull origin ccc2:ccc3  相当于 git pull + : git checkout -b dev origin/分支名\n本地没有a分支，但本地却感知远端的a分支。需要将a分支删除掉\n检测那些分支时不需要的：\ngit remote prune origin --dry-run  清理无效的 追踪分支（本地中感知的远程分支）\ngit remote prune origin  将远端分支 拉去到本地某个新分支 ： git fetch origin master:refs/remotes/orogin/helloworld  将远端的master分支拉到本地的helloworld追踪分支\n给命令起别名： git config --global alias.ch checkout  使用ch 将相当于使用了checkout指令\n标签 查看本机标签 git tag  创建本机标签 git tag v1.0 简单标签，只存储当前的commit的sha1值 git tag -a v2.0 -m \u0026quot;我的v.2.0版本\u0026quot; （创建一个新对象，会产生一个新的commit/sha1）存储信息，其中包含了当前的commit的sha1值  推送标签 git push origin v1.0 v2.0 推送指定的标签 git push origin --tags 推送本地所有标签 git push origin v1.0 完整 git push origin refs/tags/v1.0:refs/tags/v1.0  获取远程标签 git pull  如果远端新增标签，则pull 可以将新增的标签拉去到本地；如果远程是删除标签，则pull无法感知\ngit fetch orgin tag v4.0  删除远程标签 git push origin :refs/tags/v1.0  注意：如果将远程标签删除，其他用户无法直接感知，需要用户自己手工删除\ngit gc :压缩 git gc  objects、refs目录中记录了很多commit的sha1值，如果执行gc 则会将这么多sha1值 存放到一个 压缩文件中packed-refs\nrefs ：标签、head、remote\nobjects：对象 ,git 每一次version的全量内容\ngit裸库 创建裸库\ngit init --bare  没有工作区的 工作仓库 ，存在于服务端.不能add\nsubmodule ：子模块 应用场景 ：在一个仓库中 引用另一个仓库的代码。\n在github上如果新建项目，并且ssh连接 则必须配置ssh，如果给项目单独配置ssh则，一个密钥只能对应一个项目\n第一次：指定仓库地址、分支\ngit remote add origin xxx git push -u origin master  本地A仓库引用B仓库\ngit submodule add B仓库ssh地址  推到远程仓库\ngit add . git commit -m \u0026quot;xx\u0026quot; git push  A中有B库，但B push之后 A无法直接感知 ，需要主动操作：pull\n 进入A/B中pull\ncd B/ git pull  将B库更新到远程\ncd .. git add . git commit -m \u0026quot;xx\u0026quot; git push  直接在A中 迭代pull（将A中的所有submodule全部pull）：\ngit submodule foreach git pull  更新远程的submodule\ngit add . git commit -m \u0026quot;x\u0026quot; git push  注意：本地仓库直接使用git pull不会更新模块中的内容\n  如果clone的项目包含submodule,则clone方法 git clone sshxxxx --recursive  删除submodule  工作区\nrm -rf B rm -rf .gitmoudles  暂存区\ngit rm --cached B  对象区\n将删除后的\ngit add . git commit -m \u0026quot;\u0026quot;  远程\ngit push\n  建议：submodule 单向操作\nsubstree：双向、简单\nsubstree 加入子模块 git subtree  查看指令帮助\n 给子模块起别名\ngit remote add subtree-origin 子模块ssh地址  本地仓库引入子模块\ngit subtree add -P 本地项目名 模块地址 模块分支 git subtree add -P subtree subtree-origin master  等价\ngit subtree add --prefix subtree subtree-origin master  另一种方式\ngit subtree add -P subtree2 subtree-origin master --squash  \u0026ndash;squash：合并commit,为了防止 子工程干扰父工程\nsquash：减少commit的次数,会将提交封装起来\n加了squash之后：\n 会产生新的提交(很容易冲突)\n 往前走两步commit  \u0026ndash;结论： 在做subtree\n如果加squash，以后每次都加 （git subtree开头的命令，要么都加 要么都不加）\n如果不加，都不要加\n-如果是同一个祖先，则可能不会冲突\n-如果不是同一个祖先，很可能冲突\n在subtree submodule容易冲突（有2个跟解决） -\u0026gt; vi add commit push\n  推送远程 git push  本地更新子模块 git 子模块文件夹名 pull -P subtree 子模块ssh地址 分支名 git suntree pull subtree subtree-origin master  本地更新远程模块 git push  核心流程：\n子-\u0026gt;父中子 有反应\n 修改子工程 push\n 将github中的子工程更新到 父中子模块（本地）\ngit subtree pull -P subtree subtree-origin master  父中子模块 的更新情况 推送到 对应的github上（父-子）\n  修改 父工程中子模块-\u0026gt;子模块 如何将 本地修改的内容（父-子） 推送到 远程中真实的子模块中：\ncd 子模块 进行修改 git add . git commit -m \u0026quot;xx\u0026quot; git push 更新父工程远程的子模块文件 cd .. 进入父工程 git 本地模块文件夹名 push -P subtree subtree-origin master 更新对应子模块远程仓库 git subtree push -P subtree subtree-origin master  冲突 冲突：修改同一文件的同一行、不是同一祖先、不规范\ncherry-pick 如果写了一半(已经提交)，发现写错分支，需要将已提交的commit转移 分支\n每次只能转移（复制）一个commit ，内容会被复制，但是sha1会变\n在想要转移到的分支中\ngit cherry-pick shal值  在转移的分支中删除提交\ngit checkout shal值 git branch -D dev 删除分支 git checkout -b dev 创建分支  思路： cherry-pick 复制到应该编写的分支上；\n把写错分支删除（checkout 旧节点，删除分支）；\n新建分支\ncherry-pick 在复制的时候，不要跨commit节点复制\nrebase:变基（衍合） 改变分支的根基\ngit rebase 转移的分支名  rebase会改变提交历史\nrebase之后的提交线路 是一条直线\nshal值会改变\n编写代码的地方\n如果B转到A ；\n cherry-pick:在A中操作\n rebase:在B中操作\n  rebase也会冲突：\n 解决冲突\nvi ... add . 告知程序已解决 git rebase --continue 继续trbase  忽略冲突（放弃rebase所在分支的修改，直接使用其他分支）\ngit rebase --skip  终止,还原成rebase之前的场景\ngit rebase --abort   建议：\n reabase分支 只在本机操作，不要推送github\n 不要在master上直接rebase\n  rebase到的分支的头节点不会前进，因此可以merge两个分支\u0026ndash;fast-forward\nIDEA使用gradle整合gretty进行web开发 git - gradle\njar :maven\ngradle -\u0026gt;Maven\n下载、解压缩\ngradle官网\n下载地址\ngradle -\u0026gt;maven\ngradle实际是在maven仓库中获取 jar，因此引用jar包时去maven中搜索\nbuild.gradle\u0026mdash;pom.xml\n配置 配置jdk cmd开发 GRADLE_HOME：gradle安装目录 GRADLE_USER_HOME 本地仓库（本地存放JAR的目录） PATH：%GRADLE_HOME%\\bin  idea开发 (本地仓库)额外 idea:settings-gradle ：Service directory path  idea新建gradle项目 File--\u0026gt;new-\u0026gt;Gradle 勾选web-\u0026gt;设置坐标--\u0026gt;勾选Use auto-import自动导入  下载的jar包在resp/caches/modules-2/files-2.1中\nbuild.gradle配置 apply plugin : 'java' apply plugin : 'war' apply plugin : 'idea' apply plugin : 'maven' apply plugin : 'org.akhikhl.gretty' buildscript { repositories { mavenCentral() } dependencies { classpath 'org.akhikhl.gretty:gretty:2.0.0' } } repositories { mavenCentral() } //私服 //dependencies{ //repositories { // maven{ // url:xxx // } //} //} if (!project.plugins.findPlugin(org.akhikhl.gretty.GrettyPlugin)) project.apply(plugin: org.akhikhl.gretty.GrettyPlugin) gretty { httpPort=8080 contextPath = '/MyGradlePro' host=\u0026quot;localhost\u0026quot; httpEnabled = true servletContainer = \u0026quot;tomcat8\u0026quot; scanInterval = 1 fastReload = true loggingLevel = \u0026quot;DEBUG\u0026quot; consoleLogEnabled = true debugPort = 8887 debugSuspend = true } //sourceSets { // main{ // java{ // srcDir 'src/main/nn' // } // resources{ // srcDir 'src/main/yy' // } // // } //} //plugins { // id 'java' // id 'war' //} group 'com.mumu.gradle' version '1.0-SNAPSHOT' sourceCompatibility = 1.8 targetCompatibility = 1.8 repositories { mavenCentral() } dependencies { testCompile group: 'junit', name: 'junit', version: '4.12' compile group: 'org.mybatis', name: 'mybatis', version: '3.4.6' } tasks.withType(JavaCompile){ options.encoding = \u0026quot;UTF-8\u0026quot; } [compileJava,javadoc,compileTestJava]*.options*.encoding = \u0026quot;UTF-8\u0026quot;  IDEA右侧有Gradle的工具箱\nweb服务器 gradle或maven中 可以通过编码配置 产生web服务器环境\ngradle:gretty\ngretty -》tomcat\ngretty教程\napply plugin: 'war' apply plugin : 'org.akhikhl.gretty' buildscript { repositories { mavenCentral() } dependencies { classpath 'org.akhikhl.gretty:gretty:2.0.0' } } repositories { mavenCentral() } if (!project.plugins.findPlugin(org.akhikhl.gretty.GrettyPlugin)) project.apply(plugin: org.akhikhl.gretty.GrettyPlugin) gretty { httpPort=8080 contextPath = '/MyGradlePro' host=\u0026quot;localhost\u0026quot; httpEnabled = true servletContainer = \u0026quot;tomcat8\u0026quot; scanInterval = 1 fastReload = true loggingLevel = \u0026quot;DEBUG\u0026quot; consoleLogEnabled = true debugPort = 8887 debugSuspend = true }  编码\n//编码 tasks.withType(JavaCompile){ options.encoding = \u0026quot;UTF-8\u0026quot; } [compileJava,javadoc,compileTestJava]*.options*.encoding = \u0026quot;UTF-8\u0026quot;  执行 加前缀gradle xxx appRun 运行 appRunDebug 调试 --结束： 按任意键 appStart appStartDebug --结束：appStop  idea右侧gradle子目录gretty有诸多命令\n运行：\ngradle appRun 、gradle appStart -》直接访问  调试： 1. 配置\n debugPort = 8888 （5005） debugSuspend = true   启动\ngradle appRunDebug/gradle appStartDebug  监听服务\n配置run-- Configuration - Remote name随便取 host：localhost port：8887  启动调试，idea的debug按钮\n 访问\n访问8080\n  新建servlet 右键\u0026ndash; new\u0026ndash;Create new Servlet\n自动生成的文件\n@WebServlet(name = \u0026quot;MyServlet\u0026quot;) 改成 @WebServlet(urlPatterns = \u0026quot;/MyServlet\u0026quot;)  web.xml注意\nmetadata-complete=\u0026quot;false\u0026quot;\u0026gt;，应为false  源码\npackage org.mumu.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(urlPatterns = \u0026quot;/MyServlet\u0026quot;) public class MyServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\u0026quot;do post\u0026quot;); int a =10; int b=9; a=a+b; System.out.println(a); System.out.println(b); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } }  在idea中使用git托管项目（版本控制） 将idea中默认的cmd更换 bash.exe 重启\nfile--\u0026gt;setting--\u0026gt;Terminal--\u0026gt;设置Shell path路径为git安装目录/bin/bash.exe  创建忽略文件\n.gitignore\nbuild out .gradle .idea  初始化\ngit init git add . git commit -m \u0026quot;xxxx\u0026quot; git remote add origin xxxx git push origin master  项目地址\n本地更新idea git pull  clone项目到本地 file \u0026ndash;\u0026gt; new\u0026ndash;\u0026gt;Project from Version Control \u0026ndash;\u0026gt;Git\n复制远程的地址\n构建项目 （gradle项目）\ngradle build  菜单栏VCS中也有Git的操作指令，快捷键\n右键文件也有Git的快捷键\n右键项目也有\n解决冲突图形化界面\n右键\u0026ndash;\u0026gt;git\u0026ndash;\u0026gt;resolve Conficts\u0026hellip;.\nGitLab 下载 gitlab-ce-12.7.2-ce.0.el7.x86_64.rpm\n下载地址\ngitlab ee（收费）\ngitlab ce\n安装说明\nyum install -y curl policycoreutils-python openssh-server systemctl enable sshd systemctl start sshd systemctl start firewalld firewall-cmd --permanent --add-service=http firewall-cmd --permanent --add-service=https systemctl reload firewalld  yum install postfix systemctl enable postfix systemctl start postfix EXTERNAL_URL=\u0026quot;https://192.168.2.150\u0026quot;  将下载的文件传到linux中\nrpm -ivh gitlab-ce-12.7.2-ce.0.el7.x86_64.rpm gitlab-ctl reconfigure  等待时间较长，会一致出现action run，不用理它，耐心等待\n启动\ngitlab-ctl start  关闭\ngitlab-ctl stop  访问 可以先关闭防火墙\nsystemctl stop firewalld  访问\n centos7init 192.168.2.150  用户名\nroot  设置密码\nrootroot  登录\n创建组，创建项目\n之前EXTERNAL_URL=\u0026quot;https://192.168.2.150\u0026quot;忘记设置\n补救\n","id":19,"section":"posts","summary":"Git简介 git lab指令 启动 gitlab-ctl start 关闭 gitlab-ctl stop 关闭防火墙 systemctl stop firewalld 开启防火墙 systemctl start firewalld Git指令 git init 项目初始化 git status 查看当前状态 git log 查看日志 git log -2 查看最近两次","tags":["版本控制"],"title":"Git自学笔记","uri":"https://mumulx.github.io/2019/11/git%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" 简介 Query是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等。\n下载 JQuery官网\nmin.js：压缩版 发布版\n.js:常规版 开发板\n开始使用 $(document).ready(function(){}): 初始化函数， 当网页中的dom元素(不包含图片、视频、资源)全部加载完毕后立刻执行\nonload:javascript,初始化函数，当网页中的dom元素(关联图片、视频、资源)全部加载完毕后立刻执行\njquery初始化函数简化:\n$ (function() {...}) ;  $ 等价于jQuery\ndom模型: 将html xml 等文档结构的标签语言看成dom模型\ndom节点有三种类型:\n 元素节点\u0026lt;html\u0026gt; \u0026lt;ul\u0026gt;... \u0026lt;p\u0026gt;\n 属性节点: title Src alt\n 文本节点:文本节点\n  Dom对象: 以上三种节点类型的具体对象就是Dom对象。\n使用层面: 凡是JavaSCript 能够直接操作的对象，就是Dom对象。\n例如，var title = document. getElementById(' myTitile\u0026quot;) ;通过js获取到的title对象就是一个dom 对象(就是\u0026lt;p\u0026gt;对象)\njQuery对象: 凡是jQuery能够直接操作的对象，就是jQuery对象。\n例如: var $title = $(\u0026quot; #myTitile\u0026quot;) ;通过jquery获取到的$title就是一个jquery对象。\n同样一个元素，既可以成为个dom对象 (javascript对象) ，也可以成为一个jquery对象\n注意: dom对象只适用于js的各种语法(函数、属性)，jquery对 象只用于jquery的各种语法(函数、属性)。dom对象和jquery对象的各自独立。\n例如\n title是dom对象，因此可以使用js属性或方法title. innerHTML\n $title是jquery对象，因此可以使用jquery属性或方法$title.html ()\n  建议:\n js对象 直接写title jQuery对象加上$title  dom对象和jQuery对象的转换\n title.innerHTML: title-\u0026gt;$title $title.html(): $title-\u0026gt;title  dom-jQuery:jquery工厂，$(dom对象).jQuery方法\njQuery-Dom:  基础：jquery对象默认是一个数组或集合；dom对象默认是一个单独对象 数组：jQuery对象[0]； jQuery对象(含有$) 集合：jQuery对象.get(0);  jQuery选择器：jQuery根基 分类：  基本选择器：\n标签选择器： $(\u0026quot;标签名\u0026quot;) 类选择器： $(\u0026quot;.class值\u0026quot;) id选择器: $(\u0026quot;#id值\u0026quot;) 全局选择器： $(\u0026quot;*\u0026quot;) 并集选择器:\u0026quot;,\u0026quot; $(\u0026quot;#id值,.class值\u0026quot;) 交集选择器（同时存在）：直接写$(\u0026quot;p.class值\u0026quot;) 无需\u0026quot;,\u0026quot; 既是p标签的值又是clss的值 错误$(\u0026quot;.class值p\u0026quot;) 交集选择器在交接处只能是.或#  层次选择器: 只取后面的那个\n相邻选择器 + $(\u0026quot;#b+li\u0026quot;) id为b的相邻的标签为li的元素 $(\u0026quot;选择器1+选择器2\u0026quot;) 同辈选择器 ~ $(\u0026quot;选择器1~选择器2\u0026quot;) 后代选择器： 空格 $(\u0026quot;选择器1 选择器2\u0026quot;) 子代选择器： \u0026gt; $(\u0026quot;选择器1\u0026gt;选择器2\u0026quot;)  属性选择器 [\u0026hellip;.]\n$(\u0026quot;[属性名]\u0026quot;) $(\u0026quot;[name]\u0026quot;) 选中全部元素中含有name属性的元素 $(\u0026quot;[属性名=属性值]\u0026quot;) $(\u0026quot;[class=xxx\u0026quot;) 等价 $(\u0026quot;[class='xxx']\u0026quot;) $(\u0026quot;[属性名^=a]\u0026quot;) 属性名以a开头的元素 $(\u0026quot;[属性名$=a]\u0026quot;) 属性名含有a的元素 判断属性值的操作 $(\u0026quot;[属性名*=a]\u0026quot;) 属性名以a开头的元素 $(\u0026quot;[属性名!=a]\u0026quot;) 属性名不等于a开头的元素 有属性名但属性值不等于属性值 没有属性名  过滤选择器 \u0026ldquo;:\u0026rdquo; 和其他的一些方法类似\n first() last() 有些不行 :odd 基本过滤选择器 从0开始 0是偶数 :first 最开头的那一个 :last-child 最后哪一个 :even 偶数 :odd 奇数 :eq(index) 第index个 jQuery对象是一个数组0 1 2 3 :gt(index) \u0026gt;index的全部元 index就相当于下标 :lt(index) \u0026lt;index的全部元素 :not(index) 除了index以外的全部 :header: 选中所有的标题元素 h1 h2 h3 :focus: 中当前焦点的元素  例\n$(\u0026quot;ul\u0026gt;li:first\u0026quot;).length $(\u0026quot;ul\u0026gt;li\u0026quot;).first().length 对象.过滤器(); 对象:first  有些是可以通用的\n注意\n $(\u0026quot;ul\u0026gt;li:odd\u0026quot;)[0].html() 是错误的  原因：\n$(\u0026quot;ul\u0026gt;li:odd\u0026quot;)[0]是dom对象 不能使用jQuery方法  解决办法\n$($(\u0026quot;ul\u0026gt;li:odd\u0026quot;)[0]).html() 将dom对象转换为jQuery对象  可见性选择器\n:visible:选中所有可见的元素 :hidden:选中所有隐藏的元素   通过css()来设置样式\n$(\u0026quot;input:focus\u0026quot;).css $(\u0026quot;:header\u0026quot;).css(\u0026quot;key\u0026quot;,\u0026quot;value\u0026quot;); background red;  事件  js:on~ onclick() 写在script内 ready()外\n jQuery:没有on click() 写在ready()内\n  语法：\n$(选择器).事件类型(function (){ });  windows事件: ready();  鼠标事件： click（）:点击事件 mouseover():鼠标悬浮 mouseout():鼠标离开  jQuery执行完毕后返回对象本身\n因此\n$(\u0026quot;div\u0026quot;).mouseover(function(){ alert(\u0026quot;111\u0026quot;); }); $(\u0026quot;div\u0026quot;).mouseout(function(){ alert(\u0026quot;2222\u0026quot;); });  等价于 链式写法\n$(\u0026quot;div\u0026quot;).mouseover(function(){ alert(\u0026quot;111\u0026quot;); }).mouseout(function(){ alert(\u0026quot;2222\u0026quot;); });  键盘事件 event.keyCode拿到键码值\nkeydown(): 从上往下压过程 keypress(): 压到底了 keyup(): 从下往上  注意：前端的一些事件、方法会在某些情况下失效。考虑兼容性。\n表单事件  focus(方法):获取焦点 blur(方法):失去焦点  注意：\n 当颜色两两相同时六位十六进制的颜色可以写成3位\n 可以使用this代表当前对象 但是this是dom对象因此 需要转换为jQuery对象$(this)\n  绑定事件和移除事件 $(...).bind(事件类型,[数据],函数); 数据可选参数 $(...).bind(\u0026quot;click\u0026quot;,function(){ });  批量绑定  $(...).bind({\u0026quot;事件名\u0026quot;：函数，\u0026quot;事件名\u0026quot;：函数})  移除事件： $(...).unbind(事件类型,[数据],函数);数据可选参数 $(...).unbind(\u0026quot;click\u0026quot;);  复合事件： hover(f1,f2); 切换使用 mouseover mouseout toggle(f1,f2,f3,.....fn): 具有版本问题（只支持1.9之前的） 轮回执行多个click()事件 toggle()其他含义（隐藏和显示）  显示效果（隐藏与显示） hide([速度],[回调函数])：隐藏 hide()：立刻隐藏 hide(3000)三秒隐藏 show()：显示 toggle()：两者切换  注意\n 回调函数（callBack） 当函数执行完毕后 在执行回调函数\n 速度：毫秒 或者关键字\u0026rdquo;fast\u0026rdquo; \u0026ldquo;slow\u0026rdquo; \u0026ldquo;normal\u0026rdquo;\n  淡入淡出：改变透明度来隐藏 fadeIn():淡入 显示 fadeOut():淡出 隐藏  控制高度 slideDown():变大 下拉 slideUp()：变小 上拉  总结显示问题 显示：show(),fadeIn(),slideDown() 隐藏：hide(),fadeOut(),slideUp()  操作Dom： 样式操作 设置css jQuery对象.css(\u0026quot;属性名\u0026quot;,\u0026quot;属性值\u0026quot;)操作一个、 jQuery对象.css({\u0026quot;属性名\u0026quot;:\u0026quot;属性值\u0026quot;,\u0026quot;属性名\u0026quot;:\u0026quot;属性值\u0026quot;,\u0026quot;属性名\u0026quot;:\u0026quot;属性值\u0026quot;})操作多个  追加或移除样式class addClass(\u0026quot;x\u0026quot;) 一个 addClass(\u0026quot;x x x\u0026quot;) 多个以空格隔开 一组双引号 removeClass(\u0026quot;x\u0026quot;); 移除一个 removeClass(\u0026quot;x x\u0026quot;); 移除多个 removeClass()： 移除全部样式 toggleClass(); 切换追加与移除  内容操作  对象.方法 html(): 获取值，获取的是元素的内容 包括元素内部的各种标签 html(zxzz) 赋值 text(): 获取值，只获取文本值 text(xxxx) 赋值 val(): 获取value值 val(xxxx): 设置value值  节点与属性的操作 节点操作 查询节点： jquery选择器  创建节点：$() $(选择器)： 获取节点 $(DOM对象): 转换 $(html字符串) 创建节点$(\u0026quot;\u0026lt;li\u0026gt;xxxx\u0026lt;/li\u0026gt;\u0026quot;)  内部插入 先创建 var $aaaa = $(\u0026quot;\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;\u0026quot;); $(A).append(B) 将B追加到A中 后面 如: $(\u0026quot;\u0026quot;).append($aaaa); $(A).appendTo(B) 把A追加到B中 如: $aaaa.appendTo(\u0026quot;\u0026quot;); $(A). prepend (B) 将B前置插入到A中 前面 如: $(\u0026quot;\u0026quot;). prepend ($node); $(A). prependTo(B) 将A前置插入到B中 如: $ node.prependTo (\u0026quot;ul!\u0026quot;);  外部插入 $(A).after(B) 将B插入到A之后 如: $(\u0026quot;u\u0026quot;).after(Snode); S(A).insertAfter(B) 将A插入到B之后 如: $ node.insertAfer(\u0026quot;l\u0026quot;); $(A).before(B) 将B插入至A之前 如: $(\u0026quot;u\u0026quot;).before(Snode); S(A).insertBefore(B) 将 A插入到B之前 如: $ node.insertBefore(\u0026quot;ul\u0026quot;);  替换节点 $x.replaceWith(b) 用b替换a $b.replaceAll(x) 用b体寒a  删除节点 remove(): 彻底删除 deatch()： 只将节点删除 但关联的事件 数据不会删除（不推荐删除） empty()： 只删除内容  克隆节点 clone(true|false); 连事件 是否克隆  属性操作 attr(\u0026quot;属性名\u0026quot;)： 获取属性值 attr(\u0026quot;属性名\u0026quot;,\u0026quot;属性值\u0026quot;)： 设置属性值 attr({\u0026quot;属性名\u0026quot;：\u0026quot;属性值\u0026quot;,\u0026quot;属性名\u0026quot;：\u0026quot;属性值\u0026quot;,}) 设置多个值 removeAttr(\u0026quot;属性名\u0026quot;); 删除 val(): 获取value值 val(xxxx): 设置value值  获取集合与遍历 $(\u0026quot;\u0026quot;) 本身就是一个集合  节点集合 $(...).childern(\u0026quot;标签\u0026quot;) 标签为空 则选择所有节点  后代集合 不推荐 $(...).find(\u0026quot;标签\u0026quot;);  这种也可以\n后代选择器：空格 $(\u0026quot;选择器1 选择器2\u0026quot;) 子代选择器：\u0026gt; $(\u0026quot;选择器1\u0026gt;选择器2\u0026quot;)  同辈集合 ()里面可以加标签 next() : 后一个 + prev(): 前一个 无 siblings()： 同辈 都有 不包含自己  前辈集合 ()里面可以加标签 parent(): 父代 parents(): 祖先节点  过滤集合 很多方法的()就是一个过滤选择器 filter(\u0026quot;选择器\u0026quot;)  遍历集合 $(....).each(function(){ }); $(....).each(function(index,element){ });   index:当前第几个元素\n element：当前的元素是谁 相当与this但是this和element都是dom对象 需要转换为jQuery对象$(this) $(element)\n  CSS-dom操作： （）取 值 (xxxx)设置值xxxx是数字 不要加px\nheight() 高 width() 宽 offset() 偏移量（左上角） 结果是一个对象 .left .top  例\noffset(function(index,oldOffset){//通过方法来赋值 //定义对象 var newOffset = new Object(); //赋值 newOffset.left = oldOffset.left+100; newOffset.top=oldOffset.top+100; //返回结果 return newOffsetp; })   index；第几个 oldOffset；当前元素\n offsetParent()：获取已定位的最近的父元素 结果是节点而不是位置\n  定位： 元素的position的属性(默认为static)被设置为relative(相对) absolute（绝对）或dixed\nscrollLet() 滚动条 scrollTop ()  表单校验 可以减轻对服务端的访问次数\n 获取要校验的元素值(选择器)\n 通过 字符串处理方法、或者 正则表达式等手段进行验证\n 触发校验的方法或事件\nblur():失去焦点时触发 submit():当点击表单的提交按键时  js方法\nonblur=\u0026quot;xxxx()\u0026quot; onsubmit=\u0026quot;xxxx()\u0026quot;   正则表达式：用于定义规则 /.../ 一个 规则的开始和结束 ^ 匹配字 符串的开始 $ 匹配字符串的结束 [] 定义一个匹配的字符范围，如[0-9a-z]表示 该字符取值的范围是数字或小写字母 \\s 任何空白字符 \\S 任何非空白字符 \\d 匹配一个数字字符，等价于[0-9] \\D 除了数字之外的任何字符，等价于[^0-9] ^ 非 除了 \\w 匹配一个数字、下划线或字母字符，等价于[A-Za-z0-9_ ] 或直接写 范围- \\W 任何非单字字符，等价于[^a-ZA-Z0-9_ ] . 除了换行符之外的任意字符 {n} 匹配前一项n次 {n,} 匹配前项n次或n次以上 {n,m} 匹配前一项至少n次，至多m次 * 匹配前一项0 次或多次，等价于{0,} + 匹配前一项1次或多次，等价于{1,} ? 匹配前一项0次或1次，也就是说前一项是可选的，等价于{0,1}  实例\n$(\u0026quot;#utel\u0026quot;) .blur ( function() { var $tel = $(this) . val () ; var reg= /^1\\d{10}$/ ; if(! (reg. test ($tel))) { if($tel=\u0026quot;\u0026quot;||$tel. length==0) { $(\u0026quot;#telTip\u0026quot;) .css (\u0026quot;display\u0026quot;,\u0026quot;none \u0026quot;); }else{ $(\u0026quot;#telTip\u0026quot;) .css (\u0026quot;display\u0026quot;,\u0026quot;inline\u0026quot;) ;//inline不换行 block回车换行 } }else{ $(\u0026quot;#telTip\u0026quot;) .css (\u0026quot;display\u0026quot;,\u0026quot;none \u0026quot;); } }) ; $ (\u0026quot;#uemail\u0026quot;) .blur(function() { var $email = $ (this) . val () ; var reg = /^\\w+@[0-9a-zA-Z]{2,4}\\.[a-zA-Z]{2,3}([a-zA-Z] {2,3})?$/; if( ! reg. test ($email) ) if($email=\u0026quot;\u0026quot;||$email. length==0) { $ (\u0026quot; #emailTip\u0026quot;) .css (\u0026quot;emailTip\u0026quot; , \u0026quot;none\u0026quot;); }else{ $(\u0026quot;#telTip\u0026quot;) .css (\u0026quot;display\u0026quot;, \u0026quot;inline\u0026quot;) ; } }else{ $ (\u0026quot; #emailTip\u0026quot;) .css (\u0026quot;emailTip\u0026quot; , \u0026quot;none\u0026quot;); } }) ;  表单选择器（过滤选择器） :input 匹配所有input、textarea select和button元素 $(\u0026quot; #myfom :input\u0026quot;)选 取所有的input、select、 button元素 :text 匹配所有单行文本框 $(\u0026quot;#myfom :text\u0026quot; )选取所有的\u0026lt;input type=\u0026quot; text\u0026quot;/\u0026gt;元素 :password 匹配所有密码框 $(\u0026quot; #myform :password\u0026quot; )选取所有\u0026lt;inputtype=\u0026quot;password\u0026quot; /\u0026gt;元素 :radio 匹配所有单项按钮 $(\u0026quot; #myfom :radio\u0026quot;)选 取所有\u0026lt;input type=\u0026quot;radio\u0026quot;/\u0026gt;元素 :checkbox 匹配所有复选框 $(\u0026quot; #myform:checkbox”)选取\u0026lt;input type=\u0026quot;checkbox”/\u0026gt;元素 :submit 匹配所有提交按钮 $(\u0026quot; tmyfom :submit ”)选取\u0026lt;input type=\u0026quot;submit”/\u0026gt;元素 :image 匹配所有图像 S$(\u0026quot;#myform :image\u0026quot; )选取\u0026lt;input type=\u0026quot; image\u0026quot; /\u0026gt; 元素 :reset 匹配所有重置按钮 $(\u0026quot; #myform:reset”)选取\u0026lt;input type=\u0026quot; reset”/\u0026gt;元素 :button 匹配所有按钮 $(\u0026quot; #myfom :button\u0026quot; )选取button元素 :file 匹配所有文件域 $(\u0026quot; #myform :file\u0026quot; )选取\u0026lt;input type=\u0026quot; file”1\u0026gt;元素 :hidden 匹配所有不可见元素 $(\u0026quot; tmyform :hidden\u0026quot; )选取\u0026lt;input type=\u0026quot;hidden”/\u0026gt;、style=\u0026quot;display: none\u0026quot;等元素  函数 对象.stop(true,true).事件;立即执行该事件.\n","id":20,"section":"posts","summary":"简介 Query是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScr","tags":["前端框架"],"title":"JQuery自学笔记","uri":"https://mumulx.github.io/2019/11/jquery%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" 源码\nJSP:动态网页 静态、动态：\n 不用 和 是否有“动感”混为一谈\n 是否随着时间、地点、用户操作的改变而改变  动态网页需要使用到服务端脚本语言（JSP）\n架构 CS：Client Server CS不足：\n 如果 软件升级， 那么全部软件都需要升级 维护麻烦：需要维护每一台 客户端软件 每一台客户端 都需要安装 客户端软件  BS ：Broswer Server 客户端可以通过 浏览器 直接访问服务端\n注意：bs和cs各有优势。\ntomcat解压后目录： bin:可执行文件（startup.bat shutdown.bat） conf:配置文件（server.xml） lib：tomcat依赖的jar文件 log:日志文件（记录出错等信息） temp:临时文件 webapps：可执行的项目（将我们开发的项目 放入该目录） work:存放由jsp翻译成的java,以及编辑成的class文件(jsp -\u0026gt;java -\u0026gt;class)  配置tomcat  配置jdk (必须配置JAVA_HOME)\njava_home classPath path  配置catalina_home\n双击bin/startup.bat启动tomacat，\n常见错误： 可能与其他服务的端口号冲突 tomcat端口号默认8080 （此端口号较为常见，容易冲突），建议修改此端口 （8888）\n  修改端口号： 修改tomcat根目录/conf/server.xml大概70行左右\n\u0026lt;Connector connectionTimeout=\u0026quot;20000\u0026quot; port=\u0026quot;8080\u0026quot; protocol=\u0026quot;HTTP/1.1\u0026quot; redirectPort=\u0026quot;8443\u0026quot;/\u0026gt;  访问tomcat http://localhost:8888/  默认访问项目是webapp/ROOT\n常见状态码：\n200：一切正常 300/301: 页面重定向 （跳转） 404:资源不存在 403：权限不足 （如果访问a目录，但是a目录设置 不可见） 500：服务器内部错误（代码有误） 其他编码：积累  jsp：在html中嵌套的java代码\n在项目/WEB-INF/web.xml中设置 默认的 初始页面\n \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;index.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt;  tomcat项目必须有的两个/WEB-INF/web.xml目录和文件\n虚拟路径 将web项目配置到 webapps以外的目录\n方式一 conf/server.xml中配置 host标签中新增：\n\u0026lt;Context docBase=\u0026quot;D:\\study\\JspProject\u0026quot; path=\u0026quot;/JspProject\u0026quot;/\u0026gt;  docBase：实际路径\npath：虚拟路径 （绝对路径、相对路径【相对于webapps】）\n重启\n访问path实际访问的是docBase\n方式二 apache-tomcat-8.5.30\\conf\\Catalina\\localhost 中新建 “项目名.xml”中新增一行：\n\u0026lt;Context docBase=\u0026quot;D:\\study\\JspProject\u0026quot; path=\u0026quot;/JspProject\u0026quot; /\u0026gt;  虚拟主机 通过www.test.com访问本机\n conf/server.xml\n\u0026lt;Engine name=\u0026quot;Catalina\u0026quot; defaultHost=\u0026quot;www.test.com\u0026quot;\u0026gt; \u0026lt;Host appBase=\u0026quot;D:\\study\\JspProject\u0026quot; name=\u0026quot;www.test.com\u0026quot;\u0026gt; \u0026lt;Context docBase=\u0026quot;D:\\study\\JspProject\u0026quot; path=\u0026quot;/\u0026quot;/\u0026gt; \u0026lt;/Host\u0026gt;  C:\\Windows\\System32\\drivers\\etc\\host\n增加\n127.0.0.1 www.test.com   流程：\nwww.test.com-\u0026gt; host找映射关系 -\u0026gt;server.xml找Engine的defaultHost -\u0026gt;通过\u0026rdquo;/\u0026ldquo;映射到D:\\study\\JspProject\n项目默认的端口号是：80\nJSP执行流程 jsp- java(Servlet文件) -class D:\\study\\apache-tomcat-8.5.30\\work\\Catalina\\localhost\\JspProject\\org\\apache\\jsp\nJsp 和Servlet 可以相互转换\n因为第一请求服务端 会有翻译 和编译的过程，因此比较慢； 后续访问 可以直接访问class,因此速度较快。但是 如果 服务端修改了代码，则再次访问时 会重新的翻译、编译。\n使用Eclipse开发Web项目(JSP项目) tomcat 配置tomcat windows-\u0026gt;preferences\u0026ndash;\u0026gt;server\u0026ndash;\u0026gt;run time 添加tomcat与jdk\n在Eclipse中创建的Web项目： File\u0026ndash;\u0026gt;new \u0026ndash;\u0026gt;Dynamic Web Project\n浏览器可以直接访问 WebContent中的文件，\n例如http://localhost:8888/MyJspProject/index1.jsp\n其中的index1.jsp就在WebContent目录中；\n但是WEB-INF中的文件 无法通过客户端（浏览器）直接访问，只能通过请求转发来访问\n注意：并不是 任何的内部跳转都能访问WEB-INF；原因是 跳转有2种方式：请求转发 、重定向\n配置tomcat运行时环境 jsp\u0026lt;-\u0026gt;Servlet两种方法 1. 将tomcat/lib中的servlet-api.jar加入项目的构建路径 1. 右键项目-\u0026gt;Build Path -\u0026gt; Add library -\u0026gt;Server Runtime\n部署tomcat 在servers面板 新建一个 tomcat实例 ， 再在该实例中 部署项目（右键-add）\n之后运行\n注意：一般建议 将eclipse中的tomcat与 本地tomcat的配置信息保持一致： 将eclipse中的tomcat设置为托管模式：【第一次】创建tomcat实例之后， 双击，选择Server Location的第二项\n统一字符集编码 编码分类：\n设置jsp文件的编码（jsp文件中的pageEncoding属性）： jsp -\u0026gt; java\n设置浏览器读取jsp文件的编码（jsp文件中content属性）\n一般将上述设置成 一致的编码，推荐使用UTF-8\n文本编码：三种方式\n 将整个eclipse中的文件 统一设置 （推荐）\n 设置 某一个项目\n 设置单独文件\n  JSP的页面元素 HTML java代码（脚本Scriptlet）、指令、注释\n脚本Scriptlet \u0026lt;% 局部变量、java语句 %\u0026gt;  \u0026lt;%! 全局变量、定义方法 %\u0026gt;  \u0026lt;%=输出表达式 %\u0026gt;  \u0026lt;%! public String bookName ;//全局变量java注释 public void init() /*java注释 */ { Date date = new Date(); bookName = \u0026quot;java书\u0026quot;+date ; } %\u0026gt; ====hello index1 你好...==== \u0026lt;% String name = \u0026quot;zhangsan\u0026quot; ; out.println(\u0026quot;\u0026lt;font color='red'\u0026gt;hello.\u0026lt;/font\u0026gt;..\u0026quot;+name +\u0026quot;\u0026lt;br/\u0026gt;\u0026quot;); init() ; %\u0026gt; \u0026lt;%=\u0026quot;he\u0026lt;br/\u0026gt;llo...\u0026quot;+bookName %\u0026gt; \u0026lt;!--html注释 --\u0026gt; \u0026lt;%-- jsp注释--%\u0026gt;  一般而言，修改web.xml、配置文件、java 需要重启tomcat服务\n但是如果修改 Jsp\\html\\css\\js ，不需要重启\n注意，out.println()不能回车； 要想回车：“\u0026lt;br/\u0026gt;”，即out.print() \u0026lt;%= %\u0026gt; 可以直接解析html代码\n指令 page指令\n\u0026lt;%@ page ....%\u0026gt;  page指定的属性：\nlanguage:jsp页面使用的脚本语言 import:导入类（java） pageEncoding:jsp文件自身编码 jsp -\u0026gt;java contentType:浏览器解析jsp的编码  \u0026lt;%@ page language=\u0026quot;java\u0026quot; contentType=\u0026quot;text/html; charset=UTF-8\u0026quot; pageEncoding=\u0026quot;UTF-8\u0026quot; import=\u0026quot;java.util.Date\u0026quot; %\u0026gt;  注释 html注释 \u0026lt;!-- --\u0026gt; ,可以被客户 通过浏览器查看源码 所观察到,其他两个则不行 java注释 // /*...*/ jsp注释 \u0026lt;%-- --%\u0026gt;  JSP九大内置对象 （自带的，不需要new 也能使用的对象）\nout：输出对象，向客户端输出内容 pageContext: request：请求对象；存储“客户端向服务端发送的请求信息” reponse session application config 配置对象（服务器配置信息） page 当前JSP页面对象（相当于java中的this） exception 异常对象  request对象 request：请求对象；存储“客户端向服务端发送的请求信息”\nrequest对象的常见方法：\nString getParameter(String name) :根据请求的字段名key （input标签的name属性值） ，返回字段值value （input标签的value属性值） String[] getParameterValues(String name): 根据请求的字段名key ，返回多个字段值value （checkbox） void setCharacterEncoding(\u0026quot;编码格式utf-8\u0026quot;) ：设置post方式的请求编码 （tomcat7以前默认iso-8859-1，tomcat8以后改为了utf-8） getRequestDispatcher(\u0026quot;b.jsp\u0026quot;).forward(request,response) ; ：请求转发 的方式跳转页面 A - \u0026gt; B ServletContext getServerContext():获取项目的ServletContext对象  实例 注册\nregister.jsp ，show.jsp  register.jsp\n\u0026lt;form action=\u0026quot;show.jsp\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 用户名：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;uname\u0026quot; /\u0026gt;\u0026lt;br/\u0026gt; 密码：\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;upwd\u0026quot;/\u0026gt;\u0026lt;br/\u0026gt; 年龄：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;uage\u0026quot;/\u0026gt;\u0026lt;br/\u0026gt; 爱好\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;uhobbies\u0026quot; value=\u0026quot;足球\u0026quot;/\u0026gt;足球、 \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;uhobbies\u0026quot; value=\u0026quot;篮球\u0026quot;/\u0026gt;篮球、 \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;uhobbies\u0026quot; value=\u0026quot;乒乓球\u0026quot;/\u0026gt;乒乓球\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;注册\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  show.jsp\n\u0026lt;% //设置编码 request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;) ; String name = request.getParameter(\u0026quot;uname\u0026quot;) ; //name = new String( name.getBytes(\u0026quot;gbk\u0026quot;) , \u0026quot;utf-8\u0026quot;); get方式修改编码 int age = Integer.parseInt( request.getParameter(\u0026quot;uage\u0026quot;) ) ; String pwd = request.getParameter(\u0026quot;upwd\u0026quot;) ; String[] hobbies = request.getParameterValues(\u0026quot;uhobbies\u0026quot;) ; %\u0026gt; 注册成功，信息如下：\u0026lt;br/\u0026gt; 姓名：\u0026lt;%=name %\u0026gt;\u0026lt;br/\u0026gt; 年龄：\u0026lt;%=age %\u0026gt;\u0026lt;br/\u0026gt; 密码：\u0026lt;%=pwd %\u0026gt;\u0026lt;br/\u0026gt; 爱好：\u0026lt;br/\u0026gt; \u0026lt;% if(hobbies !=null){ for(String hobby :hobbies) { out.print(hobby +\u0026quot;\u0026amp;nbsp;\u0026quot;); } } %\u0026gt;  通过地址栏传参\nhttp://localhost:8888/MyJspProject/show.jsp?uname=aa\u0026amp;upwd=123\u0026amp;uage=22\u0026amp;uhobbies=%E7%AF%AE%E7%90%83 连接/文件？参数名1=参数值1 \u0026amp; 参数名2=参数值2 \u0026amp; 参数名1=参数值1  get提交方式: method=\u0026ldquo;get\u0026rdquo; 和 地址栏 、超链接(\u0026lt;a href=\u0026quot;xx\u0026quot;\u0026gt;)请求方式 默认都属于get提交方式\nget与post请求方式的区别  get方式 在地址栏显示 请求信息 (但是地址栏能够容纳的 信息有限，4-5KB；如果请求数据存在大文件，图片等 会出现地址栏无法容纳全部的数据而出错) ；post不会显示\n 文件上传操作，必须是post 推荐使用post\n  统一请求的编码 request get方式请求 如果出现乱码，解决：\n 统一每一个变量的 编码 （不推荐）\nnew String( 旧编码，新编码); name = new String(name.getBytes(\u0026quot;iso-8859-1\u0026quot;),\u0026quot;utf-8\u0026quot;);  修改server.xml ，一次性的 更改tomcat默认get提交方式的编码 （utf-8）(建议)\n使用tomcat时， 首先在server.xml中 统一get方式的编码..在修改端口号的标签中添加属性\nURIEncoding=\u0026quot;UTF-8\u0026quot;   tomcat7 (iso-8859-1)\ntomcat8（utf-8）\npost方式设置编码\nrequest.setCharacterEncoding(\u0026quot;utf-8\u0026quot;) ;  response 响应对象\n提供的方法：\nvoid addCookie( Cookie cookie ); 服务端向客户端增加cookie对象 void sendRedirect(String location ) throws IOException; :页面跳转的一种方式（重定向） void setContetType(String type):设置服务端响应的编码（设置服务端的contentType类型）  实例：登陆\nlogin.jsp -\u0026gt; check.jsp -\u0026gt;success.jsp login.jsp\n\u0026lt;form action=\u0026quot;check.jsp\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 用户名:\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;uname\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; 密码:\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;upwd\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;登陆\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/form\u0026gt;  check.jsp\n\u0026lt;% request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;) ; String name = request.getParameter(\u0026quot;uname\u0026quot;); String pwd = request.getParameter(\u0026quot;upwd\u0026quot;); if(name.equals(\u0026quot;zs\u0026quot;) \u0026amp;\u0026amp; pwd.equals(\u0026quot;abc\u0026quot;)){//假设 zs abc response.sendRedirect(\u0026quot;success.jsp\u0026quot;) ;//页面跳转：重定向， 导致数据丢失 //页面跳转：请求转发, 可以获取到数据，并且 地址栏 没有改变（仍然保留 转发时的页面check.jsp） //request.getRequestDispatcher(\u0026quot;success.jsp\u0026quot;).forward( request,response); }else{ //登陆失败 out.print(\u0026quot;用户名或密码有误！\u0026quot;) ; } %\u0026gt;  success.jsp\n登录成功！\u0026lt;br/\u0026gt; 欢迎您： \u0026lt;% String name = request.getParameter(\u0026quot;uname\u0026quot;) ; out.print(name) ; %\u0026gt;  请求转发和重定向的区别\n 请求转发 重定向 地址栏是否改变 不变(check.jsp) 改变(success.jsp) 是否保留第一次 保留 不保留 --4种范围对象 请求时的数据 请求的次数 1 2 跳转发生的位置 服务端 客户端发出的第二次跳转  session(服务端) Cookie Cookie（客户端，不是内置对象）:Cookie是由 服务端生成的 ，再发送给客户端保存。\n相当于 本地缓存的作用： 客户端(hello.mp4,zs/abc)-\u0026gt;服务端(hello.mp4；zs/abc)\n作用：提高访问服务端的效率，但是安全性较差。\nCookie：\tname=value javax.servlet.http.Cookie  public Cookie(String name,String value) String getName()：获取name String getValue():获取value void setMaxAge(int expiry);最大有效期 （秒）  服务端准备Cookie：\nresponse.addCookie(Cookie cookie)  页面跳转（转发，重定向）\n客户端获取cookie:\nrequest.getCookies();   服务端增加cookie :response对象；客户端获取对象：request对象 不能直接获取某一个单独对象，只能一次性将 全部的cookie拿到\n\u0026lt;% //服务端 Cookie cookie1 = new Cookie(\u0026quot;name\u0026quot;,\u0026quot;zs\u0026quot;); Cookie cookie2 = new Cookie(\u0026quot;pwd\u0026quot;,\u0026quot;abc\u0026quot;); response.addCookie( cookie1 ); response.addCookie( cookie2 ); //页面跳转到客户端（转发、重定向） response.sendRedirect(\u0026quot;result.jsp\u0026quot;) ; %\u0026gt;  \u0026lt;% //客户端 Cookie[] cookies = request.getCookies(); for(Cookie cookie:cookies){ out.print(cookie.getName()+\u0026quot;--\u0026quot;+cookie.getValue() +\u0026quot;\u0026lt;br/\u0026gt;\u0026quot;); } %\u0026gt;   通过F12可以发现 除了自己设置的Cookie对象外，还有一个name为 JSESSIONID的cookie\n建议 cookie只保存 英文数字，否则需要进行编码、解码\ncookie保存位置\nC:\\Users\\26069\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\q4od5ob1.default-release-1573292012539\\cookies.sqlite  使用Cookie实现 记住用户名 功能 login.jsp--\u0026gt;check.jsp--\u0026gt;A.jap  login.jsp\n\u0026lt;%! String uname ; %\u0026gt; \u0026lt;% boolean flag = false ; Cookie[] cookies = request.getCookies() ; for(Cookie cookie :cookies){ if(cookie.getName().equals(\u0026quot;uname\u0026quot;)){ uname = cookie.getValue() ; flag = true ; } } if(!flag){//if(flag ==true) out.print(\u0026quot;cookie已失效！\u0026quot;); }else{ out.print(\u0026quot;cookie:\u0026quot;+uname); } %\u0026gt; \u0026lt;form action=\u0026quot;check.jsp\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 用户名:\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;uname\u0026quot; value=\u0026quot;\u0026lt;%=(uname==null?\u0026quot;\u0026quot;:uname)%\u0026gt;\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; 密码:\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;upwd\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;登陆\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/form\u0026gt;  check.jsp\n\u0026lt;% request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;) ; String name = request.getParameter(\u0026quot;uname\u0026quot;); String pwd = request.getParameter(\u0026quot;upwd\u0026quot;); //将用户名 加入到Cookie种 Cookie cookie = new Cookie(\u0026quot;uname\u0026quot;,name); cookie.setMaxAge(10) ; response.addCookie(cookie) ; response.sendRedirect(\u0026quot;A.jsp\u0026quot;) ; %\u0026gt;  session :会话 一次访问：\n 浏览网站：开始-关闭 购物： 浏览、付款、退出 电子邮件：浏览、写邮件、退出  开始-结束\nsession机制：\n客户端第一次请求服务端时，（jsessionid-sessionid匹配）服务端会产生一个session对象（用于保存该客户的信息）并且每个session对象 都会有一个唯一的 sessionId( 用于区分其他session);\n服务端由会 产生一个cookie，并且 该cookie的name=JSESSIONID ,value=服务端sessionId的值；\n然后 服务端会在 响应客户端的同时 将该cookie发送给客户端，至此 客户端就有了 一个cookie(JSESSIONID)；\n因此，客户端的cookie就可以和服务端的session一一对应（JSESSIONID - sessionID）\n客户端第二/n次请求服务端时:服务端会先用客户端cookie种的JSESSIONID 去服务端的session中匹配sessionid,如果匹配成功（cookie jsessionid和sesion sessionid），说明此用户 不是第一次访问,无需登录；\n例子：\n客户端： 顾客（客户端） 服务端: 存包处 - 商场(服务端)\n顾客第一次存包：商场 判断此人是 之前已经存过包（通过你手里是否有钥匙）。 如果是新顾客（没钥匙） ，分配一个钥匙 给该顾客； 钥匙 会和 柜子 一一对应；\n第二/n次 存包：商场 判断此人是 之前已经存过包（通过你手里是否有钥匙） 如果是老顾客（有钥匙），则不需要分配；该顾客手里的钥匙 会 和柜子 自动一一对应。\nsession:\n session存储在服务端 session是在 同一个用户（客户）请求时 共享 实现机制：第一次客户请求时 产生一个sessionid 并复制给 cookie的jsessionid 然后发给客户端。最终 通过session的sessionid-cookie的jsessionid  session方法 String getId() :获取sessionId boolean isNew() :判断是否是 新用户（第一次访问） void invalidate():使session失效 （退出登录、注销） void setAttribute() Object getAttribute(); void setMaxInactiveInterval(秒) ：设置最大有效 非活动时间 int getMaxInactiveInterval():获取最大有效 非活动时间  实例：\n登录 login.jsp\n\u0026lt;form action=\u0026quot;check.jsp\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 用户名:\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;uname\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; 密码:\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;upwd\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;登陆\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/form\u0026gt;  check.jsp\n\u0026lt;% request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;) ; String name = request.getParameter(\u0026quot;uname\u0026quot;); String pwd = request.getParameter(\u0026quot;upwd\u0026quot;); if(name.equals(\u0026quot;zs\u0026quot;) \u0026amp;\u0026amp; pwd.equals(\u0026quot;abc\u0026quot;)){//假设 zs abc //只有登录成功，session中才会存在uname /upwd session.setAttribute(\u0026quot;uname\u0026quot;, name)\t; session.setAttribute(\u0026quot;upwd\u0026quot;, pwd)\t; System.out.println(\u0026quot;sessionId\u0026quot;+session.getId()); //Cookie cookie = new Cookie(\u0026quot;uname\u0026quot; ,namxe); //response.addCookie(cookie) ; //服务端在第一次响应客户端时，会发送一个 JSESSIONID的cookie //session.setMaxInactiveInterval(10) ; request.getRequestDispatcher(\u0026quot;welcome.jsp\u0026quot;).forward(request, response) ; }else{ //登录失败 response.sendRedirect(\u0026quot;login.jsp\u0026quot;) ; } %\u0026gt;  invalidate.jsp\n\u0026lt;% session.invalidate() ;//session失效 response.sendRedirect(\u0026quot;login.jsp\u0026quot;) ; //session.removeAttribute(\u0026quot;uname\u0026quot;) ; %\u0026gt;  welcome.jsp\n欢迎您： \u0026lt;% String name = (String)session.getAttribute(\u0026quot;uname\u0026quot;) ; //如果 用户没有登录，而是直接 通过地址栏 访问welcome.jsp,则必然获取到的name是null if(name!=null){ out.print(name); System.out.println(); %\u0026gt; \u0026lt;a href=\u0026quot;invalidate.jsp\u0026quot;\u0026gt;注销\u0026lt;/a\u0026gt; \u0026lt;% }else{//如果没有登录，应该跳转登录页面 response.sendRedirect(\u0026quot;login.jsp\u0026quot;); } %\u0026gt;  A.jsp\n\u0026lt;% out.print(session.getAttribute(\u0026quot;uname\u0026quot;)); Cookie[] cookies = request.getCookies(); for(Cookie cookie:cookies){ if(cookie.getName().equals(\u0026quot;JSESSIONID\u0026quot;)){ System.out.print(\u0026quot;JSESSIONID\u0026quot;+cookie.getValue()); } } %\u0026gt;  客户端在第一次请求服务端时，如果服务端发现 此请求没有 JSESSIONID,则会创建一个 name=JSESIONID的cookie 并返回给客户端\n即使服务端并没有new Cookie对象\nCookie：\n 不是内对对象，要使用必须new 但是，服务端会 自动生成一个(服务端自动new一个cookie) name=JSESIONID的cookie 并返回给客户端  cookie和session的区别：\n session cookie 保存的位置 服务端 客户端 安全性 较安全 较不安全 保存的内容 Object String  appliation 全局对象 方法\nString getContextPath() 虚拟路径 String getRealPath(String name): 绝对路径（虚拟路径 相对的绝对路径）  \u0026lt;%=\u0026quot;当前项目的虚拟路径：\u0026quot; +application.getContextPath() +\u0026quot;\u0026lt;br/\u0026gt;\u0026quot;\t%\u0026gt; \u0026lt;%=\u0026quot;虚拟路径对应的绝对路径：\u0026quot; +application.getRealPath(\u0026quot;/MyJspProject\u0026quot;) +\u0026quot;\u0026lt;br/\u0026gt;\u0026quot;\t%\u0026gt;  四种范围对象（小-\u0026gt;大） pageContext JSP页面容器 当前页面有效 request 请求对象 同一次请求有效 session 会话对象 同一次会话有效 appliation 全局对象 全局有效（整个项目有效）  pageContext有些书上也叫（page对象，但不是九大内置对象的page）；\n以上4个对象共有的方法：\nObject getAttribute(String name):根据属性名，或者属性值 void setAttribute(String name,Object obj) :设置属性值（新增，修改） setAttribute(\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;) 如果a对象之前不存在，则新建一个a对象 ； 如果a之前已经存在，则将a的值改为b void removeAttribute(String name)：根据属性名，删除对象  pageContext 当前页面有效 (页面跳转后无效)\n\u0026lt;%\tpageContext.setAttribute(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;) ; request.getRequestDispatcher(\u0026quot;pc1.jsp\u0026quot;).forward(request, response) ; %\u0026gt; \u0026lt;%=pageContext.getAttribute(\u0026quot;hello\u0026quot;) %\u0026gt;  request 同一次请求有效；其他请求无效 （请求转发后有效；重定向后无效）\n\u0026lt;% request.setAttribute(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;) ; request.getRequestDispatcher(\u0026quot;rq1.jsp\u0026quot;).forward(request, response) ; //response.sendRedirect(\u0026quot;rq1.jsp\u0026quot; ) ; %\u0026gt;  \u0026lt;%=request.getAttribute(\u0026quot;hello\u0026quot;) %\u0026gt;  session 同一次会话有效 （无论怎么跳转，都有效；关闭/切换浏览器后无效 ； 从 登陆-\u0026gt;退出 之间 全部有效）\n\u0026lt;% session.setAttribute(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;) ; //request.getRequestDispatcher(\u0026quot;rq1.jsp\u0026quot;).forward(request, response) ; response.sendRedirect(\u0026quot;ss1.jsp\u0026quot; ) ; %\u0026gt;  application 全局变量；整个项目运行期间 都有效 (切换浏览器 仍然有效)；关闭服务、其他项目 无效\n-\u0026gt;多个项目共享、重启后仍然有效 ：JNDI\n\u0026lt;%\tapplication.setAttribute(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;) ; //request.getRequestDispatcher(\u0026quot;rq1.jsp\u0026quot;).forward(request, response) ; response.sendRedirect(\u0026quot;ap1.jsp\u0026quot; ) ; %\u0026gt;  小结  以上的4个范围对象，通过 setAttribute()复制，通过getAttribute()取值；\n 以上范围对象，尽量使用最小的范围。因为对象的范围越大，造成的性能损耗越大。\n  JDBC Java DataBase Connectivity 可以为多种关系型数据库DBMS 提供统一的访问方式，用Java来操作数据库\nJDBC API 主要功能\n三件事，具体是通过以下类/接口实现：\nDriverManager ： 管理jdbc驱动 Connection： 连接（通过DriverManager产生） Statement（PreparedStatement） ：增删改查 （通过Connection产生 ） CallableStatement ： 调用数据库中的 存储过程/存储函数 （通过Connection产生 ） Result ：返回的结果集 （上面的Statement等产生 ）  Connection 产生操作数据库的对象：\nConnection产生Statement对象：createStatement() Connection产生PreparedStatement对象：prepareStatement() Connection产生CallableStatement对象：prepareCall();  Statement 操作数据库：\n增删改：executeUpdate() 查询：executeQuery();  ResultSet 保存结果集 select * from xxx\nnext():光标下移，判断是否有下一条数据；true/false previous(): true/false getXxx(字段名|位置):获取具体的字段值  PreparedStatement 操作数据库：\npublic interface PreparedStatement extends Statement  因此\n增删改：executeUpdate() 查询：executeQuery();  \u0026ndash;此外\n赋值操作 setXxx();  PreparedStatement与Statement在使用时的区别：\n Statement:\nsql executeUpdate(sql)  PreparedStatement:\nsql(可能存在占位符?)  在创建PreparedStatement 对象时，将sql预编译\nprepareStatement(sql) executeUpdate() setXxx()替换占位符？   推荐使用PreparedStatement：原因如下：\n 编码更加简便（避免了字符串的拼接）\nString name = \u0026quot;zs\u0026quot; ; int age = 23 ;   stmt:\nString sql =\u0026quot; insert into student(stuno,stuname) values('\u0026quot;+name+\u0026quot;', \u0026quot;+age+\u0026quot; ) \u0026quot; ; stmt.executeUpdate(sql);  pstmt:\nString sql =\u0026quot; insert into student(stuno,stuname) values(?,?) \u0026quot; ; pstmt = connection.prepareStatement(sql);//预编译SQL pstmt.setString(1,name); pstmt.setInt(2,age);   提高性能(因为 有预编译操作，预编译只需要执行一次) 需要重复增加100条数\n stmt:\nString sql =\u0026quot; insert into student(stuno,stuname) values('\u0026quot;+name+\u0026quot;', \u0026quot;+age+\u0026quot; ) \u0026quot; ; for(100) stmt.executeUpdate(sql);  pstmt:\nString sql =\u0026quot; insert into student(stuno,stuname) values(?,?) \u0026quot; ; pstmt = connection.prepareStatement(sql);//预编译SQL pstmt.setString(1,name); pstmt.setInt(2,age); for( 100){ pstmt.executeUpdate(); }   安全（可以有效防止sql注入）\nsql注入：将客户输入的内容和开发人员的SQL语句 混为一体\n stmt:存在被sql注入的风险\n(例如输入 用户名：任意值 \u0026lsquo; or 1=1 \u0026ndash; 密码：任意值)\n分析：\nselect count(*) from login where uname='任意值 ' or 1=1 --' and upwd ='任意值' ; 简化 select count(*) from login where uname='任意值 ' or 1=1 ; 简化 select count(*) from login ;  登陆时输入 xxx \u0026lsquo; or 1=1 \u0026ndash;\n pstmt:有效防止sql注入\nselect count(*) from login where uname='\u0026quot;+name+\u0026quot;' and upwd ='\u0026quot;+pwd+\u0026quot;'   推荐使用pstmt\n  jdbc访问数据库的具体步骤：  导入驱动，加载具体的驱动类 与数据库建立连接 发送sql，执行 处理结果集 （查询）  数据库驱动 Oracle\n驱动jar ojdbc-x.jar 具体驱动类 oracle.jdbc.OracleDriver 连接字符串 jdbc:oracle:thin:@localhost:1521:ORCL  MySQL\n驱动jar mysql-connector-java-x.jar 具体驱动类 com.mysql.jdbc.Driver 连接字符串 jdbc:mysql://localhost:3306/数据库实例名  SqlServer\n驱动jar sqljdbc-x.jar 具体驱动类 com.microsoft.sqlserver.jdbc.SQLServerDriver 连接字符串 jdbc:microsoft:sqlserver:localhost:1433;databasename=数据库实例名  使用jdbc操作数据库时，如果对数据库进行了更换，只需要替换：驱动、具体驱动类、连接字符串、用户名、密码\npublic class JDBCDemo { private static final String URL = \u0026quot;jdbc:oracle:thin:@localhost:1521:ORCL\u0026quot;; private static final String USERNAME = \u0026quot;scott\u0026quot;; private static final String PWD = \u0026quot;tiger\u0026quot;; public static void update() {// 增删改 Connection connection = null; Statement stmt = null; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); // c.发送sql，执行(增删改、查) stmt = connection.createStatement(); //String sql = \u0026quot;insert into student values(1,'zs',23,'s1')\u0026quot;; //String sql = \u0026quot;update student set STUNAME='ls' where stuno=1\u0026quot;; String sql = \u0026quot;delete from student where stuno=1\u0026quot;; // 执行SQL int count = stmt.executeUpdate(sql); // 返回值表示 增删改 几条数据 // d.处理结果 if (count \u0026gt; 0) { System.out.println(\u0026quot;操作成功！\u0026quot;); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(stmt!=null) stmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } } public static void query() { Connection connection = null; Statement stmt = null; ResultSet rs = null ; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); // c.发送sql，执行(增删改、【查】) stmt = connection.createStatement(); //String sql = \u0026quot;select stuno,stuname from student\u0026quot;; Scanner input= new Scanner(System.in); System.out.println(\u0026quot;请输入用户名：\u0026quot;); String name = input.nextLine() ; System.out.println(\u0026quot;请输入密码：\u0026quot;); String pwd = input.nextLine() ; String sql = \u0026quot;select count(*) from login where uname='\u0026quot;+name+\u0026quot;' and upwd ='\u0026quot;+pwd+\u0026quot;' \u0026quot; ; //String sql = \u0026quot;select * from student where stuname like '%\u0026quot;+name+\u0026quot;%'\u0026quot;; // 执行SQL(增删改executeUpdate()，查询executeQuery()) rs = stmt.executeQuery(sql); // 返回值表示 增删改 几条数据 // d.处理结果 //\twhile(rs.next()) { //\tint sno = rs.getInt( \u0026quot;stuno\u0026quot;) ; //\tString sname = rs.getString(\u0026quot;stuname\u0026quot;) ; ////\tint sno = rs.getInt(1) ; //下标：从1开始计数 ////\tString sname = rs.getString(2) ; //\tSystem.out.println(sno+\u0026quot;--\u0026quot;+sname); //\t} int count = -1; if(rs.next()) { count = rs.getInt(1) ; } if(count\u0026gt;0) { System.out.println(\u0026quot;登陆成功！\u0026quot;); }else { System.out.println(\u0026quot;登陆失败！\u0026quot;); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(rs!=null) rs.close(); if(stmt!=null) stmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } } }   public class JDBCPreparedStatementDemo { private static final String URL = \u0026quot;jdbc:oracle:thin:@localhost:1521:ORCL\u0026quot;; private static final String USERNAME = \u0026quot;scott\u0026quot;; private static final String PWD = \u0026quot;tiger\u0026quot;; public static void update() {// 增删改 Connection connection = null; PreparedStatement pstmt = null; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); //PreparedStatement String sql = \u0026quot;insert into student values(?,?,?,?)\u0026quot;; pstmt = connection.prepareStatement(sql);//预编译 pstmt.setInt(1, 36); pstmt.setString(2, \u0026quot;zhangsan\u0026quot;); pstmt.setInt(3, 56); pstmt.setString(4, \u0026quot;s3\u0026quot;); int count =pstmt.executeUpdate() ; // d.处理结果 if (count \u0026gt; 0) { System.out.println(\u0026quot;操作成功！\u0026quot;); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(pstmt!=null) pstmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } } public static void query() { Connection connection = null; PreparedStatement pstmt = null; ResultSet rs = null ; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); // c.发送sql，执行(增删改、【查】) Scanner input= new Scanner(System.in); System.out.println(\u0026quot;请输入用户名：\u0026quot;); String name = input.nextLine() ; System.out.println(\u0026quot;请输入密码：\u0026quot;); String pwd = input.nextLine() ; //String sql = \u0026quot;select * from student where stuname like '%\u0026quot;+name+\u0026quot;%'\u0026quot;; //String sql = \u0026quot;select * from student where stuname like ?\u0026quot;; String sql =\u0026quot;select count(*) from login where uname= ? and upwd =?\u0026quot;; pstmt = connection.prepareStatement(sql) ; pstmt.setString(1, name); pstmt.setString(2, pwd); //String sql = \u0026quot;select stuno,stuname from student\u0026quot;; // 执行SQL(增删改executeUpdate()，查询executeQuery()) rs = pstmt.executeQuery(); // 返回值表示 增删改 几条数据 // d.处理结果 int count = -1; if(rs.next()) { count = rs.getInt(1) ; } if(count\u0026gt;0) { System.out.println(\u0026quot;登陆成功！\u0026quot;); }else { System.out.println(\u0026quot;登陆失败！\u0026quot;); } } catch (ClassNotFoundException e) { System.out.println(\u0026quot;111\u0026quot;); e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(rs!=null) rs.close(); if(pstmt!=null) pstmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); }catch(Exception e) { e.printStackTrace(); } } } }  jdbc总结 （模板、八股文）：\ntry{ a.导入驱动包、加载具体驱动类Class.forName(\u0026quot;具体驱动类\u0026quot;); b.与数据库建立连接connection = DriverManager.getConnection(...); c.通过connection，获取操作数据库的对象（Statement\\preparedStatement\\callablestatement） stmt = connection.createStatement(); d.(查询)处理结果集rs = pstmt.executeQuery() while(rs.next()){ rs.getXxx(..) ;} }catch(ClassNotFoundException e ) { ...} catch(SQLException e) {... } catch(Exception e) {... } finally { //打开顺序，与关闭顺序相反 if(rs!=null)rs.close() if(stmt!=null) stmt.close(); if(connection!=null)connection.close(); }  \u0026ndash;jdbc中，除了Class.forName() 抛出ClassNotFoundException，其余方法全部抛SQLException\nCallableStatement 调用 存储过程、存储函数\nconnection.prepareCall(参数：存储过程或存储函数名)  参数格式：\n存储过程（无返回值return，用out参数替代）：\n{ call 存储过程名(参数列表) }  存储函数（有返回值return）：\n{ ? = call 存储函数名(参数列表) }  创建存储过程\ncreate or replace procedure addTwoNum ( num1 in number,num2 in number,result out number ) as begin result := num1+num2 ; end ; /  强调： 如果通过sqlplus 访问数据库，只需要开启：\nOracleServiceSID  通过其他程序访问数据（sqldevelop、navicate、JDBC），需要开启：\nOracleServiceSID、XxxListener  public static void invokeProcedure() { Connection connection = null; CallableStatement cstmt = null; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); // c.发送sql，执行(增删改、查) num1+num2 -\u0026gt;num3 cstmt = connection.prepareCall( \u0026quot;{ call addTwoNum(?,?,?) }\u0026quot; ) ; cstmt.setInt(1, 30); cstmt.setInt(2, 40); //设置输出参数的类型 cstmt.registerOutParameter(3, Types.INTEGER); cstmt.execute() ;//num1+num2 ,execute()之前处理 输入参数以及输出参数类型，之后接受输出参数值 int result = cstmt.getInt(3) ;//获取计算结果 System.out.println(result); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(cstmt!=null) cstmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } }  JDBC调用存储过程的步骤：\n 产生 调用存储过程的对象（CallableStatement） cstmt = connection.prepareCall( \u0026quot;...\u0026quot; ) ; 通过setXxx()处理 输出参数值 cstmt.setInt(1, 30); 通过 registerOutParameter(\u0026hellip;)处理输出参数类型 cstmt.execute()执行 接受 输出值（返回值）getXxx()  调存储函数： 创建存储函数\ncreate or replace function addTwoNumfunction ( num1 in number,num2 in number) -- 1 + 2 return number as result number ; begin result := num1+num2 ; return result ; end ; /  调用存储函数\npublic static void invokeFunction() { Connection connection = null; CallableStatement cstmt = null; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); // c.发送sql，执行(增删改、查) num1+num2 -\u0026gt;num3 cstmt = connection.prepareCall( \u0026quot;{? = call addTwoNumfunction\t(?,?) }\u0026quot; ) ; cstmt.setInt(2, 30); cstmt.setInt(3,40); cstmt.registerOutParameter(1, Types.INTEGER); cstmt.execute() ;//num1+num2 ,execute()之前处理 输入参数以及输出参数类型，之后接受输出参数值 //设置输出参数的类型 int result = cstmt.getInt(1) ;//获取计算结果 System.out.println(result); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(cstmt!=null) cstmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } }  JDBC调用存储函数：与调存储过程的区别：\n在调用时，注意参数位置\n处理CLOB/BLOB类型 CLOB：大文本数据\nBLOB：二进制文件\n处理稍大型数据：\n 方法一\n存储路径 E:\\JDK_API_zh_CN.CHM\n通过JDBC存储文件路径，然后 根据IO操作处理\n例如：JDBC将 E:\\JDK_API_zh_CN.CHM 文件 以字符串形式“E:\\JDK_API_zh_CN.CHM”存储到数据库中\n获取：\n 获取该路径“E:\\JDK_API_zh_CN.CHM”\n IO\n  方法二\n直接将数据存放到数据库中\n  clob:大文本数据 字符流 Reader Writer\n创建表\ncreate table mynovel(id number primary key,novel clob);  通过jdbc存储大文本数据（小说）CLOB\n//通过jdbc存储大文本数据（小说）CLOB //设置CLOB类型：setCharacterStream public static void clobDemo() { Connection connection = null; PreparedStatement pstmt = null; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); String sql = \u0026quot;insert into mynovel values(?,?)\u0026quot;; // c.发送sql，执行(增删改、查) pstmt = connection.prepareStatement(sql); pstmt.setInt(1, 1); File file = new File(\u0026quot;E:\\\\all.txt\u0026quot;); InputStream in = new FileInputStream( file) ; Reader reader = new InputStreamReader( in ,\u0026quot;UTF-8\u0026quot;) ;//转换流 可以设置编码 pstmt.setCharacterStream(2, reader, (int)file.length()); int count =pstmt.executeUpdate() ; // d.处理结果 if (count \u0026gt; 0) { System.out.println(\u0026quot;操作成功！\u0026quot;); } reader.close(); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(pstmt!=null) pstmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } }  步骤\n 先通过pstmt 的?代替小说内容 （占位符）\n 再通过pstmt.setCharacterStream(2, reader, (int)file.length()); 将上一步的？替换为 小说流， 注意第三个参数需要是 Int类型\n  读取小说\n//读取小说 public static void clobReaderDemo() { Connection connection = null; PreparedStatement pstmt = null; ResultSet rs = null ; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); String sql = \u0026quot;select NOVEL from mynovel where id = ? \u0026quot;; // c.发送sql，执行(查) pstmt = connection.prepareStatement(sql); pstmt.setInt(1, 1); rs = pstmt.executeQuery() ; //setXxxx getXxxx setInt getInt if(rs.next()) { Reader reader = rs.getCharacterStream(\u0026quot;NOVEL\u0026quot;) ; Writer writer = new FileWriter(\u0026quot;src/小说.txt\u0026quot;); char[] chs = new char[100] ; int len = -1; while( (len = reader.read(chs)) !=-1 ) { writer.write( chs,0,len ); } writer.close(); reader.close(); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(pstmt!=null) pstmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } }  读取步骤\n 通过Reader reader = rs.getCharacterStream(\u0026ldquo;NOVEL\u0026rdquo;) ; 将cloc类型的数据 保存到Reader对象中 将Reader通过Writer输出即可。  blob: 二进制 字节流 InputStream OutputStream\n与CLOB步骤基本一致，区别：\nsetBinaryStream(...) getBinaryStream(...)  创建表\ncreate table mymusic(id number primary key,music blob);  通过jdbc存储二进制类型 （mp3）\n//通过jdbc存储二进制类型 （mp3） //设置BLOB类型： public static void blobDemo() { Connection connection = null; PreparedStatement pstmt = null; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); String sql = \u0026quot;insert into mymusic values(?,?)\u0026quot;; // c.发送sql，执行(增删改、查) pstmt = connection.prepareStatement(sql); pstmt.setInt(1, 1); File file = new File(\u0026quot;d:\\\\luna.mp3\u0026quot;); InputStream in = new FileInputStream(file ); pstmt.setBinaryStream(2,in ,(int)file.length() ); int count =pstmt.executeUpdate() ; // d.处理结果 if (count \u0026gt; 0) { System.out.println(\u0026quot;操作成功！\u0026quot;); } in.close(); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(pstmt!=null) pstmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } }  读取二进制文件\n//读取二进制文件 public static void blobReaderDemo() { Connection connection = null; PreparedStatement pstmt = null; ResultSet rs = null ; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); String sql = \u0026quot;select music from mymusic where id = ? \u0026quot;; // c.发送sql，执行(查) pstmt = connection.prepareStatement(sql); pstmt.setInt(1, 1); rs = pstmt.executeQuery() ; if(rs.next()) { InputStream in = rs.getBinaryStream(\u0026quot;music\u0026quot;) ; OutputStream out = new FileOutputStream(\u0026quot;src/music.mp3\u0026quot;) ; byte[] chs = new byte[100] ; int len = -1; while( (len = in.read(chs)) !=-1 ) { out.write( chs,0,len ); } out.close(); in.close(); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(pstmt!=null) pstmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } }  JSP访问数据库 JSP就是在html中嵌套的java代码，因此 java代码可以写在jsp中（\u0026lt;% \u0026hellip; %\u0026gt;）\n导包操作： java项目 ：\n Jar复制到工程中 右键该Jar :build path -\u0026gt;add to build Path  Web项目：\n jar复制到WEB-INF/lib  核心：就是将 java中的JDBC代码，复制到 JSP中的\u0026lt;% \u0026hellip; %\u0026gt;\nindex.jsp\n\u0026lt;form action=\u0026quot;check.jsp\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 用户名：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;uname\u0026quot; /\u0026gt;\u0026lt;br/\u0026gt; 密码：\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;upwd\u0026quot; /\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;登录\u0026quot; /\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/form\u0026gt;  check.jsp\n\u0026lt;%@ page import=\u0026quot;java.sql.*\u0026quot; %\u0026gt; \u0026lt;% String URL = \u0026quot;jdbc:oracle:thin:@localhost:1521:ORCL\u0026quot;; String USERNAME = \u0026quot;scott\u0026quot;; String PWD = \u0026quot;tiger\u0026quot;; Connection connection = null; Statement stmt = null; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); // c.发送sql，执行(增删改、查) stmt = connection.createStatement(); String name =request.getParameter(\u0026quot;uname\u0026quot;); String pwd = request.getParameter(\u0026quot;upwd\u0026quot;); String sql = \u0026quot;select count(*) from login where uname='\u0026quot;+name+\u0026quot;' and upwd ='\u0026quot;+pwd+\u0026quot;' \u0026quot; ; // 执行SQL(增删改executeUpdate()，查询executeQuery()) rs = stmt.executeQuery(sql); // 返回值表示 增删改 几条数据 // d.处理结果 int count = -1; if(rs.next()) { count = rs.getInt(1) ; } if(count\u0026gt;0) { System.out.println(\u0026quot;登陆成功！\u0026quot;); }else { System.out.println(\u0026quot;登陆失败！\u0026quot;); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(rs!=null) rs.close(); if(stmt!=null) stmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } %\u0026gt;  注意：如果jsp出现错误：The import Xxx cannot be resolved\n尝试解决步骤：\n (可能是Jdk、tomcat版本问题) 右键项目-\u0026gt;build path，将其中 报错的 libary或Lib 删除后 重新导入\n 清空各种缓存：右键项目-\u0026gt;Clean tomcat\u0026hellip; clean （Project -clean或者 进tomcat目录 删除里面work的子目录）\n 删除之前的tomcat，重新解压缩、配置tomcat，重启计算机\n 如果类之前没有包，则将该类加入包中\n  JavaBean 刚才我们将 jsp中 登录操作的代码 转移到了LoginDao.java；其中LoginDao类 就称之为JavaBean。 JavaBean的作用： 1. 减轻的jsp复杂度\n1. 提高代码复用（以后任何地方的 登录操作，都可以通过调用LoginDao实现）\nloginDao.java\npublic class LoginDao { //1:登录成功 0：登录失败（用户名或密码有误） -1：系统异常 public int login(Login login) { String URL = \u0026quot;jdbc:oracle:thin:@localhost:1521:ORCL\u0026quot;; String USERNAME = \u0026quot;scott\u0026quot;; String PWD = \u0026quot;tiger\u0026quot;; Connection connection = null; Statement stmt = null; ResultSet rs = null ; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); // c.发送sql，执行(【查】) stmt = connection.createStatement(); String sql = \u0026quot;select count(*) from login where uname='\u0026quot;+login.getName()+\u0026quot;' and upwd ='\u0026quot;+login.getPwd()+\u0026quot;' \u0026quot; ; rs = stmt.executeQuery(sql); // 返回值表示 增删改 几条数据 // d.处理结果 int count = -1; if(rs.next()) { count = rs.getInt(1) ; } return count ; } catch (ClassNotFoundException e) { e.printStackTrace(); return -1 ; } catch (SQLException e) { e.printStackTrace(); return -1 ; } catch(Exception e) { e.printStackTrace(); return -1 ; } finally { try { if(rs!=null) rs.close(); if(stmt!=null) stmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } }  check.jsp\n\u0026lt;%@ page import=\u0026quot;org.lanqiao.dao.LoginDao\u0026quot; %\u0026gt; \u0026lt;% String name = request.getParameter(\u0026quot;uname\u0026quot;) ; String pwd = request.getParameter(\u0026quot;upwd\u0026quot;) ; Login login = new Login(name,pwd) ; LoginDao dao = new LoginDao(); int result = dao.login(login) ; if(result \u0026gt;0){ out.print(\u0026quot;登录成功！\u0026quot;); }else if(result==0){ out.print(\u0026quot;用户名或密码有误！！\u0026quot;); }else{ out.print(\u0026quot;系统异常！！\u0026quot;); } %\u0026gt;  Login.java\npublic class Login { private int id ; private String name; private String pwd ; public Login() { } public Login(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public Login( String name, String pwd) { this.name = name; this.pwd = pwd; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } }  JavaBean（就是一个Java类）的定义：满足一下2点 ，就可以称为JavaBean\n public 修饰的类 ,public 无参构造 所有属性(如果有) 都是private，并且提供set/get (如果boolean 则get 可以替换成is)  使用层面，Java分为2大类：\n 封装业务逻辑的JavaBean (LoginDao.java封装了登录逻辑)逻辑\n可以将jsp中的JDBC代码，封装到Login.java类中 （Login.java）\n 封装数据的JavaBean （实体类，Student.java Person.java ）数据\n对应于数据库中的一张表\nLogin login = new Login(uname,upwd) ;//即用Login对象 封装了2个数据（用户名 和密码）\n  封装数据的JavaBean 对应于数据库中的一张表 (Login(name,pwd))\n封装业务逻辑的JavaBean 用于操作 一个封装数据的JavaBean\n可以发现，JavaBean可以简化 代码(jsp-\u0026gt;jsp+java)、提供代码复用(LoginDao.java)\nMVC设计模式  M：Model，模型 ：一个功能。用JavaBean实现。\n V:View，视图： 用于展示、以及与用户交互。使用html js css jsp jquery等前端技术实现\n C:Controller，控制器 ：接受请求，将请求跳转到模型进行处理；模型处理完毕后，再将处理的结果\n返回给 请求处 。 可以用jsp实现， 但是一般建议使用 Servlet实现控制器。\n  Jsp-\u0026gt;Java(Servlet)-\u0026gt;JSP\nServlet Java类必须符合一定的 规范：\n 必须继承 javax.servlet.http.HttpServlet 重写其中的 doGet()或doPost()方法\ndoGet()： 接受 并处 所有get提交方式的请求 doPost()：接受 并处 所有post提交方式的请求   public class WelcomeServlet extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026quot;doGet...\u0026quot;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //System.out.println(\u0026quot;doPost...\u0026quot;); this.doGet(req, resp); } }  \u0026lt;a href=\u0026quot;/Servlet25Project/WelcomeServlet\u0026quot;\u0026gt;WelcomeServlet\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;form action=\u0026quot;/WelcomeServlet\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; \u0026gt; \u0026lt;/form\u0026gt;   Servlet要想使用，必须配置\n Serlvet2.5：web.xml Servle3.0： @WebServlet  Serlvet2.5 web.xml:\n\u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;WelcomeServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.lanqiao.servlet.WelcomeServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;WelcomeServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/WelcomeServlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;  项目的根目录：WebContent 、src\n\u0026lt;a href=\u0026quot;WelcomeServlet\u0026quot;\u0026gt;所在的jsp是在 WebContent目录中，因此 发出的请求WelcomeServlet 是去请求项目的根目录(/)。\nServlet流程： 请求 -\u0026gt;\u0026lt;url-pattern\u0026gt; -\u0026gt; 根据\u0026lt;servlet-mapping\u0026gt;中的\u0026lt;servlet-name\u0026gt;去匹配 \u0026lt;servlet\u0026gt; 中的\u0026lt;servlet-name\u0026gt;，然后寻找到\u0026lt;servlet-class\u0026gt;，求中将请求交由该\u0026lt;servlet-class\u0026gt;执行。\n创建servlet\n 纯手工方法创建第一个Servlet\n步骤：\n 编写一个类，继承HttpServlet\n 重写doGet()、doPost()方法\n 编写web.xml 中的servlet映射关系\n  借助于Eclipse快速生成Servlet\n直接新建Servlet即可！（继承、重写、web.xml 可以借助Eclipse自动生成）\n  Servlet3.0，与Servlet2.5的区别：\nServlet3.0不需要在web.xml中配置，但 需要在 Servlet类的定义处之上编写 注解@WebServlet(\u0026ldquo;url-pattern的值\u0026rdquo;)\n匹配流程： 请求地址 与@WebServlet中的值 进行匹配，如果匹配成功 ，则说明 请求的就是该注解所对应的类\n项目根目录 项目根目录：WebContent、src（所有的构建路径）\n例如：\nWebContent中有一个文件index.jsp src中有一个Servlet.java  如果: index.jsp中请求 \u0026lt;a href=\u0026quot;abc\u0026quot;\u0026gt;...\u0026lt;/a\u0026gt; ，则 寻找范围：既会在src根目录中找 也会在WebContent根目录中找\n如果：index.jsp中请求\u0026lt;a href=\u0026quot;a/abc\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;，寻找范围：先在src或WebContent中找a目录，然后再在a目录中找abc\n web.xml中的 /:代表项目根路径\nhttp://localhost:8888/Servlet25Project/  jsp中的/: 服务器根路径\nhttp://localhost:8888/   构建路径、WebContent:根目录\nServlet生命周期：5个阶段  加载 :Servlet容器自动处理 初始化： init() ，该方法会在 Servlet被加载并实例化的以后 执行 服务 ：service() -\u0026gt;doGet() doPost 销毁 ：destroy()， Servlet被系统回收时执行 卸载 :Servlet容器自动处理  init():  默认第一次访问 Servlet时会被执行 （只执行这一次）\n 可以修改为 Tomcat启动时自动执行\n Servlet2.5： web.xml\n\u0026lt;servlet\u0026gt; ... \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt;  其中的“1”代表第一个。\n Servlet3.0\n@WebServlet( value=\u0026quot;/WelcomeServlet\u0026quot; ,loadOnStartup=1 )    service() -\u0026gt;doGet() doPost ：调用几次，则执行几次\ndestroy()：关闭tomcat服务时，执行一次。\nServlet API 由两个软件包组成： 对应于HTTP协议的软件包、对应于除了HTTP协议以外的其他软件包\n即Servlet API可以适用于 任何 通信协议。\n我们学习的Servlet,是位于javax.servlet.http包中的类和接口，是基础HTTP协议。\nServlet继承关系 ServletConfig:接口\nServletContext getServletContext():获取Servlet上下文对象 application String getInitParameter(String name):在当前Servlet范围内，获取名为name的参数值（初始化参数）  ServletContext中的常见方法(application)：\ngetContextPath():相对路径 getRealPath()：绝对路径 setAttribute() 、getAttribute() ---\u0026gt; String getInitParameter(String name);在当前Web容器范围内(范围更大，包含了servlet)，获取名为name的参数值（初始化参数）  servlet2.5方式设置参数值\n在整个web容器中设置初始化参数\n \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;globalParam\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;global value..\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt;  在servlet中设置初始化参数\n\u0026lt;servlet\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;servletparamname\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;servletparamvalue...\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/servlet\u0026gt;  获取值\npublic void init() throws ServletException { System.out.println(\u0026quot;init...\u0026quot;); //获取当前Servlet的初始化参数 String value = super.getInitParameter(\u0026quot;servletparamname\u0026quot;) ; System.out.println(\u0026quot;当前Servlet的参数servletparamname的值是：\u0026quot;+value); //获取当前Web容器的初始化参数 ServletContext servletContext = super.getServletContext() ; String globalValue = servletContext.getInitParameter(\u0026quot;globalParam\u0026quot;) ; System.out.println(\u0026quot;当前Web容器的 参数globalValue的值是：\u0026quot;+globalValue); }  Servlet3.0方式 给当前Servlet设置初始值：\n@WebServlet( .... , initParams= {@WebInitParam(name=\u0026quot;serveltparaname30\u0026quot;,value=\u0026quot;servletparavalue30\u0026quot;)})  注意，此注解只 隶属于某一个具体的Servlet ，因此无法为 整个web容器设置初始化参数 （如果要通过3.0方式设置 web容器的初始化参数，仍然需要在web.xml中设置）\n全局的servlet值在web.xml中设置\nHttpServletRequest中的方法：(同request)，例如\nsetAttrite()、getCookies()、getMethod() HttpServletResponse中的方法：同response  Servlet使用层面：\nEclipse中在src创建一个Servlet，然后重写doGet() doPost()就可以 （doGet() doPost()只需要编写一个）。\nMVC案例 三层架构 与MVC设计模式的目标一致：都是为了解耦合、提高代码的复用；\n三层组成：\n表示层（USL,User Show Layer; 视图层）\n 表示层前台代码（jsp，html js css用于和用户交互，界面的显示 代码位子WebContent）\n 表示层后台代码（servlet用于控制跳转、调用业务逻辑层 在src中的xxx.servlet包中）  业务逻辑层(BLL,Business Logic Layer; service )(逻辑。可拆（也是功能 可以拆分）\n调用数据访问层的方法 一般在src中的xxx.service包中)组装数据访问层 带逻辑性的操作（增删改查 删：查+删）接受表示层的请求调用\n数据访问层(DAL,Data Acess Layer; Dao层\n一般位于src中的xxx.dao包)（原子性 不可拆，各种功能方法）直接访问数据库原子性的操作（增删改查）\nMVC和三层的关系 mvc\nV对应三层里面表示层的前台代码\nC对应三层里面表示层后台diamante\nM对应业务逻辑层和数据访问层\nM里面的封装数据的JavaBean对应业务逻辑层和数据访问层\n封装数据的JavaBean对应实体类（不在三层架构当中，但是三层架构借助实体类封装数据传递数据）\njsp的对象在servlet怎么使用\n out: PrintWriter out = response.getWriter();\n session:request.getSession();\n applicayion: request.getServletContext();\n  设置编码  设置请求编码\n页面向数据库传东西 数据库出现乱码\nrequest.setCharacterEncoding(\u0026quot;utf-8\u0026quot;);   出现乱码要设置相应的编码\n 设置响应编码\n数据库向页面传东西 页面出现乱码\nresponse.setContentType(\u0026quot;text/html; charset=UTF-8\u0026quot; ); response.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); PrintWriter out = response.getWriter();   三层\n三层间的关系：上层将请求传递给下层，下层处理后返回给上层\n上层依赖下层\n依赖：代码的理解，就是持有成员变量\n流程解析  表示层前台 add.jsp (form action=\u0026ldquo;\u0026hellip;Servlet\u0026rdquo; 用户输入数据)\n 表示层后台addStuServlet(获取数据 封装数据 调用Service中的方法)\n 业务逻辑层 StudentService\naddStudent(student) （调用数据访问层的方法）  数据访问层 StudentDao\nisExist(student)（访问数据库） addStudent(student)（访问数据库）  数据库\n  每一个方法都有返回值 调用方法结束后要根据返回值进行相应的操作\njsp\u0026mdash;》servlet\u0026mdash;》service\u0026ndash;》Dao\u0026ndash;》数据库\nservlet:一个servlet对应一个功能\n因此增删改查四个功能写四个servlet\n三层优化  加入接口\n建议面向接口开发：先接口-再实现类\n\u0026ndash;service、dao加入接口\n\u0026ndash;接口与实现类的命名规范\n接口：interface，起名 ：I实体类Service\nIStudentService IStudentDao  实现类：implements起名 ：实体类ServiceImpl\nStudentServiceImpl StudentDaoImpl  接口所在的包：\nxxx.service xx.dao  实现类所在的包：\nxxx.service.impl xx.dao.impl  以后使用接口/实现类时，推荐写法：\n接口 x = new 实现类(); IStudentDao studentDao = new StudentDaoImpl();  DBUtil 通用的数据库帮助类，可以简化Dao层的代码量\n帮助类 一般建议写在 xxx.util包\n  方法重构： 将多个方法 的共同代码 提炼出来，单独写在一个方法中，然后引入该方法即可\nWeb调试： 与java代码的调试 区别：启动方式不同\nindex.jsp -\u0026gt;index_jsp.java -\u0026gt;index_jsp.class  jsp-\u0026gt;java-\u0026gt;class\njsp翻译成的Java 以及编译后的class文件 存在于tomcat中的work目录中\n分页 5变量（属性）\n 数据总数 （select count(*) from xxx ，查数据库） 页面大小（页面容量，每页显示的数据条数） （用户自定义） 总页数 （自动计算）\n800:10= 80页 总页数= 数据总数 /页面大小 802:10= 800/10 +1 ； 总页数= 数据总数 /页面大小 + 1;  \u0026ndash;\u0026gt;通式\n总页数= 数据总数 % 页面大小==0 ?数据总数 /页面大小:数据总数 /页面大小 + 1;  注意：自动计算的时机：当 数据总数 和 页面大小都被赋值以后，自动计算总页数。\n 当前页码 （用户自定义）\n 实体类对象集合（当前页的数据集合）：依赖于数据库 (查数据库)\n假设： 每页显示10条（页面大小=10）\nselect * from student where id\u0026gt;=起始 and id\u0026lt;=终止;  页数 起止 起止等价写法 1 1-10 (页数-1)*10+1-页数*10 2 11-20 3 21-30\n  某一页的数据 起止：\n(页数-1)*10+1-页数*10  select * from student where sno\u0026gt;=(页数-1)*10+1 and sno\u0026lt;=页数*10;  此种分页SQL 严格依赖sno的数据，一旦sno出现了间隙（裂缝），则无法满足每页10条\n-\u0026gt;将此SQL 转换： 1. 有rownum\n2. 不能有rownum\u0026gt;xx\n转换的核心：将rownum从伪列 转换为 一个 临时表的 普通列。\nselect *from ( select rownum r,t.*from (select s.* from student s order by sno asc) t ) where r\u0026gt;=(页数-1)*10+1 and r\u0026lt;=页数*10;  优化：\nselect *from ( select rownum r,t.*from (select s.* from student s order by sno asc) t where rownum\u0026lt;=页数*页面大小 ) where r\u0026gt;=(页数-1)*页面大小+1 ;  dao和DBUtil的区别：\n dao 是处理特定 类的 数据库操作类： DBUtil是通用 数据库操作类  分页\n要实现分页，必须知道 某一页的 数据 从哪里开始 到哪里结束\n页面大小：每页显示的数据量\n假设每页显示10条数据\nmysql分页 mysql:从0开始计数 0 0 9 1 10 19 2 20 29 n n*10 (n+1)*10-1  结论：\n分页：\n第n页的数据：\n第(n-1)*10+1条 -- 第n*10条  MYSQL实现分页的sql：\nlimit 开始,多少条\n第0页 select * from student limit 0,10 ; 第1页 select * from student limit 10,10 ; 第2页 select * from student limit 20,10 ; 第n页 select * from student limit n*10,10  mysql的分页语句：\nselect * from student limit 页数*页面大小,页面大小  oracle分页： sqlserver/oracle:从1开始计数 第n页 开始 结束 1 1 10 2 11 20 3 21 30 n (n-1)*10+1 n*10  select *from student where sno \u0026gt;=(n-1)*10+1 and sno \u0026lt;=n*10 ;  \u0026ndash;此种写法的前提：必须是Id连续 ，否则 无法满足每页显示10条数据\nselect rownum,t.*from student t where rownum \u0026gt;=(n-1)*10+1 and rownum \u0026lt;=n*10 order by sno;   如果根据sno排序则rownum会混乱（解决方案：分开使用-\u0026gt;先只排序，再只查询rownum） rownum不能查询\u0026gt;的数据\nselect s.* from student s order by sno asc; select rownum, t.* from (select s.* from student s order by sno asc) t where rownum \u0026gt;=(n-1)*10+1 and rownum \u0026lt;=n*10 ; ;   //ORACLE\\sqlserver都是从1开始计数：\n(n-1)*10+1 --- n*10  oracle的分页查询语句：\nselect *from ( select rownum r, t.* from (select s.* from student s order by sno asc) t 10000 ) where r\u0026gt;=(n-1)*10+1 and \u0026lt;=n*10 ;  优化：\nselect *from ( select rownum r, t.* from (select s.* from student s order by sno asc) t where rownum\u0026lt;=n*10 ) where r\u0026gt;=(n-1)*10+1 ;  select *from ( select rownum r, t.* from (select s.* from student s order by sno asc) t where rownum\u0026lt;=页数*页面大小 ) where r\u0026gt;=(页数-1)*页面大小+1 ;\t SQLServer分页 3种分页sql\nrow_number() over(字段) ;  sqlserver2003:top \u0026ndash;此种分页SQL存在弊端（如果id值不连续，则不能保证每页数据量相等）\nselect top 页面大小 * from student where id not in ( select top (页数-1)*页面大小 id from student order by sno asc )  sqlserver2005之后支持：\nselect *from ( select row_number() over (sno order by sno asc) as r,* from student where r\u0026lt;=n*10 ) where r\u0026gt;=(n-1)*10+1 and ;  SQLServer此种分页sql与oralce分页sql的区别： 1. rownum ，row_number()\n2. oracle需要排序（为了排序，单独写了一个子查询），但是在sqlserver 中可以省略该排序的子查询 因为sqlserver中可以通过over直接排序\nsqlserver2012之后支持\noffset fetch next only  select * from student oreder by sno offset (页数-1)*页面大小+1 rows fetch next 页面大小 rows only ;  (n-1)*10+1 --- n*10  mysql从0开始计数，Oracle/sqlserver 从1开始计数\n上传文件 引入2个jar\napache: commons-fileupload.jar组件 commons-fileupload.jar依赖 commons-io.jar  代码：\n前台jsp：\n\u0026lt;form action=\u0026quot;UploadServet\u0026quot; method=\u0026quot;post\u0026quot; enctype=\u0026quot;multipart/form-data\u0026quot;\u0026gt; 学号：\u0026lt;input name=\u0026quot;sno\u0026quot; /\u0026gt;\u0026lt;br/\u0026gt; 姓名：\u0026lt;input name=\u0026quot;sname\u0026quot; /\u0026gt;\u0026lt;br/\u0026gt; 上传照片: \u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;spicture\u0026quot;/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;注册\u0026quot;/\u0026gt; \u0026lt;/form\u0026gt;  表单提交方式必须为post\n在表单中必须增加一个属性 entype=\u0026quot;multipart/form-data\u0026quot;\n后台servlet：\nprotected void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException { request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); response.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); response.setContentType(\u0026quot;text/html; charset=UTF-8\u0026quot;); // 上传 // request.getParameter(\u0026quot;sname\u0026quot;) try { boolean isMultipart = ServletFileUpload.isMultipartContent(request); if (isMultipart) {// 判断前台的form是否有 mutipart属性 //\tFileItemFactory factory = new DiskFileItemFactory(); DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); //设置上传文件时 用到的临时文件的大小DiskFileItemFactory factory.setSizeThreshold(10240);//设置临时的缓冲文件大小为10 factory.setRepository(new File(\u0026quot;D:\\\\study\\\\uploadtemp\u0026quot;));//设置临时文件的目录 //控制上传单个文件的大小 20KB ServletFileUpload upload.setSizeMax(20480);//字节B Thread.sleep(3000); // 通过parseRequest解析form中的所有请求字段，并保存到 items集合中（即前台传递的sno sname // spicture此时就保存在了items中） List\u0026lt;FileItem\u0026gt; items = upload.parseRequest(request); // 遍历items中的数据（item=sno sname spicture） Iterator\u0026lt;FileItem\u0026gt; iter = items.iterator(); while (iter.hasNext()) { FileItem item = iter.next(); String itemName = item.getFieldName(); int sno = -1; String sname = null; // 判断前台字段 是普通form表单字段(sno sname)，还是文件字段 // request.getParameter() -- iter.getString() if (item.isFormField()) { if (itemName.equals(\u0026quot;sno\u0026quot;)) {// 根据name属性 判断item是sno sname 还是spicture? sno = Integer.parseInt(item.getString(\u0026quot;UTF-8\u0026quot;)); } else if (itemName.equals(\u0026quot;sname\u0026quot;)) { sname = item.getString(\u0026quot;UTF-8\u0026quot;); } else { System.out.println(\u0026quot;其他字段xxx.....\u0026quot;); } } else {// spicture 123 // 文件 上传 // 文件名 getFieldName是获取 普通表单字段的Name值 // getName()是获取 文件名 String fileName = item.getName();//a.txt a.docx a.png String ext = fileName.substring( fileName.indexOf(\u0026quot;.\u0026quot;)+1 ) ; if(!(ext.equals(\u0026quot;png\u0026quot;) || ext.equals(\u0026quot;gif\u0026quot;) ||ext.equals(\u0026quot;jpg\u0026quot;))) { System.out.println(\u0026quot;图片类型有误！格式只能是 png gif jpg\u0026quot;); return ;//终止 } // 获取文件内容 并上传 // 定义文件路径：指定上传的位置(服务器路径) // 获取服务器路径D:\\\\study\\\\apache-tomcat-8.5.30\\\\wtpwebapps\\\\UpAndDown\\\\upload // String path =request.getSession().getServletContext().getRealPath(\u0026quot;upload\u0026quot;) ; String path = \u0026quot;D:\\\\study\\\\upload\u0026quot;; File file = new File(path, fileName); item.write(file);// 上传 System.out.println(fileName + \u0026quot;上传成功！\u0026quot;); return; } } } } catch (FileUploadBase.SizeLimitExceededException e) {//SizeLimitExceededException是FileUploadException的一个子类 System.out.println(\u0026quot;上传文件大小超过限制！最大20KB\u0026quot;); } catch (FileUploadException e) { e.printStackTrace(); } // 解析请求 catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } }  注意的问题：\n上传的目录 upload ： 1. 如果修改代码，则在tomcat重新启动时 会被删除\n原因：当修改代码的时候,tomcat会重新编译一份class 并且重新部署（重新创建各种目录）   如果不修改代码，则不会删除\n原因： 没有修改代码，class仍然是之前的class\n  因此，为了防止 上传目录丢失 1. 虚拟路径 1. 直接更换上传目录 到非tomcat目录\n限制上传：\n类型、大小\n注意 对文件的限制条件 写再parseRequest之前\n下载 不需要依赖任何jar\n 请求（地址a form），请求Servlet\n Servlet通过文件的地址 将文件转为输入流 读到Servlet中 通过输出流 将 刚才已经转为输入流的文件 输出给用户  请求\n\u0026lt;a href=\u0026quot;DownloadServlet?filename=MIME.png\u0026quot;\u0026gt;MIME\u0026lt;/a\u0026gt;  servlet\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); //获取需要下载的文件名 String fileName = request.getParameter(\u0026quot;filename\u0026quot;) ;//form 、a href、 ...Server?a=b //下载文件：需要设置 消息头 response.addHeader(\u0026quot;content-Type\u0026quot;,\u0026quot;application/octet-stream\u0026quot; );//MIME类型:二进制文件（任意文件） //对于不同浏览器，进行不同的处理 //获取客户端的user-agent信息 String agent = request.getHeader(\u0026quot;User-Agent\u0026quot;); if(agent.toLowerCase().indexOf(\u0026quot;firefox\u0026quot;) !=-1) { //ff下载 文件名乱码问题 response.addHeader(\u0026quot;content-Disposition\u0026quot;,\u0026quot;attachment;filename==?UTF-8?B?\u0026quot;+ new String( Base64.encodeBase64(fileName.getBytes(\u0026quot;UTF-8\u0026quot;)) ) +\u0026quot;?=\u0026quot; );//fileName包含了文件后缀：abc.txt }else { //edge下载 文件名乱码问题 response.addHeader(\u0026quot;content-Disposition\u0026quot;,\u0026quot;attachment;filename=\u0026quot;+ URLEncoder.encode(fileName,\u0026quot;UTF-8\u0026quot;) );//fileName包含了文件后缀：abc.txt } //Servlet通过文件的地址 将文件转为输入流 读到Servlet中 InputStream in = getServletContext().getResourceAsStream(\u0026quot;/res/\u0026quot;+fileName) ; //通过输出流 将 刚才已经转为输入流的文件 输出给用户 ServletOutputStream out = response.getOutputStream() ; byte[] bs = new byte[10]; int len=-1 ; while( (len=in.read(bs)) != -1) { out.write(bs,0,len); } out.close(); in.close(); }  注意：下载文件 需要设置2个 响应头：\nresponse.addHeader(\u0026quot;content-Type\u0026quot;,\u0026quot;application/octet-stream\u0026quot; );//MIME类型:二进制文件（任意文件） response.addHeader(\u0026quot;content-Disposition\u0026quot;,\u0026quot;attachement;filename=\u0026quot;+fileName );//fileName包含了文件后缀：abc.txt  下载时 ，文件名乱码问题：\nedge：\nURLEncoder.encode(fileName,\u0026quot;UTF-8\u0026quot;)  firefox：\n给文件名 加：\n前缀\n=?UTF-8?B?  中间\nString构造方法 Base64.encode  后缀\n?=  示例：\nresponse.addHeader(\u0026quot;content-Disposition\u0026quot;,\u0026quot;attachment;filename==?UTF-8?B?\u0026quot;+ new String( Base64.encodeBase64(fileName.getBytes(\u0026quot;UTF-8\u0026quot;)) ) +\u0026quot;?=\u0026quot; );//fileName包含了文件后缀：abc.txt  ","id":21,"section":"posts","summary":"源码 JSP:动态网页 静态、动态： 不用 和 是否有“动感”混为一谈 是否随着时间、地点、用户操作的改变而改变 动态网页需要使用到服务端脚本语言（JSP","tags":["J2EE"],"title":"JSP学习笔记","uri":"https://mumulx.github.io/2019/11/jsp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" 源码\nEL Expression Launguage:可以代替JSp页面中的Java代码\n传统的在jsp代码中显示java代码 需要使用\u0026lt;%%\u0026gt;\u0026lt;%=%\u0026gt; 需要处理null 类型转换 代码参杂 \u0026mdash;》EL\nEL示例\n${域对象.域对象中的属性.对象属性的属性......级联属性} ${requestScope.student.sno}、 ${requestScope.student.address.homeAddress} ${requestScope.student[\u0026quot;address\u0026quot;]['schoolAddress']}  EL操作符：\n 点操作符. 使用方便 [\u0026quot;\u0026quot;] 或者['']操作符 功能强大：可以使用特殊字符(. 、 -) 获取变量值int a =10 ; [a]可以获取变量值10 加\u0026rdquo;\u0026ldquo;是常量，不加\u0026rdquo;\u0026ldquo;是变量,可以访问数组\n点操作符：$(requestScope.my-name) 不可以 [\u0026quot;\u0026quot;]操作符：$(requestScope['my-name']) 可以 数组：$(requestScope。hobbies[0]) 数组：$(requestScope。hobbies[1])   获取 map属性 map\nMap\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026quot;ud\u0026quot;,\u0026quot;df\u0026quot;); map.put(\u0026quot;dfs\u0026quot;,\u0026quot;dsfsdf\u0026quot;); request.setAttribute(\u0026quot;map\u0026quot;,map); ${requestScope.map.ud} ${requestScope.map[\u0026quot;dfs\u0026quot;]  ${9\u0026gt;8}、${9 gt 8} ${3\u0026gt;2||3\u0026lt;2\u0026gt;}、${3\u0026gt;2 or 3\u0026lt;2\u0026gt;}  Empty运算符\n判断一个值是否null，\n不存在或null:true\n存在:false\n${empty requestScope[\u0026quot;my-name\u0026quot;]}  EL表达式的隐式对象 不需要new就能使用的对象，自带的\n 作用域访问对象（EL域对象）\npageScopeScope requestScope sessionScope applicationScope  如果没指定域对象则从小到大一次查找\n 参数访问对象\n获取表单数据\\超链接地址栏的值 jsp :\nrequest.getParameter()request.getParameterValues()  EL\n${param} ${paramValues}  如\n${param.uname} ${paramValues.hobbies[0]} ${paramValues.hobbies[1]}  JSP隐式对象\npageContext\n在 jsp中可以使用pageContext获取其他jsp的隐式对象： 因此如果在EL中使用JSP隐式对象，就可以通过pageContext间接获取 ${pageContext.方法名去掉get并且将首字母小写} ${pageContext.request} ${pageContext.session}\n可以使用此方法获取级联对象\n${pageContext.request.serverPort}   JSTl JSTl比EL更加强大比EL更加强大\n需要引入jar包：\njstl.jar standard.jar  复制到lib\n引入tablib\n在jsp中导包\n\u0026lt;%@ uri=\u0026quot;http://java.sun.com/jsp/jstl/core\u0026quot; prefix=\u0026quot;c\u0026quot;%\u0026gt;  其中prefix=\u0026ldquo;c\u0026rdquo;：前缀\n核心标签库：通用标签库、条件标签库 迭代标签库\n通用标签库 \u0026lt;c:set\u0026gt;赋值  某个作用域（4个范围对象）中给某个变量赋值\n\u0026lt;c:set var=\u0026quot;属性名\u0026quot; value=\u0026quot;属性值\u0026quot; scope=\u0026quot;作用域\u0026quot;/\u0026gt; \u0026lt;c:set var=\u0026quot;name\u0026quot; value=\u0026quot;aaa\u0026quot; scope=\u0026quot;request\u0026quot;/\u0026gt;  在某个作用域中给某个对象（和map）的属性进行赋值,不需要指定scope属性\n\u0026lt;c:set target=\u0026quot;对象\u0026quot; property=\u0026quot;对象的属性\u0026quot; value=\u0026quot;赋值\u0026quot; /\u0026gt; ${requestScope.student.sname} \u0026lt;c:set target=\u0026quot;${requestScope.student}\u0026quot; property=\u0026quot;sname\u0026quot; value=\u0026quot;fdsdf\u0026quot;/\u0026gt;  给map对象赋值\n\u0026lt;c:set target=\u0026quot;${requestScope.countries}\u0026quot; property=\u0026quot;cn\u0026quot; value=\u0026quot;中国\u0026quot; /\u0026gt;  \u0026lt;c:set/\u0026gt;可以给不存在的变量赋值,不能给不存在的对象赋值\n\u0026lt;c：set var=\u0026quot;x\u0026quot; values= \u0026quot;dfg\u0026quot; dcope=\u0026quot;request\u0026quot;/\u0026gt;   \u0026lt;c:out\u0026gt; ：显示 传统EL：${requestScope.student }\u0026lt;br/\u0026gt; c:out方式：\u0026lt;c:out value=\u0026quot;${requestScope.student }\u0026quot; /\u0026gt;\u0026lt;br/\u0026gt; c:out显示不存在的数据：\u0026lt;c:out value=\u0026quot;${requestScope.stu }\u0026quot; default=\u0026quot;zs-23\u0026quot;/\u0026gt;\u0026lt;br/\u0026gt; true:\u0026lt;c:out value='\u0026lt;a href=\u0026quot;https://www.baidu.com\u0026quot;\u0026gt;百度\u0026lt;/a\u0026gt;' default=\u0026quot;当value为空的，显示的默认值\u0026quot; escapeXml=\u0026quot;true\u0026quot; /\u0026gt; 原样输出 false： \u0026lt;c:out value='\u0026lt;a href=\u0026quot;https://www.baidu.com\u0026quot;\u0026gt;百度\u0026lt;/a\u0026gt;' escapeXml=\u0026quot;false\u0026quot; /\u0026gt; 解析标签  \u0026lt;c:remove \u0026gt;：删除属性 \u0026lt;c:remove var=\u0026quot;a\u0026quot; scope=\u0026quot;request\u0026quot;/\u0026gt;  选择： if(boolean)\n单重选择\n\u0026lt;c:if test=\u0026quot;${1\u0026gt;2}\u0026quot;\u0026gt;\u0026lt;/c:if\u0026gt; \u0026lt;c:if test=\u0026quot;${1\u0026gt;2}\u0026quot; var=\u0026quot;result\u0026quot; scope=\u0026quot;request\u0026quot; \u0026gt;\u0026lt;/c:if\u0026gt;  将运算结果赋值为result并且放入scope域中\n多重选择\nif else if... esle if... else /switch  \u0026lt;c:choose\u0026gt; \u0026lt;c:when test=\u0026quot;${}\u0026quot;\u0026gt; \u0026lt;/c:when\u0026gt; \u0026lt;c:when test=\u0026quot;${}\u0026quot;\u0026gt; \u0026lt;/c:when\u0026gt; \u0026lt;c:when test=\u0026quot;${}\u0026quot;\u0026gt; \u0026lt;/c:when\u0026gt; \u0026lt;c:otherwise\u0026gt; \u0026lt;/c:otherwise\u0026gt; \u0026lt;/c:choose\u0026gt;  判断语句使用el语法\n在使用 test=\u0026ldquo;\u0026rdquo; 一定要注意后面是否有空格 例如：\ntest=\u0026quot;${10\u0026gt;2 }\u0026quot; true test=\u0026quot;${10\u0026gt;2 } \u0026quot; 非true true+\u0026quot; \u0026quot;==String  任何类型遇到字符串变成字符串\n循环（迭代标签库）\nfor(int i=0;i\u0026lt;=5;i++)  \u0026lt;c:forEach begin=\u0026quot;0\u0026quot; end=\u0026quot;5\u0026quot; step=\u0026quot;1\u0026quot; varStatus=\u0026quot;status\u0026quot;\u0026gt; ${status.index } 第几次 test.... \u0026lt;/c:forEach\u0026gt;  for(String str:names)  \u0026lt;c:forEach var=\u0026quot;student\u0026quot; items=\u0026quot;${requestScope.students }\u0026quot; \u0026gt; ${student.sname }-${student.sno } \u0026lt;/c:forEach\u0026gt;  过滤器： 实现一个Filter接口\ninit()、destroy() 原理、执行时机 同Servlet\n//要想将 一个普通的class 编程一个 具有特定功能的类（过滤器、拦截....），要么继承 父类、要么实现一个接口、要么增加一个注解 public class MyFilter implements Filter {//过滤器 @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\u0026quot;filter..init..\u0026quot;); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\u0026quot;拦截请求......\u0026quot;); chain.doFilter(request, response);//放行 System.out.println(\u0026quot;拦截响应......\u0026quot;); } @Override public void destroy() { System.out.println(\u0026quot;filter..destroy..\u0026quot;); } }  配置过滤器，类似servlet\n \u0026lt;!-- 配置过滤器 --\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;MyServlet\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.student.filter.MyFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;MyFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/MyServlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;  通过doFilter()处理拦截，并且通过chain.doFilter(request, response);放行\nfilter映射\n只拦截 访问MyServlet的请求\n\u0026lt;url-pattern\u0026gt;/MyServlet\u0026lt;/url-pattern\u0026gt;  拦截一切请求（每一次访问 都会被拦截）\n\u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt;  通配符\ndispatcher请求方式：\nREQUEST：拦截HTTP请求 get post FORWARD：只拦截 通过 请求转发方式的请求 INCLUDE:只拦截拦截通过 request.getRequestDispatcher(\u0026quot;\u0026quot;).include() 、通过\u0026lt;jsp:include page=\u0026quot;...\u0026quot; /\u0026gt;此种方式发出的请求 ERROR：只拦截\u0026lt;error-page\u0026gt;发出的请求  过滤器中doFilter方法参数：ServletRequest\n在Servlet中的方法参数：HttpServletRequest\n\u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;MyServlet\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;dispatcher\u0026gt;REQUEST\u0026lt;/dispatcher\u0026gt; \u0026lt;dispatcher\u0026gt;FORWARD\u0026lt;/dispatcher\u0026gt; \u0026lt;/filter-mapping\u0026gt;  过滤器链\n可以配置多个过滤器，过滤器的先后顺序 是由 \u0026lt;filter-mapping\u0026gt;的位置 决定\n监听器 一个类实现了三个接口\n监听对象的创建销毁\n\u0026mdash;四个范围对象 PageContext request session application\n监听对象request response application 各自一个监听器\nrequest：ServletRequestListener response：HttpSessionListener application：ServletContextListener  每个监听器提供了两个方法 一个开始一个结束\nServletContext在Servlet启动时自动创建\n //监听器实现接听接口 public class ContextSessionRequestListner implements ServletRequestListener,HttpSessionListener,ServletContextListener{ //application（ServletContext） public void contextDestroyed(ServletContextEvent arg0) { System.out.println(\u0026quot;监听ServletConntext，创建Servlet对象........\u0026quot;+arg0); } public void contextInitialized(ServletContextEvent arg0) { System.out.println(\u0026quot;监听ServletConntext，销毁Servlet对象........\u0026quot;+arg0); } //session public void sessionCreated(HttpSessionEvent se) { System.out.println(\u0026quot;监听HttpSession，创建HttpSession对象........\u0026quot;+se); } public void sessionDestroyed(HttpSessionEvent se) { System.out.println(\u0026quot;监听HttpSession,销毁HttpSession对象........\u0026quot;+se); } //request public void requestDestroyed(ServletRequestEvent sre) { System.out.println(\u0026quot;监听ServletRequest,销毁ServletRequest对象........\u0026quot;+sre); } public void requestInitialized(ServletRequestEvent sre) { System.out.println(\u0026quot;初始化ServletRequest,创建ServletRequest对象........\u0026quot;+sre); } }  web.xml配置监听器\n\u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;org.ycit.listner.ContextSessionRequestListner\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt;  监听对象属性的变更 request：ServletRequestAttributeListener response：HttpSessionAttributeListener application：ServletServletContextAttributeListener  每个方法有三个方法(创建、删除、修改)\n public class AttributeListener implements ServletRequestAttributeListener,HttpSessionAttributeListener,ServletContextAttributeListener{ public void attributeAdded(ServletContextAttributeEvent arg0) { String attrName = arg0.getName(); Object attrValue = arg0.getServletContext().getAttribute(attrName); System.out.println(\u0026quot;ServletContex【增加】属性\u0026quot;+attrName+\u0026quot;属性值: \u0026quot;+attrValue); } @Override public void attributeRemoved(ServletContextAttributeEvent arg0) { System.out.println(\u0026quot;ServletContex【删除】属性\u0026quot;+arg0.getName()); } public void attributeReplaced(ServletContextAttributeEvent arg0) { String attrName = arg0.getName(); Object attrValue = arg0.getServletContext().getAttribute(attrName); System.out.println(\u0026quot;ServletContex【替换】属性\u0026quot;+attrName+\u0026quot;属性值: \u0026quot;+attrValue); } public void attributeAdded(HttpSessionBindingEvent arg0) { } public void attributeRemoved(HttpSessionBindingEvent arg0) { } public void attributeReplaced(HttpSessionBindingEvent arg0) { } public void attributeAdded(ServletRequestAttributeEvent srae) { } public void attributeRemoved(ServletRequestAttributeEvent srae) { } public void attributeReplaced(ServletRequestAttributeEvent srae) { } }  配置 web.xml\n\u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt;  session钝化 客户端访问服务器会分配session对象(在内存中) 当访问量很多的时候会使得内存放不下 我们可以将session放入硬盘中(钝化)\n从硬盘取到内存中叫活化\nsession对象的四种状态： 不需要配xml\n监听绑定和解绑HttpSessionBindingListener\n监听Session对象的钝化和活HttpSessionActivationListener\n session.setAttribute(\u0026ldquo;aa\u0026rdquo;,\u0026ldquo;dfg\u0026rdquo;)对象aa绑定到session中(增加)\n session.removeAttribute(\u0026ldquo;aa\u0026rdquo;) 将对象aa从session中解绑(删除)\n每次访问时会先后创建session对象，然后再删除之前绑定的session对象\n 钝化\n 活化\n方法WillPa 监听钝化之前\nDid 刚刚进行活化之后\n  如何钝化和活化\n钝化\n配置 tomcat安装目录/conf/context.xml\n添加； 最大空闲时间；5秒钟没访问就钝化\n\u0026lt;Manager className=\u0026quot;org.apache.catalina.session.PersistentManager\u0026quot; maxIdleSwap=\u0026quot;5\u0026quot;\u0026gt; \u0026lt;Store className=\u0026quot;apache.catalina.session.FileStore\u0026quot; directory=\u0026quot;aqa\u0026quot;/\u0026gt; \u0026lt;/Manager\u0026gt;  FileStore:拖过该类具体操作 directory:相对路径 相对于tomcat/work/Catalina/localhost/项目名/aqa  活化:自动活化\n两个本质：序列化反序列化 需要借助Serializable接口\n类名 implements HttpSessionActivationListener,Serializable  总结： 钝化活化实际的执行是通过tomcat中的context.xml中进行配置\nHttpSessionActivationListener只是负责session钝化和活化时予以监听\n需要实现Serializable接口\n活化：session中获取某一个对象时，如果该对象不存在时，则直接尝试从之前钝化的文件中去获取(活化)\nAjax 异步js 和 xml\n异步刷新： 如果网页中某一个地方需要修改，异步刷新可以使：只刷新该需要修改的地方，而页面中其他地方 保持不变。例如：百度搜索框、视频的点赞\n实现：\njs: XMLHttpRequest对象\nXMLHttpRequest对象的方法：\nopen(方法名(提交方式get|post),服务器地址,true) :与服务端建立连接true异步刷新，false全局刷新 send(): get: send(null) post: send(参数值) setRequestHeader(header,value): get:不需要设置此方法 post:需要设置： a.如果请求元素中包含了 文件上传: setRequestHeader(\u0026quot;Content-Type\u0026quot;,\u0026quot;multipart/form-data\u0026quot;); b.不包含了 文件上传 setRequestHeader(\u0026quot;Content-Type\u0026quot;,\u0026quot;application/x-www-form-urlencoded\u0026quot;)  XMLHttpRequest对象的属性：\nreadyState:请求状态 只有状态为4 代表请求完毕 status:响应状态 只有200 代表响应正常 onreadystatechange:回调函数 responseText：响应格式为String responseXML：相应格式为XML  js \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; function register() { var mobile = document.getElementById(\u0026quot;mobile\u0026quot;).value; //通过ajax异步方式 请求服务端 xmlHttpRequest = new XMLHttpRequest(); //设置xmlHttpRequest对象的回调函数 xmlHttpRequest.onreadystatechange = callBack ; xmlHttpRequest.open(\u0026quot;post\u0026quot;,\u0026quot;MobileServlet\u0026quot;,true); //设置post方式的 头信息 xmlHttpRequest.setRequestHeader(\u0026quot;Content-Type\u0026quot;,\u0026quot;application/x-www-form-urlencoded\u0026quot;); } function registerGet() { var mobile = document.getElementById(\u0026quot;mobile\u0026quot;).value; //通过ajax异步方式 请求服务端 xmlHttpRequest = new XMLHttpRequest(); //设置xmlHttpRequest对象的回调函数 xmlHttpRequest.onreadystatechange = callBack ; xmlHttpRequest.open(\u0026quot;get\u0026quot;,\u0026quot;MobileServlet?mobile=\u0026quot;+mobile,true); //设置post方式的 头信息 ,get不需要 //xmlHttpRequest.setRequestHeader(\u0026quot;Content-Type\u0026quot;,\u0026quot;application/x-www-form-urlencoded\u0026quot;); xmlHttpRequest.send(null);//k=v } //定义回调函数 (接收服务端的返回值) function callBack(){ if(xmlHttpRequest.readyState ==4 \u0026amp;\u0026amp; xmlHttpRequest.status ==200){ //接收服务端返回的数据 var data = xmlHttpRequest.responseText ;//服务端返回值为string格式 alert(data.length +\u0026quot;===\u0026quot;+data) if(data == \u0026quot;true\u0026quot;){ alert(\u0026quot;请号码已存在,请更换！\u0026quot;); }else{ alert(\u0026quot;注册成功！\u0026quot;); } } } \u0026lt;/script\u0026gt;  手机：\u0026lt;input id=\u0026quot;mobile\u0026quot;/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;注册\u0026quot; onclick=\u0026quot;registerGet()\u0026quot; /\u0026gt;  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); response.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); response.setContentType(\u0026quot;text/html; charset=UTF-8\u0026quot;); String mobile = request.getParameter(\u0026quot;mobile\u0026quot;) ; //假设此时 数据库中 只有一个号码：18888888888 //if(mobile.equals(\u0026quot;18888888888\u0026quot;)) { PrintWriter out = response.getWriter(); if(\u0026quot;18888888888\u0026quot;.equals(mobile)) { //return true ; //out.write(\u0026quot;true\u0026quot;);//servlet以输出流的方式 将信息 返回给客户端 //out.write(\u0026quot;此号码已存在！\u0026quot;); //如果客户端是getJSON(),则需要以json格式返回数据 out.write( \u0026quot;{\\\u0026quot;msg\\\u0026quot;:\\\u0026quot;true\\\u0026quot;}\u0026quot; );// {\u0026quot;\\\u0026quot;msg\\\u0026quot;:\\\u0026quot;true\\\u0026quot;\u0026quot;} }else { //return false ; //out.write(\u0026quot;false\u0026quot;); //out.write(\u0026quot;注册成功！\u0026quot;); out.write( \u0026quot;{\\\u0026quot;msg\\\u0026quot;:\\\u0026quot;false\\\u0026quot;}\u0026quot; );// \u0026quot;\\\u0026quot;msg\\\u0026quot;:\\\u0026quot;false\\\u0026quot;\u0026quot; } out.close(); }  jquery:推荐 $.ajax({ url:服务器地址, 请求方式:get|post, data:请求数据, success:function(result,testStatus) { }, error:function(xhr,errrorMessage,e){ } });  $.get( 服务器地址, 请求数据, function (result){ }, 预期返回值类型（string\\xml） );  $.post( 服务器地址, 请求数据, function (result){ }, \u0026quot;xml\u0026quot; 或 \u0026quot;json\u0026quot; 或 \u0026quot;text\u0026quot; );  $(xxx).load( 服务器地址, 请求数据 );  load:将服务端的返回值 直接加载到$(xxx)所选择的元素中 JSON\n$.getJSON( 服务器地址, JSON格式的请求数据, function (result){ } );  \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; function register() { var $mobile = $(\u0026quot;#mobile\u0026quot;).val(); /* $.ajax({ url:\u0026quot;MobileServlet\u0026quot;, 请求方式:\u0026quot;post\u0026quot;, data:\u0026quot;mobile=\u0026quot;+$mobile, success:function(result,testStatus) { if(result == \u0026quot;true\u0026quot;){ alert(\u0026quot;已存在！注册失败！\u0026quot;); }else{ alert(\u0026quot;注册成功！\u0026quot;); } }, error:function(xhr,errrorMessage,e){ alert(\u0026quot;系统异常！\u0026quot;); } }); $.post( \u0026quot;MobileServlet\u0026quot;, \u0026quot;mobile=\u0026quot;+$mobile, function (result){ if(result == \u0026quot;true\u0026quot;){ alert(\u0026quot;已存在！注册失败！\u0026quot;); }else{ alert(\u0026quot;注册成功！\u0026quot;); } }, \u0026quot;text\u0026quot; ); $.get( \u0026quot;MobileServlet\u0026quot;, \u0026quot;mobile=\u0026quot;+$mobile, function (result){ if(result == \u0026quot;true\u0026quot;){ alert(\u0026quot;已存在！注册失败！\u0026quot;); }else{ alert(\u0026quot;注册成功！\u0026quot;); } } ); $(\u0026quot;#tip\u0026quot;).load( \u0026quot;MobileServlet\u0026quot;, \u0026quot;mobile=\u0026quot;+$mobile ); var student = {\u0026quot;name\u0026quot;:\u0026quot;zs\u0026quot; , \u0026quot;age\u0026quot;:23} ; //alert(student.name +\u0026quot;--\u0026quot; +student.age) ; //var name = [\u0026quot;xx\u0026quot;,\u0026quot;xx\u0026quot;,\u0026quot;xx\u0026quot;] ; var students =[ {\u0026quot;name\u0026quot;:\u0026quot;zs\u0026quot; , \u0026quot;age\u0026quot;:23} , {\u0026quot;name\u0026quot;:\u0026quot;ls\u0026quot; , \u0026quot;age\u0026quot;:24} , {\u0026quot;name\u0026quot;:\u0026quot;ww\u0026quot; , \u0026quot;age\u0026quot;:25} ]; alert(students[1].name +\u0026quot;--\u0026quot; +students[1].age) ; */ $.getJSON( \u0026quot;MobileServlet\u0026quot;, //\t\u0026quot;mobile=\u0026quot;+$mobile, {\u0026quot;mobile\u0026quot;:$mobile}, function (result){//msg:true|false alert(123); if(result.msg == \u0026quot;true\u0026quot;){ alert(\u0026quot;已存在！注册失败！\u0026quot;); }else{ alert(\u0026quot;注册成功！\u0026quot;); } } ); } \u0026lt;/script\u0026gt;  手机：\u0026lt;input id=\u0026quot;mobile\u0026quot;/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;注册\u0026quot; onclick=\u0026quot;register()\u0026quot; /\u0026gt; \u0026lt;span id=\u0026quot;tip\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;  Ajax处理JSON数据 jar包\ncommons-beanutils-1.7.0.jar commons-lang-2.6.jar commons-collections-3.2.1.jar commons-logging-1.1.3.jar ezmorph-1.0.6.jar json-lib-2.4-jdk15.jar  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); response.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); response.setContentType(\u0026quot;text/html; charset=UTF-8\u0026quot;); PrintWriter out = response.getWriter(); //测试前端传来的数据 String name2 = request.getParameter(\u0026quot;name\u0026quot;) ; String age2 = request.getParameter(\u0026quot;age\u0026quot;) ; System.out.println(name2+\u0026quot;--\u0026quot;+age2); Student stu1 = new Student(); stu1.setAge(23); stu1.setName(\u0026quot;zs\u0026quot;); Student stu2 = new Student(); stu2.setAge(44); stu2.setName(\u0026quot;ls\u0026quot;); Student stu3 = new Student(); stu3.setAge(55); stu3.setName(\u0026quot;ww\u0026quot;); JSONObject json = new JSONObject() ; json.put(\u0026quot;stu1\u0026quot;,stu1 ) ; json.put(\u0026quot;stu2\u0026quot;,stu2 ) ; json.put(\u0026quot;stu3\u0026quot;,stu3 ) ; out.print( json);// 返回json对象 {\u0026quot;stu1\u0026quot;:stu1, \u0026quot;stu2\u0026quot;:stu2,\u0026quot;stu3\u0026quot;:stu3 } out.close(); }  /* json中只有一个对象的情况 function testJson() { $.getJSON( \u0026quot;JsonServlet\u0026quot;, {\u0026quot;name\u0026quot;:\u0026quot;zs\u0026quot;, \u0026quot;age\u0026quot;:24}, function (result){ //js需要通过eval()函数 将返回值 转为一个js能够识别的json对象 var jsonStudent = eval(result.stu1) ; alert(jsonStudent.name +\u0026quot;---\u0026quot;+ jsonStudent.age) ; } ); } */ /* json中有多对象的情况*/ function testJson() { $.getJSON( \u0026quot;JsonServlet\u0026quot;, {\u0026quot;name\u0026quot;:\u0026quot;zs\u0026quot;, \u0026quot;age\u0026quot;:24}, function (result){ // result： {\u0026quot;stu1\u0026quot;:stu1, \u0026quot;stu2\u0026quot;:stu2,\u0026quot;stu3\u0026quot;:stu3 } //js需要通过eval()函数 将返回值 转为一个js能够识别的json对象 var json = eval(result) ; $.each( json, function(i,element){ alert( this.name +\u0026quot;---\u0026quot;+ this.age ); } ); } ); }  IDEA开发Web 配置tomcat run\u0026ndash;》Edit Configurations\u0026ndash;\u0026gt;点击加号\u0026ndash;\u0026gt;Tomcat Server\n选择tomcat，jre\nDeployment部署项目，设置项目名\nidea中tomcat乱码：  file - settings - 搜File Encodings,全部改为utf-8 打开idea安装目录/bin，在idea64.exe.vmoptions和idea.exe.vmoptions最后追加\n-Dfile.encoding=UTF-8  配置tomcat的页面中：VM option设置：\n-Dfile.encoding=UTF-8   热部署问题(jsp+java) 在配置tomcat的页面\n Update:更新操作（经过测试，很多时候无效） Frame:idea失去焦点时触发  推荐选项：\n Update：任意 Frame:update classes and resources  idea：热部署\n 如果是run启动，仅JSP等静态资源有效 如果是debug启动，java和jsp等均有效  总结 热部署：\n Frame:update classes and resources 以debug模式启动  注意：编写servlet前 需要先加入tomcat环境\n打开Project Structure \u0026ndash;》Modules \u0026ndash;\u0026gt;右边加号\u0026ndash;\u0026gt;Library\u0026ndash;》tomcat\nServlet3.0注解方式的参数设置访问路径的为url-pattern,也是默认值，值中要含有项目根目录/;例\n@javax.servlet.annotation.WebServlet( \u0026quot;/MyServlet\u0026quot;)  注意注解参数的值中有没有url-pattern,和值正不正确\n自动导包\nSettings\u0026ndash;\u0026gt;Editor\u0026ndash;\u0026gt;General\u0026ndash;\u0026gt;Auto Import\nJNDI java命名与目录接口\npageContext \u0026lt; request\u0026lt; session\u0026lt; application(一个项目运行期间都有效)\njndi:将某一个资源（对象），以配置文件(tomcat/conf/context.xml)的形式写入；\n实现步骤：\ntomcat/conf/context.xml配置：\n\u0026lt;Context\u0026gt; \u0026lt;Environment name=\u0026quot;jndiName\u0026quot; value=\u0026quot;jndiValue\u0026quot; type=\u0026quot;java.lang.String\u0026quot; /\u0026gt;  jsp中用：\n\u0026lt;% Context ctx = new InitialContext() ; String testJndi = (String)ctx.lookup(\u0026quot;java:comp/env/jndiName\u0026quot;); out.print(testJndi); %\u0026gt;  DIEA JAR包  java项目\n复制粘贴jar包\u0026ndash;》右键Add as Library\n Web项目\n WEB-INF新建目录lib\n 将jar包复制到目录\n Project Structure\u0026ndash;\u0026gt;Artifacts\u0026ndash;\u0026gt;右边添加文件夹lib\n   Eclipse中的web项目引入jar:只需要 jar 放入web-context/lib/xx.jar,Eclipse就会将web-context/lib/中的所有jar存放到项目的全部生命周期中\nIDEA：会将web-context/lib/中的所有jar包，只存在于运行阶段生效\n开发（编写、编译）- 运行(commons-dbcp.jar )\n即idea中Web-Content/lib/的jar，只在运行时生效，在其他阶段不生效。\n解决方案： gradle/maven\n手工解决（了解）:原理-结论\n jar包本身只在 运行时有效(ojdbc.jar)\n Class.forName() DriverManager.getCOnnection() Presss Connection  处理办法：\n 只需要将jar复制在Web-Content/lib/ojdbc7.jar\n问题：有时候延迟较长\n Structure - Artifacts - output\n   2.commons-dbcp.jar （开发时、运行均有效）\nWeb-Content/lib/commons-dbcp.jar --只在运行时有效 手工解决： 将commons-dbcp.jar 在开发时也有效： 直接将jar复制到工程src中，右键-Add as Library...  常见错误：\n仅仅将jar引用在了Dependencies中，并且将jar的生命周期选择为了compile -错误\n错误原因：\nweb项目结构：web约定jar是存放在lib中\n总结论：\n java项目，和eclipse,在项目src中复制粘贴jar包右键 add as library web项目：\n jar本身就只在运行阶段有效ojdbc.jar\n只需要复制Web-Content/lib/中即可。\n jar在各个阶段均有效\n要复制Web-Content/lib/中即可\n再复制src中，右键-Add as library\u0026hellip;\n   或Project Structure中Modules添加jar包\n连接池 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。\n常见连接池：Tomcat-dbcp、dbcp、c3p0、druid\n可以用数据源(javax.sql.DataSource)管理连接池\nTomcat-dbcp  类似jndi,在context.xml中配置数据库\n\u0026lt;Context\u0026gt; \u0026lt;Resource name=\u0026quot;student\u0026quot; auth=\u0026quot;Container\u0026quot; type=\u0026quot;javax.sql.DataSource\u0026quot; maxActive=\u0026quot;400\u0026quot; maxIdle=\u0026quot;20\u0026quot; maxWait=\u0026quot;5000\u0026quot; username=\u0026quot;scott\u0026quot; password=\u0026quot;tiger\u0026quot; driverClassName=\u0026quot;oracle.jdbc.driver.OracleDriver\u0026quot; url=\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026quot; /\u0026gt;  在项目的web.xml中\n\u0026lt;resource-ref\u0026gt; \u0026lt;res-ref-name\u0026gt;student\u0026lt;/res-ref-name\u0026gt; \u0026lt;res-type\u0026gt;javax.sql.DataSource\u0026lt;/res-type\u0026gt; \u0026lt;res-auth\u0026gt;Container\u0026lt;/res-auth\u0026gt; \u0026lt;/resource-ref\u0026gt;  使用数据源\n更改 连接对象Connection的获取方式 ：\n 传统Jdbc方式\nconnection = DriverManager.getConnection(URL,USERNAME,PASSWORD);  数据源方式：\nContext ctx = new InitialContext() ;//context.xml DataSource ds = (DataSource)ctx.lookup(\u0026quot;java:comp/env/student\u0026quot;) ; connection = ds.getConnection();    tomcat-dbcp数据源总结：\n 配置数据源（context.xml）\n 指定数据源（web.xml） 用数据源 ：通过数据库获取Connection  dbcp连接池 Jar包\ncommons-dbcp-1.4.jar commons-pool.jar  连接池：\n怎么用？ * 不用连接池\n Class.forName(); Connection connection = DriverManager.getConnection();//连接指向数据库   用连接池的核心：将连接的指向改了，现在指向的是数据源 而不是数据库。\n....-\u0026gt; DataSource ds = .... Connection connection =ds.getConnection();//指向的是数据源的连接   数据库访问核心 -\u0026gt; pstmt/stmt -\u0026gt;connection\n 直接数据库 数据源 ds.getConnection()\nPreparedStatemnt pstmt = connection.preparedStatement();   dbcp获取ds:\n1. BasicDataSource 2. BasicDataSourceFactory  BasicDataSource方式 （硬编码）：DasicDataSource对象设置各种数据\n//获取dbcp方式的ds对象 public static DataSource getDataSourceWIthDBCP(){ BasicDataSource dbcp = new BasicDataSource(); dbcp.setDriverClassName(\u0026quot;oracle.jdbc.driver.OracleDriver\u0026quot;); dbcp.setUrl(\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026quot;); dbcp.setUsername(\u0026quot;scott\u0026quot;); dbcp.setPassword(\u0026quot;tiger\u0026quot;); dbcp.setInitialSize(20); dbcp.setMaxActive(10); return dbcp; }  getDataSourceWIthDBCP().getConnection()  BasicDataSourceFactory方式 配置方式（.properties文件, 编写方式key=value）\ndbcpconfig.properties\ndriverClassName=oracle.jdbc.driver.OracleDriver url=jdbc:oracle:thin:@127.0.0.1:1521:ORCL username=scott password=tiger initialSize=10  public static DataSource getDataSourceWIthDBCPByProperties() throws Exception{ DataSource dbcp = null ; Properties props = new Properties(); InputStream input = new DBCPDemo().getClass().getClassLoader().getResourceAsStream(\u0026quot;dbcpconfig.properties\u0026quot;); props.load(input); //只需要记住以下一句 dbcp = BasicDataSourceFactory.createDataSource(props) ; return dbcp; }  getDataSourceWIthDBCPByProperties().getConnection();  报错：NoClassDefFoundError异常 说明少jar\nDataSource 是所有sql数据源的上级类。BasicDataSource是dbcp类型的数据源,ComboPooledDataSource是c3p0类型的数据源；XxxDataSource\u0026hellip;\n###c3p0连接池\n两种方式\n 硬编码 配置文件  -\u0026gt;合二为一 ，通过ComboPooledDataSource的构造方法参数区分：\n 如果无参，硬编码； 有参，配置文件  jar包\nc3p0.jar c3p0-oracle-thin-extras.jar  无参，硬编码 public static DataSource getDataSourceWithC3P0(){ ComboPooledDataSource c3p0 = new ComboPooledDataSource(); try { c3p0.setDriverClass(\u0026quot;oracle.jdbc.driver.OracleDriver\u0026quot;); } catch (PropertyVetoException e) { e.printStackTrace(); } c3p0.setJdbcUrl(\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026quot;); c3p0.setUser(\u0026quot;scott\u0026quot;); c3p0.setPassword(\u0026quot;tiger\u0026quot;); return c3p0 ; }  有参，配置文件 c3p0-config.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;c3p0-config\u0026gt; \u0026lt;default-config\u0026gt; \u0026lt;!-- 如果要研究某个xml中可以设置哪些属性。找相关类的 属性 或者setXxx()--\u0026gt; \u0026lt;property name=\u0026quot;user\u0026quot;\u0026gt;scott\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot;\u0026gt;tiger\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;driverClass\u0026quot;\u0026gt;oracle.jdbc.driver.OracleDriver\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jdbcUrl\u0026quot;\u0026gt;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;checkoutTimeout\u0026quot;\u0026gt;30000\u0026lt;/property\u0026gt; \u0026lt;/default-config\u0026gt; \u0026lt;named-config name=\u0026quot;yanqun\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;user\u0026quot;\u0026gt;scott\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot;\u0026gt;tiger\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;driverClass\u0026quot;\u0026gt;oracle.jdbc.driver.OracleDriver\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jdbcUrl\u0026quot;\u0026gt;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;checkoutTimeout\u0026quot;\u0026gt;20000\u0026lt;/property\u0026gt; \u0026lt;/named-config\u0026gt; \u0026lt;/c3p0-config\u0026gt;  public static DataSource getDataSourceWithC3P0ByXml(){ ComboPooledDataSource c3p0 = new ComboPooledDataSource(\u0026quot;yanqun\u0026quot;); return c3p0 ; }  oralce修改密码：\n管理员状态 sqlplus / as sysdba\nalter user scott identified by tiger ;  所有连接池的思路：\n 硬编码，某个连接池数据源的\n对象 ds = new XxxDataSource(); ds.setXxx(); return ds ;  配置文件\nds = new XxxDataSource();加载配置文件 ,return ds ;   数据源工具类 dbcp、c3p0, druid\npublic class DataSourceUtil { //获取dbcp方式的ds对象 public static DataSource getDataSourceWIthDBCP(){ BasicDataSource dbcp = new BasicDataSource(); dbcp.setDriverClassName(\u0026quot;oracle.jdbc.driver.OracleDriver\u0026quot;); dbcp.setUrl(\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026quot;); dbcp.setUsername(\u0026quot;scott\u0026quot;); dbcp.setPassword(\u0026quot;tiger\u0026quot;); dbcp.setInitialSize(20); dbcp.setMaxActive(10); return dbcp; } public static DataSource getDataSourceWIthDBCPByProperties() throws Exception{ DataSource dbcp = null ; Properties props = new Properties(); InputStream input = new DBCPDemo().getClass().getClassLoader().getResourceAsStream(\u0026quot;dbcpconfig.properties\u0026quot;); props.load( input ); //只需要记住以下一句 dbcp = BasicDataSourceFactory.createDataSource(props ) ; return dbcp; } public static DataSource getDataSourceWithC3P0(){ ComboPooledDataSource c3p0 = new ComboPooledDataSource(); try { c3p0.setDriverClass(\u0026quot;oracle.jdbc.driver.OracleDriver\u0026quot;); } catch (PropertyVetoException e) { e.printStackTrace(); } c3p0.setJdbcUrl(\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026quot;); c3p0.setUser(\u0026quot;scott\u0026quot;); c3p0.setPassword(\u0026quot;tiger\u0026quot;); return c3p0 ; } public static DataSource getDataSourceWithC3P0ByXml(){ ComboPooledDataSource c3p0 = new ComboPooledDataSource(\u0026quot;yanqun\u0026quot;); return c3p0 ; } }  Apache DBUtils jar\ncommons-dbutils-1.7.jar  其中包含以下几个重点类：\nDbUtils、QueryRunner、ResultSetHandler   DbUtils：辅助 QueryRunner：增删改查\nupdate() query()  oracle:dml,commit\nmysql:dml自动提交\n 如果是查询，则需要ResultSetHandler接口，有很多实现类,一个实现类对应于一种 不同的查询结果类型\n  实现类ArrayHandler ：返回结果集中的第一行数据，并用Object[]接收\n//select *from student ; -\u0026gt; List\u0026lt;Student\u0026gt; //查询单行数据 public static void testArrayHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 Object[] student = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new ArrayHandler(),1) ; System.out.println( student[0]+\u0026quot;,\u0026quot;+student[1]); }  实现类ArrayListHandler：返回结果集中的多行数据， List\u0026lt;Object[]\u0026gt;\n//查询单多数据 public static void testArrayListHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 List\u0026lt;Object[]\u0026gt; students = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new ArrayListHandler(),1) ; for(Object[] student:students){ System.out.println( student[0]+\u0026quot;,\u0026quot;+student[1]); } }  BeanHandler ：返回结果集中的第一行数据，用对象(Student)接收\n//查询单行数据(放入对象中) public static void testBeanHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 Student student = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new BeanHandler\u0026lt;Student\u0026gt;(Student.class),1) ; System.out.println( student.getId()+\u0026quot;,\u0026quot;+student.getName()); }  BeanListHandler：返回结果集中的多行数据， List\u0026lt;Student\u0026gt; students, stu stu2 stu3\n //查询多行数据(放入对象中) public static void testBeanListHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 List\u0026lt;Student\u0026gt; students = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new BeanListHandler\u0026lt;Student\u0026gt;(Student.class),1) ; for(Student student:students){ System.out.println( student.getId()+\u0026quot;,\u0026quot;+student.getName()); } }  BeanMapHandler\n1:stu1,2:stu2.3:stu3\n//查询多行数据(放入map中) public static void testBeanMapHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 -- java中对应oracle默认的数值类型 BigDecimal Map\u0026lt;BigDecimal,Student\u0026gt; students = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new BeanMapHandler\u0026lt;BigDecimal,Student\u0026gt;( Student.class,\u0026quot;id\u0026quot; ),1) ; // 2: ls, 3:ww Student stu = students.get(new BigDecimal(2)) ; System.out.println(stu.getId()+\u0026quot;,\u0026quot;+stu.getName()); }  反射会通过无参构造来创建对象\n\u0026ndash; Map\nMapHandler:：返回结果集中的第一行数据\n{id=1 ,name=zs}\n//查询单行数据 map public static void testMapHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 Map\u0026lt;String,Object\u0026gt; student = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new MapHandler(),1) ; System.out.println( student); }  MapListHandler：返回结果集中的多行数据\n{{id=2 ,name=ls}，{id=3 ,name=ww}}\n//查询多行数据 map public static void testMapListHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 List\u0026lt;Map\u0026lt;String,Object\u0026gt;\u0026gt; students = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new MapListHandler(),1) ; System.out.println( students); }  KeyedHanlder:\n{ls={id=2 ,name=ls}，ww={id=3 ,name=ww}}\n//查询多行数据 keyed public static void testKeyedHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 Map\u0026lt;String,Map\u0026lt;String,Object\u0026gt;\u0026gt; students = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new KeyedHandler\u0026lt;String\u0026gt;(\u0026quot;name\u0026quot;),1) ; System.out.println( students); }  ColumnListHander ：把结果集中的某一列 保存到List中\n//查询多行数据中的某一列 public static void testColumnListHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 List\u0026lt;String\u0026gt; names = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new ColumnListHandler\u0026lt;String\u0026gt;(\u0026quot;name\u0026quot;),1) ; System.out.println( names); }  ScalarHandler ：单值结果\n//查询单值数据 public static void testScalarHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 // BigDecimal result = runner.query(\u0026quot;select name from student where id = ? \u0026quot; ,new ScalarHandler\u0026lt;BigDecimal\u0026gt;(),2) ; String result = runner.query(\u0026quot;select name from student where id = ? \u0026quot; ,new ScalarHandler\u0026lt;String\u0026gt;(),2) ; System.out.println( result); }  问题：查询的实现类的参数问题\nquery(..., Object... params )  其中Object\u0026hellip; params代表可变参数： 既可以写单值，也可以写一个数组\nrunner.query(\u0026quot;... where id = ? and name like ? \u0026quot; ,new ArrayHandler(),new Object[]{1,\u0026quot;%s%\u0026quot;}) ; runner.query(\u0026quot;... where id = ?\u0026quot; ,new ArrayHandler(),1) ;  apache dbutils 增删改 自动提交事务 update(sql,参数);update(sql);\n手动提交事务 update(connection ,sql,参数);\npublic static void add() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0()) ; int count = runner.update( \u0026quot;insert into student(id,name) values(?,?)\u0026quot;,new Object[]{4,\u0026quot;zl\u0026quot;} ) ; System.out.println(count); } public static void delete() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0()) ; int count = runner.update( \u0026quot;delete from student where id = ?\u0026quot;,4 ) ; System.out.println(count); } public static void update() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0()) ; int count = runner.update( \u0026quot;update student set name = ? where id = ?\u0026quot;,new Object[]{\u0026quot;xx\u0026quot;,3} ) ; System.out.println(count); }  手动提交事务 基础知识：\n如果既要保证数据安全，又要保证性能，可以考虑ThreadLocal\nThreadLocal:可以为每个线程 复制一个副本。每个线程可以访问自己内部的副本。 别名 :线程本地变量\nset():给tl中存放一个 变量 get():从tl中获取变量（副本）， remove();删除副本  对于数据库来说，一个连接 对应于一个事务 ，一个事务可以包含多个DML操作\nService(多个原子操作) -\u0026gt; Dao(原子操作)  如果给每个 dao操作 都创建一个connection，则 多个dao操作对应于多个事务；\n但是 一般来讲，一个业务(service) 中的多个dao操作 应该包含在一个事务中。\n-\u0026gt;解决，ThreadLocal, 在第一个dao操作时 真正的创建一个connection对象，然后在其他几次dao操作时，借助于tl本身特性 自动将该connection复制多个（connection只创建了一个，因此该connection中的所有操作 必然对应于同一个事务； 并且tl将connection在使用层面复制了多个，因此可以同时完成多个dao操作）\n事务流程： 开启事务（将自动提交-\u0026gt;手工提交） -\u0026gt;进行各种DML -\u0026gt;正常，将刚才所有DML全部提交 （全部成功）\n-\u0026gt;失败（异常），将刚才所有DML全部回滚（全部失败）\n事务的操作 全部和连接Connection密切相关\npublic class JDBCUtil { private static ThreadLocal\u0026lt;Connection\u0026gt; threadLocal = new ThreadLocal\u0026lt;\u0026gt;() ; public static Connection getConnection() throws SQLException { Connection conn = threadLocal.get();//获取tl中的变量，如果不够，会自动创建副本 if(conn == null){ conn = DataSourceUtil.getDataSourceWithC3P0().getConnection(); threadLocal.set(conn); } return conn; } //开启事务 public static void beginTransaction() throws SQLException { //连接 Connection conn = getConnection() ; conn.setAutoCommit(false);//开启事务 } //正常。提交事务 public static void commitTransaction() throws SQLException { //连接 Connection conn = getConnection() ; //所有的 对象.方法() 全部排空 if(conn !=null) conn.commit(); } //失败。回滚事务 public static void rollbackTransaction() throws SQLException { //连接 Connection conn = getConnection() ; if(conn !=null) conn.rollback(); } public static void close() throws SQLException{ Connection conn = getConnection() ; if(conn !=null) conn.close(); threadLocal.remove(); conn = null ; } }  public class AccountDaoImpl implements AccountDao { @Override public Account queryAccountByCard(int cardId) throws SQLException { QueryRunner runner = new QueryRunner() ; Connection conn = JDBCUtil.getConnection() ; Account account = runner.query(conn, \u0026quot;select * from account where carid = ?\u0026quot;, new BeanHandler\u0026lt;Account\u0026gt;(Account.class), cardId);//如果是手动提交： QueryRunner()无参；query()update()必须传入connection return account; } //carid 余额 @Override public void updateAccount(Account account) throws SQLException{ QueryRunner runner = new QueryRunner() ; Connection conn = JDBCUtil.getConnection() ; runner.update(conn,\u0026quot;update account set balance = ? where carid = ?\u0026quot;,new Object[]{account.getBalance(),account.getCardId()} ); } }  public class AccountServiceImpl implements AccountService { @Override public void transfer(int fromCardId, int toCardId, int money) { AccountDaoImpl accountDao = new AccountDaoImpl(); //开启事务 try { JDBCUtil.beginTransaction(); //各种DML操作 //a. -1000 b.+1000 //根据cardid查询相应的账户 Account fromAccount = accountDao.queryAccountByCard(fromCardId) ;//付款方 Account toAccount = accountDao.queryAccountByCard(toCardId) ;//收款方 //转账 if(fromAccount.getBalance() \u0026gt; money){ //付款方 -1000 int fromBalance = fromAccount.getBalance() - money; fromAccount.setBalance( fromBalance ); fromAccount.setCardId(fromCardId ); accountDao.updateAccount(fromAccount); System.out.println(1/0); //收款方+1000 int toBalance = toAccount.getBalance() + money ; toAccount.setBalance(toBalance); toAccount.setCardId(toCardId); accountDao.updateAccount(toAccount); System.out.println(\u0026quot;转账成功!\u0026quot;); //正常提交事务 JDBCUtil.commitTransaction(); }else{ System.out.println(\u0026quot;余额不足！\u0026quot;); } } catch (Exception e) { try { JDBCUtil.rollbackTransaction(); System.out.println(\u0026quot;转账失败，回滚操作！\u0026quot;); } catch (SQLException e1) { e1.printStackTrace(); }catch (Exception e1) { e1.printStackTrace(); } e.printStackTrace(); }finally{ try { JDBCUtil.close(); } catch (SQLException e) { e.printStackTrace(); } } //结束事务（正常、失败） } }  public class Test { public static void main(String[] args) { AccountServiceImpl accountService = new AccountServiceImpl(); accountService.transfer(1234,1111,100); } }  元数据(MetaData) 描述数据的数据\n三类：\n 数据库元数据 参数元数据 结果集元数据  1.数据库元数据 DataBaseMetaData\nConnection -\u0026gt; DataBaseMetaData -\u0026gt; .  2.参数元数据 ParameterMetaData pstmt -\u0026gt; ParameterMetaData -\u0026gt; .\n3.结果集元数据 ResultSetMetaData ResultSet -\u0026gt; ResultSetMetaData\n public class MeteDataDemo { private final static String DRIVER=\u0026quot;oracle.jdbc.OracleDriver\u0026quot;; private final static String URL=\u0026quot;jdbc:oracle:thin:@localhost:1521:orcl\u0026quot;; private final static String USERNAME=\u0026quot;scott\u0026quot;; private final static String PASSWORD=\u0026quot;tiger\u0026quot;; public static void databaseMetaData(){ try { Class.forName(DRIVER); Connection connection = DriverManager.getConnection(URL,USERNAME,PASSWORD); //数据库元信息 DatabaseMetaData dbMetadata = connection.getMetaData() ; String dbName = dbMetadata.getDatabaseProductName() ; System.out.println(\u0026quot;数据库名\u0026quot;+dbName); String dbVersion = dbMetadata.getDatabaseProductVersion() ;//11.1.22 System.out.println(\u0026quot;数据库版本\u0026quot;+dbVersion); String driverName = dbMetadata.getDriverName(); System.out.println(driverName); String url = dbMetadata.getURL(); System.out.println(url); String userName = dbMetadata.getUserName(); System.out.println(userName); System.out.println(\u0026quot;-----------\u0026quot;); ResultSet rs = dbMetadata.getPrimaryKeys(null, userName, \u0026quot;STUDENT\u0026quot;); while(rs.next()){ Object tableName = rs.getObject(3); Object columnName = rs.getObject(4); Object pkName = rs.getObject(6); System.out.println(tableName+\u0026quot;--\u0026quot;+columnName+\u0026quot;--\u0026quot;+pkName); } }catch(Exception e){ e.printStackTrace(); } } public static void parameterMetaData(){ try { Class.forName(DRIVER); Connection connection = DriverManager.getConnection(URL,USERNAME,PASSWORD); PreparedStatement pstmt = connection.prepareStatement(\u0026quot;select * from student where id = ? and name = ?\u0026quot;); //通過pstmt獲取參數元数据 ParameterMetaData metaData = pstmt.getParameterMetaData(); int count = metaData.getParameterCount() ; System.out.println(\u0026quot;参数个数：\u0026quot;+count); for(int i=1;i\u0026lt;=count ; i++){ String typeName = metaData.getParameterTypeName(i) ; System.out.println(typeName); } }catch(Exception e){ e.printStackTrace(); } } public static void resultSetMetaData(){ try { Class.forName(DRIVER); Connection connection = DriverManager.getConnection(URL,USERNAME,PASSWORD); PreparedStatement pstmt = connection.prepareStatement(\u0026quot;select * from student \u0026quot;); ResultSet rs = pstmt.executeQuery(); ResultSetMetaData metaData = rs.getMetaData(); int count = metaData.getColumnCount(); System.out.println(\u0026quot;列的个数：\u0026quot;+count); System.out.println(\u0026quot;---\u0026quot;); for(int i=1;i\u0026lt;=count ;i++){ String columnName = metaData.getColumnName(i); String columnTypeName = metaData.getColumnTypeName(i); System.out.println( columnName+\u0026quot;\\t\u0026quot;+columnTypeName); } while(rs.next()){ for(int i=1;i\u0026lt;=count;i++){ System.out.print( rs.getObject(i)+\u0026quot;\\t\u0026quot;); } System.out.println(); } }catch(Exception e){ e.printStackTrace(); } } }  很多数据库对元数据的支持问题：\nOralce目前必须使用ojdbc7.jar作为驱动包；\nMySql必须在url中附加参数配置：\njdbc:mysql://localhost:3306/数据库名?generateSimpleParameterMetadata=true  自定义标签 步骤：\n 编写标签处理类 编写标签描述符\n 导入并使用  编写标签处理类  传统方式（JSP1.1）：实现\njavax.servlet.jsp.tagext.Tag接口 doStartTag()  简单方式（JSP2.0）：实现\njavax.servlet.jsp.tagext.SimpleTag接口 doTag()   如果jsp在编译阶段 发现了自定义标签\u0026lt;xx:yyy\u0026gt;，就会交给doStartTag()或doTag()\n编写标签描述符 tld 编写建议：可以仿照一个 其他标签语言（el jstl ） 的tld文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!-- 标签库的头文件--\u0026gt; \u0026lt;taglib xmlns=\u0026quot;http://java.sun.com/xml/ns/j2ee\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\u0026quot; version=\u0026quot;2.0\u0026quot;\u0026gt; \u0026lt;description\u0026gt;标签库描述\u0026lt;/description\u0026gt; \u0026lt;tlib-version\u0026gt;1.0\u0026lt;/tlib-version\u0026gt; \u0026lt;short-name\u0026gt;xxxxxx\u0026lt;/short-name\u0026gt; \u0026lt;uri\u0026gt;标签库的url\u0026lt;/uri\u0026gt; \u0026lt;!-- -自定义标签的相关信息 --\u0026gt; \u0026lt;tag\u0026gt; \u0026lt;description\u0026gt;标签描述\u0026lt;/description\u0026gt; \u0026lt;name\u0026gt;标签名\u0026lt;/name\u0026gt; \u0026lt;tag-class\u0026gt;标签的处理\u0026lt;/tag-class\u0026gt; \u0026lt;body-content\u0026gt;标签体的类型\u0026lt;/body-content\u0026gt; \u0026lt;/tag\u0026gt; \u0026lt;/taglib\u0026gt;  scriptlet：\n\u0026lt;% ... %\u0026gt; \u0026lt;%！ ... %\u0026gt; \u0026lt;%= ... %\u0026gt;  导入并使用 位置：myTag.tld导入 WEB-INF或子目录下WEB-INF/xxx/(特例排除，不能是WEB-INF/lib、WEB-INF/classes )\n使用：\n引入具体要使用的.tld文件\n\u0026lt;%@ taglib uri=\u0026quot;...\u0026quot; prefix=\u0026quot;d\u0026quot; %\u0026gt;   uri：每个tld文件的 唯一描述符 prefix：使用tld标签时 的前缀  具体的使用：\n 空标签（没有标签体的标签）\n\u0026lt;d:foreach\u0026gt;\u0026lt;/d:foreach\u0026gt; \u0026lt;d:foreach /\u0026gt;  带标签体\n\u0026lt;d:foreach\u0026gt; xxx \u0026lt;/d:foreach\u0026gt;  带属性\n\u0026lt;d:foreach 属性名=\u0026quot;属性值\u0026quot; \u0026gt; xxx \u0026lt;/d:foreach\u0026gt; \u0026lt;d:foreach collection=\u0026quot;${students}\u0026quot; \u0026gt; xxx \u0026lt;/d:foreach\u0026gt;  嵌套\n\u0026lt;d:foreach\u0026gt; \u0026lt;d:foreach\u0026gt; xxx \u0026lt;/d:foreach\u0026gt; \u0026lt;/d:foreach\u0026gt; \u0026lt;d:foreach\u0026gt;   实际开发步骤 编写标签处理类\n先确保项目有tomcat环境\nTag接口：\ndoStartTag()：标签处理类的核心方法 （标签体的执行逻辑）\n该方法有以下2个返回值：0/1\nint SKIP_BODY = 0; 标签体不会被执行 int EVAL_BODY_INCLUDE = 1; 标签体会被执行  doEndTag()：标签执行完毕之后 的方法.例如可以让 标签在执行完毕后，再执行一次\nint SKIP_PAGE = 5;后面的JSP页面内容不被执行 int EVAL_PAGE = 6;后面的JSP页面内容继续执行  Tag接口中的所有方法执行顺序：\njsp - servlet\n当JSP容器（Tomcat、jetty）在将.jsp翻译成.servlet(.java)的时候 ,如果遇到JSP中有标签，就会依次执行 setPageContext() setParent()doStartTag() doEndTagrealease(),用于解析标签的执行逻辑。\njavax.servlet.jsp.tagext.IterationTag接口：（是Tag的子接口）\n 如果有循环：IterationTag，\n 没有循环：Tag\n  IterationTag接口中存在以下方法：\ndoAfterBody()：当标签体执行完毕之后的操作 ，通过返回值决定 ：\n（EVAL_BODY_AGAIN = 2）要么重复执行 ； （SKIP_BODY=0）：要么不再执行  目标：遍历3次 (hello)\n\u0026lt;xxx\u0026gt;hello\u0026lt;xxx\u0026gt;  执行一次，并重复两次\npublic class MyIteration extends TagSupport { private int num ;//执行次数 3 public void setNum(int num){ this.num = num ; } //执行标签 @Override public int doStartTag() throws JspException { return EVAL_BODY_INCLUDE ;//先执行一次 } //执行完毕后 @Override public int doAfterBody() throws JspException { num-- ; return num\u0026gt;0 ? EVAL_BODY_AGAIN :SKIP_BODY; //重复执行 } }  编写标签描述符\nmyTag.tld\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!-- 标签库的头文件--\u0026gt; \u0026lt;taglib xmlns=\u0026quot;http://java.sun.com/xml/ns/j2ee\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\u0026quot; version=\u0026quot;2.0\u0026quot;\u0026gt; \u0026lt;description\u0026gt;这是我的迭代器标签库\u0026lt;/description\u0026gt; \u0026lt;tlib-version\u0026gt;1.0\u0026lt;/tlib-version\u0026gt; \u0026lt;short-name\u0026gt;mytaglib\u0026lt;/short-name\u0026gt; \u0026lt;uri\u0026gt;http://www.yanqun.com\u0026lt;/uri\u0026gt; \u0026lt;!-- -自定义标签的相关信息 --\u0026gt; \u0026lt;tag\u0026gt; \u0026lt;description\u0026gt;这是我的迭代器标签\u0026lt;/description\u0026gt; \u0026lt;name\u0026gt;mytag\u0026lt;/name\u0026gt; \u0026lt;tag-class\u0026gt;com.yanqun.tag.MyIteration\u0026lt;/tag-class\u0026gt; \u0026lt;body-content\u0026gt;JSP\u0026lt;/body-content\u0026gt; \u0026lt;attribute\u0026gt; \u0026lt;name\u0026gt;num\u0026lt;/name\u0026gt; \u0026lt;required\u0026gt;true\u0026lt;/required\u0026gt; \u0026lt;/attribute\u0026gt; \u0026lt;/tag\u0026gt; \u0026lt;/taglib\u0026gt;  导入并使用\n位置：myTag.tld导入 WEB-INF或子目录下WEB-INF/xxx/(特例排除，不能是WEB-INF/lib、WEB-INF/classes )\n\u0026lt;%@ taglib uri=\u0026quot;http://www.yanqun.com\u0026quot; prefix=\u0026quot;yq\u0026quot;%\u0026gt;   \u0026lt;body\u0026gt; \u0026lt;yq:mytag num=\u0026quot;3\u0026quot;\u0026gt; hello \u0026lt;/yq:mytag\u0026gt; \u0026lt;/body\u0026gt;  BoyTag接口：如果在标签体 被显示之前，进行一些其他的“额外”操作\nhello hello hello -\u0026gt; HELLO HELLO HELLO\n包含属性：\nint EVAL_BODY_BUFFERED = 2  是doStartTag()的第三个返回值 ，代表一个缓冲区（BodyContent）。\nBodyContent是abstract,具体使用时需要使用实现类 BodyContentImpl(再引入jasper.jar)\n缓冲区（BodyContent）的使用用途：hello -\u0026gt;HELLO\n如果返回值是EVAL_BODY_BUFFERED ，则服务器会自动 将标签体需要显示的内容 放入缓冲区中（BodyContent）\n。因此，如果要更改最终显示结果，只需要从 缓冲区 获取原来的数据 进行修改即可。\n如何修改、获取 缓冲区：详见BodyContent的方法,具体就是 通过getXxx()获取原来的数据(hello),自己修改（HELLO）,输出getEnclosingWriter();\npublic class ToUpperCase extends BodyTagSupport { //第一步，告诉程序 我要将原来的hello变成大写，即将 doStartTag()的返回值设置成 EVAL_BODY_BUFFER (此步骤，已经在父类默认实现) //第二步：获取，并修改 @Override public int doEndTag() throws JspException { try { String content = getBodyContent().getString();//hello content = content.toUpperCase();//修改 bodyContent.getEnclosingWriter().write(content); } catch (Exception e) { e.printStackTrace(); } return super.doEndTag();//默认6，代表标签执行完毕后 是否执行其他的JSP元素 } }  \u0026lt;tag\u0026gt; \u0026lt;name\u0026gt;myToUpperCase\u0026lt;/name\u0026gt; \u0026lt;tag-class\u0026gt;com.yanqun.tag.ToUpperCase\u0026lt;/tag-class\u0026gt; \u0026lt;body-content\u0026gt;JSP\u0026lt;/body-content\u0026gt; \u0026lt;/tag\u0026gt;  简单方式 SimpleTag\n最大的简化：\n将传统方式的doStartTag() doEndTag() doafterBody()等方法 简化成了一个通用的 doTag()方法。\ndoTag() ：传统方式 可以对标签的最终显示 进行修改, hello -\u0026gt;HELLO ,核心是有一个缓冲区。\n但是简单方式 没有“缓冲区”。 如何修改显示内容？ 流\njavax.servlet.jsp.tagext.JspFragment类 ：代表一块JSP元素（该块 不包含scriptlet,因此简单方式的tld文件中\u0026lt;body-content\u0026gt;不能是JSP ）\nJspFragment中有一个invoke(Writer var1) 方法，入参是 “流”，即如果要修改显示内容，只需要修改此 流\ninvoke(Writer var1) ：每调用一次invoke()方法，会执行一次 标签体。\nSimpleTagSupport的 getJspBody()可以获取JspFragment对象。\nSimpleTagSupport的 getJspContext()方法 可以获取 jsp一些内置对象：getJspContext()的返回值是JspContext对象 是JSP内置对象的入口对象PageContext 的父类。\n简单标签方式 ，获取JSP内置对象： getJspContext() -\u0026gt; JspContext -\u0026gt;转成子类PageContext -\u0026gt;PageContext就是所有JSP内置对象的入口，即可以获取一切JSP内置对象\npublic class MySimpleTagIterator extends SimpleTagSupport { private int num ;//3 public int getNum() { return num; } public void setNum(int num) { this.num = num; } /* \u0026lt;aa\u0026gt; xxx \u0026lt;/aa\u0026gt; */ @Override public void doTag() throws JspException, IOException { JspFragment jspFragment = getJspBody(); for(int i=0;i\u0026lt;num ;i++){ jspFragment.invoke(null); } } }  \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!-- 标签库的头文件--\u0026gt; \u0026lt;taglib xmlns=\u0026quot;http://java.sun.com/xml/ns/j2ee\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\u0026quot; version=\u0026quot;2.0\u0026quot;\u0026gt; \u0026lt;description\u0026gt;这是我的简单迭代器标签库\u0026lt;/description\u0026gt; \u0026lt;tlib-version\u0026gt;1.0\u0026lt;/tlib-version\u0026gt; \u0026lt;short-name\u0026gt;mysimpletaglib\u0026lt;/short-name\u0026gt; \u0026lt;uri\u0026gt;http://www.yanqunsimple.com\u0026lt;/uri\u0026gt; \u0026lt;!-- -自定义标签的相关信息 --\u0026gt; \u0026lt;tag\u0026gt; \u0026lt;description\u0026gt;这是我的简单迭代器标签\u0026lt;/description\u0026gt; \u0026lt;name\u0026gt;mysimpletag\u0026lt;/name\u0026gt; \u0026lt;tag-class\u0026gt;com.yanqun.tag.MySimpleTagIterator\u0026lt;/tag-class\u0026gt; \u0026lt;body-content\u0026gt;scriptless\u0026lt;/body-content\u0026gt; \u0026lt;attribute\u0026gt; \u0026lt;name\u0026gt;num\u0026lt;/name\u0026gt; \u0026lt;required\u0026gt;true\u0026lt;/required\u0026gt; \u0026lt;/attribute\u0026gt; \u0026lt;/tag\u0026gt; \u0026lt;/taglib\u0026gt;  \u0026lt;%@ taglib uri=\u0026quot;http://www.yanqunsimple.com\u0026quot; prefix=\u0026quot;yqs\u0026quot;%\u0026gt; \u0026lt;yqs:mysimpletag num=\u0026quot;5\u0026quot;\u0026gt; nihao \u0026lt;/yqs:mysimpletag\u0026gt;  条件选择：\n当某一个条件满足时，再执行某个标签体\n传统标签：如果条件不满足，让doStartTag()的返回值为0；\n简单标签(不允许写scriplet \u0026lt;% \u0026hellip;%\u0026gt;)： 如果条件不满足，不调用invoke()即可。\n实例使用简单标签实现登录功能 \u0026lt;tag\u0026gt; \u0026lt;name\u0026gt;login\u0026lt;/name\u0026gt; \u0026lt;tag-class\u0026gt;com.yanqun.tag.LoginTag\u0026lt;/tag-class\u0026gt; \u0026lt;body-content\u0026gt;scriptless\u0026lt;/body-content\u0026gt; \u0026lt;/tag\u0026gt;  input.jsp\n\u0026lt;form action=\u0026quot;LoginServlet\u0026quot;\u0026gt; 用户名 \u0026lt;input name=\u0026quot;uname\u0026quot;/\u0026gt;\u0026lt;br/\u0026gt; 密码 \u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;upwd\u0026quot;/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;登录\u0026quot;/\u0026gt; \u0026lt;/form\u0026gt;  input.jsp\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String name = request.getParameter(\u0026quot;uname\u0026quot;) ; String pwd = request.getParameter(\u0026quot;upwd\u0026quot;) ; //zs ,abc if(name.equals(\u0026quot;zs\u0026quot;) \u0026amp;\u0026amp; pwd.equals(\u0026quot;abc\u0026quot;)){ //登录成功，将当前用户名 保存到session request.getSession().setAttribute(\u0026quot;name\u0026quot;,name); //User user = new User(); request.getRequestDispatcher(\u0026quot;show.jsp\u0026quot;).forward(request,response); }else{ //跳转到失败页面 response.sendRedirect(\u0026quot;error.jsp\u0026quot;); } }  show.jsp\n\u0026lt;%@taglib uri=\u0026quot;http://www.yanqunsimple.com\u0026quot; prefix=\u0026quot;yqs\u0026quot;%\u0026gt; \u0026lt;yqs:login\u0026gt; ${sessionScope.name},已登录 ${name} \u0026lt;/yqs:login\u0026gt;  LoginTag.java\npublic class LoginTag extends SimpleTagSupport { @Override public void doTag() throws JspException, IOException { //判断 是否已经登录成功 PageContext pageContext = (PageContext)getJspContext() ; HttpSession session = pageContext.getSession(); String name = (String)session.getAttribute(\u0026quot;name\u0026quot;) ; if(name !=null){ //执行一次标签体 getJspBody().invoke(null) ; } //如果成功，执行标签体 //如果失败，不执行 } }  验证码 强制刷新：除了禁止缓存以外，还需要给服务端传递一个唯一的参数值（没有实际用处）。随机数、时间\nimg.jsp\n\u0026lt;%@ page import=\u0026quot;java.awt.*\u0026quot; %\u0026gt; \u0026lt;%@ page import=\u0026quot;java.util.Random\u0026quot; %\u0026gt; \u0026lt;%@ page import=\u0026quot;java.awt.image.BufferedImage\u0026quot; %\u0026gt; \u0026lt;%@ page import=\u0026quot;javax.imageio.ImageIO\u0026quot; %\u0026gt; \u0026lt;%@ page contentType=\u0026quot;image/jpeg;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;%! //随机产生颜色值 public Color getColor(){ Random ran = new Random() ;//Math.random() 0-1 int r = ran.nextInt(256) ; int g = ran.nextInt(256) ; int b = ran.nextInt(256) ; return new Color(r,g,b) ;//red green blue 0-255 } //产生验证码值 public String getNum() { // 0-8999 1000-9999 int ran = (int)( Math.random()*9000) +1000 ; return String.valueOf(ran) ; } %\u0026gt; \u0026lt;% //禁止缓存，防止验证码过期 response.setHeader(\u0026quot;Pragma\u0026quot;,\u0026quot;no-cache\u0026quot;); response.setHeader(\u0026quot;Cache-Control\u0026quot;,\u0026quot;no-cache\u0026quot;); response.setHeader(\u0026quot;Expires\u0026quot;,\u0026quot;0\u0026quot;); //绘制验证码 BufferedImage image = new BufferedImage(80,30,BufferedImage.TYPE_INT_RGB) ; //画笔 Graphics graphics = image.getGraphics(); graphics.fillRect(0,0,80,30); //绘制干扰线条 for(int i=0;i\u0026lt;60;i++) { Random ran = new Random() ; int xBegin = ran.nextInt(80) ;//55 int yBegin = ran.nextInt(30) ; int xEnd = ran.nextInt(xBegin +10 ) ; int yEnd = ran.nextInt(yBegin + 10) ; graphics.setColor( getColor()); //绘制线条 graphics.drawLine(xBegin,yBegin,xEnd,yEnd); } graphics.setFont(new Font(\u0026quot;seif\u0026quot;,Font.BOLD,20)); //绘制验证码 graphics.setColor(Color.BLACK); String checkCode = getNum() ; //2 1 3 4 StringBuffer sb = new StringBuffer() ; for(int i=0;i\u0026lt;checkCode.length();i++){ sb.append(checkCode.charAt(i)+\u0026quot; \u0026quot; ) ;//验证码的每一位数字 } graphics.drawString( sb.toString(), 15,20 );//绘制验证码 //将验证码真实值 保存在session中，供使用时比较真实性 session.setAttribute(\u0026quot;CKECKCODE\u0026quot; ,checkCode ); //真实的产生图片 ImageIO.write(image,\u0026quot;jpeg\u0026quot;, response.getOutputStream()) ; //关闭 out.clear(); out = pageContext.pushBody() ; //\u0026lt;input type=\u0026quot;image\u0026quot; src=\u0026quot;xxx\u0026quot; /\u0026gt; %\u0026gt;  CheckCodeServlet.java\n@WebServlet(\u0026quot;/CheckCodeServlet\u0026quot;) public class CheckCodeServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String resultTip = \u0026quot;imgs/wrong.jpg\u0026quot;; //获取用户输入验证码 String checkcodeClient = request.getParameter(\u0026quot;checkcode\u0026quot;); //真实的验证码值 String checkcodeServer = (String) request.getSession().getAttribute(\u0026quot;CKECKCODE\u0026quot;); if(checkcodeServer.equals(checkcodeClient)){ resultTip = \u0026quot;imgs/right.jpg\u0026quot;; } response.setContentType(\u0026quot;text/html;charset=UTF-8\u0026quot;); PrintWriter writer = response.getWriter();//输出流 writer.write(resultTip); writer.flush(); writer.close(); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } }  index.jsp\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;jquery-3.3.1.js\u0026quot; \u0026gt; \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; \u0026gt; function reloadCheckImg() { $(\u0026quot;img\u0026quot;).attr(\u0026quot;src\u0026quot;, \u0026quot;img.jsp?t=\u0026quot;+(new Date().getTime())); //\u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; } $(document).ready(function(){ $(\u0026quot;#checkcodeId\u0026quot;).blur(function(){ var $checkcode = $(\u0026quot;#checkcodeId\u0026quot;).val(); //校验 :文本框中输入的值 发送到服务端。 //服务端： 获取文本框输入的值 ，和真实验证码图片中的值对比 ，并返回验证结果 $.post( \u0026quot;CheckCodeServlet\u0026quot;,//服务端地址 \u0026quot;checkcode=\u0026quot;+$checkcode , function(result){//图片地址（imgs/right.jpg imgs/wrong.jpg） //result: imgs/right.jpg var resultHtml = $(\u0026quot;\u0026lt;img src='\u0026quot;+result+\u0026quot;' height='15' width='15px' /\u0026gt;\u0026quot;) ; $(\u0026quot;#tip\u0026quot;).html(resultHtml); } ); }); }); \u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;验证码\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 验证码： \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;checkcode\u0026quot; id=\u0026quot;checkcodeId\u0026quot; size=\u0026quot;4\u0026quot; /\u0026gt; \u0026lt;!-- 验证码--\u0026gt; \u0026lt;a href=\u0026quot;javascript:reloadCheckImg();\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;img.jsp\u0026quot;/\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;span id=\u0026quot;tip\u0026quot;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  集群： apache、 nginx  tomcat:理论上 单节点tomcat能够稳定的 处理请求并发量200-300；\n负载均衡\n失败迁移\n服务端集群：\n 水平集群 :将服务器安装在 各个不同的计算机上 （失败迁移）\n 垂直集群 ：将多个服务器，安装在同一个计算机上 （负载均衡）\n 水平+垂直\n  搭建集群： apache :特点是处理静态资源（html 图片 js） .这里的apache是一个服务工具，不是 之前理解的 基金组织。\ntomcat:特点 可以处理动态资源\napache+tomcat:动静分离\napache：请求的分流操作\n下载apache服务器工具下载地址\n配置：\nconf/http.conf（37行左右）\nDefine SRVROOT \u0026quot;D:\\dev\\cluster\\Apache24\u0026quot;  看一看将apache配置成windows服务，既可以在服务中启动停止服务：\n管理员身份打开cmd，通过命令注册apache服务\n\u0026quot;C:\\workplace\\jar\\cluster\\httpd-2.4.41-win64-VS16\\Apache24\\bin\\httpd.exe\u0026quot; -k install -n apache24  删除服务\nsc delete 服务名  如果在注册apache服务时，提示“丢失VCRUNTIME140.DLL”，则需要下载并安装vc_redist.x64.exe。下载地址\n注册成功后，启动，浏览器访问\nlocalhost  查看是否成功访问\n准备tomcat：复制两份，改端口\n 规划并修改端口： server.xml\n 22行 63行 108行 server端口号 http协议端口 ajp协议端口号 tomcat-a: 1005 1080 1009 tomcat-b: 2005 2080 2009  配置引擎Engine ： server.xml\n增加jvmRoute（128行）\n\u0026lt;Engine name=\u0026quot;Catalina\u0026quot; defaultHost=\u0026quot;localhost\u0026quot; jvmRoute=\u0026quot;tomcat-b\u0026quot;\u0026gt;  打开集群开关 server.xml（133行）\n打开以下注释\n\u0026lt;Cluster className=\u0026quot;org.apache.catalina.ha.tcp.SimpleTcpCluster\u0026quot;/\u0026gt;   tomcat集群配置搞定，apache启动\n-\u0026gt;结合apache+tomcat :mod_jk.so\n下载地址\n配置mod_jk.so：  存放位置，\\Apache24\\modules\\mod_jk.so\n 配置\\Apache24\\conf\\workers.properties\n 配置\\Apache24\\conf\\mod_jk.conf （用于加载mod_jk.so和workers.properties）\n 配置httpd.conf： 在apache启动时 自动加载mod_jk.conf：\n追加(最后)\ninclude conf/mod_jk.conf  mod_jk.so,workers.properties -\u0026gt;mod_jk.conf -\u0026gt; apache程序会自动加载httpd.conf\n 在项目web.xml中添加\n\u0026lt;distributable/\u0026gt;  表示开启项目同步\n  部署项目将项目分别部署到tomcat中\n依次启动apache、tomcata、tomcatb 访问\nhttp://localhost/ClusterProject/  workers.properties\nworker.list=controller,tomcata,tomcatb #tomcata worker.tomcata.port=1009 worker.tomcata.host=localhost worker.tomcata.type=ajp13 #负载均衡的权重 worker.tomcata.lbfactor=1 #tomcatb worker.tomcatb.port=2009 worker.tomcatb.host=localhost worker.tomcatb.type=ajp13 #负载均衡的权重 worker.tomcatb.lbfactor=2 #controller worker.controller.type=lb worker.controller.balanced_workers=tomcata,tomcatb worker.controller.sticky_session=false  分布式session策略：  sticky:固定将每一个用户的请求 分给特定的服务器，后期的请求不会分给其他服务器\n弊端：无法失败迁移\n session广播（自动同步session）： 自动同步session，\n弊端：如果服务器太多，可能造成广播风暴（将一个服务器的session,需要同步到其他所有的服务器中）\n 集中管理方式（推荐）：将各个服务器的session集群存储到一个 数据库中\n  mod_jk.conf\n#加载mod_jk.so LoadModule jk_module modules/mod_jk.so #加载workers.properties JkWorkersFile conf/workers.properties JkMount /* controller  路径以apache的根目录开始找\n其中JkMount /* controller，表示拦截一切请求。也可以只拦截jsp： /*.jsp\n集群 应用阶段、部署实施\nCATALINA_HOME会使 启动tomcat时 自动开启CATALINA_HOME指定的tomcat。而集群中 需要开启多个不同的tomcat，因此 在单机环境下，需要删除CATALINA_HOME。\n依次启动apache、tomcata、tomcatb\n原因：\napache之前已经成功运行，但是重启时 失败  分析思路：\n成功运行的时机：第一把apche下载完后 失败时机： apache+tomcat整合  得出结论： 整合\n测试：失败迁移 负载均衡 session共享\n细节：  apache:\nworker.list=controller,tomcata,tomcatb  流程：apache-\u0026gt;workers.properties中配置的 ip:端口 找到具体的tomcat服务（与tomcat中的jvmRoute=\u0026ldquo;tomcat-a\u0026rdquo;的没有关系）\n tomcat配置：（只需要保证 所有tomcat的jvmRoute不能重名即可 ，可以和apache中的命名不一致）\njvmRoute=\u0026quot;tomcat-a\u0026quot; jvmRoute=\u0026quot;tomcat-b\u0026quot;  tomcat服务的目录名：（任意）\ntomcata tomcatb   ","id":22,"section":"posts","summary":"源码 EL Expression Launguage:可以代替JSp页面中的Java代码 传统的在jsp代码中显示java代码 需要使用\u0026lt;%%\u0026gt;\u0026lt;%=%","tags":["J2EE"],"title":"JSP进阶学习笔记","uri":"https://mumulx.github.io/2019/11/jsp%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" vm安装centos6 新建虚拟机\n稍后安装操作系统\n处理器数量（虚拟的，只跟自己的真实机有关）1，1，1\n内存2048\n网络nat\n磁盘20G\n完成\n编辑虚拟机设置\n设置iso镜像位置\n开启虚拟机\n第一项回车\nskip 跳过检测\n语言简体中文\n键盘默认\n是忽略所有数据\n主机名 centosinit\n选择时区 亚洲/上海\n输入密码\n自定义系统布局\n磁盘布局: 创建 标准分区\n/boot:系统启动时需要的内存200M /:系统的可用磁盘大小10240M swap:交换内存，建议大小和内存一致2048M  鼠标从虚拟机中释放: ctrl+alt\n下一步\n格式化\n是将修改写入磁盘\nDesktopt 现在自定义\n基本系统取消java平台\n下一步\n重新引导\n不创建用户\n关于vmware中计算机名子: 虚拟机名: bigdata01 计算机名: bigdata01 网络中的名字: bigdata01 用户名:root  默认超级管理员: root/自己设置\n查看计算机名: hostname hostname  查看计算机名\n通过文本编辑器打开文件: vi路径/文件名\nvi /etc/sysconfig/network  查看文件: cat /etc/sysconfig/network\n编辑: a\n保存: esc，shift +z+z\n重启计算机:reboot\n关机:halt\nlinux安装vm tools 虚拟机\u0026ndash;\u0026gt;安装vmtool\u0026mdash;\u0026gt;复制压缩包xxx.tar.gz到桌面\u0026ndash;\u0026gt;解压缩\u0026ndash;\u0026gt;xxxx.pl\u0026mdash;\u0026gt;在命令行打开，一直回车\u0026ndash;\u0026gt;重启\ncentos网络配置 编辑\u0026ndash;》虚拟机网络设置\u0026ndash;》更改设置》NAT模式 vmnet8\n子网ip 192.168.2.0\n子网掩码255.255.255.0\nDHCP设置\n起始IP192.168.2.128 终止ip192.168.2.254\nNAT设置 网关192.168.2.1\n配置windows访问虚拟机 网络\u0026ndash;》右键属性\u0026ndash;》更改适配器设置\u0026ndash;网络连接- vmNet8- -TCP/IP V4 - IP192. 168. 2.2，网关192. 168.2. 1 ，子网掩码 255.255.255.0\ncentos网卡 vi /etc/sysconfig/network-scripts/ifcfg-eth0  DEVICE=eth0 HWADDR=00:0C:29:26:8F:4F TYPE=Ethernet UUID=d7986e04-0a7d-4f73-a69a-782be645067b --修改以下配置 ONBOOT=yes NM_CONTROLLED=yes BOOTPROTO=static IPADDR=192.168.2.128 GATEWAY=192.168.2.1 BROADCAST=192.168.2.255 DNS1=114.114.114.114 DNS2=8.8.8.8  vi如果使用shift+z+z无法保存，则使用\u0026rdquo;:wq!\u0026rdquo;\n通过网络名访问虚拟机(192. 168. 2.128 -\u0026gt;bi gdata01)  centos:\nvi /etc/hosts, 追加: 192.168.2.128 centos6  windows:\nC: \\Windows \\System32\\drivers\\etc\\hosts 追加: 192.168.2.128 bigdata01   配置网络服务 service NetworkManager stop /etc/init.d/network restart chkconfig NetworkManager off vi /etc/resolv.conf 追 加 nameserve 192. 168. 2.1 service network restart  防火墙 service iptables stop：关闭当前防火墙 chkconfig iptables off：禁止开机自启 service iptables status：查看当前防火墙状态  自动同步时间 yum -y install ntp utpdate：安装时间插件 ntpdate cn.pool.ntp.org：根据网站同步时间 hwclock --systohc：将系统时间写入硬盘时间  windows真实机通过SecureCRT操作centos  下载SecureCRT\n通过SecureCRT对centos进行文件的上传下载:\nyum -y install lrzsz  上传:切换到当前目录cd /tmp, 直接用鼠标拖拽，Zmodem. .\n  添加连接 单击快速连接(alt+q)\nhostname 填写ip地址\nusername 填写root\n下载安装jdk（rpm方式） exe:rpm rar:.tar.gz  下载rpm版jdk\n安装:切到 rpm版 jdk的文件夹中，\nrpm -ivh jdk名字  ll:查看当前文件夹文件 pwd:查看当前所在的目录 rpm安装完毕之后全部在usr文件夹中\n例如Java的安装位置：/usr/java/jdk1.8.0_231-amd64\nlinux：一切都是文件，一切都是命令\n配置环境变量: vi /etc/profile 中 的最后追加: export JAVA_ HOME=/usr/java/jdk1.8.0_ 181-amd64 export CLASSPATH=$JAVA_HOME$\\lib: $CLASSPATH export PATH=$JAVA_HOME$\\bin:$PATH  让环境变量立即生效\nsource /etc/profile  集群(3台) :完整克隆 bigdata01 -\u0026gt; bigdata02/bi gdata03  克隆完毕后:\n 将从计算机的内存适当降低\n 修改从计算中唯一性的配置(ip、uuid、hostname映射)\n在克隆后的bigdata02/bigdata03中\n修改计算机名:\nvi /etc/sysconfig/network  修改ip\nvi /etc/sysconfig/network-scripts/ifcfg-eth0 修改IP地址 删除uuid/hwaddr (在重启时，自动生成)  删除文件：\nrm -r /etc/udev/rule.d/70-persistent-net.rules 输入yes  映射\ncentos\nvi /etc/hosts 追加: 192.168. 2.128 bi gdata01 192. 168. 2. 129 bi gdata02 192.168. 2. 130 bi gdata03  windows:\nC: \\Windows \\System32\\drivers\\etc \\hosts 追加: 192.168. 2.128 bi gdata01 192. 168. 2. 129 bi gdata02 192.168. 2. 130 bi gdata03   SSH免密钥登录 生成密钥 ssh-keygen -t rsa  一直回车\n存储路径：\n/root/.ssh  id_rsa:私钥\nid_rsa.pub：公钥\n发送给其他计算机 发送私钥(本机)：\nssh-copy-id localhost yes 当前用户密码  发送公钥（其他计算机）\nssh-copy-id xxxx yes xxxx计算机的密码  测试免密钥登录\nssh localhost ssh xxxx  用户权限 用户组 创建用户组\ngroupadd bd  在用户组中添加用户\nuseradd -g bd lx passwd lx 回车 输入密码  给用户提升权限（在/etc/sudoers中设置lx的权限）\n/etc/sudoers文件本身是可读的，所以修改该文件前需要，将只读禁止\nchmod 777 /etc/sudoers 最高权限（可读可写）  编辑文件\n追加\nlx ALL(ALL) ALL  还原/etc/sudoers的权限为只读：\nchomd 440 /etc/sudoers  删除用户 userdel lx  切换用户 su lx 切换普通用户 su 切换到管理员用户  jps 查看进程\njps  删除进程\nkill -9 进程编号  Linux Centos7 安装 新建虚拟机\n稍后安装操作系统\n处理器数量（虚拟的，只跟自己的真实机有关）1，1，1\n内存2048\n网络nat\n磁盘20G\n完成\n编辑虚拟机设置\n设置iso镜像位置\n开启虚拟机\n第一项回车\n语言推荐选英语\n更改时区\nSOFTWARE SELECTION选择\nGNOME Desktop  INSTALLATION DESTINATION选择\nI will configure partitioning  Standard Partition 点击+\n/ 10240 /boot 300 swap 1024(与内存大小一致)  设置管理员密码\n重启\n同意协议\n设置hostname hostnamectl set-hostname centos7init  设置ip 编辑\u0026ndash;》虚拟网络编辑器，与centos6设置一样\ncd /etc/sysconfig/network-scripts/ ls  DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=f75a83a8-750a-40db-8ac1-562e6190d1e4 DEVICE=ens33 ONBOOT=yes IPADDR=192.168.2.150 GATEWAY=192.168.2.1 BROADCAST=192.168.2.255 DNS1=114.114.114.114 DNS2=8.8.8.8  域名映射 vi /etc/hosts 192.168.2.150 centos7init  windows:\nC: \\Windows \\System32\\dr ivers\\etc \\hosts 追加: 192.168.2.150 centos7init  配置网络服务 service NetworkManager stop /etc/init.d/network restart chkconfig NetworkManager off vi /etc/resolv.conf 追 加 nameserve 192. 168. 2.1 service network restart  防火墙 systemctl stop firewalld：关闭当前防火墙 systemctl disable firewalld：禁止开机自启  自动同步时间 yum -y install ntp utpdate：安装时间插件 ntpdate cn.pool.ntp.org：根据网站同步时间 hwclock --systohc：将系统时间写入硬盘时间  windows真实机通过SecureCRT操作centos  下载SecureCRT\n通过SecureCRT对centos进行文件的上传下载:\nyum -y install lrzsz  上传:切换到当前目录cd /tmp, 直接用鼠标拖拽，Zmodem. .\n  添加连接 单击快速连接(alt+q)\nhostname 填写ip地址\nusername 填写root\n下载安装jdk（rpm方式） exe:rpm rar:.tar.gz  下载rpm版jdk\n安装:切到 rpm版 jdk的文件夹中，\nrpm -ivh jdk名字  例如Java的安装位置：/usr/java/jdk1.8.0_231-amd64\nlinux：一切都是文件，一切都是命令\n配置环境变量: vi /etc/profile 中 的最后追加: export JAVA_ HOME=/usr/java/jdk1.8.0_231-amd64 export CLASSPATH=$JAVA_HOME$\\lib: $CLASSPATH export PATH=$JAVA_HOME$\\bin:$PATH  让环境变量立即生效\nsource /etc/profile  集群(3台) :完整克隆 克隆完毕后:\n 将从计算机的内存适当降低\n 修改从计算中唯一性的配置(ip、uuid、hostname映射)\n在克隆后的bigdata02/bigdata03中\n修改计算机名:\nhostnamectl set-hostname xxxx  修改ip\ncd /etc/sysconfig/network-scripts/ ls 删除uuid(在重启时，自动生成)  映射\ncentos\nvi /etc/hosts 追加: 192.168. 2.128 bi gdata01 192. 168. 2. 129 bi gdata02 192.168. 2. 130 bi gdata03  windows:\nC: \\Windows \\System32\\drivers\\etc \\hosts 追加: 192.168. 2.128 bi gdata01 192. 168. 2. 129 bi gdata02 192.168. 2. 130 bi gdata03   SSH免密钥登录 生成密钥 ssh-keygen -t rsa  一直回车\n存储路径：\n/root/.ssh  id_rsa:私钥\nid_rsa.pub：公钥\n发送给其他计算机 发送私钥(本机)：\nssh-copy-id localhost yes 当前用户密码  发送公钥（其他计算机）\nssh-copy-id xxxx yes xxxx计算机的密码  测试免密钥登录\nssh localhost ssh xxxx  centos7.x用firewall打开80端口  关闭与开启防火墙\n启动：systemctl start firewalld 关闭： systemctl stop firewalld  查看防火墙是否开启的状态，以及开放端口的情况\nsystemctl status firewalld.service firewall-cmd --list-all  通过以下命令开放http 80 端口\nfirewall-cmd --add-port=80/tcp --permanent  命令末尾的\u0026ndash;permanent表示用久有效，不加这句的话重启后刚才开放的端口就又失效了\n 然后重启防火墙：\nsudo firewall-cmd --reload  再次查看端口的开放情况：\n firewall-cmd --list-all  ports：里出现了 80 端口\n  然后再阿里云上添加安全组\n","id":23,"section":"posts","summary":"vm安装centos6 新建虚拟机 稍后安装操作系统 处理器数量（虚拟的，只跟自己的真实机有关）1，1，1 内存2048 网络nat 磁盘20G 完成 编辑","tags":["杂七杂八"],"title":"Linux Centos6安装","uri":"https://mumulx.github.io/2019/11/linux-centos6%E5%AE%89%E8%A3%85/","year":"2019"},{"content":" Mybatis 简介 官网\nmybatis:\nibatis:apache\n2010 ibatis-\u0026gt; google colde ,Mybatis\nMyBatis可以简化JDBC操作，实现数据的持久化 。\nORM:Object Relational Mapping\nperson对象 person表 之间一一映射起来  ORM：概念 ，Mybatis是ORM的一个实现/Hibernate orm可以是的开发人员像操作对象一样操作数据库表。\n开发mybatis程序从步骤： 所有学习源码git地址\njar包 mybatis-3.4.6.jar  类\u0026ndash;表  public class Student { private int id; private String name; private int age ; public Student() { } public Student(int id, String name, int age) { this.id = id; this.name = name; this.age = age; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return this.id+\u0026quot;,\u0026quot;+this.name+\u0026quot;,\u0026quot;+this.age ; } }  配置mybatis conf.xml:配置数据库信息 和 需要加载的映射文件 表 - 类\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026quot;-//mybatis.org//DTD Config 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026quot;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;environment id=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot;/\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;!-- 配置数据库信息 --\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;oracle.jdbc.OracleDriver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;scott\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;tiger\u0026quot;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;!-- 加载映射文件 --\u0026gt; \u0026lt;mapper resource=\u0026quot;org/lanqiao/entity/personMapper.xml\u0026quot;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;  映射文件xxMapper.xml :增删改查标签\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot;\u0026gt; \u0026lt;mapper namespace=\u0026quot;org.lanqiao.entity.personMapper\u0026quot;\u0026gt; \u0026lt;select id=\u0026quot;queryPersonById\u0026quot; resultType=\u0026quot;org.lanqiao.entity.Person\u0026quot; parameterType=\u0026quot;int\u0026quot;\u0026gt; select * from person where id = #{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;  测试类：\npublic class TestMyBatis { public static void main(String[] args) throws IOException { //加载MyBatis配置文件（为了访问数据库） Reader reader = Resources.getResourceAsReader(\u0026quot;conf.xml\u0026quot;) ; SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader) ; //session - connection SqlSession session = sessionFactory.openSession() ; String statement = \u0026quot;org.lanqiao.entity.personMapper.queryPersonById\u0026quot; ; Student person = session.selectOne( statement,1 ) ; System.out.println(person); session.close(); } }  session.selectOne(\u0026ldquo;需要查询的SQL的namespace.id\u0026rdquo;,\u0026ldquo;SQL的参数值\u0026rdquo;);\nconf.xml配置文件 配置文件的提示功能是通过\nPUBLIC \u0026quot;-//mybatis.org//DTD Config 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026quot;  来配置的，因此需要联网，也可以将http://mybatis.org/dtd/mybatis-3-config.dtd下载下来，通过，windows-Preferences\u0026ndash;\u0026gt;XML\u0026ndash;\u0026gt;XML Catalog\u0026ndash;\u0026gt;Catalog Entry指定文件的内容；其中Location放文件地址，Key放-//mybatis.org//DTD Config 3.0//EN\n切换环境 \u0026lt;!-- 通过environments的default值 和 environment的 id 来指定 MyBatis运行时的数据库环境--\u0026gt; \u0026lt;environments default=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;!-- 开发环境（自己的计算机） --\u0026gt; \u0026lt;environment id=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;!-- 事务提交方式： JDBC:利用JDBC方式处理事务（手工commit rollback close） MANAGED：将事务交由 其他组件去托管（spring ,jobss）,默认 会关闭连接。 关闭默认值，默认不关闭 \u0026lt;transactionManager type=\u0026quot;MANAGED\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;closeConnection\u0026quot; value=\u0026quot;false\u0026quot;/\u0026gt; --\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot; /\u0026gt; \u0026lt;!-- 数据源类型： UNPOOLED:传统的JDBC模式（每次访问数据库，均需要 打开、关闭等数据库操作，但是 打开、关闭数据库是比较消耗性能的，不推荐使用） POOLED：使用数据库连接池 JNDI：从tomcat中获取一个内置的数据库连接池 （数据库连接池-数据源 ） --\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;!-- 配置数据库信息 --\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;oracle.jdbc.OracleDriver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;scott\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;tiger\u0026quot;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;!-- 真正的项目应该在 发布的那台计算机上运行 --\u0026gt; \u0026lt;environment id=\u0026quot;shishi\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot;/\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;!-- 配置数据库信息 --\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;oracle.jdbc.OracleDriver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;jdbc:oracle:thin:@192.168.1.183:1521:ORCL\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;scott\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;tiger\u0026quot;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;!-- --\u0026gt; \u0026lt;environment id=\u0026quot;test\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot;/\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;!-- 配置数据库信息 --\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;oracle.jdbc.OracleDriver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;jdbc:oracle:thin:@192.168.1.111:1521:ORCL\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;scott\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;tiger\u0026quot;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt;  还可以通过硬编码的方式指定环境，即使conf中default已经指定了默认环境。可以通过build的第二参数 指定数据库环境\nSqlSessionFactory sessionFacotry = new SqlSessionFactoryBuilder().build(reader, \u0026quot;development\u0026quot;);  xxxMapper.xml文件 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot;\u0026gt; \u0026lt;!-- namespace:该mapper.xml映射文件的 唯一标识 --\u0026gt; \u0026lt;mapper namespace=\u0026quot;org.lanqiao.mapper.StudentMapper\u0026quot;\u0026gt; \u0026lt;/mapper\u0026gt;  后续通过 namespace.id定位sql语句\nparameterType:输入参数的类型\nresultType：查询返回结果值的类型 ，返回类型\n复习第一个MyBatis程序： mybatis.jar ojdbc.jar   conf.xml (数据库配置信息、映射文件)\n 表-类：映射文件 mapper.xml\n 测试\n  基础方式的增删改查CRUD: mybatis约定：\n输入参数parameterType 和 输出参数resultType ，在形式上都只能有一个\n 如果输入/输出参数 ：\n 是简单类型（8个基本类型+String） 是可以使用任何占位符,#{xxxx}\n 如果是对象类型，则必须是对象的属性 #{属性名}\n  输出参数：\n 如果返回值类型是一个 对象（如Student），则无论返回一个、还是多个，在resultType都写成org.lx.entity.Student即 resultType=\u0026quot;org.lx.entity.Student\u0026quot;   注意事项：\n 如果使用的 事务方式为 jdbc,则需要 手工commit提交，即\nsession.commit();  所有的标签 \u0026lt;select\u0026gt; \u0026lt;update\u0026gt;等 ，都必须有sql语句，但是sql参数值可选(重载了函数，有一个参数，有两个参数)\nsql有参数：session.insert(statement, 参数值 ); sql没参数：session.insert(statement);   增加 \u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;org.lanqiao.entity.Student\u0026quot; \u0026gt; insert into student(stuno,stuname,stuage,graname) values(#{stuNo},#{stuName},#{stuAge},#{graName} ) \u0026lt;/insert\u0026gt;  String statement = \u0026quot;org.lanqiao.entity.studentMapper.\u0026quot;+\u0026quot;addStudent\u0026quot;; Student student = new Student(13, \u0026quot;ww3\u0026quot;, 23, \u0026quot;s3\u0026quot;); int count = session.insert(statement,student); session.commit();  删除 \u0026lt;delete id=\u0026quot;deleteStudentByStuno\u0026quot; parameterType=\u0026quot;int\u0026quot;\u0026gt; delete from student where stuno = #{stuno} \u0026lt;/delete\u0026gt;  String statement = \u0026quot;org.lanqiao.entity.studentMapper.\u0026quot;+\u0026quot;deleteStudentByStuno\u0026quot;; int count = session.delete(statement,3) session.commit();  修改 \u0026lt;update id=\u0026quot;updateStudentByStuno\u0026quot; parameterType=\u0026quot;org.lx.entity.Student\u0026quot; \u0026gt; update student set stuname=#{stuName} ,stuage=#{stuAge},graname=#{graName} where stuno=#{stuNo} \u0026lt;/update\u0026gt;  String statement = \u0026quot;org.lanqiao.entity.studentMapper.\u0026quot;+\u0026quot;updateStudentByStuno\u0026quot;; Student student = new Student(); // 修改哪个人，where stuno =2 student.setStuNo(2); // 修改成什么样子？ student.setStuName(\u0026quot;ls\u0026quot;); student.setStuAge(24); student.setGraName(\u0026quot;s1\u0026quot;); int count = session.update(statement,student) session.commit();  查询 查询一个\n\u0026lt;select id=\u0026quot;queryStudentByStuno\u0026quot; parameterType=\u0026quot;int\u0026quot; resultMap=\u0026quot;org.lx.entity.Student\u0026quot; \u0026gt; select * from student where stuno = #{stuno} \u0026lt;/select\u0026gt;  String statement = \u0026quot;org.lanqiao.entity.studentMapper.\u0026quot;+\u0026quot;queryStudentByStuno\u0026quot;; Student student = session.selectOne(statement,1)  查询多个\n\u0026lt;select id=\u0026quot;queryAllStudents\u0026quot; resultType=\u0026quot;org.lx.entity.Student\u0026quot; \u0026gt; select * from student \u0026lt;/select\u0026gt;  String statement = \u0026quot;org.lanqiao.entity.studentMapper.\u0026quot;+\u0026quot;queryAllStudents\u0026quot;; List\u0026lt;Student\u0026gt; students = session.selectList(statement)  mapper动态代理方式的crud （MyBatis接口开发）: 原则：约定优于配置\n硬编码方式\nabc.java\nConfiguration conf = new Configuration(); con.setName(\u0026quot;myProject\u0026quot;) ;  配置方式：\nabc.xml\n\u0026lt;name\u0026gt;myProject\u0026lt;/name\u0026gt;  配置方式优于硬编码方式\n约定方式优于硬编码方式\n约定：\n默认值就是myProject\n具体实现的步骤：\n 基础环境：\nmybatis.jar/ojdbc.jar、conf.xml、mapper.xml\n 不同之处\n约定的目标：省略掉statement,即根据约定直接可以定位出SQL语句\n   接口，接口中的方法必须遵循以下约定：\n 方法名和mapper.xml文件中标签的id值相同\n 方法的 输入参数和mapper.xml文件中标签的 parameterType类型一致 (如果mapper.xml的标签中没有 parameterType，则说明方法没有输入参数)\n 方法的返回值和mapper.xml文件中标签的 resultType类型一致 （无论查询结果是一个 还是多个（student、List\u0026lt;Student\u0026gt;），在mapper.xml标签中的resultType中只写 一个（Student）；如果没有resultType，则说明方法的返回值为void）\n  除了以上约定，要实现 接口中的方法 和 Mapper.xml中SQL标签一一对应，还需要以下1点：\nnamespace的值 ，就是 接口的全类名（ 接口 - mapper.xml 一一对应）   匹配的过程：（约定的过程）\n 根据 接口名 找到 mapper.xml文件（根据的是namespace=接口全类名） 根据 接口的方法名 找到 mapper.xml文件中的SQL标签 （方法名=SQL标签Id值）\n以上2点可以保证： 当我们调用接口中的方法时， 程序能自动定位到 某一个Mapper.xml文件中的sqL标签\n  习惯：SQL映射文件（mapper.xml） 和 接口放在同一个包中 （注意修改conf.xml中加载mapper.xml文件的路径）\n以上，可以通过接口的方法-\u0026gt;SQL语句\n接口中的方法-\u0026gt;SQL语句\n执行：\n通过session对象获取接口（session.getMapper(接口.class);），再调用该接口中的方法，程序会自动执行该方法对应的SQL。\n增加 \u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;org.lanqiao.entity.Student\u0026quot; \u0026gt; insert into student(stuno,stuname,stuage,graname) values(#{stuNo},#{stuName},#{stuAge},#{graName} ) \u0026lt;/insert\u0026gt;  void addStudent(Student student);  Student student = new Student(13, \u0026quot;ww3\u0026quot;, 23, \u0026quot;s3\u0026quot;); StudentMapper studentMapper = session.getMapper(StudentMapper.class); studentMapper.addStudent(student);  删除 \u0026lt;delete id=\u0026quot;deleteStudentByStuno\u0026quot; parameterType=\u0026quot;int\u0026quot;\u0026gt; delete from student where stuno = #{stuno} \u0026lt;/delete\u0026gt;  void deleteStudentByStuno(int stuno);  StudentMapper studentMapper = session.getMapper(StudentMapper.class); studentMapper.deleteStudentByStuno(13);  修改 \u0026lt;update id=\u0026quot;updateStudentByStuno\u0026quot; parameterType=\u0026quot;org.lx.entity.Student\u0026quot; \u0026gt; update student set stuname=#{stuName} ,stuage=#{stuAge},graname=#{graName} where stuno=#{stuNo} \u0026lt;/update\u0026gt;  void updateStudentByStuno(Student student);  // 修改的参数 Student student = new Student(); // 修改哪个人，where stuno =2 student.setStuNo(2); // 修改成什么样子？ student.setStuName(\u0026quot;ls\u0026quot;); student.setStuAge(24); student.setGraName(\u0026quot;s1\u0026quot;); // 执行 StudentMapper studentMapper = session.getMapper(StudentMapper.class); studentMapper.updateStudentByStuno(student);  查询 查询单个学生\n\u0026lt;select id=\u0026quot;queryStudentByStuno\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;org.lanqiao.entity.Student\u0026quot; \u0026gt; select * from student where stuno = #{stuno} \u0026lt;/select\u0026gt;  Student queryStudentByStuno(int stuno);  StudentMapper studentMapper = session.getMapper(StudentMapper.class); Student student = studentMapper.queryStudentByStuno  查询多个\n\u0026lt;select id=\u0026quot;queryAllStudents\u0026quot; resultType=\u0026quot;org.lanqiao.entity.Student\u0026quot; \u0026gt; select * from student \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryAllStudents();  StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u0026lt;Student\u0026gt; students = studentMapper.queryAllStudents();// 接口的方法-\u0026gt;SQL  优化、 可以将配置信息 单独放入 db.properties文件中，然后再动态引入 新建文件db.properties\ndriver=oracle.jdbc.OracleDriver url=jdbc:oracle:thin:@127.0.0.1:1521:ORCL username=scott password=tiger  配置\n\u0026lt;configuration\u0026gt; \u0026lt;properties resource=\u0026quot;db.properties\u0026quot;/\u0026gt;  使用\n\u0026lt;environment id=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot; /\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;!-- 配置数据库信息 --\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;${driver}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;${url}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;${username}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${password}\u0026quot; /\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt;  引入之后，使用${key}\nMyBatis全局参数 Mybatis全局参数.png\n了解即可\n在conf.xml中设置，在configuration里面\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026quot;cacheEnabled\u0026quot; value=\u0026quot;false\u0026quot; /\u0026gt; \u0026lt;setting name=\u0026quot;lazyLoadingEnabled\u0026quot; value=\u0026quot;false\u0026quot; /\u0026gt; \u0026lt;/settings\u0026gt;  别名 conf.xml  设置单个别名\n\u0026lt;!-- 设置单个/多个别名 --\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;!-- 单个别名 （别名 忽略大小写） --\u0026gt; \u0026lt;typeAlias type=\u0026quot;org.lanqiao.entity.Student\u0026quot; alias=\u0026quot;student\u0026quot;/\u0026gt; \u0026lt;/typeAliases\u0026gt;  使用,在xxMapper.xml中\n\u0026lt;select id=\u0026quot;queryAllStudents\u0026quot; resultType=\u0026quot;sTuDenT\u0026quot; \u0026gt; select * from student \u0026lt;/select\u0026gt;  别名，忽略大小写\n 批量设置别名\n\u0026lt;typeAliases\u0026gt; \u0026lt;!-- 批量定义别名 （别名 忽略大小写），以下会自动将该包中的所有类 批量定义别名： 别名就是类名（不带包名，忽略大小写） --\u0026gt; \u0026lt;package name=\u0026quot;org.lanqiao.entity\u0026quot;/\u0026gt; \u0026lt;/typeAliases\u0026gt;  别名，忽略大小写\n  除了自定义别名外，MyBatis还内置了一些常见类的别名。\n类型处理器（类型转换器） MyBatis自带一些常见的类型处理器 自定义MyBatis类型处理器 java -数据库(jdbc类型)  示例：\n实体类Student : boolean stuSex\ntrue:男 false：女  表student： number stuSex\n1:男 0：女  自定义类型转换器（boolean -number）步骤：\n 创建转换器：需要实现TypeHandler接口\n通过阅读源码发现，此接口有一个实现类 BaseTypeHandler ，因此 要实现转换器有2种选择：\n 实现接口TypeHandler接口 继承BaseTypeHandler\n//BaseTypeHandler\u0026lt;java类型\u0026gt; public class BooleanAndIntConverter extends BaseTypeHandler\u0026lt;Boolean\u0026gt;{ //java(boolean)-DB(number) /* * ps:PreparedStatement对象 * i:PreparedStatement对象操作参数的位置 * parameter:java值 * jdbcType：JDBC操作的数据库类型 */ @Override public void setNonNullParameter(PreparedStatement ps, int i, Boolean parameter, JdbcType jdbcType) throws SQLException { if(parameter) { //1 ps.setInt(i, 1); }else { // 0 ps.setInt(i, 0); } } //db(number)-\u0026gt;java(boolean) @Override public Boolean getNullableResult(ResultSet rs, String columnName) throws SQLException { int sexNum = rs.getInt(columnName) ;//rs.getInt(\u0026quot;stuno\u0026quot;) ; // if(sexNum == 1) // // return true; // else { // return false ; // } return sexNum == 1?true:false ; } @Override public Boolean getNullableResult(ResultSet rs, int columnIndex) throws SQLException { int sexNum = rs.getInt(columnIndex) ;//rs.getInt(1) return sexNum == 1?true:false ; } @Override public Boolean getNullableResult(CallableStatement cs, int columnIndex) throws SQLException { int sexNum = cs.getInt(columnIndex) ;//rs.getInt(1) return sexNum == 1?true:false ; } }   配置conf.xml\n\u0026lt;typeHandlers\u0026gt; \u0026lt;typeHandler handler=\u0026quot;org.lanqiao.converter.BooleanAndIntConverter\u0026quot; javaType=\u0026quot;Boolean\u0026quot; jdbcType=\u0026quot;INTEGER\u0026quot; /\u0026gt; \u0026lt;/typeHandlers\u0026gt;  使用\n查询\n\u0026lt;!-- 查询：使用了类型转换器 1如果 类中属性 和表中的字段 类型能够合理识别 （String-varchar2），则可以使用resultType;否则(boolean-number) 使用resultMap 2如果 类中属性名 和表中的字段名能够合理识别 （stuNo -stuno）则可以使用resultType;否则(id-stuno) 使用resultMap --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentByStunoWithConverter\u0026quot; parameterType=\u0026quot;int\u0026quot; resultMap=\u0026quot;studentResult\u0026quot; \u0026gt; select * from student where stuno = #{stuno} \u0026lt;/select\u0026gt;  \u0026lt;resultMap type=\u0026quot;student\u0026quot; id=\u0026quot;studentResult\u0026quot;\u0026gt; \u0026lt;!-- 分为主键id 和非主键 result--\u0026gt; \u0026lt;id property=\u0026quot;stuNo\u0026quot; column=\u0026quot;stuno\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuName\u0026quot; column=\u0026quot;stuname\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuAge\u0026quot; column=\u0026quot;stuage\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;graName\u0026quot; column=\u0026quot;graname\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuSex\u0026quot; column=\u0026quot;stusex\u0026quot; javaType=\u0026quot;boolean\u0026quot; jdbcType=\u0026quot;INTEGER\u0026quot;/\u0026gt; \u0026lt;/resultMap\u0026gt;  注意#{stuNo} 中存放的是 属性值，需要严格区分大小写。\nresultMap可以实现2个功能：\n 类型转换\n 属性-字段的映射关系\n\u0026lt;resultMap type=\u0026quot;student\u0026quot; id=\u0026quot;studentMapping\u0026quot;\u0026gt; \u0026lt;!-- 分为主键id 和非主键 result--\u0026gt; \u0026lt;id property=\u0026quot;id\u0026quot; column=\u0026quot;stuno\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuName\u0026quot; column=\u0026quot;stuname\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuAge\u0026quot; column=\u0026quot;stuage\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;graName\u0026quot; column=\u0026quot;graname\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuSex\u0026quot; column=\u0026quot;stusex\u0026quot; javaType=\u0026quot;boolean\u0026quot; jdbcType=\u0026quot;INTEGER\u0026quot;/\u0026gt; \u0026lt;/resultMap\u0026gt;  当表中的字段名和类中的属性名不同是，也可以通过resultMap进行转换\nStudent queryStudentByStunoWithConverter(int stuno);  StudentMapper studentMapper = session.getMapper(StudentMapper.class); Student student = studentMapper.queryStudentByStunoWithConverter(1);// 接口中的方法-\u0026gt;SQL语句   需要注意的问题： INTEGER\n查询：使用了类型转换器\n 如果 类中属性 和表中的字段 类型能够合理识别 （String-varchar2），则可以使用resultType;否则(boolean-number) 使用resultMap\n 如果 类中属性名 和表中的字段名能够合理识别 （stuNo -stuno）则可以使用resultType;否则(id-stuno) 使用resultMap\n  增加\n\u0026lt;!-- 带转换器的增加 --\u0026gt; \u0026lt;insert id=\u0026quot;addStudentWithConverter\u0026quot; parameterType=\u0026quot;student\u0026quot; \u0026gt; insert into student(stuno,stuname,stuage,graname,stusex) values(#{stuNo},#{stuName},#{stuAge},#{graName} ,#{stuSex ,javaType=boolean ,jdbcType=INTEGER } ) \u0026lt;/insert\u0026gt;  //增加 void addStudentWithConverter(Student student);  Student student = new Student(63, \u0026quot;ww53\u0026quot;, 23, \u0026quot;s3\u0026quot;); student.setStuSex(true);// 1 StudentMapper studentMapper = session.getMapper(StudentMapper.class); studentMapper.addStudentWithConverter(student); session.commit(); // 提交事务   输入参数：parameterType 类型为 简单类型（8个基本类型+String） #{}、${}的区别\n 存放的值不同\n#{任意值},一般建议不要乱写，即见名知意 ${value} ，其中的标识符只能是value  输出不同\n#{}自动给String类型加上'' （自动类型转换） ${} 原样输出，但是适合于 动态排序（动态字段） select stuno,stuname,stuage from student where stuname = #{value} select stuno,stuname,stuage from student where stuname = '${value}'  动态排序：\n\u0026lt;select id=\u0026quot;queryStudentOrderByColumn\u0026quot; parameterType=\u0026quot;string\u0026quot; resultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student order by ${value} asc \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentOrderByColumn(String column);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentOrderByColumn(\u0026quot;stuno\u0026quot;) ;//接口的方法-\u0026gt;SQL  SQL注入\n#{}可以防止SQL注入\n${}不防止\n  ${}、#{}相同之处：  都可以 获取对象的值 （嵌套类型对象）\n模糊查询，方式一：\n\u0026lt;select id=\u0026quot;queryStudentBystuageOrstuName\u0026quot; parameterType=\u0026quot;student\u0026quot; resultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student where stuage= #{stuAge} or stuname like #{stuName} \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentBystuageOrstuName(Student student);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; Student student = new Student(); student.setStuAge(24); student.setStuName(\u0026quot;%w%\u0026quot;); List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentBystuageOrstuName(student) ;//接口的方法-\u0026gt;SQL  like #{stuName} student.setStuName(\u0026quot;%w%\u0026quot;);  模糊查询，方式二：\n\u0026lt;select id=\u0026quot;queryStudentBystuageOrstuName\u0026quot; parameterType=\u0026quot;student\u0026quot; resultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student where stuage= #{stuAge} or stuname like '%${stuName}%' \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentBystuageOrstuName(Student student);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; Student student = new Student(); student.setStuAge(24); student.setStuName(\u0026quot;w\u0026quot;); List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentBystuageOrstuName(student) ;//接口的方法-\u0026gt;SQL  like '%${stuName}%' student.setStuName(\u0026quot;w\u0026quot;);  嵌套类型对象\n  Address.java\npublic class Address { private String homeAddress; private String schoolAddress; public String getHomeAddress() { return homeAddress; } public void setHomeAddress(String homeAddress) { this.homeAddress = homeAddress; } public String getSchoolAddress() { return schoolAddress; } public void setSchoolAddress(String schoolAddress) { this.schoolAddress = schoolAddress; } }  Student.java包含Address的对象\nprivate Address address;//家庭、学校 public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; }   方式一\n\u0026lt;select id=\u0026quot;queryStudentByaddress\u0026quot; parameterType=\u0026quot;address\u0026quot; resultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student where homeaddress = #{homeAddress} or schooladdress = '${schoolAddress}' \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentByaddress(Address address);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; Address address = new Address(); address.setHomeAddress(\u0026quot;xa\u0026quot;); address.setSchoolAddress(\u0026quot;x\u0026quot;); List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentByaddress(address) ;  方式二:级联属性\n\u0026lt;!-- 输入参数为 级联属性 --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentByaddress\u0026quot; parameterType=\u0026quot;student\u0026quot; resultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student where homeaddress = #{address.homeAddress} or schooladdress = '${address.schoolAddress}' \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentByaddress(Student address);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; Student student = new Student(); Address address = new Address(); address.setHomeAddress(\u0026quot;xa\u0026quot;); address.setSchoolAddress(\u0026quot;xxxxxx\u0026quot;); student.setAddress(address); List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentByaddress(student) ;  方式三：输入对象为HashMap：\n\u0026lt;select id=\u0026quot;queryStudentBystuageOrstuNameWithHashMap\u0026quot; parameterType=\u0026quot;HashMap\u0026quot; resultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student where stuage= #{stuAge} or stuname like '%${stuName}%' \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentBystuageOrstuNameWithHashMap(Map\u0026lt;String,Object\u0026gt; map);//String,Object  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; Map\u0026lt;String,Object\u0026gt; studentMap = new HashMap\u0026lt;\u0026gt;(); studentMap.put(\u0026quot;stuAge\u0026quot;, 24) ; studentMap.put(\u0026quot;stuName\u0026quot;, \u0026quot;zs\u0026quot;) ; List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentBystuageOrstuNameWithHashMap (studentMap) ;//接口的方法-\u0026gt;SQL  where stuage= #{stuAge}\n用map中key的值 匹配 占位符#{stuAge}，如果匹配成功 就用map的value替换占位符\n  mybatis调用存储过程 创建存储过程 查询某个年级的 学生总数\n输入：年级\n输出：该年级的学生总数\ncreate or replace procedure queryCountByGradeWithProcedure(gName in varchar, scount out number ) as begin select count(*) into scount from student where graname = gname ; end; /  根据学号删除学生\ncreate or replace procedure deleteStuBynoWithProcedure(sno in number) as begin delete from student where stuno = sno ; end; /  调用存储过程实现查询 \u0026lt;!-- 通过调用[存储过程] 实现查询 ,statementType=\u0026quot;CALLABLE\u0026quot; 存储过程的输入参数，在mybatis用Map来传递（HashMap） --\u0026gt; \u0026lt;select id=\u0026quot;queryCountByGradeWithProcedure\u0026quot; statementType=\u0026quot;CALLABLE\u0026quot; parameterType=\u0026quot;HashMap\u0026quot; \u0026gt; { CALL queryCountByGradeWithProcedure( #{gName,jdbcType=VARCHAR,mode=IN}, #{scount,jdbcType=INTEGER,mode=OUT} ) }\t\u0026lt;/select\u0026gt;  void queryCountByGradeWithProcedure(Map\u0026lt;String,Object\u0026gt; params );  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; //通过map给 存储过程指定输入参数 Map\u0026lt;String,Object\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026quot;gName\u0026quot;, \u0026quot;g1\u0026quot;) ;//指定存储过程的输入参数gName的值是g1 studentMapper.queryCountByGradeWithProcedure(params);//调用存储过程，并传入输入参数 //获取存储过程的输出参数 Object count = params.get(\u0026quot;scount\u0026quot;) ;  其中 通过statementType=\u0026ldquo;CALLABLE\u0026rdquo;设置SQL的执行方式是存储过程。 存储过程的输入参数gName需要通过HashMap来指定 在使用时，通过hashmap的put方法传入输入参数的值；通过hashmap的Get方法 获取输出参数的值。\n要注意Jar问题：ojdbc6.jar不能在 调存储过程时 打回车、tab，但是ojdbc7.jar可以。\n如果报错： No enum constant org.apache.ibatis.type.JdbcType.xx，则说明mybatis不支持xx类型，需要查表。\n调用存储过程实现删除 \u0026lt;!-- 通过存储过程实现删除 --\u0026gt; \u0026lt;delete id=\u0026quot;deleteStuBynoWithProcedure\u0026quot; statementType=\u0026quot;CALLABLE\u0026quot; parameterType=\u0026quot;HashMap\u0026quot;\u0026gt; { CALL deleteStuBynoWithProcedure( #{sno,jdbcType=INTEGER,mode=IN} ) }\t\u0026lt;/delete\u0026gt;  void deleteStuBynoWithProcedure(Map\u0026lt;String,Object\u0026gt; params );  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026quot;sno\u0026quot;, 3) ; studentMapper.deleteStuBynoWithProcedure( map) ; session.commit(); session.close();  存储过程 无论输入参数是什么值，语法上都需要 用map来传递该值；\n只要 是 \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot;/\u0026gt;，则增删改都需要手工commit ;\n输出参数 输出参数resultType\n简单类型（8个基本+String） \u0026lt;select id=\u0026quot;queryStudentCount\u0026quot; resultType=\u0026quot;int\u0026quot; \u0026gt; select count(*) from student \u0026lt;/select\u0026gt;  int queryStudentCount();  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; int count = studentMapper.queryStudentCount();  输出参数为实体对象类型 \u0026lt;select id=\u0026quot;queryStuByStuno\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;student\u0026quot; \u0026gt; select * from student where stuno = ${value} \u0026lt;/select\u0026gt;  Student queryStuByStuno(int stuno);  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; Student student = studentMapper.queryStuByStuno(2) ;//接口中的方法-\u0026gt;SQL语句  输出参数为实体对象类型的集合 虽然输出类型为集合，但是resultType依然写 集合的元素类型（resyltType=\u0026ldquo;Student\u0026rdquo;）\n\u0026lt;select id=\u0026quot;queryAllStudents\u0026quot; resultType=\u0026quot;Student\u0026quot; \u0026gt; select * from student \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryAllStudents();  StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u0026lt;Student\u0026gt; students = studentMapper.queryAllStudents();// 接口的方法-\u0026gt;SQL  输出参数类型为HashMap \u0026lt;!-- 别名作为Map的key --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentOutByHashMap\u0026quot; resultType=\u0026quot;HashMap\u0026quot; \u0026gt; select stuno \u0026quot;no\u0026quot;,stuname \u0026quot;name\u0026quot; from student where stuno=1 \u0026lt;/select\u0026gt;  HashMap\u0026lt;String,Object\u0026gt; queryStudentOutByHashMap();  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; HashMap\u0026lt;String,Object\u0026gt; studentMap = studentMapper.queryStudentOutByHashMap();  HashMap本身是一个集合，可以存放多个元素，但是根据提示发现 返回值为HashMap时 ，查询的结果只能是1个学生（no,name）\n结论：一个HashMap 对应一个学生的多个元素（多个属性） 【一个map，一个学生】\n比较像二维数组，一个数组是一个HashMap对象\n{ {1,zs,23,xa}, -一个HashMap对象 {2,ls,24,bj}, {3,ww,25,tj} }  获取多个HashMap\n\u0026lt;select id=\u0026quot;queryAllStudentsOutByHashMap\u0026quot; resultType=\u0026quot;HashMap\u0026quot; \u0026gt; select stuno \u0026quot;no\u0026quot;,stuname \u0026quot;name\u0026quot; from student \u0026lt;/select\u0026gt;  List\u0026lt;HashMap\u0026lt;String,Object\u0026gt;\u0026gt; queryAllStudentsOutByHashMap();  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; List\u0026lt;HashMap\u0026lt;String,Object\u0026gt;\u0026gt; studentMap = studentMapper.queryAllStudentsOutByHashMap();  resultType\nresultMap:实体类的属性、数据表的字段： 类型、名字不同时（stuno,id）\n注意：当属性名 和字段名 不一致时，除了使用resultMap以外，还可以使用resultType+HashMap:\nresultMap \u0026lt;select id=\u0026quot;queryStudentById\u0026quot; parameterType=\u0026quot;int\u0026quot;\tresultMap=\u0026quot;queryStudentByIdMap\u0026quot; \u0026gt; select id,name from student where id = #{id} \u0026lt;/select\u0026gt; \u0026lt;resultMap type=\u0026quot;student\u0026quot; id=\u0026quot;queryStudentByIdMap\u0026quot;\u0026gt; \u0026lt;!-- 指定类中的属性 和 表中的字段 对应关系 --\u0026gt; \u0026lt;id property=\u0026quot;stuNo\u0026quot; column=\u0026quot;id\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuName\u0026quot; column=\u0026quot;name\u0026quot; /\u0026gt; \u0026lt;/resultMap\u0026gt;  Student queryStudentById(int stuno);  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; Student student = studentMapper.queryStudentById(2) ;//接口中的方法-\u0026gt;SQL语句  resultType+HashMap \u0026lt;select id=\u0026quot;queryStudentByIdWithHashMap\u0026quot; parameterType=\u0026quot;int\u0026quot;\tresultType=\u0026quot;student\u0026quot; \u0026gt; select id \u0026quot;stuNo\u0026quot;,name \u0026quot;stuName\u0026quot; from student where id = #{id} \u0026lt;/select\u0026gt;  Student queryStudentByIdWithHashMap(int stuno);  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; Student student = studentMapper.queryStudentByIdWithHashMap(2) ;//接口中的方法-\u0026gt;SQL语句  select 表的字段名 \u0026ldquo;类的属性名\u0026rdquo; from\u0026hellip; 来制定字段名 和属性名的对应关系\n注意: 如果如果10个字段，但发现 某一个字段结果始终为默认值（0，0.0，null），则可能是 表的字段 和 类的属性名字写错。\n动态SQL //查询全部 String statement = \u0026quot;select stuno,stuname from student\u0026quot;; //根据年龄查询学生 String statement = \u0026quot;select stuno,stuname from student where stuage = #{stuage}\u0026quot;; //根据姓名和年龄查询学生 String statement = \u0026quot;select stuno,stuname from student where stuage = #{stuage} and stuage = #{stuage} \u0026quot;;  可以发现其中有重复的部分\n\u0026lt;select id=\u0026quot;queryStuByNOrAWishSQLTag\u0026quot; parameterType=\u0026quot;student\u0026quot;\tresultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student \u0026lt;where\u0026gt; \u0026lt;!-- \u0026lt;if test=\u0026quot;student有stuname属性 且不为null\u0026quot;\u0026gt; 属性严格区分大小写--\u0026gt; \u0026lt;if test=\u0026quot;stuName !=null and stuName!='' \u0026quot;\u0026gt; and stuname = #{stuName} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;stuAge !=null and stuAge!=0 \u0026quot;\u0026gt; and stuage = #{stuAge} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;  Student queryStuByNOrAWishSQLTag(Student student);  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; Student stu = new Student(); stu.setStuAge(24); //stu.setStuName(\u0026quot;ls\u0026quot;); Student student = studentMapper.queryStuByNOrAWishSQLTag(stu) ;//接口中的方法-\u0026gt;SQL语句  处理and的两种方式\n 方式一\n\u0026lt;select id=\u0026quot;queryStuByNOrAWishSQLTag\u0026quot; parameterType=\u0026quot;student\u0026quot; resultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student where 1=1 \u0026lt;if test=\u0026quot;stuName !=null and stuName!='' \u0026quot;\u0026gt; and stuname = #{stuName} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;stuAge !=null and stuAge!=0 \u0026quot;\u0026gt; and stuage = #{stuAge} \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt;  方式二 （推荐）\n\u0026lt;select id=\u0026quot;queryStuByNOrAWishSQLTag\u0026quot; parameterType=\u0026quot;student\u0026quot; resultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student \u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;stuName !=null and stuName!='' \u0026quot;\u0026gt; and stuname = #{stuName} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;stuAge !=null and stuAge!=0 \u0026quot;\u0026gt; and stuage = #{stuAge} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;  \u0026lt;where\u0026gt;会自动处理第一个（满足条件的第一个）\u0026lt;if\u0026gt;标签中的 and，但不会处理之后\u0026lt;if\u0026gt;中的and。\n  foreach 查询学号为1、2、53的学生信息\nsql语句\nselect stuno,stuname from student where stuno in(1,2,53)  \u0026lt;foreach\u0026gt;迭代的类型：数组、对象数组、集合、属性(Grade类： List\u0026lt;Integer\u0026gt; ids)\n属性 (Grade类： List\u0026lt;Integer\u0026gt; ids\npublic class Grade { //学号 private List\u0026lt;Integer\u0026gt; stuNos ; public List\u0026lt;Integer\u0026gt; getStuNos() { return stuNos; } public void setStuNos(List\u0026lt;Integer\u0026gt; stuNos) { this.stuNos = stuNos; } }  \u0026lt;!-- 将多个元素值 放入对象的属性中 --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentsWithNosInGrade\u0026quot; parameterType=\u0026quot;grade\u0026quot; resultType=\u0026quot;student\u0026quot;\u0026gt; select * from student \u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;stuNos!=null and stuNos.size\u0026gt;0\u0026quot;\u0026gt; \u0026lt;foreach collection=\u0026quot;stuNos\u0026quot; open=\u0026quot; and stuno in (\u0026quot; close=\u0026quot;)\u0026quot; item=\u0026quot;stuNo\u0026quot; separator=\u0026quot;,\u0026quot;\u0026gt; #{stuNo} \u0026lt;/foreach\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;  collection:集合 select * from student +open: select * from student and stuno in ( +item: select * from student and stuno in (1,2,53 +close: select * from student and stuno in (1,2,53) separator:分隔符  List\u0026lt;Student\u0026gt; queryStudentsWithNosInGrade(Grade grade);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; Grade grade = new Grade(); List\u0026lt;Integer\u0026gt; stuNos = new ArrayList\u0026lt;\u0026gt;(); stuNos.add(1) ; stuNos.add(2) ; // stuNos.add(53) ; grade.setStuNos(stuNos); List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentsWithNosInGrade(grade) ;  简单类型的数组: \u0026lt;!-- 将多个元素值 放入数组中 int[] stuNos = {1,2,53} --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentsWithArray\u0026quot; parameterType=\u0026quot;int[]\u0026quot; resultType=\u0026quot;student\u0026quot;\u0026gt; select * from student \u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;array!=null and array.length\u0026quot;\u0026gt; \u0026lt;foreach collection=\u0026quot;array\u0026quot; open=\u0026quot; and stuno in (\u0026quot; close=\u0026quot;)\u0026quot; item=\u0026quot;stuNo\u0026quot; separator=\u0026quot;,\u0026quot;\u0026gt; #{stuNo} \u0026lt;/foreach\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;  约定：无论编写代码时，传递的是什么参数名(stuNos)，在mapper.xml中 必须用array代替该数组\nList\u0026lt;Student\u0026gt; queryStudentsWithArray(int[] stuNos);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; int[] stuNos = {1,2,53}; List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentsWithArray(stuNos) ;  对象数组： \u0026lt;!-- 将多个元素值 放入对象数组中Student[] students = {student0,student1,student2} 每个studentx包含一个学号属性 --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentsWithObjectArray\u0026quot; parameterType=\u0026quot;Object[]\u0026quot; resultType=\u0026quot;student\u0026quot;\u0026gt; select * from student \u0026lt;!--如果sql片段和 引用处不在同一个文件中，则需要 在refid 引用时 加上namespace: namespace.id \u0026lt;include refid=\u0026quot;org.lanqiao.mapper.abcMapper.objectArrayStunos\u0026quot;\u0026gt;\u0026lt;/include\u0026gt; --\u0026gt; \u0026lt;include refid=\u0026quot;objectArrayStunos\u0026quot;\u0026gt;\u0026lt;/include\u0026gt; \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentsWithObjectArray(Student[] students);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; Student stu1 = new Student(); stu1.setStuNo(1); Student stu2 = new Student(); stu2.setStuNo(2); Student stu53 = new Student(); stu53.setStuNo(53); Student[] stus = new Student[] {stu1,stu2,stu53}; List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentsWithObjectArray(stus);  集合： 无论编写代码时，传递的是什么参数名(stuNos)，在mapper.xml中 必须用list代替该数组\n\u0026lt;!-- 将多个元素值 放入数组中 List\u0026lt;Integer\u0026gt; stuNos 值 {1,2,53} --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentsWithList\u0026quot; parameterType=\u0026quot;list\u0026quot; resultType=\u0026quot;student\u0026quot;\u0026gt; select * from student \u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;list!=null and list.size\u0026gt;0\u0026quot;\u0026gt; \u0026lt;foreach collection=\u0026quot;list\u0026quot; open=\u0026quot; and stuno in (\u0026quot; close=\u0026quot;)\u0026quot; item=\u0026quot;stuNo\u0026quot; separator=\u0026quot;,\u0026quot;\u0026gt; #{stuNo} \u0026lt;/foreach\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentsWithList(List\u0026lt;Integer\u0026gt; stuNos);  List\u0026lt;Integer\u0026gt; stuNos = new ArrayList\u0026lt;\u0026gt;(); stuNos.add(1) ; stuNos.add(2) ; stuNos.add(53) ; List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentsWithList(stuNos) ;  SQL片段： java：方法 数据库：存储过程、存储函数 Mybatis :SQL片段   提取相似代码 引用\n\u0026lt;sql id=\u0026quot;objectArrayStunos\u0026quot;\u0026gt; \u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;array!=null and array.length\u0026gt;0\u0026quot;\u0026gt; \u0026lt;foreach collection=\u0026quot;array\u0026quot; open=\u0026quot; and stuno in (\u0026quot; close=\u0026quot;)\u0026quot; item=\u0026quot;student\u0026quot; separator=\u0026quot;,\u0026quot;\u0026gt; #{student.stuNo} \u0026lt;/foreach\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/sql\u0026gt;  \u0026lt;select id=\u0026quot;queryStudentsWithObjectArray\u0026quot; parameterType=\u0026quot;Object[]\u0026quot; resultType=\u0026quot;student\u0026quot;\u0026gt; select * from student \u0026lt;!--如果sql片段和 引用处不在同一个文件中，则需要 在refid 引用时 加上namespace: namespace.id \u0026lt;include refid=\u0026quot;org.lanqiao.mapper.abcMapper.objectArrayStunos\u0026quot;\u0026gt;\u0026lt;/include\u0026gt; --\u0026gt; \u0026lt;include refid=\u0026quot;objectArrayStunos\u0026quot;\u0026gt;\u0026lt;/include\u0026gt; \u0026lt;/select\u0026gt;   关联查询 两张表\nstudent\nstuno stuname cardid  studentCard\ncardid cardinfo  一对一  业务扩展类\n核心：用resultType指定类的属性 包含 多表查询的所有字段\n resultMap\n  业务扩展类做法：\n新建业务扩展类，类中既包含了A的属性也包含了B的属性，继承一个属性多的类，重写一个属性较少的类的属性\npublic class StudentBusiness extends Student{//学生业务扩展类 private int cardId; private String cardInfo ; public int getCardId() { return cardId; } public void setCardId(int cardId) { this.cardId = cardId; } public String getCardInfo() { return cardInfo; } public void setCardInfo(String cardInfo) { this.cardInfo = cardInfo; } @Override public String toString() { return super.toString() + \u0026quot;,\u0026quot;+this.cardId+\u0026quot;,\u0026quot;+this.cardInfo; } }  \u0026lt;select id=\u0026quot;queryStudentByNoWithOO\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;StudentBusiness\u0026quot; \u0026gt; select s.*,c.* from student s inner join studentcard c on s.cardid=c.cardid where s.stuno = #{stuNo} \u0026lt;/select\u0026gt;  StudentBusiness queryStudentByNoWithOO(int stuno);  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; StudentBusiness studentBusiness = studentMapper.queryStudentByNoWithOO(2) ;//接口中的方法-\u0026gt;SQL语句  resultMap的做法\n表与表之间通过外键进行连接，那么，类与类之间通过属性进行连接\n通过 属性成员 将2个类建立起联系\n把其中一个类作为另一个的类的属性\n//学生类 包含：1学生信息 2学生证信息 public class Student { //1学生信息 private int stuNo ; private String stuName ; private int stuAge ; private String graName ; private boolean stuSex ; //2学生证信息 private StudentCard card ; x x x x }  \u0026lt;resultMap type=\u0026quot;student\u0026quot; id=\u0026quot;student_card_map\u0026quot;\u0026gt; \u0026lt;!-- 学生的信息 --\u0026gt; \u0026lt;id property=\u0026quot;stuNo\u0026quot; column=\u0026quot;stuNo\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;stuName\u0026quot; column=\u0026quot;stuName\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuAge\u0026quot; column=\u0026quot;stuAge\u0026quot; /\u0026gt; \u0026lt;!-- 一对一时，对象成员使用 association映射;javaType指定该属性的类型--\u0026gt; \u0026lt;association property=\u0026quot;card\u0026quot; javaType=\u0026quot;StudentCard\u0026quot; \u0026gt; \u0026lt;id property=\u0026quot;cardId\u0026quot; column=\u0026quot;cardId\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;cardInfo\u0026quot; column=\u0026quot;cardInfo\u0026quot;/\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt;  \u0026lt;!-- 利用resultMap实现一对一 --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentByNoWithOO2\u0026quot; parameterType=\u0026quot;int\u0026quot; resultMap=\u0026quot;student_card_map\u0026quot; \u0026gt; select s.*,c.* from student s inner join studentcard c on s.cardid=c.cardid where s.stuno = #{stuNo} \u0026lt;/select\u0026gt;  Student queryStudentByNoWithOO2(int stuNo);  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; Student student = studentMapper.queryStudentByNoWithOO2(2) ;  一对多 （MyBatis:多对一，多对多的本质就是 一对多的变化）\n表：\nstudentClass\nclassId className  student\nstuno stuname classId  其中两个学生对应一个班级\n班级类中增加学生属性\npublic class StudentClass { private int classId; private String className; //增加学生属性 (通过该字段 让Student类和StudentClass类建立起关联) List\u0026lt;Student\u0026gt; students ; x x x }  \u0026lt;!-- 类-表的对应关系 --\u0026gt; \u0026lt;resultMap type=\u0026quot;studentClass\u0026quot; id=\u0026quot;class_student_map\u0026quot;\u0026gt; \u0026lt;!-- 因为 type的主类是班级，因此先配置班级的信息--\u0026gt; \u0026lt;id property=\u0026quot;classId\u0026quot; column=\u0026quot;classId\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;className\u0026quot; column=\u0026quot;className\u0026quot;/\u0026gt; \u0026lt;!-- 配置成员属性学生，一对多;属性类型：javaType，属性的元素类型ofType --\u0026gt; \u0026lt;collection property=\u0026quot;students\u0026quot; ofType=\u0026quot;student\u0026quot;\u0026gt; \u0026lt;id property=\u0026quot;stuNo\u0026quot; column=\u0026quot;stuNo\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;stuName\u0026quot; column=\u0026quot;stuName\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;stuAge\u0026quot; column=\u0026quot;stuAge\u0026quot;/\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt;  可以级联匹配，student中在配置studentcard的信息\n查询g1班的班级信息，和g1班的所有学生信息\n\u0026lt;select id=\u0026quot;queryClassAndStudents\u0026quot; parameterType=\u0026quot;int\u0026quot; resultMap=\u0026quot;class_student_map\u0026quot;\u0026gt; select c.*,s.* from student s inner join studentclass c on c.classid = s.classid where c.classid = #{classId} \u0026lt;/select\u0026gt;  StudentClass queryClassAndStudents(int classId);  StudentClassMapper studentClassMapper = session.getMapper(StudentClassMapper.class) ; //班级 List\u0026lt;StudentClass\u0026gt; studentClasses = studentClassMapper.queryClassAndStudents() ; //班级信息 for(StudentClass stuClass :studentClasses) { System.out.println(stuClass.getClassId()+\u0026quot;,\u0026quot;+stuClass.getClassName()); System.out.println(\u0026quot;-----------\u0026quot;); for(Student student: stuClass.getStudents()) { System.out.println(student.getStuNo()+\u0026quot;,\u0026quot;+student.getStuName()); } }  日志 如果不指定，Mybatis就会根据以下顺序 寻找日志\nSLF4J →Apache Commons Logging →Log4j 2 → Log4j →JDK logging  使用log4j\njar Log4j: log4j.jar (mybatis.zip中lib中包含此jar)  开启日志，conf.xml \u0026lt;settings\u0026gt; \u0026lt;!-- 开启日志，并指定使用的具体日志 --\u0026gt; \u0026lt;setting name=\u0026quot;logImpl\u0026quot; value=\u0026quot;LOG4J\u0026quot;/\u0026gt; \u0026lt;/settings\u0026gt;  编写配置日志输出文件 log4j.properties log4j.properties，内容\nlog4j.rootLogger=DEBUG, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n  DEBUG：级别\n日志级别：\nDEBUG\u0026lt;INFO\u0026lt;WARN\u0026lt;ERROR  如果设置为info，则只显示 info及以上级别的信息；\n建议：在开发时设置debug，在运行时设置为info或以上。\nstdout：在控制台输出\n可以通过日志信息，相信的阅读mybatis执行情况（ 观察mybatis实际执行sql语句 以及SQL中的参数 和返回结果）\n延迟加载（懒加载）： 一对一、一对多、多对一、多对多\n一对多：班级-学生 ，\n如果不采用延迟加载 （立即加载），查询时会将 一 和多 都查询，班级、班级中的所有学生。\n如果想要 暂时只查询1的一方， 而多的一方 先不查询 而是在需要的时候再去查询 \u0026ndash;\u0026gt;延迟加载\nmybatis中使用延迟加载，需要先配置：\n\u0026lt;settings\u0026gt; \u0026lt;!-- 开启延迟加载 --\u0026gt; \u0026lt;setting name=\u0026quot;lazyLoadingEnabled\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 关闭立即加载 --\u0026gt; \u0026lt;setting name=\u0026quot;aggressiveLazyLoading\u0026quot; value=\u0026quot;false\u0026quot;/\u0026gt; \u0026lt;/settings\u0026gt;  一对一：学生（student）、学生证（studentCard） studentCardMapper.xml\n\u0026lt;mapper namespace=\u0026quot;org.lanqiao.mapper.StudentCardMapper\u0026quot;\u0026gt; \u0026lt;!-- 查询学生证信息 --\u0026gt;\t\u0026lt;select id=\u0026quot;queryCardById\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;studentCard\u0026quot;\u0026gt; \u0026lt;!-- 查询学生对应的学生证 --\u0026gt; select * from studentCard where cardid = #{cardId} \u0026lt;/select\u0026gt; \u0026lt;!-- 根据cardid查询学生证的SQL： org.lanqiao.mapper.StudentCardMapper.queryCardById --\u0026gt; \u0026lt;/mapper\u0026gt;  加载mapper配置文件\n\u0026lt;mapper resource=\u0026quot;org/lanqiao/mapper/studentCardMapper.xml\u0026quot;/\u0026gt;  \u0026lt;resultMap type=\u0026quot;student\u0026quot; id=\u0026quot;student_card_lazyLoad_map\u0026quot;\u0026gt; \u0026lt;!-- 学生的信息 --\u0026gt; \u0026lt;id property=\u0026quot;stuNo\u0026quot; column=\u0026quot;stuNo\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;stuName\u0026quot; column=\u0026quot;stuName\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuAge\u0026quot; column=\u0026quot;stuAge\u0026quot; /\u0026gt; \u0026lt;!-- 一对一时，对象成员使用 association映射;javaType指定该属性的类型 此次采用延迟加载：在查询学生时，并不立即加载 学生证信息 --\u0026gt; \u0026lt;!-- 学生证 ,通过select 在需要的时候再查学生证 --\u0026gt; \u0026lt;association property=\u0026quot;card\u0026quot; javaType=\u0026quot;StudentCard\u0026quot; select=\u0026quot;org.lanqiao.mapper.StudentCardMapper.queryCardById\u0026quot; column=\u0026quot;cardid\u0026quot; \u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt;   \u0026lt;!-- 利用resultMap实现一对一 ，延迟加载--\u0026gt; \u0026lt;select id=\u0026quot;queryStudentWithOO2LazyLoad\u0026quot; parameterType=\u0026quot;int\u0026quot; resultMap=\u0026quot;student_card_lazyLoad_map\u0026quot; \u0026gt; \u0026lt;!-- 先查学生 --\u0026gt; select * from student \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentWithOO2LazyLoad();  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; //学生, List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentWithOO2LazyLoad(); //此时，只获取了学生的信息 for(Student student:students) { System.out.println(student.getStuNo()+\u0026quot;,\u0026quot;+student.getStuName()); //获取学生证，下一步即将获取学生证的信息 StudentCard card = student.getCard() ; System.out.println(card.getCardId()+\u0026quot;,\u0026quot;+card.getCardInfo()); } session.close();  如果增加了mapper.xml ,要修改conf.xml配置文件（将新增的mapper.xml加载进去）\n通过debug可以发现， 如果程序只需要学生，则只向数据库发送了查询学生的SQL；当我们后续 需要用到学生证的时候，再第二次发送 查询学生证的SQL。\n一对多：和一对一的延迟加载配置方法相同 延迟加载的步骤：先查班级，按需查询学生\n开启延迟加载conf.xml配置settings\n配置mapper.xml\nStudentClassMapper.xml\n\u0026lt;!-- 一对多，带延迟加载 --\u0026gt; \u0026lt;select id=\u0026quot;queryClassAndStudents\u0026quot; resultMap=\u0026quot;class_student_lazyLoad_map\u0026quot;\u0026gt; \u0026lt;!-- 先查询班级 --\u0026gt; select c.* from studentclass c \u0026lt;/select\u0026gt;  \u0026lt;!-- 类-表的对应关系 --\u0026gt; \u0026lt;resultMap type=\u0026quot;studentClass\u0026quot; id=\u0026quot;class_student_lazyLoad_map\u0026quot;\u0026gt; \u0026lt;id property=\u0026quot;classId\u0026quot; column=\u0026quot;classId\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;className\u0026quot; column=\u0026quot;className\u0026quot;/\u0026gt; \u0026lt;!-- 再查班级对应的学生 --\u0026gt; \u0026lt;collection property=\u0026quot;students\u0026quot; ofType=\u0026quot;student\u0026quot; select=\u0026quot;org.lanqiao.mapper.StudentMapper.queryStudentsByClassId\u0026quot; column=\u0026quot;classid\u0026quot;\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt;  StudentMapper.xml\n\u0026lt;!-- 一对多,延迟加载需要的： 查询班级中的所有学生 --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentsByClassId\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;student\u0026quot;\u0026gt; select * from student where classId = #{classId} \u0026lt;/select\u0026gt;  StudentClassMapper.java\n//查询全部班级 List\u0026lt;StudentClass\u0026gt; queryClassAndStudents();  StudentClassMapper studentClassMapper = session.getMapper(StudentClassMapper.class) ; //班级 List\u0026lt;StudentClass\u0026gt; studentClasses = studentClassMapper.queryClassAndStudents() ; //班级信息 for(StudentClass stuClass :studentClasses) { System.out.println(stuClass.getClassId()+\u0026quot;,\u0026quot;+stuClass.getClassName()); System.out.println(\u0026quot;-----------\u0026quot;); for(Student student: stuClass.getStudents()) { System.out.println(student.getStuNo()+\u0026quot;,\u0026quot;+student.getStuName()); } } session.close();  即查询 学生的sql是通过 select属性指定，并且通过column指定外键\n查询缓存 只涉及查询\n一级缓存 ：同一个SqlSession对象 MyBatis默认开启一级缓存，如果用同样的SqlSession对象查询相同的数据，则只会在第一次 查询时 向数据库发送SQL语句，并将查询的结果 放入到SQLSESSION中（作为缓存在）；后续再次查询该同样的对象时，则直接从缓存中查询该对象即可（即省略了数据库的访问）\n执行commit操作后会将缓存清空\n二级缓存 MyBatis默认情况没有开启二级缓存，需要手工打开。\n conf.xml\n\u0026lt;!-- 开启二级缓存 --\u0026gt; \u0026lt;setting name=\u0026quot;cacheEnabled\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;  在具体的mapper.xml中声明开启\n\u0026lt;!-- 声明次namespace开启二级缓存 --\u0026gt; \u0026lt;cache/\u0026gt;   根据异常提示：NotSerializableException可知，MyBatis的二级缓存 是将对象放入硬盘文件中(序列化)\n序列化：内存-\u0026gt;硬盘 反序列化：硬盘-\u0026gt;内存  准备缓存的对象，必须实现了序列化接口 （如果开启的缓存Namespace=\u0026ldquo;org.lanqiao.mapper.StudentMapper\u0026rdquo;），可知序列化对象为Student，因此需要将Student序列化 （序列化Student类，以及Student的级联属性、和父类）\npublic class Student implements Serializable{} public class StudentCard implements Serializable{}  二级缓存，实际存放的位置在硬盘中\n触发将对象写入二级缓存的时机：SqlSession对象的close()方法。将一级缓存的对象放入硬盘\n日志中会发现有Cache Hit Ratio[xxxx]:0.0和Cache Hit Ratio[xxxx]:0.5，它的意思是命中率的问题。\n第一次查询时，二级缓存中没有，因此是0.0；第二次之前已经close了，因此将查询结果放入二级缓存；第二次查询，总共查询了两次，查到了结果，因此命中率是0.5\n命中率：\n1:zs :0% 2: 50% 3: 2/3 0.666 4: 3/4 0.75  Mybatis自带二级缓存：【同一个namespace】生成的mapper对象 回顾：namespace的值 就是 接口的全类名（包名.类名）， 通过接口可以产生代理对象（studentMapper对象\u0026mdash;\u0026gt;namespace决定了studentMapper对象的产生\n结论：只要产生的xxxMapper对象 来自于同一个namespace，则 这些对象 共享二级缓存。\n如果是同一个SqlSession对象进行多次相同的查询，则直接进入一级缓存查询；如果不是同一个SqlSession对象进行多次相同的查询（但是来自于同一个namespace）则进入二级缓存查询\n注意：二级缓存 的范围是同一个namespace, 如果有多个xxMapper.xml的namespace值相同，则通过这些xxxMapper.xml产生的xxMapper对象 仍然共享二级缓存。\n禁用 ：select标签中添加属性\nuseCache=\u0026quot;false\u0026quot;  清理：\n 与清理一级缓存的方法相同commit();\ncommit(); （一般执行增删改时 会清理掉缓存；设计的原因 是为了防止脏数据）\n在二级缓存中，commit()不能是查询自身的commit。（session.commit;）\ncommit会清理一级和二级缓存；但是 清理二级缓存时，不能是查询自身的commit；\n 在select标签中 增加属性\nflushCache=\u0026quot;true\u0026quot;   三方提供的二级缓存： ehcache、memcache\n要想整合三方提供的二级缓存 （或者自定义二级缓存），必须实现org.apache.ibatis.cache.Cache接口，该接口的默认实现类是PerpetualCache\n整合ehcache二级缓存：\n jar\nehcache-core.jar mybatis-Ehcache.jar slf4j-api.jar  编写ehcache配置文件 Ehcache.xml\n\u0026lt;ehcache xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:noNamespaceSchemaLocation=\u0026quot;../config/ehcache.xsd\u0026quot;\u0026gt; \u0026lt;diskStore path=\u0026quot;D:\\Ehcache\u0026quot;/\u0026gt; \u0026lt;defaultCache maxElementsInMemory=\u0026quot;1000\u0026quot; maxElementsOnDisk=\u0026quot;1000000\u0026quot; eternal=\u0026quot;false\u0026quot; overflowToDisk=\u0026quot;false\u0026quot; timeToIdleSeconds=\u0026quot;100\u0026quot; timeToLiveSeconds=\u0026quot;100\u0026quot; diskExpiryThreadIntervalSeconds=\u0026quot;120\u0026quot; memoryStoreEvictionPolicy=\u0026quot;LRU\u0026quot;\u0026gt; \u0026lt;/defaultCache\u0026gt; \u0026lt;/ehcache\u0026gt;  当二级缓存的对象 超过内存限制时（缓存对象的个数\u0026gt;maxElementsInMemory），存放入的硬盘文件\u0026lt;diskStore path=\u0026quot;D:\\Ehcache\u0026quot;/\u0026gt;\nmaxElementsInMemory:设置 在内存中缓存 对象的个数 maxElementsOnDisk：设置 在硬盘中缓存 对象的个数 eternal：设置缓存是否 永远不过期 overflowToDisk：当内存中缓存的对象个数 超过maxElementsInMemory的时候，是否转移到硬盘中 timeToIdleSeconds：当2次访问 超过该值的时候，将缓存对象失效 timeToLiveSeconds：一个缓存对象 最多存放的时间（生命周期） diskExpiryThreadIntervalSeconds：设置每隔多长时间，通过一个线程来清理硬盘中的缓存 memoryStoreEvictionPolicy：当超过缓存对象的最大值时，处理的策略；LRU，FIFO,LFU  开启EhCache二级缓存\n在xxxMapper.xml中开启\n\u0026lt;cache type=\u0026quot;org.mybatis.caches.ehcache.EhcacheCache\u0026quot;\u0026gt; \u0026lt;!-- 通过property覆盖Ehcache.xml中的值 --\u0026gt; \u0026lt;property name=\u0026quot;maxElementsInMemory\u0026quot; value=\u0026quot;2000\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;maxElementsOnDisk\u0026quot; value=\u0026quot;3000\u0026quot;/\u0026gt; \u0026lt;/cache\u0026gt;   逆向工程 表、类、接口、mapper.xml四者密切相关，因此 当知道一个的时候 其他三个应该可以自动生成。\n表-\u0026gt;其他三个 实现步骤：\n jar\nmybatis-generator-core.jar mybatis.jar ojdbc.jar  逆向工程的配置文件generator.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE generatorConfiguration PUBLIC \u0026quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026quot;\u0026gt; \u0026lt;generatorConfiguration\u0026gt; \u0026lt;context id=\u0026quot;DB2Tables\u0026quot; targetRuntime=\u0026quot;MyBatis3\u0026quot;\u0026gt; \u0026lt;commentGenerator\u0026gt; \u0026lt;!-- suppressAllComments属性值： true:自动生成实体类、SQL映射文件时没有注释 true:自动生成实体类、SQL映射文件，并附有注释 --\u0026gt; \u0026lt;property name=\u0026quot;suppressAllComments\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;/commentGenerator\u0026gt; \u0026lt;!-- 数据库连接信息 --\u0026gt; \u0026lt;jdbcConnection driverClass=\u0026quot;oracle.jdbc.OracleDriver\u0026quot; connectionURL=\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026quot; userId=\u0026quot;scott\u0026quot; password=\u0026quot;tiger\u0026quot;\u0026gt; \u0026lt;/jdbcConnection\u0026gt; \u0026lt;!-- forceBigDecimals属性值： true:把数据表中的DECIMAL和NUMERIC类型， 解析为JAVA代码中的java.math.BigDecimal类型 false(默认):把数据表中的DECIMAL和NUMERIC类型， 解析为解析为JAVA代码中的Integer类型 --\u0026gt; \u0026lt;javaTypeResolver\u0026gt; \u0026lt;property name=\u0026quot;forceBigDecimals\u0026quot; value=\u0026quot;false\u0026quot; /\u0026gt; \u0026lt;/javaTypeResolver\u0026gt; \u0026lt;!-- targetProject属性值:实体类的生成位置 targetPackage属性值：实体类所在包的路径 --\u0026gt; \u0026lt;javaModelGenerator targetPackage=\u0026quot;org.lanqiao.entity\u0026quot; targetProject=\u0026quot;.\\src\u0026quot;\u0026gt; \u0026lt;!-- trimStrings属性值： true：对数据库的查询结果进行trim（去空格）操作 false(默认)：不进行trim操作 --\u0026gt; \u0026lt;property name=\u0026quot;trimStrings\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;/javaModelGenerator\u0026gt; \u0026lt;!-- targetProject属性值:SQL映射文件的生成位置 targetPackage属性值：SQL映射文件所在包的路径 --\u0026gt; \u0026lt;sqlMapGenerator targetPackage=\u0026quot;org.lanqiao.mapper\u0026quot; targetProject=\u0026quot;.\\src\u0026quot;\u0026gt; \u0026lt;/sqlMapGenerator\u0026gt; \u0026lt;!-- 生成动态代理的接口 --\u0026gt; \u0026lt;javaClientGenerator type=\u0026quot;XMLMAPPER\u0026quot; targetPackage=\u0026quot;org.lanqiao.mapper\u0026quot; targetProject=\u0026quot;.\\src\u0026quot;\u0026gt; \u0026lt;/javaClientGenerator\u0026gt; \u0026lt;!-- 指定数据库表 --\u0026gt; \u0026lt;table tableName=\u0026quot;Student\u0026quot;\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;table tableName=\u0026quot;studentCard\u0026quot;\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;table tableName=\u0026quot;studentClass\u0026quot;\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/context\u0026gt; \u0026lt;/generatorConfiguration\u0026gt;  执行\npublic class Test { public static void main(String[] args) throws IOException, XMLParserException, InvalidConfigurationException, SQLException, InterruptedException { File file = new File(\u0026quot;src/generator.xml\u0026quot;) ;//配置文件 List\u0026lt;String\u0026gt; warnings = new ArrayList\u0026lt;\u0026gt;(); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(file); DefaultShellCallback callBack = new DefaultShellCallback(true); //逆向工程的核心类 MyBatisGenerator generator = new MyBatisGenerator(config, callBack,warnings ); generator.generate(null); } }   数据库环境切换 （驱动jar）  切换 environment （指定实际使用的数据库）\n\u0026lt;!--default指定環境 --\u0026gt; \u0026lt;environments default=\u0026quot;devOracle\u0026quot;\u0026gt; \u0026lt;!--oracle --\u0026gt; \u0026lt;environment id=\u0026quot;devOracle\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot; /\u0026gt; \u0026lt;!-- 配置数据库连接信息 --\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;${oracle.driver}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;${oracle.url}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;${oracle.username}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${oracle.password}\u0026quot; /\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;!--mysql --\u0026gt; \u0026lt;environment id=\u0026quot;devMysql\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot; /\u0026gt; \u0026lt;!-- 配置数据库连接信息 --\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;${mysql.driver}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;${mysql.url}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;${mysql.username}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${mysql.password}\u0026quot; /\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt;  db.properties\n#oracle oracle.driver=oracle.jdbc.OracleDriver oracle.url=jdbc:oracle:thin:@127.0.0.1:1521:ORCL oracle.username=scott oracle.password=tiger #mysql mysql.driver=com.mysql.jdbc.Driver mysql.url=jdbc:mysql://localhost:3306/mydb?allowMultiQueries=true mysql.username=root mysql.password=root  配置 Provider别名\n\u0026lt;!-- 配置数据库支持类，value的值是别名--\u0026gt; \u0026lt;databaseIdProvider type=\u0026quot;DB_VENDOR\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;MySQL\u0026quot; value=\u0026quot;mysql\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;Oracle\u0026quot; value=\u0026quot;oracle\u0026quot; /\u0026gt; \u0026lt;/databaseIdProvider\u0026gt;  写不同数据库的SQL语句\n 在mappe.xml中配置databaseId=\u0026ldquo;Provider别名\u0026rdquo;、\n\u0026lt;!--mysql--\u0026gt; \u0026lt;select id=\u0026quot;queryStudentByNo\u0026quot; resultType=\u0026quot;com.yanqun.entity.Student\u0026quot; parameterType=\u0026quot;int\u0026quot; databaseId=\u0026quot;mysql\u0026quot;\u0026gt; select * from student where stuNo=#{stuNo} \u0026lt;/select\u0026gt;  \u0026lt;!-- oracle--\u0026gt; \u0026lt;select id=\u0026quot;queryStudentByNo\u0026quot; parameterType=\u0026quot;student\u0026quot; resultType=\u0026quot;student\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; select * from student where stuNo=#{stuNo} \u0026lt;/select\u0026gt;  id值相同，系统会根据环境的不同选择执行的语句\n  如果mapper.xml的 sql标签 仅有 一个 不带databaseId的标签，则改标签 会自动适应当前数据库。如果既有不带databaseId的标签，又有带databaseId的标签,则程序会优先使用带databaseId的标签\n注解方式 推荐使用xml\n将sql语句写在接口的方法上@Select(\u0026ldquo;\u0026rdquo;) ;xxMapper.java // @Select(\u0026quot;select * from student where stuNo = #{stuNo}\u0026quot;) Student queryStudentByNo (int stuNo);  将接口的全类名 写入，让mybatis知道sql语句此时是存储在接口中conf.xml \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026quot;com.yanqun.mapper.StudentMapper\u0026quot; /\u0026gt; \u0026lt;/mappers\u0026gt;  注解/xml都支持批量引入，\n\u0026lt;mappers\u0026gt; \u0026lt;!--以下可以将com.yanqun.mapper 包中的注解接口 和 xml全部一次性引入 --\u0026gt; \u0026lt;package name=\u0026quot;com.yanqun.mapper\u0026quot; /\u0026gt; \u0026lt;/mappers\u0026gt;  增删改的返回值问题 返回值可以是void、Integer、Long、Boolean 如何操作：只需要在接口中 修改返回值即可,映射文件不需要任何其他的操作\n事务自动提交 手动提交： sessionFactory.openSession(); session.commit();//提交  自动提交：每个dml语句 自动提交 sessionFactory.openSession(true);  自增问题 mysql支持自增 表\ncreate table student ( stuno int(4) primary key auto_increment, stuname varchar(10), stuage int(4), graname varchar(10) );  自增的同时将值回写\n\u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;com.lx.entity.Student\u0026quot; databaseId=\u0026quot;mysql\u0026quot; useGeneratedKeys=\u0026quot;true\u0026quot; keyProperty=\u0026quot;stuNo\u0026quot;\u0026gt; insert into student(stuName,stuAge,graName) values(#{stuName},#{stuAge},#{graName}) \u0026lt;/insert\u0026gt;  只需要配置两个属性即可：\nuseGeneratedKeys=\u0026quot;true\u0026quot; keyProperty=\u0026quot;stuNo\u0026quot;  oracle不支持自增 ：通过序列模拟实现 创建序列\ncreate sequence myseq increment by 1 start with 1;  序列自带的两个属性：\nnextval：序列中下一个值 currval: 当前值  插入值\ninsert into student values(myseq.nextval,'zs1',23,'a1'); insert into student values(myseq.nextval,'zs2',24,'a2'); insert into student values(myseq.nextval,'zs3',25,'a3'); insert into student values(myseq.nextval,'zs4',26,'a4'); insert into student values(myseq.nextval,'zs5',27,'a5');  方式一：before（推荐）\n通过 \u0026lt;insert\u0026gt;的子标签 \u0026lt;selectKey\u0026gt;实现： 在 \u0026lt;selectKey\u0026gt;中查询下一个序列（自增后的值），再将此值传入keyProperty=\u0026ldquo;stuNo\u0026rdquo;属性，最后在真正执行时 使用该属性值。\n\u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;com.yanqun.entity.Student\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; \u0026lt;!--order=\u0026quot;BEFORE\u0026quot;表示先执行selectKey标签，将myseq.nextval的值拿到，放入keyProperty=\u0026quot;stuNo\u0026quot;中--\u0026gt; \u0026lt;selectKey keyProperty=\u0026quot;stuNo\u0026quot; resultType=\u0026quot;Integer\u0026quot; order=\u0026quot;BEFORE\u0026quot;\u0026gt; select myseq.nextval from dual \u0026lt;/selectKey\u0026gt; insert into student(stuno,stuName,stuAge,graName) values(#{stuNo} , #{stuName},#{stuAge},#{graName}) \u0026lt;/insert\u0026gt;  方式二：after\n\u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;com.yanqun.entity.Student\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; \u0026lt;selectKey keyProperty=\u0026quot;stuNo\u0026quot; resultType=\u0026quot;Integer\u0026quot; order=\u0026quot;AFTER\u0026quot;\u0026gt; select myseq.currval from dual \u0026lt;/selectKey\u0026gt; insert into student(stuno,stuName,stuAge,graName) values(myseq.nextval , #{stuName},#{stuAge},#{graName}) \u0026lt;/insert\u0026gt;  先执行sql语句，将数据插入在执行selectKey标签，将值回写，插入时使用的myseq.nextval，因此回写时使用的是myseq.currval\n参数问题 目前 将多个参数封装到一个javabean对象（pojo）,然后使用该对象传递\n传入多个参数时，不用在mapper.xml中编写parameterType（输入参数不用写） 异常提示：\nstuNo不能使用。可以使用的是：\n[arg3, arg2, arg1, arg0, param3, param4, param1, param2]  \u0026lt;insert id=\u0026quot;addStudent\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; insert into student(stuno,stuName,stuAge,graName) values(#{arg0} , #{arg1},#{arg2},#{arg3}) \u0026lt;/insert\u0026gt;  或\nvalues(#{param1},#{param2},#{param3},#{param4})  注意param1从1开始计数arg0从0开始计数\npublic abstract Integer addStudent(Integer stuNo, String stuName, Integer stuAge,String graName);  StudentMapper studentMapper = session.getMapper(StudentMapper.class);//接口 Student stu = new Student(555, \u0026quot;bbb\u0026quot;, 44, \u0026quot;xx\u0026quot;); studentMapper.addStudent( stu);  命名参数 可以在接口中通过@Param(\u0026ldquo;sNo\u0026rdquo;) 指定sql中参数的名字\n\u0026lt;insert id=\u0026quot;addStudent\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; insert into student(stuno,stuName,stuAge,graName) values(#{sNo} , #{sName},#{sAge},#{gName}) \u0026lt;/insert\u0026gt;  public abstract Integer addStudent(@Param(\u0026quot;sNo\u0026quot;) Integer stuNo, @Param(\u0026quot;sName\u0026quot;)String stuName, @Param(\u0026quot;sAge\u0026quot;)Integer stuAge, @Param(\u0026quot;gName\u0026quot;)String graName);  StudentMapper studentMapper = session.getMapper(StudentMapper.class);//接口 Student stu = new Student(555, \u0026quot;aaa\u0026quot;, 44, \u0026quot;xx\u0026quot;); studentMapper.addStudent( stu);  综合使用 \u0026lt;insert id=\u0026quot;addStudent\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; insert into student(stuno,stuName,stuAge,graName) values(#{sNo} , #{stu.stuName},#{stu.stuAge},#{stu.graName}) \u0026lt;/insert\u0026gt;  Integer addStudent(@Param(\u0026quot;sNo\u0026quot;)Integer stuNo, @Param(\u0026quot;stu\u0026quot;)Student student);  StudentMapper studentMapper = session.getMapper(StudentMapper.class);//接口 Student stu = new Student(null, \u0026quot;xx\u0026quot;, 44, \u0026quot;xx\u0026quot;); studentMapper.addStudent(444,stu);  增加null Student stu = new Student(555, null, 44, \u0026quot;xx\u0026quot;); studentMapper.addStudent( stu);  oracle: 如果插入的字段是Null, 提示错误： Other 而不是null\nmysql：如果插入的字段是Null, 可以正常执行（没有约束）\n原因：\n各个数据库 在mybatis中 对各种数据类型的 默认值不一致。\nmybatis中，jdbcTypeForNull（如果是null） ，则默认值OTHER。Other来说，MySQL能够处理（NULL）,但是Oracle不行。\n解决： oracle： null -\u0026gt;OTHER ,需要手工告诉oracle :other -\u0026gt;null\n方法一：修改具体的sql标签\n当某个数据类型oracle无法处理时，告诉它用默认值null；\n注意，此时设置的jdbcType=NULL，不会影响正常的赋值（“zs”）\n\u0026lt;insert id=\u0026quot;addStudent\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; insert into student(stuno,stuName) values(#{stuNo} , #{stuName,jdbcType=NULL}) \u0026lt;/insert\u0026gt;  jdbcType=NULL表示，当且仅当oracle遇到不能处理的值的时候，赋值为null\n方法二：配置 mybatis全局配置文件conf.xml\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026quot;jdbcTypeForNull\u0026quot; value=\u0026quot;NULL\u0026quot;/\u0026gt; \u0026lt;/settings\u0026gt;  null -\u0026gt;jdbcTypeForNull -\u0026gt; NULL\n返回值为HashMap的情况 \u0026lt;select id=\u0026quot;queryStudentOutByHashMap\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;HashMap\u0026quot;\u0026gt; select stuNo \u0026quot;no\u0026quot;,stuName \u0026quot;name\u0026quot;,stuAge \u0026quot;age\u0026quot; from student where stuNo = #{stuNo} \u0026lt;/select\u0026gt;  HashMap\u0026lt;String,Object\u0026gt; queryStudentOutByHashMap(int stuNo);  StudentMapper studentMapper = session.getMapper(StudentMapper.class); HashMap\u0026lt;String, Object\u0026gt; studentMap = studentMapper.queryStudentOutByHashMap(11); //System.out.println( studentMap.get(\u0026quot;no\u0026quot;) +\u0026quot;,\u0026quot; +studentMap.get(\u0026quot;name\u0026quot;) +\u0026quot;,\u0026quot; +studentMap.get(\u0026quot;age\u0026quot;) ); System.out.println(studentMap);  select stuNo \u0026quot;no\u0026quot; ...其中 stuNo是数据库的字段名。 “no”是stuNo的别名，用于 在map中 get值时使用(作为map的key)。 map.get(\u0026quot;no\u0026quot; );\n如果不加别名，则map的key就是字段名\n\u0026lt;select id=\u0026quot;queryStudentOutByHashMap\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;HashMap\u0026quot;\u0026gt; select stuNo,stuName,stuAge from student where stuNo = #{stuNo} \u0026lt;/select\u0026gt;  查询结果为HashMap的集合\n\u0026lt;select id=\u0026quot;queryStudentsByHashMap\u0026quot; resultType=\u0026quot;HashMap\u0026quot;\u0026gt; select stuNo ,stuName ,stuAge from student \u0026lt;/select\u0026gt;  @MapKey(\u0026quot;STUNO\u0026quot;) HashMap\u0026lt;String,Student\u0026gt; queryStudentsByHashMap();  程序根据select的返回值 知道map的value就是 Student ,根据 @MapKey(\u0026quot;stuNo\u0026quot;)知道 Map的key是stuNo\n@MapKey(\u0026quot;STUNO\u0026quot;) //oracle的元数据（字段名、表名 ）都是大写\nStudentMxapper studentMapper = session.getMapper(StudentMapper.class); HashMap\u0026lt;String, Student\u0026gt; studentMap= studentMapper.queryStudentsByHashMap(); System.out.println( studentMap.get(\u0026quot;no\u0026quot;) +\u0026quot;,\u0026quot; +studentMap.get(\u0026quot;name\u0026quot;) +\u0026quot;,\u0026quot; +studentMap.get(\u0026quot;age\u0026quot;) ); session.close();  map:\nkey:STUNO value:Student  ResultMap ： 字段 和 属性名 的对应关系 字段名 \u0026mdash; 属性名 不一致\nsno - stuNo   \u0026lt;!-- 如果字段名 属性名不一致，需要使用resultMap指定对应关系--\u0026gt; \u0026lt;select id=\u0026quot;queryStudentsWithResultMap\u0026quot; parameterType=\u0026quot;int\u0026quot; resultMap =\u0026quot;studentResultMap\u0026quot;\u0026gt; select sno, sname, sage, gname from student where sno = #{sno} \u0026lt;/select\u0026gt;  \u0026lt;resultMap type=\u0026quot;com.yanqun.entity.Student\u0026quot; id=\u0026quot;studentResultMap\u0026quot;\u0026gt; \u0026lt;!--主键 --\u0026gt; \u0026lt;id column=\u0026quot;sno\u0026quot; property=\u0026quot;stuNo\u0026quot;/\u0026gt; \u0026lt;!--普通字段 \u0026lt;result column=\u0026quot;sname\u0026quot; property=\u0026quot;stuName\u0026quot;/\u0026gt; --\u0026gt; \u0026lt;result column=\u0026quot;sage\u0026quot; property=\u0026quot;stuAge\u0026quot;/\u0026gt; \u0026lt;result column=\u0026quot;gname\u0026quot; property=\u0026quot;graName\u0026quot;/\u0026gt; \u0026lt;/resultMap\u0026gt;  鉴别器\n \u0026lt;!-- 如果字段名 属性名不一致，需要使用resultMap指定对应关系--\u0026gt; \u0026lt;select id=\u0026quot;queryStudentsWithResultMap\u0026quot; resultMap =\u0026quot;studentResultMap\u0026quot;\u0026gt; select sno, sname,nickname, sage, gname from student \u0026lt;/select\u0026gt;  \u0026lt;resultMap type=\u0026quot;com.yanqun.entity.Student\u0026quot; id=\u0026quot;studentResultMap\u0026quot;\u0026gt; \u0026lt;!--主键 --\u0026gt; \u0026lt;id column=\u0026quot;sno\u0026quot; property=\u0026quot;stuNo\u0026quot;/\u0026gt; \u0026lt;!--普通字段 \u0026lt;result column=\u0026quot;sname\u0026quot; property=\u0026quot;stuName\u0026quot;/\u0026gt; --\u0026gt; \u0026lt;result column=\u0026quot;sage\u0026quot; property=\u0026quot;stuAge\u0026quot;/\u0026gt; \u0026lt;result column=\u0026quot;gname\u0026quot; property=\u0026quot;graName\u0026quot;/\u0026gt; \u0026lt;!-- 鉴别器 : 对查询结果进行分支处理： 如果是a年级，则真名，如果b年级，显示昵称--\u0026gt; \u0026lt;discriminator javaType=\u0026quot;string\u0026quot; column=\u0026quot;gname\u0026quot;\u0026gt; \u0026lt;case value=\u0026quot;a\u0026quot; resultType=\u0026quot;com.yanqun.entity.Student\u0026quot; \u0026gt; \u0026lt;result column=\u0026quot;sname\u0026quot; property=\u0026quot;stuName\u0026quot;/\u0026gt; \u0026lt;/case\u0026gt; \u0026lt;case value=\u0026quot;b\u0026quot; resultType=\u0026quot;student\u0026quot;\u0026gt; \u0026lt;result column=\u0026quot;nickname\u0026quot; property=\u0026quot;stuName\u0026quot;/\u0026gt; \u0026lt;/case\u0026gt; \u0026lt;/discriminator\u0026gt; \u0026lt;/resultMap\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentsWithResultMap();  StudentMapper studentMapper = session.getMapper(StudentMapper.class);//接口 List\u0026lt;Student\u0026gt; students= studentMapper.queryStudentsWithResultMap();  在resultMap中 还可以使用鉴别器：对相同sql中不同字段值进行判断，从而进行不同的处理。\n别名问题 conf.xml\n\u0026lt;typeAliases\u0026gt; \u0026lt;!-- 给com.yanqun.entity包（包和子包）中的所有类 起了别名： 不带包名的类名，不区分大小写--\u0026gt; \u0026lt;package name=\u0026quot;com.yanqun.entity\u0026quot; \u0026gt;\u0026lt;/package\u0026gt; \u0026lt;/typeAliases\u0026gt;  如果在批量设置别名时，出现了冲突。可以使用@Alias(\u0026ldquo;myStudent\u0026rdquo;)区分。\n@Alias(\u0026quot;myStudent\u0026quot;) public class Student {}  SQL标签 ONGL技术\n\u0026lt;select id=\u0026quot;queryStudentByNoWithONGL\u0026quot; parameterType=\u0026quot;student\u0026quot; resultType=\u0026quot;student\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; \u0026lt;!-- select * from student where 1=1 --\u0026gt; select * from student \u0026lt;trim prefix=\u0026quot;where\u0026quot; suffixOverrides=\u0026quot;and\u0026quot;\u0026gt; \u0026lt;bind name=\u0026quot;_queryName\u0026quot; value=\u0026quot;'%'+stuName+'%'\u0026quot;/\u0026gt; \u0026lt;if test=\u0026quot;stuName != null and stuName !='' \u0026quot;\u0026gt; stuName like #{stuName} and \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;graName != null and graName !='' \u0026quot;\u0026gt; graName like '%${graName}%' and \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;stuAge != null and stuAge !='' \u0026quot;\u0026gt; stuAge = #{stuAge} and \u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; \u0026lt;!-- \u0026lt;trim prefix=\u0026quot;where\u0026quot; prefixOverrides=\u0026quot;and\u0026quot;\u0026gt; \u0026lt;if test=\u0026quot;stuName != null and stuName !='' \u0026quot;\u0026gt; and stuName like '%${stuName}%' \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;graName != null and graName !='' \u0026quot;\u0026gt; and graName like '%${graName}%' \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;stuAge != null and stuAge !='' \u0026quot;\u0026gt; and stuAge = #{stuAge} \u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; --\u0026gt; \u0026lt;!-- \u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;stuName != null and stuName !='' \u0026quot;\u0026gt; and stuName like '%${stuName}%' \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;graName != null and graName !='' \u0026quot;\u0026gt; and graName like '%${graName}%' \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;stuAge != null and stuAge !='' \u0026quot;\u0026gt; and stuAge = #{stuAge} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; --\u0026gt; \u0026lt;/select\u0026gt;  \u0026lt;where\u0026gt;可以处理拼接sql中 【开头】第一个and\n\u0026lt;trim\u0026gt;可以处理拼接sql中 【开头或结尾】第一个and\n开头：\n\u0026lt;trim prefix=\u0026quot;where\u0026quot; prefixOverrides=\u0026quot;and\u0026quot;\u0026gt; 给拼接的SQL加prefix=\u0026quot;where\u0026quot; prefixOverrides=\u0026quot;and\u0026quot;，处理拼接SQL中【开头】第一个and suffixOverrides=\u0026quot;and\u0026quot;，处理拼接SQL中【结尾】最后一个and prefix： 拼接 prefixOverrides：删除  内置参数 _parameter: 代表mybatis的输入参数。 _databaseId: 代表当前数据库的 名字  _parameter\n\u0026lt;if test=\u0026quot;_parameter.stuName != null and _parameter.stuName !='' \u0026quot;\u0026gt; stuName like '%${_parameter.stuName}%' and \u0026lt;/if\u0026gt;  _databaseId\n\u0026lt;if test=\u0026quot;_databaseId == 'oracle'\u0026quot;\u0026gt; select * from student where stuNo = #{_parameter} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;_databaseId == 'mysql'\u0026quot;\u0026gt; select * from student where stuNo != #{_parameter} \u0026lt;/if\u0026gt;  模糊查询三种方法 ${} ：原样输出 #[]:加引号  方法一${} stuName like '%${stuName}%'  方法二：传值时，直接传 #{} stuName like #{stuName} student.setStuName(\u0026quot;%s%\u0026quot;);  方法三：bind参数 \u0026lt;bind name=\u0026quot;_queryName\u0026quot; value=\u0026quot;'%'+stuName+'%'\u0026quot;/\u0026gt; stuName like #{_queryName}  通过bind将传入的stuName进行了处理（增加了%\u0026hellip;%）\n逆向工程的使用 生成逆向工程的文件\n增加 mybatis配置文件 conf.xml\n查询所有学生\n//Example中的Criteria：查询条件 List\u0026lt;Student\u0026gt; students = mapper.selectByExample(null) ;  public class TestGeneratorDemo { public static void main(String[] args) throws IOException { String resource = \u0026quot;conf.xml\u0026quot;; Reader reader = Resources.getResourceAsReader(resource); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession session = sessionFactory.openSession(); StudentMapper mapper = session.getMapper(StudentMapper.class); //Example中的Criteria：查询条件 // List\u0026lt;Student\u0026gt; students = mapper.selectByExample(null) ; //规则：example 默认使用的是 第一个criteria StudentExample example = new StudentExample() ; StudentExample.Criteria criteria = example.createCriteria(); // criteria.andStunoBetween((short) 32, (short) 33);// stuno: 2-3 criteria.andStunameLike(\u0026quot;%l%\u0026quot;); //where (xx=xx and xx =x) or (xx =xxx and xx =xx) ; //where stuname like '%z%' or ( stuno \u0026lt;=31 and granameLike \u0026quot;%j%) ; //criteria:where stuname like '%z%' // or //criteria: stuno \u0026lt;=31 and granameLike \u0026quot;%j% ； StudentExample.Criteria criteria1 = example.createCriteria(); criteria1.andStunoLessThanOrEqualTo((short)31) ; //\u0026lt;= criteria1.andGranameLike(\u0026quot;%j%\u0026quot;) ; example.or(criteria1) ; //query by Criteria , QBC List\u0026lt;Student\u0026gt; students = mapper.selectByExample(example ) ; System.out.println(students ); session.close(); } }  对于like模糊查询，逆向工程需要在传值时 写入%x%\nMyBatis架构和源码解析 MyBatis中步骤\na.获取SqlSessionFactory对象 b.获取SqlSession对象 c.获取XxxMapper对象（代理接口中的方法、mapper.xml中的\u0026lt;select\u0026gt;等标签） d.执行\u0026lt;select\u0026gt;等标签中定义的SQL语句  获取SqlSessionFactory对象 parser解析器\n通过parseConfiguration()在configuration标签 设置了 properties、settings、 environments等属性标签\n将所有的配置信息 放在了Configuration对象中\n解析所有的XxxMapper.xml文件（分析其中的 增删改查标签）\n\u0026lt;select id=\u0026quot;\u0026quot; resultType=\u0026quot; 等属性 是通过 parseStatementNode()解析的\n会将XxxMapper.xml中的\u0026lt;select\u0026gt;等标签解析成 MappedStatement对象即 MappedStatement对象就是 \u0026lt;select\u0026gt;等标签\nMappedStatement -\u0026gt;存在于Configuration中\nenvironment -\u0026gt;存在于Configuration中\n所有的配置信息、增删改标签 全部存在于Configuration中\nConfiguration又存在于DefaultSqlSessionFactory对象中（SqlSessionFactory）\nSqlSessionFactory对象 -\u0026gt;DefaultSqlSessionFactory -\u0026gt;Configuration -\u0026gt;包含了一切配置信息\n获取SqlSession对象 configuration.newExecutor(tx, execType) -\u0026gt;SimpleExecutor(默认)  根据不同的类型execType，产生不同的Executor,并且会对执行器进行拦截操作：\nexecutor = (Executor) interceptorChain.pluginAll(executor);  通过装饰模式，将刚才产生的executor 包装成一个更加强大的 executor。\n作用：以后 如果我们要给MyBatis写自己的插件， 就可以通过拦截器实现。\n插件开发：\n1. 写插件\n2. 放入拦截器\n返回DefaultSqlSession(configuration,executor,事务)\nSqlSession -》openSession()-\u0026gt;openSessionFromDataSource()-\u0026gt;DefaultSqlSession对象  SqlSession -》 DefaultSqlSession对象 -》执行SQL\n获取XxxMapper对象、执行 执行增删改查-\u0026gt;MapperProxy/invoke()\u0026ndash;\u0026gt;InvocationHandler ：JDK动态代理接口\n用到了 动态代理模式：增删改查 -\u0026gt; 代理对象 （MapperProxy对象） -\u0026gt;代理对象 帮我们“代理执行” 增删改查 -\u0026gt;\nXxxMapper代理对象： MapperProxy对象  mapperMethod.execute(sqlSession,args) ：实际调用增删改查的方法 ，依靠了sqlSession中的configuration和 executor..\n处理增删改查方法的参数：method.convertArgsToSqlCommandParam(args);： 如果參數是0个，reutrun null ;如果参数是1，返回第一个 ； 如果有多个参数 放入map中\n查询方法：selectOne() -\u0026gt;selectList() : configuration.getMappedStatement() 即获取到用于增删改查的对象\nboundSql ：将我们写的SQL 和 参数值进行了拼接后的对象，即最终能被真正执行的SQL\n执行SQL 是通过Executor\n如果缓存中没有要查询的内容，则进入数据库 真实查询：queryFromDatabase()\nmybatis使用的jdbc对象是PreparedStatement\n底层执行增删改查：PreparedStatement的execute()\nMyBatis底层在执行CRUD时 可能会涉及到四个处理器：StatementHandler（处理对象PreparedStatement的控制器） 、 ParameterHandler（处理参数的控制器） 、 TypeHandler（类型转换的控制器） 、 ResultSetHandler（处理结果集的控制器）\nXxxMapper包含:\nSqlSession(configuration,executor,事务)、代理接口的对象(MapperInterface)、methodCache(存放查询缓存， 底层是CurrentHashMap)\n自定义插件 四个处理：StatementHandler ParameterHandler ResultSetHandler TypeHandler\n四大核心对象：StatementHandler ParameterHandler ResultSetHandler Executor\n四大核心对象\n 都涉及到了 拦截器 用于增强 四大核心对象都包含了 该增强操作  自定义插件的编写逻辑： 根据MyBatis规则 编写一个 拦截器 ，在拦截器内部加入 自定义增强功能\n步骤：\n编写拦截器 public class MyInterceptor implements Interceptor { //拦截 @Override public Object intercept(Invocation invocation) throws Throwable { System.out.println(\u0026quot;拦截方法...intercept...\u0026quot;); Object proceed = invocation.proceed();//放行 return proceed; } @Override public Object plugin(Object target) {//将拦截器中定义的 增强功能 和原来的核心对象 合并起来，称为最终的 核心对象 Object wrap = Plugin.wrap(target, this); System.out.println(\u0026quot;plugin....\u0026quot;+wrap); return wrap; } @Override public void setProperties(Properties properties) { System.out.println(\u0026quot;setProperties....\u0026quot;); } }  编写签名注解 @Intercepts({ @Signature(type = StatementHandler.class , method =\u0026quot;query\u0026quot;,args = {Statement.class, ResultHandler.class}) public class MyInterceptor implements Interceptor {  配置 \u0026lt;plugins\u0026gt; \u0026lt;plugin interceptor=\u0026quot;com.yanqun.my.interceptors.MyInterceptor\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;name\u0026quot; value=\u0026quot;zs\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;age\u0026quot; value=\u0026quot;23\u0026quot;/\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt;  编写多个拦截器时，执行顺序 和 \u0026lt;plugins\u0026gt;配置顺序一致\n插件\nselect * from student -\u0026gt;拦截器 增加where条件  编写拦截器\n//query(Statement statement, ResultHandler resultHandler) @Intercepts({ @Signature(type = StatementHandler.class , method =\u0026quot;parameterize\u0026quot;,args = {Statement.class}) }) public class MyInterceptor implements Interceptor { //拦截 @Override public Object intercept(Invocation invocation) throws Throwable { System.out.println(\u0026quot;拦截方法...intercept...\u0026quot;); Object target = invocation.getTarget();//目标方法 ： select * from student where stuNo = #{stuNo} System.out.println(\u0026quot;目标对象\u0026quot; +target); MetaObject metaObject = SystemMetaObject.forObject(target); // metaObject.getValue(\u0026quot;参数..\u0026quot;) ; Object value = metaObject.getValue(\u0026quot;parameterHandler.parameterObject\u0026quot;); System.out.println(value+\u0026quot;---------\u0026quot;); metaObject.setValue(\u0026quot;parameterHandler.parameterObject\u0026quot;,2);//11-\u0026gt;1 Object value2 = metaObject.getValue(\u0026quot;parameterHandler.parameterObject\u0026quot;); System.out.println(value2+\u0026quot;---------\u0026quot;); Object proceed = invocation.proceed();//放行 System.out.println(proceed); return proceed; } @Override public Object plugin(Object target) {//将拦截器中定义的 增强功能 和原来的核心对象 合并起来，称为最终的 核心对象 Object wrap = Plugin.wrap(target, this); System.out.println(\u0026quot;plugin....\u0026quot;+wrap); return wrap; } @Override public void setProperties(Properties properties) { // System.out.println(\u0026quot;setProperties....\u0026quot;); System.out.println(\u0026quot;设置属性:\u0026quot;+properties); //设置属性... } }  目标对象target的包装后的产物 -\u0026gt; metaObject.getValue(\u0026ldquo;可以从target中获取\u0026rdquo;)\n通过打印语句 可知，target就是 RoutingStatementHandler \u0026ndash;\u0026gt; metaObject.getValue(\u0026ldquo;可以从RoutingStatementHandler中获取\u0026rdquo;)\n-\u0026gt;metaObject.getValue(\u0026ldquo;可以从RoutingStatementHandler中获取 :boundSql/parameterHandler\u0026rdquo;)\n-\u0026gt;-\u0026gt;metaObject.getValue(\u0026ldquo;parameterHandler\u0026rdquo;)\nmetaObject.getValue(\u0026quot;parameterHandler.parameterObject\u0026quot;) //XxxMapper.xml中的sql语句中的参数值 metaObject.getValue(\u0026quot;parameterHandler.boundSql\u0026quot;) //XxxMapper.xml中的sql语句  \u0026ndash;\u0026gt;只研究\nmetaObject.setValue(\u0026quot;parameterHandler.parameterObject\u0026quot;,2)//修改参数值 metaObject.setValue(\u0026quot;parameterHandler.boundSql.sql\u0026quot;,\u0026quot;select * from book...\u0026quot;) //修改sql语句 metaObject.setValue(\u0026quot;parameterHandler.boundSql.parameterObject\u0026quot;,2)  批量操作DML sessionFactory.openSession(ExecutorType.BATCH ); --推荐的写法  \u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;com.yanqun.entity.Student\u0026quot; databaseId=\u0026quot;mysql\u0026quot;\u0026gt; insert into student(stuNo,stuName,stuAge,graName) values(#{stuNo} , #{stuName},#{stuAge},#{graName}) \u0026lt;/insert\u0026gt;   public abstract Integer addStudent(Student student);  SqlSession session = sessionFactory.openSession( ); StudentMapper studentMapper = session.getMapper(StudentMapper.class);//接口 long start = System.currentTimeMillis(); for(int i=0;i\u0026lt;100000;i++) { Student stu = new Student((int)(Math.random()*9000) +1000, \u0026quot;abc\u0026quot;, 44, \u0026quot;xx\u0026quot;); studentMapper.addStudent(stu); } long end = System.currentTimeMillis(); System.out.println(end-start);  此时插入数据较慢\n想变快则使用BATCH sessionFactory.openSession(ExecutorType.BATCH ); \u0026ndash;推荐的写法\nSqlSession session = sessionFactory.openSession( ExecutorType.BATCH); StudentMapper studentMapper = session.getMapper(StudentMapper.class);//接口 long start = System.currentTimeMillis(); for(int i=0;i\u0026lt;100000;i++) { Student stu = new Student((int)(Math.random()*9000) +1000, \u0026quot;abc\u0026quot;, 44, \u0026quot;xx\u0026quot;); studentMapper.addStudent(stu); } long end = System.currentTimeMillis(); System.out.println(end-start);  使用BATCH: 预编译SQL一次 ，其余DML 只需要设置参数值即可\ninsert into student(stuNo,stuName,stuAge,graName) values(#{stuNo} , #{stuName},#{stuAge},#{graName})  不使用BATCH： 预编译N次 ，每次DML都需要 执行完整的SQL\n不推荐的方式： 拼接SQL\noracle:批量插入 a. create table 表 select ... from 旧表 b. insert into 表(...) select .. from 表 ; c. begin ..(DML).. end ; d. 数据泵、SQL Loader 、外部表  以 c. begin ..(DML).. end ;为例\nbegin insert into student(stuno,stuname) values(1,\u0026quot;zs\u0026quot;); insert into student(stuno,stuname) values(1,\u0026quot;ls\u0026quot;); end ;  \u0026lt;insert id=\u0026quot;addStudentOracle\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; \u0026lt;foreach collection=\u0026quot;list\u0026quot; open=\u0026quot;begin\u0026quot; close=\u0026quot;end ;\u0026quot; item=\u0026quot;student\u0026quot;\u0026gt; insert into student(stuno,stuname) values(#{student.stuNo},#{student.stuName}) ; \u0026lt;/foreach\u0026gt; \u0026lt;/insert\u0026gt;  void addStudentOracle (List\u0026lt;Student\u0026gt; students) ;  StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); students.add( new Student(10,\u0026quot;zs\u0026quot;) ); students.add( new Student(20,\u0026quot;ls\u0026quot;) ); studentMapper.addStudentOracle(students);  \u0026ndash;核心：将SQL拼接成oracle能够执行的SQL；\ncollection的参数必须是 collection或List\nmysql:批量插入 insert into student(stuno,stuname) values(100,'zsx'),(200,'lsx'),(200,'lsx'),(200,'lsx')...... ;  \u0026lt;insert id=\u0026quot;addStudentMySql\u0026quot; databaseId=\u0026quot;mysql\u0026quot;\u0026gt; insert into student(stuno,stuname) values \u0026lt;foreach collection=\u0026quot;list\u0026quot; item=\u0026quot;student\u0026quot; separator=\u0026quot;,\u0026quot; close=\u0026quot;;\u0026quot; \u0026gt; (#{student.stuNo},#{student.stuName}) \u0026lt;/foreach\u0026gt; \u0026lt;/insert\u0026gt;  void addStudentMySql (List\u0026lt;Student\u0026gt; students) ;  StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); students.add( new Student(510,\u0026quot;311zs\u0026quot;) ); students.add( new Student(610,\u0026quot;311ls\u0026quot;) ); studentMapper.addStudentMySql(students);  这种批量插入方式不推荐：\n 没有用到mybatis对批量插入的支持\n 不适合数据库迁移\n 如果大量数据，则会将 拼接的SQL语句拉的很长，而部分数据库 对SQL语句的长度有限制。  推荐：调存储过程、存储函数\nmysql.url=jdbc:mysql://localhost:3306/mydb?allowMultiQueries=true  myssql默认不支持接收多个分号（多条语句），这个可以修改默认设置\n分页插件 PageHelper\nPageHelper的git地址\n jar 配置conf.xml中 PageHelper.startPage(2, 3);  配置conf.xml \u0026lt;plugin interceptor=\u0026quot;com.github.pagehelper.PageInterceptor\u0026quot;\u0026gt; \u0026lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 \u0026lt;property name=\u0026quot;reasonable\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;--\u0026gt; \u0026lt;/plugin\u0026gt;  \u0026lt;select id=\u0026quot;queryStudents\u0026quot; resultType=\u0026quot;com.yanqun.entity.Student\u0026quot; \u0026gt; select * from student order by stuno \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudents () ;  public static void queryStudents() throws IOException { String resource = \u0026quot;conf.xml\u0026quot;; Reader reader = Resources.getResourceAsReader(resource); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession session = sessionFactory.openSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); /* 方式一 加入分页功能 Page\u0026lt;Object\u0026gt; page = PageHelper.startPage(2, 3); */ //pageInfo方式 PageHelper.startPage(2, 3); /* lambda形式 Page\u0026lt;Student\u0026gt; page = PageHelper.startPage(2, 3).doSelectPage(()-\u0026gt; studentMapper.queryStudents()); List\u0026lt;Student\u0026gt; list = page.getResult(); */ // select * from student order by stuno -\u0026gt;拦截器 //select * from student order by stuno limit 6,3 List\u0026lt;Student\u0026gt; list = studentMapper.queryStudents() ; for(Student student :list){ System.out.println(student); } //PageInfo方式 PageInfo\u0026lt;Student\u0026gt; pageInfo = new PageInfo\u0026lt;\u0026gt;(list); System.out.println(\u0026quot;当前页：\u0026quot;+pageInfo.getPageNum()); System.out.println(\u0026quot;总数据量：\u0026quot;+pageInfo.getTotal()); System.out.println(\u0026quot;总页码：\u0026quot; +pageInfo.getPages()); System.out.println(\u0026quot;页面大小：\u0026quot; +pageInfo.getPageSize()); System.out.println(\u0026quot;最开头那一页：\u0026quot;+ pageInfo.getNavigateFirstPage()); System.out.println(\u0026quot;每一页的页号\u0026quot;); for( int pageNum : pageInfo.getNavigatepageNums()){ System.out.println(pageNum); } session.close(); }  ","id":24,"section":"posts","summary":"Mybatis 简介 官网 mybatis: ibatis:apache 2010 ibatis-\u0026gt; google colde ,Mybatis MyBatis可以简化JDBC操作，实现数据的持久化 。 ORM:Object Relational Mapping person对象 person表 之间一一映射起来 ORM：概","tags":["Spring家族"],"title":"Mybatis自学笔记","uri":"https://mumulx.github.io/2019/11/mybatis%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" git源码\n简介 Servlet发展史\nStruts1.x\u0026ndash;\u0026gt;Struts2.x\u0026ndash;\u0026gt;SpringMVC\nspringmvc:\njar spring-aop.jar spring-bean.jar spring-context.jar spring-core.jar spring-web.jar spring-webmvc.jar commons-logging.jar  报错NoClassDefFoundError：缺少jar\n第一个SpringMVC程序 Servet - Springmvc jsp -\u0026gt;Servlet (Springmvc)-\u0026gt;Jsp  url\nspringmvc配置文件 springmvc.xml 选中常用的命名空间：beans aop context mvc\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns:aop=\u0026quot;http://www.springframework.org/schema/aop\u0026quot; xmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot; xmlns:mvc=\u0026quot;http://www.springframework.org/schema/mvc\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\u0026quot;\u0026gt; \u0026lt;!-- 扫描 有注解的包 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;org.lanqiao.handler\u0026quot;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;!--配置视图解析器(InternalResourceViewResolver) 配置的prefix和suffix会给所有返回的地址加上前缀/views/加上后缀.jsp。 例return \u0026quot;success\u0026quot; 实际的结果为/views/success.jsp --\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;prefix\u0026quot; value=\u0026quot;/views/\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;suffix\u0026quot; value=\u0026quot;.jsp\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;  普通的servlet流程：\n请求-url-pattern -交给对应的servlet去处理\n如果现在想用springmvc，而不是普通的servlet，如何告知程序？-如何让springmvc 介入程序：\n需要配置一个 Springmvc自带的servlet\n通过以下配置，拦截所有请求，交给SpringMVC处理：web.xml\n\u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springDispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springDispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;  其中：\n\u0026lt;url-pattern\u0026gt;.action\u0026lt;/url-pattern\u0026gt; / :一切请求 ，注意不是 /* /user :拦截以 /user开头的请求 /user/abc.do :只拦截该请求 .action :只拦截 .action结尾的请求  通过\n\u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt;  指定springmvc配置文件的路径，如果要省略，必须放到 默认路径：\n/WEB-INF/springDispatcherServlet-servlet.xml  严格的来说是\n\u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springDispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springDispatcherServlet\u0026lt;/servlet-name\u0026gt; /WEB-INF/servetname的值-servlet.xml  请求\n\u0026lt;a href=\u0026quot;welcome\u0026quot;\u0026gt;first springmvc - welcome\u0026lt;/a\u0026gt;  servlet\n@RequestMapping(value=\u0026quot;welcome\u0026quot;,method=RequestMethod.POST,params= {\u0026quot;name=zs\u0026quot;,\u0026quot;age!=23\u0026quot;,\u0026quot;!height\u0026quot;})//映射 public String welcome() { return \u0026quot;success\u0026quot; ;// views/success.jsp }  项目中同时兼容 springMVC和Servlet\n\u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springDispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;.action\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;  @RequestMapping 映射是 去匹配@RequestMapping注解，可以和方法名、类名不一致，\n//接口/类 注解 配置 @Controller @RequestMapping(value=\u0026quot;handler\u0026quot;) //映射 public class SpringMVCHandler { @RequestMapping(value=\u0026quot;welcome\u0026quot;)//映射 public String welcome() { return \u0026quot;success\u0026quot; ; } }  默认值的属性为value\n@RequestMapping(value=\u0026quot;welcome\u0026quot;) @RequestMapping(\u0026quot;welcome\u0026quot;)  二者相等\n此时请求的路径为\nhandler/welcome  先去找类前面的，再去找方法前面的，默认使用了 请求转发的 跳转方式，地址栏的地址没有改变\nmethod 通过method指定 请求方式（get post delete put）\n@RequestMapping(value=\u0026quot;welcome\u0026quot;,method=RequestMethod.POST)//映射  params 参数值\nparams= {\u0026quot;name\u0026quot;}  请求参数值中一定要有name属性\nparams= {\u0026quot;name=zs\u0026quot;}  请求参数值中一定要有name属性，并且参数值一定是zs params= {\u0026ldquo;name=zs\u0026rdquo;,\u0026ldquo;age!=23\u0026rdquo;})\n name:必须有name=\u0026ldquo;zs\u0026rdquo;参数\n age!=23 :\n 如果有name=\u0026ldquo;age\u0026rdquo;，则age值不能是23 要么没有age\nparams= {\u0026quot;name=zs\u0026quot;,\u0026quot;age!=23\u0026quot;,\u0026quot;!height\u0026quot;})  请求参数中不能有height\nheaders 请求头\nheaders= {\u0026quot;Accept=text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\u0026quot;,\u0026quot;Accept-Encoding=gzip, deflate\u0026quot;}  多个参数使用,隔开\n   ant风格的请求路径 ? 单字符 * 任意个字符（0或多个） ** 任意目录  @RequestMapping(value=\u0026quot;welcome3/a?c/test\u0026quot;)  接受示例： a href=\u0026ldquo;welcome3/axc/test\u0026rdquo; a href=\u0026ldquo;welcome3/ayc/test\u0026rdquo;\n@RequestMapping(value=\u0026quot;welcome3/*/test\u0026quot;)  接受示例：\na href=\u0026quot;welcome3/abc/test\u0026quot; a href=\u0026quot;welcome3/xxx/test\u0026quot;  @RequestMapping(value=\u0026quot;welcome3/**/test\u0026quot;)  接受示例：\na href=\u0026quot;welcome3/abc/xyz/abccc/test\u0026quot; a href=\u0026quot;welcome3/xxx/xxx/xxx/test\u0026quot;  @PathVariable 通过@PathVariable获取动态参数\n传参\n\u0026lt;a href=\u0026quot;hander/welcome5/zs\u0026quot;\u0026gt;  zs为传递的值\n@RequestMapping(value=\u0026quot;welcome5/{name}\u0026quot;) public String welcome5(@PathVariable(\u0026quot;name\u0026quot;) String name ) { System.out.println(name); return \u0026quot;success\u0026quot; ; }  name的值为zs\nREST风格 ：软件编程风格 conf.xml快速生成配置文件\nctrl+/ 选择#dispatcherservlet  然后修改拦截请求，和配置文件的位置\nSpringmvc:\nGET :查 POST :增 DELETE :删 PUT :改  普通浏览器 只支持get post方式 ；其他请求方式 如 delelte|put请求是通过过滤器（HiddenHttpMethodFilter）新加入的支持。\n过滤器拦截delelte|put请求的条件\n 请求方式为post\n 标签有隐藏域，并且隐藏域的name为_method,value为delete或put\n\u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;_method\u0026quot; value=\u0026quot;delete|put\u0026quot;\u0026gt;   springmvc实现 ：put|post请求方式的步骤 增加过滤器,web.xml\n\u0026lt;!-- 增加HiddenHttpMethodFilte过滤器：目的是给普通浏览器 增加 put|delete请求方式 --\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;HiddenHttpMethodFilte\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.HiddenHttpMethodFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;HiddenHttpMethodFilte\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;  delete 表单\n\u0026lt;form action=\u0026quot;handler/testRest/1234\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;_method\u0026quot; value=\u0026quot;DELETE\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;删\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  控制器\n @RequestMapping(value=\u0026quot;testRest/{id}\u0026quot;,method=RequestMethod.DELETE) public String testDelete(@PathVariable(\u0026quot;id\u0026quot;) Integer id) { System.out.println(\u0026quot;delete：删 \u0026quot; +id); return \u0026quot;success\u0026quot; ; }  put 表单\n\u0026lt;form action=\u0026quot;handler/testRest/1234\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;_method\u0026quot; value=\u0026quot;PUT\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;改\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  控制器\n@RequestMapping(value=\u0026quot;testRest/{id}\u0026quot;,method=RequestMethod.PUT) public String testPut(@PathVariable(\u0026quot;id\u0026quot;) Integer id) { System.out.println(\u0026quot;put：改 \u0026quot;+id); return \u0026quot;success\u0026quot; ; }  get 表单\n\u0026lt;form action=\u0026quot;handler/testRest/1234\u0026quot; method=\u0026quot;get\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;查\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  控制器\n@RequestMapping(value=\u0026quot;testRest/{id}\u0026quot;,method=RequestMethod.GET) public String testGet(@PathVariable(\u0026quot;id\u0026quot;) Integer id) { System.out.println(\u0026quot;get：查 \u0026quot; +id); return \u0026quot;success\u0026quot; ; }  post 表单\n\u0026lt;form action=\u0026quot;handler/testRest/1234\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;增\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  控制器\n@RequestMapping(value=\u0026quot;testRest/{id}\u0026quot;,method=RequestMethod.POST) public String testPost(@PathVariable(\u0026quot;id\u0026quot;) Integer id) { System.out.println(\u0026quot;post：增 \u0026quot; +id); return \u0026quot;success\u0026quot; ; }  通过method=RequestMethod.DELETE匹配具体的请求方式\n此外，可以发现 ，当映射名相同时即@RequestMapping(value=\u0026quot;testRest)相同，可以通过method处理不同的请求。\n处理delete|put的源码分析 过滤器中 处理put|delete请求的部分源码：\nprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)throws ServletException, IOException { HttpServletRequest requestToUse = request; if (\u0026quot;POST\u0026quot;.equals(request.getMethod()) \u0026amp;\u0026amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) { String paramValue = request.getParameter(this.methodParam); if (StringUtils.hasLength(paramValue)) { requestToUse = new HttpMethodRequestWrapper(request, paramValue); } } filterChain.doFilter(requestToUse, response); }  原始请求：request，改请求默认只支持get\\ post \\ header]\n但是如果 是\u0026rdquo;POST\u0026rdquo; 并且有隐藏域\n\u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;_method\u0026quot; value=\u0026quot;DELETE\u0026quot;/\u0026gt;  则，过滤器 将原始的请求 request加入新的请求方式DELETE，并将原始请求 转为 requestToUse 请求（request+Delete请求）\n最后将requestToUse 放入 请求链中， 后续再事情request时 实际就使用改造后的 requestToUse\n普通传值 表单\n\u0026lt;form action=\u0026quot;handler/testParam\u0026quot; method=\u0026quot;get\u0026quot;\u0026gt; name:\u0026lt;input name=\u0026quot;uname\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;查\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  控制器\n@RequestMapping(value=\u0026quot;testParam\u0026quot;) public String testParam(@RequestParam(\u0026quot;uname\u0026quot;) String name) { String name = request.getParameter(\u0026quot;uname\u0026quot;); System.out.println(name); return \u0026quot;success\u0026quot; ; }  前台传多个参数值，后台可以接收其中几个值，但是不可以接收多的值，即后台接收的的值，前台一定要发送；前台发送的值，后台可以不接收\n@RequestParam(\u0026quot;uname\u0026quot;) String name,@RequestParam(value=\u0026quot;uage\u0026quot;,required=false,defaultValue=\u0026quot;23\u0026quot;)  设置默认值，不传的时候为23\n@RequestParam(\u0026quot;uname\u0026quot;)  接受前台传递的值，等价于\nrequest.getParameter(\u0026quot;uname\u0026quot;);  required=false:该属性 不是必须的。 defaultValue=\u0026quot;23\u0026quot;：默认值23  获取请求头信息 @RequestHeader \u0026lt;a href=\u0026quot;handler/testRequestHeader\u0026quot;\u0026gt;testRequestHeader\u0026lt;/a\u0026gt;  public String testRequestHeader(@RequestHeader(\u0026quot;Accept-Language\u0026quot;) String al ) {  通过@RequestHeader(\u0026quot;Accept-Language\u0026quot;) String al 获取请求头中的Accept-Language值，并将值保存再al变量中\n通过mvc获取cookie值（JSESSIONID） @CookieValue (前置知识： 服务端在接受客户端第一次请求时，会给该客户端分配一个session （该session包含一个sessionId）),并且服务端会在第一次响应客户端时 ，将该sessionId赋值给JSESSIONID 并传递给客户端的cookie中\n\u0026lt;a href=\u0026quot;handler/testCookieValue\u0026quot;\u0026gt;testCookieValue\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt;  @RequestMapping(value=\u0026quot;testRequestHeader\u0026quot;) public String testRequestHeader(@RequestHeader(\u0026quot;Accept-Language\u0026quot;) String al ) { System.out.println( al); return \u0026quot;success\u0026quot; ; }  小结：\nSpringMVC处理各种参数的流程/逻辑：\n请求： 前端发请求a-\u0026gt; @RequestMappting(\u0026ldquo;a\u0026rdquo;)\n处理请求中的参数xyz：\n@RequestMappting(\u0026quot;a\u0026quot;) public String aa(@Xxx注解(\u0026quot;xyz\u0026quot;) xyz) { }  使用对象（实体类Student）接受请求参数 public class Student { private int id; private String name; private Address address ; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } }  public class Address { private String homeAddress ; private String schoolAddress ; public String getHomeAddress() { return homeAddress; } public void setHomeAddress(String homeAddress) { this.homeAddress = homeAddress; } public String getSchoolAddress() { return schoolAddress; } public void setSchoolAddress(String schoolAddress) { this.schoolAddress = schoolAddress; } }  \u0026lt;form action=\u0026quot;handler/testObjectProperties\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; id:\u0026lt;input name=\u0026quot;id\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; name:\u0026lt;input name=\u0026quot;name\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; 家庭地址:\u0026lt;input name=\u0026quot;address.homeAddress\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; 学校地址:\u0026lt;input name=\u0026quot;address.schoolAddress\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;查\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  @RequestMapping(value=\u0026quot;testObjectProperties\u0026quot;) public String testObjectProperties(Student student) {//student属性 必须 和 form表单中的属性Name值一致（支持级联属性） /* 以前的方式 String name = request.getParameter(\u0026quot;name\u0026quot;); int age= Integer.parseInt(request.getParameter(\u0026quot;age\u0026quot;)s)\t; String haddrss = request.getParameter(\u0026quot;homeaddress\u0026quot;); String saddress = request.getParameter(\u0026quot;schooladdress\u0026quot;); Address address = new Address(); address.setHomeAddress(haddrss); address.setSchoolAddress(saddress); Student student = new Student(); student.setName(name); student.setAddress(address); */\tSystem.out.println(student.getId()+\u0026quot;,\u0026quot;+student.getName()+\u0026quot;,\u0026quot;+student.getAddress().getHomeAddress()+\u0026quot;,\u0026quot;+student.getAddress().getSchoolAddress()); return \u0026quot;success\u0026quot; ; }  在SpringMVC中使用原生态的Servlet API HttpServletRequest ,HttpServletResponse\n\u0026lt;a href=\u0026quot;handler/testServletAPI\u0026quot;\u0026gt;testServletAPI\u0026lt;/a\u0026gt;  @RequestMapping(value=\u0026quot;testServletAPI\u0026quot;) public String testServletAPI(HttpServletRequest request,HttpServletResponse response) { //\trequest.getParameter(\u0026quot;uname\u0026quot;) ; System.out.println(request); return \u0026quot;success\u0026quot; ; }  直接将 servlet-api中的类、接口等 写在springMVC所映射的方法参数中即可：\n处理模型数据 如果跳转时需要带数据：V、M,则可以使用以下方式：\nModelAndView、ModelMap 、Map、Model -数据放在了request作用域 @SessionAttributes、@ModelAttribute  ModelAndView \u0026lt;a href=\u0026quot;handler/testModelAndView\u0026quot;\u0026gt;testModelAndView\u0026lt;/a\u0026gt;  @RequestMapping(value=\u0026quot;testModelAndView\u0026quot;) public ModelAndView testModelAndView() { //ModelAndView:既有数据，又有视图 //ModelAndView:Model -M View-V ModelAndView mv = new ModelAndView(\u0026quot;success\u0026quot;);//view: views/success.jsp,仍然会加前缀和后缀 Student student = new Student() ; student.setId(2); student.setName(\u0026quot;zs\u0026quot;); mv.addObject(\u0026quot;student\u0026quot;, student);//相当于request.setAttribute(\u0026quot;student\u0026quot;, student); return mv; }  取值\n${requestScope.student.id } -${requestScope.student.name } \u0026lt;br/\u0026gt;  ModelMap \u0026lt;a href=\u0026quot;handler/testModelMap\u0026quot;\u0026gt;testModelMap\u0026lt;/a\u0026gt;  @RequestMapping(value=\u0026quot;testModelMap\u0026quot;) public String testModelMap(ModelMap mm) { Student student = new Student() ; student.setId(2); student.setName(\u0026quot;zs\u0026quot;); mm.put(\u0026quot;student2\u0026quot;, student);//request域 return \u0026quot;success\u0026quot;; //view }  ${requestScope.student2.id } -${requestScope.student2.name } \u0026lt;br/\u0026gt;  Map \u0026lt;a href=\u0026quot;handler/testMap\u0026quot;\u0026gt;testMap\u0026lt;/a\u0026gt;  @RequestMapping(value=\u0026quot;testMap\u0026quot;) public String testMap(Map\u0026lt;String,Object\u0026gt; m) { Student student = new Student() ; student.setId(2); student.setName(\u0026quot;zs\u0026quot;); m.put(\u0026quot;student3\u0026quot;, student);//request域 return \u0026quot;success\u0026quot;; }  ${requestScope.student3.id } -${requestScope.student3.name }  Model \u0026lt;a href=\u0026quot;handler/testModel\u0026quot;\u0026gt;testModel  @RequestMapping(value=\u0026quot;testModel\u0026quot;) public String testModel(Model model) { Student student = new Student() ; student.setId(2); student.setName(\u0026quot;zs\u0026quot;); model.addAttribute(\u0026quot;student4\u0026quot;,student);//request域 return \u0026quot;success\u0026quot;; }  ${requestScope.student4.id } -${requestScope.student4.name }  会将x对象 放入request域中\n如何将上述数据放入session中 加上注解\n@SessionAttributes(..)  在Handlee类前加注解\n@SessionAttributes(value=\u0026quot;student4\u0026quot;)  如果要在request中存放student4对象，则同时将该对象 放入session域中\n@SessionAttributes(types= {Student.class,Address.class})  如果要在request中存放Student类型的对象，则同时将该类型对象放入session域中\n@ModelAttribute  经常在 更新时使用 在不改变原有代码的基础之上，插入一个新方法。\n\u0026lt;form action=\u0026quot;handler/testModelAttribute\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 编号:\u0026lt;input name=\u0026quot;id\u0026quot; type=\u0026quot;hidden\u0026quot; value=\u0026quot;31\u0026quot; /\u0026gt; 姓名:\u0026lt;input name=\u0026quot;name\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;修改\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  @ModelAttribute//在任何一次请求前，都会先执行@ModelAttribute修饰的方法 //@ModelAttribute 在请求 该类的各个方法前 均被执行的设计是基于一个思想：一个控制器 只做一个功能 public void queryStudentById(Map\u0026lt;String,Object\u0026gt; map) { //StuentService stuService = new StudentServiceImpl(); //Student student = stuService.queryStudentById(31); //模拟调用三层查询数据库的操作 Student student = new Student(); student.setId(31); student.setName(\u0026quot;zs\u0026quot;); student.setAge(23); //map.put(\u0026quot;student\u0026quot;, student) ;//约定：map的key 就是方法参数 类型的首字母小写 map.put(\u0026quot;stu\u0026quot;, student) ;//约定：map的key 就是方法参数 类型的首字母小写 }  //修改:Zs-ls @RequestMapping(value=\u0026quot;testModelAttribute\u0026quot;) public String testModelAttribute(@ModelAttribute(\u0026quot;stu\u0026quot;)Student student) { student.setName(student.getName());//将名字修改为ls System.out.println(student.getId()+\u0026quot;,\u0026quot;+student.getName()+\u0026quot;,\u0026quot;+student.getAge()); return \u0026quot;success\u0026quot;; }   通过@ModelAttribute修饰的方法 ，会在每次请求前先执行； 并且该方法的参数map.put()可以将 对象 放入 即将查询的参数中；\n必须满足的约定： map.put(k,v) 其中的k 必须是即将查询的方法参数的首字母小写\n //map.put(\u0026quot;student\u0026quot;, student) ; public String testModelAttribute(Student student)  如果不一致，需要通过@ModelAttribute声明。\nmap.put(\u0026quot;stu\u0026quot;, student); public String testModelAttribute(@ModelAttribute(\u0026quot;stu\u0026quot;)Student student) {  一个Servlet 对应一个功能：\n增删改查 对应于 4个Servlet\n@ModelAttribute会在 该类的每个方法执行前 均被执行一次，因为使用时需要注意。\n视图、视图解析器 流程\nController返回值\u0026ndash;\u0026gt;ModeAndView\u0026ndash;\u0026gt;ViewResolver(视图解析器)\u0026ndash;\u0026gt;视图view（渲染）（Jsp/PDF/Excel）\n视图的顶级接口:\nView  视图解析器顶级接口：\nViewResolver  常见的视图和解析器：\nInternalResourceView、InternalResourceViewResolver  public class JstlView extends InternalResourceView：\nspringMVC解析jsp时 会默认使用InternalResourceView，如果发现Jsp中包含了jstl语言相关的内容，则自动转为JstlView。\nJstlView： 可以解析jstl\\实现国际化操作\n国际化： 针对不同地区、不同国家 ，进行不同的显示\n中国: 欢迎 美国： welcome  具体实现国际化步骤：  创建资源文件\n基名_语言_地区.properties 基名_语言.properties  中国\ni18n_zh_CH.properties\nresource.welcome=你好 resource.exist=退出  i18n_en_US.properties\nresource.welcome=WELCOME resource.exist=EXIST  i18n.properties\nxxx  系统会先查询i18n_zh_CH.properties文件中的内容，如果其他文件中没有设置一些属性的值，则在i18n.properties中寻找\n文件中存放的是ASCLL值，如果输入时，没有进行转化，可以使用jdk中的工具：\ncd到jdk安装位置/bin native2ascii.exe回车 输入要转化的值 回车  然后将转换后的值放入文件中\ni18n:internationalization的首末字符i和n，18为中间的字符数\n 配置springmvc.xml，加载资源文件\n\u0026lt;!-- 加载国际化资源文件 --\u0026gt; \u0026lt;bean id=\u0026quot;messageSource\u0026quot; class=\u0026quot;org.springframework.context.support.ResourceBundleMessageSource\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;basename\u0026quot; value=\u0026quot;i18n\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  ResourceBundleMessageSource会在springmvc响应程序时 介入（解析国际化资源文件）\nspringmvc在启动时，会自动查找一个id=\u0026ldquo;messageSource\u0026rdquo;的bean，如果有 则自动加载\n 通过jstl使用国际化\njar\njstl.jar standar.jar  导入命名空间success.jsp\n\u0026lt;%@ taglib uri=\u0026quot;http://java.sun.com/jsp/jstl/core\u0026quot; prefix=\u0026quot;fmt\u0026quot; %\u0026gt;  使用\n\u0026lt;fmt:message key=\u0026quot;resources.welcome\u0026quot;\u0026gt;\u0026lt;/fmt:message\u0026gt; \u0026lt;fmt:message key=\u0026quot;resources.exit\u0026quot;\u0026gt;\u0026lt;/fmt:message\u0026gt;  ResourceBundleMessageSource:在MVC响应时介入，因此不能直接访问success.jsp，需要响应请求后访问\n\u0026lt;a href=\u0026quot;handler/testI18n\u0026quot;\u0026gt;testI18n\u0026lt;/a\u0026gt;  @RequestMapping(value=\u0026quot;testI18n\u0026quot;) public String testI18n() { return \u0026quot;success\u0026quot;; }   InternalResourceViewResolver其他功能： \u0026lt;mvc:view-controller ...\u0026gt; index.jsp -\u0026gt; Controller(@RequsetMapping(\u0026quot;a\u0026quot;)) -\u0026gt;succes.jsp  要用SpringMVC实现：index.jsp -\u0026gt; succes.jsp ：\n\u0026lt;a href=\u0026quot;handler/testMvcViewController\u0026quot;\u0026gt;testMvcViewController\u0026lt;/a\u0026gt;  配置，springMVC.xml\n\u0026lt;!--view-name会被视图解析器 加上前缀、后缀 --\u0026gt; \u0026lt;mvc:view-controller path=\u0026quot;handler/testMvcViewController\u0026quot; view-name=\u0026quot;success\u0026quot;/\u0026gt;  以上注解 ，会让所有的请求 转入\u0026lt;mvc:..\u0026gt;标签中匹配映射地址，而会忽略调@RequsetMapping()；(controller)\n如果想让 @RequsetMapping(\u0026ldquo;a\u0026rdquo;) 和\u0026lt;mvc:..\u0026gt;共存，则需要加入一个注解：\n\u0026lt;!--此配置是SpringMVC的基础配置，很功能都需要通过该注解来协调 --\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt;  指定请求方式 指定跳转方式： 请求转发：地址栏不改变\nreturn \u0026quot;forward:/views/success.jsp\u0026quot;;  重定向：地址栏改变 return \u0026ldquo;redirect:/views/success.jsp\u0026rdquo;;\nforward: redirect: ，需要注意 此种方式，不会被视图解析器加上前缀(/views)、后缀(.jsp)\n处理静态资源： html css js 图片 视频  动态（百度：天气 ）：可以与用户交互、因为时间/地点的不同 而结果不同的内容\n在SpringMVC中，如果直接访问静态资源：404 。\n原因：之前将所有的请求 通过通配符/拦截，进而交给 SPringMVC的入口DispatcherServlet去处理：找该请求映射对应的 @requestMapping\nhttp://localhost:8888/SpringMVCProject/img.png\n@RequsetMapping(\u0026ldquo;img.png\u0026rdquo;) return sucess\n解决：如果是 需要mvc处理的，则交给@RequsetMapping(\u0026ldquo;img.png\u0026rdquo;)处理；如果不需要springmvc处理，则使用 tomcat默认的Servlet去处理。\ntomcat默认的Servlet去处理：如果有 对应的请求拦截,则交给相应的Servlet去处理；如果没有对应的servlet，则直接访问。\ntomcat默认的Servlet在哪里？\n在tomcat配置文件\\conf\\web.xml中\n解决静态资源方案：如果有springmvc对应的@requestMapping则交给spring处理；如果没有对应@requestMapping,则交给服务器tomcat默认的servlet去处理 ：\n实现方法，只需要增加2个注解即可 springmvc.xml：\n\u0026lt;!-- 该注解 会让 springmvc： 接收一个请求，并且该请求 没有对应的@requestmapping时，将该请求 交给服务器默认的servlet去处理（直接访问） --\u0026gt; \u0026lt;mvc:default-servlet-handler\u0026gt;\u0026lt;/mvc:default-servlet-handler\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt;  总结：要让springmvc访问静态资源，只需要加入以下2个注解：\n\u0026lt;mvc:default-servlet-handler\u0026gt;\u0026lt;/mvc:default-servlet-handler\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt;  类型转换 Spring自带一些 常见的类型转换器 public String testDelete(@PathVariable(\u0026quot;id\u0026quot;) String id)  既可以接受int类型数据id 也可以接受String类型的id\n可以自定义类型转换器  编写 自定义类型转器的类 （实现Converter接口）\n//将字符串变成Student public class MyConverter implements Converter\u0026lt;String,Student\u0026gt;{ @Override public Student convert(String source) {//source:2-zs-23 //source接受前端传来的String:2-zs-23 String[] studentStrArr = source.split(\u0026quot;-\u0026quot;) ; Student student = new Student(); student.setId( Integer.parseInt( studentStrArr[0]) ); student.setName(studentStrArr[1]); student.setAge(Integer.parseInt(studentStrArr[2] )); return student; } }  配置：将MyConverter加入到springmvc中\n 将 自定义转换器 纳入SpringIOC容器\n\u0026lt;!-- 1将 自定义转换器 纳入SpringIOC容器 --\u0026gt; \u0026lt;bean id=\u0026quot;myConverter\u0026quot; class=\u0026quot;org.lanqiao.converter.MyConverter\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt;  将myConverter再纳入 SpringMVC提供的转换器Bean\n\u0026lt;!-- 2将myConverter再纳入 SpringMVC提供的转换器Bean --\u0026gt; \u0026lt;bean id=\u0026quot;conversionService\u0026quot; class=\u0026quot;org.springframework.context.support.ConversionServiceFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;converters\u0026quot;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;ref bean=\u0026quot;myConverter\u0026quot;/\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  将conversionService注册到annotation-driven中\n\u0026lt;!-- 3将conversionService注册到annotation-driven中 --\u0026gt; \u0026lt;!--此配置是SpringMVC的基础配置，很功能都需要通过该注解来协调 --\u0026gt; \u0026lt;mvc:annotation-driven conversion-service=\u0026quot;conversionService\u0026quot;\u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt;    测试转换器：\n\u0026lt;form action=\u0026quot;handler/testConverter\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 学生信息:\u0026lt;input name=\u0026quot;studentInfo\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt;\u0026lt;!-- 2-zs-23 --\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;转换\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  @RequestMapping(value=\u0026quot;testConverter\u0026quot;) public String testConverter(@RequestParam(\u0026quot;studentInfo\u0026quot;) Student student) {// 前端：2-zs-23 System.out.println(student.getId()+\u0026quot;,\u0026quot;+student.getName()+\u0026quot;,\u0026quot;+student.getAge()); return \u0026quot;success\u0026quot;; }  其中@RequestParam(\u0026quot;studentInfo\u0026quot;)是触发转换器的桥梁： @RequestParam(\u0026quot;studentInfo\u0026quot;)接收的数据 是前端传递过来的：2-zs-23 ，但是需要将该数据赋值给修饰的目的对象Student；因此SPringMVC可以发现 接收的数据 和目标数据不一致，并且 这两种数据分别是 String、Student,正好符合public Student convert(String source)转换器。因此将类型进行转换\n数据格式化 主要用于对数字和日期的转换\nSimpleDateForamt sdf = new SimpleDateFormat(\u0026quot;yyyy-MM-dd hh:mm:ss\u0026quot;);  SPringMVC提供了很多注解，方便我们数据格式化\n @DateTimeFormat(pattern=\u0026quot;yyyy-MM-dd\u0026quot;) @NumberFormat(parttern=\u0026quot;###,#\u0026quot;)  实现步骤： 1. 配置,springMVC.xml  \u0026lt;!-- 配置 数据格式化 注解 所依赖的bean --\u0026gt; \u0026lt;bean id=\u0026quot;conversionService\u0026quot; class=\u0026quot;org.springframework.format.support.FormattingConversionServiceFactoryBean\u0026quot;\u0026gt; \u0026lt;/bean\u0026gt;  2. 通过注解使用\nStudent.java ``` @DateTimeFormat(pattern=\u0026quot;yyyy-MM-dd\u0026quot;) private Date birthday ;// 2018-12-13 @NumberFormat(pattern=\u0026quot;###,#\u0026quot;) private int id; ``` 格式化：前台传递来的数据，将前台传递来到数据 固定为yyyy-MM-dd 当输入格式不正确时会报错  测试\n\u0026lt;form action=\u0026quot;handler/testDateTimeFormat\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 编号:\u0026lt;input name=\u0026quot;id\u0026quot; type=\u0026quot;text\u0026quot; value=\u0026quot;31\u0026quot; /\u0026gt; 姓名:\u0026lt;input name=\u0026quot;name\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; 出生日期:\u0026lt;input name=\u0026quot;birthday\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;修改\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  @RequestMapping(value=\u0026quot;testDateTimeFormat\u0026quot;) //如果Student格式化出错，会将错误信息 传入result中，这样控制台会显示错误信息，但是前端不显示了，类似异常处理，将异常进行了处理 public String testDateTimeFormat(Student student , BindingResult result) { System.out.println(student.getId()+\u0026quot;,\u0026quot;+student.getName()+\u0026quot;,\u0026quot;+student.getBirthday()); if(result.getErrorCount() \u0026gt;0) { for(FieldError error: result.getFieldErrors() ) { System.out.println(error.getDefaultMessage()); } } return \u0026quot;success\u0026quot;; }  在配置时发现格式化和类型转换所用到的类为\nFormattingConversionServiceFactoryBean ConversionServiceFactoryBean  因此可以将类型转化在格式化中配置，即FormattingConversionServiceFactoryBean:既可以实现格式化、又可以实现类型转换\n由\n\u0026lt;!-- \u0026lt;bean id=\u0026quot;conversionService\u0026quot; class=\u0026quot;org.springframework.context.support.ConversionServiceFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;converters\u0026quot;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;ref bean=\u0026quot;myConverter\u0026quot;/\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; --\u0026gt;  整合到\n\u0026lt;bean id=\u0026quot;conversionService\u0026quot; class=\u0026quot;org.springframework.format.support.FormattingConversionServiceFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;converters\u0026quot;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;ref bean=\u0026quot;myConverter\u0026quot;/\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;\t 错误消息： 上面我们可知，发生异常时在控制台打印后就不在页面打印了，此时想要两处都提示：\n思路：将异常信息传到前端页面中即可\n@RequestMapping(value=\u0026quot;testDateTimeFormat\u0026quot;)//如果Student格式化出错，会将错误信息 传入result中 public String testDateTimeFormat(@Valid Student student, BindingResult result ,Map\u0026lt;String,Object\u0026gt; map) { //System.out.println(student.getId()+\u0026quot;,\u0026quot;+student.getName()+\u0026quot;,\u0026quot;+student.getBirthday()); if(result.getErrorCount() \u0026gt;0) { for(FieldError error: result.getFieldErrors() ) { System.out.println(error.getDefaultMessage()); map.put(\u0026quot;errors\u0026quot;, result.getFieldErrors() ) ;//将错误信息传入requset域中的errors中 //\tresult.getFieldErrors().get(0).getDefaultMessage() } } return \u0026quot;success\u0026quot;; }  \u0026lt;c:forEach items=\u0026quot;${requestScope.errors}\u0026quot; var=\u0026quot;error\u0026quot;\u0026gt; ${error.getDefaultMessage()}\u0026lt;br/\u0026gt; \u0026lt;/c:forEach\u0026gt;  取值时使用了jstl表达式，因此需要配置\njar包\njstl.jar standaed.jar  引入jstl标签库xx.jsp\n \u0026lt;%@ taglib uri=\u0026quot;http://java.sun.com/jsp/jstl/core\u0026quot; prefix=\u0026quot;c\u0026quot; %\u0026gt;  public String testDateTimeFormat(Student student, BindingResult result ,Map\u0026lt;String,Object\u0026gt; map) {  需要验证的数据是 Student中的birthday, SPringMVC要求 如果校验失败 则将错误信息 自动放入 该对象之后紧挨着的 BindingResult中。即Student student, BindingResult result之间 不能有其他参数。\n如果要将控制台的错误消息 传到jsp中显示，则可以将 错误消息对象放入request域中，然后 在jsp中 从request中获取。\n数据校验 JSR303 Hibernate Validator  Hibernate Validator 是JSR 303的扩展。Hibernate Validator 提供了 JSR 303中所有内置的注解，以及自身扩展的4个注解\n使用Hibernate Validator步骤：\njar （注意各个jar之间可能存在版本不兼容）\nhibernate-validator-5.0.0.CR2.jar classmate-0.8.0.jar jboss-logging-3.1.1.GA.jar validation-api-1.1.0.CR1.jar hibernate-validator-annotation-processor-5.0.0.CR2.jar  配置springMVC.xml \u0026lt;mvc:annotation-driven \u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt;  此时mvc:annotation-driven的作用：要实现Hibernate Validator/JSR303 校验（或者其他各种校验），必须实现SpringMVC提供的一个接口：ValidatorFactory\nspringMVC已经帮我们写了一个ValidatorFactory的实现类LocalValidatorFactoryBean\n\u0026lt;mvc:annotation-driven \u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt;会在springmvc容器中 自动加载一个LocalValidatorFactoryBean类，因此可以直接实现数据校验。\n直接使用注解  在属性前加注解\npublic class Student { @Past//当前时间以前 private Date birthday ; }  在校验的Controller中 ，给校验的对象前增加 @Valid\npublic String testDateTimeFormat(@Valid Student student, BindingResult result ,Map\u0026lt;String,Object\u0026gt; map) {   Ajax请求SpringMVC，并且返回JSON格式的数据 jar\njackson-annotations-2.8.9.jar jackson-core-2.8.9.jar jackson-databind-2.8.9.jar  ajax请求\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;js/jquery-1.8.3.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; $(document).ready(function(){ $(\u0026quot;#testJson\u0026quot;).click(function(){ //通过ajax请求springmvc $.post( \u0026quot;handler/testJson\u0026quot;,//服务器地址 //{\u0026quot;name\u0026quot;:\u0026quot;zs\u0026quot;,\u0026quot;age\u0026quot;:23} function(result){//服务端处理完毕后的回调函数 List\u0026lt;Student\u0026gt; students， 加上@ResponseBody后， students实质是一个json数组的格式 for(var i=0;i\u0026lt;result.length ;i++){ alert(result[i].id +\u0026quot;-\u0026quot;+result[i].name +\u0026quot;-\u0026quot;+result[i].age); } } ); }); });  @ResponseBody//告诉SpringMVC，此时的返回 不是一个 View页面，而是一个 ajax调用的返回值（Json数组） @RequestMapping(value=\u0026quot;testJson\u0026quot;) public List\u0026lt;Student\u0026gt; testJson() { //Controller-Service-dao //StudentService studentService = new StudentServiceImp(); //List\u0026lt;Student\u0026gt; students = studentService.qeuryAllStudent(); //模拟调用service的查询操作 Student stu1 = new Student(1,\u0026quot;zs\u0026quot;,23); Student stu2 = new Student(2,\u0026quot;ls\u0026quot;,24); Student stu3 = new Student(3,\u0026quot;ww\u0026quot;,25); List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); students.add(stu1) ; students.add(stu2) ; students.add(stu3) ; return students; }  SpringMVC实现文件上传 和Servlet方式的本质一样，都是通过\ncommons-fileupload.jar和commons-io.jar  SpringMVC可以简化文件上传的代码，但是必须满足条件：实现MultipartResolver接口 ；而该接口的实现类SpringMVC也已经提供了CommonsMultipartResolver\n具体步骤：（直接使用CommonsMultipartResolver实现上传） 1. jar包\n commons-fileupload.jar、commons-io.jar   配置CommonsMultipartResolver\n将其加入SpringIOC容器\n\u0026lt;bean id=\u0026quot;multipartResolver\u0026quot; class=\u0026quot;org.springframework.web.multipart.commons.CommonsMultipartResolver\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;defaultEncoding\u0026quot; value=\u0026quot;UTF-8\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 上传单个文件的最大值，单位Byte;如果-1，表示无限制 --\u0026gt; \u0026lt;property name=\u0026quot;maxUploadSize\u0026quot; value=\u0026quot;104857600\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  配置CommonsMultipartResolver，用于实现文件上传 将其加入SpringIOC容器.\nspringIoc容器在初始化时，会自动寻找一个Id=\u0026quot;multipartResolver\u0026quot;的bean，并将其加入Ioc容器\n 处理方法\n\u0026lt;form action=\u0026quot;handler/testUpload\u0026quot; method=\u0026quot;post\u0026quot; enctype=\u0026quot;multipart/form-data\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;file\u0026quot; /\u0026gt; 描述:\u0026lt;input name=\u0026quot;desc\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;上传\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  //文件上传处理方法 @RequestMapping(value=\u0026quot;testUpload\u0026quot;) //abc.png public String testUpload(@RequestParam(\u0026quot;desc\u0026quot;) String desc , @RequestParam(\u0026quot;file\u0026quot;) MultipartFile file ) throws IOException { System.out.println(\u0026quot;文件描述信息：\u0026quot;+desc); //jsp中上传的文件：file InputStream input = file.getInputStream() ;//IO String fileName = file.getOriginalFilename() ; OutputStream out = new FileOutputStream(\u0026quot;d:\\\\\u0026quot;+fileName) ; byte[] bs = new byte[1024]; int len = -1; while(( len = input.read(bs)) !=-1 ) { out.write(bs, 0, len); } out.close(); input.close(); //将file上传到服务器中的 某一个硬盘文件中 System.out.println(\u0026quot;上传成功！\u0026quot;); return \u0026quot;success\u0026quot;; }  框架： 将原来自己写的1000行代码，变成：框架帮你写900行，剩下100行自己写\n  控制器：handler servlet controller action\n拦截器 拦截器的原理和过滤器相同。\nSpringMVC：要想实现拦截器，必须实现一个接口\nHandlerInterceptor   编写拦截器\nimplements HandlerInterceptor\n拦截器一\npublic class MyInterceptor implements HandlerInterceptor{ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026quot;拦截请求\u0026quot;); // return true;//true:拦截操作之后，放行 ；false:拦截之后不放行，请求终止； } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026quot;拦截响应\u0026quot;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026quot;视图(jsp)被渲染完毕\u0026quot;); } }  拦截器二\npublic class MySecondInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026quot;第二个拦截器，拦截请求...22222\u0026quot;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026quot;第二个拦截器，拦截响应...22222\u0026quot;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026quot;第二个拦截器，afterCompletion\u0026quot;); } }  配置\n将自己写的拦截器 配置到springmvc中（spring）\n\u0026lt;!-- 将自己写的拦截器 配置到springmvc中（spring）；默认拦截全部请求 --\u0026gt; \u0026lt;mvc:interceptors\u0026gt; \u0026lt;!--拦截一切请求时放在这 \u0026lt;bean class=\u0026quot;org.lanqiao.interceptor.MySecondInterceptor\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; --\u0026gt; \u0026lt;!-- 配置具体的拦截路径,二者取交集 --\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;!-- 指定拦截的路径,基于ant风格 --\u0026gt; \u0026lt;mvc:mapping path=\u0026quot;/**\u0026quot;/\u0026gt; \u0026lt;!-- 指定拦不截的路径 --\u0026gt; \u0026lt;mvc:exclude-mapping path=\u0026quot;/handler/testUpload\u0026quot;/\u0026gt; \u0026lt;bean class=\u0026quot;org.lanqiao.interceptor.MyInterceptor\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;!-- 配置具体的拦截路径 --\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;!-- 指定拦截的路径,基于ant风格 --\u0026gt; \u0026lt;mvc:mapping path=\u0026quot;/**\u0026quot;/\u0026gt; \u0026lt;!-- 指定拦不截的路径 --\u0026gt; \u0026lt;mvc:exclude-mapping path=\u0026quot;/handler/testUpload\u0026quot;/\u0026gt; \u0026lt;bean class=\u0026quot;org.lanqiao.interceptor.MySecondInterceptor\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt;   拦截器1拦截请求- 拦截器2拦截请求 - 请求方法 - 拦截器2处理相应-拦截器1处理相应- 只会被 最后一个拦截器的afterCompletion()拦截\n如果有多个拦截器，则每个拦截器的preHandle postHandle 都会在相应时机各被触发一次；但是afterCompletion， 只会执行最后一个拦截器的该方法。\n异常处理 SpringMVC实现异常处理的顶级接口\nHandlerExceptionResolver  该接口的每个实现类 都是异常的一种处理方式：\nExceptionHandlerExceptionResolver 主要提供了@ExceptionHandler注解，并通过该注解处理异常\n@RequestMapping(\u0026quot;testExceptionHandler\u0026quot;) public String testExceptionHandler() { //try { System.out.println( 1/0 );// //}catch(ArithmeticException e) e //}catch(Exception e) e return \u0026quot;success\u0026quot; ; }  @RequestMapping(\u0026quot;testExceptionHandler2\u0026quot;) public String testExceptionHandler2() { int[] nums = new int[2]; System.out.println(nums[2]);//ArrayIndexOutOfBoundsException return \u0026quot;success\u0026quot; ; }  //该方法 可以捕获本类中 抛出的ArithmeticException异常 @ExceptionHandler({ArithmeticException.class,ArrayIndexOutOfBoundsException.class}) public ModelAndView handlerArithmeticException(Exception e) { ModelAndView mv = new ModelAndView(\u0026quot;error\u0026quot;); System.out.println(e +\u0026quot;============\u0026quot;); mv.addObject(\u0026quot;er\u0026quot;, e) ; return mv; }  @ExceptionHandler标识的方法的参数 必须在异常类型(Throwable或其子类) ，不能包含其他类型的参数\n异常处理路径：最短优先\n如果有方法抛出一个ArithmeticException异常，而该类中 有2个对应的异常处理方法：\n@ExceptionHandler({Exception.class }) public ModelAndView handlerArithmeticException2(Exception e) {} @ExceptionHandler({ArithmeticException.class }) public ModelAndView handlerArithmeticException1(Exception e) {}  则优先级： 最短优先。\n@ExceptionHandler默认只能捕获 当前类中的异常方法。\n如果发生异常的方法 和处理异常的方法 不在同一个类中：@ControllerAdvice\n//@ControllerAdvice public class MyExceptionHandler {//不是控制器，仅仅是 用于处理异常的类\n@ExceptionHandler({Exception.class }) public ModelAndView handlerArithmeticException2(Exception e) { ModelAndView mv = new ModelAndView(\u0026quot;error\u0026quot;); System.out.println(e +\u0026quot;============\u0026quot;+\u0026quot;该@ControllerAdvice中的异常处理方法，可以处理任何类中的异常\u0026quot;); mv.addObject(\u0026quot;er\u0026quot;, e) ; return mv; } }  总结：如果一个方法用于处理异常，并且只处理当前类中的异常：@ExceptionHandler\n如果一个方法用于处理异常，并且处理所有类中的异常： 类前加@ControllerAdvice、 处理异常的方法前加@ExceptionHandler\nResponseStatusExceptionResolver 自定义异常显示页面 @ResponseStatus\n@ResponseStatus(value=HttpStatus.FORBIDDEN,reason=\u0026quot;数组越界222!!!\u0026quot;) public class MyArrayIndexOutofBoundsException extends Exception {//自定义异常 }  @RequestMapping(\u0026quot;testMyException\u0026quot;) public String testMyException(@RequestParam(\u0026quot;i\u0026quot;) Integer i) throws MyArrayIndexOutofBoundsException { if(i == 3) { throw new MyArrayIndexOutofBoundsException();//抛出异常 } return \u0026quot;success\u0026quot; ; }  @ResponseStatus也可以标志在方法前：\n@RequestMapping(\u0026quot;testMyException2\u0026quot;) public String testMyException2(@RequestParam(\u0026quot;i\u0026quot;) Integer i) { if(i == 3) { return \u0026quot;redirect:testResponseStatus\u0026quot; ;//跳转到某一个 异常处理方法里 } return \u0026quot;success\u0026quot; ; } @ResponseStatus(value=HttpStatus.CONFLICT ,reason=\u0026quot;测试。。。\u0026quot;) @RequestMapping(\u0026quot;testResponseStatus\u0026quot;) public String testResponseStatus() { return \u0026quot;success\u0026quot; ; }  DefaultHandlerExceptionResolver SPringMVC在一些常见异常的基础上（300 500 405），新增了一些异常，例如：\n* @see org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler * @see #handleNoSuchRequestHandlingMethod * @see #handleHttpRequestMethodNotSupported ：如果springmvc的处理方法限制为post方式，如果实际请求为get,则会触发此异常显示的页面 * @see #handleHttpMediaTypeNotSupported * @see #handleMissingServletRequestParameter * @see #handleServletRequestBindingException * @see #handleTypeMismatch * @see #handleHttpMessageNotReadable * @see #handleHttpMessageNotWritable * @see #handleMethodArgumentNotValidException * @see #handleMissingServletRequestParameter * @see #handleMissingServletRequestPartException * @see #handleBindException  SimpleMappingExceptionResolver 通过配置来实现异常的处理\n@RequestMapping(value=\u0026quot;testSimpleMappingExceptionResolver\u0026quot;) public String testSimpleMappingExceptionResolver() { System.out.println(1/0); return \u0026quot;success\u0026quot; ; }   \u0026lt;!-- SimpleMappingExceptionResolver:以配置的方式 处理异常 --\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\u0026quot;\u0026gt; \u0026lt;!-- 如果发生异常，异常对象会被保存在 exceptionAttribute的value值中；并且会放入request域中 ；异常变量的默认值是 exception--\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026quot;exceptionAttribute\u0026quot; value=\u0026quot;exception\u0026quot;\u0026gt;\u0026lt;/property\u0026gt;--\u0026gt; \u0026lt;property name=\u0026quot;exceptionMappings\u0026quot;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;!-- 相当于catch(ArithmeticException ex){ 跳转：error } --\u0026gt; \u0026lt;prop key=\u0026quot;java.lang.ArithmeticException\u0026quot;\u0026gt; error \u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026quot;java.lang.NullPointerException\u0026quot;\u0026gt; error \u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  ${requestScope.exception}  表单标签: 启动tomcat报错：\nCaused by: java.lang.IllegalArgumentException: More than one fragment with the name [spring_web] was found. This is not legal with relative ordering. See section 8.2.2 2c of the Servlet specification for details.  需要在web.xml添加标签\n\u0026lt;absolute-ordering/\u0026gt;  自定义标签el/ jstl\nSpring EL : 1. 支持各种类型的请求方式(查询doGet增 加doPost、删除doDelete 、修改doPut) 2. 可以将对象和表单绑定起来；对象的属性\u0026ndash;表单path值 一一对应\nIDEA开发springmvc SPringMVC项目:\n选择Springmvc:自动下载springmvc相关的jar\n处理Jar :artifacts - fix : miss all\u0026hellip;\n开发代码:\n引入标签库 \u0026lt;%@ taglib prefix=\u0026quot;form\u0026quot; uri=\u0026quot;http://www.springframework.org/tags/form\u0026quot; %\u0026gt;  使用： 类\n public class Persion { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } }  表单\n\u0026lt;form:form\u0026gt; 姓名：\u0026lt;form:input path=\u0026quot;name\u0026quot;/\u0026gt;\u0026lt;br\u0026gt; 年龄：\u0026lt;form:input path=\u0026quot;age\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt;  控制器\n@Controller @RequestMapping(\u0026quot;/FormDemo\u0026quot;) public class FormDemo { public String testForm(Map\u0026lt;String,Object\u0026gt; map){ Persion per = new Persion(); per.setAge(23); per.setName(\u0026quot;zs\u0026quot;); map.put(\u0026quot;command\u0026quot;, per);//将per放入了request域中的command中 return \u0026quot;forward:/views/springForm.jsp\u0026quot;; } }  \u0026lt;form id=\u0026quot;command\u0026quot;\u0026gt;:SpringMVC标签会默认自动从名为\u0026rdquo;command\u0026rdquo;的对象中获取值，因此传值时将值放入command中\n如果在map.put()时，名字不是command，则需要手工指定\n\u0026lt;form:form commandName=\u0026quot;person\u0026quot;\u0026gt; 或 \u0026lt;form:form modelAttribute=\u0026quot;person\u0026quot;\u0026gt;  则传值时\n map.put(\u0026quot;person\u0026quot;, per);//将per放入了request  各种表单的提交方式  编写method属性\n\u0026lt;form:form action=\u0026quot;FormDemo/testMethod\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;增加\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt; \u0026lt;form:form action=\u0026quot;FormDemo/testMethod\u0026quot; method=\u0026quot;delete\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;删除\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt; \u0026lt;form:form action=\u0026quot;FormDemo/testMethod\u0026quot; method=\u0026quot;put\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;修改\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt; \u0026lt;form:form action=\u0026quot;FormDemo/testMethod\u0026quot; method=\u0026quot;get\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;查询\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt;  @RequestMapping(value = \u0026quot;/testMethod\u0026quot;,method = RequestMethod.POST) public String testPost(){ System.out.println(\u0026quot;post\u0026quot;); return \u0026quot;/index.jsp\u0026quot;; } @RequestMapping(value = \u0026quot;/testMethod\u0026quot;,method = RequestMethod.DELETE) public String testDelete(){ System.out.println(\u0026quot;delete\u0026quot;); return \u0026quot;/index.jsp\u0026quot;; } @RequestMapping(value = \u0026quot;/testMethod\u0026quot;,method =RequestMethod.PUT) public String testPut(){ System.out.println(\u0026quot;put\u0026quot;); return \u0026quot;/index.jsp\u0026quot;; } @RequestMapping(value = \u0026quot;/testMethod\u0026quot;,method = RequestMethod.GET) public String testGet(){ System.out.println(\u0026quot;get\u0026quot;); return \u0026quot;/index.jsp\u0026quot;; }  配置过滤器\n\u0026lt;!--增加过滤器 支持delete和put请求--\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;HiddenHttpMethodFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.HiddenHttpMethodFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;HiddenHttpMethodFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;  HiddenHttpMethodFilter会将全部请求中名为\u0026rdquo;method\u0026rdquo;的隐藏域进行Put|Delete处理\n  可以配置\n \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;HiddenHttpMethodFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.HiddenHttpMethodFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;methodParam\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;myMethod\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt;  指定要处理的隐藏的名字\n\u0026lt;form action=\u0026quot;FormDemo/testMethod\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;myMethod\u0026quot; value=\u0026quot;delete\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;修改\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  如果是使用的是SpringMvc标签：\nmethod=\u0026quot;put|delete\u0026quot;  如果不是SpringMVC标签，是传统的htnl标签\nmethod=\u0026quot;post\u0026quot; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;myMethod\u0026quot; value=\u0026quot;delete|put\u0026quot;\u0026gt;  checkbox 自动绑定request域中的值   通过boolean值绑定\n@RequestMapping(\u0026quot;/testForm2\u0026quot;) public String testForm2(Map\u0026lt;String,Object\u0026gt; map){ Persion per = new Persion(); //per.setAge(23); //per.setName(\u0026quot;zs\u0026quot;); per.setSex(false); map.put(\u0026quot;per\u0026quot;, per); return \u0026quot;springForm\u0026quot;; //return \u0026quot;forward:/views/springForm.jsp\u0026quot;; }  \u0026lt;form:form commandName=\u0026quot;per\u0026quot; action=\u0026quot;textForm2\u0026quot;\u0026gt; \u0026lt;for:checkbox path=\u0026quot;sex\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt;   绑定集合（有值的打上勾）\n@RequestMapping(\u0026quot;/testForm3\u0026quot;) public String testForm3(Map\u0026lt;String,Object\u0026gt; map){ Persion per = new Persion(); List\u0026lt;String\u0026gt; hobbirs=new ArrayList\u0026lt;\u0026gt;(); hobbirs.add(\u0026quot;football\u0026quot;); hobbirs.add(\u0026quot;basketball\u0026quot;); per.setHobbies(hobbirs); map.put(\u0026quot;per\u0026quot;, per);//将per放入了request域中 return \u0026quot;springForm\u0026quot;; }  \u0026lt;form:form commandName=\u0026quot;per\u0026quot; action=\u0026quot;textForm3\u0026quot;\u0026gt; \u0026lt;form:checkbox path=\u0026quot;hobbies\u0026quot; value=\u0026quot;football\u0026quot;\u0026gt;\u0026lt;/form:checkbox\u0026gt; \u0026lt;form:checkbox path=\u0026quot;hobbies\u0026quot; value=\u0026quot;basketball\u0026quot;\u0026gt;\u0026lt;/form:checkbox\u0026gt; \u0026lt;form:checkbox path=\u0026quot;hobbies\u0026quot; value=\u0026quot;pingpang\u0026quot;\u0026gt;\u0026lt;/form:checkbox\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt;  (了解）嵌套对象的toString（）返回值\n@RequestMapping(\u0026quot;/testForm4\u0026quot;) public String testForm4(Map\u0026lt;String,Object\u0026gt; map){ Persion per = new Persion(); Other other = new Other(); per.setOther(other); map.put(\u0026quot;per\u0026quot;, per);//将per放入了request域中 return \u0026quot;springForm\u0026quot;; }  \u0026lt;form:form commandName=\u0026quot;per\u0026quot; action=\u0026quot;textForm\u0026quot;\u0026gt; \u0026lt;form:checkbox path=\u0026quot;other\u0026quot; value=\u0026quot;football\u0026quot;\u0026gt;\u0026lt;/form:checkbox\u0026gt; \u0026lt;form:checkbox path=\u0026quot;other\u0026quot; value=\u0026quot;basketball\u0026quot;\u0026gt;\u0026lt;/form:checkbox\u0026gt; \u0026lt;form:checkbox path=\u0026quot;other\u0026quot; value=\u0026quot;pingpang\u0026quot;\u0026gt;\u0026lt;/form:checkbox\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt;  public class Other { @Override public String toString() { return \u0026quot;pingpang\u0026quot;; } }  path:选中的选项（选中）\nitem:所有的选项 a,b ,c d：如果是list，set，数组，则标签名默认就是选项值，如果想自定义标签名需要使用map\n@RequestMapping(\u0026quot;/testForm5\u0026quot;) public String testForm5(Map\u0026lt;String,Object\u0026gt; map){ Persion per = new Persion(); List\u0026lt;String\u0026gt; hobbies=new ArrayList\u0026lt;\u0026gt;(); hobbies.add(\u0026quot;football\u0026quot;); hobbies.add(\u0026quot;basketball\u0026quot;); per.setHobbies(hobbies); map.put(\u0026quot;per\u0026quot;, per);//将per放入了request域中 List\u0026lt;String\u0026gt; allHobbies=new ArrayList\u0026lt;\u0026gt;(); allHobbies.add(\u0026quot;football\u0026quot;); allHobbies.add(\u0026quot;basketball\u0026quot;); allHobbies.add(\u0026quot;pingpang\u0026quot;); allHobbies.add(\u0026quot;aaa\u0026quot;); allHobbies.add(\u0026quot;bbb\u0026quot;); map.put(\u0026quot;allHobbies\u0026quot;, allHobbies); return \u0026quot;springForm\u0026quot;; }  \u0026lt;form:form commandName=\u0026quot;per\u0026quot; action=\u0026quot;textForm\u0026quot;\u0026gt; \u0026lt;form:checkboxes path=\u0026quot;hobbies\u0026quot; items=\u0026quot;${allHobbies}\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt;  加载所有的选项allHobbies并且选中选中的hobbies\n指定标签名\n可以通过 Map\u0026lt;Value值，标签名\u0026gt;\nMap\u0026lt;String, String\u0026gt; allHobbiesMap = new HashMap\u0026lt;\u0026gt;(); allHobbiesMap.put(\u0026quot;football\u0026quot;,\u0026quot;足球\u0026quot;); allHobbiesMap.put(\u0026quot;basketball\u0026quot;,\u0026quot;篮球\u0026quot;); allHobbiesMap.put(\u0026quot;pingpang\u0026quot;,\u0026quot;乒乓球\u0026quot;); allHobbiesMap.put(\u0026quot;aaa\u0026quot;,\u0026quot;bbb\u0026quot;); map.put(\u0026quot;allHobbies\u0026quot;, allHobbiesMap);  单选按钮 @RequestMapping(\u0026quot;/testForm6\u0026quot;) public String testForm6(Map\u0026lt;String,Object\u0026gt; map){ Persion per = new Persion(); per.setCountry(\u0026quot;China\u0026quot;); map.put(\u0026quot;per\u0026quot;, per);//将per放入了request域中 return \u0026quot;springForm\u0026quot;; }  \u0026lt;form:form commandName=\u0026quot;per\u0026quot; action=\u0026quot;textForm\u0026quot;\u0026gt; 中国：\u0026lt;form:radiobutton path=\u0026quot;country\u0026quot; value=\u0026quot;China\u0026quot;/\u0026gt; 美国：\u0026lt;form:radiobutton path=\u0026quot;country\u0026quot; value=\u0026quot;USE\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt;  一批\n@RequestMapping(\u0026quot;/testForm7\u0026quot;) public String testForm7(Map\u0026lt;String,Object\u0026gt; map){ Persion per = new Persion(); per.setFavouriteBall(\u0026quot;pingpang\u0026quot;); map.put(\u0026quot;per\u0026quot;, per);//将per放入了request域中 Map\u0026lt;String, String\u0026gt; allHobbiesMap = new HashMap\u0026lt;\u0026gt;(); allHobbiesMap.put(\u0026quot;football\u0026quot;,\u0026quot;足球\u0026quot;); allHobbiesMap.put(\u0026quot;basketball\u0026quot;,\u0026quot;篮球\u0026quot;); allHobbiesMap.put(\u0026quot;pingpang\u0026quot;,\u0026quot;乒乓球\u0026quot;); allHobbiesMap.put(\u0026quot;aaa\u0026quot;,\u0026quot;bbb\u0026quot;); map.put(\u0026quot;allBallMap\u0026quot;, allHobbiesMap); return \u0026quot;springForm\u0026quot;; }  \u0026lt;form:form commandName=\u0026quot;per\u0026quot; action=\u0026quot;textForm\u0026quot;\u0026gt; \u0026lt;form:radiobuttons path=\u0026quot;favouriteBall\u0026quot; items=\u0026quot;${allBallMap}\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt;  属性delimiter可以指定选项与选项之间的分隔符\n\u0026lt;form:radiobuttons path=\u0026quot;favouriteBall\u0026quot; items=\u0026quot;${allBallMap}\u0026quot; delimiter=\u0026quot;、\u0026quot;/\u0026gt;  select 写法一\n\u0026lt;form:form commandName=\u0026quot;per\u0026quot; action=\u0026quot;textForm\u0026quot;\u0026gt; \u0026lt;form:select path=\u0026quot;favouriteBall\u0026quot; items=\u0026quot;${allBallMap}\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt;  写法二：指定选定的值，选项是自己写的，后端不传所有的选项只传favouriteBall\n\u0026lt;form:form commandName=\u0026quot;per\u0026quot; action=\u0026quot;textForm\u0026quot;\u0026gt; \u0026lt;form:select path=\u0026quot;favouriteBall\u0026quot;\u0026gt; \u0026lt;form:option value=\u0026quot;football\u0026quot;\u0026gt;足球11\u0026lt;/form:option\u0026gt; \u0026lt;form:option value=\u0026quot;basketball\u0026quot;\u0026gt;篮球11\u0026lt;/form:option\u0026gt; \u0026lt;form:option value=\u0026quot;pingpang\u0026quot;\u0026gt;乒乓球11\u0026lt;/form:option\u0026gt; \u0026lt;form:option value=\u0026quot;aaa\u0026quot;\u0026gt;bbb11\u0026lt;/form:option\u0026gt; \u0026lt;/form:select\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt;  写法三\n\u0026lt;form:form commandName=\u0026quot;per\u0026quot; action=\u0026quot;textForm\u0026quot;\u0026gt; \u0026lt;form:select path=\u0026quot;favouriteBall\u0026quot;\u0026gt; \u0026lt;form:options items=\u0026quot;${allBallMap}\u0026quot;\u0026gt;\u0026lt;/form:options\u0026gt; \u0026lt;%-- \u0026lt;form:option value=\u0026quot;football\u0026quot;\u0026gt;足球11\u0026lt;/form:option\u0026gt; \u0026lt;form:option value=\u0026quot;basketball\u0026quot;\u0026gt;篮球11\u0026lt;/form:option\u0026gt; \u0026lt;form:option value=\u0026quot;pingpang\u0026quot;\u0026gt;乒乓球11\u0026lt;/form:option\u0026gt; \u0026lt;form:option value=\u0026quot;aaa\u0026quot;\u0026gt;bbb11\u0026lt;/form:option\u0026gt;--%\u0026gt; \u0026lt;/form:select\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt;  @RequestMapping(\u0026quot;/testForm7\u0026quot;) public String testForm7(Map\u0026lt;String,Object\u0026gt; map){ Persion per = new Persion(); per.setFavouriteBall(\u0026quot;pingpang\u0026quot;); map.put(\u0026quot;per\u0026quot;, per);//将per放入了request域中 Map\u0026lt;String, String\u0026gt; allHobbiesMap = new HashMap\u0026lt;\u0026gt;(); allHobbiesMap.put(\u0026quot;football\u0026quot;,\u0026quot;足球\u0026quot;); allHobbiesMap.put(\u0026quot;basketball\u0026quot;,\u0026quot;篮球\u0026quot;); allHobbiesMap.put(\u0026quot;pingpang\u0026quot;,\u0026quot;乒乓球\u0026quot;); allHobbiesMap.put(\u0026quot;aaa\u0026quot;,\u0026quot;bbb\u0026quot;); map.put(\u0026quot;allBallMap\u0026quot;, allHobbiesMap); return \u0026quot;springForm\u0026quot;; }  如果方式三和方式二同时存在则会优先选择方式二\n如果方式一和方式二同时存在则会优先选择一\n如果普通方式和springmvc方式同时存在则会使用springmvc的方式，普通的option没有匹配的功能。\ngit源码\n","id":25,"section":"posts","summary":"git源码 简介 Servlet发展史 Struts1.x\u0026ndash;\u0026gt;Struts2.x\u0026ndash;\u0026gt;SpringMVC springmvc: jar spring-aop.jar spring-bean.jar spring-context.jar spring-core.jar spring-web.jar spring-webmvc.jar commons-logging.jar 报错NoClassDefFoundError：缺少jar 第一个SpringMVC程序 Servet","tags":["Spring家族"],"title":"SpringMVC自学笔记","uri":"https://mumulx.github.io/2019/11/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" spring简介 2002 Rod Johnon 发布\u0026lt;Expoer One-on-one j2eedevelopment and Design\u0026gt;\n2003产生Spring，Spring两大核心IOC、Aop\nSpring data, spring boot, spring cloud, spring framework ，spring social\nIOC :控制反转 (DI:依赖注入) git源码\n搭建Spring环境 jar包 下载jar\n使用spring-framework-4.3.9.RELEASE-dist.zip\n开发spring至少需要使用的jar(5个+1个):\nspring-aop.jar 开发AOP特性时需要的JAR spring-beans.jar 处理Bean的jar \u0026lt;bean\u0026gt; spring-context.jar 处理spring_上下文的jar\u0026lt;context\u0026gt; spring-core.jarspring 核心jar spring-expression.jar spring表达式 三方提供的日志jar commons-logging.jar 日志  xxx.jar二进制文件 xxx-javadoc.jar说明文档 xxx-sources.jar源码java文件\n编写配置文件 为了编写时有一些提示、自动生成些配置信息:\n 方式一:增加sts插件\n可以给eclipse增加支持spring的插件: spring tool suite\n下载springsource-tool-suite-3.9.4. RELEASE-e4.7.3a-updatesite.zip,然后在Eclipse中安装: Help- Instal\n 方式二:\n直接下载sts工具(相当于一个Eclipse) : 下载地址\n  新建: bean configuration ..\n文件名：applicationContext.xml\n开发Spring程序(IOC) package org.ycit.entity; public class Student { private int stuNo; private String stuName; private int stuAge; public Student() { } public Student(int stuNo, String stuName, int stuAge) { this.stuNo = stuNo; this.stuName = stuName; this.stuAge = stuAge; } public int getStuNo() { return stuNo; } public void setStuNo(int stuNo) { this.stuNo = stuNo; } public String getStuName() { return stuName; } public void setStuName(String stuName) { this.stuName = stuName; } public int getStuAge() { return stuAge; } public void setStuAge(int stuAge) { this.stuAge = stuAge; } @Override public String toString() { // TODO Auto-generated method stub return this.stuNo+\u0026quot;-\u0026quot;+this.getStuName()+\u0026quot;-\u0026quot;+this.getStuAge(); } }  \t\u0026lt;!-- 该文件创建的所有的对象，被spring放入了一个称之为spring ioc容器的地方 --\u0026gt; \u0026lt;!-- id唯一标识符 class：指定类型 property：代表该类 的属性 --\u0026gt; \u0026lt;bean id=\u0026quot;student\u0026quot; class=\u0026quot;org.ycit.entity.Student\u0026quot;\u0026gt; \u0026lt;!--name 属性名，value：属性值--\u0026gt; \u0026lt;property name=\u0026quot;stuNo\u0026quot; value=\u0026quot;11\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;stuName\u0026quot; value=\u0026quot;zs\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;stuAge\u0026quot; value=\u0026quot;11\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  ApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;applicationContext.xml\u0026quot;); Student student = (Student)context.getBean(\u0026quot;student\u0026quot;);  可以发现，springioc容器 帮我们new了对象，并且给对象赋了值\nSpringIOC发展史：  new\nStudent student = new Student(); student.setXxx();  此种方法创建对象new非常零散，造成后期维护较为麻烦\n 简单工厂\n将new全部放到一个工厂（类）中，根据参数的类型决定返回值\n通过简单工厂可以将new集中起来操作，方便后期的维护\n ioc （超级工厂）\nSpringIOC容器帮我们解决了工厂的问题，可以存放任何对象\n  IOc (控制反转)也可以称之为DI (依赖注入) :\n反转的是获取对象的方式由通过自己new产生对象的方式变成直接从springioc容器中获取（applicationContext）getBean()的方式\n控制反转:将创建对象、属性值的方式进行了翻转，从new、setXxx()翻转为了从springIOC容器getBean ()\n为了更加清晰地理解ioc，ioc在spring一次大会上更名为DI（依赖注入）\n依赖注入:将属性值注入给了属性，将属性注入给了bean, 将bean注入给了ioc容器;\n总结：ioc/di ，无论要什么对象，都可以直接去springioc容器中获取，而不需要自己操作（new\\setXxx()）\n因此之后的ioc分为2步：\n 先给springioc中存放对象并赋值 拿  DI:依赖注入\n依赖：B类中有A类地对象，B类中A类地对象依赖A类\n类的右上角有s标志，标志着这个类被纳入到了ioc容器中了\nIOC容器赋值：\n如果是简单类型（8个基本+String），value\n如果是对象类型，ref=\u0026quot;需要引用的id值\u0026quot;，因此实现了 对象与对象之间的依赖关系，通过conext.getBean(需要获取的bean的id值)获取对象\n依赖注入3种方式：  set注入：通过setXxx()赋值\n赋值，默认使用的是 set方法();\n依赖注入底层是通过反射实现的。\n\u0026lt;bean id=\u0026quot;student\u0026quot; class=\u0026quot;org.ycit.entity.Student\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;stuNo\u0026quot; value=\u0026quot;11\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;stuName\u0026quot; value=\u0026quot;zs\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;stuAge\u0026quot; value=\u0026quot;11\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  构造器注入：通过构造方法赋值\n\u0026lt;bean id=\u0026quot;teacher\u0026quot; class=\u0026quot;org.ycit.entity.Teacher\u0026quot;\u0026gt; \u0026lt;!-- 通过构造方法赋值 顺序严格一致 不一致可以使用index属性指定参数的顺序 (从0开始) 可以使用属性name指定参数的名字--\u0026gt; \u0026lt;constructor-arg value=\u0026quot;ls\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg value=\u0026quot;22\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt;  \u0026lt;!--index从0开始--\u0026gt; \u0026lt;constructor-arg value=\u0026quot;ls\u0026quot; index=\u0026quot;1\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg value=\u0026quot;22\u0026quot; index=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt;  \u0026lt;!--通过name指定参数名--\u0026gt; \u0026lt;constructor-arg value=\u0026quot;ls\u0026quot; name=\u0026quot;name\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg value=\u0026quot;22\u0026quot; name=\u0026quot;age\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt;  \u0026lt;!--type--\u0026gt; \u0026lt;constructor-arg value=\u0026quot;ls\u0026quot; type=\u0026quot;String\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg value=\u0026quot;22\u0026quot; type=\u0026quot;int\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt;  这几种方式也可以同时使用\n需要注意：如果 \u0026lt;constructor-arg\u0026gt;的顺序 与构造方法参数的顺序不一致，则需要通过type或者index或name指定。\n p命名空间注入\n引入p命名空间\nxmlns:p=\u0026quot;http://www.springframework.org/schema/p\u0026quot;  使用\n\u0026lt;bean id=\u0026quot;teacher\u0026quot; class=\u0026quot;org.ycit.entity.Teacher\u0026quot; p:age=\u0026quot;25\u0026quot; p:name=\u0026quot;zs\u0026quot;\u0026gt; \u0026lt;/bean\u0026gt;  简单类型：\np:属性名=\u0026quot;属性值\u0026quot;  引用类型（除了String外）：\np:属性名-ref=\u0026quot;引用的id\u0026quot;  注意多个 p赋值的时候 要有空格,顺序无所谓。\n  注意：\n无论是String还是Int/short/long，在赋值时都是\nvalue=\u0026quot;值\u0026quot;  因此建议 此种情况 需要配合 name\\type进行区分\n注入各种集合数据类型: List Set map properties\nprivate List\u0026lt;String\u0026gt; list; private String[] array; private Set\u0026lt;String\u0026gt; set; private Map\u0026lt;String,String\u0026gt; map; private Properties props;  \u0026lt;bean id=\u0026quot;collectionDemo\u0026quot; class=\u0026quot;org.ycit.entity.AllCollectionType\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;list\u0026quot;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;足球\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;篮球\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;乒乓球\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;array\u0026quot;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;asd\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;sdf\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;asdf\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;set\u0026quot;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;asd2\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;sdf3\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;asdf4\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;map\u0026quot;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry\u0026gt; \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;aa\u0026lt;/value\u0026gt; \u0026lt;/key\u0026gt; \u0026lt;value\u0026gt;aa\u0026lt;/value\u0026gt; \u0026lt;/entry\u0026gt; \u0026lt;entry\u0026gt; \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;bb\u0026lt;/value\u0026gt; \u0026lt;/key\u0026gt; \u0026lt;value\u0026gt;bb\u0026lt;/value\u0026gt; \u0026lt;/entry\u0026gt; \u0026lt;entry\u0026gt; \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;cc\u0026lt;/value\u0026gt; \u0026lt;/key\u0026gt; \u0026lt;value\u0026gt;cc\u0026lt;/value\u0026gt; \u0026lt;/entry\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;props\u0026quot;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026quot;a4\u0026quot;\u0026gt;a4\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026quot;b4\u0026quot;\u0026gt;b4\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026quot;c4\u0026quot;\u0026gt;c4\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026quot;d4\u0026quot;\u0026gt;d4\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  set、list、数组 ;各自都有自己的标签\u0026lt;set\u0026gt; \u0026lt;list\u0026gt; \u0026lt;array\u0026gt;，但是也可以混着用,不建议使用\n注意：\n \u0026lt;bean id=\u0026quot;student\u0026quot; class=\u0026quot;org.ycit.entity.Student\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;stuNo\u0026quot; value=\u0026quot;11\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  与\n \u0026lt;bean id=\u0026quot;student\u0026quot; class=\u0026quot;org.ycit.entity.Student\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;stuNo\u0026quot;\u0026gt; \u0026lt;value\u0026gt;11\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;stuName\u0026quot;\u0026gt; \u0026lt;value\u0026gt;1\u0026lt;![CDATA[\u0026gt;\u0026lt;#$%\u0026gt;]]\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;stuName\u0026quot;\u0026gt; \u0026lt;value type=\u0026quot;java.lang.String\u0026quot;\u0026gt;zsss\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  两种方式的异同\n给对象类型\n赋值null：\n\u0026lt;property name=\u0026quot;name\u0026quot; \u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/property\u0026gt;  赋空值 \u0026quot;\u0026quot;\n\u0026lt;property name=\u0026quot;name\u0026quot; \u0026gt; \u0026lt;value\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt;  在ioc中定义bean的前提：该bean的类 必须提供了 无参构造\n自动装配（只适用于 ref类型 ）： 约定优于配置\n自动装配：\n\u0026lt;bean ... class=\u0026quot;org.lanqiao.entity.Course\u0026quot; autowire=\u0026quot;byName|byType|constructor|no\u0026quot; \u0026gt;  autowire=\u0026quot;byName\u0026quot;Course类中有一个ref属性teracher（属性名），并且该ioc容器中恰好有一个bean的id也是teacher。bean的id值=类的属性名，则会自动装配\nbyName本质是byId\n byName: 自动寻找：其他bean的id值=该Course类的属性名\n byType: 其他bean的类型(class) 是否与 该Course类的ref属性类型一致 （注意，此种方式 必须满足：当前Ioc容器中 只能有一个Bean满足条件 ）\n constructor： 其他bean的类型(class) 是否与 该Course类的构造方法参数 的类型一致；此种方式的本质就是byType\n no不使用\n  可以在头文件中 一次性将该ioc容器的所有bean 统一设置成自动装配：\n\u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; ... default-autowire=\u0026quot;byName\u0026quot;\u0026gt;  自动装配虽然可以减少代码量，但是会降低程序的可读性，使用时需要谨慎。子标签可以覆盖全局性，子标签可以进行覆盖设置\n使用注解定义bean： 通过注解的形式 将bean以及相应的属性值 放入ioc容器\n配置扫描器 \u0026lt;context:component-scan base-package=\u0026quot;org.lanqiao.dao,xxx\u0026quot;\u0026gt; \u0026lt;/context:component-scan\u0026gt;  多个包之间通过,分隔\nSpring在启动的时候，会根据base-package在 该包中扫描所有类，查找这些类是否有注解@Component或其他注解(\u0026ldquo;studentDao\u0026rdquo;),如果有，则将该类 加入spring Ioc容器。\n添加注解 //id为Component中设置的studentDao @Component(\u0026quot;studentDao\u0026quot;) public class StudentDaoImpl { public void addStudent(Student student) { System.out.println(\u0026quot;增加学生\u0026quot;); } }  @Component细化：\ndao层注解： @Repository service层注解： @Service 控制器层注解： @Controller  使用注解实现事务 使用注解实现事务（声明式事务）\n目标：通过事务 使以下方法 要么全成功、要么全失败\npublic void addStudent() { //增加班级 //增加学生 //crdu }  jar包 spring-tx-4.3.9.RELEASE.jar ojdbc.jar commons-dbcp.jar 连接池使用到数据源 commons-pool.jar 连接池 spring-jdbc-4.3.9.RELEASE.jar aopalliance.jar  配置 jdbc\\mybatis\\spring\n增加事务tx的命名空间\nxmlns:tx=\u0026quot;http://www.springframework.org/schema/tx\u0026quot;  增加对事务的支持\n\u0026lt;!-- 增加对事务的支持 --\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026quot;txManager\u0026quot; /\u0026gt;  配置事务管理器\n\u0026lt;!-- 配置事务管理器txManager --\u0026gt; \u0026lt;bean id = \u0026quot;txManager\u0026quot; class=\u0026quot;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  配置数据库相关的事务\n\u0026lt;!-- 配置数据库相关的事务 --\u0026gt; \u0026lt;bean id=\u0026quot;dataSource\u0026quot; class=\u0026quot;org.apache.commons.dbcp.BasicDataSource\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driverClassName\u0026quot; value=\u0026quot;oracle.jdbc.OracleDriver\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;jdbc:oracle:thin:@localhost:1521:MyOracleDB\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;scott\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;135451\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;maxActive\u0026quot; value=\u0026quot;10\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;maxIdle\u0026quot; value=\u0026quot;6\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  使用 将需要 成为事务的方法 前增加注解：\n@Transactional(readOnly = false,propagation = Propagation.REQUIRED) public void addStudent(Student student) { //if(该学生是否存在) //其他的判定条件 studentDao.addStudent(student); }  Propagation （事务的传播属性） Propagationkey属性确定代理应该给哪个方法增加事务行为。这样的属性最重要的部份是传播行为。有以下选项可供使用：PROPAGATION_REQUIRED\u0026ndash;支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。\nPROPAGATION_SUPPORTS\u0026ndash;支持当前事务，如果当前没有事务，就以非事务方式执行。\nPROPAGATION_MANDATORY\u0026ndash;支持当前事务，如果当前没有事务，就抛出异常。\nPROPAGATION_REQUIRES_NEW\u0026ndash;新建事务，如果当前存在事务，把当前事务挂起。\nPROPAGATION_NOT_SUPPORTED\u0026ndash;以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\nPROPAGATION_NEVER\u0026ndash;以非事务方式执行，如果当前存在事务，则抛出异常。\n PROPAGATION_REQUIRED\n加入当前正要执行的事务不在另外一个事务里，那么就起一个新的事务\n比如说，ServiceB.methodB的事务级别定义为PROPAGATION_REQUIRED, 那么由于执行ServiceA.methodA的时候，ServiceA.methodA已经起了事务，这时调用ServiceB.methodB，ServiceB.methodB看到自己已经运行在ServiceA.methodA 的事务内部，就不再起新的事务。\n而假如ServiceA.methodA运行的时候发现自己没有在事务中，他就会为自己分配一个事务。这样，在ServiceA.methodA或者在ServiceB.methodB内的任何地方出现异常，事务都会被回滚。即使ServiceB.methodB的事务已经被提交，但是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚\n PROPAGATION_SUPPORTS\n如果当前在事务中，即以事务的形式运行，如果当前不再一个事务中，那么就以非事务的形式运行\n PROPAGATION_MANDATORY\n必须在一个事务中运行。也就是说，他只能被一个父事务调用。否则，他就要抛出异常\n PROPAGATION_REQUIRES_NEW\n这个就比较绕口了。 比如我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW， 那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的事务，等待ServiceB.methodB的事务完成以后，他才继续执行。他与PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为ServiceB.methodB是新起一个事务，那么就是存在两个不同的事务。如果ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚，ServiceB.methodB是不会回滚的。如果ServiceB.methodB失败回滚， 如果他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交。\n PROPAGATION_NOT_SUPPORTED\n当前不支持事务。比如ServiceA.methodA的事务级别是PROPAGATION_REQUIRED ，ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ， 那么当执行到ServiceB.methodB时，ServiceA.methodA的事务挂起，而他以非事务的状态运行完，再继续ServiceA.methodA的事务。 6.PROPAGATION_NEVER\n不能在事务中运行。假设ServiceA.methodA的事务级别是PROPAGATION_REQUIRED， 而ServiceB.methodB的事务级别是PROPAGATION_NEVER ，那么ServiceB.methodB就要抛出异常了。\n PROPAGATION_NESTED\n理解Nested的关键是savepoint。他与PROPAGATION_REQUIRES_NEW的区别是，PROPAGATION_REQUIRES_NEW另起一个事务，将会与他的父事务相互独立，而Nested的事务和他的父事务是相依的，他的提交是要等和他的父事务一块提交的。也就是说，如果父事务最后回滚，他也要回滚的。而Nested事务的好处是他有一个savepoint。\nServiceA { /** * 事务属性配置为 PROPAGATION_REQUIRED */ void methodA() { try { //savepoint ServiceB.methodB(); //PROPAGATION_NESTED 级别 } catch (SomeException) { // 执行其他业务, 如 ServiceC.methodC(); } } }  也就是说ServiceB.methodB失败回滚，那么ServiceA.methodA也会回滚到savepoint点上，ServiceA.methodA可以选择另外一个分支，比如 ServiceC.methodC，继续执行，来尝试完成自己的事务。 但是这个事务并没有在EJB标准中定义。\n  Spring事务的隔离级别  ISOLATION_DEFAULT：\n这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应\n ISOLATION_READ_UNCOMMITTED：\n这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。\n ISOLATION_READ_COMMITTED：\n保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据\n ISOLATION_REPEATABLE_READ：\n这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。\n ISOLATION_SERIALIZABLE\n这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。\n  什么是脏数据，脏读，不可重复读，幻觉读？\n脏读: 指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。\n不可重复读: 指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。\n幻觉读: 指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。\nAOP：面向方面编程 git源码\n一个普通的类\u0026mdash;-\u0026gt;有特定功能的类\na.继承类 b.实现接口 c.注解 d.配置  类 -\u0026gt; “通知” ：实现接口\nxml方式的通知类型 通知类型\t需要实现的接口\t接口中的方法\t执行时机 前置通知\torg-springframework\tbefore()\t目标方法执行前。 .aop.MethodBeforeAdvice 后置通知\torg-springframework\tafterRetuming()\t目标方法执行后。 .aop.AfterReturningAdvice 异常通知\torg.-springframework\t无\t目标方法发生异常时 .aop.ThrowsAdvice 环绕通知\torg.aopalliance.intercept\tinvoke()\t拦截对目标方法调 .MethodInterceptor\t用，即调用目标方法的整  前置通知实现步骤： jar aopaliance.jar aspectjweaver.jar  配置 增加命名空间\nxmlns:aop=\u0026quot;http://www.springframework.org/schema/aop\u0026quot;  将两个类放入ioc容器\n\u0026lt;bean id=\u0026quot;studentServiceImpl\u0026quot; class=\u0026quot;org.ycit.service.impl.StudentServiceImpl\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;studentDao\u0026quot; ref=\u0026quot;StudentDaoImpl\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--通知所在类--\u0026gt; \u0026lt;bean id=\u0026quot;logBefore\u0026quot; class = \u0026quot;org.ycit.aop.LogBefore\u0026quot;\u0026gt; \u0026lt;/bean\u0026gt;  将二者进行关联\n\u0026lt;!-- 关联两个类 --\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--配置切入点（在哪里执行通知） --\u0026gt; \u0026lt;!-- 如果想要在多个方法执行之前 执行同一个函数则execution(aa())orexecution(bb()) --\u0026gt; \u0026lt;aop:pointcut expression=\u0026quot;execution(public void org.ycit.service.impl.StudentServiceImpl.addStudent(org.ycit.entity.Student))\u0026quot; id=\u0026quot;poioncut\u0026quot;/\u0026gt;\t\u0026lt;!--advisor：相当于连接切入点和切面的线 --\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026quot;logBefore\u0026quot; pointcut-ref=\u0026quot;poioncut\u0026quot;/\u0026gt; \u0026lt;/aop:config\u0026gt;  注意此时的全类名\n如果想在多个方法执行前执行该方法则\nexecution() or execution()  测试\npublic static void testAop() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;applicationContext.xml\u0026quot;); IsStudentService student = (IsStudentService)context.getBean(\u0026quot;studentServiceImpl\u0026quot;); Student student = new Student(); studen.addStudent(student1); }  如果出现异常：类似\njava.lang.NoClassDefFoundError: org/apache/commons/pool/impl/GenericObjectPool  则说明缺少jar\n编写 aop：每当之前add()之前 自动执行一个方法log();\naddStudent(); 业务方法（IStudentService.java中的 addStudent()）\npublic interface IsStudentService { void addStudent(Student studnet); }  log()\npublic class LogBefore implements MethodBeforeAdvice{ //前置通知的具体内容 @Override public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(\u0026quot;before....\u0026quot;); //target 对象 method 方法 args输入参数 } }  before(); 自动执行的通知，即aop前置通知  public class Xxx { @Test a(){} }\n后置通知： 通知类 ，普通实现接口\npublic class LogAfter implements AfterReturningAdvice{ @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\u0026quot;**********后置通知：目标对象：\u0026quot;+target+\u0026quot;,调用的方法名：\u0026quot;+method.getName()+\u0026quot;,方法的参数个数：\u0026quot;+args.length+\u0026quot;，方法的返回值：\u0026quot;+returnValue); } }  目标对象：+target+ 调用的方法名：method.getName() 方法的参数个数：args.length 方法的返回值:returnValue  业务类、业务方法\npublic interface IsStudentService { void addStudent(Student studnet); }  配置：\n将业务类、通知 纳入springIOC容器\n定义切入点（一端）、定义通知类（另一端），通过pointcut-ref将两端连接起来\n\u0026lt;!-- 将通知纳入springIOC容器 --\u0026gt; \u0026lt;bean id=\u0026quot;logAfter\u0026quot; class=\u0026quot;org.lanqiao.aop.LogAfter\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!-- 切入点（连接线的一端：业务类的具体方法） --\u0026gt; \u0026lt;aop:pointcut expression=\u0026quot;execution(public * org.lanqiao.service.impl.StudentServiceImpl.addStudent(..))\u0026quot; id=\u0026quot;poioncut2\u0026quot;/\u0026gt; \u0026lt;!-- （连接线的另一端：通知 类） --\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026quot;logAfter\u0026quot; pointcut-ref=\u0026quot;poioncut2\u0026quot; /\u0026gt; \u0026lt;/aop:config\u0026gt;  异常通知： 通知类\npublic class LogException implements ThrowsAdvice { //异常通知的具体方法 public void afterThrowing(Method method, Object[] args ,Object target, NullPointerException ex)//只捕获NullPointerException类型的异常 { System.out.println(\u0026quot;00000000000异常通知：目标对象:\u0026quot;+target+\u0026quot;,方法名：\u0026quot;+method.getName()+\u0026quot;,方法的参数个数：\u0026quot;+args.length+\u0026quot;,异常类型:\u0026quot;+ex.getMessage()); } }  目标对象:target 方法名：method.getName() 方法的参数个数：args.length 异常类型:ex.getMessage()  根据异常通知接口的定义可以发现，异常通知的实现类 必须编写以下方法：\npublic void afterThrowing([Method, args, target], ThrowableSubclass)：  a.public void afterThrowing(Method, args, target, ThrowableSubclass) b.public void afterThrowing(ThrowableSubclass)  配置\n\u0026lt;bean id=\u0026quot;logException\u0026quot; class=\u0026quot;org.lanqiao.aop.LogException\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!-- 切入点（连接线的一端：业务类的具体方法） --\u0026gt; \u0026lt;aop:pointcut expression=\u0026quot;execution(public * org.lanqiao.service.impl.StudentServiceImpl.addStudent(..))\u0026quot; id=\u0026quot;poioncut3\u0026quot;/\u0026gt; \u0026lt;!-- （连接线的另一端：通知 类） --\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026quot;logException\u0026quot; pointcut-ref=\u0026quot;poioncut3\u0026quot; /\u0026gt; \u0026lt;/aop:config\u0026gt;  环绕通知: 在目标方法的前后、异常发生时、最终等各个地方都可以 进行的通知，最强大的一个通知；\n可以获取目标方法的 全部控制权（目标方法是否执行、执行之前、执行之后、参数、返回值等）\n在使用环绕通知时，目标方法的一切信息 都可以通过invocation参数获取到\n环绕通知 底层是通过拦截器实现的。\n通知类 public class LogAround implements MethodInterceptor{ @Override public Object invoke(MethodInvocation invocation) throws Throwable { Object result = null ; //方法体1... try { //方法体2... System.out.println(\u0026quot;用环绕通知实现的[前置通知]...\u0026quot;); // invocation.proceed() 之前的代码：前置通知 result = invocation.proceed() ;//控制着目标方法的执行 ，addStudent() //result 就是目标方法addStudent()方法的返回值 //\tinvocation.proceed() 之后的代码：后置通知 System.out.println(\u0026quot;用环绕通知实现的[后置通知]...:\u0026quot;); System.out.println(\u0026quot;-----------------目标对象target\u0026quot;+invocation.getThis()+\u0026quot;,调用的方法名：\u0026quot;+invocation.getMethod().getName()+\u0026quot;,方法的参数个数：\u0026quot;+invocation.getArguments().length+\u0026quot;,返回值：\u0026quot;+result); }catch(Exception e) { //方法体3... //异常通知 System.out.println(\u0026quot;用环绕通知实现的[异常通知]...\u0026quot;); } return result;//目标方法的返回值 } }  配置 \u0026lt;!-- 将环绕通知加入ioc容器 \u0026lt;bean id=\u0026quot;logAround\u0026quot; class=\u0026quot;org.lanqiao.aop.LogAround\u0026quot;\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 切入点（连接线的一端：业务类的具体方法）--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut expression=\u0026quot;execution(public * org.lanqiao.service.impl.StudentServiceImpl.addStudent(..))\u0026quot; id=\u0026quot;poioncut4\u0026quot;/\u0026gt; \u0026lt;!-- （连接线的另一端：通知 类） \u0026lt;aop:advisor advice-ref=\u0026quot;logAround\u0026quot; pointcut-ref=\u0026quot;poioncut4\u0026quot; /\u0026gt; \u0026lt;/aop:config\u0026gt; --\u0026gt;  实现注解实现 通知 ,aop jar 与 实现接口 的方式相同\n配置 将业务类、通知 纳入springIOC容器\n开启注解对AOP的支持\n\u0026lt;aop:aspectj-autoproxy\u0026gt;\u0026lt;/aop:aspectj-autoproxy\u0026gt; \u0026lt;!-- 配置扫描器 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;org.lanqiao.dao\u0026quot;\u0026gt;  编写 通知：\n//@Component(\u0026quot;logAnnotation\u0026quot;) //将LogAspectAnnotation纳入springIOC容器中 @Aspect //此类是一个通知 public class LogAspectAnnotation { //前置通知 @Before(\u0026quot;execution(public * addStudent(..))\u0026quot;) //属性：定义切点 public void myBefore(JoinPoint jp) { System.out.println(\u0026quot;《注解形式-前置通知》：目标对象：\u0026quot;+jp.getTarget()+\u0026quot;,方法名：\u0026quot;+jp.getSignature().getName() +\u0026quot;,参数列表：\u0026quot;+ jp.getArgs().length ); } //后置通知 @AfterReturning( pointcut= \u0026quot;execution(public * addStudent(..))\u0026quot; ,returning=\u0026quot;returningValue\u0026quot; ) public void myAfter(JoinPoint jp,Object returningValue) {//returningValue是返回值，但需要告诉spring System.out.println(\u0026quot;《注解形式-后置通知》：目标对象：\u0026quot;+jp.getTarget()+\u0026quot;,方法名：\u0026quot;+jp.getSignature().getName() +\u0026quot;,参数列表：\u0026quot;+ jp.getArgs().length+\u0026quot;,返回值：\u0026quot;+returningValue ); } /*环绕通知 ,参数ProceedingJoinPoint @Around(\u0026quot;execution(public * addStudent(..))\u0026quot;) public void myAround(ProceedingJoinPoint jp ) { //方法之前：前置通知 System.out.println(\u0026quot;《【环绕】方法之前：前置通知\u0026quot;); try { //方法执行时 jp.proceed() ;//执行方法 //方法之前之后：后置通知 System.out.println(\u0026quot;《【环绕】方法之前之后：后置通知\u0026quot;); }catch(Throwable e) { //发生异常时：异常通知 System.out.println(\u0026quot;《【环绕】发生异常时：异常通知\u0026quot;); }finally { //最终通知 System.out.println(\u0026quot;《【环绕】最终通知\u0026quot;); } }*/ //异常通知:如果只捕获特定类型的已存银行，则可以通过第二个参数实现：e @AfterThrowing(pointcut= \u0026quot;execution(public * addStudent(..))\u0026quot;,throwing=\u0026quot;e\u0026quot;) public void myException(JoinPoint pj, NullPointerException e) {//此异常通知 只会捕获NullPointerException类型的异常 System.out.println(\u0026quot;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;《注解形式-异常通知》----e:\u0026quot;+e.getMessage()); } //最终通知 @After(\u0026quot;execution(public * addStudent(..))\u0026quot;) public void myAfter() { System.out.println(\u0026quot;《[myAfter]注解形式-最终通知-----通知》----\u0026quot;); } }  注意：通过注解形式 将对象增加到 ioc容器时，需要设置 扫描器\n\u0026lt;context:component-scan base-package=\u0026quot;org.lanqiao.aop\u0026quot;\u0026gt;\u0026lt;/context:component-scan\u0026gt;  扫描器 会将 指定的包 中的 @Componet @Service @Respository @Controller修饰的类产生的对象 增加到IOC容器中\n@Aspect不需要 加入扫描器，只需要开启即可：\n\u0026lt;aop:aspectj-autoproxy\u0026gt;\u0026lt;/aop:aspectj-autoproxy\u0026gt;  通过注解形式 实现的aop，如果想获取 目标对象的一些参数，则需要使用一个对象：JointPoint\n注解形式的返回值：\n 声明返回值 的参数名：\n@AfterReturning( pointcut= \u0026quot;execution(public * addStudent(..))\u0026quot; ,returning=\u0026quot;returningValue\u0026quot; )   注解形式实现aop时，通知的方法的参数不能多、少\npublic void myAfter(JoinPoint jp,Object returningValue) {//returningValue是返回值，但需要告诉spring System.out.println(\u0026quot;返回值：\u0026quot;+returningValue );  实现接口形式、注解形式 只捕获声明的特定类型的异常，而其他类型异常不捕获。 cath()\n通过 配置将 类-\u0026gt;通知 基于Schema配置\n类似 与 实现接口的方式\n接口方式通知：\npublic class LogAfter implements AfterReturningAdvice  Schema方式通知：\n 编写一个普通类 public class LogAfter {}\n 将该类 通过配置，转为一个“通知”\n编写普通类 public class LogSchema { //后置通知方法 :JoinPoint适用于注解 public void afterReturning(JoinPoint jp,Object returnValue) throws Throwable { System.out.println(\u0026quot;》》》》》》》》》》》后置通知：目标对象：\u0026quot;+jp.getThis()+\u0026quot;,调用的方法名：\u0026quot;+jp.getSignature().getName()+\u0026quot;,方法的参数个数：\u0026quot;+jp.getArgs().length+\u0026quot;，方法的返回值：\u0026quot;+returnValue); } public void before() { System.out.println(\u0026quot;》》》》》》》》》》》前置通知...\u0026quot;); } public void whenException(JoinPoint jp,NullPointerException e) { System.out.println(\u0026quot;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;异常：\u0026quot; +e.getMessage()); } //注意：环绕通知 会返回目标方法的返回值，因此返回值为Object public Object around(ProceedingJoinPoint jp) { System.out.println(\u0026quot;''''''''''''''''''环绕通知：前置通知\u0026quot;); Object result = null ; try { result = jp.proceed() ;//执行方法 System.out.println(\u0026quot;'''''''''\u0026quot;+jp.getSignature().getName()+\u0026quot;,\u0026quot;+result); System.out.println(\u0026quot;''''''''''''''''''环绕通知：后置通知\u0026quot;); }catch(Throwable e) { System.out.println(\u0026quot;''''''''''''''''''环绕通知：异常通知\u0026quot;); } return result ; } }   配置 \u0026lt;!-- 将准备转为 通知的类 纳入ioc容器 --\u0026gt; \u0026lt;bean id=\u0026quot;logSchema\u0026quot; class=\u0026quot;org.lanqiao.aop.LogSchema\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!-- 切入点（连接线的一端：业务类的具体方法） --\u0026gt; \u0026lt;aop:pointcut expression=\u0026quot;execution(public * org.lanqiao.service.impl.StudentServiceImpl.addStudent(..))\u0026quot; id=\u0026quot;pcShema\u0026quot;/\u0026gt; \u0026lt;!-- （连接线的另一端：通知 类 --\u0026gt; \u0026lt;!-- schema方式 --\u0026gt; \u0026lt;aop:aspect ref=\u0026quot;logSchema\u0026quot;\u0026gt; \u0026lt;!-- 连接线：连接 业务 addStudent和通知before --\u0026gt; \u0026lt;aop:before method=\u0026quot;before\u0026quot; pointcut-ref=\u0026quot;pcShema\u0026quot;/\u0026gt; \u0026lt;!-- 连接线：连接 业务 addStudent 和 通知afterReturning --\u0026gt; \u0026lt;aop:after-returning method=\u0026quot;afterReturning\u0026quot; returning=\u0026quot;returnValue\u0026quot; pointcut-ref=\u0026quot;pcShema\u0026quot;/\u0026gt; \u0026lt;!--异常--\u0026gt; \u0026lt;aop:after-throwing method=\u0026quot;whenException\u0026quot; pointcut-ref=\u0026quot;pcShema\u0026quot; throwing=\u0026quot;e\u0026quot;/\u0026gt; \u0026lt;!-- 环绕 --\u0026gt; \u0026lt;aop:around method=\u0026quot;around\u0026quot; pointcut-ref=\u0026quot;pcShema\u0026quot; /\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt;  如果要获取目标对象信息：\n注解、schema：JoinPoint\n接口：Method method, Object[] args, Object target\nschema形式 和注解形式相似，\n不同之处：\n注解形式 使用了注册@After，\nschmema形式进行了多余的配置\nSpring开发Web项目 及 拆分Spring配置文件 git源码\nSpringIoc容器初始化： 1. 将容器中的所有bean实例化为对象 2. 将各个bean依赖的属性值注入进去\n在普通Java程序中\nApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;applicationContext.xml\u0026quot;);  时初始化\nJava冲虚的入口是统一的main()，因此只需要在main中实例化一次applicationContext.xml就可以实现Ioc容器初始化操作\nSpring开发Web项目 Web项目如何初始化SpringIOC容器 ：\n思路：当服务启动时（tomcat），通过监听器将SpringIOC容器初始化一次（该监听器 spring-web.jar已经提供）\n因此用spring开发web项目 至少需要7个jar： spring-java的6个jar + spring-web.jar，\n注意：web项目的jar包 是存入到WEB-INF/lib中\nweb项目启动时 ，会自动加载web.xml，因此需要在web.xml中加载 监听器（ioc容器初始化）。\nWeb项目启动时，启动实例化Ioc容器：\n \u0026lt;!-- 指定 Ioc容器（applicationContext.xml）的位置--\u0026gt; \u0026lt;context-param\u0026gt; \u0026lt;!-- 监听器的父类ContextLoader中有一个属性contextConfigLocation，该属性值 保存着 容器配置文件applicationContext.xml的位置 --\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;!-- 配置spring-web.jar提供的监听器，此监听器 可以在服务器启动时 初始化Ioc容器。 初始化Ioc容器（applicationContext.xml） ， 1.告诉监听器 此容器的位置：context-param 2.默认约定的位置\t:WEB-INF/applicationContext.xml --\u0026gt; \u0026lt;listener-class\u0026gt;org.springframework.web.context.ContextLoaderListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt;  初始化Ioc容器（applicationContext.xml）两种方式\n 告诉监听器 此容器的位置：context-param 默认约定的位置:WEB-INFapplicationContext.xml  拆分Spring配置文件 java项目：\napplicationContext1.xml applicationContext2.xml applicationContext3.xml ApplicationContext conext = new ClassPathXmlApplicationContext(\u0026quot;applicationContext3.xml\u0026quot;) ;  Web项目：\n根据什么拆分？\n 三层结构\nUI(html/css/jsp 、Servlet) applicationController.xml Service :applicationService.xml Dao:applicationDao.xml 公共 数据库:applicationDB.xml  功能结构\n学生相关配置\napplicationContextStudent.xml \u0026lt;bean id=\u0026quot;\u0026quot; class=\u0026quot;X...Student\u0026quot;\u0026gt;  班级相关配置\napplicationContextClass.xml   合并：如何将多个配置文件 加载 * 方式1  \u0026lt;context-param\u0026gt; \u0026lt;!-- 监听器的父类ContextLoader中有一个属性contextConfigLocation，该属性值 保存着 容器配置文件applicationContext.xml的位置 --\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt; classpath:applicationContext.xml, classpath:applicationContext-Dao.xml, classpath:applicationContext-Service.xml, classpath:applicationContext-Controller.xml \u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \n 方式二（推荐）\n\u0026lt;context-param\u0026gt; \u0026lt;!-- 监听器的父类ContextLoader中有一个属性contextConfigLocation，该属性值 保存着 容器配置文件applicationContext.xml的位置 --\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt; classpath:applicationContext.xml, classpath:applicationContext-*.xml \u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt;  方式三\n只在web.xml中加载主配置文件，\n\u0026lt;param-value\u0026gt; classpath:applicationContext.xml \u0026lt;/param-value\u0026gt;  然后在主配置问加中，加载其他配置文件\n\u0026lt;import resource=\u0026quot;applicationContext-*.xml\u0026quot;/\u0026gt;  bean的实例化、DI是在保存在Spring IOC容器中的\n  但是每一次request是请求Servlet容器，因此需要在二者间创建一个桥梁\n注解形式依赖注入 //\u0026lt;bean id=\u0026quot;studentService\u0026quot; class=\u0026quot;org.ycit.service.impl.StudentServiceImpl\u0026quot;\u0026gt; //@Service(\u0026quot;studentService\u0026quot;) public class StudentServiceImpl implements IsStudnetService{  属性赋值 @Autowired//自动装配，byType private StudentMapper studentMapper;  配置扫描包\n \u0026lt;context:component-scan base-package=\u0026quot;org.ycit.service.impl\u0026quot;\u0026gt;\u0026lt;/context:component-scan\u0026gt;  注解形式\n@Autowired 自动装配，byType @Autowired @Qualifier(\u0026quot;xxx\u0026quot;) 自动装配，byName（byID），二者同时使用  SpringIOC容器 git源码\nSpring IoC容器？\n2种形式：\n xml配置文件：\napplicationContext.xml\n存bean:\n\u0026lt;bean id class\u0026gt;  取bean:\nApplicationContext context= new ClassPathXmlApplicationContext(\u0026quot;applicationContext.xml\u0026quot;); context.getBean();  注解：\n存bean、\n带有@Configuration注解的类（配置类）\n//配置类 @Configuration public class MyConfig { @Bean(value=\u0026quot;stu\u0026quot;) //id=\u0026quot;stu\u0026quot; class=\u0026quot;...Student\u0026quot; public Student myStudent( Address address){ Student student = new Student(10,\u0026quot;zs10\u0026quot;,23); return student; } }  取bean\nApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class) ; context.getBean();   注意：两种形式获取的Ioc容器是 独立的\nIOC作用\n 存bean\n 取bean\n  XXX:注解形式 给IoC容器中存放Bean：\n 必须有@Configuration注解（配置类）\n 形式：\n三层组件加入IOC容器： 给个各类加注解 、 扫描器识别注解所在包\n 给三层组件 分别加注解（@Controller、@Service、@Repository -\u0026gt; @Component）\n 将注解所在包 纳入ioc扫描器（ComponentScan）\n纳入ioc扫描器:\n xml配置文件 :\n\u0026lt;context:component-scan base-package=\u0026quot;com.lx.controller\u0026quot;\u0026gt;\u0026lt;/context:component-scan\u0026gt;  逻辑： 在三层类上加注解 ，让ioc识别，扫描器\n会将配置类也纳入IOC容器中，id值为类名的首字母小写\n 注解扫描器\n@Configuration @ComponentScan(value=\u0026quot;com.lx\u0026quot;) public class MyConfig { }  component-scan：只对三层组件负责\n    给扫描器指定规则： 三层组件 @ComponentScan只负责三层组件\n过滤类型：FilterType(ANNOTATION，ASSIGNABLE_TYPE，CUSTOM)\nANNOTATION ANNOTATION：三层注解类型@Controller、@Service、@Repository -\u0026gt; @Component\nexcludeFilters：排除\nincludeFilters：有默认行为，可以通过useDefaultFilters = false禁止，默认就是包含所有，又重复包含了一次，因此包含无效\n//排除Service和Dao的扫描 @ComponentScan(value=\u0026quot;com.lx\u0026quot;,excludeFilters = { @ComponentScan.Filter(type= FilterType.ANNOTATION,classes ={Service.class,Repository.class})}) @ComponentScan(value=\u0026quot;com.lx\u0026quot;,includeFilters = {@ComponentScan.Filter(type= FilterType.ANNOTATION,classes ={Controller.class})},useDefaultFilters = false)  ASSIGNABLE_TYPE：具体的类 @ComponentScan(value=\u0026quot;com.yanqun\u0026quot;,excludeFilters = { @ComponentScan.Filter(type= FilterType.ASSIGNABLE_TYPE,classes ={StudentDao.class} )} )  区分:\n ANNOTATION:Controller.clss 指的是 所有标有@Controller的类\n ASSIGNABLE_TYPE：值得是具体的一个类 StudentController.class\n  CUSTOM自定义：自己定义包含规则 @ComponentScan.Filter(type= FilterType.CUSTOM ,value={MyFilter.class}  MyFilter implements TypeFilter 重写其中的match，如果return true则加入IoC容器\n//自定义筛选 public class MyFilter implements TypeFilter { @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException { AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); //获取类名 String className = annotationMetadata.getClassName();、 //只纳入含School的类 if(className.contains(\u0026quot;School\u0026quot;)) return true ; return false; } }  非三层组件 （Student.class 、IntToStringConver.class）：\n放入IOC  @Bean+方法的返回值\nid默认就是方法名（可以通过@Bean(\u0026ldquo;stu\u0026rdquo;) 修改id值）\n import 、FactoryBean\n  bean的作用域  @Bean(value=\u0026quot;stu\u0026quot;) @Scope(\u0026quot;singleton\u0026quot;) public Student myStudent(){ }   \u0026lt;bean id=\u0026quot;student\u0026quot; class=\u0026quot;com.lx.entity.Student\u0026quot; scope=\u0026quot;singleton\u0026quot; \u0026gt; \u0026lt;!--value:简单类型--\u0026gt; \u0026lt;property name=\u0026quot;stuNo\u0026quot; value=\u0026quot;1\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;stuName\u0026quot; value=\u0026quot;张三\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;stuAge\u0026quot; value=\u0026quot;23\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--ref:其他类型--\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026quot;address\u0026quot; ref=\u0026quot;myaddress\u0026quot;\u0026gt;\u0026lt;/property\u0026gt;--\u0026gt; \u0026lt;/bean\u0026gt;  scope: singleton(默认)| prototype  执行时机（产生bean的时机）：\nsingleton（单例）：容器在初始化时，就会创建对象（唯一的一个）；以后再getBean时，不再产生新的bean。singleton也支持延迟加载（懒加载）：在第一次使用时产生。 @Lazy\n @Bean(value=\u0026quot;stu\u0026quot;) @Scope(\u0026quot;singleton\u0026quot;) @Lazy public Student myStudent(){ }  prototype（原型，多例）：容器在初始化时，不创建对象；只是在每次使用时（每次从容器获取对象时 ，context.getBean(Xxxx)）,再创建对象;并且每次getBean()都会创建一个新的对象。\n单例和多例\nStudent stu1 = (Student)context.getBean(Student.class) ; Student stu2 = (Student)context.getBean(Student.class) ;  当从容器中拿去对象时，拿取得是否是同一个对象; 是：单例；不是：多例\n条件注解 Spring Boot 可以让某一个Bean 在某些条件下 加入Ioc容器，其他情况下不加IoC容器。\n准备 bean 编写类\n增加条件Bean：给每个Bean设置条件 ，必须实现Condition接口 public class OilCarCondition implements Condition { //如果当前环境是 oil，则加入 OilCar @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) { //获取环境 Environment environment = conditionContext.getEnvironment(); String carType = environment.getProperty(\u0026quot;car.type\u0026quot;);//car.type=\u0026quot;oil\u0026quot; if(carType.contains(\u0026quot;oil\u0026quot;)){ return true ; } return false; } }  public class EnergyCarCondition implements Condition { //如果当前环境是 oil，则加入 OilCar @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) { //获取环境 Environment environment = conditionContext.getEnvironment(); String carType = environment.getProperty(\u0026quot;car.type\u0026quot;);//car.type=\u0026quot;oil\u0026quot; if(carType.contains(\u0026quot;energy\u0026quot;)){ return true ; } return false; } }  根据条件，加入IoC容器  @Bean @Conditional(OilCarCondition.class) public Car oilCar() { return new OilCar() ; } @Bean @Conditional(EnergyCarCondition.class) public Car energyCar() { return new EnergyCar() ; }  添加虚拟参数idea\nrun\u0026ndash;\u0026gt;Edit Configurations\u0026hellip;\u0026ndash;\u0026gt;VM option\n-Dcar.type=oil  回顾给IoC加入Bean的方法 注解 ：全部在@Congiration配置中设置：\n三层组件： 扫描器 + 三层注解\n非三层组件：三种方式\n @Bean+返回值，在配置类中 @import FactoryBean(工厂Bean)  @import使用：  直接编写到@Import中，并且id值是全类名\n//配置类 @Configuration @Import({Apple.class,Banana.class}) @ComponentScan(value=\u0026quot;com.lx\u0026quot;) public class MyConfig {  自定义ImportSelector接口的实现类，通过selectimports方法实现（方法的返回值 就是要纳入IoC容器的Bean） 。\n并且 告知程序 自己编写的实现类。@Import({Orange.class,MyImportSelector.class})\npublic class MyImportSelector implements ImportSelector { @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) { return new String[]{\u0026quot;com.lx.entity.Apple\u0026quot;,\u0026quot;com.lx.entity.Banana\u0026quot;}; //返回值就是 要加入IOC容器的Bean的全类名 } }  @Configuration @Import({Apple.class,MyImportSelector.class}) @ComponentScan(value=\u0026quot;com.lx\u0026quot;) public class MyConfig {  编写ImportBeanDefinitionRegistrar接口的实现类，重写方法\npublic class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar { @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { // \u0026quot;com.lx.entity.Orange\u0026quot; //Class方式 // BeanDefinition beanDefinition = new RootBeanDefinition(Orange.class) ; //String方式 BeanDefinition beanDefinition = new RootBeanDefinition(\u0026quot;com.lx.entity.Orange\u0026quot;) ; registry.registerBeanDefinition(\u0026quot;myorange\u0026quot;, beanDefinition ); // id ,class } }  @Configuration @Import({MyImportBeanDefinitionRegistrar.class}) @ComponentScan(value=\u0026quot;com.lx\u0026quot;) public class MyConfig {  Import中可以同时放置这三种方法的Class\n@Import({Orange.class,MyImportSelector.class,MyImportBeanDefinitionRegistrar.class})\n  FactoryBean(工厂Bean)  准备bean。实现类和重写方法\npublic class MyFactoryBean implements FactoryBean { //放入对象 @Override public Object getObject() throws Exception { return new Apple(); } //类型 @Override public Class\u0026lt;?\u0026gt; getObjectType() { return Apple.class; //Apple } //是否是单例 @Override public boolean isSingleton() { return true; } }  注册bean。注册到@Bean中\n@Bean public FactoryBean\u0026lt;Apple\u0026gt; myFactoryBean(){ return new MyFactoryBean();//到底是什么？MyFactoryBean 、Apple ？ }  通过@Bean放入容器中得对象应该是myFactoryBean，而myFactoryBean中又是放入了Apple；MyFactoryBean到底是什么？MyFactoryBean 、Apple ？\n注意：需要通过\u0026amp;区分 获取的对象是哪一个 ：\n不加\u0026amp;,获取的是最内部真实的Apple；\n如果加了\u0026amp;，获取的 是FacotryBean\n//Apple Object obj = context.getBean(\u0026quot;myFactoryBean\u0026quot;); System.out.println(obj); //FacotryBean Object obj2 = context.getBean(\u0026quot;\u0026amp;myFactoryBean\u0026quot;); System.out.println(obj2);  具体得原因再源码中又说明\n  Bean的生命周期： 方式一 适用于Bean+返回值得方式\n创建(new \u0026hellip;)、初始化（赋初值init）、 \u0026hellip;.、销毁（destroy）(类似servlet)\nxml:\n\u0026lt;bean id=\u0026quot;student\u0026quot; class=\u0026quot;com.yanqun.entity.Student\u0026quot; scope=\u0026quot;singleton\u0026quot; init-method=\u0026quot;myInit\u0026quot; destroy-method=\u0026quot;myDestroy\u0026quot; \u0026gt;  注解：\n@Bean(value=\u0026quot;stu\u0026quot;,initMethod = \u0026quot;myInit\u0026quot;,destroyMethod = \u0026quot;myDestroy\u0026quot;) //id=\u0026quot;stu\u0026quot; class=\u0026quot;...Student\u0026quot; @Autowired public Student myStudent(){ }  IoC容器在初始化时，会自动创建对象(构造方法) -\u0026gt;init -\u0026gt;\u0026hellip;..-\u0026gt;当容器关闭时 调用destroy\u0026hellip;\n销毁方法\n((AnnotationConfigApplicationContext) context).close();  方式二： JAVA规范 ：JSR250；适用于三层组件的形式 三层组件： 扫描器 + 三层注解（4个）\n三层注解 （功能性注解、MyIntToStringConverter.java）：@Controller、@Service、@Repository、@Component\n\u0026ndash;\u0026gt;三层注解（功能性注解【三层、功能性类】）\n将响应组件 加入 @Component注解、 给初始化方法加\n@PostConstruct、给销毁方法加@PreDestroy @PostConstruct：相当于方法一的init @PreDestroy：相当于方法一的destroy  如果要获取@Component注解中的bean，那么该Bean的名字就是@Component（value=\u0026ldquo;xxx\u0026rdquo;）的value值\n@Component(value=\u0026quot;myConverter\u0026quot;)//@Server @COntroller @Repository public class MyIntToStringConverter { @PostConstruct public void init(){ System.out.println(\u0026quot;转换..Init...\u0026quot;); } public void myConverter(){ System.out.println(\u0026quot;转换.......\u0026quot;); } @PreDestroy public void destroy(){ System.out.println(\u0026quot;转换..destroy...\u0026quot;); } }  MyIntToStringConverter converter= (MyIntToStringConverter)context.getBean(\u0026quot;myConverter\u0026quot;) ; converter.myConverter();  方法三：两个接口 接口：适用于三层组件（扫描器+三层组件）\nInitializingBean初始化 DisposableBean 销毁  初始化：只需要 实现InitializingBean中的afterPropertiesSet()方法\n销毁：实现DisposableBean 中的destroy()方法\n问题：要在SPring IOC容器中操作：操作方式 对象：Bean+返回 ，三层组件\n 如果是注解形式\n随便写一个方法 ，然后加上相应注解即可\n 如果是接口形式\n必须 实现接口中规定的方法\n@Component public class MyFunction implements InitializingBean , DisposableBean { public void myMethod(){ } @Override public void afterPropertiesSet() throws Exception { System.out.println(\u0026quot;MyFunction初始化...afterPropertiesSet\u0026quot;); } @Override public void destroy() throws Exception { System.out.println(\u0026quot;MyFunction销毁。。。destroy\u0026quot;); } }   方法四：（给容器中的所有Bean加初始化、销毁）一个接口 接口：适用于三层组件\n接口BeanPostProcessor：拦截了所有中容器的Bean\n@Controller //(4个) public class MyXxx implements BeanPostProcessor { //拦截器 @Override//bean:Student(zs) public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { // System.out.println(\u0026quot;初始化:\u0026quot;+beanName+\u0026quot;:\u0026quot;+bean); // bean.setName(\u0026quot;ls\u0026quot;) if(bean instanceof Student){ System.out.println(\u0026quot;MyXxx...初始化..\u0026quot;); Student stu = (Student)bean ; stu.setStuName(\u0026quot;zs123456\u0026quot;); stu.setStuNo(123); return stu ; } return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { if(bean instanceof Student) { // System.out.println(\u0026quot;销毁:\u0026quot; + beanName + \u0026quot;:\u0026quot; + bean); System.out.println(\u0026quot;MyXxx...销毁..\u0026quot;); } return bean; } }  自动装配 : 三层组件(4个注册+扫描器) @Autowired  Controller-\u0026gt;Service-\u0026gt;Dao\n三层组件\n通过@Autowired从Ioc容器中 根据类型自动注入（没有调用setXxx()方法）\n-如果@Autowired在属性前标注，则不调用setXxx；如果标注在setXxx前面 ，则调用setXxx\n-不能放在方法的参数前\n@Autowired private StudentDao studentDao ;  或\n@Autowired public void setStudentDao(StudentDao studentDao) { this.studentDao = studentDao; }  Bean+返回值：\n@Autowired 在方法的参数前（也可以省略）、方法前 （构造方法：特殊，如果只有一个有参构造方法，则构造方法前的@Autowired也可以省略）\n参数前\n@Bean(value=\u0026quot;stu\u0026quot;) public Student myStudent(@Autowired Address address){ Student student = new Student(10,\u0026quot;zs10\u0026quot;,23); return student; }  方法前\n@Autowired @Bean(value=\u0026quot;stu\u0026quot;) public Student myStudent(Address address){ Student student = new Student(10,\u0026quot;zs10\u0026quot;,23); return student; }  构造方法前\n@Autowired public StudentService(StudentDao studentDao){ this.studentDao= studentDao ; }  之前：@Autowired 根据类型匹配：\n三层注入方式/@Bean+返回值\n 如果有多个类型相同的，匹配哪个？\n报错。\n可以指定默认值@primary，就不会报错\n@Primary @Repository(\u0026quot;stuDao1\u0026quot;) public class StudentDaoImpl1 implements StudentDao { }  @Repository(\u0026quot;stuDao2\u0026quot;) public class StudentDaoImpl2 implements StudentDao { }  @Autowired private StudentDao studentDao ;  值为stuDao1\n 能否根据名字匹配？\n可以，结合 @Qualifier(\u0026ldquo;stuDao2\u0026rdquo;)使用。\n@Qualifier(\u0026quot;stuDao2\u0026quot;) @Autowired private StudentDao studentDao ;  如果有0个类型相同，默认报错；可以修改成不注入（值为null），\n@Autowired(required=false) private StudentDao studentDao ;   自动注入方式一：@Autowired (Spring) ，默认根据类型\n自动注入方式二 @Resource（JSR250，来自jdk），默认根据名字 （如果 有名字，根据名字匹配；如果没有名字，先根据名字查找，如果没找到，再根据类型查找）；也可以通过name或type属性 指定根据名字 或类型找。也可以使用@Primary指定默认\n@Resource @Resource(name=\u0026quot;studentDao1\u0026quot;) @Resource(type=StudentDao.class)  自动注入方式三：@Inject（JSR330），额外引入javax.inject.jar，默认根据类型匹配\n利用Spring底层组件进行开发 (三层组件+扫描器方式) 能够供我们使用的组件，都是Aware的子接口，即XxxxAware\n以ApplicationContextAware为例:实现步骤  实现ApplicationContextAware\n 重写其中的方法，都包含了一个对象。只需要将该对象 赋值到属性中即可\n@Component(\u0026quot;myComponent\u0026quot;) //id name public class MyComponent implements ApplicationContextAware{ private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { System.out.println(\u0026quot;------\u0026quot;+applicationContext); this.applicationContext= applicationContext ; } }  有什么用：例如ApplicationContextAware，可以通过该接口 获取到Ioc容器对象。\n  执行时间：如果在main（）中new Ioc容器： 先执行ApplicationContextAware实现类中的方法，通过该方法传入IoC容器 供我们自己使用； 然后再将该容器通过new返回给用户\nBeanNameAware： @Component(\u0026quot;myComponent\u0026quot;) //id name public class MyComponent implements BeanNameAware { private String beanName ; @Override public void setBeanName(String name) { System.out.println(\u0026quot;获取当前bean的name\u0026quot;+name); this.beanName = name ; } }  环境切换：@Profile Spring:切换环境\n @Profile(\u0026quot;myApple\u0026quot;) @Bean(\u0026quot;apple\u0026quot;) public Fruit apple(){ return new Apple() ; } @Profile(\u0026quot;myBanana\u0026quot;) @Bean(\u0026quot;banana\u0026quot;) public Fruit banana(){ return new Banana() ; }  激活方式一：\n-Dspring.profiles.active=@Profile环境名 -Dspring.profiles.active=myApple  有什么用：可以用于切换数据库环境：\n激活方式二：硬编码\n坑：错误写法\nApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class) ; ConfigurableEnvironment environment = (ConfigurableEnvironment)context.getEnvironment(); environment.setActiveProfiles(\u0026quot;myBanana\u0026quot;);  其中AnnotationConfigApplicationContext中有一个refresh()操作：会将我们设置的一些参数还原\n没激活 |-\u0026gt;进行激活 -\u0026gt;刷新 -\u0026gt;没激活\n流程调整：\n没激活-\u0026gt;进行激活 | -\u0026gt;刷新  什么时候设置 保存点|： 配置类的编写处 IoC容器在使用时必须refresh() ;如果是有参构造，内部已经刷新；如果无参构造，需要手工刷新。\n正确方式\n//注解方式 AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext() ; ConfigurableEnvironment environment = (ConfigurableEnvironment)context.getEnvironment(); environment.setActiveProfiles(\u0026quot;myApple\u0026quot;); //保存点 context.register(MyConfig.class); context.refresh();  Spring重要组件 接口BeanPostProcessor：拦截了所有中容器的Bean，并且可以进行bean的初始化 、销毁\n创建-\u0026gt;初始化-\u0026gt;使用\u0026hellip;-》销毁\nBeanPostProcessor BeanFactoryPostProcessor：拦截了容器 BeanDefinitionRegistryPostProcessor：即将被加载之前（解析之前，称为BeanDefination对象之前）  BeanPostProcessor\n@Controller //(4个) public class MyXxx implements BeanPostProcessor { //拦截器 @Override//bean:Student(zs) public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { // System.out.println(\u0026quot;初始化:\u0026quot;+beanName+\u0026quot;:\u0026quot;+bean); // bean.setName(\u0026quot;ls\u0026quot;) if(bean instanceof Student){ System.out.println(\u0026quot;MyXxx...初始化..\u0026quot;); Student stu = (Student)bean ; stu.setStuName(\u0026quot;zs123456\u0026quot;); stu.setStuNo(123); return stu ; } return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { if(bean instanceof Student) { // System.out.println(\u0026quot;销毁:\u0026quot; + beanName + \u0026quot;:\u0026quot; + bean); System.out.println(\u0026quot;MyXxx...销毁..\u0026quot;); } return bean; } }  BeanFactoryPostProcessor\n@Component public class MyYYY implements BeanFactoryPostProcessor { @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { // beanFactory.getBeanDefinition(\u0026quot;id\u0026quot;);//根据bean的名字(id)获取bean int count = beanFactory.getBeanDefinitionCount(); System.out.println(\u0026quot;【b】\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;容器中bean的个数：\u0026quot;+count); String[] names = beanFactory.getBeanDefinitionNames();//name-\u0026gt;id \u0026lt;bean id =\u0026quot;\u0026quot;\u0026gt; System.out.println(\u0026quot;【b】\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;容器中所有bean的名字：\u0026quot; +Arrays.asList( names ) ); } }  BeanDefinitionRegistryPostProcessor\n@Component public class MyZZZ implements BeanDefinitionRegistryPostProcessor { //继承自BeanFactoryPostProcessor的方法 （bean的工厂） @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { System.out.println(\u0026quot;【a后】postProcessBeanFactory:容器中注册的bean的数量:\u0026quot;+beanFactory.getBeanDefinitionCount()); Object myBean = beanFactory.getBean(\u0026quot;myBean\u0026quot;); System.out.println( myBean.getClass().getName() ); } // ApplicationListener， //BeanDefinitionRegistryPostProcessor接口自己的方法 （维护着容器中所有bean的注册信息） @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException { System.out.println(\u0026quot;【a先】postProcessBeanDefinitionRegistry:容器中注册的bean的数量:\u0026quot;+registry.getBeanDefinitionCount()); //额外增加一个：postProcessBeanDefinitionRegistry （可以为容器 额外增加一些bean的注册） //Orange BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.rootBeanDefinition(Orange.class);//产生BeanDefinition // beanDefinitionBuilder.getBeanDefinition();;//AbstractBeanDefinition registry.registerBeanDefinition(\u0026quot;myBean\u0026quot;, beanDefinitionBuilder.getBeanDefinition()); } }  BeanDefinitionRegistryPostProcessor(a) -》加载bean-\u0026gt;BeanFactoryPostProcessor(b)-\u0026gt;实例化bean-\u0026gt;BeanPostProcessor\n同一个方法 在不同地方（类、接口）的出现时机问题：\na继承b，因此a中必然包含b中的方法(记c )：虽然a和b中都有c，但是 因此c出现的时机不同， 则c的执行顺序也不同： 如果是在a中出现，则先执行；如果是在b中执行 则后执行\n在同一个地方（类、接口），的不同方法的出现时机问题\n监听器： 可以监听事件 ，监听的对象必须是 ApplicationEvent自身或其子类/子接口\n方式一：\n必须实现ApplicationListener接口，\n//监听器 @Component public class MyListener implements ApplicationListener { //监听对象 @Override public void onApplicationEvent(ApplicationEvent event) { System.out.println(\u0026quot;=======\u0026quot;+event+\u0026quot;======\u0026quot;); } }  方式二：注解\n(语法上 可以监听任意事件，但建议 ApplicationEvent自身或其子类/子接口) Spring：要让SPring识别自己，必须加入IOc容器（Bean+返回值| 注解+扫描器）\n@Component public class MyListener2 { //本方法是一个 监听方法 @EventListener(classes = {ApplicationEvent.class}) public void myListenerMethod(ApplicationEvent event){ System.out.println(\u0026quot;--0000000--------\u0026quot;+event); } }  自定被监听事件\n 自定义类 实现ApplicationEvent接口（自定义事件） 发布事件\ncontext.publishEvent(自定义事件);  //创建一个事件并发布 context.publishEvent(new ApplicationEven(\u0026quot;my event...\u0026quot;)) ;  或\npublic class MyEvent3 extends ApplicationEvent { public MyEvent3(Object source) { super(source); } }  MyEvent3 evn = new MyEvent3(\u0026quot;my Event3...\u0026quot;); context.publishEvent(evn) ;   ","id":26,"section":"posts","summary":"spring简介 2002 Rod Johnon 发布\u0026lt;Expoer One-on-one j2eedevelopment and Design\u0026gt; 2003产生Spring，Spring两大核心IOC、Aop Spring data, spring boot, spring cloud, spring framework ，spri","tags":["Spring家族"],"title":"Spring自学笔记","uri":"https://mumulx.github.io/2019/11/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" Spring整合MyBatis git源码\nSpring - MyBatis\n思路：\nSqlSessionFactory -\u0026gt; SqlSession -\u0026gt;StudentMapper -\u0026gt;CRUD  可以发现 ，MyBatis最终是通过SqlSessionFactory来操作数据库，\nSpring整合MyBatis 其实就是 将MyBatis的SqlSessionFactory 交给Spring\nSM整合步骤： java项目\njar mybatis-spring.jar spring-tx.jar spring-jdbc.jar spring-expression.jar spring-context-support.jar spring-core.jar spring-context.jar spring-beans.jar spring-aop.jar spring-web.jar commons-logging.jar commons-dbcp.jar ojdbc.jar mybatis.jar log4j.jar commons-pool.jar  类-表 package org.ycit.entity; public class Student { private int stuNo; private String stuName; private int stuAge; public Student() { }\tpublic Student(int stuNo, String stuName, int stuAge) { this.stuNo = stuNo; this.stuName = stuName; this.stuAge = stuAge; } public int getStuNo() { return stuNo; } public void setStuNo(int stuNo) { this.stuNo = stuNo; } public String getStuName() { return stuName; } public void setStuName(String stuName) { this.stuName = stuName; } public int getStuAge() { return stuAge; } public void setStuAge(int stuAge) { this.stuAge = stuAge; } }  MyBatis配置文件conf.xml \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026quot;-//mybatis.org//DTD Config 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026quot;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 数据库信息 --\u0026gt; \u0026lt;!-- 在spring容器中配置 --\u0026gt; \u0026lt;!-- 加载映射文件studentmapper.xml \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026quot;org/ycit/mapper/StudentMapper.xml\u0026quot;\u0026gt;\u0026lt;/mapper\u0026gt; \u0026lt;/mappers\u0026gt; --\u0026gt; \u0026lt;/configuration\u0026gt;  driver=oracle.jdbc.OracleDriver url=jdbc:oracle:thin:@localhost:1521:MyOracleDB username=scott password=135451 maxIdle=1000 maxActive=500  通过mapper.xml将 类、表建立映射关系 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot;\u0026gt; \u0026lt;!--namespace：该mapper.xml映射文件的唯一标识符 --\u0026gt; \u0026lt;mapper namespace=\u0026quot;org.ycit.mapper.StudentMapper\u0026quot;\u0026gt; \u0026lt;select id=\u0026quot;queryStudentbyStuno\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;org.ycit.entity.Student\u0026quot;\u0026gt; select * from student where stuno = #{stuNo} \u0026lt;/select\u0026gt; \u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;org.ycit.entity.Student\u0026quot;\u0026gt; insert into student(stuno,stuname,stuage) values(#{stuNo},#{stuName},#{stuAge}) \u0026lt;/insert\u0026gt; \u0026lt;/mapper\u0026gt;  public interface StudentMapper { public void addStudent(Student student); }  整合 之前使用MyBatis:conf.xml -\u0026gt;SqlSessionFacotry\n现在整合的时候，需要通过Spring管理SqlSessionFacotry ，因此 产生qlSessionFacotry 所需要的数据库信息 不在放入conf.xml 而需要放入spring配置文件中\n配置Spring配置文件（applicationContext.xml）\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026quot;\u0026gt; \u0026lt;!-- 加载db.properties文件 --\u0026gt; \u0026lt;bean id=\u0026quot;config\u0026quot; class=\u0026quot;org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;locations\u0026quot; \u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;classpath:db.properties\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置数据库的信息（代替mybatis的配置i文件conf.xml） --\u0026gt; \u0026lt;bean id=\u0026quot;dataSource\u0026quot; class=\u0026quot;org.apache.commons.dbcp.BasicDataSource\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driverClassName\u0026quot; value=\u0026quot;${driver}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name= \u0026quot;url\u0026quot; value= \u0026quot;${url}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name= \u0026quot;username\u0026quot; value= \u0026quot;${username}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name= \u0026quot;password\u0026quot; value= \u0026quot;${password}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;maxActive\u0026quot; value=\u0026quot;${maxActive}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;maxIdle\u0026quot; value=\u0026quot;${maxIdle}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 在SpringIoc容器中创建MyBatis的核心类SqlSessionFactory --\u0026gt; \u0026lt;bean id=\u0026quot;sqlSessionFactory\u0026quot; class=\u0026quot;org.mybatis.spring.SqlSessionFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 加载mybatis的配置文件 \u0026lt;property name=\u0026quot;configLocation\u0026quot; value=\u0026quot;classpath:conf.xml\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; --\u0026gt; \u0026lt;!-- 加载，apper的文件路径 --\u0026gt; \u0026lt;property name=\u0026quot;mapperLocations\u0026quot; value=\u0026quot;org/ycit/mapper/*.xml\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026quot;studentService\u0026quot; class= \u0026quot;org.ycit.service.impl.StudentServiceImpl\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;studentMapper\u0026quot; ref=\u0026quot;studentMapper\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;\t\u0026lt;!--第一种方式生成mapper对象 \u0026lt;bean id=\u0026quot;studentMapper\u0026quot; class= \u0026quot;org.ycit.dao.impl.StudentDaoImpl\u0026quot;\u0026gt; dao层注入sqlSessionFactory \u0026lt;property name=\u0026quot;sqlSessionFactory\u0026quot; ref=\u0026quot;sqlSessionFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; --\u0026gt; \u0026lt;!-- 第二种方式生成mapper对象 \u0026lt;bean id=\u0026quot;studentMapper\u0026quot; class= \u0026quot;org.mybatis.spring.mapper.MapperFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;mapperInterface\u0026quot; value=\u0026quot;org.ycit.mapper.StudentMapper\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;sqlSessionFactory\u0026quot; ref=\u0026quot;sqlSessionFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; --\u0026gt; \u0026lt;!-- 第三种方式生成mapper对象(批量产生了 多个mapper) 批量产生的mapper对象在springioc中的id值默认为 （首字母小写） 接口名 --\u0026gt; \u0026lt;bean id=\u0026quot;mappers\u0026quot; class= \u0026quot;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;sqlSessionFactoryBeanName\u0026quot; value=\u0026quot;sqlSessionFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 指定批量产生 那个包中的mapper对象 多个包使用,隔开 --\u0026gt; \u0026lt;property name=\u0026quot;basePackage\u0026quot; value=\u0026quot;org.ycit.mapper\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;  使用Spring-MyBatis整合产物开发程序 目标：通过spring产生mybatis最终操作需要的 动态mapper对象(StudentMapper对象)\nSpring产生 动态mapper对象 有3种方法：\n 第一种方式\nDAO层实现类 继承 SqlSessionDaoSupport类\nSqlSessionDaoSupport类提供了一个属性 SqlSession  public class StudentDaoImpl extends SqlSessionDaoSupport implements StudentMapper{ public void addStudent(Student student) { SqlSession session = super.getSqlSession(); StudentMapper stuDao = session.getMapper(StudentMapper.class); stuDao.addStudent(student); } }  \u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;org.ycit.entity.Student\u0026quot;\u0026gt; insert into student(stuno,stuname,stuage) values(#{stuNo},#{stuName},#{stuAge}) \u0026lt;/insert\u0026gt;   \u0026lt;!--第一种方式生成mapper对象 要在dao层注入sqlSessionFactory --\u0026gt; \u0026lt;bean id=\u0026quot;studentMapper\u0026quot; class= \u0026quot;org.ycit.dao.impl.StudentDaoImpl\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;sqlSessionFactory\u0026quot; ref=\u0026quot;sqlSessionFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   \u0026lt;!-- 在SpringIoc容器中创建MyBatis的核心类SqlSessionFactory --\u0026gt; \u0026lt;bean id=\u0026quot;sqlSessionFactory\u0026quot; class=\u0026quot;org.mybatis.spring.SqlSessionFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 加载mybatis的配置文件 \u0026lt;property name=\u0026quot;configLocation\u0026quot; value=\u0026quot;classpath:conf.xml\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; --\u0026gt; \u0026lt;!-- 加载，mapper的文件路径 --\u0026gt; \u0026lt;property name=\u0026quot;mapperLocations\u0026quot; value=\u0026quot;org/ycit/mapper/*.xml\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  这时可以在spring中配置mapper文件的路径，以前是在mybatis的配置文件conf.xml文件中配置的，此时我们可以在spring中配置，发现mybatis配置文件形同虚设，里面没有配置的信息，因此，spring也不需要加载mybatis的配置文件，所以把加载mybatis的配置文件配置信息注释掉。\n此时不在需要我们手动提交，交给spring后会自动提交，以前采用mybatis，采用jdbc手动提交的方式。\n 第二种方式\n就是省略掉 第一种方式的 实现类 直接MyBatis提供的 Mapper实现类：org.mybatis.spring.mapper.MapperFactoryBean\n不需要自己再编写实现类\n缺点：每个mapper都需要一个配置一次\n\u0026lt;bean id=\u0026quot;studentMapper\u0026quot; class= \u0026quot;org.mybatis.spring.mapper.MapperFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;mapperInterface\u0026quot; value=\u0026quot;org.ycit.mapper.StudentMapper\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;sqlSessionFactory\u0026quot; ref=\u0026quot;sqlSessionFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  第三种方式\n批量配置 实现类\n\u0026lt;!-- 第三种方式生成mapper对象(批量产生了 多个mapper) 批量产生的mapper对象在springioc中的id值默认为 （首字母小写） 接口名 --\u0026gt; \u0026lt;bean id=\u0026quot;mappers\u0026quot; class= \u0026quot;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;sqlSessionFactoryBeanName\u0026quot; value=\u0026quot;sqlSessionFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 指定批量产生 那个包中的mapper对象 多个包使用,隔开 --\u0026gt; \u0026lt;property name=\u0026quot;basePackage\u0026quot; value=\u0026quot;org.ycit.mapper\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  批量产生的mapper对象在springioc中的id值默认为 （首字母小写） 接口名\n  SSM整合： Spring - SpringMVC - MyBatis\n SM\nSpring - MyBatis : 需要整合：将MyBatis的SqlSessionFactory 交给Spring\n SSM\n  Spring - SpringMVC ： 就是将Spring - SpringMVC 各自配置一遍\n思路： SqlSessionFactory -\u0026gt; SqlSession -\u0026gt;StudentMapper -\u0026gt;CRUD 可以发现 ，MyBatis最终是通过SqlSessionFactory来操作数据库， Spring整合MyBatis 其实就是 将MyBatis的SqlSessionFactory 交给Spring\nSM整合步骤：  jar\nmybatis-spring.jar spring-tx.jar spring-jdbc.jar spring-expression.jar spring-context-support.jar spring-core.jar spring-context.jar spring-beans.jar spring-aop.jar spring-web.jar commons-logging.jar commons-dbcp.jar ojdbc.jar mybatis.jar log4j.jar commons-pool.jar  类-表\nStudent类 -student表\n 配置\n（与Spring整合时，conf.xml可省）\u0026ndash;MyBatis配置文件conf.xml（数据源、mapper.xml） \u0026ndash;可省，将该文件中的配置 全部交由spring管理\nspring配置文件 applicationContext.xml\n 通过mapper.xml将 类、表建立映射关系\n 配置spring配置文件\n配置Spring配置文件（applicationContext.xml） （Web项目）：\nweb.xml\n\u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;org.springframework.web.context.ContextLoaderListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt;  之前使用MyBatis: conf.xml -\u0026gt;SqlSessionFacotry\n现在整合的时候，需要通过Spring管理SqlSessionFacotry ，因此 产生SqlSessionFacotry 所需要的数据库信息 不在放入conf.xml 而需要放入spring配置文件中\n在applicationContext中配置mybatis信息\n配置数据库信息\n\u0026lt;!-- 加载db.properties文件 --\u0026gt; \u0026lt;bean id=\u0026quot;config\u0026quot; class=\u0026quot;org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;locations\u0026quot;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;classpath:db.properties\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 配置配置数据库信息（替代mybatis的配置文件conf.xml） --\u0026gt; \u0026lt;bean id=\u0026quot;dataSource\u0026quot; class=\u0026quot;org.apache.commons.dbcp.BasicDataSource\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driverClassName\u0026quot; value=\u0026quot;${driver}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;${url}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;${username}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${password}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  使用Spring整合MyBatis ：\n在SpringIoc容器中 创建MyBatis的核心类\n\u0026lt;!-- 在SpringIoc容器中 创建MyBatis的核心类 SqlSesionFactory --\u0026gt; \u0026lt;bean id=\u0026quot;sqlSessionFactory\u0026quot; class=\u0026quot;org.mybatis.spring.SqlSessionFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 加载mapper.xml路径 --\u0026gt; \u0026lt;property name=\u0026quot;mapperLocations\u0026quot; value=\u0026quot;classpath:org/lanqiao/mapper/*.xml\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  将MyBatis的SqlSessionFactory 交给Spring\n\u0026lt;!-- 将MyBatis的SqlSessionFactory 交给Spring --\u0026gt; \u0026lt;bean class=\u0026quot;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;sqlSessionFactoryBeanName\u0026quot; value=\u0026quot;sqlSessionFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;basePackage\u0026quot; value=\u0026quot;org.lanqiao.mapper\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--上面basePackage所在的property的作用： 将org.lanqiao.mapper包中，所有的接口 产生与之对应的 动态代理对象 （对象名 就是 首字母小写的接口名） --\u0026gt; \u0026lt;/bean\u0026gt;  继续整合SpringMVC\n将springmvc加入项目即可\n 加入SpringMVC需要的jar\nspring-webmvc.jar  给项目加入SpringMVC支持\nweb.xml: dispatcherServlet\n\u0026lt;!-- 整合SPringMVC --\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springDispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext-controller.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!-- Map all requests to the DispatcherServlet for handling --\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springDispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;  编写springmvc配置文件：\napplicationContext-controller.xml：视图解析器、基础配置\n\u0026lt;!-- 将控制器所在包 加入IOC容器 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;org.lanqiao.controller\u0026quot;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;!-- 配置视图解析器 --\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;prefix\u0026quot; value=\u0026quot;/views/\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;suffix\u0026quot; value=\u0026quot;.jsp\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- SPringMVC基础配置、标配 --\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt;    示例 git源码\n","id":27,"section":"posts","summary":"Spring整合MyBatis git源码 Spring - MyBatis 思路： SqlSessionFactory -\u0026gt; SqlSession -\u0026gt;StudentMapper -\u0026gt;CRUD 可以发现 ，MyBatis最终是通过SqlSessionFactory来操作数据","tags":["Spring家族"],"title":"SSM整合自学笔记","uri":"https://mumulx.github.io/2019/11/ssm%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" 记录自己的第一篇博客 \u0026emsp;2019-10-31，抓住10月的小尾巴，创建了人生的第一个博客。经过一天的努力，终于是在22：13的时候创建好了人生的第一个博客。也不知道要写一些什么，就简单的记录一下这特殊的一天。\n\u0026emsp;其实很早的时候就计划着要建立自己的博客，一直也没有着手弄。今天的话就心血来潮，仿佛是命运在召唤，促使着我建立了这个网站。就这么的，忙了一个晚上，经过了一系列的难关终于是将博客建立了起来。以后的话会分享一些自己的学习笔记和学习过程中遇到过的各种问题。说来也是惭愧，自出生二十年以来，一直也没养成什么习惯，也没有什么爱好，也没能长时间坚持做过什么事情。也是希望能把本站当作一件自己能够一直坚持想做的事情。\n\u0026emsp;此时的我呢是一名普通的本科大三的学生，在 这个时间段又再一次处在了一个人生的十字路口，一方是考研，一方是预就业。两个各有各的好处吧，于我来说可能预就业是一个更好的选择吧，当然我也不是很确定这次的选择是正确的。我呢是一个不是很能认清自己的人，也是一个每当要做选择的时候，总会错过最重要选项的那个人，很是害怕这次的选择又错过了。\n\u0026emsp;迷茫和矛盾两个词可能是我现在最真实的状态了。迷茫，更多的是对自己未来的迷茫，看不清也说不透。我对于人生没有什么规划，总是随遇而安，秉着车到山前必有路的理念，不争也不抢。可是这次与往常不同，学校和社会是两个完全不同的地方，而我又是一个不善交际的人，对于自己即将步入的社会还是没有什么概念的。这次是即将告别学校，离开这个困住了十几年的地方，要去一个更加复杂，更加混乱的地方。而这个地方充满了未知，你不知道你能否适应这个地方，能否承受的住生活的压力，能否找到一份满意的工作，能否顺利的从学生这个身份过渡到社会人士这个身份，只知道自己现在能做的只能是一个更好的自己。对于我这种不善交际，不喜争抢，性格内向的人来说，步入社会四个字就像是哈利波特里面的摄魂怪一样，令人畏惧与害怕。\n\u0026emsp;矛盾的是不能坚定自己的选择，总是患得患失，即不甘于平庸，又陷于平庸。心里想的，嘴上说的，实际做的，往往是三种样子。每当要自己做一个决定的时候，总是犹犹豫豫，患得患失，担心这担心那，考虑这考虑那，越想越复杂。最后反而会选择自己的第一映像做出的决定，而做出这个决定后呢，又总是觉着自己的选择是错误的，不能肯定自己。内心是非常矛盾的。\n\u0026emsp;懒惰是毁掉一个人的罪魁祸首，它让你逐渐的安于现状，丧失对未来拼搏的动力。我觉着自己是一个很懒惰的人，而又不是一个懒惰的人。很是矛盾吧！懒惰的背后是自己没什么奋斗目标，没什梦想，没什么理想，没什么信念。所以整个人是懒懒散散的。而每当自己有了一个奋斗的目标后，我会为之努力奋斗，整个人的状态像是上了劲的发条，充满干劲。\n\u0026emsp;我是一个完美主义者，和强迫症晚期的人，我会尽量的把自己的每一项工作和目标完成的很完美。当天的事情必须完成，什么时候完成什么时候睡觉，绝不会留到第二天，有些人可能不会理解这一点，但这确确实实是发生在我身上的。人是一个复杂的动物，真是因为这些完美的和不完美的，才构成了一个第一无二的自己。我希望呢，每个人都应该得认识自己，了解自己，知道自己的不足，知道自己想要什么，尽量让自己活得明白一点。而未来是属于我们的，时间会洗涤一切，现时的烦恼是阻挡不了自己前进的脚步的。几年后的自己回看现在的自己就像现在的自己回看过去的自己一样，肯定会觉得自己那个时候怎么那么的幼稚，可笑。\n\u0026emsp;也是希望自己在回首往事的时，不因虚度年华而悔恨，也不因碌碌无为而羞愧。珍惜当下的时间，做自己该做的事情，充实自己的脑袋，多思考，未来的你会感谢现在这样拼搏的你。\n\u0026emsp;下面给大家分享一段话，这段话，感觉还是很适合现在的自己。\n 每天认真洗脸，多读书，按时睡，少食多餐，变得温柔，大度，继续善良，保持爱心。不在人前矫情，四处诉说以求宽慰，而是学会一个人静静面对，自己把道理想通。这样的你，暂时单身也无所谓啊，你那么虔诚的做更好的自己，一定会遇到最好的，而那个人也一定值得你所有等待。\n ","id":28,"section":"posts","summary":"记录自己的第一篇博客 \u0026emsp;2019-10-31，抓住10月的小尾巴，创建了人生的第一个博客。经过一天的努力，终于是在22：13的时候创","tags":["日记"],"title":"自己的第一篇博客","uri":"https://mumulx.github.io/2019/10/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","year":"2019"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }","id":29,"section":"posts","summary":"\u003cp\u003eEmoji can be enabled in a Hugo project in a number of ways.\u003c/p\u003e","tags":["杂七杂八"],"title":"Emoji Support","uri":"https://mumulx.github.io/2019/01/emoji-support/","year":"2019"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline\u0026nbsp;\u0026nbsp;\u0026nbsp; Markdown\u0026nbsp;\u0026nbsp;\u0026nbsp; In\u0026nbsp;\u0026nbsp;\u0026nbsp; Table     italics bold strikethrough\u0026nbsp;\u0026nbsp;\u0026nbsp; code    Code Blocks Code block with backticks html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. ↩  ","id":30,"section":"posts","summary":"\u003cp\u003eThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","tags":["杂七杂八"],"title":"Markdown Syntax Guide","uri":"https://mumulx.github.io/2019/01/markdown-syntax/","year":"2019"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt \nThe Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","id":31,"section":"posts","summary":"\u003cp\u003eLorem est tota propiore conpellat pectoribus de\npectora summo.\u003c/p\u003e","tags":["杂七杂八"],"title":"Placeholder Text","uri":"https://mumulx.github.io/2019/01/placeholder-text/","year":"2019"}],"tags":[{"title":"J2EE","uri":"https://mumulx.github.io/tags/j2ee/"},{"title":"Java","uri":"https://mumulx.github.io/tags/java/"},{"title":"node","uri":"https://mumulx.github.io/tags/node/"},{"title":"Spring家族","uri":"https://mumulx.github.io/tags/spring%E5%AE%B6%E6%97%8F/"},{"title":"其他问题","uri":"https://mumulx.github.io/tags/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/"},{"title":"前端框架","uri":"https://mumulx.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"title":"开发软件","uri":"https://mumulx.github.io/tags/%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6/"},{"title":"数据库","uri":"https://mumulx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"日记","uri":"https://mumulx.github.io/tags/%E6%97%A5%E8%AE%B0/"},{"title":"杂七杂八","uri":"https://mumulx.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"title":"版本控制","uri":"https://mumulx.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}]}