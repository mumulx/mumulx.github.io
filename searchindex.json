{"categories":[{"title":"技术收录","uri":"https://mumulx.github.io/categories/%E6%8A%80%E6%9C%AF%E6%94%B6%E5%BD%95/"},{"title":"技术框架","uri":"https://mumulx.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"title":"私人博客","uri":"https://mumulx.github.io/categories/%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"问题收录","uri":"https://mumulx.github.io/categories/%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95/"}],"posts":[{"content":" vue介绍 vue是一个渐进式的JavaScript框架。渐进式：可插拔式、可扩展。\n我们刚开始只需要使用最核心的核心库，后期可以自己去增加新库。\nvue官网\nvue引入 vue提供了非常详细的官方文档，我们完全可以通过官方文档来学习vue.vue官方文档\nxx.vue文件组成结构： \u0026lt;template\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt;  在chrome中安装vue开发工具 解压文件下载,或者参考网上的解决方案进行安装\n该插件可以在chrome浏览器中充当vue的调试工具\nmvvm简介 html使用vue \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; var vm = new Vue({ el:'', data:{ }, methods:{ }, computed:{ }, watch:{ } }) \u0026lt;/script\u0026gt;   var vm = new Vue({});\n创建一个vue的实例\n当我们导入包之后在浏览器的内存中，就多了一个Vue的构造函数\n注意：我们new出来的这个vm对象就是我们mvvm中的vm调度者\n el\n表示，当前我们 new的这个vue实例，要控制页面上的哪一个区域\n data\ndata属性中，存放的时el中索要用到的数据\n这里的data 就是mvvm中的m，专门用来保存页面数据的\n通过 vue提供的指令，很方便的就能把数据渲染到页面上，程序员不需要手动操作dom元素了【前端的vue之类的框架，不提倡我们区手动操作dom元素了】\ncomputed中的返回值也作为data中的一部分\n computed\n 进行计算，初始时自动加载，和变量是共享的（在data中定义的变量，就不能再在computed中定义）它中方法的返回值，也作为data变量存在：方法名就是变量名，返回值就是它的值。\n 当data数据发生改变时也会执行。\n computed中定义的data变量（类似方法的形式）只会被计算一次，之后会加入缓存中，之后在取值时，直接从缓存中获取。\ncomputed:{ ageAndName(){ return this.name+this.age; } }   watch\n进行监听，将html中的数据放到data中(mvvm中 v\u0026ndash;\u0026gt;m),当数据发生变化时，触发监听\nwatch:{ name:function(value){ this.name1= value; } }  directives\n定义局部指令\n  语法 插值表达式 {{}} 显示内容，只会替换自己的这个占位符，不会吧整个元素的内容清空\n\u0026lt;h1\u0026gt;{{name}}2222222\u0026lt;/h1\u0026gt; name:\u0026quot;helloword\u0026quot;  输出\nhelloword2222222  v-clock: 能够解决插值表达式闪烁的问题\n出现的原因：跟生命周期有关\nvue会先加载html文件，然后加载js文件，最后进行替换(vue数据)\n解决方案：先将元素隐藏，当加载完毕之后在进行显示\n 定义\n\u0026lt;style\u0026gt; [v-clock] { display: none; } \u0026lt;/style\u0026gt;  使用\n\u0026lt;p v-cloak\u0026gt;{{msg}}\u0026lt;/p\u0026gt;   使用v-clock能够解决插值表达式闪烁的问题，当网络较慢的时候{{msg}}会显示在页面中\nv-text: 显示内容，但是会覆盖元素中的原本内容\n\u0026lt;h1 v-text=\u0026quot;name\u0026quot;\u0026gt;222222\u0026lt;/h1\u0026gt; name:\u0026quot;helloword\u0026quot;  输出\nhelloword  v-html: 带渲染的显示，节点操作\n\u0026lt;h1 v-html=\u0026quot;site\u0026quot;\u0026gt;\u0026lt;/h1\u0026gt; site:\u0026quot;\u0026lt;a href='https://www.baidu.com'\u0026gt;百度\u0026lt;/a\u0026gt;\u0026quot;,  v-bind: 或 : 给html标签的属性绑定值\n他的缩写是 :\n\u0026lt;a v-bind:href=\u0026quot;link\u0026quot;\u0026gt;百度\u0026lt;/a\u0026gt; \u0026lt;a :href=\u0026quot;link\u0026quot;\u0026gt;百度\u0026lt;/a\u0026gt;  v-on: 或 @ 事件的绑定\n\u0026lt;button v-on:click=\u0026quot;sayHello\u0026quot;\u0026gt;sayHello\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026quot;sayHello\u0026quot;\u0026gt;sayHello\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026quot;sayHelloName('ssss')\u0026quot;\u0026gt;sayHelloName\u0026lt;/button\u0026gt;  无参函数中的()可写可不写\n有参函数需要传参的时候需要加上()\nv-model 可以实现 表单元素和model中的数据实现双向绑定\n用户名：\u0026lt;input type=\u0026quot;text\u0026quot; v-model=\u0026quot;name\u0026quot;/\u0026gt;  注意：\n 将data中的数据传到html中 插值表达式 {{}}，v-text:，v-html:，等方式\n 将html中的数据传到data中：\n 通过监听watch\n 通过vue对象\nvm.$watch('name', function(value){ this.age= value; })    vue引入css 通过class  定义css\n\u0026lt;style\u0026gt; .mystyle1{ background-color: blue ; width: 100px; height: 100px; } \u0026lt;/style\u0026gt;  css绑定到data\ncss1 : 'mystyle1'  html元素使用css\n\u0026lt;h3 :class=\u0026quot;mystyle1\u0026quot;\u0026gt;1111111\u0026lt;/h3\u0026gt;   注意\n vue的css样式引入可以与传统的css样式引入共存\n\u0026lt;h3 class=\u0026quot;mystyle3\u0026quot; :class=\u0026quot;css1\u0026quot;\u0026gt;info:{{info}}\u0026lt;/h3\u0026gt;  :class的值 是一个对象{k1:v1,k2:v2...}如果对象中的变量值true，则生效；否则不生效\n\u0026lt;h3 :class=\u0026quot;{mystyle1:istrue, mystyle3:isfalse}\u0026quot; \u0026gt;111111\u0026lt;/h3\u0026gt;  istrue和isfalse在data中定义，根据他们的值来判断样式是否生效，当istrue=true;isfalse=false;时，mystyle1生效，mystyle3不生效\n值可以同时为true或false\n 绑定数组 []\n\u0026lt;h3 :class=\u0026quot;['mystyle1', 'mystyle3']\u0026quot;\u0026gt;11111\u0026lt;/h3\u0026gt;  同时生效\n vue取值有一个特点：取的值是变量，变量名是在data中定义的。\n  通过style 语法：\n:style={样式名:样式值(\u0026lt;从data中获取\u0026gt;),x:x,...}\n\u0026lt;h3 :style=\u0026quot;{backgroundColor:x,color:y}\u0026quot;\u0026gt;info000000:{{info}}\u0026lt;/h3\u0026gt; x:'lightgray' , y:'purple',  注意：\n属性的名字不能使用xxx-yyyy(中间使用-符号)，而需要使用 xxxYyyy(驼峰命名)\n条件渲染 v-if和v-else \u0026lt;h3 v-if=\u0026quot;istrue\u0026quot;\u0026gt;1111\u0026lt;/h3\u0026gt; \u0026lt;h3 v-else\u0026gt;222\u0026lt;/h3\u0026gt;  isture在data中定义，当为真时显示111，为假时显示222\nv-show \u0026lt;h3 v-show=\u0026quot;isture\u0026quot;\u0026gt;111\u0026lt;/h3\u0026gt; \u0026lt;h3 v-show=\u0026quot;!isture\u0026quot;\u0026gt;222\u0026lt;/h3\u0026gt;  注意：v-if和v-show的区别\nv-show可以在源码中追踪到隐藏的元素,即隐藏的元素可以在源码中找到；\nv-if无法追踪，即隐藏的元素，在源码中找不到；\n循环遍历  \u0026lt;!-- 遍历一个具体对象 (一个对象有很多属性：name age )--\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026quot;(value,name) in students[2]\u0026quot; :key=\u0026quot;name\u0026quot; \u0026gt; {{value}} --{{name}} \u0026lt;/li\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;  value：对象属性的值\nname：对象的属性名\nstudents[2]:对象数组中的一个元素(即一个对象)\n遍历对象 遍历对象数组 \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026quot;(s,index) in students\u0026quot; :key=\u0026quot;index\u0026quot; \u0026gt; {{index}} - {{s.name}} - {{s.age}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; students: [ {name:'zs', age:23}, {name:'ls', age:24}, {name:'ww', age:25}, {name:'zl', age:26}, {name:'sq', age:27} ] //对象数组  s:数组的每一个元素\nindex:下标\nstudents:数组\n:key:唯一值\n注意：想要获取data中的数据，需要通过this.来获取\n删除数组元素:splice //删除完毕后，数组元素 会自动重新排序 this.students.splice(index,1);  从下标index起删除1个\n更新数组元素:splice this.students.splice(index,1,stu);  将下标为index的数组元素更新为stu对象\n筛选 组成：查询的条件，新数组\n 定义查询条件(即定义data中数据)\nqueryname: \u0026ldquo; //筛选条件\n 具体实现方法(在computed中定义，函数名就是变量，即新数组)\n//筛选后的新数组 queryStuentsResult(){ // 新数组的值 var queryStudents ;//s //筛选条件 // var queryname = data中定义的queryname ; // var student2 = data中定义的数组students ; var {queryname,students} = this ;//this 就是data //根据查询条件，筛选出新数组 queryStudents = students.filter( stu=\u0026gt;stu.name .indexOf(queryname ) \u0026gt; -1 ) return queryStudents ; }   排序  定义升降序变量(0:升序,1:降序)\n ordered: 0  对queryStudents对象数组中的元素，根据age属性进行排序\n//排序 queryStudents.sort( function(s1,s2) { if(ordered ==0){//升序 return s1.age - s2.age }{//降序 return s2.age -s1.age } })  升序：第一个 - 第二个\n降序：第二个 - 第一个\n别忘了return\n  传播行为与事件 传参当前对象 \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;按钮1\u0026quot; @click=\u0026quot;myclick\u0026quot; /\u0026gt; \u0026lt;!--错误行为--\u0026gt; \u0026lt;!-- \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;按钮\u0026quot; @click=\u0026quot;myclick()\u0026quot; /\u0026gt; --\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;按钮2\u0026quot; @click=\u0026quot;myclick2($event)\u0026quot; /\u0026gt;  传当前对象时，要么不写，要么添加($event)，不能只写()这样会报错\n获取对象 myclick(event){ alert( event.target.value ) }, myclick2(event){ alert(event.target.value ) },  event.target：当前对象\n注意：在vue中结尾符;可写可不写(要么都写，要么都不写)\n事件的传播行为(propogation) \u0026lt;div :class=\u0026quot;css1\u0026quot; @click='myclick3()'\u0026gt; outer \u0026lt;div :class=\u0026quot;css2\u0026quot; @click='myclick4()'\u0026gt; inner \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; myclick4(){ alert('inner' ) }, myclick5(){ alert('link...' ) },  结果：\n点击:inner时，会触发outer的点击事件\n阻止行为：\n\u0026lt;div :class=\u0026quot;css1\u0026quot; @click='myclick3()'\u0026gt; outer \u0026lt;div :class=\u0026quot;css2\u0026quot; @click.stop='myclick4()'\u0026gt; inner \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;  阻止默认行为 \u0026lt;a href=\u0026quot;https://www.baidu.com\u0026quot; @click.prevent='myclick5()'\u0026gt;百度\u0026lt;/a\u0026gt; myclick5(){ alert('link...' ) },  注意:.xxx可以嵌套着使用\n键盘点击事件 keydown 按键 按下事件\n\u0026lt;input @keydown='myclick6'\u0026gt; myclick6(event){ //event.target :当前dom对象 //event.keyCode：按键的值 a : 65 alert( event.keyCode +'--'+ event.target.value ) },  keyup 按键弹上去事件\n指定按键触发事件 \u0026lt;input @keyup.13='myclick6' \u0026gt;  指定的按键按下抬起时才触发的事件\n每一个键盘的按键都对应着一个键码值\n表单输入绑定 \u0026lt;form action=\u0026quot;\u0026quot; @submit.prevent=\u0026quot;mysubmit\u0026quot;\u0026gt; 用户名：\u0026lt;input type=\u0026quot;text\u0026quot; v-model=\u0026quot;user.username\u0026quot; \u0026gt;\u0026lt;br\u0026gt; 密码：\u0026lt;input type=\u0026quot;password\u0026quot; v-model=\u0026quot;user.password\u0026quot; \u0026gt;\u0026lt;br\u0026gt; 性别： \u0026lt;input type=\u0026quot;radio\u0026quot; value=\u0026quot;male\u0026quot; v-model=\u0026quot;user.password\u0026quot;\u0026gt;男\u0026lt;br\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; value=\u0026quot;female\u0026quot; v-model=\u0026quot;user.password\u0026quot;\u0026gt;女\u0026lt;br\u0026gt; 兴趣： \u0026lt;input type=\u0026quot;checkbox\u0026quot; value=\u0026quot;football\u0026quot; v-model=\u0026quot;user.hobbies\u0026quot;\u0026gt;足球， \u0026lt;input type=\u0026quot;checkbox\u0026quot; value=\u0026quot;basketball\u0026quot; v-model=\u0026quot;user.hobbies\u0026quot;\u0026gt;篮球， \u0026lt;input type=\u0026quot;checkbox\u0026quot; value=\u0026quot;pingpang\u0026quot; v-model=\u0026quot;user.hobbies\u0026quot;\u0026gt;乒乓球， 城市： \u0026lt;select name=\u0026quot;\u0026quot; id=\u0026quot;\u0026quot; v-model=\u0026quot;user.city\u0026quot;\u0026gt; \u0026lt;option :value=\u0026quot;c.id\u0026quot; v-for=\u0026quot;c in optionalCities\u0026quot;\u0026gt; {{c.name}} \u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;注册\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  data:{ user:{ username: '' , passowrd: '' , sex: 'male', hobbies: [] , city: '' //选中 }, //可选 optionalCities: [\u0026quot;js\u0026quot;,\u0026quot;bj\u0026quot;,\u0026quot;sh\u0026quot;] },  这里只列出了部分的用法详细的用法参考官网手册(http://doc.vue-js.com/v2/guide/forms.html)\n意义：如果给后台传递一个form表单的数据，不用再 一个一个的获取每个input等元素的值；而可以一次性传递一个对象\n生命周期 作用 生命周期的作用：某个动作 都有一个流程，当执行到该流程的某一个阶段时，会自动触发一些函数\n注意:生命周期函数与methods和el等标签同级\n详细的说明参见官方文档(https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA)\n动画效果 显示：Enter\n隐藏：Leave\n三个阶段： 初始阶段： v-enter/v-leave  过渡阶段： v-enter-active / v-leave-active  结束阶段： v-enter-to/v-leave-to  v- 是这些类名的前缀。使用 \u0026lt;name=\u0026quot;my-transition\u0026quot;\u0026gt; 可以重置前缀，比如 v-enter 替换为 my-transition-enter。\n过滤器 {{ message | filterA | filterB }}\n{{msg | 过滤器1 | 过滤器2 }}\nmoment.js 时间格式化，去官网下载js文件\n引入\n注册过滤器  //过滤：注册-\u0026gt;使用 (西方日期 -\u0026gt;格式) //es6:函数默认参数值 Vue.filter('dateFilter' , function(value, dateFormat='YYYY-MM-DD HH:mm:ss' ){ return moment(value).format(dateFormat) ; })  使用过滤器 {{ now | dateFilter('YYYY-MM-DD')}}  自定义指令 v-text-upper\nv-text-lower\n定义指令的名字是v-是不需要我们写的，只需要写右边的部分即可\n全局指令 与var vm = new Vue({})同级（与全局变量定义类似）\n 注册全局指令\nVue.directive('text-upper',function(el,binding){ el.innerHTML= binding.value.toUpperCase(); })  使用\n\u0026lt;p v-text-upper=\u0026quot;myVariable\u0026quot;\u0026gt;\u0026lt;/p\u0026gt; myVariable : \u0026quot;Hello World\u0026quot;,   局部指令 在var vm = new Vue({})中定义 （与局部变量定义类似）\n 注册局部指令\n//注册局部指令 directives:{ 'text-lower' :{ bind(el,binding){ el.innerHTML= binding.value.toLowerCase(); } } }  使用\n\u0026lt;p v-text-upper=\u0026quot;myVariable\u0026quot;\u0026gt;\u0026lt;/p\u0026gt; myVariable : \u0026quot;Hello World\u0026quot;,   自定义插件 详细参见官方文档\n开发插件 例\n(function(){ const MyPlugin = {} ; MyPlugin.install = function (Vue, options) { // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () { alert('全局方法或属性'); } // 2. 添加全局资源 Vue.directive('my-directive', {//v-text-upper bind (el, binding, vnode, oldVnode) { // 逻辑... } }) // 3. 注入组件选项 .每次实例vue对象中调用一次 Vue.mixin({ created: function () { // 逻辑... alert('mixin'); } }) // 4. 添加实例方法（局部） Vue.prototype.$myMethod = function (methodOptions) { // 逻辑... alert('局部') ; } } //将插件 暴露给外部使用 window.MyPlugin = MyPlugin ; })()  使用插件  引入(js文件)\n 使用插件\nVue.use(MyPlugin); //全局：static //类名.静态方法() Vue.myGlobalMethod(); //对象.方法() vm.$myMethod();   vue脚手架开发 vue脚手架指的是vue-cli，它是一个专门为单页面应用快速搭建繁杂的脚手架，它可以轻松的创建新的应用程序而且可用于自动生成vue和webpack的项目模板。\n安装 npm install -g vue-cli  下载模板 vue init webpack my_vue_cli  需要配置一些基本信息，不配置的话就一路回车\n注意： 根据提示 安装附加组件，安装时输入项目名时不能包含大写字母。安装时，不要随意点鼠标，点击鼠标右键可以恢复。\n根据提示\ncd my_vue_cli npm run dev  打包运行项目  生成dist目录\nnpm run build  安装服务组件(静态服务)\nnpm install -g serve\n 运行 serve dist\n 动态服务(tomcat)\n 配置webpack.prod.conf.js\noutput: { ... publicPath: '/myvue/' --\u0026gt;配置访问时的项目名  打包成dist\n 将dist拷贝到tomcat/webapps中，并且再将dist修改成myvue\n 启动tomcat,运行\n   vuecli源码解读 npm run dev 触发了哪些文件  dev -\u0026gt;package.json -\u0026gt;build/webpack.dev.conf.js -\u0026gt;./webpack.base.conf -\u0026gt;./src/main.js引用时的名字叫app\n 根据web基础知识可知： http://localhost:8080 实际是访问http://localhost:8080/index.html\n index.html:\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; -\u0026gt;会被src/App.vue中的\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;内容注入：\n  src/App.vue中内容\n\u0026lt;router-view/\u0026gt; ：路由，映射关系 localhost:8080/b\u0026ndash;\u0026gt; xxx本项目的映射： localhost:8080/ \u0026ndash;\u0026gt;HelloWorld.vue\n配置路由：\u0026lt;router-view/\u0026gt;: router/index.js 文件\n  小结 npm run dev -\u0026gt; main.js localhost:8080 / :index -\u0026gt; router -\u0026gt; HelloWorld.vue中的内容  app.vue中直接引入helloworld.vue  引入helloworld.vue\n\u0026lt;script\u0026gt; import HelloWorld from './components/HelloWorld'  将引入的文件打成一个组件\nexport default{ xxxxxx, components:{ HelloWorld } }  使用组件\n以标签的形式使用\n\u0026lt;HelloWorld\u0026gt;\u0026lt;/HelloWorld\u0026gt;   ESlint 代码规范检查工具，官网\n可以检测\n 空格个数 空行 变量名 代码是否未被使用 \u0026hellip;  如果不规范，则警告 或报错\n检测规则  \u0026ldquo;off\u0026rdquo; 或 0 - 关闭规则 \u0026ldquo;warn\u0026rdquo; 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出) \u0026ldquo;error\u0026rdquo; 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)  设置某些检查规则：.eslintrc.js文件\n全局设置是否启用ESlint：.eslintignore文件\n注意：\n初学：关闭\n真实的开发项目：打开，帮助规范代码的编写\nvue文件 组成 \u0026lt;template\u0026gt; \u0026lt;script\u0026gt; \u0026lt;style\u0026gt;  export default { name: '名字' , data(){ return msg: 'xxx' }， omputed:{}, methods:{}, components:{//组件} }  vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 vue中文官网\n开发一个简单的状态管理 ","id":0,"section":"posts","summary":"vue介绍 vue是一个渐进式的JavaScript框架。渐进式：可插拔式、可扩展。 我们刚开始只需要使用最核心的核心库，后期可以自己去增加新库","tags":["前端框架"],"title":"Vue自学笔记","uri":"https://mumulx.github.io/2019/12/vue%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" Express 简介 什么是Express express是一个基于node.js的极简、灵活的web开发框架。可以实现非常强大的web服务器功能。\nExpress的特点  可以设置中间件响应或过滤http请求。 可以使用路由实现动态网页，响应不同的http请求。 内置支持ejs模板(默认是jade模板)实现模板渲染生成html。  express-generator生成器 express-generator是express官方团队为开发者准备的一个快速生成工具，可以非常快速的生成一个基本的express开发框架。\nexpress的安装使用 安装express-generator生成器 cnpm i -g express-generator //安装 完成后可以使用express命令，需要安装淘宝镜像 npm i -g express-generator//直接安装，较慢  注意:可能需要以管理员身份运行cmd\n创建项目 express -e 项目名称//自动创建项目目录 express -e //手动创建项目目录  安装依赖 cnpm install cnpm i//简写 npm install npm i//简写  开启项目 node app npm start//自动查找当前目录下的package.json文件 node ./bin/www  node app\n需要手动添加监听端口，打开app.js添加以下内容：\napp.listen(80,function(){ console.log(\u0026quot;服务器已运行\u0026quot;); });  监听端口为:80\nnpm start：默认监听端口为:3000\n测试项目 打开浏览器输入localhost或127.0.0.1\n目录说明  bin 可执行文件目录 node_moudles 依赖包的目录 public 静态文件根目录  所有的静态文件都应该放在这个目录的下面(静态html,css,js,图片，字体，视频资源等)  routes 路由模块目录，动态文件的目录  优先找静态文件，如果没有静态存在则找动态路由，如果动态路由也没有就404  views 视图目录  用于存储所有的ejs模板   文件说明  app.js 项目的主文件  对整个项目的所有的字眼进行统筹的安排   var indexRouter = require('./routes/index');//引入处理根目录请求的路由 var usersRouter = require('./routes/users');//引进处理users目录请求的路由 app.use('/', indexRouter);//分配根目录下的请求给index去处理 app.use('/users', usersRouter);//分配users目录下的请求给users模块去处理 app.set('views', path.join(__dirname, 'views'));//设置模板的默认目录 app.set('view engine', 'ejs');//设置模板引擎为ejs模板 app.use(express.static(path.join(__dirname, 'public')));//设置静态文件目录   package.json 项目描述文件  生命项目的名称、版本、依赖包等信息   路由 什么是路由 路由是指接收用户请求，处理用户数据，返回结果给用户的一套程序。可以理解为：生成动态网页的程序。\n后端路由的核心: URL\nexpress对象自带有一个Router类，可以实例化出路由对象，可以在该对象上挂载非常多的路由节点。\n路由的写法 挂载路由线路的写法：\nrouter.请求方式('请求地址',function(req,res){ res.send('数据'); });  创建一个独立的路由模块 需求:创建一个vip路由模块，接收vip目录下的所有请求，响应数据。\n实现步骤：\n 创建一个vip路由模块\n 编写路由模块的代码(在Router文件夹下新建vip.js)\na. 引入express模块\nb. 实例化路由对象\nc. 编写路由线路挂载到路由对象上\nd. 暴露路由对象\n  代码：\nvar express = require('express');//引入express模块 var router = express.Router();//利用Router类创建一个路由的实例 //编写list.html用于展示所有的vip用户 router.get('/list.html', function(req, res, next){ res.send('\u0026lt;h1\u0026gt;张三，李四，王五\u0026lt;/h1\u0026gt;'); }); router.get('/info.html', function(req, res, next){ res.send('\u0026lt;h1\u0026gt;张三:23，李四:23，王五:24\u0026lt;/h1\u0026gt;'); }); module.exports = router;  注意:写请求路径news.html时不需要添加父路径/vip\n 将编写好的路由模块引入到主模块中，由主模块分配对应的请求到该模块中去处理(主模块为app.js)  代码\nvar appRouter = require('./routes/vip');//引入vip模块 app.use('/vip',appRouter);//分配vip目录下的请求给vip路由模块去处理  路由的区分 大路由(总路由) : app.js负责接收所有请求，对请求进行分配\n小路由(分路由) : /routes下面的所有路由模块，只负责处理自己能管理的目录下的所有请求\n响应对象 什么是响应对象 响应对象（res）是指服务器向容户端响应数据的对象，包含了所有要响应的内容\n响应对象的方法 res.send() //返回任意类型的数据 例：\nrouter.get('/',function(req,res){ //res.send('hello world'); //可以返回字符串数据 //var data={\u0026quot;name\u0026quot;:\u0026quot;李白\u0026quot;, \u0026quot;age\u0026quot;:999}; //res.send(data); // 也可以返回一个JSON数据 //res.send(1);//返回数字，即状态码 //res.send('1');//返回数字1 //返回状态码+数据链式调用 // res.status(404).send(\u0026quot;页面不见啦。。。。\u0026quot;); });  注意：\n 如果返回一个数字，就会被当成状态码，容易报错。 send方法能且仅能出现一次，重复无效且会报错，不写的话会挂起  res.json(); 返回JSON数据，自动设置相应头\n和send方法传递JSON数据的区别不大\n例\nrouter.get('/',function(req,res){ //var data={\u0026quot;name\u0026quot;:\u0026quot;李白\u0026quot;, \u0026quot;age\u0026quot;:999}; //res.json(data); // 返回json自动设置响应头 });  自己新建模板文件list.ejs 代码\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;用户列表\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;%for(var i in users){%\u0026gt; \u0026lt;li\u0026gt;姓名：\u0026lt;%=users[i].name%\u0026gt;====年龄:\u0026lt;%=users[i].age%\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;%}%\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  res.render(\u0026ldquo;模板名称\u0026rdquo;,{数据}); 读取模板文件，拼接数据（必须是json数据），自动将结果发送给浏览器\n模板名称直接写，路径在app.js文件中已经配置过了(即views目录下的文件)\n例\nrouter.get('/',function(req,res){ var data = [ {\u0026quot;name\u0026quot;:\u0026quot;aa\u0026quot;,\u0026quot;age\u0026quot;:\u0026quot;11\u0026quot;}, {\u0026quot;name\u0026quot;:\u0026quot;bb\u0026quot;,\u0026quot;age\u0026quot;:\u0026quot;22\u0026quot;}, {\u0026quot;name\u0026quot;:\u0026quot;cc\u0026quot;,\u0026quot;age\u0026quot;:\u0026quot;33\u0026quot;}, {\u0026quot;name\u0026quot;:\u0026quot;dd\u0026quot;,\u0026quot;age\u0026quot;:\u0026quot;44\u0026quot;} ]; //模板渲染 res.render('list.ejs',{users:data}); });  res.download 下载 res.download('./xxx.doc');//下载当前目录下面的xxx.doc文件。 res.download('./xxx doc, 'yyy.doc');//下载当前目录下面的xxx.doc文件，并且重命名为yyy.doc.  res.redirect(\u0026lsquo;目标\u0026rsquo;) 服务器端的跳转\nres.redirect('www.baidu.com');  完整api 1. res.app:同req.app一样 2. res.append():追加指定HTTP头 3. res.set()在res.append()后将重置之前设置的头 4. res.cookie (name,value[,option]) :设置Cookie opition:domain/expires/httpOnly/maxAge/path/secure/signed 5. res.clearCookie():清除Cookie 6. res.download():传送指定路径的文件 7. res.get():返回指定的HTTP头 8. res.json():传送JSON响应 9. res.jsonp():传送JSONP响应 10. res.location():只设置响应的Location HTTP头,不设置状态码或者closeresponse 11. res.redirect():设置响应的Location HTTP头，并且设置状态码302 12. res.send():传送HTTP响应 13. res.sendFile(path[,options][,fn]) :传送指定路的的文件-会自动根据文件extension 设定Content-Type 14.res.set():设置HTTP头，传入object可以一次设置多个头 15. res.status():设置HTTP的状态码 16. res.type():设置Content-type的MIME类型  请求对象 什么是请求对象 客户端向服务器发送数据的对象，包含请求头和请求主体\n接收GRT方式传的值 req.query.参数名  例\nrouter.get('/content.html',function(req,res){ var id=req.query.id; res.send('获取到的ID是:'+id); });  接收POST方式传的值 req.body.参数名\n例：\nrouter.post('/login.html',function(req,res){ var username=req.body.username; var pwd=req.bady.pwd; res .send('你传的用户名是:'+username+',你传的密码是:'+pwd); });  匹配URL网址上的数据 在接请求地方去匹配，再通过语法进行接收，\n语法：\nreq.params.参数名\n请求：\nlocalhost:/news/abc  例：\nrouter.get('/news/:id',function(req,res){ //自动匹配news/后的值作为id的值 var id=req.params.id; res. send('\u0026lt;h1\u0026gt;接收到的参数是: '+id+'\u0026lt;/h1\u0026gt;'); });  完整api 1. req.app:当callback为外部文件时，用req.app访问express的实例 2. req.baseUrl:获取路由当前安装的URL路径 3. req.body/req.cookies:获得「请求主体」/Cookies 4. reg.fresh/req.sale:判断请求是否还「新鲜」 5. req.hostname/req.ip:获取主机名和IP地址 6. req.originalUrl:获取原始请求URL 7. req.params:获取路由的parameters 8. req.path:获取请求路径 9. req.protocol:获取协议类型 10. req-query:获取URL的查询参数串 11. req.route:获取当前匹配的路由 12. req subdomains:获取子域名 13. req.accpets():检查请求的Accept头的请求类型 14. req.acceptsCharsets/req.acceptsEncodings/req.acceptsLanguages 15. req.get():获取指定的HTTP请求头 16. req.is():判断请求头Content-Type的MIME类型  中间件 Express是一个自身功能极简，完全是由路由和中间件构成一个的web开发框架:从本质上来说，一个Express应用就是在调用各种中间件。\n什么是中间件 中间件就是一个函数，位于客户端与路由之间，可以访问请求对象和响应对象，也可以调起下一个中间件。\n自定义中间件 app.use(function(req,res,next){ res.send('我是中间件'); //next(); });  尾函数next 如果在中间件不调用next函数，整个请求响应流程就中止不会再往后面执行。\n调用尾函数相当于调用下一个中间件，执行完以后自己的函数继续执行。\n例：编写一个记录用户访问的中间件\napp.use(function(req,res,next){ var fs=require('fs'); var ip=req.ip; var time=new Date().toLocaleString(); var data=fs.readFileSync('./2019-12-09.1og'); data+='访问时间:'+time+'IP: '+ip+'\\n'; fs.writeFileSync('./2019-12-09.1og',data); next();| });  ","id":1,"section":"posts","summary":"Express 简介 什么是Express express是一个基于node.js的极简、灵活的web开发框架。可以实现非常强大的web服务器功能。 Expre","tags":["node"],"title":"Express框架","uri":"https://mumulx.github.io/2019/12/express%E6%A1%86%E6%9E%B6/","year":"2019"},{"content":" 常见的操作  发布项目（share project）：项目组长将本机的项目第一次发布到中央仓库中\n 下载项目（check out）：（检出项目：check out），组员将中央仓库的项目第一次下载到本机\n 更新（update）：将服务器中的最新的代码，同步到本机 (服务器\u0026ndash;\u0026gt;本机)\n 提交（commit）：将本地修改的内容，同步到服务器中（本地\u0026ndash;\u0026gt;服务器）\n  注意：更新和提交一定要及时，即：\n提交：在编写完某一个小功能，每天下班前提交 更新：编写功能前，每天上班前更新 编写之前先更新，写完之后立刻提交  svn的安装配置 下载 下载地址\nwindow下载地址\n配置 环境变量配置：一般是自动配置，可以进入环境变量(Path)检验一下，如果没有配置的话，则将root/bin目录配置到环境变量。\n验证是否安装成功 win+r\ncmd\nsvn --version\n出现一下代码则安装成功\nsvn，版本 1.8.17 (r1770682) 编译于 Nov 30 2016，13:25:58 在 x86-microsoft-windows Copyright (C) 2016 The Apache Software Foundation. This software consists of contributions made by many people; see the NOTICE file for more information. Subversion is open source software, see http://subversion.apache.org/ 可使用以下的版本库访问模块: * ra_svn : 使用 svn 网络协议访问版本库的模块。 - 使用 Cyrus SASL 认证 - 处理“svn”方案 * ra_local : 访问本地磁盘的版本库模块。 - 处理“file”方案 * ra_serf : Module for accessing a repository via WebDAV protocol using serf. - using serf 1.3.9 - 处理“http”方案 - 处理“https”方案  配置中央仓库 中央仓库：保存项目的各个版本\n使用本地文件夹模拟中央仓库：\n svnadmin create 文件夹目录  例：\nsvnadmin createC:\\\\workplace\\\\svn\\\\svnck  注意：文件夹要为空\n启动svn服务 命令行方式(不推荐) svnserve -d -r 仓库目录  例\nsvnserve -d -r C:\\workplace\\svn\\svnck  注意：此时命令行窗口不能关闭，关闭之后服务就会终止\n注册系统方式(推荐) 在cmd中运行\n注意：cmd要以管理员身份运行\nsc create 服务名 binpath=\u0026quot;安装目录\\bin\\svnserve.exe --service -r 仓库位置\u0026quot; start=auto depend=Tcpip  例：\nsc create mysvn binpath=\u0026quot;C:\\RJ\\svn\\bin\\svnserve.exe --service -r C:\\workplace\\svn\\svnck\u0026quot; start=auto depend=Tcpip  出现以下代码则成功\n[SC] CreateService 成功  启动服务的两种方式 方式一(命令行)： 启动：sc start 服务名\n关闭：sc stop 服务名\n删除 sc delete 服务名\n方式二(服务列表)： 服务列表所在位置：开始-\u0026gt;windows管理工具-\u0026gt;服务\n访问项目 匿名访问 开启匿名访问 打开项目仓库的conf目录下的svnserve.conf文件找到\n# anon-access = read # anon-access = write # anon-access = none  三者者三选一，\n# anon-access = read 表示开启匿名访问后指允许读；\n# anon-access = write 表示开启匿名访问可读可写；\n# anon-access = none 表示什么也不能操作（一般选择）；\n注意：去掉#的时候把空格也要去掉，顶格写，否则可能会出错！\n授权访问 开启授权访问 打开项目仓库的conf目录下的svnserve.conf文件找到\n# auth-access = write # password-db = passwd # authz-db = authz  # password-db = passwd 表示授权人的用户名密码存放在passwd文件（授权文件）中。\n# authz-db = authz 表示授权访问的权限标识符，权限文件存放在authz中。\n注意：去掉#的时候把空格也要去掉，顶格写，否则可能会出错！\n编写用户文件 打开passwd文件（授权文件）在svnserve.conf文件的同级目录，在[users]下面添加用户名密码。采用键值对的形式用户名=密码。\n例如：\naa=123 bb=abc  编写授权文件 在[groups]下面创建分组\n例\ndev=aa,bb  对分组进行权限编写，例\n[/] @dev=rw *=  表示dev组的人员对项目根目录下的文件具有读和写的操作，其他人员没有权限。\n在Eclipse中使用SVN 默认eclipse是不支持svn的\n配置 离线方式 将eclipse_svn_site-1.10.5插件放入eclipse的安装目录的dropins子目录下，需要解压。\n在线方式 打开eclipse\u0026ndash;\u0026gt;help\u0026ndash;\u0026gt;Eclipse Marketplace 搜索：subversion/subeclipse，下载安装即可（可能比较慢）。\n检查 启动eclipse在项目中右键Team\u0026mdash;\u0026gt;Share Project会出现SVN选项。\n使用 发布项目 项目中右键Team\u0026mdash;\u0026gt;Share Project-\u0026gt;SVN\u0026ndash;\u0026gt;创建新的资源库位置\u0026ndash;\u0026gt;ur:svn://127.0.0.1\u0026ndash;\u0026gt;finish\u0026ndash;\u0026gt;右键项目\u0026ndash;\u0026gt;提交;\n需要输入用户名和密码，\n打开项目会发现代码后面有黄色的状态码\n黄色圆柱：本地无未提交代码 */灰色箭头：本地有未提交的代码 红色！：有冲突 蓝色箭头：服务端有最新代码，本地还没有更新  下载项目 file\u0026ndash;\u0026gt;import\u0026ndash;\u0026gt;从svn检出项目\u0026ndash;\u0026gt;next-\u0026gt;ur:svn://127.0.0.1\u0026ndash;\u0026gt;next\u0026ndash;\u0026gt;finsh\n提交代码 单个提交\n代码右键\u0026ndash;\u0026gt;team\u0026ndash;\u0026gt;提交\n多文件提交\n项目右键\u0026ndash;\u0026gt;Team\u0026ndash;\u0026gt;与资源库同步\u0026ndash;\u0026gt;ctrl选中多个文件\u0026ndash;\u0026gt;右键提交\n更新代码 单个文件\n代码右键\u0026ndash;\u0026gt;team\u0026ndash;\u0026gt;更新\n多个文件\n项目右键\u0026ndash;\u0026gt;Team\u0026ndash;\u0026gt;与资源库同步\u0026ndash;\u0026gt;ctrl选中多个文件\u0026ndash;\u0026gt;右键更新\n或\n右键项目\u0026ndash;\u0026gt;Team\u0026ndash;\u0026gt;更新\n注意：当提交项目或下载项目时，点击了保存密码，一但密码出错，很难更改密码，或更换用户；\n更改svn用户密码 进入C:\\Users\\当前用户\\AppData\\Roaming\\Subversion\\auth 删除文件夹中的所有文件即可重新填写用户，密码。\n解决冲突 一般更新或提交时会发现冲突\n右键项目\u0026ndash;\u0026gt;Team\u0026ndash;\u0026gt;与资源库同步\u0026ndash;\u0026gt;红色箭头表示冲突文件\n右键编辑冲突\u0026ndash;\u0026gt;修改\u0026ndash;\u0026gt;右键文件\u0026ndash;\u0026gt;team\u0026ndash;\u0026gt;标记为解决；重新提交。\n查看和恢复历史版本 右键\u0026ndash;\u0026gt;Team\u0026ndash;\u0026gt;显示资源历史记录\n查看版本：双击\n恢复所选版本:右键\u0026ndash;\u0026gt;获取内容\n注意：如果报错，则需要设置svnserve.conf 文件中的anon-access=none\nsvn发布到外网 第一种 当网段不在同一个网段上时，可以借助nat123将局域网ip映射到外网ip；通过访问外网ip来访问中央仓库。\n第二种 租赁服务器，将项目发布到服务器中\n第三种 使用svn托管的网站，\n","id":2,"section":"posts","summary":"常见的操作 发布项目（share project）：项目组长将本机的项目第一次发布到中央仓库中 下载项目（check out）：（检出项目：chec","tags":["版本控制"],"title":"Svn学习笔记","uri":"https://mumulx.github.io/2019/12/svn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" node.js简介 简单来说node.js就是js的一个运行环境，可以运行js代码，用于服务器端编程。\n下载安装 下载node.js\n安装：一路next\nnode使用 进入项目目录运行cmd\nnode 文件名(.js)  .js可写可不写，因为node能且仅能运行js文件\n模块组成 所有用户编写的代码都放在模块中，模块就是文件(函数)\n用户编写的代码在nodejs运行时都会自动放在一个函数中，所以一个文件就是一个模块\n用户编写的代码都自动封装在一个函数中\nfunction(exports,require,module,_filename,_dirname){}  函数有五个参数:\nexports 暴露对象，可以将模块中的数据暴露给引入的地方 require 引入模块的函数， 用于在一个模块中引入另外一个模块，并且将子模块暴露的数据赋值给变量 module 模块对象， 包含了当前模块的所有信息 __filename 当前模块的文件 名 __dirname 当前模块所在的路径(目录路径〉  nodejs的模块是指所有用户编室的代码都放在函数中，所有定义的函数或变量都是局部的，相互之间不受影响。如果模块之间需要共享数据，则需要使用module.exports是暴漏对象。\nrequire : 作用:在当前模块中加载另外一个模块\n模块分类:\n 自定义模块\n我们自己编写的文件就是一个自定义模块\n注意：\na.子模块没有暴漏数据，返回空对象\nb.自定义模块必须加./(指向当前模块)因为在node.js中查找模块默认在node_modules目录中去查找\n 第三方模块\n第三方程序员或公司开发的模块，先安装再使用\n安装可以使用npm包管理工具\nnpm install \u0026lt;包的名字\u0026gt;  引入 require(\u0026ldquo;模块名\u0026rdquo;)\n 系统模块\nnode.js开发团队已经开发好的功能模块，直接引入即可使用，不需要安装也不需要自己写\n例如：\nfs http url path \u0026hellip;.\n引入 require(\u0026ldquo;模块名\u0026rdquo;)\n  require函数的注意事项:\n1) 当引入的模块有语法错误时，会报错。 2) 当引入的模块路径有错时，也会报错。 3) 当一个模块被多次引入时，只执行一次,会将暴露对象直接写入缓存，以后就直接从缓存读取  exports导出对象: 作用:将模块中需要共享给其它模块的数据暴露(导出)到引用处\n语法:\nexports.属性名=值; exports .方法名=函数;  注意:\n1) exports 是module.exports对象的引用 2) exports 是module.exports的引用，不能改指向，只能添加属性和方法S 3) module.exports才是真正的暴漏对象，指向哪里就暴漏哪里  module模块对象: module.exports真正的暴露对象, exports对象只是对它的引用。\nmodule.exports.属性=值; module.exports.方法=函数; module.exports=对象或函数; module.id模块ID， 模块名称 module. parent模块的父级 module. filename模块的文 件名和路径 module.children子模块列表 module. paths模块查找路径，如果当前目录下找不到node_ modules就去上一级目录查找，直到根目录如果配置了NODE_ PATH环境变量， 则会再去环境变量指向的路径查找  控制合命令: console.1og() 普通输出语句 console.dir() 输出对象 console.errar() 警告输出 console.time(标识) 计时开始 console.timeEnd(标识) 计时结束 console.assert(表达式，输出文字) 当表达式为假时，输出文字  node. js的作用域: 由于node.js在执行里会将用户编写的所有代码都封装在函数中，所有用户定义的变量或函数都是局部的。\n要将数据共享给其它模块使用:\n1.暴露对象 module.exports 2.全局对象 global.工性或方法=值; 注意:使用时global关键字可以省略不写  npm 什么是NPM? npm(Node Package Manager)是基 于nodejs的包管理工具\n什么是包? 包===项目 模块===文件\n什么是package.json? package.json是node. js项目的包描述文件，以JSON格 式的形式描述项目\n如何创建package.json npm init npm init -y //自动以全部为yes的形式生成package . json文件  package .json的常用属性 name 项目名称 version 版本号 description 项目描述 main 主模块 dependencies 依赖列表 devDependencies 开发时依赖 scripts 脚本命令， 可以使用npm命令进行执行 license 开源协议 contibutors 包的其他贡献者姓名。  npm的常用命令 安装命令\nnpm install \u0026lt;包的名称\u0026gt; //安装指定的包 npm i //自动下载package.json中的依赖 npm i \u0026lt;包的名称\u0026gt; , //效果同上，缩写形式 npm i \u0026lt;包的名称\u0026gt;@版本号 //安装指定版本的包 npm i \u0026lt;包的名称\u0026gt; -g //全局安装 安装位置: C: \\Users \\Administrator\\AppData\\Roaming \\npm\\node_ modules 我的位置已修改C:\\Program Files\\nodejs\\node_global npm i \u0026lt;包的名称\u0026gt; --save //将安装包写入package .json依赖列表 npm i \u0026lt;包的名称\u0026gt; --save-dev //将安装包写入package .json开发时依赖列表 //其它命令 npm search \u0026lt;包的名称\u0026gt; , /搜索包 npm view \u0026lt;包的名称\u0026gt; //查看 包的信息 npm uninstall \u0026lt;包的名称\u0026gt; //卸载包 npm update \u0026lt;包的名称\u0026gt; 更新包  cnpm npm 就是一个文件下载工具，默认情况下去 npmjs.com/github. com下载资源\ncnpm 由于在国内下载npmjs. com的数据非常慢，所以淘宝制作了一个npmjs.com的镜像(可以下载，不能上传)，直接访问国内的网站下载较快用法和npm一毛一样。\n安装：\nnpm install -g cnpm --registry=https://registry.npm.taobao.org  回调函数 什么是回调函数? 回调函数又称为回调，将a函数作为参数传入b函数中，b函数在执行过程中根据时机或条件决定是否调用a函数，a函数就是回调函数。\n异步的三种实现方式:\n1. 回调函数 回调函数不一定是异步，但是异步定有回调函数 2. 事件 3. promise  回调函数 //异步-定有回调函数\nsetTimeout(function(){ console.1og('....' ); }, 1000);  //回调函数不一定是异步\nconsole. log( '1111'); var arr=[1,2,3,4]; arr.forEach(function(v,i){ console.1og(v); }); console.1og('2222');  时间 事件源.on('事件名称',回调函数)  promise承诺对象:  什么是promise\npromise是ES6中新增的承诺对象，用于对异步的操作进行消息的传递。\n promise的状态\n Pending 等待中 Resolved 成功 Rejected 失败 Pending =\u0026gt; Resolved Pending =\u0026gt; Rejected  promise有什么用?\npromise可以用于传递异步消息\n  缓存区: 什么是缓存区 在内存中开辟-个临时区域用于存 储需要运算的字节码\n创建缓存区 创建指定长度的缓存区 var buf = new Buffer(5);  按指定的数组（编码）创建缓存区 var buf=new Buffer([97,98,99,65,66]);  按指定字符创建缓存区 var buf=new Buffer( '字符串' ) ;  写入缓存区 buf.write('字符串' );  读取缓存区 buf.toString();  缓存区复制 buf.copy(buf2);  文件系统操作 读取文件 由于node.js是服务器端程序，必须要有读写文件操作，在客户端没有这样的功能。\n文字读写有两种方式:\n直接读取 将硬盘上的所有内容全部读入内存以后才触发回调函数\n两种写法:\n异步:\nfs.readFile('./file1.txt',function(err.data){ console.log(data.toString()); });  同步:\nvar data = fs.readFileSync('./file.txt');  注意：一般同步的方法都是在异步的方法后面添加Sync\n流式读取 下面会专门讲。\n写文件: 同步版本  fs.writeFileSync('文件名','数据');  异步版本 fs.writeFile('文件名',数据,function(err){ //写完文件以后执行的代码 });  例\n//文件读取 //如果要读写文件，必须使用文件系统模块(fs) var fs=require('fs'); //直接读取文件---异步 fs.readFile('./file1.txt',function(err.data){ console.log(data.toString()); }); //同步 var data = fs.readFileSync('./file.txt'); console.log(data); console.log(data.toString()); //异步写文件 var hello=\u0026quot;\u0026lt;h1\u0026gt;Hel1o Node.js\u0026lt;/h1\u0026gt;\u0026quot;; fs.writeFile( 'index.html', hello,function(err){ if(err){ throw err; }else{ console.1og('文件写入成功'); } });  读取文件信息 fs.stat(' ./file1.txt',function(err,state){ console.log(state); });  属性解析\nsize 文件大小(字节) mtime 文件修改时间 birthtime 文件创建时间  方法解析\nisFile() 判断当前查看的对就是不是一个文件 isDirectory() 判断是不是一个目录  删除文件 fs.unlink('./jquery.js',function(err){ if(err){ throw err; }else{ console.log( '删除成功') ; });  例\n需求:编写代码实现删除一个非空目录\n使用代码删除某个文件夹，该文件夹不为空。\n使用递归函数实现，逐层查询并清空文件再删除空文件夹\n 定义一个函数，用于实现递归调用。\n 删除空文件夹(删不掉，目录非空)\n 读取文件夹的内容(文件及文件夹列表)\n 遍历数组一个一个获取文件信息\n 判断是否为文件，如果是文件则删除\n 判断是否为目录，如果是目录就调用自己(递归的入口)\n  代码\nfunction deldir(p){ //读取文件央的内容 var list=fs.readdirSync(p); //遍历数组 for(var i in list){ //list[i]是当前目录中每个文件及文件夹的名称 var path=p+'/'+list[i]; //拼接 一个从(05.js)当前目录能查找到的路径 var info=fs.statSync(path); if(info.isFile()){ fs.unlinkSync(path); //如果是文件则删除文件 }else{ arguments.callee(path);//如果不是文件就是目录，则调用自己再删除该目录 } } fs.rmdirSync(p); //删除空文件夹 } deldir('./aa');  文件流 什么是流 所有互联网传输的数据都是以流的方式，流是一组有起点有终点的数据传输方式\n流的操作 流式读取文件 一节一节的读取数据，一节64kb ==\u0026gt; 65536字节\n以流的方式写文件 一节一节的写文件\n例\n读入流\n//创建一个可以读取的流 var stream=fs.createReadStream('./file1.txt'); //绑定data事件，当读取到内容就执行 stream.on( 'data',function(a){ console.log('------------------'); console.log(a.length); }); //读取流的事件: end完成事件 stream.on('end',function(){ console.log('数据读完了'); }); //读取流出错事件: error错误事件 stream.on('error'，function(err){ console.log(\u0026quot;读取出错\u0026quot;); //抛出错误 //throw err; });  写入流\nvar fs=require('fs'); //创建一个可以写入的流 var stream=fs.createWriteStream('./file2.txt' ); //写入数据 stream.write('张三失踪了'); stream.write('李四也失踪了'); stream.write('王小五也疯了'); stream.end(); //以流的方式写入数据 必须显示的声明结束 //on是绑定时事件 //写入流的事件: finish 完成事件 stream.on('finish',function(){ console.log('写完了'); }); //写入流的事件: error 错误事件 stream.on('error',function(err){ console.log( '出错啦'); });  需求:实现大文件的复制\nvar fs=require('fs'); var s1=fs.createReadStream('./file3.txt'); var s2=fs.createWriteStream('./file6.txt'); //以流的方式 //以流的方式实现大文件复制，读取一节存一节 s1.on('data',function(a){ s2.write(a); }); s1.on('end',function(){ s2.end(); console.log(\u0026quot;文件复制已完成!\u0026quot;) ; }); //以管道的形式 s1.pipe(s2);  链式流:\n将多个管道连接起来，实现链式处理。\n需求:使用链式流实现大文件压缩!\n代码\nvar fs=require('fs'); var zlib=require('zlib'); var s1=fs.createReadStream('./file3.txt'); var s2=fs . createWriteStream('./file3.txt.zip'); s1.pipe(zlib.createGzip()).pipe(s2);|  path模块 什么是path模块? path模块是node.js中提供的一个系统模块，用于格式化或拼接一个完整的路径\npath模块的常用方法  path.join() //将多 个字符串拼接成一-个完整的路径 path.dirname() / /返回路径中的文件夹部分 path.basename() / /返回路径中的文件部分(文件名和扩展名) path.extname( ) / /返回路径中的扩展名部分 path.parse()/ / 解析路径:近回一个对象包含路径中的各个部分  URL模块: 什么是URL? url全球统一资源定位符， 对网站资源的一种简洁表达形式，也称为网址。\nURL 的构成 构成：\n协议://用户名:密码@主机名.名.城:端口号/目录名/文件名.扩展名?参数名=参数值\u0026amp;参数名2=参数值2#hash\nhttp协议的URL常见结构:\n协议://主机名.名.域/目录名/文件名.扩展名?参数名=参数值\u0026amp;参数名2=参数值2#hash\nhttps默认的端口号是443\nhttp默认的端口号是80\nnode. js的URL模块 在node.js中提供了两套对于url进行处理的API功能。\n 老的node.js url模块\n 新的url模块 (WHATWG URL标准模块》\n  什么是网络 网络是一个共享、传输信息的虚拟平台。\n什么是网络协议 每天有大量的数据在网络上传输，都需要遵循相应的规则，规则就是网络协议。\n什么是http协议 http (hypertext transfer protocol) 即超文本传输协议，传输超文本内容(文字、图片、视频、音频、动漫\u0026hellip;\nhttp协议规定了数据在服务器与浏览器之间传输数据的格式和过程。\nhttp协议规定 的细节 http协议是一种请求应答形式的协议，一次请求， 一次应答(响应)。\n细节: 1. 定义了浏览器以什么格式向服务器发请求， 2. 定义了服务器以什么格式解析浏览器发送过来的数据， 1. 定义了服务器以什么格式响应数据给浏览器， 1. 定义了浏览器以什么格式解析服务器响应的数据\n软件开发模式  单机软件\n打开电脑就能用，不需要网络，如: HBuilder、Word.西图\u0026hellip;.\n  2) C/S软件\n客户端Client /服务器端 Server 需要下载安装以后，才能连接网络使用，如:迅雷、QQ、微信....  3) B/S软件\n浏览器BrowEr /服务器端 Server 打开网址直接使用，不需要安装，如:百度、淘宝、JD....  注意：所有浏览器发起的请求都是get方式，post请求只能通过表单提交发起\nhttp模块:  get方法  get方法用于模仿客户端从服务器获取数据\nhttp.get('url',function(res){ //res是返回对象，接收到服务器响应的所有内容 });  网络爬虫程序 什么是爬虫? 网络爬虫又被称为网页蜘蛛或网络机器人，是一种按照一定的规则， 自动地抓取万维网信息的程序。\n案例：写一个爬虫程序从nipic. com批量下载图片 url: http://www. nipic. com/ photo/jianzhu/ shinei/index. html\n开发思路:\n1)打开网页查看内容，找图片地址 找规律=\u0026gt;查看网页源代码 小图: http://img90.nipic. com/file/20180110/5792316151721347529 1.jpg 大图: http://pic152.nipic. com/fne/20180110/5792316_ _151721347529_ _2.jpg 2)编写代码实现打开网页，获取所有的html内容 3)通过正则表达式提取出有哪些图片地址 4)遍历图片地址数组，一个一个请求 5)将获取到的图片数据保存在硬盘上  代码：\nvar http=require('http'); http.get('http://www.nipic.com/photo/jianzhu/shinei/index.html',function(res){ var data=''; //定义一个变量用于存放一段一段的HTML数据 //以流的方式读取数据 res.on('data',function(a){ data+=a. toString(); }; //绑定end事件 res.on('end',function(){ //data 就是当前网页的HTML内容 //编写正则表达式提取所有的图片地址 var reg=/\u0026lt;img src=\u0026quot;(.+?)\u0026quot; alt=\u0026quot;.*?\u0026quot;\\/\u0026gt;/img; //exec正则表达式方法，获取匹配到的结果，只能获取一个，指针自动向下移动 var arr =[]; var result=\u0026quot;\u0026quot;; while(result= reg.exec(data)){ arr.push(result[1]); } for(var i in arr){ (function(i){ setTimeout(function(){ getImg(arr[i]); },3000*i); })(i); } }); }); //定义一个函数用于获取图片内容 function getImg(ur1){ //console.log('修改前: ' ,ur1); ur1=ur1.replace(/img\\d\\d/,'pic152').replace('1.jpg','2.jpg'); //console.log('修改后:',url); http.get(ur1, function(res){ var fn=new Date().getTime(); //创建一个可写流 var stream=fs.createwriteStream('./files/'+fn+'.jpg'); res.pipe(stream); });\t}  小结 回调函数 什么是回调函数? 回调函数也称为回调(callback)，其实就是一个普通函数。将该函数作为另外一个函数的参数传入，由另外一个函数根据条件或时机决定调用\n回调函数的实现机制  定义一个普通函数(作为回调函数)\n 将该函数作为一个参数传入另外一个函数(调用者)中\n 调用者函数在具体的时机或条件达到时，调用该函数(回过头再调用的函数)\n  回调函数的作用 如果我们需要在某一个任务完成后，执行一段代码，可以使用回调函数\n异步与同步[重点] 什么是异步与同步? 同步:前一个任务完成以后，后一个任务才能继续执行(会造成阻塞)\n异步:将比较复杂的任务制作成异步模式(回调函数)，后一句代码不需要等待前一.句完成也可以继续执行(不会造成阻塞)\n异步的实现  回调函数 异步一定有回调函数，回调函数不一定是异步(一些同步的情况也会用到回调函数) 事件 触发事件以后执行一个回调函数，就是异步 事件源.on(事件类型,回调函数) ; promise promise (承诺)对象，实现异步的消息传递。  buffer缓存区 什么是缓存区? 缓存区就是在内存中开辟存储空间，用于存储字节码数据。\n缓存区操作 1.创建新的缓存区\nvar buf=new Buffer(10); var buf=new Buffer([97,98]); var buf=new Buffer('张三 ');  1.读取缓存区\nbuf.toString(); //将字节码转换成字符串  1.写缓存区\nbuf.write(\u0026quot;字符串\u0026quot;);  1.复制缓存区\nbuf1. copy(buf2);  文件基本操作(直接操作) 读取文件内容 //异步出错时自己定义抛出异常系统不会报错 fs. readFile('文件路径'，function(err, data){ //err是错误对象，如果有错则有值，没有错则为nu1l //data是数据(字符串) }); //同步:只要在异步的方法名后面加Sync就是同步版本 //出错时系统会自动报错 var data=fs.readFileSync( '文件路径);  读取文件信息 fs.stat('文件路径'，function(err, info){ //info就是文件的信息 .size文件的大小 .ctime文件的创建时间 .mtime文件的修改时间 .atime文件的访问时间 .birthtime文件的创建时间 //方法 .isFile()判断是不是 一个文件 .isDirectory()判断是不是一一个目录  写文件内容(新增、修改) fs .writeFile('文件路径'，数据内容，function(err){ //如果文件存在则修改 //如果文件不存在则新增 });  删除文件 fs.unlink('文件路径',function(err){ });  新增目录 fs.mkdir('目录路径',function(err,list){ //list是读取到的当前文件夹的所有文件及其子文件夹列表 });  读取目录中的文件列表 fs. readdir('目录路径', function(){ });  删除空文件夹 fs . rmdir('目录路径', function(err){ //只能删除空文件夹，不能删除非空文件夹 });  其它操作 改支件名或目录名...  流式读写 什么是流 流是一组有序的、有起点和终点的字节数据的传输方式(流式)。流的内容称为字节流。\n读取流 var stream=fs.createReadStream('文件路径'); //绑定data事件接收数据 stream. on('data',function(data){ console.1og(data); }); //绑定error错误事件 异步的方式 stream.on('error'function(err){ throw err; }); //绑定end结束事件 stream.on('end',function(){ console.log( '数据读取完毕'); });  写入流 var stream=fs.createWriteStream('文件路径'); //写入数据 stream.write('数据1'); stream.write('数据2'); stream.write('数据3'); stream.end(); //流式写入完毕时一 定要-个明确的结束标识 //绑定finish数据写入完成事件 stream. on('finish'，function(){ }); //绑定error出错事件 stream. on('error'，function(err){ });  管道pipe 什么是管道 管道(pipe)是一种输入流与输出流之间传输数据的机制\n管道的写法 输出流.pipe(输入流);  管道的作用 管道可以实现对大文件的操作(文件大小超过内存)\n链式流 将多个管道连接起来，进行链式操作。\n输出流.pipe(中转流). pipe(中转流).pipe(....). pipe(输出渝) ;  远程服务器(使用的是阿里云) 使用window的远程桌面命令:mstsc: 连接远程服务器，操作服务器。\n注意在网页的后面添加robots.txt就可以看到网站（例如：淘宝）的蜘蛛协议，它可以说明此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。\nnode.js服务器创建步骤  引入通信模块 创建服务器 监听request事件 监听端口 访问服务器:\n 打开浏览器 输入网址\n 127.0.0.1 本机地址\n localhost 本地主机，本地域名\n 172.16.3.224 局域网工IP(使用cmd命令行获取ipconfig)\n    例：\nvar http=require('http'); //创建服务器 var server=http.createServer(); //监听request请求事件， 当前请求事件发生时就返回数据 server.on('request',function(req,res){ //都是以流的方式来传送请求 //req: 请求对象，包含了所有客户端请求的数据，请求头、请求主体 //res:响应对象，包含了所有服务器端发送给客户端的数据，响应头、响应主体 res .write('\u0026lt;h1\u0026gt;He11o Node.js\u0026lt;/h1\u0026gt;'); res .write('\u0026lt;p\u0026gt;He1lo 1111\u0026lt;/p\u0026gt;'); res. end(); }); //监听服务器的80端口（默认的就是80，所以访问时不需要加端口号） //可以监听其他端口，但是访问时需要加端口号 server.listen(80, function(){ console.log( '服务器已运行...'); });  //组合写法 require('http').createServer(function(req,res){ res .write('\u0026lt;h1\u0026gt;He1lo world\u0026lt;/h1\u0026gt;'); res.end() ; }).listen(80,function(){ console.log( '服务器已运行...'); });  注意：可能需要的cmd命令\n//查看自己的电脑开了哪些端口 //netstat -a //查看端口被谁占用 //netstat -ab  服务器url 网页响应内容:\n可以根据用户请求的url不同，判断响应不同的数据，实现访问不同的URL得到不同的结果。 核心: req.ur1获取到用户请求的网址\n例\nvar http=require('http'); var server=http.createServer(); server.on('request',function(req,res){ if(req.url==='/'){ res.write(\u0026quot;\u0026lt;h1\u0026gt;HomePage\u0026lt;/h1\u0026gt;\u0026quot;) } if(req.url==='/article.html'){ res.write(\u0026quot;\u0026lt;h1\u0026gt;article.html\u0026lt;/h1\u0026gt;\u0026quot;) } if(req.url==='/about.html'){ res.write(\u0026quot;\u0026lt;h1\u0026gt;about.html\u0026lt;/h1\u0026gt;\u0026quot;) } res.end(); }); server.listen(80, function(){ console.log( '服务器已运行...'); });  http状态码 什么是状态码 http协议规定的服务器响应数据时的状态编码，就是状态码\n常用的状态码 1xx :表示普通消息，没有特殊含义 2xx :表示服务器响应成功 200 成功 3xx :表示重定向 301 永久重定向 302 临时重定向 304 使用缓存(服务器没有更新过) 4xx :无法访问 403 权限不足， 无法访问 404 资源找不到 5xx :服务器有错 500 服务器端代码有错 502 网关错误 503 服务器已崩溃  状态码的使用 res .writeHead(状态码,响应头对象);  例\nvar http=require('http'); var server=http.createServer(); server.on('request',function(req,res){ res.writeHead(200,{\u0026quot;Content-type\u0026quot;:\u0026quot;text/html;charset=utf-8\u0026quot;}); res.write(\u0026quot;\u0026lt;h1\u0026gt;中文乱码解决\u0026lt;/h1\u0026gt;\u0026quot;) res.end(); }); server.listen(80, function(){ console.log( '服务器已运行...'); });  响应头 Content-Type 响应的文件类型 text/html 注意:未指定响应文件类型时，默认就是html,编码默认是系统编码 Content-Length 响应内容的长度 Access -Control-Allow-Origin 设置响应头可以跨域  例\nvar http=require('http'); var server=http.createServer(); server.on('request',function(req,res){ res.writeHead(200,{ \u0026quot;Content-type\u0026quot;:\u0026quot;text/html;charset=utf-8\u0026quot;, \u0026quot;Content-Length\u0026quot;:24 //\u0026quot;Access-Control-Allow-Origin\u0026quot;:\u0026quot;*\u0026quot;//实现跨域 }); res.write(\u0026quot;\u0026lt;h1\u0026gt;中文乱码解决\u0026lt;/h1\u0026gt;\u0026quot;) res.end(); }); server.listen(80, function(){ console.log( '服务器已运行...'); });  MIME类型: 什么是MIME类型 MIME类型可以认为是文件类型的表述\n常用的MIME类型 .txt text/plain .html text/html . CSS text/css .js text/javascript .png image/png .jpg image/jpeg .gif image/gif .json text/json application/json .mp3 dio/mpeg .mp4 video/mpeg .pdf application/pdf .xml text/xm1 .zip application/x-gzip  例\n\u0026quot;Content-Type:\u0026quot;text/html; charset=utf-8\u0026quot;, / /生成一个html网页 \u0026quot;Content-Type\u0026quot;:\u0026quot;text/plain; charset=utf-8\u0026quot;, //生成一个普通文本 \u0026quot;Content-Type\u0026quot;:\u0026quot;inage/png\u0026quot;, //生成一个普通文本 \u0026quot;Content- Type\u0026quot;:\u0026quot;application/x-gzip\u0026quot;, //生成一个压缩包， 浏览器自动下载  静态网页资源服务器实例 node.js静态网页服务器实例\n客户端向服务器传递数据:  GET方式\n 在URL后面添加?写键值对形式就是GET方式传数据 只要可以写url的地方就可以在后面加?传参数 在node.js可以接收到客户端传过来的参数值。  POST方式\n post方式提交数据只能使用表单提交的方式   实例\nvar http=require('http'); var server=http.createServer(); /*server.on('request',function(req,res){ //Get方式 //通过解析req.url后面参数字符串的解析分析出传递的参数的值 var query = req.url.split(\u0026quot;?\u0026quot;); var value = query[1].split(\u0026quot;=\u0026quot;); res.writeHead(200,{\u0026quot;content-type\u0026quot;:\u0026quot;text/html;charset=utf-8\u0026quot;}); res.write(\u0026quot;\u0026lt;h1\u0026gt;你传递的参数的值是\u0026quot;+value[1]+\u0026quot;\u0026lt;/h1\u0026gt;\u0026quot;) res.end(); });*/ //定义一个动态页面 //if(req. ur1===' /action.html'){ //\t//从req请求主体中获取到POST方式提交的数据 //\tvar query=''; //\treq.on('data',function(a){ //\tquery+=a . toString(); //\t}); //\treq.on('end'，function(){ //\tres.writeHead(200, {\u0026quot;Content - Type\u0026quot;: \u0026quot;text/html; charset=utf-8\u0026quot;}); //\tres.write('\u0026lt;h1\u0026gt;我们已经收到了请求\u0026lt;/h1\u0026gt;'); //\tres.write(' \u0026lt;h1\u0026gt;接收到的数据是:'+query+*\u0026lt;/h1\u0026gt;' ); //\tres.end( ); //\t}); //\treturn; //} server.listen(80, function(){ console.log( '服务器已运行...'); });  模板 使用动态网页模板:\n什么是模板\n将一些固定的结构或表现直接以静态文件形式存储，将需要表现成动态数据的地方使用模板语法进行编写，再使用模板引擎读取该静态文件，将动态的数据进行替换进去。最终实现产生出一个动态的网页\n小结 path模块 path模块主要用于对路径进行处理(解析、拼接、格式化等)\npath.join(字符串,字符串2); //将字符串拼 接成一个完整的路径 path.parse(路径); //将路径解析成为各个不同的部分，返回一个对象  url模块 什么是URL url是全球统一资源定位符，也称为网址\nURL的格式  完整的格式\n协议://用户名:密码@主机名.名.域:端口号/路径/文件名.扩展名?参数名=参数值\u0026amp;参数名2=参数值2#hash地址\n 常见的格式\n协议://主机名.名.域:端口号/路径/文件名。扩展名?参数名=参数值#hash地址\n  url模块 在node.js中提供了url模块，用于解析ur1中的各个部分，有两套API功能:\n//传统的node. js的ur1解析 var obj=url.parse(网址); //按WHATWG标准进行解析 var obj=new url . URL (网址);  http协议 什么是http协议 http协议就是超文本传输协议，主要用于规定客户端与服务器端进行数据传输的过程及格式。\nhttp协议以请求、应答形式进行数据交互，必须一次请求对应一次应答(响应)。\nhttp协议的细节 规定了客户端如何向服务器发送数据\n规定了服务器如何向客户端发送数据\n发送过程 客户端向服务器端发送数据称为请求，包含请求头和请求主体;\n服务器端向客户端发送数据称为响应，包含响应头和响应主体;\nhttp模块 什么是http模块 http模块是node. js中的系统模块，用于进行网络通信(服务器、客户端)\n.get()方法 用于获取其它服务器的数据(可以跨域)\n语法:\nhttp. get(url, function(响应对象){ 响应对象.on('data',function(){ }); });  http协议及工作原理 在浏览器中输入网址，回车时，将网址发送到指定的DNS服务器去查询对应的IP地址。\n浏览器获取到IP地址以后，向该IP的服务器发起请求，服务器收到请求，并且读取请求的网页文件，发送给客户端浏览器,浏览器可以直接解析执行html代码将内容渲染出来显示给用户\n如果服务器硬盘中没有该文件，就执行动态程序生成一个(使用node.js引擎读写数据库)生成html网页在发送给浏览器。\n编写网络蜘蛛抓职itsource . cn首页的所有图片 var http=require('http'); var fs=require('fs'); //获取itsource. cn首页的html内容 http. get( 'http://www.itsource.cn/',function(res){ varstr=''; res. on('data',function(a){ str+=a; }); res.on('end',function(){ //fs.writeFileSync('./itsource.html',str); var reg = /url\\((\\/upload.*?)\\)/; var arr,result=[]; while(arr=reg.exec(str)){ result.push(arr[1]); } }); });  ","id":3,"section":"posts","summary":"node.js简介 简单来说node.js就是js的一个运行环境，可以运行js代码，用于服务器端编程。 下载安装 下载node.js 安装：一路ne","tags":["node"],"title":"Node.js学习笔记","uri":"https://mumulx.github.io/2019/12/node/","year":"2019"},{"content":" 关于解决Eclipse导入SpringBoot项目jar包从Maven中下载太慢的问题 只需要在maven安装目录./config/settings.xml中插入下列代码,配置阿里镜像就可以了！\n\u0026lt;mirrors\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;nexus-aliyun\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;Nexus aliyun\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://maven.aliyun.com/nexus/content/groups/public\u0026lt;/url\u0026gt;; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; shshsh  ","id":4,"section":"posts","summary":"关于解决Eclipse导入SpringBoot项目jar包从Maven中下载太慢的问题 只需要在maven安装目录./config/setti","tags":["其他问题"],"title":"Eclipse导入springBoot项目jar包下载太慢的问题","uri":"https://mumulx.github.io/2019/11/eclipse%E5%AF%BC%E5%85%A5springboot/","year":"2019"},{"content":" Git简介 \u0026emsp;Git是一个分布式版本控制系统。版本控制系统又分为：集群式版本控制系统(常见的有cvs、svn)、分布式版本控制系统(常见的有Git)。Git的官网是 Git，Git起源于Linus系统，因为BitMover公司不再向Linux社区提供BitKeeper软件免费的软件授权，因此有一些Linux大神创建了Git分布式版本控制系统，并且上传了Linux系统的源码。Git是以全量的方式管理版本即每一个版本都包含全部的文件，可以时刻保持数据的完整性。\n\u0026emsp;Git内部具有三种状态：\n 已修改(modified)：表示数据文件已经被修改，但未被保存到Git数据库中。 已暂存(staged)：表示数据文件已经被修改，并会在下次提交时提交到Git数据库中。 已提交(committed)：表示数据文件已经顺利提交到Git数据库中。  \u0026emsp;Git在管理项目时，文件流转的三个工作区域是：工作区域-\u0026gt;暂存区域-\u0026gt;对象区域。因此，基本的Git工作流程如下：在本地的工作目录对文件进行写操作；然后对修改后的文件进行add（处于 modified 状态），保存到暂存区域(处于 stage 状态)；最后提交更新(处于 commited 状态)，将保存在暂存区域中的文件版本永久转存到Git的本地仓库中。关于Git的安装和环境的配置，这里就不多说了，本篇主要是记录，自学过程中的知识点。\nGit的安装 \u0026emsp;网上关于Git的安装有很多的教程，这里就不详细记录了，基本就是一路下一步就可以了。\nGit的使用 Git官网新建仓库 加号\u0026ndash;\u0026gt;new repository\u0026ndash;\u0026gt;填写仓库名，描述\u0026ndash;\u0026gt;create\nGit项目初始化 git init  \u0026emsp;在本地新建一个文件夹，鼠标右键选择 Git Bash Here 输入指令git init 这样的话就将该文件夹纳入到了Git的管理。在本地文件夹会出现一个隐藏的目录.git目录。它是一个版本控制的目录。\n设置邮箱、用户名 \u0026emsp;当我们每次使用git push来将文件推到远程仓库的的时候，会发现每次都需要输入用户名和密码，为了解决它，可以给项目配置用户名，邮箱，这样每次push的时候就不需要再次输入用户名和密码，配置的方式分为三种，分别是：\n git config --global给整个计算机一次性设置 git config --system给当前用户一次性设置 git config --local给当前项目一次性设置  他们的优先级是3\u0026gt;2\u0026gt;1，也就是说会采用就近的原则进行设置，而且当修改了配置文件时只对修改之后的提交有效。修改之前的提交仍然使用的是之前的配置(用户名、邮箱)\n例如,：\ngit config --local user.name 'mumulx' git config --local user.email '1819778796@qq.com'  Git指令 git init \u0026amp;emsp;项目初始化 git status \u0026amp;emsp;查看当前状态 git log \u0026amp;emsp;查看日志  ","id":5,"section":"posts","summary":"Git简介 \u0026emsp;Git是一个分布式版本控制系统。版本控制系统又分为：集群式版本控制系统(常见的有cvs、svn)、分布式版本控制系统(","tags":["版本控制"],"title":"Git自学笔记","uri":"https://mumulx.github.io/2019/11/git%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" 这个人比较懒还没开始写呢！ ","id":6,"section":"posts","summary":"这个人比较懒还没开始写呢！","tags":["Spring家族"],"title":"SpringMVC自学笔记","uri":"https://mumulx.github.io/2019/11/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" 这个人比较懒还没开始写呢！ ","id":7,"section":"posts","summary":"这个人比较懒还没开始写呢！","tags":["Spring家族"],"title":"Spring自学笔记","uri":"https://mumulx.github.io/2019/11/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" 这个人比较懒还没开始写呢！ ","id":8,"section":"posts","summary":"这个人比较懒还没开始写呢！","tags":["Spring家族"],"title":"SSM整合自学笔记","uri":"https://mumulx.github.io/2019/11/ssm%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" 记录自己的第一篇博客 \u0026emsp;2019-10-31，抓住10月的小尾巴，创建了人生的第一个博客。经过一天的努力，终于是在22：13的时候创建好了人生的第一个博客。也不知道要写一些什么，就简单的记录一下这特殊的一天。\n\u0026emsp;其实很早的时候就计划着要建立自己的博客，一直也没有着手弄。今天的话就心血来潮，仿佛是命运在召唤，促使着我建立了这个网站。就这么的，忙了一个晚上，经过了一系列的难关终于是将博客建立了起来。以后的话会分享一些自己的学习笔记和学习过程中遇到过的各种问题。说来也是惭愧，自出生二十年以来，一直也没养成什么习惯，也没有什么爱好，也没能长时间坚持做过什么事情。也是希望能把本站当作一件自己能够一直坚持想做的事情。\n\u0026emsp;此时的我呢是一名普通的本科大三的学生，在 这个时间段又再一次处在了一个人生的十字路口，一方是考研，一方是预就业。两个各有各的好处吧，于我来说可能预就业是一个更好的选择吧，当然我也不是很确定这次的选择是正确的。我呢是一个不是很能认清自己的人，也是一个每当要做选择的时候，总会错过最重要选项的那个人，很是害怕这次的选择又错过了。\n\u0026emsp;迷茫和矛盾两个词可能是我现在最真实的状态了。迷茫，更多的是对自己未来的迷茫，看不清也说不透。我对于人生没有什么规划，总是随遇而安，秉着车到山前必有路的理念，不争也不抢。可是这次与往常不同，学校和社会是两个完全不同的地方，而我又是一个不善交际的人，对于自己即将步入的社会还是没有什么概念的。这次是即将告别学校，离开这个困住了十几年的地方，要去一个更加复杂，更加混乱的地方。而这个地方充满了未知，你不知道你能否适应这个地方，能否承受的住生活的压力，能否找到一份满意的工作，能否顺利的从学生这个身份过渡到社会人士这个身份，只知道自己现在能做的只能是一个更好的自己。对于我这种不善交际，不喜争抢，性格内向的人来说，步入社会四个字就像是哈利波特里面的摄魂怪一样，令人畏惧与害怕。\n\u0026emsp;矛盾的是不能坚定自己的选择，总是患得患失，即不甘于平庸，又陷于平庸。心里想的，嘴上说的，实际做的，往往是三种样子。每当要自己做一个决定的时候，总是犹犹豫豫，患得患失，担心这担心那，考虑这考虑那，越想越复杂。最后反而会选择自己的第一映像做出的决定，而做出这个决定后呢，又总是觉着自己的选择是错误的，不能肯定自己。内心是非常矛盾的。\n\u0026emsp;懒惰是毁掉一个人的罪魁祸首，它让你逐渐的安于现状，丧失对未来拼搏的动力。我觉着自己是一个很懒惰的人，而又不是一个懒惰的人。很是矛盾吧！懒惰的背后是自己没什么奋斗目标，没什梦想，没什么理想，没什么信念。所以整个人是懒懒散散的。而每当自己有了一个奋斗的目标后，我会为之努力奋斗，整个人的状态像是上了劲的发条，充满干劲。\n\u0026emsp;我是一个完美主义者，和强迫症晚期的人，我会尽量的把自己的每一项工作和目标完成的很完美。当天的事情必须完成，什么时候完成什么时候睡觉，绝不会留到第二天，有些人可能不会理解这一点，但这确确实实是发生在我身上的。人是一个复杂的动物，真是因为这些完美的和不完美的，才构成了一个第一无二的自己。我希望呢，每个人都应该得认识自己，了解自己，知道自己的不足，知道自己想要什么，尽量让自己活得明白一点。而未来是属于我们的，时间会洗涤一切，现时的烦恼是阻挡不了自己前进的脚步的。几年后的自己回看现在的自己就像现在的自己回看过去的自己一样，肯定会觉得自己那个时候怎么那么的幼稚，可笑。\n\u0026emsp;也是希望自己在回首往事的时，不因虚度年华而悔恨，也不因碌碌无为而羞愧。珍惜当下的时间，做自己该做的事情，充实自己的脑袋，多思考，未来的你会感谢现在这样拼搏的你。\n\u0026emsp;下面给大家分享一段话，这段话，感觉还是很适合现在的自己。\n 每天认真洗脸，多读书，按时睡，少食多餐，变得温柔，大度，继续善良，保持爱心。不在人前矫情，四处诉说以求宽慰，而是学会一个人静静面对，自己把道理想通。这样的你，暂时单身也无所谓啊，你那么虔诚的做更好的自己，一定会遇到最好的，而那个人也一定值得你所有等待。\n ","id":9,"section":"posts","summary":"记录自己的第一篇博客 \u0026emsp;2019-10-31，抓住10月的小尾巴，创建了人生的第一个博客。经过一天的努力，终于是在22：13的时候创","tags":["日记"],"title":"自己的第一篇博客","uri":"https://mumulx.github.io/2019/10/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","year":"2019"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }","id":10,"section":"posts","summary":"\u003cp\u003eEmoji can be enabled in a Hugo project in a number of ways.\u003c/p\u003e","tags":["杂七杂八"],"title":"Emoji Support","uri":"https://mumulx.github.io/2019/01/emoji-support/","year":"2019"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline\u0026nbsp;\u0026nbsp;\u0026nbsp; Markdown\u0026nbsp;\u0026nbsp;\u0026nbsp; In\u0026nbsp;\u0026nbsp;\u0026nbsp; Table     italics bold strikethrough\u0026nbsp;\u0026nbsp;\u0026nbsp; code    Code Blocks Code block with backticks html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. ↩  ","id":11,"section":"posts","summary":"\u003cp\u003eThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","tags":["杂七杂八"],"title":"Markdown Syntax Guide","uri":"https://mumulx.github.io/2019/01/markdown-syntax/","year":"2019"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt \nThe Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","id":12,"section":"posts","summary":"\u003cp\u003eLorem est tota propiore conpellat pectoribus de\npectora summo.\u003c/p\u003e","tags":["杂七杂八"],"title":"Placeholder Text","uri":"https://mumulx.github.io/2019/01/placeholder-text/","year":"2019"}],"tags":[{"title":"node","uri":"https://mumulx.github.io/tags/node/"},{"title":"Spring家族","uri":"https://mumulx.github.io/tags/spring%E5%AE%B6%E6%97%8F/"},{"title":"其他问题","uri":"https://mumulx.github.io/tags/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/"},{"title":"前端框架","uri":"https://mumulx.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"title":"日记","uri":"https://mumulx.github.io/tags/%E6%97%A5%E8%AE%B0/"},{"title":"杂七杂八","uri":"https://mumulx.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"title":"版本控制","uri":"https://mumulx.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}]}