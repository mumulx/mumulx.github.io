{"categories":[{"title":"技术收录","uri":"https://mumulx.github.io/categories/%E6%8A%80%E6%9C%AF%E6%94%B6%E5%BD%95/"},{"title":"技术框架","uri":"https://mumulx.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"title":"杂七杂八","uri":"https://mumulx.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"title":"私人博客","uri":"https://mumulx.github.io/categories/%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"问题收录","uri":"https://mumulx.github.io/categories/%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95/"}],"posts":[{"content":" Teamcenter笔记 概述 Teamcenter的标准功能基本可以供用户使用，但是基于每家公司业务问题以及使用习惯，还有一些特殊的应用与数据整合，所以会产生不同的业务需求，这个时候我们就需要通过客户化定制的方式去满足用户的应用。通过对TC系统的二次开发来实现客户化。\n客户端定制  通过个性化定制让用户操作更加方便，提高用户的操作效率。比如一些对话框、操作界面等的定制，数据显示与表单定制，可以对系统中对象图标的显示、表单界面进行具体的定制与开发。\n 数据显示与表单定制：可以对系统中对象图标的显示、表单界面进行具体的定制与开发。\n服务端定制  应用集成：\n使用集成工具包（ITK）或服务（Teamcenter Service）进行定制，改变Teamcenter与外部应用集成时行为（behavior）。比如前处理，后处理，SOA接口，ITK函数，Handler等。\n 数据共享\n通过定制开发可以使Teamcenter系统中的一些数据与别的系统共享，或者Teamcenter共享别的系统中数据，比较典型的有报表、CAD集成ERP集成、CAPP集成等。\n   第一章 1）查看\\设置 TC命令行\nset TC_ROOT=D:\\Siemens\\Teamcenter10 set TC_Data=D:\\Siemens\\tcdata call D:\\Siemens\\tcdata\\tc_profilevars.bat  2）运行TC命令：\n​\n（1）清除TC死进程 clearlocks -verbose （2）列出所有登录到TC的用户 list_users –u=infodba –p=infodba （3）获取TC版本信息 install -ask_version （4）导出某个Item到本地文件夹中 tcxml_export -u=infodba -p=infodba -file=D:\\output.xml -item=000034 -rev=A -floder=Home (5)文件卷信息备份 backup_xmlinfo -u=infodba -p=infodba -g=dba  3）查看TC环境变量 ： set TC\n实践练习2：\n1）运行TC命令：\n（1）导出原始或旧的CAD属性映射文件 export_attr_mappings -u=infodba -p=infodba -g=dba -file=D:\\attr.txt\n（2）导入原始或旧的CAD属性映射文件 import_attr_mappings -u=infodba -p=infodba -g=dba -file=D:\\attr.txt\n实践练习3：\n1）运行TC命令：\n（1）游离数据收集命令： collect_garbage -u=infodba -p=infodba -g=dba -item -dataset -floder -report\n（2）删除WASTE BASKET文件夹下所有没有引用的对象 collect_garbage -u=infodba -p=infodba -g=dba -all –delete\n第二章 2.1对象模型和系统框架 Item和Item Revision模型  POM Item\n |tem Revision\n 动态类型\n Relation\n 属性及属性分类\n  Teamcenter对象模型由管理数据的类组成 模型可描述成两个基本关系集图\n 继承关系 关联关系  对象模型原理\n Item and Item Revision Model Dataset Model Form Model System Administration Model Product structure object Model Access control Model Application encapsulation M lodel  POM persistent Object Manager\nPOM是Teamcenter的核心模块，是应用模块与系统模块的接口，是一个提供内部程序员、第三方以及客户定义他们自己业务对象(business object) 的工具。\n 系统模块通常是用0DBC访问0racle关系数据库或MS SQL Server\n POM提供应用程序与系统模块比关系数据库表更高层次的抽象(如创建文件夹)，可以创建、存取他们自己的数据以及存取简单的TC数据\n 可以通过BMIDE (Bus iness Modeler IDE) 创建业务对象，而不是直接编辑表或写代码，提供了数据的面向对象浏览器，而不是SQL 表达式。\n  Item Item是TC中管理信息的最基本的对象，提供了用于组织信息、审计/变更控制的物理或概念上的实体。表示真实世界中的一个产品、部件或零件对象等，例如发动机总成、支架等。\nltem有以下基本信息:\n Item ID (必须唯一,可以是流水码) |tem Name Item type\n Unitof Measure (Optional) 。\n Description\n 最多240个字符\n  其中Bus inessOb ject是所有类的基类，再往下是两个分支:\n POM_ object带有存储类的业务类 Runt imeBusinessOb ect动态类型  Item类型是选择客户化继承类的首选基类。在Item这个视图下，有:存储类、父类、版本类、表单这四项。这里主要解释的是存储类。规则为:每个业务对象，都有一个存储类与之对应。另外同时注意:不同的业务对象可以共同对应于一个存储类。\nItem Revision Item Revision用于记录Item的历史 |tem Revision信息\n ID  Item的唯一 标识  Revision Name .  动态类型 例如: BOML ine它实际是从种存储类.上获取属性从而计算得到的。其中包括PSOccur rence,Note，Item，ItemRev等等 属性可以加载到结构管理器。\nRelations TC用Re | at i on来关联数据的Item和Item Revision\nReIation描述了数据是怎样与Item和Ite Revision关联的\n例:一个Dataset包含了CAD模型，这个模型由某个ItemRevisi on说明 例:一个标准文档描述了一个Item所需要特定草图的填充表单和功能\nItem和ltem Revis ion可以与其他一些对象有关，包括Datasets，Forms， Fo Iders以及其他的Item和Item Revision .\n每个与Item关联的对象表示了该ltem的各个方面信息\nTC提供了基本的关系集，对象与Item、Item Revision之间的关系取决于所执行的规则\n master_ Form  关联Form与Item或Item Revision Form是Item或Item Revis ion的属性(Attr ibutes) 集合 关系规则  Item或Item Revis ion必须要有对Form添加、删除master_ Form关系的权限 一个Form与一个Item或Item Revision只能有一个master_ Form关系 一个Form的master_ Form关系只能对应一个Item或Item Revision    TC提供了基本的关系集，对象与ltem、Item Revision之间的关系取决于所执行的规则\n requirement\n 关联data与Item或Item Revision (如:草图的标准、Part的技术需求)\n 关系规则\n Item或Item Revis ion必须要有对一个对象添加、删除requirement关系的权限\n Form与Item或Item Revis ion可以有一个requi rement关系\n 只有Dataset的0版本可以与Item或Item Revis i on有requi rement关系\n Folder、 enve | ope、 BOM vi ew或BOM Revis i on不能与Item或ItemRevision有requirement关系\n 一个Item不能另外的Item或Item Revis ion有requi rement关系\n 一个Item Revis i on可以与另外的Item或Item Revis ion有requirement关系\n 一个Item Revision不能与另外的同- -个Item的Item Revision有requi rement关系\n manifestation关联与Item或Item Revis ion相关其他数据\n specification关联定义Item Revis ion的数据\n reference关联数据与Item或Item Revision\n Revision关联Item Revis ion与相应的Item\n BOMView关联产品结构与Item\n BOMView Revision关联产品结构Revision与Item Revision\n    修改Item/Item Recision  当Item被创建时就有了ID 只有对Item添加了数据，Item才有意义\n 数据集(Dataset)用于其他应用中创建的信息，这些数据可以与Item和Item Revision关联\n 在TC中，ItemRevision和Datasetversion都可以表示修改信息\n Item Revis ion表示Item的明显变化 Dataset vers ion表示每天的变化  修改Item、 Item Revis i on的方法\n 通过cut、paste方法添加或移除Item与Item Revision的关系 修改与Item和ItemRevision相关的对象的内容   属性及属性分类  类定义了对象的类型(type of object) 、属性(Attr ibutes)和方法(methods) 在TC中，Attr ibute可以是: Integer， Float，Boolean， String,Date，Tag,Array Tag唯一标识Reference和Relation Attribute具有以下特性:  Unique Protected:属性只能由创建该对象的应用修改 NULLallowed：如果这个特性不为true的话，对象不能保存 Upper bound (.上边界) Lower bound (下边界) Default value (默认值)   永久\n 该类型的属性会在数据库中对应一条记录上的一个字段，从而得以保存\n 运行时\n 一顾名思义，只是运行时动态的属性，需要配合程序计算获得。\n 复合\n 复合属性，如不清楚可以 查看BMI DE使用帮助\n 关系\n 从TC8开始关系首先需要定义为属性。 TC2007是不需要的，只用首选项配置。\n 其他对象模型\nDataset Model 每个产品对象均有一些具体的数据文件来描述其不同方面的详细信息，如设计模型、计算说明、设计要求等。这些数据文件是由不同的应用软件产生的( 如CAD软件、0ffice软件等)，具有不同的表现形式(如Text文件、图形文件等)。\nTeamcenter的Dataset (数据集)提供了管理各类应用软件所产生的文件的手段。不管是技术说明文件或CAD / CAM / CAE系统产生的图形数据文件，都可以用原来的形式或点阵形式或其它任何计算机形式的文件存放在Teamcenter系统中。\nDataset是用来管理(存放)应用软件生成的数据(文件)的-种对象。对应于不同类型(格式)的数据(文件)，Teamcenter 提供Dataset Type与之对应。\n业务对象是用于详细说明TC对象的行为的\nDataset业务对象用于对Dataset分类\n例:当Document Dataset数据打开时， 与该对象关联的WORD处理程序打开\n当创建数据集时，会创建0和1两个版本，Revision 0总是指向最新的版本，所以最初时它指向Revision 1。如果创建了Revision 2,Revision 0就指向2。在编程时，如果希望获得最新的版本，就用Revision 0。\n所有Dataset的版本都有相同的所有者(owning user)、组(group) 和保护(protect ion)机制。\nITK functions use this convention with R evisions asfollows:\nAE_ask_dataset  Given any dataset, returns Revision 0.\nAE_ask_dataset_first_rev  Given any dataset, returns the oldest Revision.\nAE_ask_dataset_latest_rev  Given any dataset, returns the most recent Revision (nothe Revision 0 copy).\nGiven any dataset, returns the most recent evision (nothe Revision 0 copy).\nAE_ask_dataset_next_rev  Given any dataset, returns the next Revision 1n the sequence.\nAE_ask_dataset_prev_rev  Given any dataset, returns the previous Revision in the sequence\nAE_find_dataset (\u0026quot;name\u0026quot;, \u0026amp;Dataset)  Finds Revision 0 of the Dataset.\nAOM_refresh(dataset, true)  Loads the given Dataset version for modification.\nAOM_ save (dataset)  Creates a new, later version of the Dataset and saves a copy to Revision 0.\nForm Model Form能存储用户定义的属性(Attr ibute), TC提供了标准Form模型。Form是POM对象，可以使用Form |TK函数存取Attr ibute\n所有的POM_ appl icat ion_ _ob ject类和它的子类都有所有者和保护机制，只能被系统管理员修改\nACL (Access control | ist)实体由对组和/或用户以及子对象授权的引用组成。\n子对象是TC中可以被授权的对象。\nTeamcenter软件系统版本历史如下:\n Teamcenter Enterprise 4.0\nTeamcenter Enterprise 5.0\nTeamcenter Engineering 9.0\n2005年: Teamcenter Engineering 2005\n2007年: Teamcenter 2007\n2009年:Teamcenter 8\n2012年: Teamcenter 9\n201 3年: Teamcenter10\n201 6年:Teamcenter11\n201 8年:Teamcenter1 2\n 第三章 3.1客户端开发技术 Teamcenter 胖客户端基于客户端-服务器架构模式，客户端和服务器层均可以定制开发。胖客户端具有UI界面，使用Java语言进行构建与定制。服务器端使用Integration Toolkit (ITK) 和 C/C++ 编程语言进行开发。\n因为胖客户端基于Eclipse平台，开发时可以获取所有扩展点，作为Teamcenter 开发定制技术，可以使用如下三种方式定制客户端：\nBase Eclipse extension points and services (使用org.eclipse.ui.menus extension point). Teamcenter extension points and services (使用application extension points). Teamcenter customization mechanisms (使用style sheets).  ​ 基础定制技术用于在客户端创建具有用户界面的插件，并加以显示，需要熟练掌握Eclipse。\nTeamcenter 提供几种界面，包括：\n 胖客户端界面；\n 基于Web的瘦客户端界面；\n 业务建模器；\n Teamcenter集成Microsoft Office；\n Teamcenter集成CAX，ERP等\n  因为胖客户端与瘦客户端接口开放了定制方法，仅提供此两种开发方式。\n随着Teamcenter软件的发展和进步，利用新技术，尽可能灵活和简单化Teamcenter扩展和定制的能力。\n Back and Forward buttons Application banner Search box Navigation pane Application pane Getting Started application button. Primary applications Secondary applications Clipboard button  3.11AWT \u0026amp; Java Swing Abstract Windows Toolkit（AWT）是最原始的、具有有限 GUI 组件、布局管理和函数功能的工具包。AWT的主要优点是，它在 Java 技术的每个版本上都成为了一种标准配置，包括早期的 Web 浏览器中的 Java 实现。另外它也非常稳定，可以在任何一个以Java为基础的环境中运行使用。\nAWT中包含了许多类和接口，用于Java Application的GUI编程。通过图形用户界面用户和程序之间可以方便地进行交互。\nava的抽象窗口工具包AWT由Java的java.awt包提供，该包中有许多用来设计GUI的组件类，如：按钮、菜单、列表、文本框等组件类，同事它还包含窗口、面板等容器类。\nava Swing是Java Foundation Classes（JFC）的一部分，它是在 AWT 组件基础上构建的，所有 Swing组件实际上也是 AWT 的一部分。在Swing 中，Sun 开发了一个经过仔细设计的、灵活而强大的 GUI工具包。\nSwing 具有内嵌于Java 技术的优点，可完全移植的。Swing 也具有高级图形应用程序所需要的优点。SWT 具有可以作为本地应用程序实现的优点，这可以提高性能，并利用基于SWT 的GUI 来实现本地兼容性。\n在SWT之前，Sun已经提供了跨平台GUI开发工具包AWT。AWT框架底层使用原生窗口部件(native widgets)构建，只能使用各个平台窗口部件的子集。在大部分情况中，都是使用Swing与结合了JFace的SWT一起构建GUI。\n在SWT之前，Sun已经提供了跨平台GUI开发工具包AWT。AWT框架底层使用原生窗口部件(native widgets)构建，只能使用各个平台窗口部件的子集。在大部分情况中，都是使用Swing 与结合了JFace 的SWT 一起构建GUI。 Standard Widget Toolkit (SWT)，即标准部件工具包。它是一个Java平台下开放源码的Native GUI组件库，也是Eclipse平台的UI组件之一。如果只为一种平台来开发系统，那么SWT 就具有主机兼容性方面的优点，包括与主机特性的集成，例如在Windows 上对ActiveX控件的使用。 Teamcenter2007以上都是采用SWT与Swing结合进行客户端构建的。\n与 AWT 的概念相比，SWT 是一个低级的 GUI 工具包。JFace是一组用来简化使用SWT构建GUI的增强组件和工具服务。SWT的创建者为了建立一个只有两者的有点而没有缺点的系统，从AWT和Swing的实践中吸取了大量的经验。从很多方面来说，他们已经成功了。SWT 的 GUI 既具有主机外观，又具有主机的性能。这样就避免了使用 AWT 和 Swing 而引起的大部分问题。特定的主机具有一些低级功能控件，因此 SWT 提供了扩充版本，从而可以产生更一致的行为。\nRCP的概念 ​ RCP是Rich Client Platform的缩写，利用Eclipse核心平台和一些有用的插件，进行应用系统的构建。只要新的代码符合插件的代码结构，将代码放入工作空间后，Eclipse平台会自动加载新代码，构成新的Eclipse平台。\n​ Eclipse RCP 提供了标准化的组件模型，包括菜单，工具栏，以及可叠加的窗口组件(编辑器和视图)、按钮、表格、树形结构的支持。\nEclipse RCP的优点\n 组件化：基于Eclipse的系统设计由被称为plug-ins的插件构成，可以通过扩展点进行配置，也可以被不同应用程序共享。\n 便利性:Eclipse RCP对各个平台下的产品包装提供了强有力的支持，其开发的RCP甚至可以在嵌入式设备、掌上电脑上运行。Sun公司对Java的口号是write once，run everywhere，Eclipse也可以说是RCP run everywhere。\n 智能安装和升级：Eclipse提供了专门的Update组件，可以实现通过HTTP、Web站点、复制等多种方式进行安装和更新，避免了早期胖客户端应用、部署升级的麻烦。\n 可扩展性：Eclipse基于插件进行扩展的思想使得用户可以方便地搭建各种规模、类型和用途的应用程序。按照Eclipse官方的说法，Eclipse RCP一开始就被设计为可扩展的。\n 使用体验：Eclipse为各种操作系统提供了本地图形接口包。当RCP运行时，Eclipse首先直接调用本机窗口组件，只有没有本机所需组件时才进行模拟。无论RCP在哪种操作系统上运行，都可以保持与本机一致的外观和行为。一个设计优良的富客户端，可以提供诸如拖曳操作、剪切板、导航等 UI元素。UI设计者也可以利用各种界面工具，轻松设计出完美的用户界面。\n  CP中的每个视图都对应程序中的UI界面。每个透视图对应一个应用组合，如在Teamcenter中 ：我的Teamcenter、结构管理器、分类管理等。下图是以Teamcenter系统为例展示RCP应用程序运行的界面：\n透视图 perspective 一个客户端可以运行多个透视图，但每次在界面中只显示一个透视图；在一个透视图中可以添加和重新排列视图，以在透视图中同时显示多个信息集；可以保存重排的透视图，并使用当前名字，也可以为新的排列创建一个新名字。系统管理员可以使用 HiddenPerspectives 首选项来显示/隐藏各个透视图功能。\n视图 View 视图中相关工作改变通常会对其他视图中的选项更改；视图中数据的更改会立即保存；视图在透视图中可以便捷的加载，当前透视图中的视图排列可以存储到本透视图，或者新创建的透视图中。\n3.2Teamcenter插件开发 Eclipse的设计思想是:一切皆插件。Eclipse核心很小，其它所有功能都以插件的形式附加于Eclipse核心之上。Eclipse基 本内核包括:图形API (SWT/Jface)，Java开 发环境插件(JDT ),插件开发环境(PDE), JDT与PDE构成了Platform run-time。 Teamcenter胖客户端宿主于Eclipse胖客户端平台框架。RCP是一个通用的应用程序框架，通过使用插件，提供了模块化和基于可扩展的组件开发的支持。\nPDE和Java Deve lopment Tooling (JDT) IDE 是Eclipse的标准扩展。PDE提供了一些向导以帮助创建插件。 Workbench和Workspace是 Eclipse平台的两个必备的插件它们.\n提供了大多数插件使用的扩展点。插件需要添加到扩展点才可以运行。Workbench组件包含了一些扩展点，允许插件扩展Eclipse 用户界面，使这些用户界面带有菜单选择和工具栏按钮;请求不同类型事件的通知;以及创 建新视图。Workspace 组件包含了可以与资源(包括项目和文件)交互的扩展点。\n除了Workbench和Workspace，其它插件也可以扩展Eclipse组件。Debug组件可以让插件启动程序、与正在运行的程序交互，以及处理错误Team组件允许Eclipse 资源与版本控制系统(VCS) 交互，构建VCS的Eclipse客户机时，Team 组件就象Debug组件一样，会扩展或增强Eclipse的功能。Help组件可以提供应用程序的联机文档和与上下文的帮助。\n一个插件(p lug- in)是Ec lipse平台中的最小功能单元，可以进行独立的开发和发布。\n插件是用Java编写的。插件由以下内容组成:\n JAR中的Java代码 一些只读文件和其它资源(例如图片、web模板、消息资源文件、本地类库等)。 一个插件清单，用于声明它与其它插件之间的连接关系，一个插件的清单由几个文件表示:\n manifest,mf文件是一个OSGI bundle清单， 它描述了插件间运行时的依赖关系; plugin.xml是一 -个XML文件，它描述了扩展和扩展点的信息   插件目录\n标签的结解释，各个标签页的作用\n扩展与扩展点\nPlugin. xmI中扩展点(extens ion point) 解释\n org.eclipse.ui.perspectives：定义新透视图。 org.eclipse. ui.views ::为工作台定义额外的视图。 org.eclipse.ui.commands:命令定义，定义命令、命令目录以及默认快捷键。 org.eclipse.ui.perspectiveExtensions :扩展其他插件定义的透视图。允许添加菜单、工具栏项目、快捷键、视图等等。 org.eclipse.ui.menus :将命令与界面菜单或工具栏绑定。确定菜单创建的区域。用来对菜单进行扩展，可以对主菜单，工具栏，上下文菜单进行扩展。 org.eclipse.ui.handlers:命令实现，(command的具体行为，定义command对应的c lass。 org. eclipse. ui. command Images: comand的图片。  注册程序在Rich Client中起着至关重要的作用，注册程序使用属性文件定义应用程序的实现类( classes)、启动图标、本地化文本、搜索顺序和外观等。许多基本的客户化任务是用注册程序完成的，同时注册程序在Teamcenter 的程序组内增添程序入口，用于启动新开发的程序。不论是二次开发，还是Rich Client的原开发，都是通过这一注册机制来实现程序的调用。\n在进行TC客户化时主要的配置文件可以通过修改registry完成。例如修改aif. properties文件中的修改显示信息 flashScreen. ICON=images/FlashScreen. jpg执行%TC_ _ROOT%\\portal \\registry\\genregxml. bat文件，如果修改了. properties文件需要执行此程序。执行这个文件的作用是，将所有jar包中的. properties文件中的配置信息写入到RegistryLoader. xml. gz文件及其多国语言文件中。Teamcenter中的Regisity类，从这些文件中预先读取配置信 息。\n也支持基本类型的注册，支持以下类型: color、 font、integer、float、 double、 char、 boolean、 string、 string array 和images。有些类型使用特殊的格式，如下所示:\nColor\nred, green, blue 255,255,255  Font\nfont-name,. font-style,font-size \u0026quot;Times Roman, Font.ITALIC, 12”  String array\none,two,three  快捷启动eclipse\n@echo off rem setlocal title Teamcenter Rich Client set TC_JRE_HOME=C:\\Program Files\\Java\\jdk1.8.0_201\\jre set TPR=D:\\Siemens\\Teamcenter10\\portal set FMS_HOME=D:\\Siemens\\Teamcenter10\\tccs set PATH=%SYSTEMROOT%\\system32;%FMS_HOME%\\bin;%FMS_HOME%\\lib;%TPR%;%AUX_PATH% set JAVA_HOME=%TC_JRE_HOME% set JRE_HOME=%TC_JRE_HOME% start \u0026quot;TAO ImR\u0026quot; /min cmd /c \u0026quot;D:\\Siemens\\Teamcenter10\\iiopservers\\start_imr.bat\u0026quot; start D:\\eclipse\\eclipse.exe -vm \u0026quot;C:\\Program Files\\Java\\jdk1.8.0_201\\bin\\javaw\u0026quot;  对插件程序的注册方法: .  将jar格式的文件复制到TC的plugins文件夹中:D:\\Siemens\\Teamcenter 10\\portal\\plugins; 打开D:\\Siemens\\Teamcenter10\\portal中 的register文件夹，浏览到注册文件程序genregxml.bat; 双击注册文件程序genregxml.bat，开始进行注册，等待注册文件程序genregxml.bat自动关闭; 清理TC缓存;C:\\Users\\Administrator\\Teamcenter 打开TC，验证程序功能，查看注册文件。关于\u0026ndash;\u0026gt;安装详细信息  注册程序在Rich Client中起着至关重要的作用，注册程序使用属性文件定义应用程序的实现类( classes)、 启动图标、本地化文本、搜索顺序和外:观等。许多基本的客户化任务是用注册程序完成的，同时注册程序在Teamcenter的程序组内增添程序入口，用于启动新开发的程序。不论是二次开发，还是Rich Client的原开发，都是通过这一注册机制来实现程序的调用。.\n1）、将Jar文件com. newProcess. rac_ 1. 0. jar复制到TC Plugins文件夹;D:\\Siemens\\Teamcenter10\\portal\\plugins\n2）、修改genregxml.bat，start D:\\eclipse\\eclipse.exe -vm \u0026quot;C:\\Program Files\\Java\\jdk1.8.0_201\\bin\\javaw\u0026quot;\n3）、双击注册文件\n4）、清理TC缓存\n5）、打开TC验证程序功能\n3.3TC开发环境搭建 配置tcEc lipse集成文件\nTeamcenter胖客户端本质是建立在Eclipse框架之上的应用程序，因此通过改造启动Teamcenter的启动脚本portal.bat，可以快速方便的构建一个可以直接启动Teamcenter的调试环境。\n1）、复制%TC_ ROOT%\\portal\\portal.bat\n2)、将脚本最后启动Teamcenter部分，修改为启动Eclipse程序。原始脚本:\n@echo Starting Teamcenter Rich Client. ···start Teamcenter.exe %* -vm \u0026quot;%JRE_ HOME%\\bin\\javaw.exe\u0026quot; -Vmargs -Xmx%VM XMX% -XX:MaxPermSize=128m -Xbootclasspath/a:\u0026quot;%JRE_ HOME%lib\\plugin.jar\u0026quot;;\u0026quot;%JRE_ HOME%\\lib\\deploy.jar\u0026quot;;\u0026quot;%JRE_ HOME%\\lib\\javaws.jar\u0026quot;  修改后脚本:\n@echo Starting Teamcenter Rich Client..start cmd /c \u0026quot;D: leclipseleclipse.exe\u0026quot; -vm \u0026quot;C:\\ProgramFiles\\Java\\jdk1.8.0_ 201\\bin\\javaw\u0026quot;  双击该脚本，启动Eclipse， 那么就具备了调试Teamcenter系统的基础环境。\n@echo off rem setlocal rem TPR is short for TC_PORTAL_ROOT to reduce command line length title Teamcenter Rich Client call \u0026quot;D:\\Siemens\\Teamcenter10\\install\\tem_init.bat\u0026quot; set TPR=D:\\Siemens\\Teamcenter10\\portal if not defined FMS_HOME set FMS_HOME=D:\\Siemens\\Teamcenter10\\tccs rem use AUX_PATH env var for any additional required paths rem save original path for external applications set ORIGINAL_PATH=%PATH% rem for optimal startup performance, keep the PATH length at a minimum set PATH=%SYSTEMROOT%\\system32;%FMS_HOME%\\bin;%FMS_HOME%\\lib;%TPR%;%AUX_PATH% set JAVA_HOME=%TC_JRE_HOME% set JRE_HOME=%TC_JRE_HOME% start \u0026quot;TAO ImR\u0026quot; /min cmd /c \u0026quot;D:\\Siemens\\Teamcenter10\\iiopservers\\start_imr.bat\u0026quot; :start_portal cd /d %TPR% set CLASSPATH=.; set VM_XMX=1024m rem Set DJIPJL_VMARG environment variable IF EXIST \u0026quot;%TPR%\\DJIPJL\\setenv.cmd\u0026quot; call \u0026quot;%TPR%\\DJIPJL\\setenv.cmd\u0026quot; @echo Starting Teamcenter Rich Client... start D:\\eclipse\\eclipse.exe -vm \u0026quot;C:\\Program Files\\Java\\jdk1.8.0_201\\bin\\javaw\u0026quot;  i、配置Eclipse JRE的首选项\n1)、使用tcEclipse快捷方式启动Eclipse。 2）、单击菜单:窗口→首选项 3）、打开“安装JRE”窗口。自Preferences\nii、添加JRE位置和系统库\n1）、单击添加。 2）、在Add JRE对话框中，选择Standard VM，然后单击下一步。 3）、单击目录\u0026hellip;导航到JAVA_HOME，然后单击确定。 4）、等待作为Eclipse中填入的JRE系统库。 ii、更改Preference以使用新安装的JRE 1）、在Preferences对话框，请确认所安装的JRE被选中。 2）、取消选择默认安装的JRE。 3）、选择添加的jdk1.8.0 45的JRE。 4）、保持Preferences窗口打开。\niii、设置Eclipse优先目标平台Teamcenter 由于当前针对Teamcenter平台使用Eclipse进行开发，因此需要将Eclipse开发平台设置为Teamcenter。 1）、单击菜单:窗口- \u0026gt;首选项。\n2）、双击Plug-in Development树将其展开，选择Target Platform。\n3）、在Target Platform对话框中，单击Add\u0026hellip; ，打开“New Target Definition\u0026rdquo;窗口\n4）、初始化目标定义为: Nothing: Start with an empty target definition，点击下一步。\n5）、在位置选项卡上，单击“添加”，并使用目录选项，浏览到胖客户端位于:%TC_ ROOT%\\portal。\n6）、单击Finish。 7）、更改名称: Tc10 Rich Client, 然后单击Finish。 8）、设置“TC10 Rich client\u0026rdquo;为激活状态。\niiii、设置Teamcenter调试环境参数 1）、单击Run-→Run Configuration\u0026hellip;. 2）、双击Eclipse Application。 3）、名称输入“Tc10.1 Rich Client\u0026rdquo;。\n4）、选择Arguments选项卡，在VM参数区域中，输入-Xms256m -Xmx1024m,设置JVM最大内存参数为1024m。 5）、保留值的其余部分保持不变。\n创建TC插件项目 i、创建新项目\n(1)、单击文件- +新建→项目 (2)、从项目列表中选择Plug-in Project。 (3) 、单击下一步。\nii、输入项目信息 (1)、对于项目名称，键入c9.mycustom (2)、清除源文件夹框。 (3)、保留值的其余部分保持不变。 (4)、单击下一步。\niii、添加插件信息 (1)、在Plug-in Content对话框中，在Vendor框 中输入training Class。\n(2）、该值的其余部分应默认\niiii、完成创建 (1)、选择创建检查插件使用的模板“hello， world command\u0026rdquo;。\n(2)、单击Finish。\niiiii、检查调试配置项 (1)、单击Run-→Run Configuration\u0026hellip;.，查看各项参数设置。\n调试测试\n(1)单击Eclipse的运行菜单run，运行程序;\n调试测试\n(2)、在TC登录界面输入账号和密码，登录TC系统; (3)、单击TC中的菜单:帮助一-\u0026gt;关于，弹出TC10的关于对话框; (4)、在“安装详细信息”中可以检索到自定义的插件。 (5)、在TC中可以查看程序功能。\n项目打包与部署\n(1)、单击文件“导出”，弹出到处对话框，选择“导出”，选择“Deployment plug-in and fragments\u0026rdquo; ;\n(2)、选择要导出的插件项目及路径，默认设置在%TC_ ROOT %/Portal文件夹中单击完成按钮，执行导出任务; (3)、在TC的插件文件夹中查看导出的插件包;\n(4)、执行插件包的注册; (5)、打开TC，从“安装详细信息”中检索插件包。\n配置反编译环境 点击Eclipse中菜单windows- \u0026gt; preference。\n选中导航树上的Java \u0026gt;JadClipse\n编辑Path to decompiler,\n内容为刚刚下载的jadnet158.zip所解压缩后路径,如右图所示,路径是软件环境中的具体路径。\n设置Class文件默认查看器选中导航树上的General \u0026gt;Editors→File Associations，\n在右边列表里,选中*.class确保\u0026rdquo;JadClipse Class FileViewer\u0026rdquo;是默认(default)\n这样反编译工具JAD就和Eclipse集成到一-起了,只要在Eclipse中双击Class文件就能自动进行编译并显示源代 码。不过有时候反编译会不完全。\n3.4客户化开发常用接口 com.teamcenter.rac.aifrcp Teamcenter基础客户化插件，在该插件中定义了主要的接口以及抽象类、出口类等，如:\nAbstractAIFApplication AbstractAIFSession AbstractAIFDialog AbstractAIFOperation AlFDesktop AIFPortal AbstractAI FA ction  Teamcenter基础客户化插件，在该插件中定义了主要的接口以及抽象类、出口类等，如:\nAbstractAI FApplication  用于创建Application Integration Frame(AIF )应用程序的基本AIFApplication类。该类包含AbstractAIFApplication的定义。它被用作所有AIF应用程序都要继承的基类。\ngetSession() initialize(java.util.Map parameters) open(InterfaceAIFComponent[] components ) refresh()  Teamcenter基础客户化插件，在该插件中定义了主要的接口以及抽象类、出口类等，如:\nAbstractAIFSession  这个类表示抽象的AIF会话对象，应用程序集成框架要求它的注册应用程序实现这个对象。子类包括TCSession。\ngetUserName() login() refresh()  com.teamcenter.rac .common Teamcenter的一- 些动作和菜单都在该插件包中进行了定义和注册，如菜单栏，工具栏，以及右键菜单等。一般的菜单动作都在com.teamcenter.rac.common.actions中进行了定义，如新建Item，Dataset, folder.\n1.在该包中建LNewltemAction类,并继承AbstractAIFAction类，实现public void run(方法。\n2.在action.properties文件中进行了注册，如下所示:\nFile-\u0026gt; New -\u0026gt; Item\nnewItemAction=com. teamcenter.rac.common. actions. NewItemAction newItemAction.ICON=images/newitem_ 1 6.png newItemAction.COMM AND=newItem( Command newItem Action.ACCELERATOR=ctrl pressed T newItemC ommand=com.teamcenter.rac.commands. newitem.N ewItemCommand  3.相应的，在该插件中对应一一个com.teamcenter.rac.commands.newitem包，创建Item 的业务逻辑都在该包中进行了实现。\ncom.teamcenter.rac.external Teamcenter插件中引用到的第三方类大部分都在该插件中进行了继承，可以说该插件为资源性插件\ncom.teamcenter.rac .kernal 对于客户端开发，都是基于Kernel API组件的，通过Kernel API，可以调用服务器端的功能，实际上Kernel API用 于Rich Client的ITK界面。进程(Session)对象是Kernel API的核心，通过-一个组件或者应用程序的getSession( )方法可以获取该对象的引用，AIFComponentManager是一个当前Session中所存组件的缓存器。二次开发工作所涉及的对象是:进程(Session)、 类型(Type)、服务( Service)、组件(Component)，在做二次开发的时候，如果要从当前的组件转到其他的组件，一般通过Session来进行。\nType组件存在于Teamcenter的每一类对象类型中，主要用来执行如:创建这样的任务，就面向对象来说，当一个对象还没有示例化的时候，无法调用其create方法，所以必须首先获得-一个指向Session的引用，这样即可从Session中获得Type组件。例如:创建-一个Folder的代码如下(假设当前已经获得了一个Session):\nTCComponentFolderType foldertype= ( TCComponentFolderType).getTypeComponent(\u0026quot;Folder\u0026quot;); TCComponentFolder folder= foldertypecreate(\u0026quot;Folder Name\u0026quot;, \u0026quot;Folder Description\u0026quot;, \u0026quot;Folder Type\u0026quot; ); .  Kernel API面向对象的本质是通过应用程序接口(API)来满足用户的需求，整个Kernel的方法模式是创建对象、查找对应的 Type组件和对对象执行操作，组件类中的方法和服务是定义好的就Kernel而言，另外一个需要注意的问题是: Rich Client中所有的组件都是基于属性(property)的，即当要获取-一个对象名称的时候不能用getName( )方法(实际上也没有这个方法)，而是通过getProperty(object_ name; )的方法来完成这个功能。\n这主要是因为整个的Kernel是建立在属性(property)层之上的，所以组件类具备获取属性信息的能力，而新建的类是继 承自TC Component组件类的，显然具备获取属性(property)信息的能力。比如当获取-一个BOMLine的数量属性的时候，通过BOMLine.getProperty( bl_ _quantity )即可得到。.\nTCSession session = RACUIUtil.getTCSession0; AbstractAIFUIApplication app = AIFUtility.getCurrentApplication0; AIFComponentContext[] selectedContexts = app.getTargetContexts(); InterfaceAIFComponent component = context.getComponent(; TCComponentItem targetItem = (TCComponentItem)component; TCComponentItemRevision rev = targetItem.getLatestItemRevision(; TCComponentForm form = (TCComponentForm )rev.getRelatedComponent(\u0026quot;IMAN_ master_ form_ rev\u0026quot;); if(form.getProperty(\u0026quot;user_ _data_ 1\u0026quot;)== =\u0026quot;\u0026quot; || form.getProperty(\u0026quot;user_ _data_ 2\u0026quot;)=\u0026quot;\u0026quot;) { MessageBox.post(\u0026quot;ITEM无法取到用户数据属性! \u0026quot;, \u0026quot;提示\u0026quot;, MessageBox.INFORMATION); }  该插件对业务对象进行了组件的定义，系统中每个业务对象都在该插件中有相应的类去实现。如Folder是文件夹对象,该对象对应的系统类是:\n1)、TCComponentFolder\n该类继承了TCComponent类。扩展定义了Folder的获取以及和属性的修改方法。基本上所有的业务对象都继承于TCComponent类。相应的我们可以联想到，Item对 应的组件类为TCComponentItem; Dataset对 应的组件类为TCComponentDataset。\n该插件对业务对象进行了组件的定义，系统中每个业务对象都在该插件中有相应的类去实现。如Folder是文件夹对象，该对象对应的系统类是:\n2）、一个业务类对应的组件类相应的也会对应-一个业务类型类,如Folder对应的业务类型组件类为TCComponentFolderType。该类继承于TCComponentType类。相应的我们可以联想到，Item对应的组件类型类为TCComponentItemType; Dataset对应的组件类型类为TCComponentDatasetType。该类主要扩展定义了相应的业务对象的创建以及另存为等方法。\n通过业务对象对应的类型组件类去创建业务对象，还是以Folder对象为例:\nTCComponentFolderType t = (TCComponentFolderType) session.getTypeComponent(\u0026quot;Folder\u0026quot;); TCComponentFolder f= t.create(\u0026quot;My Folder Name\u0026quot;,\u0026quot;My Folder Description\u0026quot;, \u0026quot;My Folder Type\u0026quot;);  com.teamcenter.rac.tcapps Teamcenter中部分应用的基础实现和业务逻辑都在该类中进行了实现，该类也定义了\u0026ndash;些公共组件等。\n该插件是Teamcenter对大部分Swing组件进行了继承与重写。如: iTextField继承 于JTextField; iComboBox类为 Teamcenter自己定义的组件。\n该插件中还定义了一些公共工具类，如: TcLogger日志控制类，Registry注册控制类等 。\ncom.teamcenter.rac.cme.mpp\t对MSE应用进行了实现 com.teamcenter.rac.pse\t对结构管理器进行了实现 com.teamcenter.rac.query builder\t对查询构建器进行了实现 com.teamcenter.rac.explorer\t对浏览器进行了实现  任务要求: 1)、掌握jar的解压方式; 2)、掌握使用Common包中的类，构建Jar包，实现快捷菜单添加新建零组件新建数据集的功能。\n在EcIipse中创建一个新的插件项目，命名为com.newCreate，不使用模板;\n新建plugin. xml文件，调用Common包中的newltem，newDataset类， 实现右键新建Item,新建数据集的功能。\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;?eclipse version=\u0026quot;3.4\u0026quot;?\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.commands\u0026quot;\u0026gt; \u0026lt;command id=\u0026quot;CustNewItem\u0026quot; name=\u0026quot;Create New Item\u0026quot;/\u0026gt; \u0026lt;command id=\u0026quot;CustNewDataset\u0026quot; name=\u0026quot;Create New Dataset\u0026quot;/\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.handlers\u0026quot;\u0026gt; \u0026lt;handler commandId=\u0026quot;CustNewDataset\u0026quot; class=\u0026quot;com.teamcenter.rac.handlers.LegacyHandler:newDatasetAction:com.teamcenter.rac.common.actions.actions\u0026quot; /\u0026gt; \u0026lt;handler commandId=\u0026quot;CustNewItem\u0026quot; class=\u0026quot;com.teamcenter.rac.handlers.LegacyHandler:newItemAction:com.teamcenter.rac.common.actions.actions\u0026quot; /\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.menus\u0026quot;\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;popup:org.eclipse.ui.popup.any?after=additions\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;CustNewItem\u0026quot;\u0026gt;\u0026lt;/command\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;popup:org.eclipse.ui.popup.any?after=additions\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;CustNewDataset\u0026quot;\u0026gt;\u0026lt;/command\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;/plugin\u0026gt;  修改p lugin.xmI文件，调用Common包中的newltem，newDataset类， 实现右键新建Item，新建数据集的功能。\n思考:此处设置的p lugin. xmI脚本文件中，和com. newProcess. rac_1.0解压之后的p lugin.xm |做个比较。\n在runtime选项卡中添加导出包。\n在Build选项卡中，勾选.上plugin. xml文件，确保生成jar包时，plugin. xml也在包中。\n修改Minifest清单文件如下。\nManifest-Version: 1.0 Bundle-ManifestVersion: 2 Bundle-Name: NewCreate Bundle-SymbolicName: com.newCreate;singleton:=true Bundle-Version: 1.0.0.qualifier Bundle-Activator: com.newcreate.Activator Bundle-Vendor: Mycom Require-Bundle: org.eclipse.core.runtime, com.teamcenter.rac.common;bundle-version=\u0026quot;10000.1.0\u0026quot;, org.eclipse.core.runtime.compatibility;bundle-version=\u0026quot;3.2.200\u0026quot;, com.teamcenter.rac.kernel;bundle-version=\u0026quot;10000.1.0\u0026quot;, com.teamcenter.rac.aifrcp;bundle-version=\u0026quot;10000.1.0\u0026quot;, org.eclipse.ui;bundle-version=\u0026quot;3.8.0\u0026quot;, com.teamcenter.rac.external;bundle-version=\u0026quot;10000.1.0\u0026quot; Import-Package: com.teamcenter.rac.commands.newitem Import-Package: com.teamcenter.rac.commands.newdataset Bundle-RequiredExecutionEnvironment: JavaSE-1.7 Bundle-ActivationPolicy: lazy Export-Package: com.newcreate  生成结束后，打包jar包，放到p lugin文件夹中，并通过genr egxml. bat注册，清除缓存后登录TC查看功能结果。\n3.5TCSession的使用 在进行Teamcenter客户化(二次开发)前，我们首先要了解哪些是核心API。只有掌握了核心API的使用，才能游刃有余的进行定制开发。下图展示了Teamcenter的核心API。从图中可以看到TC Session是核心API的核 心，通过TC Session沟通了应用程序AbstractAIFUIApplication、业务对象TCComponent、缓存AIFComponentManager、数据类型Type、业务服务Service。其中Type和Services是 各种相关类的集合。\nTcSession类在com.teamcenter.rac.kernel包中，是com.teamcenter.rac.aif.kernel.AbstractAIFSession的子类。TC会话负责登录到TC，并记录会话信息。它扩i展了AbstractAIFSession类的功能，使用AIF会话管理器管理会话。AIF : Application Integration Framework\n获取TCSession的三种办法 从当前应用程序直接获取TC Session AbstractAIFUIApplication app =AIFUtility.getCurrentApplication(); TCSession tcSession = (TCSession) app.getSession();  AbstractAIFUIApplication类在com.teamcenter.rac.aif包中，是com.teamcenter.rac.aif.AbstractAIFApplication的子类。\n从TCComponent对象上获取TC Session TCSession tcSession = null; AbstractAIFUIApplication app = AIFUtility.getCurrentApplication(); //获取选择的目标对象 InterfaceAIFComponent target = app.getTargetComponent(); if(target != null){ TCComponent tcComp = (TCComponent)target; tcSession = target.getSession(; }  通过ISessionService获取到TCSession 在启动Teamcenter后，TCSession缓存到 了AIFSessionManager中,而AIFSessionManager实现了ISessionService接口。\nISessionService iss = AifrcpPlugin. getSessionService(); TCSession tcSession = null; try { tcSession =(TCSession)iss.getSession( \u0026quot;com.teamcenter.rac.kernel.TCSession\u0026quot;); } catch (Exceptione) { e.printStackTrace(); }  获取当前TC信息 tcSession.getUser(); //获取用户 tcSession. getCurrentGroup(); //获取组信息 tcSession.getGroup(); tcSession.getCurrentOrganization(); tcSession.getLoginGroupOrganization(); tcSession.getCurrentRole); // 获取角色. tcSession.getRole();  设置当前用户 tcSession.setCurrentGroupMember(TCComponentGroup,TCComponentRole); tcSession.setCurrentOrganization(TCComponentGroup); tcSession.setCurrentProject(TCComponentProject);  DBA用户旁路功能打开 首选要判断是否为DBA角色。注意:实际上，非BA用户也是可以开通旁路功能的，但是实现的方式稍微复杂些。在某些业务场景下，可能存在这个超越权限的特殊处理，一般是通过代码的方式，使用完后，及时关闭。\ntcSession.enableBypass(true);  获取Type 函数:\nTCComponentType type =tcSession.getTypeComponent(\u0026quot;XXXType\u0026quot;)  Type组件，存在于Teamcenter的所有数据类型对象中，比如Item、Dataset、 Folder、 Revision等。 这种Type组件主要用于执行一些.如对象的创建、对象的查找等功能。因此，当需要创建对象的时候，首先应该想到通过Type实现。\n以下是一些常用的Type:\n 表单: TCComponentFormType Item对象: TCComponentItemType 版本对象: TCComponentItemRevisionType 数据集: TTCComponentDatasetType 文件夹: CComponentFolderType 分类对象: TCComponentICOType 项目: TCComponentProjectType 查询: TCComponentQueryType 流程: TCComponentProcessType 时间表: TCComponentScheduleType BOM行: TCComponentBOMLineType BOM: TCComponentBOM WindowType 工艺对象: TCComponentMEProcessType\n 例如创建文件夹功能代码如下:\nTCComponentFolderType type = (TCComponentFolderType) tcSession.getTypeComponent(\u0026quot;Folder\u0026quot;); TCComponentFolder f= type.create(\u0026quot;My Folder Name\u0026quot;, \u0026quot;MyFolder Description\u0026quot;，\u0026quot;My Folder Type\u0026quot;);  getTypeComponent函数中传递的参数，多数情况下， 就是TCComponentXXXType中的XXX。但是也有特列。更准确的说这个参数应该与对象的存储类名\u0026ndash;致。例如:\nTCComponentQueryType queryType = (TCComponentQueryType)tcSession.getTypeComponent(\u0026quot;ImanQuery\u0026quot;); TCComponentProjectType tcComponentProjectType =(TCComponentProjectType)tcSession.getTypeComponent(\u0026quot;TC_ Project\u0026quot;); TCComponentProcessType processType =(TCComponentProcessType) tcSession.getTypeComponent(\u0026quot;Job\u0026quot;);  对于自定义的对象类型N4MTMOPTrackingRevision，获取参数的 代码如下:\nTCComponentType tcComptype =tcSession.getTypeComponent(\u0026quot;N4MTMOPTrackingRevision\u0026quot;);  获取Service服务 以下是在二次开发过程中常用的几个服务: (1)首选项服务，可以操作与首选项相关的大部分操作。\nTCPreferenceService preferenceService =tcSession. getPreferenceService();  (2)分类管理服务，可以完成大部分分类管理操作，包括创建 分类对象、查找分类对象、获取分类结构信息等。\nTCClassificationService classi ficationService =tcSession. getClassificationService();  3.6创建TC对象 TCAPI接口  TCComponent TCComponentItem TCComponentI temRevision . TCComponent ItemType . TCComponentFolderType TCComponentUser TCComponentPerson TCComponentGroup TCComponentRole TCComponentForm TCComponentBOMW indow TCComponentRevi si onRule . TCComponentiTextField JCheckBox JFi 1 eChooser JButton JPanel JLabel JTextArea LOVComboBox，LOVUIComponent,TCComponentListOfValues Jtable JDialog DateButton\n Teamcenter中对象的创建一般都是通过会话获取要创建 对象的类型，然后再根据类型去创建具体的数据对象。每种 对象的创建用的函数方法都不一样。下面将根据不同对象的 创建方式进行说明: 1. Folder 的创建。 2. Form的创建。 3. Item的创建。 4. Dataset 的创建。\nFolder 文件夹的创建需要对三个参数赋值，即文件夹名称、文件夹描述、文件夹的类型，以下是系统中创建文件夹的代码。\nTCComponentFolderType t = (TCComponentFolderType) session. getTypeComponent (\u0026quot;Folder\u0026quot;) ; TCComponentFolder f=t. create(\u0026quot; My Folder Name ”，” MyFolder Description\u0026quot;, \u0026quot;My Folder Type\u0026quot;) ;  Form的创建: Form的创建和Folder的创建类似，需要对三个参数赋值。Form名称、Form描述，以及Form类型。\nTCComponentFormType tccomponentFormType = (TCComponentFormType)session. getTypeComponent (' MyForm' ) ; TCComponentForm tccomponentForm =tccomponentFormType.create (' MyForm', \u0026quot;MyFormDescription\u0026quot;,\u0026quot;MyForm\u0026quot;) ;  Item的创建: Item的创建相对来说比前两个都复杂点，具体原理就是先根据系统类型从系统中获取编码和版本编码，然后进行创建。\nitem _ID和item Revision获取方法: TCComponentI temType tccomponenti temtype =(TCComponentItemType) session. getTypeComponent (i temType) ; String itemId = tccomponenti temtype.getNewID(); String itemRev = tccomponenti temtype.getNewRev();  Item单位获取方法 TCComponentType uom=session. getTypeComponent (\u0026quot;Uni tOfMeasure\u0026quot;) ; TCComponent[] uoms = uom.extent() ;  Item创建方法 TCComponentItem item =tccomponent i temtype. create (i temId, i temRev, itemType, itemName, i temD escription, uoms[0]); ((TCComponentFolder)target).add(\u0026quot;contents\u0026quot;,\u0026quot;item\u0026quot;) ;  Dataset的创建方法 数据集的创建涉及到命名引用，创建过程:先创建某一一个类型的数据集，然后把命名引用添加上去。代码如下:\nString as1[] = {url}; String as2[] = {\u0026quot;Text\u0026quot;}; String as3[] = {\u0026quot;Text\u0026quot;}; String as4[] = {\u0026quot;P1ain\u0026quot;}; TCComponentDatasetType tccomponentDatasetType =(TCComponentDatasetType)session. getTypeComponent(\u0026quot; Text\u0026quot;) ; TCComponentDataset tccomponentDataset =tccomponentDatasetType.create(dataFileName，\u0026quot;Text\u0026quot;,\u0026quot;Text\u0026quot;) ; tccomponentDataset.setFiles (as1,as2,as3,as4,);  查询构建器的调用 Teamcenter中有专门的查询构建器模块，我们可以通过配置查询构建器，然后通过代码对系统中的对象进行搜索，以下是调用代码:\nTCTextService tcTextService = session. getTextService() ; String asKey[] = tcTextService. getTextValue(“item_id\u0026quot;) ; String asValues[] =\u0026quot;00001\u0026quot;; InterfaceAIFComponent interfaceAifComponent [] =session.search(\u0026quot;ItemId...\u0026quot;，asKey，asValues) ;  Teamcenter中BOM结构的构建 Teamcenter中的BOM结构建立，具体方法是先在系统中创建B0MWindow对象，然后再得到B0MLine对象，分别在BOMLine.上进行添加即可，实现代码如下:\n获取版本规则 TCComponentRevisionRuleType tcComponentRevisionRuleType =(TCComponentRevisionRuleType)session. getTypeComponent (\u0026quot;RevisionRule\u0026quot;) ; TCComponentRevisionRule tcComponentRevisionRule =tcComponentRevisionRuleType. getDefaultRule() ;  创建BOMWi ndow TCComponentBOMWindowType tcComponentBomWindowType =(TCComponentBOMWindowType) session.getTypeComponent (\u0026quot;BOMWindow\u0026quot;) ; TCComponentBOMWi ndow tcComponentBomWindow =tcComponentBomWindowType. create(tcComponentRevisionRule) ;  获取BOMLine的两种方法 TCComponentB0MLine line= ((AbstractPSEApplication)app).getTopBOMLine() ;  TCComponentBOMLine []Lines= ( (AbstractPSEApplication) app).getSelectedBOMLines() ;  添加对象到BOMLine TCComponentBOMLine tcComponentBomLine1 =tcomponentBomWindow.setWindowTopLine (tcComponentItem,tcComponentI temRevision1，tcComponent,tcComponent1) ;  Java调用c的方法 有时候某些功能需要Java程序和C语言程序同时去处理，以下是Java程序调用C语言程序的方法，以调用C语言程序来创建I tem为例:\nTCUserService userServ = sessionObj.getUserService() ; Object objs = new Object[3]; String itemId = new String( \u0026quot;1234\u0026quot;); String itemRev = new String (\u0026quot;A\u0026quot;); String itemName = new String (\u0026quot;Nameof1234\u0026quot; ); objs[0] = itemId; objs[1] = itemRev; objs[2] = itemName; TCComponent itemComp = (TCComponent) userServ.call ( \u0026quot;createItem\u0026quot;,objs) ;  通过以下的方式，可以取得目前的session user所属的newstuff folder, 并将objects贴附在这个folder下\nTCComponentFolder newStuffFolder=tcfolder. getNewStuffFolder (session) ; newStuffFolder.add (\u0026quot;contents\u0026quot;,tcComponentItem) ;  通过以下的方式，建立一个已经存在的workflow template, 并将i tem贴附到target中:\nTCComponentProcessType tcComponentProcessType= (TCComponentProcessType) session. getTypeComponent(\u0026quot;Job' ) ; TCComponentProcess newProcess:s= (TCComponentProcess) tcComponentProcessType.create (PROCESS NAME， PROCESS DESC ，WORKFLOW TEMPLATE NAME，TCComponent[], Target : 1) ; TCComponentTaskTemplateType tcComponentTaskTemplateType =(TCComponentTaskTemplateType) session. getTypeComponent ( \u0026quot;EPMTaskTemplate\u0026quot;); tcComponentTaskTemplate=tcComponentTaskTemplateType.extentReadyTemplates (true) ;  第四章 菜单定制是各种软件及其开发平台都会提供的必备功能。Teamcenter平台继承自Eclipse平台，其菜单功能与Eclipse平台是一脉相承的，因此Teamcenter平 台也提供了丰富的菜单功能项。如何实现Teamcenter的菜单功能，是Teamcenter二次 开发者必须掌握的重要技能。本章节将重点介绍Teamcenter中菜单的定制方法，并且以示例的方式引导读者深入了解Teamcenter的菜单定制功能。\n菜单定制 Teamcenter Rich Client客户端本身是一个RCP程序，Teamcenter菜单的扩展遵循Ecl ipse菜单扩展的规则，给开发 人员提供了很好的用户体验。 Teamcenter菜单种类包括:\n 主菜单. 上下文菜单 视图/编辑器菜单 工具栏按钮 发送到菜单 切换菜单项Toggle menu Item  Teamcenter主菜单 主菜单一般位于软件的最顶层。下 图中的Sample Menu， 就是二次开发定制的主菜单，我们称这类菜单为一级主菜单。点开一-级主菜单“编辑”后，展开的一般是二级主菜单。Teamcenter平台即支持定制一 级菜单，也支持在OOTB平台.上定制二级菜单。主菜单在哪些应用程序显示，在什么情况下显示，也是可以定制的。\n上下文菜单 上下文菜单(Context Menu)，也称为快捷菜单(Shortcut Menu) ,右键点击时才会出现，出现频率较高的菜单项才会出现在上下文菜单中。上下文菜单具有很强的灵活项，随着点击对象的不同，弹出的菜单也会有相应的变化。\n视图/编辑器菜单 视图/编辑器菜单(ViewPart/EditorPartMenu)，最右侧弹出的就是“详细信息”视图的菜单。这部分区域的菜单，也是可定制的。\n工具栏按钮 工具栏(Toolbar) 是显示位图式按钮行的控制条，使用位图式按钮用来执行命令。按工具栏按钮相当于选择菜单项;如果某个菜单项具有和工具栏按钮相同的ID，那么使用工具栏按钮将会调用映射到该菜单项的同一个处理程序。可以配置按钮，使其在外观和行为上表现为普通按钮、单选按钮或复选框。\n菜单扩展点 按照RCP开发方式，菜单配置信息位于plugin. xml文件中,Teamcenter提供了两种扩展点供用户添加菜单到相应的位置:\n org.eclipse.ui.actionSets,简称为Actions方式;\norg.eclipse.ui.commands，简称为Commands方式。\n Actions,方式为界面上不同区域的表现方式提供了相应的扩展点，并且没有分离其界面表现和内在实现。主要在Teamcenter2007及以前的版本使用，后续版本使用Commands方式扩展。因此，课程仅讲解Commands方式的菜单项扩展。\nCommands;方式通过三步设置，有效的达到界面表现和内部实现的分离:\n 通过org. eclipse. ui. commands 扩展点创建命令和类别(Category)，并且可以把某些命令放在- 一个类别(Category) 中; 通过org. eclipse. ui. menus指定命令出现在界面的哪个区域(视图菜单/主菜单/上下文菜单) ; 通过org. eclipse. ui. handlers指定命令的实现。  针对上下文菜单，除了Actions方式和Comnands方式均可创建外，Eclipse还提供了另外一●种创建上下文菜单的扩展点 org. ecl ipse. ui. popupMenus,简称为popupMenus方 式。\n采用Commands方 式创建视图菜单，需要引入org. ecl ipse. ui. menus扩展点、org. eclipse. ui. handlers扩 展点和org. eclipse. ui. bindings扩展点。相关知识点包括:\n 菜单项扩展点 locationURI语法规则 菜单显示/隐藏控制方法  菜单项扩展点 在具体介绍各菜单扩展点时，我们使用3.3节“hello,world command” 工程中自动创建的菜单，这份配置主要包括 四个扩展点: 第一个扩展点，定义了命令ID:\ncom.teamcenter.helloworld.commands.sampleCommnand  在这个扩展点中，主要定义command id。\n\u0026lt;extension point=\u0026quot;org.eclipse.ui.commands\u0026quot; \u0026gt; \u0026lt;category name=\u0026quot;Sample Category\u0026quot; id=\u0026quot;com.teamcenter.helloworld.commands.category\u0026quot;\u0026gt; \u0026lt;/category\u0026gt; \u0026lt;command name= =' Sample Command\u0026quot; categoryId=\u0026quot; com.teamcenter.helloworld.commands.category\u0026quot; id=\u0026quot; com.teamcenter.helloworld.commands.sampleCommand\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/extension\u0026gt;  第三个扩展点，是给COMMANID增加快捷键的绑定。这个 扩展点主要用于增强用户体验。M1+6代表了当按下快捷键. Ctr1+6时也会执行相应的命令，M2代表Shift。\n\u0026lt;extension point=\u0026quot; org. eclipse. ui. bindings' \u0026gt; \u0026lt;key commandId=\u0026quot; com.teamcenter.helloworld.commands.sampleCommand\u0026quot; contextId=”org.eclipse.ui.contexts.window\u0026quot; sequence=“M1+6\u0026quot;schemeId=\u0026quot; org. eclipse. ui. defaul tAcce leratorConf iguration\u0026quot;\u0026gt; \u0026lt;/key\u0026gt; \u0026lt;/extension\u0026gt;  第四个扩展点，完成了采单的定义。这个扩展点需要重 点掌握，我们大部分的菜单配置项，都在这个扩展点中实现。.\n\u0026lt;extension point=\u0026quot; org.eclipse.ui.menus\u0026quot; \u0026gt; \u0026lt;menuContribution locat ionURI=' menu:org. eclipse. ui. main. menu?after additions' \u0026gt; \u0026lt;menu 1abe1=\u0026quot;Sample Menu\u0026quot; mnemonic=\u0026quot;M\u0026quot; id= 'com.teamcenter.helloworld.menus.sampleMenu'\u0026gt; \u0026lt;command commandId= =\u0026quot; com. teamcenter. hellowor ld. commands. sampleCommand\u0026quot; mnemonic=\u0026quot;S\u0026quot; id=\u0026quot; com. teamcenter. hel lowor ld. menus. sampl eCommand”\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/menu\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;menuContribution locationURI= toolbar:org.eclipse.ui.main.toolbar?after=additions' \u0026gt; \u0026lt;toolbar id= \u0026quot;com.teamcenter.helloworld.toolbars.sampleToolbar\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot; com. teamcenter. hel loworld. commands. sampl eCommand\u0026quot; icon :\u0026quot;icons/sample.gif\u0026quot; tooltip=\u0026quot;Say hello world\u0026quot; id=\u0026quot; com.teamcenter.helloworld.toolbars.sampleCommand^ \u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/toolbar\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;/extension\u0026gt;  locationURI语法规则 在定义菜单在Teamcenter出现的位置，需要设置locationURI的参数值。locationURI属性格式如 下:\n\u0026lt;menuContribution locationURI=\u0026quot;[Scheme]:[id] ? [argument-list] \u0026quot;\u0026gt;  其中:\n Scheme 为该菜单项出现的区域，为menu、popup、toolbar中 的任何一个。 id为菜单区域ID,即现在已经存在的菜单ID、视图ID。 argument-list为该菜单项出现在指定菜单的位置。  主菜单定义 通过Commands 方式把菜单项添加到主菜单及其工具栏上，和视图菜单一样，也是通过扩 展点org. eclipse. ui. menus ;实现，需要设定其menuContribution的locationURI。\n例如，添加一个菜单(菜单可以包含若干个菜单项)到主菜单栏中的某一个位置，其locationURI 为:\nmenu:org.eclipse.ui.main.menu?before=Edit  例如，把菜单项添加到已经存在的菜单当中。例如，添加-一个菜单项到File主菜单当中，其locationURI为: menu:File? after=additionso . 例如，在DetailsView的 下拉菜单加一一个 菜单项，其MenuContribution的locationURI 应为: menu: org.eclipse.ui.views.DetailsView?after= additions;\n快捷键参数\nD:\\Siemens\\Teamcenter10\\portal\\portal.bat -nl zh_CN D:\\Siemens\\Teamcenter10\\portal\\portal.bat -nl en_US  plugin.xml文件中定义的脚本程序：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;?eclipse version=\u0026quot;3.4\u0026quot;?\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.commands\u0026quot;\u0026gt; \u0026lt;category name=\u0026quot;Sample Category\u0026quot; id=\u0026quot;c9.mycustom.commands.category\u0026quot;\u0026gt; \u0026lt;/category\u0026gt; \u0026lt;command name=\u0026quot;Sample Command\u0026quot; categoryId=\u0026quot;c9.mycustom.commands.category\u0026quot; id=\u0026quot;c9.mycustom.commands.sampleCommand\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.handlers\u0026quot;\u0026gt; \u0026lt;handler commandId=\u0026quot;c9.mycustom.commands.sampleCommand\u0026quot; class=\u0026quot;c9.mycustom.handlers.SampleHandler\u0026quot;\u0026gt; \u0026lt;/handler\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.bindings\u0026quot;\u0026gt; \u0026lt;key commandId=\u0026quot;c9.mycustom.commands.sampleCommand\u0026quot; contextId=\u0026quot;org.eclipse.ui.contexts.window\u0026quot; sequence=\u0026quot;M1+6\u0026quot; schemeId=\u0026quot;org.eclipse.ui.defaultAcceleratorConfiguration\u0026quot;\u0026gt; \u0026lt;/key\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.menus\u0026quot;\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;menu:org.eclipse.ui.main.menu?before=Edit\u0026quot;\u0026gt; \u0026lt;menu label=\u0026quot;Sample Menu\u0026quot; mnemonic=\u0026quot;M\u0026quot; id=\u0026quot;c9.mycustom.menus.sampleMenu\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;c9.mycustom.commands.sampleCommand\u0026quot; mnemonic=\u0026quot;S\u0026quot; id=\u0026quot;c9.mycustom.commands.sampleCommand\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;visibleWhen\u0026gt; \u0026lt;or\u0026gt; \u0026lt;reference definitionId=\u0026quot;com.teamcenter.rac.ui.inMainPerspective\u0026quot;/\u0026gt; \u0026lt;reference definitionId=\u0026quot;com.teamcenter.rac.cme.mpp.inMainView\u0026quot; /\u0026gt; \u0026lt;/or\u0026gt; \u0026lt;/visibleWhen\u0026gt; \u0026lt;/menu\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;menu:file?after=additions\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;c9.mycustom.commands.sampleCommand\u0026quot; icon=\u0026quot;icons/sample.gif\u0026quot; mnemonic=\u0026quot;S\u0026quot; id=\u0026quot;c9.mycustom.commands.sampleCommand3\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;toolbar:org.eclipse.ui.main.toolbar?after=additions\u0026quot;\u0026gt; \u0026lt;toolbar id=\u0026quot;c9.mycustom.toolbars.sampleToolbar\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;c9.mycustom.commands.sampleCommand\u0026quot; icon=\u0026quot;icons/sample.gif\u0026quot; tooltip=\u0026quot;Say hello world\u0026quot; id=\u0026quot;c9.mycustom.toolbars.sampleCommand\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/toolbar\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;menu:com.teamcenter.rac.ui.views.DetailsView?after=additions\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;c9.mycustom.commands.sampleCommand\u0026quot; icon=\u0026quot;icons/sample.gif\u0026quot; mnemonic=\u0026quot;S\u0026quot; id=\u0026quot;c9.mycustom.commands.sampleCommand2\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;toolbar:com.teamcenter.rac.ui.views.DetailsView?after=additions\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;c9.mycustom.commands.sampleCommand\u0026quot; icon=\u0026quot;icons/sample.gif\u0026quot; mnemonic=\u0026quot;S\u0026quot; id=\u0026quot;c9.mycustom.commands.sampleCommand22\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;/plugin\u0026gt;  上下文菜单 Commands;方式与添加视图菜单和主菜单的方式-样，通过设定其menuContribution的locationURI 来实现。 例如，添加一个上下文菜单到快捷菜单中，其locat ionURI为: popup:org.eclipse.ui.popup.any?after=additions\n菜单显示/隐藏控制方法 菜单控制是-一个常见的功能。例如，随着选定的内容或当前窗口的不同，菜单中的菜单项会有相应的变化(显示/隐藏或启用/禁用菜单项)。如何控制菜单是插件开发必须掌握的知识。Eclipse为菜单控制提供了两种方法，一种是通过扩展点;另一种是通过API的方式编写程序控制。通过Command方式创建的菜单，可以通过org. eclipse. ui. commands的visibleWhen 属性控制菜单的显示和隐藏。visibleWhen是用于控制菜单显示的核心表达式。该标签即可位于menu标签之下，也可位于command标签之前。尽管从官方的语法说明来看，可以作用于toobar标签下，但是经过测试toolbar 下的visibl eWhen标签不生效。通过org. eclipse. ui. handlers的activewhen 或enabledWhen 控制菜单的启用或禁用。\nvisibleWhen可以用在command、menu子节点下在menu标签下，添加如下代码，可以让该菜单及其子菜单，仅仅显示在“我的Teamcenter”、“制造工艺规划器中”和“分类”。“or.”标签用于在多个应用程序中显示。\n\u0026lt;visibleWhen\u0026gt; \u0026lt;or\u0026gt; \u0026lt;reference defini tionId=\u0026quot; com. teamcenter. rac. ui. inMainPerspective”/\u0026gt; \u0026lt;reference definitionId=\u0026quot; com. teamcenter. rac. cme. mpp. inMainView'/\u0026gt; \u0026lt;reference definitionId=\u0026quot; com. teamcenter. rac. classification. icm. inMainView\u0026quot; /\u0026gt; \u0026lt;/or\u0026gt; \u0026lt;/visibleWhen\u0026gt;  Teamcenter中常见的应用程序ID如下:\n “我的Teamcenter”: com.teamcenter. rac. ui.inMainPerspective “制造工艺规划器”: com.teamcenter. rac. cme. mpp. inMainView “结构管理器”: com. teamcenter. rac. pse. inMainView . “分类管理”: com. teamcenter. rac. classification. icadmin. inMainView “分类”:com. teamcenter. rac. classification. icm. inMainView “入门”: com. teamcenter. rac. gettingstarted. inMainView “项目”: com. teamcenter. rac. project. inMainView\n 实践练习一： 加载项目c9. mycustom，查看其扩展的设置方式，并修改:\n 自定义菜单sampl eCommand在Main menu中 出现的位置,出现在windows菜单中; 自定义菜单sampleCommand出现在上下文菜单中。  实践练习二： 定义两个主菜单报表输出、功能\n报表输出含有：产品报表导出\n功能：创建项目文件夹、创建数据文件夹、修改技术文档ID\n实例 工具栏toolbar \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;?eclipse version=\u0026quot;3.6\u0026quot;?\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.commands\u0026quot;\u0026gt; \u0026lt;command name=\u0026quot;Sample Command\u0026quot; id=\u0026quot;com.mycom.addbutton.commands.sampleCommand\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.handlers\u0026quot;\u0026gt; \u0026lt;handler commandId=\u0026quot;com.mycom.addbutton.commands.sampleCommand\u0026quot; class=\u0026quot;com.mycom.addbutton.handlers.SampleHandler\u0026quot;\u0026gt; \u0026lt;/handler\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.menus\u0026quot;\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;toolbar:navigator_Toolbar?after=additions\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;com.mycom.addbutton.commands.sampleCommand\u0026quot; icon=\u0026quot;icons/sample.gif\u0026quot; tooltip=\u0026quot;Say hello world\u0026quot; id=\u0026quot;com.mycom.addbutton.toolbars.sampleCommand\u0026quot;\u0026gt; \u0026lt;visibleWhen\u0026gt; \u0026lt;reference definitionId=\u0026quot;com.teamcenter.rac.ui.inMainPerspective\u0026quot;\u0026gt; \u0026lt;/reference\u0026gt; \u0026lt;/visibleWhen\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;/plugin\u0026gt;  菜单栏中添加一个新的菜单 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;?eclipse version=\u0026quot;3.6\u0026quot;?\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.commands\u0026quot;\u0026gt; \u0026lt;command name=\u0026quot;Sample Command\u0026quot; id=\u0026quot;com.mycom.addmenuitem.commands.sampleCommand\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.handlers\u0026quot;\u0026gt; \u0026lt;handler commandId=\u0026quot;com.mycom.addmenuitem.commands.sampleCommand\u0026quot; class=\u0026quot;com.mycom.addmenuitem.handlers.SampleHandler\u0026quot;\u0026gt; \u0026lt;/handler\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.menus\u0026quot;\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;menu:tools?after=additions\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;com.mycom.addmenuitem.commands.sampleCommand\u0026quot; mnemonic=\u0026quot;S\u0026quot; icon=\u0026quot;icons/sample.gif\u0026quot; id=\u0026quot;com.mycom.addmenuitem.menus.sampleCommand\u0026quot;\u0026gt; \u0026lt;visibleWhen\u0026gt; \u0026lt;reference definitionId=\u0026quot;com.teamcenter.rac.ui.inMainPerspective\u0026quot;\u0026gt; \u0026lt;/reference\u0026gt; \u0026lt;/visibleWhen\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;/plugin\u0026gt;  package com.mycom.addmenuitem.handlers; import org.eclipse.core.commands.AbstractHandler; import org.eclipse.core.commands.ExecutionEvent; import org.eclipse.core.commands.ExecutionException; import org.eclipse.ui.IWorkbenchWindow; import org.eclipse.ui.handlers.HandlerUtil; import org.eclipse.jface.dialogs.MessageDialog; /** * Our sample handler extends AbstractHandler, an IHandler base class. * @see org.eclipse.core.commands.IHandler * @see org.eclipse.core.commands.AbstractHandler */ public class SampleHandler extends AbstractHandler { /** * The constructor. */ public SampleHandler() { } /** * the command has been executed, so extract extract the needed information * from the application context. */ public Object execute(ExecutionEvent event) throws ExecutionException { IWorkbenchWindow window = HandlerUtil.getActiveWorkbenchWindowChecked(event); MessageDialog.openInformation( window.getShell(), \u0026quot;Addmenuitem\u0026quot;, \u0026quot;demo\u0026quot;); return null; } }  菜单栏选项\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;?eclipse version=\u0026quot;3.4\u0026quot;?\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.commands\u0026quot;\u0026gt; \u0026lt;category name=\u0026quot;Sample Category\u0026quot; id=\u0026quot;com.teamcenter.rac.toggleexample.commands.category\u0026quot;\u0026gt; \u0026lt;/category\u0026gt; \u0026lt;command categoryId=\u0026quot;com.mycom.toggle.commands.category\u0026quot; defaultHandler=\u0026quot;com.mycom.toggle.handlers.ToggleInfoHandler\u0026quot; id=\u0026quot;com.mycom.toggle.commands.infoCommand\u0026quot; name=\u0026quot;Info\u0026quot;\u0026gt; \u0026lt;state class=\u0026quot;org.eclipse.ui.handlers.RegistryToggleState:true\u0026quot; id=\u0026quot;org.eclipse.ui.commands.toggleState\u0026quot;\u0026gt; \u0026lt;/state\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;command categoryId=\u0026quot;com.mycom.toggle.commands.category\u0026quot; defaultHandler=\u0026quot;com.mycom.toggle.handlers.ToggleWarnHandler\u0026quot; id=\u0026quot;com.mycom.toggle.commands.warnCommand\u0026quot; name=\u0026quot;Warn\u0026quot;\u0026gt; \u0026lt;state class=\u0026quot;org.eclipse.ui.handlers.RegistryToggleState:false\u0026quot; id=\u0026quot;org.eclipse.ui.commands.toggleState\u0026quot;\u0026gt; \u0026lt;/state\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;command categoryId=\u0026quot;com.mycom.toggle.commands.category\u0026quot; defaultHandler=\u0026quot;com.mycom.toggle.handlers.ToggleErrorHandler\u0026quot; id=\u0026quot;com.mycom.toggle.commands.errorCommand\u0026quot; name=\u0026quot;Error\u0026quot;\u0026gt; \u0026lt;state class=\u0026quot;org.eclipse.ui.handlers.RegistryToggleState:false\u0026quot; id=\u0026quot;org.eclipse.ui.commands.toggleState\u0026quot;\u0026gt; \u0026lt;/state\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.menus\u0026quot;\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;menu:org.eclipse.ui.main.menu?after=additions\u0026quot;\u0026gt; \u0026lt;menu id=\u0026quot;com.mycom.toggle.menus.sampleMenu\u0026quot; label=\u0026quot;Error Level\u0026quot; mnemonic=\u0026quot;L\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;com.mycom.toggle.commands.infoCommand\u0026quot; label=\u0026quot;Info\u0026quot; mnemonic=\u0026quot;I\u0026quot; style=\u0026quot;toggle\u0026quot;\u0026gt; \u0026lt;visibleWhen\u0026gt; \u0026lt;reference definitionId=\u0026quot;com.teamcenter.rac.ui.inMainPerspective\u0026quot;\u0026gt; \u0026lt;/reference\u0026gt; \u0026lt;/visibleWhen\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;command commandId=\u0026quot;com.mycom.toggle.commands.warnCommand\u0026quot; label=\u0026quot;Warn\u0026quot; mnemonic=\u0026quot;W\u0026quot; style=\u0026quot;toggle\u0026quot;\u0026gt; \u0026lt;visibleWhen\u0026gt; \u0026lt;reference definitionId=\u0026quot;com.teamcenter.rac.ui.inMainPerspective\u0026quot;\u0026gt; \u0026lt;/reference\u0026gt; \u0026lt;/visibleWhen\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;command commandId=\u0026quot;com.mycom.toggle.commands.errorCommand\u0026quot; label=\u0026quot;Error\u0026quot; mnemonic=\u0026quot;E\u0026quot; style=\u0026quot;toggle\u0026quot;\u0026gt; \u0026lt;visibleWhen\u0026gt; \u0026lt;reference definitionId=\u0026quot;com.teamcenter.rac.ui.inMainPerspective\u0026quot;\u0026gt; \u0026lt;/reference\u0026gt; \u0026lt;/visibleWhen\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/menu\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;/plugin\u0026gt;  在右键上添加 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;?eclipse version=\u0026quot;3.6\u0026quot;?\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.commands\u0026quot;\u0026gt; \u0026lt;command name=\u0026quot;Sample Command\u0026quot; id=\u0026quot;com.mycom.addshortcut.commands.sampleCommand\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.handlers\u0026quot;\u0026gt; \u0026lt;handler commandId=\u0026quot;com.mycom.addshortcut.commands.sampleCommand\u0026quot; class=\u0026quot;com.mycom.addshortcut.handlers.SampleHandler\u0026quot;\u0026gt; \u0026lt;/handler\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.menus\u0026quot;\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;popup:org.eclipse.ui.popup.any?after=additions\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;com.mycom.addshortcut.commands.sampleCommand\u0026quot; mnemonic=\u0026quot;S\u0026quot; icon=\u0026quot;icons/sample.gif\u0026quot; id=\u0026quot;com.mycom.addshortcut.menus.sampleCommand\u0026quot;\u0026gt; \u0026lt;visibleWhen\u0026gt; \u0026lt;reference definitionId=\u0026quot;com.teamcenter.rac.ui.inMainPerspective\u0026quot;\u0026gt; \u0026lt;/reference\u0026gt; \u0026lt;/visibleWhen\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;/plugin\u0026gt;  \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;?eclipse version=\u0026quot;3.4\u0026quot;?\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.commands\u0026quot;\u0026gt; \u0026lt;command id=\u0026quot;CustNewItem\u0026quot; name=\u0026quot;Create New Item\u0026quot;/\u0026gt; \u0026lt;command id=\u0026quot;CustNewDataset\u0026quot; name=\u0026quot;Create New Dataset\u0026quot;/\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.handlers\u0026quot;\u0026gt; \u0026lt;handler commandId=\u0026quot;CustNewDataset\u0026quot; class=\u0026quot;com.teamcenter.rac.handlers.LegacyHandler:newDatasetAction:com.teamcenter.rac.common.actions.actions\u0026quot; /\u0026gt; \u0026lt;handler commandId=\u0026quot;CustNewItem\u0026quot; class=\u0026quot;com.teamcenter.rac.handlers.LegacyHandler:newItemAction:com.teamcenter.rac.common.actions.actions\u0026quot; /\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.menus\u0026quot;\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;popup:org.eclipse.ui.popup.any?after=additions\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;CustNewItem\u0026quot;\u0026gt;\u0026lt;/command\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;popup:org.eclipse.ui.popup.any?after=additions\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;CustNewDataset\u0026quot;\u0026gt;\u0026lt;/command\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;/plugin\u0026gt;  视图 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;?eclipse version=\u0026quot;3.6\u0026quot;?\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.commands\u0026quot;\u0026gt; \u0026lt;command name=\u0026quot;Sample Command\u0026quot; id=\u0026quot;com.mycom.customview.commands.sampleCommand\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.handlers\u0026quot;\u0026gt; \u0026lt;handler commandId=\u0026quot;com.mycom.customview.commands.sampleCommand\u0026quot; class=\u0026quot;com.mycom.customview.handlers.SampleHandler\u0026quot;\u0026gt; \u0026lt;/handler\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.menus\u0026quot;\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;menu:org.eclipse.ui.main.menu?after=additions\u0026quot;\u0026gt; \u0026lt;menu label=\u0026quot;Sample Menu\u0026quot; mnemonic=\u0026quot;M\u0026quot; id=\u0026quot;com.mycom.customview.menus.sampleMenu\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;com.mycom.customview.commands.sampleCommand\u0026quot; mnemonic=\u0026quot;S\u0026quot; id=\u0026quot;com.mycom.customview.menus.sampleCommand\u0026quot;\u0026gt; \u0026lt;visibleWhen\u0026gt; \u0026lt;reference definitionId=\u0026quot;com.mycom.customview.inMainView\u0026quot; /\u0026gt; \u0026lt;/visibleWhen\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/menu\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.views\u0026quot;\u0026gt; \u0026lt;view name=\u0026quot;MyCom Custom View\u0026quot; class=\u0026quot;com.mycom.customview.views.CustomView\u0026quot; id=\u0026quot;com.mycom.customview.views.CustomView\u0026quot;\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.core.expressions.definitions\u0026quot;\u0026gt; \u0026lt;definition id=\u0026quot;com.mycom.customview.inMainView\u0026quot;\u0026gt; \u0026lt;with variable=\u0026quot;activePartId\u0026quot;\u0026gt; \u0026lt;equals value=\u0026quot;com.mycom.customview.views.CustomView\u0026quot; /\u0026gt; \u0026lt;/with\u0026gt; \u0026lt;/definition\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;/plugin\u0026gt;  退出 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;?eclipse version=\u0026quot;3.4\u0026quot;?\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.commands\u0026quot;\u0026gt; \u0026lt;category name=\u0026quot;Sample Category\u0026quot; id=\u0026quot;com.teamcenter.rac.exit.commands.category\u0026quot;\u0026gt; \u0026lt;/category\u0026gt; \u0026lt;command name=\u0026quot;Sample Command\u0026quot; categoryId=\u0026quot;com.mycom.exitcommand.commands.category\u0026quot; id=\u0026quot;com.mycom.exitcommand.commands.sampleCommand\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;command defaultHandler=\u0026quot;com.mycom.exitcommand.handlers.SampleHandler\u0026quot; id=\u0026quot;com.mycom.exitcommand.command1.Exit\u0026quot; name=\u0026quot;Exit\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.handlers\u0026quot;\u0026gt; \u0026lt;handler commandId=\u0026quot;com.mycom.exitcommand.commands.sampleCommand\u0026quot; class=\u0026quot;com.mycom.exitcommand.handlers.SampleHandler\u0026quot;\u0026gt; \u0026lt;/handler\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.bindings\u0026quot;\u0026gt; \u0026lt;key commandId=\u0026quot;com.mycom.exitcommand.commands.sampleCommand\u0026quot; contextId=\u0026quot;org.eclipse.ui.contexts.window\u0026quot; sequence=\u0026quot;M1+6\u0026quot; schemeId=\u0026quot;org.eclipse.ui.defaultAcceleratorConfiguration\u0026quot;\u0026gt; \u0026lt;/key\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.menus\u0026quot;\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;menu:com.teamcenter.rac.ui.views.DetailsView?after=group4\u0026quot;\u0026gt; \u0026lt;menu id=\u0026quot;closeMenu\u0026quot; label=\u0026quot;Close\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;com.mycom.exitcommand.command1.Exit\u0026quot; label=\u0026quot;Exit\u0026quot; style=\u0026quot;push\u0026quot; tooltip=\u0026quot;Exit the application\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/menu\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;toolbar:com.teamcenter.rac.ui.views.DetailsView\u0026quot;\u0026gt; \u0026lt;toolbar id=\u0026quot;com.mycom.exitcommand.toolbar1\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;com.mycom.exitcommand.command1.Exit\u0026quot; icon=\u0026quot;icons/sample.gif\u0026quot; label=\u0026quot;Exit\u0026quot; style=\u0026quot;push\u0026quot; tooltip=\u0026quot;Exit the application\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/toolbar\u0026gt; \u0026lt;command commandId=\u0026quot;com.mycom.exitcommand.command1.Exit\u0026quot; icon=\u0026quot;icons/sample.gif\u0026quot; label=\u0026quot;Exit\u0026quot; style=\u0026quot;push\u0026quot; tooltip=\u0026quot;Exit the application\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;/plugin\u0026gt;  综合 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;?eclipse version=\u0026quot;3.4\u0026quot;?\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.commands\u0026quot;\u0026gt; \u0026lt;command name=\u0026quot;新建文件夹\u0026quot; id=\u0026quot;com.origin.custom.handler.newFolderHandler\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.handlers\u0026quot;\u0026gt; \u0026lt;handler commandId=\u0026quot;com.origin.custom.handler.newFolderHandler\u0026quot; class=\u0026quot;com.origin.custom.handler.NewFolderHandler\u0026quot;\u0026gt; \u0026lt;/handler\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.menus\u0026quot;\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;menu:org.eclipse.ui.main.menu?after=additions\u0026quot;\u0026gt; \u0026lt;menu label=\u0026quot;客户化菜单(M)\u0026quot; mnemonic=\u0026quot;M\u0026quot; id=\u0026quot;customMenus\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;com.origin.custom.handler.newFolderHandler\u0026quot; mnemonic=\u0026quot;S\u0026quot; icon=\u0026quot;icons/newfolder_16.png\u0026quot; id=\u0026quot;customMenus\u0026quot;\u0026gt; \u0026lt;visibleWhen\u0026gt; \u0026lt;reference definitionId=\u0026quot;com.teamcenter.rac.ui.inMainPerspective\u0026quot;\u0026gt; \u0026lt;/reference\u0026gt; \u0026lt;/visibleWhen\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/menu\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;toolbar:org.eclipse.ui.main.toolbar?after=additions\u0026quot;\u0026gt; \u0026lt;toolbar id=\u0026quot;customToolbar\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;com.origin.custom.handler.newFolderHandler\u0026quot; icon=\u0026quot;icons/newfolder_16.png\u0026quot; tooltip=\u0026quot;新建文件夹\u0026quot; id=\u0026quot;customToolbar\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/toolbar\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;popup:org.eclipse.ui.popup.any?after=additions\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;com.origin.custom.handler.newFolderHandler\u0026quot; mnemonic=\u0026quot;S\u0026quot; icon=\u0026quot;icons/newfolder_16.png\u0026quot; id=\u0026quot;customPopup\u0026quot;\u0026gt; \u0026lt;visibleWhen\u0026gt; \u0026lt;reference definitionId=\u0026quot;com.teamcenter.rac.ui.inMainPerspective\u0026quot;\u0026gt; \u0026lt;/reference\u0026gt; \u0026lt;/visibleWhen\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;/plugin\u0026gt;  第五章 五代码化定制任务\n5.1.1无代码化定制 实例:定制Teamcenter 胖客户端logon window.通过定制com.teamcenter.rac.kernel version.jar文件， 当登录TC时，可以改变加载的登录界面。\n1、自定义登录窗口(logon window)\n使用解压缩包工具打开%TC _RO0T%\\portal\\plugins\\com.teamcenter.rac.kernel_10000.1. 0.jar文件，替换\\icons\u0026rsquo;下的background. png文件。\n注意:修改原始文件前，先做好备份，并去掉. jar后缀名。\n2、按照清理TC缓存的方法，删除C: \\Documents andSettings \\Admini strator \\Teamcenter*目录，重新打开TC验证功能。\n1、修改Views,Dial og boxes,Forms，Wizards的布局和内容\n可以使用渲染文件Style sheets来改变Teamcenter views, dialogboxes, forms,和wizards using的布局与内容。Style sheets是一种数据集类型，使用Style sheets可以按照实际需求加载定制的数据属性。可供修改的数据对象包括Views，Dialog boxes，Forms的窗口信息。使用渲染文件进行定制的步骤如下\n(1)在TC的Newstuff文件夹中新建XMLRenderingStylesheet数据集。例如，要修改汇总(Summary)视图的布局和加载属性，可以命名数据集为myItemSummary。\n(2)使用“数据集\u0026hellip;..”查询，检索系统中现有的XMLRenderingStylesheet,找到Itemsummary数据集。\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!-- ======================================================================= Copyright 2012. Siemens Product Lifecycle Management Software Inc. All Rights Reserved. ======================================================================= Filename: ItemSummary.xml Style sheet rendering for Item summary. ======================================================================= --\u0026gt; \u0026lt;rendering xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:noNamespaceSchemaLocation=\u0026quot;XMLRenderingStylesheet_Schema.xsd\u0026quot;\u0026gt; \u0026lt;header\u0026gt; \u0026lt;image source=\u0026quot;thumbnail\u0026quot;/\u0026gt; \u0026lt;classificationTrace/\u0026gt; \u0026lt;property name=\u0026quot;owning_user\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;last_mod_date\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;release_status_list\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;object_type\u0026quot;/\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;page titleKey=\u0026quot;tc_xrt_Overview\u0026quot;\u0026gt; \u0026lt;column\u0026gt; \u0026lt;section titleKey=\u0026quot;tc_xrt_AvailableRevisions\u0026quot;\u0026gt; \u0026lt;objectSet source=\u0026quot;revision_list.ItemRevision\u0026quot; defaultdisplay=\u0026quot;listDisplay\u0026quot; sortdirection=\u0026quot;descending\u0026quot; sortby=\u0026quot;item_revision_id\u0026quot;\u0026gt; \u0026lt;tableDisplay\u0026gt; \u0026lt;property name=\u0026quot;object_string\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;item_revision_id\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;release_status_list\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;last_mod_date\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;last_mod_user\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;checked_out_user\u0026quot;/\u0026gt; \u0026lt;/tableDisplay\u0026gt; \u0026lt;thumbnailDisplay/\u0026gt; \u0026lt;treeDisplay\u0026gt; \u0026lt;property name=\u0026quot;object_string\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;item_revision_id\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;release_status_list\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;last_mod_date\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;last_mod_user\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;checked_out_user\u0026quot;/\u0026gt; \u0026lt;/treeDisplay\u0026gt; \u0026lt;listDisplay/\u0026gt; \u0026lt;/objectSet\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section titleKey=\u0026quot;tc_xrt_ItemProperties\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;object_desc\u0026quot;/\u0026gt; \u0026lt;separator/\u0026gt;\u0026lt;!--分隔符--\u0026gt; \u0026lt;property name=\u0026quot;owning_user\u0026quot; renderingHint=\u0026quot;objectlink\u0026quot; modifiable=\u0026quot;false\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;owning_group\u0026quot; renderingHint=\u0026quot;objectlink\u0026quot; modifiable=\u0026quot;false\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;last_mod_user\u0026quot;/\u0026gt; \u0026lt;separator/\u0026gt; \u0026lt;property name=\u0026quot;checked_out\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;checked_out_user\u0026quot;/\u0026gt; \u0026lt;separator/\u0026gt; \u0026lt;command commandId=\u0026quot;com.teamcenter.rac.properties\u0026quot; titleKey=\u0026quot;tc_xrt_moreProperties\u0026quot;/\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section titleKey=\u0026quot;tc_xrt_ClassificationProperties\u0026quot;\u0026gt; \u0026lt;classificationProperties/\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/column\u0026gt; \u0026lt;column\u0026gt; \u0026lt;section titleKey=\u0026quot;tc_xrt_Preview\u0026quot;\u0026gt; \u0026lt;image source=\u0026quot;preview\u0026quot;/\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section titleKey=\u0026quot;tc_xrt_actions\u0026quot; commandLayout=\u0026quot;vertical\u0026quot;\u0026gt; \u0026lt;command actionKey=\u0026quot;copyAction\u0026quot; commandId=\u0026quot;com.teamcenter.rac.copy\u0026quot; /\u0026gt; \u0026lt;command actionKey=\u0026quot;saveAsAction\u0026quot; commandId=\u0026quot;org.eclipse.ui.file.saveAs\u0026quot; /\u0026gt; \u0026lt;command actionKey=\u0026quot;newProcessAction\u0026quot; commandId=\u0026quot;com.teamcenter.rac.newProcess\u0026quot; titleKey=\u0026quot;tc_xrt_newProc\u0026quot; /\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/column\u0026gt; \u0026lt;/page\u0026gt; \u0026lt;page titleKey=\u0026quot;tc_xrt_AttachedFiles\u0026quot;\u0026gt; \u0026lt;objectSet source=\u0026quot;IMAN_reference.Dataset,IMAN_manifestation.Dataset,IMAN_Rendering.Dataset\u0026quot; defaultdisplay=\u0026quot;tableDisplay\u0026quot; sortby=\u0026quot;object_string\u0026quot; sortdirection=\u0026quot;ascending\u0026quot;\u0026gt; \u0026lt;tableDisplay\u0026gt; \u0026lt;property name=\u0026quot;object_string\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;release_status_list\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;relation\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;last_mod_date\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;last_mod_user\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;checked_out_user\u0026quot;/\u0026gt; \u0026lt;/tableDisplay\u0026gt; \u0026lt;thumbnailDisplay/\u0026gt; \u0026lt;treeDisplay\u0026gt; \u0026lt;property name=\u0026quot;object_string\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;release_status_list\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;relation\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;last_mod_date\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;last_mod_user\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;checked_out_user\u0026quot;/\u0026gt; \u0026lt;/treeDisplay\u0026gt; \u0026lt;listDisplay/\u0026gt; \u0026lt;command actionKey=\u0026quot;newBusinessObjectContextualAction\u0026quot; commandId=\u0026quot;com.teamcenter.rac.common.AddNew\u0026quot; renderingHint=\u0026quot;commandbutton\u0026quot;/\u0026gt; \u0026lt;command actionKey=\u0026quot;pasteAction\u0026quot; commandId=\u0026quot;com.teamcenter.rac.viewer.pastewithContext\u0026quot; renderingHint=\u0026quot;commandbutton\u0026quot;/\u0026gt; \u0026lt;command actionKey=\u0026quot;cutAction\u0026quot; commandId=\u0026quot;org.eclipse.ui.edit.cut\u0026quot; renderingHint=\u0026quot;commandbutton\u0026quot;\u0026gt; \u0026lt;parameter name=\u0026quot;localSelection\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/objectSet\u0026gt; \u0026lt;/page\u0026gt; \u0026lt;page title=\u0026quot;Related Links\u0026quot; titleKey=\u0026quot;tc_xrt_RelatedLinks\u0026quot; visibleWhen=\u0026quot;{pref:LIS_RelatedLinkTabVisible}==true\u0026quot;\u0026gt; \u0026lt;objectSet source=\u0026quot;IMAN_specification.Lis0Link,IMAN_reference.Lis0Link\u0026quot; defaultdisplay=\u0026quot;tableDisplay\u0026quot; sortby=\u0026quot;object_string\u0026quot; sortdirection=\u0026quot;ascending\u0026quot;\u0026gt; \u0026lt;tableDisplay\u0026gt; \u0026lt;property name=\u0026quot;object_string\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;lis0site\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;lis0serviceProvider\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;relation\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;last_mod_date\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;last_mod_user\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;checked_out_user\u0026quot;/\u0026gt; \u0026lt;/tableDisplay\u0026gt; \u0026lt;command actionKey=\u0026quot;newBusinessObjectContextualAction\u0026quot; commandId=\u0026quot;com.teamcenter.rac.lisfmwrk.newRelatedLink\u0026quot; renderingHint=\u0026quot;commandbutton\u0026quot;/\u0026gt; \u0026lt;command actionKey=\u0026quot;copyAction\u0026quot; commandId=\u0026quot;com.teamcenter.rac.copy\u0026quot; renderingHint=\u0026quot;commandbutton\u0026quot;\u0026gt; \u0026lt;parameter name=\u0026quot;localSelection\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;command actionKey=\u0026quot;pasteAction\u0026quot; commandId=\u0026quot;com.teamcenter.rac.viewer.pastewithContext\u0026quot; renderingHint=\u0026quot;commandbutton\u0026quot;/\u0026gt; \u0026lt;command actionKey=\u0026quot;cutAction\u0026quot; commandId=\u0026quot;org.eclipse.ui.edit.cut\u0026quot; renderingHint=\u0026quot;commandbutton\u0026quot;\u0026gt; \u0026lt;parameter name=\u0026quot;localSelection\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/objectSet\u0026gt; \u0026lt;/page\u0026gt; \u0026lt;page titleKey=\u0026quot;tc_xrt_AuditLogs\u0026quot; visibleWhen=\u0026quot;{pref:TC_audit_manager_version}==3\u0026quot;\u0026gt; \u0026lt;command titleKey=\u0026quot;tc_xrt_ExportToExcel\u0026quot; actionKey=\u0026quot;exportExcelAction\u0026quot; commandId = \u0026quot;com.teamcenter.rac.exportAuditSummaryToExcel\u0026quot; renderingHint=\u0026quot;commandbutton\u0026quot;/\u0026gt; \u0026lt;command titleKey=\u0026quot;tc_xrt_ExportToCSV\u0026quot; actionKey=\u0026quot;exportCSVAction\u0026quot; commandId = \u0026quot;com.teamcenter.rac.exportAuditSummaryToCSV\u0026quot; renderingHint=\u0026quot;commandbutton\u0026quot;/\u0026gt; \u0026lt;section titleKey=\u0026quot;tc_xrt_WorkflowLogs\u0026quot; initialstate=\u0026quot;collapsed\u0026quot;\u0026gt; \u0026lt;customPanel java=\u0026quot;com.teamcenter.rac.auditmanager.WorkflowLegacyAuditLinkPanel\u0026quot;/\u0026gt; \u0026lt;objectSet source=\u0026quot;fnd0WorkflowAuditLogs.Fnd0WorkflowAudit\u0026quot; defaultdisplay=\u0026quot;tableDisplay\u0026quot; sortby=\u0026quot;fnd0LoggedDate\u0026quot; sortdirection=\u0026quot;ascending\u0026quot;\u0026gt; \u0026lt;tableDisplay\u0026gt; \u0026lt;property name=\u0026quot;fnd0LoggedDate\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;object_type\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0EventTypeName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;object_name\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;job_name\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;process_templateDisp\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0UserId\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SponsoringUserID\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;task_state\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;task_result\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0Comments\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;responsible_party\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SignoffUserID\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SignoffGroupName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SignoffRoleName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjectType\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjDispName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjQualifier\u0026quot;/\u0026gt; \u0026lt;/tableDisplay\u0026gt; \u0026lt;/objectSet\u0026gt; \u0026lt;customPanel java=\u0026quot;com.teamcenter.rac.auditmanager.WorkflowSecondaryAuditPanel\u0026quot; js=\u0026quot;displayWorkflowCustomPanel\u0026quot; /\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section titleKey=\u0026quot;tc_xrt_GeneralLogs\u0026quot; initialstate=\u0026quot;collapsed\u0026quot;\u0026gt; \u0026lt;customPanel java=\u0026quot;com.teamcenter.rac.auditmanager.CheckoutHistoyLinkPanel\u0026quot;/\u0026gt; \u0026lt;objectSet source=\u0026quot;fnd0GeneralAuditLogs.Fnd0GeneralAudit\u0026quot; defaultdisplay=\u0026quot;tableDisplay\u0026quot; sortby=\u0026quot;fnd0LoggedDate\u0026quot; sortdirection=\u0026quot;ascending\u0026quot;\u0026gt; \u0026lt;tableDisplay\u0026gt; \u0026lt;property name=\u0026quot;fnd0LoggedDate\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;object_type\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0EventTypeName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;object_name\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0PrimaryObjectID\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0PrimaryObjectRevID\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0UserId\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SponsoringUserID\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0GroupName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0RoleName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;sequence_id\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0ChangeID\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0Reason\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjectType\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjDispName\u0026quot;/\u0026gt; \u0026lt;/tableDisplay\u0026gt; \u0026lt;/objectSet\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section titleKey=\u0026quot;tc_xrt_LicenseExportLogs\u0026quot; initialstate=\u0026quot;collapsed\u0026quot;\u0026gt; \u0026lt;objectSet source=\u0026quot;fnd0LicenseExportAuditLogs.Fnd0LicenseExportAudit\u0026quot; defaultdisplay=\u0026quot;tableDisplay\u0026quot; sortby=\u0026quot;fnd0LoggedDate\u0026quot; sortdirection=\u0026quot;ascending\u0026quot;\u0026gt; \u0026lt;tableDisplay\u0026gt; \u0026lt;property name=\u0026quot;fnd0LoggedDate\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;object_type\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0EventTypeName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;object_name\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0UserId\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SponsoringUserID\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0GroupName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0RoleName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;id\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjectID\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjectRevID\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjectType\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjectName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjDispName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjectSeqID\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;ead_paragraph\u0026quot;/\u0026gt; \u0026lt;/tableDisplay\u0026gt; \u0026lt;/objectSet\u0026gt; \u0026lt;customPanel java=\u0026quot;com.teamcenter.rac.auditmanager.LicenseExportSecondaryAuditPanel\u0026quot; js=\u0026quot;displayLicenseExportCustomPanel\u0026quot; /\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section titleKey=\u0026quot;tc_xrt_StructureLogs\u0026quot; initialstate=\u0026quot;collapsed\u0026quot;\u0026gt; \u0026lt;objectSet source=\u0026quot;fnd0StructureAuditLogs.Fnd0StructureAudit\u0026quot; defaultdisplay=\u0026quot;tableDisplay\u0026quot; sortby=\u0026quot;fnd0LoggedDate\u0026quot; sortdirection=\u0026quot;ascending\u0026quot;\u0026gt; \u0026lt;tableDisplay\u0026gt; \u0026lt;property name=\u0026quot;fnd0LoggedDate\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;object_type\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0EventTypeName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;object_name\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0UserId\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SponsoringUserID\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0GroupName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0RoleName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;item_id\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;item_revision_id\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;sequence_id\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjectID\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjectRevID\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjectType\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjectName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjDispName\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;fnd0SecondaryObjectSeqID\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;comp_position\u0026quot;/\u0026gt; \u0026lt;/tableDisplay\u0026gt; \u0026lt;/objectSet\u0026gt; \u0026lt;customPanel java=\u0026quot;com.teamcenter.rac.auditmanager.StructureSecondaryAuditPanel\u0026quot; js=\u0026quot;displayStructureCustomPanel\u0026quot; /\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/page\u0026gt; \u0026lt;/rendering\u0026gt;  (3)将Itemsummary数据集中的XML脚本语句复制到新建的数据集myItemSummary中。可以通过修改XML脚本，增添属 性、修改布局，单击工具栏中的保存按钮进行保存。\n(4)从查看器中“注册类型”的下拉列表框中选择C9_ myItem，“样式表类型” 的下拉列表框选择“汇总”，单击“应用按钮”，进行配置。\n(5)在新建的C9 myItem业务对象中，在汇总视图中查看配置后的效果。\n2、增加或修改对象图标 1)可以修改BMIDE中现有的业务对象图标，或者为新创建的业务对象指定图标。从BIMIE中导入图标的素材，然后将对 应的图标添加到零组件的属性中，通过部署项目完成图标的设置。实例:业务建模器中添加图标\n2)可以使用属性文件来修改各类图标。将替代的图标添加到创建的属性文件中，然后将属性文件拖拽到.jar包中。修改属 性文件的图标格式是:business- object.ICON=image-directory/image-file-name实例:使用“自定义发布流程”发布C9_myItem版本对象，实现将发布后的系统默认状态图标变为自定义的图标。\n(3)使用普通用户登录Teamcenter,新建C9_ myItem零组 件使用自定义发布流程发布C9_ myItem零组件的A版本数据。此时，发布后的状态图标还是黑色的旗子。\n(4)创建configuration_ 10000.1.0文件夹，在此文件夹中新建customer.properties属性文件。在customer.properties 属性文件中添加脚本文件如下，完成对自定义发布状态的图标定制:\nrelease_ status_ list. I_ Released.ICON=images/C9_ IReleased.png release_ statuses. I_ Released.ICON=images/ C9_ IReleased.png  image文件夹中放置C9_ IReleased.png的1 6位像素图标。\nimage文件夹中放置C9_ IReleased.png的1 6位像素图标。\n(5)将configuration_ 10000.1 .0文件夹复制到%TC_ ROOT%\\portal\\plugins文件家中， 和系统中已有的configuration_ 10000.1 .0文件夹进行合并。\n(6)使用genregxml.bat文件注册配置文件，注册完成后清除TC缓存。再使用普通用户登录Teamcenter,查看刚才发布的数据，此时发布状态字变为自定义的图标。\n5.2 无代码化定制应用 授权，针对于组织中的组和子组的用户，开放或收回特定的应用模块。例如，针对工程组的用户，可以开放组织和工作流设计器的功能，由工程组的人员进行组织和流程的设计。\n5.2.2 首选项 1、首选项概念\n首选项是存储在TC数据库中的环境变量。当设置和修改的时候都要读取。例如可以设置登陆的名称和属性表显示的列，一些权限等都与这些首选项有关。站点（Site）首选项：站点的首选项影响到Teamcenter的整个站点。只有管理员可以创建和修改；用户（User）首选项：用户首选项是针对特定用户的，这个用户可设置和创建，具有最高的优先级，dba组的人员也可创建和修改；组（Group）首选项和 角色（Role）首选项：组和角色的首选项是针对特定的组和角色的，组管理员有权限设置，dba组的人员也可创建和修改\n2、首选项的分级规则\n首选项分两种，系统首选项和分级首选项：\n（1）系统首选项：适用于整个站点；\n（2）分级首选项有保护范围：用户，角色，组，站点，级别从用户到站点依次递增。\n首选项位置优先顺序是：用户\u0026gt;角色\u0026gt;组\u0026gt;站点。系统根据级别搜索首选项值，开始于当前定义的首选项保护范围，然后根据当前用户-\u0026gt;当前角色-\u0026gt;当前组-\u0026gt;当前站点的顺序读取\n首选项保护范围：定义保护范围，确定了可创建首选项实例的最低级别，按从高到低的级别顺序依次为站点和系统\u0026gt;组\u0026gt;角色\u0026gt;用户。\n比如系统读取一个保护范围为角色的首选项：\n（1）如果当前角色有一个值，就使用这个值；\n（2）如果当前角色没有值，但是当前组有值，使用组的值；\n（3）如果当前角色和组都没有值，但是站点有值，就用站点的值；\n（4）如果当前角色、组、站点都没有值，则没有值使用。\n根据保护范围创建首选项：\n（1）管理员可以创建所有保护级别的首选项实例，包括站点、组、角色、用户的首选项。站点的首选项，影响到Teamcenter的整个站点，只有管理员可以创建和修改；\n（2）组管理员可以创建保护范围为组、角色和用户的实例；\n（3）普通用户只能创建保护范围是用户的实例。\n站点的首选项，影响到Teamcenter的整个站点。 只有管理员可以创建和修改\n例如：TC_show_open_in_nx_button，此首选项用于设置用户是否可以使用NX按钮，即控制用户是否可以在TC客户端中打开NX集成的选项。当值设置为false后，用户不能通过首选项界面添加NX按钮。\n3、首选项的使用界面\n打开菜单“编辑”，找到“选项”来进行首选项的使用。可以使用典型的首选项，搜索首选项，设置首选项的值，创建新的首选项，删除\n已经存在的首选项\n可以打开首选项的帮助文档，查看各类首选项的使用方法。\npreferences_manager工具\n作用：\n在新安装TC的时候合并首选项到数据库中，也可以用于TC升级的时候把历史的首选项转换为XML格式，从数据库中导出首选项，检查\nTC_DATA目录下的gpfiles/rpfiles/upfiles是否有数据，把这些首选项导入到数据库中，在%TC_ROOT%\\bin下：\nSyntax： preferences_manager -u=user-name {-p=password | -pf=password-file} -g=group-name -mode= {append | category | cleanup | cleanup_definitions | clear | export | generatexml | import | migrate | delete | remove | upgradexml} [-h]  4、 首选项的相关操作\n（1）创建首选项，填写首选项的名称、保护范围、描述、值，选择类别、\n环境变量、类型、是否多个值，填写好后单击“保存”按钮\n（2）修改首选项，查找到某个首选项后，单击“编辑”按钮，可以对首选项\n的相关属性值进行修改。\n（3）删除首选项，选择某一个待删除的首选项，单击删除按钮，删除此首\n选项\n5、 常用首选项举例\n下表是在TC系统中设置的常用首选项，通过系统配置，可实现对应的功能，构建站点级别的参数设置。\nHiddenPerspectives\u0026ndash;隐藏功能模块\nAE_dataset_default_keep_limit数据集保存的版本数量。当超过这\n个数值以后，老的版本即被删除。\n5.2.3访问权限管理 1、访问权限 在分布式计算机环境中，对象保护和所有权管理非常重要，对象代表了数据库中的产品信息，TC可执行两个层次的数据保护:基于规则的保护:作为-一个管理员，你可以定义多种条件或规则来控制对对象的访问，这些规则影响TC的整个节点，用访问控制器来定义。\n基于对象的保护:可更改对象访问控制权限的任何TC用户都可以设置基于对象的保护ACL (访问控制列表)，来创建基于规则保护外的保护。当需要对具体的对象设置较宽松或较有限的访问权限时，对象的ACL非常有用，访问控制列表ACL显示了当前对一个对象的保护，并允许用户更改这些保护。初始的保护决定于规则树。\n2、访问管理器 在访问管理器规则树中来组织规则，并按照该规则在树结构中的位置起作用。TC安装时包括的默认规则树假定只要权限没被显示地拒绝，用户就拥有该访问权限。当应用于所选对象的条件满足时，在ACL中定义的权限将被使用。注意:在规则树中的子分支总是优先于父结构。\n创建和管理命名的ACL\n4、ACL 的优先级控制 对某一对象有效的ACL是在规则树中适用于该对象的所有命名的ACL的累积组合。ACL的优先级顺序:当判断规则树中的优先级顺序时, 遵守下列方针:\n 子级优先于父级 同级中上层高于下层.  评价哪个权限最终被授予取决于两个标准,最终的结果是\n 一个有效的ACL ,控制者对对象的访问。， 规则树中条件声明的优先级别 命名的ACL中的访问者优先级别  5、ACL指导方针\n 不要删除或修改规则树中. 上面部分分支的顺序。这可能会导致不可预知的后果或丢失数据。 在Working分支下为工作数据添加规则,这是为工作数据类型添加新规则的最合适的地方。 不要直接修改COTS规则(系统内置设置的规则) , 但是可以创建一个新的规则来代替它。 在作修改前或后需要导出规则树备份。  第六章 BOM管理是PLM系统管理的核心之一。在产品生命的各个阶段,都有BOM的身影，因此我们必须掌握BOM的二次开发技能，以及对应的业务场景。本教程系列主要用于探讨BOM管理的基本业务，以及围绕BOM管理，可能涉及的开发知识点。 TC报表开发技术\n BOM的概念及类型\n BOM转换方式\n TC报表生成方式\n BOM开发过程\n BOM开发关键技术\n BOM开发技术比较\n  BOM的英文全称是Bill Of Material,中文名称是物料清单。BOM是一个比较宽泛的概念，根据不同的场景、用途，BOM又衍生出许多的种类。比如需求BOM、工程BOM、设计BOM、工艺BOM、制造BOM、装配BOM、客户BOM、销售BOM、维修BOM、采购BOM、成本BOM等等，因此BOM是无处不在的。从广义的角度上来说，BOM已经远远超出了物料清单的概念范畴，任何以父子结构呈现的树状数据结构，我们都认为是BOM的- -种表现形式。下图展示的是需求BOM，在Teamcenter 系统中，所有类型的BOM数据,大体上都是这种层级的表现形式。\n下面是几种常见的BOM类型，以及他们之间的基本转换进行初步的探讨，不一定适合 所有的行业或业务。 设计BOM:又称工程BOM,主要以产品结构、功能的角度组织数据,通常描述产品的设计指标，零件和零件之间的设计关系。设计BOM-般较少考虑加工工艺、装配工艺等。在设计员的眼中，它是- -件完美的艺术品，至于如何实现，能否实现考虑得较少。同时设计BOM一般会关联三维装配模型。\n工艺BOM:在设计BOM的基础之.上，由工艺设计部门根据企业生产工艺的要求，补充相关工艺特性后形成的。工艺BOM除了添加工艺路线、工艺定额等信息外，还可能涉及对设计BOM的结构进行调整，不过这种调整一~般是局部的。但是对于BOM而言，一旦调整结构，那么从调整零部件开始，其所有父级节点，都需要创建新的零部件对象，并重新装配。比如:某些零部件受限于工艺能力，不能完整加工，需要进行拆分加工，然后通过焊接工艺连接在一起，这类业务涉及的自制件，在企业中通常叫”拆件”’;另外有些零部件，从经济性，可加工性的角度考虑，可能需要多个零部件在-起生产，最后通过切割的方式得到设计零部件，这种业务涉及的自制件在企业中通常叫”合件”;工艺BOM大概率会新增原材料、辅料等，这些也会导致BOM结构的调整。\n装配BOM:在装配工艺的编制过程中，形成的产品、部组件的装配关系，反应的是装配顺序。比如，在设计上，部组件结构可能是多层BOM组成，但是装配工艺要求在-个装配工位，一次安装完成，这个时候需要将多层设计BOM，调整为单层的装配BOM，部分部组件对象就不体现在装配BOM中。\n制造BOM: -般来源于工艺部门编制的工艺卡片上的内容。主要包括零件加工工艺、部组件装配工艺、生产加工中零部件流转路线、以及每个BOM节点上关联的工装、设备、工时等信息。其主要作用是为ERP等软件生产计划等模块提供基础数据。目前大部分的Teamcenter软件并没有直接生成制造BOM，企业主要通过开发与ERP、MES等系统的集成接口，实现按需构建制造BOM，通过中间件的方式，向ERP、MES等系统传递制造BOM数据。因此ERP接口开发、MES接口开发是目前Teamcenter二次开发的重要内容。\n在讨论设计BOM、工艺BOM、装配BOM、制造BOM的过程中，BOM转换是客户关注的焦点。不同的行业、不同的企业，由于业务不一样、运营模式不一样、研发体系不-样等等，会导致BOM转换的需求和要求不一样,自然解决方案也不- -样。OOTB系统提供的BOM转换功能，无法满足企业需求，因此需要通过定制开发的方式实现。在探讨BOM开发之前，我们需要简单的了解，为什么需要进行BOM转换。有没有可能一个BOM通吃?如果产品特别简单，或许还是存在这种可能的。但是随着产品复杂度的增加，分工的增加，-套BOM打天下的局面是不可想象的。\nBOM转换中，除了拆件、合件，大部分的零部件对象，是不需要转换的。由于绝大部分部组件是新建对象，因此如果需要完整的三维装配模型，需要重新在三维软件中装配。设计BOM转装配BOM-般存在对三维模型的重新装配问题，用于指导三维装配工艺的编制。设计BOM转工艺BOM, - -般不会涉及对三维模型的操作，可以是-一个纯粹的不带三维信息的BOM。主要需要处理拆件、合件，添加原材料、辅料等对象。制造BOM一般由装配BOM、工艺BOM、工艺规程等组合而成，通过集成接口按一定的规则往 下游传递，-般不在Teamcenter系统中创建新的BOM数据。\nBOM报表系统既要统计出符合要求的数据，又要使生成的报表符合规定的格式，并且要嵌入Teamcenter系统运行，实现无缝集成。\n6.1.3 为什么需要报表开发 每个企业都有自己的特定需求，Teamcenter中有自带的报表的导出方式和模板，TC中自带的报表导出已经不能满足企业的需求。这也是西门子提供二次开发的目的。报表的自动化、个性化生成对企业成功实施PDM系统有着重要意义。尽管TC中程序处理BOM方面功能非常强大，但由于企业内部各类报表都有固定的模版和格式，因此需要掌握BOM报表开发相关知识。.\n6.1.4 TC报表生成方式 TC系统为我们提供了两种方式的报表:HTML、XSL 每种报表都有对多国语言支持版本，所以下面对话框中有4个选项，我们选第一个。\n通过开发生成报表的方法. 在现行的报表开发中，主要有以下三种开发方式:\n 一、Java开发报表导出 二、Java+VBA  ①导入到特殊格式时,需要打印 ②数据量很大的时候，执行效率高 ③需要电子签名  三、C语言编程，EXE文件执行  1、POI技术 POI用法:\nApache POI是用Java编写的免费开源的跨平台的Java API,Apache POI提供API给 Java程式对Mi crosoft 0ffice格式档案读 和写的功能。 Apache POI 是创建和维护操作各种符合Office Open XML(00XML)标准和微软的0LE 2复合文档格式(OLE2) 的Java API,用它可以使用Java读取和创建，修改Microsoft Excel 文件。\nPOI用法:\nApache POI可以到www. apache. org下载到。实际运行时，需要有POI包即可，Horrible SpreadSheet Format (HSSF) 提供给用户使用的对象在org. apache. poi. hssf. usermode1包中，主要部分包括Exce1对象，样式和格式，还有辅助操作。Excel文件的组织形式: 一个Excel文件对应于-一个workbook (HSSF Workbook) 一 个workbook可以有多个sheet(HSSF Sheet)组成，一个sheet是由多个row (HSSF Row)组成,一个row是由多个cell (HSSF Cell) 组成。\nPOI用法: 创建一个Excel文件代码解析\nHSSFWorkbook wb= new HSSFWorkbook(); //创建WorkBook HSSFSheet sheet = wb. createSheet(' new sheet' ); //创建Sheet HSSFRow row= sheet. createRow( (short)0); //创建Row HSSFCell cell = row. createCell(0); //创建Cell cell. setCellValue(\u0026quot;hello Excel\u0026quot;); //写入数据 File0utputStream file0ut=new File0utputStream(“c:\\\\workbook. xls\u0026quot; ); //在C盘下建立文件 wb. write(file0ut); //将信息流写入文件 file0ut. close(); //关闭流  POI用法: 读取一个Excel文件代码解析\nFileInputStream inputStream= new FileInputStream (\u0026quot; c: \\\\workbook. xls\u0026quot;); HSSFWorkbook workbook = new HSSFWorkbook (inputStream) ;//创建WorkBook HSSFSheet sheet1 = workbook. getSheet(' new sheet\u0026quot; ); //获取Sheet HSSFRow row1 = sheet1. getRow(0); //获取Row . HSSFCell cel11 = row1. getCe11(0); //获取第-一个单元格 String cellValue1 = ce111. getStringCel1Value( ); //获取单元格的值有关POI  的详细用法，请登录到以下网址: http://poi. apache. org/\n2.使用BOM类创建BOM结构\n我们主要使用以下几个类读取BOM结构:\nTCComponentBOMWindowType、TCComponentBOM Window、TCComponentRevisionRule、TCComponentBOMLine。\n(1)创建BomWindow对象\nTCComponentBOMWindowType type = (TCComponentBOMWindowType) tcSession.getTypeComponent(\u0026quot;BOMWindow\u0026quot;); bomWindow = type.create(null); //使用默认的版本规则  (2)设置版本规则 如果不使用默认的版本规则，需要替换其他版本规则的话，比如以下就是使用\u0026rdquo;Latest Working”版本规则。\nTCComponentRevisionRuleType ruleType = (TCComponentRevisionRuleType) tcSession. getTypeComponent(\u0026quot;RevisionRule\u0026quot;); TCComponent[] rules = ruleType.extent(); for (inti= 0;i\u0026lt; rules.length;i++) { . String ruleName = rules[i].getProperty(\u0026quot;object name\u0026quot;); if(\u0026quot;Latest Working\u0026quot;.equals(ruleName)){ TCComponentRevisionRule rule = (TCComponentRevisionRule) rules[i]; bomWindow. setRevisionRule(rule); break; } }  (3)加载顶层BOM行\ntopBomline = bomWindow.setWindowTopLine(topRevision.getItem(),topRevision,null, null); topBomline.pack(); .  BOM数据来源 TC BOM表中需要提取的信息可分为三部分:\n第一类信息是在PSE的BOMLine属性中的，这是BOMLine的固有属性，如bl_ item_ object_ name表明当前BOMLine的Item 的名称，bl_ _quantity表明当前BOMLine的数量属性等，这些在PSE中可以进行添加或者修改; 第二部分信息是BOMLine所对应的零/部件版本( Item、ItemRevision)本身的属性，如Owning User、date等，这些信息可以通过getProperty( )函数获得其值。\n第三部分信息存在于BOMLine所对应的Item Revision的Master Form表中，当用缺省的Item类型创建-一个零部件时，在查看器中显示的项目id、系列号等就属于Master Form表的信息,可以在浏览器中查看或者修改。要提取Master Form中包含的信息，首先必须通过BOML ine获取对应的Item Revision,然后通过Item Revision获取Master Form,最后通过此Form的getProperty( )方法来获得其Master Form的属性。\nTCComponentBOMLine bomline = (TCComponentBOMLine) bomlineelement( ); TCComponentItemRevision irev = ( TCComponentItemRevision) Bomline.getItemRevision( ); / /通过BOMLine获取对应的Item Revision AIFComponentContext [ ] irm= irev.getChildren( IMAN master form_ rev); / /通过Item Revision获取Master Form TCComponentForm mf = ( TCComponentForm) irm[0].getComponent( ); String serial_ number = mf.getProperty(\u0026quot;user_ data_ 1\u0026quot;).toString( ); 1 /getProperty( )方法来获得其Master Form的属性  要进行BOM汇总必须对PSE中的产品结构进行遍历，遍历BOM有两种递归方式:深度优先遍历算法(BFS)和广度优先遍历算法（DFS）\n深度优先遍历算法(BFS)以产品结构树中的零/部件是否有子件为递归条件，充分展现了零/部件间的层次关系和BOM树的结构。该算法的优点是程序简单，但由于是递归调用，涉及到堆栈的操作，在进行深层次遍历时，系统消耗的资源会很大。\n程序代码逻辑: private void BomBFS(TCComponentBOMLine parent) { //优先遍历 if (parent.hasChildren() { AlFComponentContext[ children = parent.getChildren(); for (inti= 0; i\u0026lt; children.length; i++){ InterfaceAlFComponent tcComp = children[i].getComponent(); TCComponentBOML ine childBomline = (TCComponentBOML ine) tcComp; BomBFS(childBomline) } } // 处理业务逻辑 }..  广度优先遍历算法(DFS)首先访问层次数为0的根节点，然后访问层次数为1的所有节点，依次逐层往下遍历直到访问完最后一层的所有节点。\n程序代码逻辑:\nprivate void BomDFS(TCComponentBOMLine parent) { AIFComponentContext0 children = parent.getChildren(); if (children != null){ // 优先处理单层BOM业务逻辑 for (int i= 0; i \u0026lt; children.length; i++) { InterfaceAlFComponent tcComp = children[i].getComponent(); TCComponentBOMLine childBomline = (TCComponentBOMLine) tcComp; } //下面开始遍历 for (inti= 0; i\u0026lt; children.length; i++){ InterfaceAlFComponent tcComp = children[i].getComponent(); TCComponentBOML ine childBomline = (TCComponentBOMLine) tcComp; BomDFS(childBomline) } } }  BOM遍历算法 鉴于BOM汇总是由各项目下的子类逐层向父类归并的情况，同时考虑到企业的BOM汇总中明细表项目较多、层次较浅(- -般为3~ 4层)的特点，本文BOM开发采用深度优先遍历算法，由( TCComponentBOMLine )aifcomponentcontexts[0].getComponent( )获取选定的根节点，利用getChildren( )的方法获取根的子节点，对于每-一个子节点重复利用函数getChildren( )的方法获得其子组件，如此循环下去直到没有子节点，完成BOM的遍历。\n由于事先无法预知BOM汇总中零/部件的具体数量，所以可以用数组来容纳所汇总的零/部件信息是不现实的，而且数组-般只能存放-种类型的数据，而在产品信息中数据类型显然不能是单一的，因此采用Vector类来解决汇总过程中的数据存放问题。\n操作步骤: 获取Teamcenter数据，以获取Teamcenter中 Item的属性为例。 Step1.获取Item，\npublic static TCComponent[ ] getItem (String[ ]names, String [ ]values， String queryname) throws TCException TCSession session = (TCSession) AIFUtility. getDefaultSession() ; TCComponentQueryType querytype = (TCComponentQueryType) session. getTypeComponent (\u0026quot; ImanQuery' ) ; TCComponentQuery query =(TCComponentQuery) querytype. find (queryname) ; TCQueryClause[] Clause = query. describe() ; for (int i = 0; i \u0026lt; names. length; i++) { for (int m = 0; m \u0026lt; Clause. length; m++) { if (names [i]. equals (Clause [m]. getUserEntryName ()) { names[i] = Clause [m]. getUserEntryNameDisplay break; } } return query. execute (names，values) ;  2-获取Item的属性。\npublic static String[ ] getProperties (TCComponentItem item, String [ ] properties) { String [ ] values=null; try { values=i tem. getProperties (properties) ; } catch (Exception e) { e. printStackTrace () ; return values ; }  3.在Teamcenter NewStuff下新建文件夹用于存放文件。\npublic static TCComponentFolder getFolder (String foldername) { TCSession session = (TCSession) AIFUtility. getDefaultSession() ; TCComponentFolder newStuff = null; TCComponentFolder newFolder = null; newStuff=TCComponentFolder. getNewStuffFolder (session) ; TCComponentFolderType createFolderType = (TCComponentFol derType) session. getTypeComponent (\u0026quot; Folder\u0026quot;) ; newFolder=createFolderType. create (foldername，\u0026quot;\u0026quot;， ” Folder\u0026quot;) ; newStuff. add(\u0026quot; contents\u0026quot;，newFolder) ; return newFolder ; }  Step4:把i tem属性写入C:\\temp路径下的temp. xls中。\npublic void writeToExcel(String[ properties){ FileOutputStream fos= =null; HSSFWorkbook xlss =new HSS FW orkbook(; HSSFSheet sheet=xlss.createSheet0; HSS FRow row=sheet.createRow(0); row.createCell(0).setCellValuet(\u0026quot;item_ id\u0026quot;); row.createCell(1 ).setCellValue(\u0026quot;object_ name\u0026quot;); row.createCell(2).setCelIValue(\u0026quot;creation_ date\u0026quot;); row.createCell(3 ).setCellValue(\u0026quot;current_ id\u0026quot;); HSSFRow row1=sheet.createRow(1); row1.createCell(0).setCellValue(properties[0]); row 1.createCell(1).setCellValue(properties[1]); row 1.createCell(2).setCellValue(properties[2]); row 1.createCell(3).setCellValue(properties[3]); File xls_ file=new File(tempfile); 1/指定写 入路径 fos=new FileOutputStream(xls_ file); xlss.write(fos); }  Step5:将建立的临时excel文件导入到TC中。\npublic static TCComponentDataset createDataset (TCSession session, String path, String dType， String dRef，String dName，TCComponentFolder folder, boolean replaceA1ert) { TCComponentDataset datasetcomponent nul1 ; TCComponentDatasetType TCDatasetType= (TCComponentDatasetType) typeService. getTypeComponent (datasetType) ; String filepathnames[]= {path} ; String nameRefs []= {dRef}; datasetcomponent=TCDatasetType. setFiles (dName，null， dType, filepathnames, nameRefs) ; folder. add(\u0026quot; contents'，datasetcomponent) ; return datasetcomponent ; }  Step6: 创建报表的界面。\nStep7: 生成的临时文件。\nStep8: TC中创建的报表。\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;?eclipse version=\u0026quot;3.6\u0026quot;?\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.commands\u0026quot;\u0026gt; \u0026lt;command name=\u0026quot;Sample Command\u0026quot; id=\u0026quot;com.mycom.addbutton.commands.sampleCommand\u0026quot;\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.handlers\u0026quot;\u0026gt; \u0026lt;handler commandId=\u0026quot;com.mycom.addbutton.commands.sampleCommand\u0026quot; class=\u0026quot;com.mycom.addbutton.handlers.SampleHandler\u0026quot;\u0026gt; \u0026lt;/handler\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;extension point=\u0026quot;org.eclipse.ui.menus\u0026quot;\u0026gt; \u0026lt;menuContribution locationURI=\u0026quot;toolbar:navigator_Toolbar?after=additions\u0026quot;\u0026gt; \u0026lt;command commandId=\u0026quot;com.mycom.addbutton.commands.sampleCommand\u0026quot; icon=\u0026quot;icons/sample.gif\u0026quot; tooltip=\u0026quot;Say hello world\u0026quot; id=\u0026quot;com.mycom.addbutton.toolbars.sampleCommand\u0026quot;\u0026gt; \u0026lt;visibleWhen\u0026gt; \u0026lt;reference definitionId=\u0026quot;com.teamcenter.rac.ui.inMainPerspective\u0026quot;\u0026gt; \u0026lt;/reference\u0026gt; \u0026lt;/visibleWhen\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;/menuContribution\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;/plugin\u0026gt;  ","id":0,"section":"posts","summary":"Teamcenter笔记 概述 Teamcenter的标准功能基本可以供用户使用，但是基于每家公司业务问题以及使用习惯，还有一些特殊的应用与数据","tags":["杂七杂八"],"title":"Teamcenter定制学习笔记","uri":"https://mumulx.github.io/2020/06/tc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","year":"2020"},{"content":" 操作系统与计算机网络 TCP是传输层协议。对应osI网络模型的第4层传输层。 TCP协议的特点是基于链接。也就是传输数据前需要先建立好链接，然后再进行传输。 TCP连接一旦建立,就可以在连接上进行双向的通信。Tcp的传输是基于字节流而不是报文，将数据按字节大小进行编号，接收端通过LCK来确认收到的数据编号，通过这种机制，TCP协议能够保证接收数据的有序性和完整性。\n因此 TCP能够提供可靠性传输，TCP还能提供流量控制能力，通过滑动窗口来控制数据的发送速率。滑动窗口的本质是动态缓冲区，接收端根据自己的处理能力，在TCP的header中动态调整窗口大小，通过ACK应答包通知给发送端，发送端根据窗口的大小调整发送的速度，仅有流量控制能力还不够。Tcp协议还考虑到了网络问题可能会导致大量重传，进而导致网络情况进一步恶化。因此 TCP协议还提供了拥塞控制，TCP处理拥塞控制，主要是用到了慢启动，拥塞控制，快速重传，快速恢复四个算法。TCP的拥塞控制（详解）\n除了TCP协议的特点。还可以进一步了解TCP协议的报文状态，滑动窗口的工作流程，keep alive的参数设置和Nagel算法的规则等一些细节。另外还有典型的TCP协议问题。例如特定场景下Nagel和aCK延迟机制配合使用，可能会出现延迟40毫秒超时后才能回复aCK包的问题。\n接下来我们来看看TCP建连的三次握手。TCP是基于链接的。所以在传输数据前需要先建立链接，TCP在传输上是双工传输，不区分client端与server端。为了便于理解。我们把主动发起建连请求的一端称作client端，把被动建立连接的一端称作server端。\n看下面这张图，建连的时序是从上到下，左右两边的绿色字，分别代表client端与server端当时的链接状态。首先建立链接前需要server端先监听端口，因此server端建立链接前的初始状态就是LISTREM状态，开始客户端准备建立链接，先发送一个syn同步包，发送完成后，client端的链接状态就变成了syn_sent的状态。Server端收到syn后，同意建立链接，会向client端回复一个ACK；由于TCP是双工传输，server端也会同时向client端发送一个同步请求syn申请server向client方向建立连接，发送完ACK和SYN后，server端的链接状态就变成了syn_rcvd。client收到SYN、ACK后，client端的链接状态就变成了established的状态。同时 client端向server端发送ACK响应，回复server端的SYN请求，server端收到client端的ack后，server的链接状态也就变成了established的状态。其实建连完成双方随时可以进行数据传输，\n需要明白三次握手是为了建立双向的连接，需要记住client端和server端的链接状态变化。另外回答建连的问题是可以提到syn洪水攻击发生的原因，就是server端收到client端的SYN请求后，发送了ACK和syn，但是server端不进行回复，导致server端大量的连接处在SYN_RCVD状态，进而影响其他正常请求的建连。\n可以通过设置Linux的TCP参数，tcp_syn_retries=0来加快半连接的回收速度，或者调大tcp_max_syn_backlog来应对少量的SYN洪水攻击。\n再来看看TCP的断连，TCP链接的关闭。通信双方都可以先发起，我们暂且把先发起的一方看作client，从图中可以看出，通信中的client和server两端的链接状态都是established的状态，然后client端先发起了关闭链接请求 ；client向server发送了一个FIN包，表示客户端已经没有数据要发送了，然后client端就进入了FIN_WAIT_1状态。Server端收到FIN后。返回ACK , 然后进入close_wait状态。其实 server端属于半关闭状态，因为此时client向server方向已经不会再发送数据了，可是server向client端可能还有数据要发送，当server端数据发送完毕后，server端会向client端发送FIN表示server端也没有数据要发送的。这时 server进入last_ack状态，就等待client端的应答就可以关闭链接了。Client端收到server端的FIN后。回复ACK。然后进入time_wait的状态，time_wait的状态下需要等待两倍的msl就是最大报文段生存时间，来保证链接的可靠关闭。之后才会进入closed状态。而server端收到ack后，直接就可以进入close状态。\n这里可能会问为什么需要等待两倍的msl之后才能关闭链接？\n原因有两个\n 第一要保证TCP协议的全双工链接能够可靠关闭。 第二，要保证这次链接中重复的数据段能够从网络中消失，防止端口被重用的时候，可能会产生数据混淆。  从这个交互流程上可以看出，无论是建联还是断连，都是需要在两个方向上进行，只不过建连时，server端的syn和aCK两个包合并为一次发送，而断开连接时，两个方向的数据发送的停止时间可能是不同的，所以无法合并FIN和ACK发送；这就是建连的时候必须要三次握手，而断连的时候必须要4次挥手的原因。\n另外在回答断连的问题时，可以提到实际应用中，有可能会遇到大量socket出在time_wait或者close_wait状态的问题，一般开启Linux的TCP参数，tcp_tw_reuse 和tcp_tw_recycle能够加快time_wait的状态的回收。解决Linux TIME_WAIT过多造成的问题\n而出现大量的close_wait状态,一般是被动关闭的一方可能存在代码的bug，没有正确关闭链接导致的。\nJava语言特性与设计模式 最常见的设计模式有单例模式，工厂模式、代理模式、构造者模式、责任链模式、适配器模式、观察者模式等。\n我们看一下详解，设计模式的知识点分为三大类型，共23种，其中\n创建型的有5种，工厂方法模式，抽象工厂模式，单例模式、建造者模式、原型模式， 结构型的有7种，适配器模式，装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式， 行为型的有11种，策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式，中介者模式和解释器模式。\n面试中对于设计模式。应该明白。不同设计用来解决什么样的场景问题，对于常用的设计模式能够灵活运用。重点介绍几种常用的设计模式\n工厂模式: Spring如何创建Bean 代理模式: Motan服务的动态代理 责任链模式: Netty消息处理的方式 适配器模式: SLF4J如何支持Log4J 观察者模式: GRPC是如何支持流式请求的 构造者模式: PB序列化中的Builder\nHashMap和ConcurrentHashMap\n先来看HashMap的实现。简单来说，Java的HashMap就是数组加链表实现的，数组中的每一项是一个链表。通过计算存入对象的hashcode的来计算出对象在数组中要存入的位置，用链表来解决散列冲突。链表中的节点存储的是键值对，除了实现的方式，我们还需要知道填充因子的作用与HashMap扩容时的机制，需要知道HashMap容量都是二的幂次方。是因为可以通过按位与操作来计算余数。比求模要更快。\n另外需要知道HashMap是非线程安全的在多线程put的情况下。有可能在容量超过填充因子时进行hash。因为HashMap为了避免尾部遍历，在链表的插入时使用的是头插法。多线程场景下，可能会产生死循环。从HashMap的非线程安全，面试官很自然的就会问到线程安全的ConcurrentHashMap，ConcurrentHashMap采用分段锁的思想来降低并发场景下的锁定发生频率。\n在jdk1.7和1.8中实现差异非常大。1.7中使用的segment进行分段枷锁，降低并发锁定程度。1.8中使用cas自旋锁。这是一种乐观思维模式来提高性能。但是在并发度较高的场景下，性能会比较一般。另外1.8中ConcurrentHashMap引入了红黑树。用来解决希冲突时列表的顺序查找问题。红黑树的启用条件与列表的长度，和map的总容量有关。默认是链表大于8，且容量大于64时转为红黑树方式。\n最后在1.8中对方法区进行了调整。使用metaspace(元空间)替换掉了PermGen的永久代。metaspace与PermGen间最大的区别在于 metaspace并不在虚拟机中，而是使用本地内存。替换的目的一方面是可以提升对原数据的处理。提升这些效率。另一方面方便后续hot spot。11版本是Java最新的长期支持版本，\n 进程与线程的区别与联系 简单介绍一-下进程的切换过程 你经常使用哪些Linux命令,主要用来解决什么问题? 为什么TCP建连需要3次握手而断连需要4次 为什么TCP关闭链接时需要TIME_WAIT状态，为什么要等2MSL ? 一次完整的HTTP请求过程 是怎样的 HTTP2和HTTP的区别有哪些? 在你的项目中你使用过哪些设计模式?主要用来解决什么问题? Object中的equals和hashcode的作用分别是什么? final , finally , finalize的区别与使用场景 简单描述一下java的异常机制 线上使用的哪个版本jdk ,为什么使用这个版本(有什么特点) ?  深入浅出JVM jvm 内存模型主要是运行时的数据区，包括5个部分，栈也叫方法栈，是线程私有的，线程在执行哪个方法是都会同时创建一个栈帧，用来存储局部变量表，操作栈、动态链接方法出口等信息，调用方法时执行入栈，方法返回时执行出栈，本地方法栈与栈类似，也是用来保存现成执行方法时的信息，不同的是执行Java方法时使用栈，而执行native方法是使用本地方法栈；程序计数器保存着当前线程所执行的字节码位置，每个线程工作时都有一个独立的计数器，程序计数器只为执行Java方法服务，执行native方法时，程序计数器为空；栈、本地方法栈、程序计数器这三部分都是线程独占的。\n堆是JVM管理的内存中最大的一块，堆被所有的线程共享，目的是为了存放对象的实例，几乎所有的对象实例，都会放在这里。当堆内存没有可用的空间时，会抛出OOM异常，根据对象存活的周期不同，JVM对内存进行分代管理，由垃圾回收器来进行对象的回收。方法区也是各个线程共享的内存区域，又叫非堆区，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器优化后的代码等数据，jdk1.7中的永久代和1.8中的元空间都是方法区的一种实现。\nJMM JMM是Java内存模型，与刚才讲到的JVM模型是两回事。JMM的主要目标是定议程序中变量的访问规则，如图所示所有的共享变量都存储在主内存中共享。\n每个线程有自己的工作内存，工作内存中保存的是主内存中变量的副本，线程对变量的读写等操作。必须在自己的工作内存中进行。而不能直接读写主内存中的变量。在多线程进行数据交互时，例如线程a给一个共享变量赋值后，由线程b来读取这个值，a修改完变量是修改在自己的。你的工作内存区中，B是不可见的，只有从a的工作内存区写回到主内存， B再从主内存读取到自己的工作区。才能进行进一步的操作。由于指令重排序的存在，这个写读的顺序有可能会被打乱，因此JMM需要提供原子性、可见性、有序性的保证。\n我们来看看JMM如何保证原子性、可见性和有序性。JMM保证对除long和double外的基础数据类型，它的读写操作是原子性的。另外关键字synchronized也可以提供原子性保证，synchronized的原子性是通过Java的两个高级字级码指令，monitorenter和monitorexit来保证的。\nJMM可见性的保证，一个是通过synchronized的，另外一个就是通过volatile。volatile强制变量的赋值会同步刷新回主内存，强制变量的读取。会从主内存中重新加载。保证不同的线程总是能够看到该变量的最新值，JMM对有序性的保证，主要通过volatile和一系列的happens -before原则。\nvolatile的另一个作用就是阻止指令重排序，这样就可以保证变量读写的有序性。Happens-before原则，包括一系列规则，比如程序顺序原则，就是一个线程内必须保证与一串型性，所谓的就是对同一把锁的解锁一定要发生在再次加锁之前。此外还包括happens before原则的传递性。线程的启动中断中止规则等。\nJava的类加载机制 类的加载。是指将编译好的class类文件中的字节码读入到内存中。将其放在方法区内，并创建对应的class对象。类的加载分为加载、链接、初始化，其中链接又包括验证、准备、解析三步，看图中上半部深绿色的部分，我们逐个解析。\n加载是文件到内存的过程，通过类的完全限定名，查找此类字节码文件，并利用字节码文件创建一个class对象；\n验证是对类文件内容验证，目的在于确保class文件符合当前虚拟机的要求，不会危害到虚拟机自身安全。主要包括4种，文件格式验证、原数据验证、字节码验证、符号引用验证；\n准备阶段是进行内存分配，为类变量，也就是由类中static修饰的变量分配内存，并设置初始值。这里要注意初始值是0或null而不是代码中设置的具体值，代码中设置的值，在初始化阶段完成。另外这里也不包含final修饰的静态变量，因为final变量在编译时就已经分配了。\n解析主要是解析字段、接口、方法，主要是将常量词中的符号引用替换为直接引用的过程，直接引用就是直接指向目标的指针或者相对偏移量等。\n最后是初始化，主要完成静态块执行与静态变量的赋值，这是累类加载最后阶段。若被加载类的父类没有初始化，则先对父类进行初始化，只有对类的主动使用时才会进行初始化，初始化的触发条件，包括创建类的实例的时候，访问类的静态方法或者静态变量的时候，使用class forname反射类的时候，或者某个子类被初始化的时候，图中下方浅绿的两个部分，表示类的生命周期，就是从类的加载到类的实例的创建与使用，再到类对象不再被使用，可以被这些回收。\n这里要注意一点，由Java虚拟机自带的三种类加载器加载的类，在虚拟机的整个生命周期中是不会被卸载的。只有用户自定义的类加载器所加载的类才可以被卸载。接下来我们学习不同的类加载器\nJava自带的三种类加载器，分别是bootstrap启动类加载器、扩展类加载器、应用加载器也叫系统加载器，图右边的橘黄色文字，表示各类加载器对应的加载目录；\n启动类加载器，加载Java_home中内部目录下的加载类;\n扩展加载器，负责加载ext目录下的类;\n应用加载器加载classpath指定目录下的类。\n除此之外还可以自定义类加载器，Java的类加载，使用双亲委派模式。即一个类加载器，在加载类时，先把这个请求委托给自己的父类加载器去执行。如果父类加载器还存在父类加载器，就继续向上委托，直到顶层的启动类加载器，如图中蓝色向上的箭头，如果父类加载器能够完成类的加载就成功返回。如果父类加载器无法完成加载，那么子加载器才会尝试自己去加载，如图中黄色向下的箭头，这种双亲委派模式的好处，一是可以避免类的重复加载，另外也避免了Java的核心API被篡改。\n前面提到过 Java的堆内存被分代管理，为什么要分代管理？分代管理主要是为了方便垃圾回收，这样做是基于两个事实。\n第一是大部分对象很快就不再使用了。第二是还有一部分不会立即无用，但也不会持续很长时间。\n虚拟机中划分为年轻代、老年代和永久代。我们来看图，年轻代主要用来存放新创建的对象，年轻代分为eden等区和两个survivor区，大部分对象在eden区中生成，当eden区满时还存活的对象会在两个survival区交替保存，达到一定次数后，对象会晋升到老年代，老年代用来存放从年轻代晋升而来的存活时间较长的对象，永久代在前面也介绍过，主要保存类信息等内容，这里的永久代是指对象划分方式，不是专指1.7的永久代，或者1.8之后的元空间\n根据年轻代与老年代的特点，JVM提供了不同的垃圾回收算法，垃圾回收算法按类型可以分为引用计数法、复制法、标记清除法几种，\n其中引用计数法是通过对象被引用的次数来确定对象是否还在被使用，缺点是无法解决循环引用的问题。\n复制算法需要from和to两块大小相同的内存空间，对象分配时只在from块中进行，回收时把存活对象复制到to块中，并清空form块，然后交换两块的分工。把from块作为to快，把to块作为from块，缺点是内存使用率较低；\n标记清除算法分为标记对象和清除不再使用的对象两个阶段，标记清除算法的缺点是会产生内存碎片。\nJVM中提供的年轻代回收算法，Serial、parnew、Parallel scavenge。都是复制算法，而cms、G1、ZGC都属于标记清除算法。\n下面我们详细介绍几个典型的垃圾回收算法。先来看cms回收算法，cms是jk1.7以前，可以说最主流的垃圾回收算法，cms使用标记清除算法，优点是并发收集，停顿下，我们看图中cms的处理过程，\n cms的第一个阶段是初始标记，这个阶段会stop the world，标记的对象只是从root级最直接可达的对象。 第二个阶段是并发标记，这时GC线程和应用线程并发执行，主要是标记可达的对象。 第三个阶段是重新标记阶段，这个阶段是第二个stop the world阶段，停顿时间比并发标记要小很多，占比初始标记稍长，主要对象进行重新扫描并标记。 第四个阶段是并发清理阶段，进行并发的垃圾清理。 最后一个阶段是并发重置阶段，为下一次这些重置相关数据结构  G1算法在jdk1.9后成为了JVM的默认垃圾回收算法。G1的特点是保持高回收率的同时减少停顿，G1算法取消了堆中年轻代与老年代的物理划分，但它仍然属于分代收集器，G1算法将对堆分为若干个区域，为region，如图中的小方格所示，一部分区域用作年轻代，一部分用在老年代，还有另外一种专门用来存储巨型对象的分区Humongous，G1和cms一样，会遍历全部对象，然后标记对象引用情况，在清除对象后会对区域进行复制移动整合碎片空间。\n图的右边是G1年轻代与老年代的回收过程，G1的年轻代回收采用复制算法并行进行收集，收集过程会stop the world；G1的老年代回收，同时也会对年轻代进行回收。主要分为4个阶段\n第一个阶段依然是初始标记阶段，完成对跟对象的标记。这个过程是stop the world。\n第二个阶段，并发标记阶段，这个阶段是和用户线程并行执行的。\n第三个阶段，最终标记的阶段，完成三次标记的标记周期。\n第四阶段，复制清除阶段，这个阶段会优先对可回收空间较大的region进行回收，Garbage First这也是G1名称的由来。\nG1采用每次只清理一部分，而不是全部region的增量式清理，由此来保证每次GC停顿时间不会过长。\n总结一下G1算法，这部分需要掌握G1是逻辑分代，不是物理分代，需要知道回收的过程和停顿的阶段。此外还需要知道G1算法允许通过jvm参数设置region的大小，范围是1~32M，还可以设置期望的最大这些停顿时间等。如果你有兴趣，也可以对CMs和G1使用的三次标记算法进行简单的了解。\nZGC是最新的jdk1.11中提供的高效垃圾回收算法，针对大堆内存设计可以支持T级别的堆，他非常高效，能够做到10毫秒以下的回收停顿时间，这么短的停顿时间是ZGC如何做到的？我们来了解一下 ZGC的黑科技，ZGC使用了着色指针技术。我们知道64位平台上一个指针可用位是64位，ZGC限制最大支持4tb的堆，这样寻址只需要使用42位。那么会剩下22位就可以用来保存额外的信息。着色指针技术就是利用指针的额外信息位在指针上对象进行着色标记。\n第二个特点是使用读屏障，ZGC使用读屏障来解决GC线程和应用线程可能并发修改对象状态的问题，而不是简单粗暴的通过stop the world来做全局的锁定，使用读屏障只会在单个对象的处理上有概率被减速。\n第三个特点：由于读屏障这样的使用，进行垃圾回收的大部分时候都是不需要stop the world。因此ZGC的大部分时间都是并发处理；\n第四个特点是基于region，这与G1算法一样，不过虽然也分了region，但是并没有进行分代。Zgc的region不像G1那样是固定大小，而是动态决定region的大小。Region可以动态创建和销毁，这样可以更好地对大对象进行分配管理。\n第5五特点是压缩整理CMS算法，清理对象是原地回收，会存在内存碎片问题。ZGC和G1一样，也会在回收后对Region中的对象进行移动合并，解决了碎片问题，虽然ZGC的大部分时间是并发进行，但还是会有短暂的停顿。\n来看一下ZGC的回收过程。这张图是按ZGC的回收时序绘制的，我们从上往下看，初始状态是整个堆空间被划分为大小不等的许多region，及图中绿色的方块，开始进行回收时，ZGC首先会进行一个短暂的stop the world，来进行root根对象的标记，这个步骤非常短，因为root的总数量通常比较小，然后就开始进行并发标记。\n如图。通过对象指针进行着色来进行标记，结合读屏障，解决单个对象的并发问题。其实这个阶段在最后的时候，还会有一个非常短的stop the word停顿，用来处理一些边缘情况，这个阶段绝大部分时间都是并发进行的，所以没有明显标识出这个停顿。\n下一个阶段是清理阶段，这个阶段会把标记为不可用的对象进行回收。如图把橘色的不再使用的对象进行了回收。\n最后一个阶段是重定位，重定位就是对GC后存活的对象进行移动，来腾出大块的内存空间解决碎片问题。在重定位最开始，会有一个短暂的stop the world，用来重定位该集合中的root对象，暂停时间取决于root的数量和重定位集与对象的总活动集的比率\n最后是并发重定位，这个过程也是通过读屏障与应用线程并发进行的。\n 深入理解JVM内存模型 了解类加载机制 了解内存可见性 了解常用的GC算法实现和适用场景 能够根据业务场景选择合适JVM参数与GC算法  总结一下JVM相关的面试考察点。首先需要理解的内存模型和Java的内存模型。其次要了解类的加载过程，了解双亲委派机制。第三，要理解内存的可见性与Java内存模型对原子性可见性有序性的保证机制。第四要了解常用的这些算法的特点，执行过程和适用场景。例如G1适合对最大延迟有要求的场合，zgc适用于64位系统的大内存服务中。\n第五，要了解常用的JVM参数，明白对不同参数的调整会有怎样的影响，适用于什么样的场景？比如垃圾回收的并发数，偏向锁的设置等。如果想要面试官对你留下更好的印象的话，注意这些加分项。\n 编译器优化 问题排查经验与思路\n JVM调优经验和调优思路\n 了 解最新的技术趋势(例如ZGC、Graalvm )\n  首先如果在编译器优化方面有深入的了解的话，会让面试官觉得你对技术深度比较有追求。比如知道在编程时如何利用栈上分配，降低GC压力，如何编写适合内容优化的代码等。其次，如果你能有线上实际问题的排查经验或者思路，那就更好了。面试官都喜欢动手能力强的同学，例如解决过线上经常FullGC的问题，排查过内存泄漏的问题等。\n第三，如果有针对特定场景的JVM优化实践，或者优化思路，也会有意想不到的效果。比如针对高并发低延迟的场景，如何调整GC数，尽量降低停顿时间，针对队列处理机如何尽可能提高吞吐率等。\n第四，如果对最新的JVM技术趋势有所了解，也会给面试官留下比较深的印象。ZGC高效的实现原理，了解grave vm的特点等。\n第一题，Java内存模型前面已经讲过了，面试回答这个问题时，记得和面试官确认是希望回答gvm的内存模型，还是Java对内存访问的模型，不要打跑偏了。\n真题汇总\n 简单描述一下JVM的内存模型 什么情况下会触发FulIGC ?(年轻代晋升时老年代空间不足，永久代空间不足等)\n Java类加载器有几种,关系是怎样的?\n 双亲委派机制的加载流程是怎样的,有什么好处?\n 1.8为什么用Metaspace替换掉PermGen ? Metaspace保存在哪里?\n 编译期会对指令做哪些优化? (简单描述编译器的指令重排)\n 简单描述一下volatile可以解决什么问题 ?如何做到的?\n 简单描述一- 下GC的分代回收。\n G1垃圾回收算法与CMS的区别有哪些?\n 对象引用有哪几种方式，有什么特点?\n 使用过哪些JVM调试工具，主要分析哪些内容?\n  多线程 线程状态转换，在运行中线程一共有NEW、RUNNING、BLOCKED、WAITING、TIME_WAITING、TERMINATED 6种状态，这些状态对应thread中state枚举类的状态。\n如图上方。当创建一个线程的时候，线程处在NEW状态。运行thread start方法后。现成进入RUNNABLE可运行状态，这个时候所有可运行状态的线程并不能马上运行，而是需要先进入就绪状态，等待线程调度，就是图中间的 ready状态。\n在获取到CPU后才能进入运行状态，就是图中的running。运行状态可随着不同条件转换成除new以外的其他状态。我们先看左边，在运行态中的线程，进入synchronized同步块或者同步方法时，如果获取锁失败，就会进入到BLOCKED的状态。当获取到锁时，会从block状态恢复到就绪状态。\n再来看右边，运行中的线程还会进入等待状态，这两个等待状态一个是有超时间的等待，例如调用object类的wait方法。 Thread类的join方法等。另外一个是无超时的等待，例如调用thread类的join方法或者lock的park方法。这两种等待都可以通过notify或者unpark。结束等待状态，恢复到就绪状态，最后是线程运行完成结束时。如图下方。线程状态就变成了TERMINATED的。\n线程的同步与互斥，解决线程同步与互斥的主要方式是cas、Synchronized和lock。\n我们先来看CAS，CAS是属于一种乐观锁的实现，是一种轻量级锁，JUC中很多工具类的实现就是基于CAS。 CAS操作的流程如左图所示。线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改，则写回若已被修改则重新执行读取流程，这是一种乐观策略。认为并发操作并不总会发生，比较并写回的操作是通过操作系统的原语实现的，保证执行过程中不会被中断。CAS容易出现ABA问题，比如按右图所示的时序，线程t一在读取完值a后发生过两次写入，先由线程t二写回了b又由线程t三写回了a；此时T1在写回时进行比较，发现值还是a就无法判断是否发生过修改。ABA问题不一定会影响结果，但还是需要防范；解决的办法可以增加额外的标志位或者时间戳，JUC工具包中提供了这样的类；\nsynchronized是最常用的现成同步手段之一。 他是如何保证同一时刻只有一个线程可以进入到临界区？我们知道 synchronized是对象进行加锁，在JVM中对象在内存中分为三块区域，对象头、实例数据和对齐填充，在对象头中保存了锁标志位和指向monitor对象的起始地址。如上图所示，右边的就是一个对象，它对应的monitor对象，当monitor被某个线程占用后，就会处于锁定状态。如图中的owner部分会指向持有monitor对象的线程。另外， Monitor还有两个队列，用来存放进入以及等待获取所的线程synchronize的应用在方法上时，在字节码中是通过方法的acc_synchronized的标志来实现的。\nSynchronize应用在同步块上时，在字节码中是通过monitor enter和monitor exit来实现的。针对synchronized获取锁的方式，JVM使用了锁升级的优化方式，就是先使用偏向锁，优先同一线程再次获取锁，如果失败就升级为cas轻量级锁，如果再失败会进行短暂的自旋，防止线程被系统挂起，最后如果以上都失败，就会升级为重量级锁。\n在介绍lock前，我们先来看一下AQS也就是队列同步器，这是实现lock的基础。.左图就是AQS的结构图，从图中可以看出，AQS有一个state标志位,值为1时表示有线程占用，其他线程需要进入到同步队列等待。同步队列是一个双向链表，当获得所在线程需要等待某个条件时，会进入condition的等待队列，等待队列可以有多个，当condition条件满足时，线程会从等待队列重新进入到同步对列，进行获取锁得竞争。\nReentrantLock就是基于AQS实现的，我们看右边的图，ReentrantLock内部有公平锁和非公平锁两种实现，差别就在于新来的线程有没有可能比已经在同步队列中等待的线程更早获得锁，和ReentrantLock的实现方式类似。Semaphore也是基于AQs差别在于与ReentrantLock是独占锁，Semaphore是共享锁。\n线程池 线程池通过复用线程，避免线程频繁的创建与销毁。Java的Executors工具类提供了5种类型线程池的创建方法。就是图中列出的这5种，我们看看他们的特点和适用场景：\n第一个是固定大小线程池，特点是线程数固定，使用的是无界缓冲队列，适用于任务数量不均匀的场景，以及对内存压力不敏感，但对系统负载比较敏感的场景。\n第二个是cach的线程池，特点是不限制创建的线程数，适用于要求低延迟的短期任务的场景。\n第三个是单线程线程池，也就是一个线程的固定线程池，适用于需要异步执行，但需要保证任务执行顺序的场景。\n第4个是scheduled的线程池，适用于定期执行任务的场景，支持按固定的频率定期执行和按固定的延时定期执行两种方式。\n第5个是工作窃取线程池，使用的forkjoinpool，是固定并行度的多任务队列，适合任务执行时长不均匀的场景。前面提到的线程池，除了工作窃取线程池之外，都是通过threadPoolExecute的不同初始化参数来创建的。\n线程池参数介绍 构造函数的参数列表，看到这张图。\n第一个参数设置核心线程数，默认情况下，核心线程会一直存活。\n第二个参数设置最大线程数，决定线程池最多可以创建多少线程。\n第3个参数和第4个参数，用来设置现成的空闲时间和空闲时间的单位，当线程闲置超过空闲时间时就会被销毁。可以通过threadPoolExecutor.allowCoreThreadTimeOut(true);方法来允许核心线程被回收。\n第5个参数设置缓冲队列，图中左下方的三个队列是设置线程池时最常使用的缓冲队列，其中ArrayBlockingQueue是一个有界队列，就是指队列有最大容量限制，linkedBlockingQueue是无界队列，就是队列不限制容量，最后一个是synchronousQueue是一个同步队列，内部没有缓冲区。\n第6个参数设置线程池工厂方法，线程工厂用来创建新的线程，可以用来对现成的一些属性进行定制。例如线程的group、线程名、优先级等，一般使用默认工厂类即可。\n第7个参数设置线程池满时的拒绝策略，如右下角所示有4种策略。\n Abort策略，在线程池满后。提交新任务时会抛出rejectExecutionException，这个也是默认的拒绝策略。 Discard策略，会在提交失败时对任务直接进行丢弃。 CallerOldest策略,会在提交失败时，由提交任务的线程直接执行提交的任务。 DiscardOldest的策略，会丢弃最早提交的任务。  我们再来看前面说的几种线程池都是使用怎样的参数来创建的？\n固定大小线程池创建时，核心和最大线程数都设置成指定的线程数，这样线程池中就只会使用固定大小的线程数，这种类型的线程池它的缓冲队列使用的是无界队列linkedBlockingQueue，\nsingle线程池就是线程数设置为1的固定线程池。\ncach的线程池它的核心线程数设置为0，最大线程数是整数integer的最大值，主要是通过把缓存队列设置成synchronousQueue这样只要没有空闲的线程就会新建；\nschedule的线程池，与前几种不同的是使用了delayworkQueue这是一种按延迟时间获取任务的优先级队列。\n我们向线程池提交任务时，可以使用execute和submit，区别就是 submit可以返回一个future对象，通过future对象可以了解任务的执行情况，可以取消任务的执行，还可以获取执行结果或者执行异常。Submit最终也是通过execute执行的。\n我们看看图中，向线程池提交任务时的执行顺序。向线程池提交任务时，会首先判断线程池中的线程数是否大于设置的核心线程数？如果不大于，就创建一个核心线程来执行任务，如果大于核心线程数，就会判断缓冲队列是否满了。如果没满，则放入队列，等待线程空闲时来执行，如果队列已经满了，就判断是否达到了线程值设置的最大线程数。如果没达到。就创建新的线程来执行任务。如果已经达到了最大线程数，就会执行指定的拒绝策略。这里需要注意，队列的判断，与最大线程数的判断，他们之间的顺序不要搞反。\nJUC常用工具类 前面基础知识部分已经提到过JUC是Java提供的用于多线程处理的工具类库，我们来看看其中常用工具类的作用，看图表格，第一行的类都是基本数据类型的原子类。包括AtomicBoolean、AtomicLong、AtomicInteger。\nAtomicLong是通过unsafe类实现的，基于cas。unsafe类是底层工具类，JUC中很多类的底层都使用到了unsafe包中的功能。unsafe类提供了类似c的指针操作，提供CAS的功能。unsafe中的所有方法，都是native修饰的。\n另外的LongAdder 4个类，是jdk1.8中提供的更高效的操作类。LongAdder是基于Cell实现使用分段锁思想，是一种以空间换时间的策略，更适合高并发场景。LongAccumulator提供了比LongAdder更强大的功能，能够指定对数据的操作规则。例如可以把对数据的相加操作改成相乘操作。\n第二行中的类。提供了对象的原子读写功能后两个类atomicStampReferenc和 atomicmarkableReference，是用来解决我们前面提到的aba问题，分别基于时间戳和标志位来解决.\n上图第一行的类主要是所相关的类，例如我们前面介绍过的reentrant重入锁，与reentrantLock的独占锁不同，Semaphore是共享锁，允许多个线程共享资源，适用于限制使用共享资源线程数量的场景，例如100个车辆要使用20个停车位，那么最多允许20个车占用停车位，stampedLock是1.8中改进的读写锁，是一种使用CLH的乐观锁，能够有效防止写饥饿。所谓写饥饿就是在多线程读写时，读线程访问非常频繁，导致总是有读线程占用资源，写线程很难加上写锁。\n第二行中主要是异步执行相关的类，这里可以重点了解JDK1.8中提供的 completableFuture，可以支持流式调用，可以方便的进行多future的组合使用。例如可以同时执行两个异步任务，然后对执行结果进行合并处理，还可以很方便的设置完成时间。\n另外一个是1.7中提供的folkJoinPool，采用分治思想，将大任务分解成多个小任务来处理，然后再合并处理结果，folkJoinPool的特点，是使用工作窃取算法，可以有效平衡任务执行时间长短不一的场景。\n上图中第一行是常用的阻塞队列，刚才讲解线程知识已经简单介绍过了，这里再补充一点，linkedblockingDeque是双端队列，也就是可以分别从队头和队尾操作入队和出队，而arrayBlockingQueue是单端队列，只能从队尾入队，从队头出队。\n第二行是控制多线程协作式使用的类，其中, CountDown Latch,实现计数器功能，可以用来等待多个线程执行任务后进行汇总。CyclicBarrier可以让一组线程等待着某个状态后在全部同时执行，一般在测试时使用，可以让多线程更好的并发执行。\nSemaphore前面已经介绍过，用来控制对共享资源的并发访问度。最后一行。是比较常用的两个集合类。ConcurrentHashMap前面已经细介绍过了，这里可以再了解一下。CopyOnWriteArrayList，COW通过写入数据时进行拷贝修改，然后再更新引用的方式，来消除并行读写中的锁使用，比较适合读多写少，数据量比较小，但是并发非常高的场景。\n考察点\n 理解线程的同步与互斥的原理 掌握线程安全相关机制 了解JUC工具的使用场景与实现原理 熟悉线程池的原理、使用场景、常用配置 理解线程的同步与异步、阻塞与非阻塞  同步与异步的区别，是任务是否是在同一个线程中执行的，阻塞与非阻塞的区别是异步执行任务时，线程是不是会阻塞等待结果，还是会继续执行后面的逻辑。\n加分项\n 结合实际项目经验或实际案例介绍原理 解决多线程问题的排查思路与经验 熟悉常用的线程分析工具与方法 了解Java8对JUC的增强 了解Reactive异步编程思想  面试题\n 如何实现一个生产者与消费者模型? ( 锁、信号量、线程通信、阻塞队列等) 如何理解线程的同步与异步、阻塞与非阻塞? 线程池处理任务的流程是怎样的? wait与sleep的有什么不同?  wait属于Object类，sleep属于Thread类 wait会释放对象锁而sleep不会 wait需要在同步代块中使用，而sleep不需要，可以在任何地方使用 wait不需要捕获异常，sleep需要捕获异常  Synchronized和ReentrantLock有什么不同?各适合什么场景? 读写锁适用于什么场景? ReentrantReadWriteLock是如何实现的?  读写锁适合读并发多，写并发少的场景另外一个解决该场景的方式时copyOnWrite  线程之间如何通信?（wait notify机制、共享变量的synchronized和Lock同步机制） 保证线程安全的方法有哪些?（CAS、Synchronized、Lock、ThreadLocal机制） 如何尽可能提高多线程并发性能?（尽量减少临界值范围、使用ThreadLocal、减少线程切换、使用读写锁或CopyOnWrite机制） ThreadL ocal用来解决什么问题? ThreadLocal是如何实现的?（ThreadLocal不是用来解决多线程共享变量的问题而是用来解决线程数据隔离的问题） 死锁的产生条件?如何分析是否有线程死锁? 在实际工作中遇到过什么样的并发问题,如何发现(排查)并解决的?  数据结构与算法 首先看数据结构的知识点有哪些，队列和栈是经常使用的数据结构，需要了解他们的特点。队列是先进先出，栈是后进先出。第三个是表，包括很多种，有占用连续空间的数组，用指针链接的单向和双向链表，首尾相接的循环链表，以及散列表也叫哈希表。\n第4个是图,在特定领域使用的比较多。例如旅游算法中经常会使用到。图分为有向图、无向图以及带权图。这部分需要掌握图的深度遍历和广度遍历算法，了解最短路径算法。最后部分是树的内容。树一般用作查找与排序的辅助结构。\n剩下的两个部分都和树有关。一个是二叉树，一个是多叉树，多叉数包括b树组。有B树，B+树。B+树比较适合用来做文件检索。另外一个是字典树，适合进行字符串的多模匹配，二叉树包括平衡二叉树、红黑树、哈夫曼树以及堆，适合用来进行数据查找和排序，这部分需要了解二叉树的构建、插入、删除操作的实现，需要掌握二叉树的前序中序后序便利。\n二分查找适合小数量级内存查找，B树适合文件索引，哈希是常数集的时间复杂度，更适合对查找效率要求较高的场合，BloomFilter适合对大数据及进行数据存在性过滤。\n二叉搜索树满足这样的条件。每个节点包含一个值，每个节点至多有两棵子树，每个节点左子树节点的值都小于自身的值。每个节点右子树的值都大于自身的值。如左图所示，二叉树的查询时间复杂度是O(log n)但是随着不断的插入删除节点。二叉树的树高可能会不断变大。当一个二叉树所有的节点都只有左子树。或者都只有右子树时，去查找性能已经退化成线性的了。平衡二叉树可以解决这个问题，平衡二叉树保证每个节点左右指数的高度差，绝对值不会超过1。例如avl树，avl树是严格的平衡二叉树插入或删除数据时，可能经常需要旋转来保持平衡。比较适合插入删除比较少的场景。红黑树是一种更加实用的非严格的平衡二叉数。红黑树更关注局部平衡而非整体平衡，确保没有一条路径会比其他路径长出两倍。所以是接近平衡的，但减少了许多不必要的旋转操作，更加实用。前面提到过，Java8的发行map中就应用了红黑树解决散列冲突时查找的问题。Tree map也是通过红黑树来保证有序性的。红黑树除了拥有二叉搜索树的特点还有以下规则。\n看到右边的图,红黑树具有如下特性\n 第一，每个节点不是红色，就是黑色 第二，根节点是黑色 第三，每个叶子节点都是黑色的空节点，例如图中的黑色三角。 第四，红色节点的两个子节点都是黑色的。 第五，任意节点到其夜节点的每条路径上，包含相同数量的黑色节点  再来看看B树的知识点，B树是一种多叉树，也叫多路搜索树。B树中每个节点可以存储多个元素，非常适合用在文件索引上，可以有效减少磁盘的IO次数。\nB树中所有的节点最大子节点数称为B树的阶，左边的图就是一棵三阶B树，也叫二三树。一个m阶b树有如下特点。\n 第一，非叶节点最多有m颗子树。 第二，根节点最少有两颗子树，非根非叶节点最少有二分之m棵子数。 第三，非叶子节点中保存的关键字个数等于该节点子树个数减一。就是说一颗节点如果有三颗子树，那么其中必定包含两个关键字。 第四。非叶子节点中的关键字大小有序。如图中左面的节点。37、51这两个元素就是有序的。 第五，节点中每个关键字左子树中的关键字。都小于该关键字。右子树中的关键字都大于该关键字，如图中关键字51的左子数有42 49都小于51。右子树的节点有59。都大于51。 第六，所有叶结点都在同一层  b树在查找时，从根节点开始，对节点内有序的关键字序列进行二分查找，如果找到就结束，如果没找到就进入查询关键字所属范围的子树进行查找，直到叶结点。\n总结一下：B树的关键字分布在整棵树中，一个关键字，只出现在一个节点中，搜索可能在非叶结点停止。B树一般应用在文件系统。右边的图是B树的一个变种。叫B+树，B+树的定义与B树基本相同。除了下面这几个特点。\n 第一，节点中的关键字与子树目相同，比如节点有三个关键字，那么就有三棵子树。 第二，关键字对应的指数的节点都大于等于关键字。子数中包括关键字自身。 第三。所有关键字都出现在叶结点中。 第四。所有叶节点都有指向下一个叶节点的指针。  与b树不同，B+树在搜索时。不会在非叶结点命中，一定会查询到叶子节点。另外一个叶子节点，相当于数据存储层，保存关键字对应的数据，而非叶节点只保存关键字和指向叶节点的指针，不保存关键字对应的数据，所以同样关键字数量的分页节点。B+树比b树要小很多。B+树更适合做索引系统，原因有三个。\n 第一个由于叶节点之间有指针相连，B+树更适合范围检索。 第二个，由于非叶结点只保存关键字和指针，同样大小的非叶结点，B+树可以容纳更多的关键字，可以降低树高，查询时磁盘读写代价更低。 第三个，B+树的查询效率比较稳定，任何关键字的查找必须走一条从根节点到叶节点的路。所有关键字查询的路径长度相同，效率相当。  MySQL数据库的索引就提供了B+树的实现。最后可以简单了解，还有一种B*树的变种。在B+树的非叶节点上，也增加了指向同一层下一个非叶节点的指针。\n字符串匹配问题: 判断给定字符串中的括号是否匹配 解题思路: 1、使用栈 2、遇左括号入栈 3、遇右括号出栈,判断出栈括号是否与右括号成对\n判定给定字符串中的括号是否匹配。以这道题为例，可以确认括号的范围是不是只考虑大中小括号就可以？包不包括尖括号？对函数的入参和返回值有没有什么样的特殊要求？需不需要考虑针对大文件的操作等。我们假定细化后，本题的要求是只考虑大中小括号，不考虑针对大文件的操作，以字符串作为入参，返回值为boolean类型，未出现括号也算做匹配的一种情况。那么解题思路如下。字符串匹配问题，可以考虑使用栈的特性来处理。遇到左括号时入栈，遇到右括号时出栈对比，看是不是成对的括号。当匹配完成时。如果栈内为空，说明匹配，否则说明左括号多余右括号。\npublic class Test { public static Map\u0026lt;Character, Character\u0026gt; brackets = new HashMap\u0026lt;\u0026gt;(); static { brackets.put(')', '('); brackets.put(']', '['); brackets.put('}', '{'); } public static Boolean isMatch(String str) { if (str == null) { return false; } Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (char ch : str.toCharArray()) { if (brackets.containsValue(ch)) { stack.push(ch); } else if (brackets.containsKey(ch)) { if (stack.empty() || stack.pop() != brackets.get(ch)) { return false; } } } return stack.empty(); } }  按照刚才的思路，需要对字符串进行遍历。所以首先要能确定栈操作的触发条件。也就是定义好括号对。方便入栈和出栈匹配。这里要注意编码实现时一定要注意编码风格与规范。例如变量命名必须要有明确的意义。不能简单使用a，b这种没有明确意义的变量名。我们首先定义一个brackets 的Map。Key是所有的右括号，Value是所有对应的左括号这样定义方便出栈时对比括号是否成对？再看一下匹配函数的逻辑，这里也要注意，作为工具类函数，要做好健壮性防御，首先要对输入参数进行验空，然后我们定义一个保存字符类型的栈，开始对输入的字符串进行遍历。\n如果当前的字符串是bracket中的值，也就是左括号的入栈。这里要注意 map的值查询的时间复杂度是O(n)因为本题中括号种类非常少，才使用这种方式让代码更简洁一些。如果当前的字符不是左括号。在使用containsKey来判断是不是又括号？如果是有括号，需要检验是否匹配，如果栈为空，表示右括号多余左括号。如果栈不空，但出栈的左括号不匹配，这两种情况都说明字符串中括号是不匹配的。当遍历完成时，如果栈中没有多余的左括号的匹配，最后强调一下，编码题除了编程思路，一定要注意编程风格和细节点的处理。\nTop k问题 例如微博的热搜。\n第三个讲解知识点，我们就来分析Top k问题。Top k一般是要求在n个数据的集合中找到最小或者最大的k个值。通常n都非常的大，Top k可以通过排序的方式来解决，但是时间复杂度较高，一般是O(n*k)这里我们来看看更高效的方法，看到右面的图。首先取k个元素，建立一个大根堆。然后对剩下的n-k个元素进行遍历，如果小于对应的元素，则替换掉对应元素，然后调整堆当全部遍历完成时，堆中的k个元素就是最小的k个值。这个算法的时间复杂度是O(n*log k)算法的优点是不用在内存中读入全部的元素，能够适用于非常大的数据集。\n也许还会碰到关于Top k的变种问题。就是从n个有序队列中找到最小或最大的k个值。这个问题的不同点在于是对多个数据集进行排序，由于初始的数据集是有序的，因此不需要遍历完n个队列中的所有元素。因此解题思路是如何减少要遍历的元素。\n解题思路如右面的图所示。第一步先用n个队列的对头元素。也就是每个队列的最小元素，组成一个有k个元素的小根堆，方式同Top k中的方法。第二步。获取堆顶值，也就是所有队列中最小的那一个元素。第三步。用这个堆顶元素所在的队列的下一个值放入堆顶，然后调整堆，最后重复这个步骤。直到获取够k个数，这里还可以有个小优化。，就是第三步往堆顶放入新值时。跟堆的最大值进行一下比较。如果已经大于堆中的最大值。就可以提前终止循环了。这个算法的时间复杂度是O(N+K-1)*logK。注意这里与队列的长度无关.\n第一个方法是分治法。分治法的思想是将一个难以直接解决的复杂问题或者大问题，分割成一些规模较小的相同的问题，分而治之。\n比如快速排序，归并排序。都是应用了分治法是和使用分治法的场景，需要满足三点要求。\n 第一、可以分解为子问题 第二、子问题的解可以合并为原问题的解。 第三、子问题之间没有关联。  使用分治法解决问题的一般步骤，如表格第三列所示。第一步，要找到最小子问题的求解方法。第二步，要找到合并子问题解的方法。第三步，要找到递归终止条件。\n第二个方法。是动态规划法，与分治法类似，也是将问题分解为多个子问题。与分治法不同的是，子问题的解之间是有关联的，前一子问题的解为后一子问题的求解提供了有用信息，动态规划法依次解决各个子问题，在求解每一个子问题时，列出所有的局部解，通过决策保留那些可能达到全集最优的局部解。最后一个子问题的解就是初始问题的解。使用动态规划的场景。也需要满足三个条件。\n 第一，子问题的求解必须是按顺序进行的。 第二，相邻的子问题之间有关联关系。 第三，最后一个子问题的解就是初始问题的解。  使用动态规划解决问题时。第一步。先要分析最优解的性质。第二步，递归的定义最优解。第三步，记录不同阶段的最优值。第4步，根据阶段最优质，选择全局最优解。\n第三个方法是贪心算法，因为它考虑的是局部最优解，所以贪心算法不是对所有问题都能得到整体最优解，贪心算法的关键是贪心策略的选择，贪心策略必须具备无后效性。就是说某个状态以后的过程，不会影响以前的状态，只与当前状态有关。贪心算法使用的场景必须满足两点。第一是局部最优解能产生全局最优解。第二点就是刚才说的必须具备无后效性。使用贪心算法，解题的一般步骤为。第一步，先分解子问题。第二步，贪心策略 计算每个子问题的局部最优解。第三步，合并局部最优解。\n第四个方法是回溯算法。它实际上是一种深度优先的搜索算法，按选优的条件向前搜索，当探索到某一步时，发现，原先的选择并不优或者达不到目标，就退回上一步重新选择。这种走不通就退回再走的方法，就是回溯法，回溯法适用于能够深度优先搜索，并且需要获取解空间的所有解的场合。例如迷宫问题，回溯算法一般的解题步骤为。第一步。先针对所给问题确定问题的解空间。第二步，确定节点的扩展搜索规则。第三步，以深度优先的方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。\n最后是分支界定法。与回溯法的求解目标不同，回溯法求解目标是找出满足约束条件的所有解，而分支界定法的求解目标是找出满足约束条件的一个解。分支界定法适用于广度优先搜索。并且获取解空间任意解就可以的场合。例如求解整数规划的问题。分支界定法一般的解题步骤。第一步。先确定解的特征。第二步。再确定子节点搜索策略。例如是先入先出还是先入后出？第三步通过广度优先遍历寻找解。\n考察点\n 了解基本数据结构及特点 表、栈、队列、树需要熟练掌握,深刻理解使用场景 了解常用的搜索、排序算法,及复杂度和稳定性 了解常用的字符串处理算法 能够分析算法实现的复杂度 了解常用算法分类,解决问题的思路和解决哪类问题  加分项\n 能够将数据结构与实际使用场景结合 不同算法在业务场景中的应用 面对模糊的题目能沟通确认条件和边界 书写算法代码前,先讲一下解题思路 能够发现解答中的一些问题,给出改进的思路  题目\n 各种排序算法实现和复杂度、稳定性 二叉树的前、中、后序遍历 翻转句子中单词的顺序 用栈模拟队列(或用队列模拟栈) 对10亿个数进行排序,限制内存为1G 去掉(或找出)两个数组中重复的数字 将一颗二叉树转换成其镜像 确定一个字符串中的括号是否匹配 给定一个开始词，一个结束词，一个字典，如何找到从开始词到结束词的最短单词接龙路径 如何查找两个二叉树节点的最近公共祖先  常用工具集 JMC 第一个要介绍的是JMC就是 Java Mission control，JMC是Jdk1.7中提供的图形化JVM监控与分析工具。我们看图，JMC包括JVM浏览器和JMX控制台，以及JFR也就是飞行记录器三部分，\nJVM浏览器可以列出正在运行的Java程序的JVM,每个JVM实例叫做一个JVM连接，JVM浏览器使用GDP，也就是Java发现协议，可以连接到本地和远程运行的JVM 。JMMX是Java管理扩展规范，能够管理并监控 JVM。JMX通过对MBns的管理，可以实时收集JVM信息，比如类实例信息，堆使用情况，CPU负载、线程信息等，以及其他可以通过MBns管理的一些运行时的属性，JFR提供了深入到JVM内部，去看运行是状态的能力，是一个非常强大的性能profile工具，适合对程序进行调优和问题排查。\nJFR对jvm运行时产生的事件进行采集，可以通过指定采集事件的类型和频率来收集非常全面的数据信息。这里我主要介绍一下使用JFR可以分析到哪些信息？看到图下方 JFR可以采集分析5大类信息，第一部分是内存信息，这里可以获取到gc的不同阶段及耗时情况，GC的停顿时间，gc的分代大小等配置信息，能够查看到对象分配，包括Tlab栈上分配情况，以及对象统计信息等。第二部分是代码信息，可以分析出热点的类热点的方法、热点的调用数、运行时的异常信息、编译情况、包括osr栈上替换等信息，以及类的加载卸载情况。第三部分是现线程息部分。可以分析到热点的线程。线程的征用情况，线程的等待时间，以及锁相关的信息。第4部分是io信息部分。可以获得收集期间的磁盘Io。也就是文件读写信息以及网络IO等信息。最后一部分系统信息可以获取到操作系统信息，进程相关信息以及环境变量等信息。\n总结一下 JMX和JFR都可以获得JVM运行时的信息，JMX主要用来对JVM进行监控与管理，通过扩展mbn，支持自定义的管理能力。JFR主要用来对JVM运行信息进行周期性采集，用来对运行状况进行分析。\nbtrace 第二个工具，我们来了解btrace，如果你在分析线上问题时，发现日志打的不全，无法定位问题怎么办？添加日志重新上线肯定不是个好主意，特别是调试时，可能需要反复添加日志来定位问题，或者。线上出现的问题很难再复现，你根本没有机会添加日志再继续分析，这时就需要使用到btrace。btrace是一个实时监控工具，被Java工程师分为性能调优和线上问题诊断的神器，btrace基于动态字节码修改技术，来实现对运行时的Java程序进行跟踪和替换。\n也就是说可以在不重启JVM的情况下，监控系统运行情况，获取JVM运行时的数据信息。比如方法参数。返回值，全局变量、堆栈信息等。先看左边的表格，btrace可以做什么？\n首先可以对方法进行定位拦截，获取方法的入参，返回值、执行时间等信息。第二，可以查看某类对象的创建情况。第三，可以对内存使用情况进行统计，可以查看对象大小，可以查看同步块执行情况。第五可以查看异常抛出情况，即导致异常的参数信息。第六，能够支持定时执行检查任务。第七，能够查看类加载的信息，批发能够进行死锁检测。第九。可以打印线程栈信息。第十，可以监控文件或网络的读写情况，可以看到btrace的功能非常强大，几乎无所不能。因为btrace会把逻辑直接植入到运行的中，为了保证安全，在使用上会有一些限制。\n我们再看看右边的表格，btrace不能做什么？第一，btrace不能创建新的对象。第二不能抛出或者捕获异常。第三不能使用循环。例如for while。第四，btrace脚本的属性和方法必须使用static修饰。第五。不能使用synchronized同步块或同步方法。第六，不能调用实例方法或静态方法，只能使用b treesutil类提供的方法，使用btrace条件还是非常严格的。\n这里要注意三点，一个是不恰当的使用btrace，可能导致JVM崩溃。第二个。Btrace所做的修改是会一直生效的，直到重新启动后才会消除。第三，可以通过设置JVM参数，取消被btrace的安全限制。\njvm 我们再来看看其他一些常用的JVM工具，JPS用来查看Java进程的信息，包括进程ID，主类名称、主类全路径等。\njmap可以查看JVM中对象的统计信息。包括内存占用，实例个数。对象类型等。jmap可以把堆dump下来。配合内存分析工具MIT进行分析。jstat对资源和性能进行实时监控。统计项主要包括类加载情况，内存容量及使用量，GC次数和时间等。\njstack可以查看JVM线程栈信息。包括线程的名称、序号。优先级，线程状态锁状态等，jinfo可以查看运行中JVM的全部参数，还可以设置部分参数，jcmd是jdk1.7后提供的工具，可以向JVM发送诊断命令，它的功能非常强大，基本上包括了jmap、jstack、jstat的功能，可以重点了解一下这个工具。\n我再来列举几个实际应用场景，当你排查线上问题时，需要查看GC日志，发现没有打印jGC详细日志，这是可以通过jinfo来开启JVM参数，print GC details来动态生效。\n当你分析内存泄漏风险时，可以通过jmap或jcmd定期获取堆对象的统计信息，来发现持续增长的可疑对象。当你遇到某一时刻，所有服务都出现耗时较高的情况，可以通过jstack来观察GC回收状况，看看是不是GC行动耗时过高了。当你遇到JVM中某一个服务卡死。或者停止处理时，可以通过jsdaCK来查看线程栈，看看是否有多个线程处于blocked状态，产生了死锁。当你的服务上线后，发现性能达不到预期，可以使用jmc来分析运行信息，看看哪些热点方法可以优化，哪些线程竞争可以避免。\ngit 来看看git相关的知识点详解。Git与svn的区别在前面的知识点汇总中已经简单介绍过，这里来看看Git的常用命令及其对应的使用场景。Git对版本是分布式管理，有4个保存数据的区域，如图中浅绿色的部分，分别是本地工作区，work space，本地暂存区stage，本地仓库和远程仓库开发时，先从远程仓库拉取代码到工作区。\n可以有clone，full。Fetch加check out几种方式，如图中向左的几个箭头所示，在提交代码时，先通过add命令添加到暂存区，然后再commit提交到本地仓库,之后再使用push推送到远程仓库。如图中向右的几个箭头所示，稍微注意一下fetch与pull的区别，fetch是从远程仓库同步到本地仓库，但并不会合并到工作区，pull相当于执行的是fetch命令加merge命令，先同步到本地仓库，然后在merge到工作区，get的命令行提示做得非常友好，对常用的Git操作的说明也非常完善，其他的命令我就不展开介绍。\n使用Git进行团队协作开发时，多人协作多分支开发是非常见的。为了更好的管理代码，需要制定一个工作流程，这就是我们说的工作流，也可以叫做分支管理策略，常见的基于git的工作流，有get flow工作流，github工作流和gitlab工作流。\n看到左边的图，gitflow按功能来说分为5种分支，在图中以不同颜色表示，其中master和develop是长期分支，master分支上的代码都是版本发布状态，develop分支是代表最新的开发进度，当需要开发某些功能时，就从develop拉出feature分支进行开发。开发完成并验证后。就可以合并回develop分支，当develop上的代码达到一个稳定状态，可以发布版本的时候，会从develop合并到release分支进行发布。如果验证有问题，就在release分支进行修复。修复验证通过后进行正式发布。然后合并到master分支和develop分支，还有一个hotfix分支，用来做线上的紧急bug修复，hotfix直接从master拉出分支修改，修改完成验证后，直接合并回master，并同步到develop分支。gitflow的流程非常完善，但对很多开发人员和团队来说，会稍微有些复杂，而且没有图形界面。\n我们来看另一种更简单的工作流，图中间的github工作流，github工作流只有一个长期分支master，而且master分支的代码永远是可发布状态。如果有新的功能开发，可以从master分支上剪出新分支，开发完成需要合并时，创建一个合并到master的p2，也就是pull request。当merge通过或者验证通过后，代码合并到master分支。github工作流hotfix热修复的流程，和feature分支是完全一样的。\n最后看到右面的gitlab工作流，前面两种工作流各有优缺点，gitflow工作流稍微复杂，github工作流的单一分支，有时会略显不足。gitlab结合了两者的优势，既支持gitflow的多分支策略，也有github工作流的一些机制。比如。merge、request和ishow跟踪。\ngitlab的工作流，使用pre production分支来进行预发管理，使用production分支来发布版本。\nlinux分析工具 首先是表格中列出的stat系列，vm state可以获取有关进程，内存页面交换，虚拟内存线程上下文切换，等待队列等信息，能够反映系统的负载情况，一般用来查看进程，等待数量，内存换液情况，系统上下文切换是否频繁等。\niostat的工具可以对系统的磁盘操作活动进行监视，同时也可以显示CPU使用情况，一般用来排查与文件读写有关的问题。例如，排查文件写入耗时较高时，可以查看awake和ut是否过高。iotop是查看磁盘io使用状况的Top类工具，当你想知道到底哪个进程产生了大量的io时，可以使用Io Top。\nifstat是简洁的实时网络流量监控工具，可以查看系统的网络出口入口的使用情况。IfTop可以用来监控网卡的实时流量，反向解析IP，显示端口信息等。通过IfTop很容易找到哪个IP在霸占网络流量。\nnetstat是一个监控系统网络状态的工具，它可以查看网络链接状态，监听了哪些端口，链接相关的进程等信息，能够显示与IP、tcp、udp、ICMP协议相关的统计数据是非常用的网络工具。\ndstat是一个全能实时系统信息统计工具，能够统计cpu占用，内存占用，网络状况、系统负载、进程信息、磁盘信息等，可以用来替换vmstat，Iostat，netstat、idstat这些工具。\n再来看这一张图几个工具，strace是一个用于诊断调试程序运行时系统调用的工具，可以动态跟踪程序的运行，能够清楚地看到一个程序运行时产生的系统调用的过程及其使用的参数，返回值和执行耗时。JVM执行native方法是可以很方便的通过strace来进行调试。例如。在执行系统读写时，线程卡住很长时间，就可以用strace来查看系统调用的参数和耗时。\nGDB是一个强大的命令行调试工具，可以让程序在受控的环境中运行，让被调试的程序在您所指定的断点处停住，也可以动态的改变你程序的执行环境。当JVM因为未知原因crash时。你可以通过GDP来分析crash产生的coredump文件，来定位分析问题。\nLSOF是一个列出当前系统打开文件的工具，我们知道Linux中一切皆文件，包括设备链接等，都以文件形式管理。因此通过lsof工具查看文件列表，对系统监测以及排错都很有帮助。\nTcpdump是一个强大的网络抓包工具，在分析服务之间的调用时非常有用，可以将网络中传输的数据包抓取下来进行分析。Tcpdump提供灵活的抓取策略，支持针对网络层协议、主机或者端口进行过滤。并提供and or not。等逻辑语句来去掉不想要的信息。\nTrace root是一个网络路由分析工具，利用sMP协议定位本地计算机和目标计算机之间的所有路由，trace note对服务之间，特别是经过公网的服务之间的网络问题排查非常有帮助。\n考察点\n 了解常用的JVM分析工具 掌握Git的常用操作和工作流 了解Linux系统下常用的分析工具  例如线程死锁可以用现成分析工具jstack。内存溢出可以使用jmap查看堆中占用最大的对象类型，需要对程序性能进行分析时，可以使用JMC中的飞行记录器等。\n第要知道git的merge与get replaced的区别，merge是提交commit来合并修改，replace是修改提交历史记录，还要知道自己的团队在协作开发时使用的哪种工作流，有什么样的优缺点。\n当面试官询问你遇到过哪些现象问题时。你可以说我遇到过单机请求耗时较高的问题。\n通过JMC的飞行记录器采样分析，发现写log日志时，线程竞争非常激烈，很多线程在等待解写锁时耗时非常大，进一步通过lOstat排查发现ut利用率。比较高。最后定位是磁盘出现的问题，解决方法一方面更换磁盘来解决问题，另一方面对写竞争比较激烈的日志文件使用了异步log机制。\n这样回答。既可以突出你对常用工具的掌握能力。也可以突出你的实战和解决问题能力。另外再给你提供两个思路。一个你可以在介绍自己开发的项目时。提到在上线前使用jmc做了性能profile，发现并优化了某些问题。第二个。在介绍项目方案时，讲到自己对某两个不同方案进行了jMh测试，来验证方案实现的性能等。\n真题\n 排查JVM问题有哪些常用工具? (你曾经遇到过什么问题,如何排查,如何解决的) Git合并代码有哪两种方法?有什么区别? Git与SVN有哪些差异? 你所在的团队项目开发使用什么样工作流?有什么优点?  spring全家桶 spring boot的目标是简化spring应用和服务的创建开发与部署，简化了配置文件，使用嵌入式web服务，还有诸多开箱即用的微服务功能，可以和spring cloud联合部署，spring boot的核心思想是约定大于配置，应用只需要很少的配置即可，简化了应用开发模式。\nSpring data是一个数据访问及操作的工具集，封装了对多种数据源的操作能力。包括JDBC、Redis等。Springcloud是一套完整的微服务解决方案，是一系列不同功能的微服务框架的集合。Spring cloud基于spring boot，简化了分布式系统的开发，集成了服务发现，配置管理、消息总线、负载均衡、断路器、数据监控的各种服务治理能力，比如sleuth。提供了全链路追踪能力，Netflix套件提供了Hystrix熔断器做网关等众多的治理组件，configure组件提供了动态配置能力，bus组件支持了rabbit mq、kfaka、Active mq等消息队列，实现分布式服务之间的事件通信，spring security，用于快速构建安全的应用程序和服务。\n在spring boot和spring security OAuth2 的基础上，可以快速实现常见安全模型。比如单点登录、令牌中继、品牌交换。这里可以了解一下 OAuth2的授权机制和的认证方式。OAuth2是一种授权机制，规定了完备的授权认证流程。\nJwt全称是jason web token，是一种把认证信息包含在token中的认证实现。OAuth2的授权机制，就可以运用jwt来作为认证的具体实现方法。\n第二个知识点是struts，它是曾经非常火爆的web组合，ssh中的控制层，我们知道web服务一般都采用分层模型构建。就是 Model层负责内部数据模型。Controller负责请求的分发控制、dao层负责返回给用户展示的视图，struts实现的就是集中控制层的角色，struts采用filter实现，针对类进行拦截，每次请求就会创建一个action，不过使用struts的ssh组合，已经逐渐被使用spring mvc的ssm组合代替，一方面原因是由于struts对几次安全漏洞的处理，让大家对struts的信心受到了影响。另一方面string mvc更加灵活，不需要额外配置，不存在和string整合的问题，使用更加方便。所以建议。以ssm框架的学习为主。\n第三个知识点，我们来看看常用的orm框架，orm就是对象关系匹配。是为了解决面向对象与关系数据库存在互相不匹配的问题。简单来说，就是把关系数据库中的数据转化成面向对象程序中的对象，常用的orm框架有hibernate和mybatis，也就是ssh组合和ssm组合中的h与m我们来看一下它们的特点和区别，hibernate对数据库结构提供了完整的封装，实现了对象与数据库表之间的映射，能够自动生成并执行sql语句。只要定义了portal到数据库表的用水关系，就可以通过hibernate提供的方法完成数据库操作，hibernate符合JPA规范，就是 Java持久层API。mybatis是通过映射配置文件，将sql所需的参数和返回的结果映射到指定对象。mybatis是不会自动生成sql,需要自己定义sql语句，不过这样也更方便对sql语句进行优化。\n总结起来,hibernate配置要比mybatis复杂,学习成本也比mybatis高。mybatis是简单、高效、灵活，但是需要自己维护sql，hibernate功能强大，全自动适配不同数据库。但是非常复杂，灵活性稍差。再来看到图的右面，netty是一个高性能的异步事件驱动的网络通信框架，Netty对jdk原生的nio进行封装，简化了网络服务的开发，耐的知识点详解，后面我也会说到。\n下一个知识点是RPC服务。Motan、Dubbo、Grpc都是比较常用的高性能RPC框架，可以提供完善的服务治理能力。Java版本的通信层都是基于前面提到的netty实现的，他们的特点也会在详解中进行介绍。最后再简单介绍几个常用的框架，jersey和resteasy都是可以快速开发rest服务的框架，和spring mvc相比，这两个框架都基于jaxrs标准。而spring mvc基于servlet使用自己构建的API是两个不同的标准。shiro框架是一个与spring security类似的开源权限管理框架，用于访问的授权认证加密及会话管理，能够支持单机与分布式的session管理，相比security，shiro更加简单易用。\nspring 第一个讲解知识点是spring框架，讲解中涉及的流程与实现，默认都是基于5.x版本。先来看spring中的几个重要概念，第一个是ioc，也就是控制反转，看到图片最左边，我们拿公司招聘岗位来举个例子。假设一个公司有产品研发、测试、等岗位。如果是公司根据岗位要求，逐个安排人选，如图中向下的箭头，这就是正向流程。如果翻过来，不用公司来安排人选，而是由第三方猎头来匹配岗位和候选人，然后进行推荐。如图中向上的箭头，这就是控制反转。\n在spring中，对象的属性是由对象自己创建的，这是正向流程。如果属性不是对象创建，而是由spring来自动进行装配，这就是控制反转。这里的DI也就是依赖注入，是实现控制反转的一种方式，正向流程导致了对象与对象之间的高耦合，IOC可以解决对象耦合的问题，有利于功能的复用，能够使程序的结构变得非常灵活。\n第二个是spring进行loc实现时使用的两个概念，context上下文和bean，如中间图所示，所有被spring管理的，由spring创建的。用于依赖注入的对象就叫做一个bean。Spring创建并完成依赖注入后，所有的bean统一放在一个叫做context上下文中进行管理。\n最后一个重要的概念是aop也就是面向切面编程，看右面的图，一般我们的程序执行流程是从controller调用service层。然后service层调用dao层访问数据最后再逐层返回结果。这是一个图中向下箭头所示的按程序执行顺序的纵向处理。但是我们思考这样一个问题，一个系统中会有多个不同的服务。比如用户服务、商品信息服务等。每个服务的controller层都需要验证参数，都需要处理异常。\n如果按照图中红色的部分。对不同服务的纵向处理流程中进行横切，在每个切面上完成通用的功能。例如身份验证、参数验证、异常处理等。这样就不用在每个服务中都写相同的逻辑了，这就是aop思想解决的问题。Aop功能进行划分，对服务顺序执行流程中的不同位置进行横切，完成各服务共同需要实现的功能。\n再来看看spring框架，图中列出了string框架主要包含的组件，这张图来自spring四点几的文档，目前最新的5.x版本中，右面的portlet组件已经被废弃掉，同时增加了用于异步响应式处理的webFlux组件。\n这里你不需要对所有组件都详细了解，只需要重点了解最常用的几个组件实现，以及知道每个组件用来实现哪一类功能就可以了。图中橙色框住的是比较重要的组件，core组件是spring所有组件的核心beans组件和context组件，刚才我提到了，是实现IOC和依赖注入的基础。\nAOP组件用来实现面向切面编程，web组件包括了stringMVC。是web服务的控制层实现。\n接下来是spring中机制和实现相关的知识点。我们从左边看起，aop的实现是通过代理模式，在调用对象的某个方法时，执行插入的切面逻辑，实现的方式有动态代理，也叫做运行时增强。比如jdk代理CGLib，还有静态代理，就是在编译时进行植入，或者类加载时进行植入，比如AspectJ 。关于AOP还需要了解一下对应的aspect，print，card，advice等注解和具体的使用方式。Place holder动态替换，主要需要了解替换发生的时间是在Beandefactory创建完成后，bean初始化之前，是通过实现BeanFactoryPostProcessor接口实现的，主要实现的方式。有PropertyPlaceholderConfigurer和PropertySourcesPlacesPlaceholderConfigurer实现。这两个类实现逻辑不一样。Spring boot使用的是PropertySourcesPlacesPlaceholderConfigurer。\n第三个知识点是事务。需要了解spring中对事物规定的隔离类型和事物传播类型。这里需要知道事务的隔离级别是由具体的数据库来实现的。事物的传播类型，可以重点了解最常用的requireed和Supports两种类型。再来看右上方需要重点掌握的核心类，applicationcontext，保存了IOC的整个应用上下文，可以通过其中的bean factory获取到任意的bean。beanfactory的主要作用是根据being definition，也就是bean的描述。来创建具体的bean，beanWrapper是对bean的包装,一般情况下是在spring lOc的内部使用，提供了访问bean的属性值，属性编辑器注册，类型转换等功能，方便loc容器用统一的方式来访问bean的属性。\nFactorybean通过getobject方法返回实际的bean对象。例如motan框架中，refer对service的动态代理，就是通过factory bean来实现的。bean的scope是指bean的作用域，默认情况下是单例模式，这也是使用最多的一种方式。多例模式，就是每次从beanFactory中获取bean时都创建一个新的bean。request，session，globalSession是在web服务中使用的scope，request每次请求时都会创建一个实例。session是在一个会话周期内保证只有一个session。 Global session在五点几版本中已经不再使用。同时增加了application和web socket两种scope，分别保证在一个servlet context与一个web socket中只创建一个实例，还可以了解一下spring的事件机制，知道string定义的5种标准事件，了解如何自定义事件和实现对应的application listener来处理自定义事件。\n我们来看看string应用相关的知识点，首先要熟练掌握常用的注解的使用，按类型来分，可以分为类型类的注解，包括controller、service等，你可以重点了解一下component和bean这两个注解的区别，component注解在类上使用，表明这个类是个组件类，需要spring为这个类创建bean。bean注解使用在方法上告诉string，这个方法将会返回一个bean对象，需要把返回的对象注册到此类应用的上下文中，设置类的注解，可以重点了解autowired和qualifier。以及Bytype byname等不同的自动装配机制。\nweb类主要以了解为主，关注requestMapping，getMappeing。PostMapping等路径匹配注解。以及Pathvariable、requestparam等参数获取注解。最后是功能类注解。包括。ImportResource引用配置，components scan，注解自动扫描。Traditional事务注解等，这里就不一一介绍了。再来看右面，我们需要了解配置string的几种方式，XML文件配置、注解配置和使用API进行配置，自动装配机制，需要了解按类型匹配进行自动装配，按变名称进行自动装配，构造器中的自动装配和自动检测等4种主要方式。\n最后还可以了解一下 list、set、map等集合类型的属性，它的配置方式，以及内部bean的使用。\n这部分是spring context的初始化流程，左上角是三种类型的content，xml配置方式的content，spring boot 的 context和web服务的context，不论哪种centext的，创建后。都会调用abstract application context类的refresh方法。这个方法是我们要重点分析的。Refresh方法中。\n 第一步，首先对刷新进行准备，包括设置开始时间，设置激活状态，初始化contents环境中的占位符。这个动作根据子类的需求，由子类来执行。然后验证是否缺失必要的property。 第二步，刷新并获取内部的beanfactory。 第三步，对beanfactory进行准备工作。比如设置类加载器和后置处理器。配置不能自动装配的类型，注册默认的环境bean\n 第四步为contact的子类提供后置处理beanfactory的扩展能力。如果子类想在bean定义与加载完成后，开始初始化上下文之前。做一些特殊逻辑，可以复写这个方法。 第五步，执行contents中注册的beanfactory后置处理器，这里有两种后置处理器。一种是可以注册bean的后置处理器。另一种是针对beanfactory进行处理的后置处理器。执行的顺序是先按优先级执行。可注册bean的处理器。然后再按优先级执行，针对beanfactory的处理器。对spring boot来说。这一步。会进行注解beandefinition的解析。流程如右面的小框中所示，由configuration class post processor触发，并注册到并factory。 第六步。按优先级顺序。在beanfactory中注册bean后置处理器，bean后置处理器可以在bean的初始化前后执行处理。 第七步。初始化消息源，消息源用来支持消息的国际化。 第8步，初始化应用事件广播器，事件广播器。用来向application listener通知各种应用产生的事件。是一个标准的观察者模式。 第9步,是留给子类的扩展步骤，用来让特定的context子类来初始化其他的bean。 第10步,把实现了application listener的bean注册到事件广播器，并对广播器中早期没有广播的事件进行通知。 第11步,冻结所有的bean描述信息的修改，实力化非延迟加载的单例bean。 第12步，完成上下文的刷新工作。调用life cycle processor的on fresh方法，以及发布context refresh的even事件。 最后在finally中。执行第13步，重置公共的缓存。比如。Reflection duties中的缓存，annotation units中的缓存等。  至此。Spring的contact的初始化就完成了 。由于篇幅和时间的关系。这里介绍了最主要的流程，建议课后阅读源码来复习这个知识点。来补全细节。\n面试中经常会问到bean的生命周期。我们先看绿色的部分，bean的创建过程，\n 首先调用bean的构造方法创建bean 然后通过反射调用set方法进行属性的依赖注入。 第三步，如果实现了beannameaware接口的话，会设置bean的name。 第4步，如果实现了beanfactoryaware接口，会把bean factory设置给bean。 第5步，如果实现了application context aware接口，会给bean设置application context。 第6步,如果实现了bean post processor接口。则执行前置的处理方法。 第7步,实现了initializingBean接口的话，会执行 after property side的方法。 第8步，执行自定义的init方法。 第9步,执行bean post processor接口的后置处理方法。这时就完成了bean的创建过程。  那么在bean使用完毕需要销毁的时候。会先执行DisposableBean接口的destroy方法，然后再执行自定义的destroy方法。这部分也建议你阅读原版来加深理解。\n这介绍对spring进行定制化功能扩展时可以选择的一些扩展点。beanFactorytPostprocessor，是beanfactory的后置处理器，支持在beandfactory标准初始化完成后，对beanfactory进行一些额外处理。我们在讲context初始化流程时介绍过，这时所有的bean的描述信息已经加载完毕，但是还没有进行bean的初始化。例如我前面提到的 Property place holder configure。就是在这个扩展点上对bean属性中的占位符进行替换的。\n第二个扩展点。是beandefinitionregistrypostprocessor。它扩展自beanFactoeyPostprocessor，在执行beanpost processor的功能前，提供了可以添加bean定义的能力。允许在初始化一般的bean前注册额外的bean。例如可以在这里根据bean的scope创建一个新的代理bean。第三个困难点是beanPostprocess，提供了在bean初始化的之前和之后插入自定义逻辑的能力，与beanfactory post process的区别，主要是处理对象不同，beanfactory post process是对beanfactory进行处理。beanpostprocessor时对bean进行处理。上面这三个扩展点，可以通过实现 order的或者 priority order的接口来指定执行顺序，实现priority order接口的processor，会先于实行order接口的执行。\n第4个扩展点，是application contacts aware可以获得application content以及其中的bean，但需要在代码中动态获取bean时，可以通过实现这个接口来实现。\n第5个扩展点，是 Initializingbean。可以在bean初始化完成，所有属性设置完成后执行特定的逻辑。例如对自动装配的属性进行验证等。第6个扩展点是disposabledbean，用于在bean销毁前执行特定的逻辑，例如做一些回收工作等。\n第7个扩展点是application listener用来监听string的标准事件，以及自定义的事件。\nspring boot 第一个是spring boot启动流程，首先要配置environment。然后准备contact上下文，包括执行application context的后置处理器，初始化initialize，通知listener处理contacts prepared和contacts loaded的事件。最后执行refresh contact。也就是我们前面介绍过的 abstract application context类的fresh方法。然后要知道spring boot中有两种上下文。一种是bootstrap，另一种是application。\nbootstrap是应用程序的副上下文，也就是说bootstrap会先于application加载。bootstrap主要用于从额外的资源来加载配置信息。还可以从本地外部配置文件中紧密属性，bootstrap里面的属性会优先加载，默认也不能被本地相同的配置覆盖。\n再来看右面 spring boot的注解，需要知道springBootApplication。包含了componentScan、EnableAutoConfiguration 、SpringBootConfiguration三个注解。而sSpringBootConfiguration注解里面包含了 configuration注解，也就是spring的自动配置功能、Conditional注解是控制自动配置的生效条件的注解。例如，Bean或class的存在或不存在时进行配置。当满足条件时进行配置等。\n最后，了解一下bootstrap的几个特色模块，Starter是spring提供的无缝集成功能的一种方式，使用某个功能时，开发者不需要关注各种依赖库的处理，不需要具体的配置信息，由bootstrap的自动配置进行bean的创建。\n例如。需要使用web功能时。只需要在依赖中引入springBoot-start-web即可。Accurate是用来对应用程序进行监控和管理。通过rest for API请求来监管审计收集应用的运行情况。devtools提供了一系列开发工具的支持，来提高开发效率。例如支持热部署能力等。cli就是命令行接口是一个命令行工具，支持使用grow way脚本，可以快速搭建spring原型项目。\nNetty 先看到左面，首先你要了解Netty的特点，Netty是一个高性能的异步事件驱动的l框架，他对消息的处理采用串型无锁化设计。提供了对TCP、UDP和文件传输的支持。\nNetty内置了多种encoder的decode的实现，来解决TCP粘包问题。Netty处理消息时，使用了池化的ByteBufs缓冲池，来提高性能。同时结合内存零copy机制，减少了对象的创建，降低了GC的压力。\n第二个，要掌握Netty中的一些对象概念。比如,将socket封装成channel对象，在channel读写消息时。使用chandler对消息进行处理。一组handle的顺序链接，组成了channel pipeline的责任链模式，一个channel产生的所有事件，交给一个单线程的eventLoop事件处理器来进行串行处理，而bootstrap对象的主要作用是配置整个Netty程序，串联起各个组件，是一个Netty应用的起点。\n第三个，要掌握Netty的线程模型，我会在稍后详解介绍Netty4的现场模型。右面第4点，要了解Netty的内存零copy技术，包括使用堆外内存，避免在socket的读写时，缓冲数据在对堆与对堆内进行频繁的复制，使用compositeByteBuf来减少对多个小的buffer合并时产生的内存复制。\n使用file region实现文件传输时的零copy等。\n第5个，要了解TCP协议下粘包与半包产生的原因。知道Netty提供的多个decoder是，用什么方式解决这个问题的？例如。FixedLengthframe decoder用来解决固定大小数据包的占包问题。Linebased frame decoder适合对文本进行按行分包，delimiterbased frame decoder，适合按特殊字符作为分包标记的场景。LengthFieldbasedframedecoder可以支持复杂的自定义协议分包等。\n最后一个要简单了解一下Netty3和Netty4的区别，其中最主要的就是两个版本的线程处理模型完全不同，Netty4的处理模型更加优雅。其他的以Netty4的特点介绍为主即可。\nNetty线程模型，采用服务端监听线程和IO线程分离的方式，看图的左面，boss线程负责监听事件，创建socket并绑定到work线程组。work线程组负责IO处理，线程组有eventloop，group实现。其中包含了多个eventloop事件处理器，每个eventloop包含一个处理线程，通常在NIO非阻塞模式下,Netty为每个channel分配一个event loop，并且它的整个生命周期中的事件都由这个eventLoop来处理。\n一个event loop可以绑定多个channel，我们再看图的右面，evenloop的处理模型。Netty4中，Channel的读写事件都是由work线程来处理的。请求处理中最主要的就是ChannelPipeline。其中包含了一组channel handle，这些handle组成了责任链模式，依次对Channel中的消息进行处理。一般接收消息时由Pipeline处理完成，会把消息提交到业务线程池进行处理。当业务线程处理完成时，会封装成task。提交回channel对应的eventloop写回返回值。\nRPC RPC是远程过程调用的简写，RPC与HTTP一样，都可以实现远程服务的调用，但是在使用方式上有很大的区别，RPC能够像使用本地方法一样调用远程的方法。我们看看RPC的交互流程，图中绿色的模块是RPC中最主要的三个角色，左面是client就是请求的发起方。也可以叫做consumer或者rubbe。右面的模块是server端，也就是服务的提供方，也叫做Provider，为了保持较高的性能，client端一般都是直接请求远端的server节点，因此 RPC框架需要一个自动的服务注册与发现能力。上方绿色的注册中心就是用来动态维护可用服务节点信息的模块。图中的箭头代表交互流程。当serve提供服务时，向注册中心注册服务信息，告诉注册中心可以提供哪些服务。同时与注册中心保持心跳，或者维持长连接，来维持服务的可能状态。具体的方式与注册中心的时间有关。例如。ZK使用长链接推送方式。而channel使用心跳方式。当client需要使用服务时，会先向注册中心订阅服务，获得可用的server节点，并保存在client的本地。当serve节点发生变更时，会通知client更新本地server节点信息，client按某种负载均衡策略，直接请求server端使用服务。\n这里要注意注册中心只参与服务节点的注册与变更通知，并不会参与到具体请求的处理当中。另外一般的RPC框架都提供了完整的服务治理能力。因此会额外的管理模块和信息采集模块来监控管理服务。如图中灰色的模块所示。\nDubbo是阿里开源的RPC框架，提供完善的服务治理能力，可以快速的为Java服务提供RPC能力，Dubbo提供了随机轮巡，最少调用优先等多种负载均衡策略，提供对ZK等多种注册中心的支持，能够自动完成服务的注册与发现，double提供可视化的管理后台，方便对服务状态进行监控和管理。Dubbo的数据通讯默认使用我们前面介绍的Netty框架来实现的，拥有非常不错的性能。\n第二个是微博开源的轻量级服务治理框架模板，Motan的特点是轻量级，提供强大灵活的扩展能力Motan提供了多语言支持。Motan通过a站的代理方式，实现了跨语言的service match支持，service match被誉为下一代的微服务。\nMotan Java版本的通信层也是通过Netty来实现的。基于TCP的私有协议进行通信。第三个是Google勘验的GRPC。GRPC默认使用product buff进行消息序列化。非常适合多语言服务之间进行交互。虽然GRPC本身支持的服务治理能力并不多，但提供了非常灵活的插件扩展能力，可以方便的实现自定义的服务治理功能。GRPC基于HTTP2协议，能够支持链接复用，并且提供了流式调用能力，也支持从服务端进行推送消息的能力。\nMybatis 下面我们来看orm框架Mybatis，首先要了解它的特点，可以和habinitate来对比进行理解。Mybatis的优点，第一个是原生sql，不像habinitate的hacker，需要额外的学习成本。第二个优点是sql语句与代码进行了解耦合，这个与habinitate是一致的。\n第三个优点是功能简单，学习成本比较低，使用的门槛也非常低，可以快速上手。最后一个优点是Mysql调优比较灵活，对比habinitated的sql语句是自动生成的，当有复杂语句需要进行优化时就比较难处理。Mybatis的缺点就是相比habinitate，这样的全自动orm框架不能自动生成sql语句，编写sql的工作量比较大，尤其是字段多，关联比较多的情况下，另一个缺点就是sql语句依赖于具体的数据库，导致数据库迁移性差。而habinitate则拥有良好的数据库可移植性。\n第二个知识点是缓存相关，Mybatis只提供两级缓存，Mybatis的一级缓存，存储作用域是session。会对同一个session中执行语句的结果进行缓存。来提高再次执行时的效率。Mybatis内部通过HashMap实现存储缓存，一级缓存默认开启的。Mybatis的二级缓存的作用域，是一个mapper的namespace，在同一个namespace中查询sql时，可以从缓存中获取数据。二级缓存能够跨sqlSession生效。并且可以自定义存储源，比如ehcache、redis 。 Mybatis是二级缓存，可以设置剔除策略，刷新间隔，缓存数量等参数来进行优化。\n第三个是使用相关的知识点，第一个小点，Mybatis提供井号加大括号，这样的变量占位符来支持sql的预编译，防止sql注入。第二个获取自增主键的ID，可以通过使用keyProperty属性和使用selectKey 标签两种方式来实现。\n\u0026lt;!--增加一个用户并返回主键id--\u0026gt; \u0026lt;insert id=\u0026quot;saveOne\u0026quot; parameterType=\u0026quot;com.buwei.entity.User\u0026quot; \u0026gt; INSERT into user(name, password) value(#{name},#{password}) \u0026lt;selectKey keyProperty=\u0026quot;id\u0026quot; order=\u0026quot;AFTER\u0026quot; resultType=\u0026quot;int\u0026quot;\u0026gt; select last_insert_id() \u0026lt;/selectKey\u0026gt; \u0026lt;/insert\u0026gt; \u0026lt;insert id=\u0026quot;saveOne\u0026quot; parameterType=\u0026quot;com.buwei.entity.User\u0026quot; useGeneratedKeys=\u0026quot;true\u0026quot; keyProperty=\u0026quot;id\u0026quot;\u0026gt; INSERT into user(name, password) value(#{name},#{password}) \u0026lt;/insert\u0026gt;  第三个小点要记住，动态最后常用的几个标签。例如for each。where、if 等。右边Mybatis的执行流程，咱们稍后再讲。\n第5个需要理解Mybatis主要对象有哪些？它们的作用是什么？例如，Sqlsessionfactory是用来创建Sqlsession的工厂类，一个Sqlsessionfactory对应配置文件中的一个环境，也就是一个数据库配置，对数据库的操作必须在Sqlession中进行。Sqlsession非线程安全，每一次操作完数据库后，做到调用close对其进行关闭。sqlsession通过内部的execute来执行增删改查操作。Statement handler用来处理sql语句的预编译，设置参数等。Primate handler用来设置预编译参数，Resultsethandler用来处理结果集。typehandler进行数据库类型和Java bean类型的互相映射。最后一个知识点需要了解Mybatis的插件机制。\n要知道插件机制是通过拦截器组成责任链，来对executor、 statementHandler、ParameterHandler、resultSetHandler这4个作用点进行定制化处理。另外可以了解一下，基于插件机制实现的pagehelper分页插件\n上一页我们提到了Mybatis的处理流程，在执行sql时，首先会从SqlsessionFactory中创建一个新的sqlsession，sql语句是通过sqlsession中的executor来执行的，executor根据sqlsession传递的参数，执行query方法，然后创建一个statement handle的对象。将必要的参数传递给statement handler。由statement handler来完成对数据库的查询。Statement handler将用primate handler的setprimate的方法，把用户传递的参数转换成 JDBCstatement所需要的参数，调用原生的jdbc来执行语句。\n最后有resultsethandler的handleresult et方法，对jdbc反回的resultset结果集转换成对象集，并逐级返回结果，完成一次sql语句执行。\n考察点\n 掌握Spring的IOC、AOP的概念与实现 掌握Spring的Contex创建流程和Bean的生命周期 了解Spring常用注解的作用与使用方式 了解SpringBoot的相关知识点 掌握Netty的线程处理模型 知道常用RPC框架的特点 了解Mybatis、Hibernate的实现原理  真题\n SSH和SSM框架组合的区别是什么? 能描述一下Spring Context初始化的整个流程吗? 简单介绍一下Bean的生命周期及作用域。 Spring配置中的placeholder占位符是如何替换的?有什么办法可以实现自定义的配置替换? SpringMVC的工作流程是怎样的? Spring如何解决循环依赖? Bean的构造方法、@PostConstruct注解、 InitializingBean、 init-method的执行顺序是怎样的?(就是题目中的顺序) 说说Netty中有哪些重要的对象,它们之间的关系是什么? RPC与HTTP的区别是什么,什么场景适合选用RPC ,什么场景适合使用HTTP ? RPC的交互流程是怎样的? 请介绍一下Mybatis的缓存机制。 Mybatis如何配置动态SQL ?有哪些动态SQL标签?  第一题除了说出ssh框架是struts spring habinitate。Ssm框架是指springmvc spring、mybatis。除了这个之外，还要重点说一下 springmvc和struts 的区别。以及mybatis和habinitate的区别。\n缓存 缓存是高并发场景下提高热点数据访问性能的一个有效手段。在开发项目时经常会使用。到我们先看缓存的类型，分为本地缓存，分布式缓存和多级缓存，本地缓存就是在进程的内存中进行缓存，比如我们的JVM堆中。最简单的我们可以用LRUmap来实现，也可以使用这样的工具来实现。本地缓存是内存访问。没有远程交互的开销，性能最好，但是受限于单机容量，一般缓存较小且无法扩展。分布式缓存可以很好地解决这个问题。分布式缓存一般都提供良好的水平扩展能力。对较大数据量的场景也能应付自如。缺点就是需要进行远程请求，性能不如本地缓存。为了平衡这种状况，实际业务中。一般采用多级缓存。本地缓存只保存访问频率最高的部分热点数据，其他的热点数据。放在分布式缓存中。\n第二个知识点是淘汰策略。不管是本地缓存还是分布式缓存,为了保证较高的性能，都使用内存来保存数据。由于成本和内存容量的限制，当存储的数据超过缓存容量时，需要对缓存的数据进行剔除。一般的剔除策略有fIfo就是先入先出，淘汰最早的数据，FRU最近最少使用的数据和LFU剔除最近使用频率最低的数据几种策略。\n第三个知识点是使用缓存时常见的一些问题，我在后面详细讲解。剩下两个知识点是最常使用的分布式缓存Memcache和Redis。注意后面我会把Memcache简称为MC。先来看MC有哪些特点，MC处理请求时使用多线程异步IO的方式，可以合理利用CPU多核的优势，性能非常优秀，MC功能简单，使用内存存储数据，只支持kv结构，不提供持久化和主从同步功能。Mc的内存结构以及钙化问题，我稍后详细讲解。Mc对缓存的数据可以设置失效期，过期后的数据会被清除，失效的策略采用延迟失效，就是当再次使用数据时检查是否失效，当容量存满时，会对缓存中的数据进行剔除，剔除时除了会对过期k进行清理，还会按LRU策略对数据进行剔除。另外还要记住几个使用MC的限制，k不能超过250个字节，value不能超过一兆字节，key的最大失效周期是30天。\n最后一个知识点redis，我会展开详细介绍。这里先简单说一下redis的特点，方便和MC比较，与MC不同的是 redis采用单线程模式处理请求，这样做的原因有两个，一个是因为采用非阻塞的异步事件处理 机制，另一个是缓存数据都是内存操作，IO时间不会太长，单线程可以避免线程上下文切换产生的代价。\nredis的另一个特点是支持久化。所以redis不仅可以用作缓存。也可以用作NOSQL数据库。相比MC， redis还有一个非常大的优势，就是除了KV之外，还支持多种数据格式。最后redis供主从同步机制以及class集群部署能力，能够提供高可用服务。\nMemcache 我们进入详解知识点，先来看看MC的内存结构，MC默认通过slap alligator来管理内存，slap机制主要是用来解决产生内存碎片的问题。\n看到图左面，MC会把内存分为许多个不同类型的slab，每 种类型slab用来保存不同大小的对象，每个slide由若干page组成，如图中浅绿色的模块，不同page的配置默认大小都是一样的，都是一兆，这也是默认MC存储对象不能超过一兆的原因。\n每个配置内又划分许多chunk，chunk就是实际用来保存对象的空间，就是图中橘红色的部分，不同类型的slap中的chunk大小是不同的。当保存一个对象时，MC会根据对象的大小来选择最合适的chunk来存储，减少空间浪费。Slap alligator创建slap时的参数有三个，分别是chunk大小的增长因子，chunk大小的初始值，以及page的大小。\n在运行时会根据要保存的对象大小来逐个创建slab。我们来考虑这样一个场景，使用MC来保存用户信息，假设单个对象大约是300字节，确实会产生大量384字节的大小的slab。运行一段时间后，用户信息增加了一个属性，单个对象大小变成了500字节，确实在保存对象需要使用768字节的slap，而MC中的容量大部分都创建了384字节的slap，所以768的非常少。\n这时虽然384的slave内存大量空闲，但是768sleep还是会根据lru算法。频繁的剔除缓存。导致MC的剔除率升高，命中率降低，这就是所谓的MC钙化问题，解决钙化问题，可以开启MC的auto move机制，每10秒调整slab，也可以分批重启MC缓存，不过要注意重启时要进行一定时间的预热，防止雪崩的问题。\n另外使用MC时，最好计算一下数据的预期平均长度，调整growth factor，以获得最恰当的设置，避免内存的大量浪费。\nRedis 第二个知识点，我们来看看radis，首先是register支持的多种数据结构，要了解最常用的5种数据结构及相关的命令，稍后我详细介绍一下radis是怎么实现这5种结构的。\n第二个点是radis提供的功能，bit map是支持按bit位来存储信息，可以用来实现htperLogLog，提供不精确的去重统计功能，比较适合用来做大规模数据去重的统计。例如统计uv只有special可以用来保存地理位置，并作位置距离计算，或者根据半径计算位置等，这三个其实也可以算作数据结构。\npub/sub是订阅发布功能，可以用作简单的消息队列。pipeline可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。另一种方式是使用脚本，radis支持提交lua脚本来执行一系列的功能。\n最后一个功能是事务，但radis提供的不是严格的事务，radis只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。第三个知识点是radis的持久化，radis提供了RDB和AOF两种持续化方式，RDB是把内存中的数据集以快照形式写入磁盘，实际操作是通过父进程执行的，采用二进制压缩存储，SOF是以文本日志的形式记录radis处理的每一个写入或者删除操作。RDB把整个radis的数据保存在单一文件中，比较适合用来做灾备。但缺点是快照保存完成之前如果宕机，这段时间的数据将会丢失。另外保存快照是可能导致服务短时间不可用，AOF对日志文件的写入操作使用追加模式，有灵活的同步策略，支持每秒同步，每次修改同步和不同步，缺点就是相同规模的数据集AOF要大于RDB，AOF在运行效率上往会慢于RDB。\n再来看图的右面。第4个知识点是Redis的高可用，Redis支持主从同步提供class的集群部署模式，通过sentinel的哨兵来监控Redis主服务器的状态。当主挂掉时，在从节点中根据一定策略选出新主，并调整其他从slave的新主，选主的策略简单的说有三个，slave部的priority设置的越低，优先级就越高。同等情况下，slave复制的数据越多，优先级就越高，相同的条件下，让ID越小就越容易被选中。在redis集群中，sentinel也会进行多实例部署，sentinel之间通过rough的协议来保证自身的高可用，redis class的使用分片机制，在内部分为16384个slot，也就是2的14次方，分布在所有的master节点上，每个master节点负责一部分的slot，数据操作时，按k做crc16来计算，在哪个slot上，由哪个master进行处理，数据的冗余是通过slave节点来保障的。\n第5个redis key可以设置过期时间，过期后redis 采用主动和被动结合的失效机制，一个是和MC一样，在访问时触发被动删除，另一种是定期的主动删除，\n第6个redis 提供了6种淘汰策略，分别是只针对设置了失效期的k做lru最小生存时间和随机剔除。\n另一类是针对所有的k做lru随机剔除，当然也可以设置不剔除，容量满时再存储对象会返回异常，但是以存储的key还是可以继续读取。最后一个可以了解一下redis 4.0和5.0的新特性，例如5.0的stream，是一个支持多波，也就是一写多读的消息队列，4.0的模块机制等。\nredis 内部使用字典来存储不同类型的数据。如图中的dictht，字典由1组dictentry组成，其中包括了指向k和value的指针，以及指向下一个dictentry的安全的指针。在redis中所有的对象就被封装成了redis object。如图中浅绿色的模块，redis object包括了对象的类型，就是redis中支持的5种类型。另外还包括了具体对象的存储方式，比如最右边虚线标出的模块内的几种类型，下面我结合着类型来介绍具体的数据存储方式。String类型是redis中最常使用的类型，内部的实现是通过sds来实现的，就是 simple dynamic strain的缩写。Sds类似于Java中的arraylist，可以通过预分配冗余空间的方式，来减小内存的频繁分配。对于list类型有这个ziplist压缩列表和linklist的双链表实现，ziplist是存储在一段连续的内存上，存储效率高，但是它不利于修改操作，适用于数据较少的情况。\nLinkedlist在插入节点上复杂度很低，但它的内存开销很大，每个节点的地址不连续，容易产生内存碎片。此外这3.2版本后，增加了quick list，quicklist结合了两者的优点，quicklist本身是一个双向无关链表，它的每一个节点都是一个ziplist，哈希类型在redis中有ziplist和hashtable两种实现。\n在hash表中所有的key和value字符串长度都小于64字节，且键值对的数量小于512个时，使用压缩表来节省空间，超过时转为使用hashtable\nset类型的内部实现，可以是intset或者是hashtable，当集合中元素小于512，且所有的数据都是数值类型时，才会使用intset，否则会使用hashtable。最后sortedset是有序集合，有序集合的实现，可以是zip list，或者是skiplist的跳表，有序集合的编码转换条件与hash和list有些不同，当有序集合中元素数量小于128个时，并且所有元素长度都小于64字节时，会使用ziplist，否则会转换成skip list跳表。提示一下，redis的内存分配是使用ge molecule进行分配的，ge molecule将内存空间划分为小大巨大三个范围，并在范围内划分了许多小的内存块。当存储数据时，选择大小最合适的内存块进行分配，有利于减小内存碎片。\n这里我对使用缓存时常遇到的几个问题整理出一个表格，第一个问题是缓存更新方式，这是决定在使用缓存时就该考虑的问题。缓存的数据在数据源发生变更时，需要对缓存进行更新，数据源可能是db，也可能是远程服务，更新的方式可以是主动更新。\n例如数据源是db时，可以在更新完db后直接更新缓存，当数据源不是db时，而是其他远程服务，可能无法及时主动的感知数据变更。这种情况下，一般会选择对缓存数据设置失效期，也就是数据不一致的最大容忍时间。这种场景下可以选择失效更新，key不存在或者失效时，先请求数据源获取最新的数据，然后再次缓存并更新时效期。但这样做有个问题，如果依赖的远程服务在更新时出现异常，则会导致数据不可用，改进的办法是异步更新。就是当失效时先不清除数据，继续使用旧的数据，然后由异步的线程去执行更新任务，这样就避免了失效瞬间的空窗期。另外还有一种纯异步更新方式，定时对数据进行分批更新，实际使用时可以根据业务场景选择具体的更新方式。\n第二个问题是数据不一致的问题，可以说只要使用缓存就要考虑如何面对这个问题，缓存不一致产生的原因，一般是主动更新失败。例如更新db后更新redis时，因为网络原因请求超时或者异步更新失败导致。解决的办法，如果服务对耗时不是特别敏感，可以增加重试，如果服务对耗时敏感，可以通过异步补偿任务来处理失败的更新，或者短期的数据不一致，不会影响业务，那么只要下次更新时可以成功就能保证最终一致性就可以了。\n第三个问题是缓存穿透，产生这个问题的原因，可能是外部的恶意攻击。例如对用户信息进行了缓存，但恶意攻击者使用不存在的用户ID，频繁请求接口，导致查询缓存不命中，然后穿透db查询依然不命中，这是会有大量的请求，穿透缓存访问到db解决的办法。一是对不存在的用户在缓存中保存一个空对象进行标记，防止相同ID再次访问db。不过有时这个方法并不能很好的解决问题，可能会导致缓存中存储大量的无用数据。另一个方法就是使用布隆过滤器，bloomfilter的特点是存在性检测，如果布bloomfilter中不存在，那么数据一定不存在。如果bloomfilter中存在，实际数据可能存在，也有可能不存在，这非常适合解决这类问题。\n第4个问题是缓存击穿，就是某个热点数据失效时，大量针对这个数据的请求，会穿透到数据源，为了解决这个问题，可以使用互斥锁更新，保证同一个进程中针对同一个数据，不会并发请求db减小db的压力。另一个方法就是使用随机配备方式，失效时随机sleep一段时间。再次查询，如果失败，再执行更新，还有一个方法是针对多个热点可以同时失效的问题，可以在缓存时使用固定时间，加上一个很小的随机数，避免大量的热点k同一时刻失效。\n第5个问题是缓存的雪崩，产生的原因是缓存挂掉了，这时所有的请求都会穿透到db，解决的办法，一个是使用快速失败的熔断策略，减少db的压力，另一个就是使用主从模式和集群模式，来尽可能保证缓存服务的高可用。实际场景中通常会将这两种方式结合来使用。\n考察点\n 了解缓存的使用场景,不同类型缓存的使用方式 掌握MC和Redis的常用命令 了解MC和Redis在内存中的存储结构 了解MC和Redis的数据失效方式和剔除策略 了解Redis的持久化、主从同步与cluster部署的原理  缓存的使用场景，不同类型的缓存的使用方式，例如对db热点数据进行缓存，可以减少db压力，对依赖的服务进行缓存，可以提高并发访问性能。例如单纯的kv缓存场景可以使用MC，而需要缓存list set等特殊数据结构时，可以使用redis。像缓存一个数据，最近播放的视频列表这种场景，可以使用redis的list来保存，需要计算排行榜数据时，可以使用redis的gset结构来保存。\n其次，要了解MC和redis的常用命令，例如原子增减，对不同数据结构进行操作的命令等。第三个要了解MC和redis在内存中的存储结构，这对评估使用容量会很有帮助。第4个，了解MC和redis的数据失效方式和剔除策略，比如主动出发的定期删除和被动触发的延期删除。\n最后要理解redis的持久化，主从同步和cluster部署的原理，比如rdb和aof的实现方式与区别。\n第一是要结合实际应用场景来介绍缓存的使用，例如调用后端服务接口获取信息时，可以使用本地加远程的多级缓存。对于动态排行榜类的场景，可以考虑使用redis的sortedset来实现等。\n比如redis是单线程处理，应尽量避免耗时较高的单客请求任务，防止相互影响。redis服务应避免和其他CPU密集型的进程，部署在同一台机器或者进入swap内存交换，防止redis的缓存数据交换到硬盘上，影响性能。再比如前面提到的MC钙化问题等。\n第四，要了解redis的典型应用场景。例如 redis来实现分布式锁，使用bit map来实现blue filter，使用hyperlog log来进行uv统计等。最后要知道redis4.05.0中的新特性，例如支持多波的可持续化消息队列stream，通过model系统来进行定制功能扩展等。\n真题\n Redis和Memcache有什么区别?该如何选用? 你用到过哪些Redis的数据结构?用在什么场景下? Redis有哪些持久化方式，区别是什么? Redis的过期机制是怎样的? Redis有哪些淘汰策略? 如何保证Redis的高并发和高可用? 如何使用Redis实现延时队列?如何使用Redis实现分布式锁?  第5题，可以从主从读写分离，多存库，多端口实例，以及claster集群部署，来支持水平扩展等几方面来回答。高可用可以回答，用sentinel来保证主挂角时重新选主，并完成从库的变更。\n第6题可以使用ready的shortage site来实现延迟队列，使用时间戳做score，消费方使用z range by score，来获取指定延迟时间之前的数据。简单场景下，分布式锁可以使用set n x事件，使用set n x设置k如果返回一表示设置成功，即获取锁成功，如果返回零则获取锁失败。\nsetnx需要同时使用px参数，设置超时间，防止获取锁的实力，宕机后产生死锁，严格场景下可以考虑使用readlock方案，但实现比较复杂。\n消息队列与数据库 提到的队列就是指消息队列。队列可以对应用进行解耦合，应用之间不用直接调用，可以通过队列来传递消息完成通信，队列也可以用来执行异步任务，任务提交方无需等待结果。队列的另一个作用是削峰填谷，在突发流量时可以通过队列做缓冲，不会对后端服务产生较大的压力。当峰值过去时，可以逐渐消费堆积的数据，来填平流量的低谷。消息队列一般还提供了一写多读的能力，可以用来做消息的广播与多播。关于队列你还需要知道两个主要的消息协议。JMS是Java的消息服务，规定了Java使用消息服务的API，在前面spring的j介绍中，我提到过 spring提供了支持JMS组件，amqp是高级消息队列协议，是应用层协议的一个开放标准。\nAmqp不从API层进行限定，而是直接定义网络交换的数据格式。因此，支持跨语言的能力。例如RabbitMQ就使用了AMQP实现。我们再来对比几个常用的消息队列，首先是rabbitmq使用Erlang开发的开源消息队列，中国Erlang的act模型，实现了数据的稳定可靠传输，支持产品amqp、 smtp等多种协议，因此也比较重量级。由于采用break代理架构发送给客户端时，先在中心队列进行排队，rabbitMQ的单机吞吐量在万级不算很高，activemq，可以部署于代理模式和P2P模式。支持多种协议，单机存储量在万级，但activemq不够轻巧，对于队列较多的情况支持不是很好，并且有较低概率丢失消息。\n第三个RocketMQ是阿里开源的消息中间件，单机能够支持10万级的存储量，使用Java开发，具有高吞吐量高可用性的特点，适合在大规模分布式系统中应用，最后是kafka，由Scala开发的高性能跨语言分布式消息队列，单机吞吐量可以达到10万级，消息延迟在毫秒级，kafka 是完全的分布式系统。\nBroker.Producer、consumer都是原生自动支持分布式，依赖于组zookeeper做分布式协调，kafka支持一写多读，消息可以被多个客户端消费，消息有可能会重复，但是不会丢失。后面的讲解知识点，我会对kafka的架构进行介绍。\n左下方第二大知识点是常用的数据库中间件，数据库中间件一般提供了读写分离，数据库水平扩展的能力，首先是sharding-sphere，是一个开源的分布式数据库中间件解决方案，由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar，这几个独立的产品组成，适用不同的使用场景，这几个产品都提供标准化的数据分片，读写分离，柔性事务和数据治理功能，可适用于Java重构，异构语言、容器、云原生。等多种多样的应用场景。\n目前sharding-sphere已经进入apache，发展速度非常的快，可以重点关注。第二个中间件是MyCat，也提供了分库分表能力，MyCat基于proxy代理模式，后端可以支持Mysql、oracle、db2等不同的数据库实现。不过代理方式对性能会有一定影响。其他还有些数据库中间件，例如vtc等，这个使用不算广泛了解即可。\n我们再来看右面，主要是数据库相关的知识点，首先需要知道不同类型的数据库，常用的关系型数据库主要是oracle和MySql。\nOracle功能强大，主要缺点就是贵。MySQL是互联网行业中最流行的数据库，这不仅是因为MySQL的免费，可以说关系数据库场景中你需要用到的功能，MySQL都能很好的满足。后面的讲解部分，我会详细介绍MySQL的一些知识点Mqriadb是MySQL的分支，由开源社区维护，MariaDB虽然被看作MySQL的代替品。但是它在功能扩展。存储引擎上都有非常好的改进，后续可以继续关注。PostgreSQL也叫PGSQL。PGSQL类似于oracle的多进程模型，可以支持高并发的应用场景，几乎支持所有的oracle标准，知识类型相当丰富，PG更加适合严格的企业应用场景。而MySql更适合业务逻辑相对简单，数据可靠性要求比较低的互联网场景。\n第二类是NOSQL。就是 Not only sql。一般指非关系型数据库。比如redis，提供了持久化的能力，支持多种数据类型。redis适用于数据变化快，写数据大小可预测的场景，mongoDB是一个基于分布式文件存储的数据库，将数据存储为一个文档，数据结构由键值对组成。\nmongoDB比较适合表结构不明确。写数据结构可能不断发生变化的场景，不适合有事务或者复杂查询的场景。hbase是建立在hdfs也就是Hadoop文件系统之上的分布式面向列的数据库，类似于Google的大表设计，hbase可以提供快速随机访问海量结构化数据，在表中它有行排序，一个表有多个列族，以及每个列族都可以有任意数量的列。hbase依赖于hdfs可以实现海量数据的可靠存储，适用于数据量大，写多读少，不需要复杂查询的场景。\ncassandra是一个高可靠的大规模分布式存储系统，支持分布式的结构化kv存储，以高可用为主要目标。适合写多的场景，适合做一些简单的查询。不适合用来做数据分析统计。pika是一个可持久化的大容量类redis的存储服务，兼容redis的5种主要数据结构的大部分命令。pika使用磁盘存储，主要解决redis大容量存储的成本问题。\n第三类new sql数据库也越来越被大家关注。New sql是指新一代的关系型数据库。比较典型的有TiDB。TiDB是开源分布式关系数据库，几乎完全兼容Mysql，能够支持水平弹性扩展。S i d事务、标准sql，Mysql语法和Mysql协议，具有数据强一致性的高可用性。既适合在线事务处理，也是和在线分析处理。另外一个比较著名的new sql是蚂蚁金服的OceanBase，OceanBase是可以满足金融级的可靠性和数据一致性要求的数据库系统。当你需要使用事务，并且数据量比较大，就比较适合使用ob。不过目前ob已经商业化，不再开源。\n看数据库的范式，目前关系数据库一共有6种范式，第一范式第二范式第三范式、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式），范式级别越高，对数据表的要求越严格，要求最低的第一范式只要求表中的字段不可再拆分。\n第二范式是在第一范式的基础上。要求每条记录有主键唯一区分。记录中的所有属性都依赖于主键。第三范式是在第二范式的基础上。要求所有的属性必须直接依赖于主键。不允许间接依赖，一般来说数据库只需要满足第三范式就可以了。\nkafka 我们来学习kafka的架构，先结合这张架构图来了解一下kafka中的几个概念。首先kafka消息队列由三个角色组成，左面的是消息生产方producer，中间是kafka集群。kafka集群由多台kafka server组成。每个server称为一个broker，也就是消息代理。右面是消息的消费方consumer。传感中消息是按照topic进行划分的，一个topic就是一个q。我们在实际应用中，不同业务数据就可以设置为不同的topic。\n一个topic可以有多个消费方，当生产方在某个topic发出一条消息后。所有订阅了这个 topic的消费方都可以收到这条消息。为了提高并行能力，kafka为每个topic维护了多个partition分区。每个分区可以看做一份追加类型的日志，每个分区中的消息，保证ID唯一且有序，新消息不断追加在尾部。\nPartition实际存储数据时，会按照大小进行分段，来保证总是对较小的文件进行写操作，提高性能方面管理。看到图中间的部分，partition分布于多个broker上。图中绿色的模块表示。Topic1，被分成了三个partition。每个partition，会被复制多份，存在于不同的broker上，如图中红色的模块，这样可以保证主分区出现问题时进行融灾。每个broker可以保存多个topic的多个partition，kafka只保证一个分区内的消息有序。不能保证一个topic中不同的分区之间消息有序。为了保证较高的处理效率，所有的消息读写都是在主partition上进行的。其他的副本分区，主分区复制数据，kafka会在zookeeper上针对每个topic维护一个称为 isr，也就是以同步副本集，如果某个主分区不可用了。kafka就会从ISR集合中选择一个副本作为新的分区。\nkafka对消费方进行分组管理，来支持消息的一写多读。我们来看图中的例子，这个 topic分为4个partition，就是图中绿色的p1到p4，上部的生产方根据规则选择一个partition进行写入，默认规则是轮巡策略，也可以由生产方指定partition，或者指定key来根据hash值选择partition。消息的发送有三种方式，同步、异步、发送并忘记。同步模式下，后台线程发送消息时，同步获取结果，这也是默认的模式。异步模式，允许生产者批量发送数据。可以极大的提高性能，但是会增加丢失数据的风险。、发送并忘记模式只发送消息。不需要返回发送结果，消息可靠性最低，但是低延迟高吞吐，适合用于对可靠性要求不高的场景。再来看消息的消费，consumer按照group来消费消息。Topic中，每一条消息可以被多个consumer group消费。如图中的group a和group b。kafka确保每个partition在一个group中只能有一个consumer消费。kafka通过group coordinator来管理consumer实力，负责消费哪个partition？默认支持range和轮巡分配。kafka在zk中保存了每个topic，每个partition在不同group的消费偏移量offset，通过更新偏移量，保证每条消息都被消费。\n这里要注意用多线程来读取消息时，一个线程相当于一个很深的consumer实例，当consumer的数量大于分期数量时，有的comsumer线程会读取不到数据。\n数据库事务 第二个讲解知识点是数据库事务，数据库的特性是面试时考察频率非常高的题目。我们先看看数据库的acId4大特性\n第一个原则性是指事务由原子的操作序列组成。所有的操作要么全部成功，要么全部失败回滚。\n第二个事务的一致性是指事务的执行，不能破坏数据库数据的完整性和一致性。一个事物在执行前和执行之后，数据库都必须处于一致性状态。比如在做多表操作时。多个表，要么都是事务后的新值。要么都是事务前的旧值。\n第三个事务的隔离性是指多个用户并发访问数据库时。数据库为每个用户执行的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离，事务的隔离级别我们稍后介绍。\n第4个事物的持久性。是指一个事务一旦提交并执行成功，那么对数据库中数据的改变是永久性的。即便是在数据库系统遇到故障的情况下，也不会丢失提交事务的操作。\n在介绍数据库的隔离级别之前，我们先看看在没有隔离性的情况下，数据库会出现哪些并发问题？看到图的左面，首先可能会出现脏读，脏读是指一个事务处理过程中读取了另一个未提交的事务中的数据。例如账户a转账给b500元，b余额增加后，但事务还没完成提交。此时如果另外的请求中，获取到的是b增加后的余额，这就发生了脏读。因为事务如果失败回滚时，b的余额就不应该增加。\n第二个并发问题是不可重复读，不可重复读是指对于数据库中的某个数据，一个事务范围内多次查询，返回了不同的数据值。这是由于多次查询之间，有其他事物修改的数据。并进行了提交。\n第三个是幻读，是指一个事务中执行两次完全相同的查询，第二次查询所返回的结果集跟第一次查询的不同，与不可重复读的区别在于不可重复读是对同一条记录两次读取的值不同，而幻读是记录的增加或者删除，导致两次相同条件获取的结果记录数不同。\n事务的4种隔离级别，可以解决这几种并发问题。我们看到这一页的右面由上到下，4种隔离级别由低到高，第一个隔离级别是读未提交。也就是可以读取到其他事务未提交的内容。这是最低的隔离级别。在这个隔离级别下，前面提到三种并发问题，都可能会发生。第二个级别是读已提交。就是只能读取到其他事务已提交的数据，这个隔离级别可以解决脏读问题。第三个是可重复读，可以保证整个事务过程中对数据的多次读取结果是相同的，这个级别可以解决脏读和不可重复读的问题。MySql默认的隔离级别就是可重复读。最后一个是串行化，这是最高的隔离级别，所有事务操作都依次顺序执行。这个级别会导致并发度下降，性能最差。不过这个级别可以解决前面提到的所有并发问题。\n接下来我们看一下事务的分类，第一个是扁平化事务，扁平事务中，所有的操作都在同一层次，这也是我们平时使用最多的一种事务。它的主要限制是不能提交或者回滚事务的某一部分，要么都成功，要么都回滚。\n为了解决第一种事务的弊端，就有了第二种带保存点的扁平事务。他允许事务在执行过程中回滚到较早的状态，而不是全部回滚。通过在事务中插入保存点，当操作失败后，可以选择回滚到最近的保存点处。\n第三个事务是链事物。可以看作第二种事务的变种。他在事务提交时，会将必要的上下文隐式传递给下一个事务，当事务失败时，可以回滚到最近的事务。不过链事务只能回滚到最近的保存点。而在保存点的扁平化事务，是可以回滚到任意一个保存点。\n第4种事务是嵌套事务，由顶层事务和子事务构成，类似于树的结构，一般顶层事务负责逻辑处理，子事务负责具体的工作，此事务可以提交，但真正的提交要等到父事务的提交。如果上层事务回滚，那么所有的子事务都会回滚。\n最后一种是分布式事务，是指在分布式环境中的扁平化事务。常用的分布式事务解决方案如图右面所示。第一个解决方案是XA协议，是保证强一致性的刚性事务，实现方式有两段式提交和三段式提交。两段式提交需要一个事务协调者。来保证所有的事务参与者都完成了第一阶段的准备工作。如果协调者收到了所有参与者都准备好的消息。就会通知所有的事务执行第二阶段提交，一般场景下两段式提交，已经能够很好的解决分布式事务了。然而两阶段在即使只有一个进程发生故障时，也会导致整个系统存在较长时间的阻塞。三段式提交，通过增加。Pre commit阶段来减少前面提到的系统阻塞时间。三段式提交很少在实际中使用，简单了解就可以了。\n第二个分布式解决方案是tcc是满足最终一致性的柔性事务方案，tcc采用补偿机制。核心的思想是对每一个操作都要注册对应的确认和补偿操作。它分为三个阶段，try阶段，主要对业务系统进行检测及资源预留，confirm阶段，对业务系统进行确认提交。Cancel阶段是在业务执行错误执行回滚，释放预留的资源。\n第三种方案是消息一致性方案，基本思路是将本地操作和发送消息封装在一个事务中。保证本地的操作和消息发送，要么都成功，要么都失败。下游应用订阅消息，收到消息后执行对应的操作。最后可以了解一下阿里云中的全局事务服务，gts对应的开源版本是fescar，fescar基于两段式提交进行改良，剥离了分布式事务方案，对数据库在协议支持上的要求。使用fescar的前提，是分支事务中涉及的资源，必须是支持acId事务的关系性数据库，分支的提交和回滚机制，都依赖于本地事务来保障。fescar实现目前还存在一些局限，比如事务隔离级别，最高支持到读已提交级别。\nMysql 第三个知识点，我们来学习互联网行业中使用最为广泛的关系性数据库Mysql\n第二个知识点。要知道Mysql都提供哪些基本的数据类型。不同数据类型占用的空间大小，\n第三个知识点是Mysql中的主要存储引擎，MyIASM是Mysql官方提供的存储引擎，其特点是支持全文检索，查询效率比较高，缺点是不支持事务，使用表级锁。innodb在5.5版本后成为Mysql中的默认存储引擎。特点是支持aCAD事务，支持外建，支持行级锁提高的并发效率。TokuDB是第三方开发的开源存储引擎，有非常快的写速度，支持数据的压缩存储。可以在线添加索引，而不影响读写操作。但是因为压缩的原因，TokuDB非常适合访问频率不高的数据，或者历史数据归档，不适合大量读取的场景。\n第4个知识点是Mysql中的锁。刚才也提到了MyIASM使用表级锁，innoDB使用行级锁。\n表锁开销小加锁快，不会出现死锁，但锁的力度比较大，发生锁冲突的概率高，并发访问效率比较低；行级锁开销大，加锁慢有可能会出现死锁，不会因为锁定力度小，发生锁冲突的概率比较低，并发访问效率比较高；共享锁也就是读锁，其他事务可以读，但不能写。Mysql可以通过log in share mode，语句来显示的使用共享锁；排他锁就是写锁，其他事务不能读取也不能写。对于update、Delete、insert语句 innoDB会自动给涉及的数据集加排他锁，或者使用select for update。使用显式的排他锁。第5个知识点索引，我们稍后讲解。\n第6个知识点。是Mysql的存储过程与函数，存储过程与函数，都可以避免开发人员重复编写相同的sql语句，并且存储过程和函数都是在Mysql服务器中运行的，可以减少客户端与服务端的数据传输，存储过程实现了更复杂的功能。而函数一般用来实现针对性比较强的功能。比如按特殊策略来求和。存储过程。可以执行，包括修改表等一系列数据库操作，而用户定义函数不能用于执行修改全局数据库状态的操作。\n存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句中的一个部分来调用。Sql语句中不能使用存储过程。但可以使用函数。不过存储过程一般与数据库的实现绑定。使用存储过程，会降低程序的可移植性，应谨慎使用。\n第7个知识点。可以去了解一下Mysql8.0的一些新特性。例如默认字符集改为了utf-8，增加了隐式索引功能，隐藏后的索引不会被查询优化器使用。可以使用这个特性用于性能调试。支持了通用表表达式，使复杂查询中的嵌入语句表达更清晰，新增了窗口函数的概念，它可以用来实现新的查询方式，窗口函数。与some count等级和函数类似但不会将多行查询结果合并，而是将结果放于多行中，即窗口函数不需要group by。最后一个知识点，Mysql调优，稍后展开讲解。\n先来看索引，索引可以大幅增加数据库的查询性能，在实际业务场景中或多或少都会使用到，但索引也是有代价的。\n首先需要额外的磁盘空间来保存索引。其次，对于插入、更新、删除等操作，由于更新索引会增加额外的开销，因此索引比较适合用在读多写少的场景。我们先学习Mysql的索引类型。看得出左面的模块。Mysql的索引按类型有唯一索引。就是索引列中的值必须是唯一的，但是允许出现空值，这种索引一般用来保证数据的唯一性。比如保存账户信息的表。每个账户的ID必须要保证唯一，如果重复插入相同的账户ID，这个时候Mysql会返回异常。第二种主键索引是一种特殊的唯一索引，但它不允许出现空值。第三种是普通索引，与唯一索引不同，它允许索引列中存在相同的值。例如学生的成绩表。各个学科的分数是允许重复的，就可以使用普通索引。第4种是联合索引，就是由多个列共同组成的索引。一个表中含有多个单列的索引，并不是联合索引，联合索引是对多个列字段按顺序共同组成一个索引。应用联合索引时需要注意最左原则。就是 While查询条件中的字段必须与索引字段从左到右进行匹配。比如一个用户信息表用姓名和年龄组成了联合索引。如果查询条件是姓名等于张三。那么满足最左原则，如果查询条件是年龄大于20。由于索引中最左的字段是姓名，不是年龄。所以就不能使用这个索引。\n最后一个类型是全文索引，前面提到了MyIASM引擎中实现了这个索引。在5.6版本后，innodb引擎也支持了全文索引，并且在5.7.6版本后支持了中文索引。全文索引只能在char、varchar、text 类型上使用，底层使用的是倒排索引实现。要注意对于大数据量的表生成全文索引会非常消耗时间，也非常消耗磁盘空间。再看到图右面的模块，Mysql的索引，按时间来分，有我们前面学习过的B+树，B+树比较适合用做大于或者小于这样的范围查询，是Mysql中最常使用的一种索引实现。\nR-Tree是一种用于处理多维数据的数据结构。可以对地理数据进行空间索引，不过实际业务场景中使用的比较少.hash是使用散列表来对数据进行索引，hash是不需要像B-Tree那样需要查询多次才能定位到记录，因此hash索引的效率比b_tree高。但是不支持范围查找和排序等功能，实际使用的也比较少。最后fullText就是我们前面提到的全文索引。是一种记录关键字与对于文档关系的一种倒排索引。\nMySQL的调优，也是研发人员需要掌握的一项技能。一般MySQL调优有图中的4个维度，第一个是针对数据库设计、表结构设计、以及索引设置维度进行优化。第二个是对我们业务中使用的sql语句进行优化，那例如调整where查询条件。第三个维度是对MySQL服务的配置进行优化，例如对连接数的管理，对索引缓存、查询缓存、排序缓存等各种缓存大小进行优化。第4个维度是对硬件设备和操作系统设置进行优化。例如调整操作系统参数禁用swap、增加内存、升级固态硬盘等。这4个维度从优化成本的角度讲。从左到右优化成本逐渐升高。从优化效果角度来看，从右到左优化效果更高。对于研发人员来说，前两个维度与业务息相关，因此需要重点掌握。后两个维度更适合DBA进行深入学习。简单了解就好。\n我们重点来看刚才说的前两个维度，先看到左边的模块，关于表结构和索引的优化，应掌握如下原则。第一个要在设计表结构时考虑数据库的水平和垂直扩展能力，提前规划好未来一年的数据量和读写量的增长，规划好分库分表方案。比如设计用户信息表时，预计一年后用户数据10亿条。写QPS(每秒Query量)约5000，读QPS 3万。可以设计按uId维度进行散列。分为4个库，每个库32张表。这样可以保证单表数据量控制在千万级别。第二个，要为字段选择合适的数据类型。在保留扩展能力的前提下，优先选用较小的数据结构。 例如保持年龄的字段，要使用talent。而不要使用int。第三个可以将字段多的表分解成多个表。必要时增加中间表进行关联。假如一张表有四五十个字段，显然不是一个好的设计。第4个一般来说，我们设计关系数据库时，需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表，而在查询时就需要对多张表进行关联查询，有时为了提高查询效率，会降低范式要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式时一定要适度。第5个要善用索引，比如为经常作为查询条件的字段创建索引，创建联合索引时要根据最左原则。考虑所有的复用能力，不要重复创建索引，要为保证数据不能重复的字段创建唯一索引等。不过要注意索引，对插入更新等写操作是有代价的，不要滥用索引。比如像性别这样唯一性很差的字段。就不适合建立索引。第6个，列字段，尽量设置not null，MySQL难以对使用null的列进行查询优化，允许null会使索引，索引统计和值更加复杂，允许null值得列需要更多的存储空间，还需要MySQL内部进行特殊处理。\n再看到右面的模块，对sql语句进行优化的原则。第一个。要找到最需要优化的sql语句，要么是使用频率最高的。要么是优化后。提高最明显的语句，可以通过查询MySQL的慢查询日志，来发现需要进行优化的sql语句。第二个要学会利用MySQL提供的分析工具，例如使用explain来分析语句的执行计划。看看是否使用了索引，使用了哪个索引？扫描了多少记录，是否使用了文件排序等，或者使用profile命令，来分析某个语句执行过程中的各分部耗时。第三个，要注意使用查询语句时。要避免使用select *，而应当指定需要获取的字段。原因，一是可以避免查询出不需要使用的字段。二是可以避免查询列字段的原信息。第4个是尽量使用Preparestatement。一是性能更好，另一个是可以防止sql注入。第5个是尽量使用索引扫描来进行排序。也就是尽量在有索引的字段上进行排序操作。\n考察点\n 了解消息队列、数据库的基本原理和常用队列、数据库的特点。 了解Kafka的架构和消息处理流程 理解数据库事务的ACID特性和隔离级别 掌握常用的MySQL语句,和常用函数 了解MySQL数据库不同引|擎的特点及不同类型的索弓|实现  比如消息队列适用于异步处理和削峰填谷的场景。kfaka在提供高可用性的前提下，实现了零消息丢失的高性能分布式队列服务。MySql提供了多种引擎，可以支持事务型与非事务型的关系对象库服务等。\n 了解新特性 知道数据库表设计原则、有设计经验 有过数据库调优经验 消息队列使用经验,不同场景下的取舍  第三，你最好有过数据库的调优经验。例如。明建立了索引语句，但是查询效率还很慢。后来通过一个explain分析发现表中有多个索引。\n真题\n 使用过消息队列吗?在什么场景使用的?用来解决什么问题? 使用队列时如何保证可靠性? MQ有可能发生重复消费吗,如何解决? 在数据库中查询语句速度很慢，如何优化? 数据库事务有哪些特性?事务的隔离级别有哪几种? 如何对SQL语句进行优化?  架构的演讲之路与前沿技术 首先第一个知识点，我们以演进的方式来了解不同的系统架构，最简单的系统架构是单体服务，一个项目中的多个服务，混合部署在一个进程内。服务之间的交互都是通过进程内调用完成的。就像图中的service之间红色的箭头所示，这样做的好处是可以快速开发部署服务，服务之间的调用的性能也是最好的。当然这种架构缺点也非常多，比如随着业务的增长，项目越来越臃肿。服务之间，因为jar引用导致频繁的依赖冲突。服务资源变更困难，因为一个服务可能会被多个不同的业务引用，升级资源需要多个业方同时升级，同时因为不同业务方都可以直连服务的数据资源，这个架构也存在明显的数据安全风险。另外还有修改代码后回归困难，架构难以调整等。\n以上所有的问题都是因为服务耦合在一起导致的。在服务规模不大的情况下，比较适合采用单体架构，方便快速迭代。但是当服务规模变大时，单体架构就不是一个好的选择。当服务的规模变大时，为了解决服务耦合的问题，出现了sOA就是面向服务架构，\n它的起源是为了解决企业应用问题，随着不断的演进，发展到目前业界普遍采用的微服务架构，微服务架构的思想，就是让服务尽可能做到高内聚低耦合，不同的服务单独开发，单独测试单独部署。服务之间通过RPC或者是HTTP进行远程交互，如图中蓝色加粗箭头所示微服务架构解决了单体架构的耦合问题。但同时也带来了新的问题，因为服务部署在不同的进程或者服务器中，要使用服务前需要先找到服务。这就是所谓的服务发现。一般微服务使用两种发现方式，一种是我们前面课程介绍过的RPC方式，通过注册中心进行服务的注册和订阅。来完成服务发现，比如图中灰色的register模块。这种方式由服务的调用端，获得全部可用服务节点。由client进行负载均衡调用服务。另外一种是通过HTTP协议，调用服务端提供的rest for接口。这种方式不需要client侧做服务发现，而是在server端通过nginx这样的反向代理。来提供server侧的负载均衡。\n不论哪种方式，服务的交互，都从进程内通信变成了远程通信，所以性能必然会受到一些影响。此外也会产生很多不确定的因素。例如网络拥塞，server端服务宕机、挖掘机铲断机房光纤等，需要许多额外的功能和措施，才能保证微服务流畅稳定的工作。\n前面讲spring cloud提到的各种组件，都是用来解决这些问题的微服务组件。在微服务架构中，服务变成了无状态的分布式服务，所以我们有必要了解一下，分布式系统中的cAP原则和base理论。\n看这张图，cAP原则是指在一个分布式系统中 consistency一致性，availability可用性、partition tolerance分区容错性这三个特征最多只能同时满足两个，三者不可兼得。\n其中一致性是指所有节点在同一时间的数据完全一致，可用性指任何时候对分布式系统总是可以成功读和写。分区容错性是指当某些节点或者网络分析故障的时候，仍然能够提供满足一致性和可用性的服务。既然无法同时满足三个特征，那么就会有三种取舍。\n首先是选择ca，就是放弃分区容错，这也就等同于放弃了分布式系统，所以ca只存在于单机系统。第二个选择是cp也就是选择强一致和分区容错。允许在极端情况下出现短时的服务不可用，采用cp原则实现分布式系统，比如zookeeper。zookeeper是一个分布式协调系统，强一致性是zookeeper的目标，允许出现短时的系统不可用，也正是因为这个原因。zk并不适合用来做微服务的注册中心。第三个选择是AP，也就是选择分区容错和高可用，允许数据出现短时间不一致。采用AP原则的分布式系统有eureka。在服务注册的场景，短期的不一致，一般不会对服务交互产生影响。因此采用AP原则的注册中心，才是微服务比较适合的选择。\n最后介绍一下base理论，就是图下方的几个词汇的缩写，是指basically available基本可用，soft state软状态，eventually consistent最终一致性，它是对cAP中的一致性和可用性权衡的结果。base的核心思想是即使无法做到强一致性，但可以根据系统的特点，采用适当的方式达到最终一致性。\n回来继续看系统架构演进，微服务架构的思路是服务结构和这会导致一个大的业务拆分成众多的小的服务。每个服务的部署都需要考虑单点问题。需要多机房多节点部署，会造成系统资源的浪费。另外在服务扩容时。需要重新整理服务运行依赖的环境，对微服务的普及都有一定阻碍。容器化技术，把服务的运行环境进行打包管理，解决了服务扩缩容时。对运行环境的管理问题，以及服务器的利用率问题。因此随着容器技术的逐渐成熟，微服务架构也快速普及。云原生架构有微服务组成，它不是一种业务系统架构，而是一种能够快速持续可靠规模化的交付业务服务的模式。图上方列出的是云原生的三个特征，第一个是容器化的微服务，这是云原生的主体。第二个是Devops，是对微服务的动态管理。第三个是持续交付能力，这是云原生的目的。云原生服务需要底层的云服务。提供as基础设施。或者pass平台设施来运行。as理解为提供了服务器资源，pass平台可以理解为提供了运行环境，常见的实践方式有两种，自建的私有云和云厂商提供的公有云。公有云，比如阿里云、aws腾讯云等，像新浪微博内部使用的私有云与公有云结合的混合云模式。\n接下来我们看云原生应用开发的最佳实践原则。12要素。它定义了设计SARS应用时需要遵循的一些基本原则。SARS是软件及服务的缩写，通过云原生应用来提供服务。第一个要素是基本代码，是指代码有版本管理工具来管理，一个应用只有一份基准代码，运行时有多个部署实力。第二个要素依赖是指要在应用中显示的生命依赖，方便服务进行构建。第三个要素配置。只要在环境中存储配置，而不是写在代码配置文件中,也就是说配置与代码要分开管理，从代码外部进行加载。例如测试环境的配置，仿真环境的配置以及生产环境的配置，都应该从对应的环境中进行加载。第4个要素后端服务，是只要把依赖的后端服务看作统一资源来对待，不论是db缓存还是HTTP服务，第5个要素是构建发布运行，是指要严格区分应用的构建、发布、运行这三个步骤，并且必须按顺序进行。第6个要素进程，是指应用以一个或多个进程运行。要保证应用的无状态性。第7个要素端口绑定，是指不同的应用，使用不同的端口提供服务，应用与端口是绑定的，这不是指具体的绑定某一个端口，而是指，一旦服务启动。确定了端口，那么这个端口就能够提供对应的服务，一直到应用进程停止。第8个要素并发是指应用进程之间。可以并发处理。因此可以通过多进程方式进行水平扩展。第9个要素，易处理是指应用应该容易被管理。可以通过优雅停机和快速启动，构建最健壮的服务。第10个要素。开发生产等价。是指要保证在开发、预览、生产等不同环境下的应用。尽可能一致。第11个要素日志，是指要合理记录应用的运行日志，并且把日志当做一种事件流来对待，方便对日志的收集和处理。第12个要素，管理进程是只要把后台管理任务当做一次性进程来运行，而不是常驻的后台进程的方式。以上12要素是对设计云原生服务的指导原则。在实际项目中可以结合实际业务场景进行架构设计，不一定完全照搬。\n云原生应用是目前大部分互联网公司的服务架构推进方向，那么下一代的服务架构是什么样？这里我给你介绍一个最新的服务化趋势，它离实际应用可能还有些遥远，我们可以静待它的发展service mesh是2017年逐渐在国内进入大家视野的一种架构方式，被誉为下一代的微服务。service mesh在微服务的基础上，引入了 sidecar边圈的概念，如图左下方的放大图所示，每个服务会伴生着部署一个sidecar。服务之间的交互不再由服务自身来完成。服务所有的出入的请求都交由这个sidecar尔来进行处理。通过管理平面对所有的sidecar尔进行统一管理。由sidecar来实现服务发现。负载均衡、流量调度等能力。目前最有代表性 service mesh的开源实现是由Google IBM last三家一起维护的Istio。\n那么service mesh与微服务的区别是什么？service mesh又可以解决哪些问题？我们看图，微服务的出现是为了解决多个服务之间的耦合问题，如图中绿色的竖线，就是微服务架构要做的事情，他把service a、b、c进行了解耦。服务单独部署，单独管理。这时每个服务都需要实现，比如服务发现，服务的远程交互，交互过程中的负载均衡，高可用策略、服务熔断等一系列的功能，这些功能与服务自身的业务逻辑没有任何关系。service mesh的思路是把与业务逻辑无关的功能进行解耦。如图中红色的线，对服务进行横切，把与服务交互相关的功能从服务中剥离出来，统一交给sidecar去实现。让服务更聚焦于业务逻辑，提高研发效率。同时由于功能相对独立。sidecar可以更专注于服务的交互与管理，更方便实现极致的功能与性能。所以service mesh不是一个全新的技术，他对业务与服务的交互管理进行了拆分，提供统一强大的服务管理能力，是在微服务基础上进行的演进。另外,service mesh是由于使用独立的sidecar进程。因此天然适合为不同语言的服务提供统一的服务治理能力。因此跨语言服务治理也是service mesh的一个重要特点。像微博基于motan研发的weibo mesh,初衷就是为了解决内部不同语言之间服务化的问题。\n由于引入了额外的sidecar，service mesh的架构复杂度更高，也会带来额外的可用性和性能问题，这也是service mesh架构需要努力解决的问题。通过了解系统架构的演进，我们发现从单体架构到微服务架构，实现了服务之间的解耦，但带来了额外的服务发现与交互问题。\n从微服务到service mesh，实现了业务与服务治理功能的解耦，但是引入了额外的可用性和性能问题，架构复杂度也随之提高。那么这样做的意义在哪里？系统架构的设计从来就是一个权衡的艺术，在很多情况下，我们只是让问题进行了转移，方便对问题进行集中的整治和处理，让服务更聚焦于业务研发。不同的功能就 交给专门的组件来处理。正所谓术业有专攻，通过架构的演进，虽然当下没有消灭复杂度，但可以成功的让问题变得透明化，变得业务无感知，提升服务整体的开发效率扩展能力，拓宽服务能力的上限。\n容器化技术 微服务之所以能够快速发展，很重要的一个原因就是容器化技术的发展和容器管理系统的成熟。第二个知识点，我们来学习微服务架构的基础，容器化技术docker和Kubernetes容器集群管理系统 。docker的作用，主要是快速构建部署运行服务，通过服务镜像能够为服务提供版本管理理，通过容器化技术，可以屏蔽不同运行环境的差异，让服务在任何docker环境中运行，就像Java的一次编译到处运行，docker是轻量化虚拟技术，可以在一台宿主机上运行多个服务，对运行的服务之间进行了有效的隔离，提高宿主机的资源利用率。再来看docker的特点，第一个是开源，意味着可以免费使用docker容器技术。第二个特点是基于LXC实现轻量虚拟化，docker容器直接运行进程，不需要模拟，运行效率非常高。第三个是能够支持大规模的构建，docker的架构十分灵活，可扩展不同的实现。例如支持不同存储驱动的实现。最后docker可以提供可视化UI，管理非常简单，还有docker的几个主要概念，第一个是镜像，就是服务代码和运行环境的封装，服务的版本管理就是通过镜像来实现的，镜像是部署的基础。第二个概念是容器，就是tontainer，容器是基于镜像的服务运行状态，可以基于一个镜像运行多个容器。\n第三个概念是守护进程，是运行在宿主机上的管理进程，用户通过client与守护进程进行交互。第4个客户端是用来和守护进程交互的命令行工具。也可以通过socket或者rest for apI访问远程的docker守护进程。最后一个概念是镜像仓库，类似我们的git代码仓库。镜像仓库用来保存管理不同服务不同版本的镜像。服务部署时会从镜像仓库拉取对应版本的镜像进行部署。\ndocker的实现我们再来了解一下原理，docker是通过对不同运行进程进行隔离，来实现虚拟化，主要利用三种方式来实现服务的隔离。\n如图所示第一个是利用Linux的namespace命名空间来隔离进程之间的可见性，不同的服务进程，彼此属于不同的namespace，互相之间无法感知对方的存在。docker实现了host、 container、none、bridge 4种网络模式，默认使用bridge桥接模式。每一个容器在创建时都会创建一对虚拟网卡，两个虚拟网卡组成了数据的通道，其中一个会放在容器中，另一个会加入到docker0的网桥中。docker的网桥通过APP tables中的配置，与宿主机的网卡相连，所有符合条件的请求都会通过IP table转发到docker0，并由网桥分发给对应的容器网卡。为了防止容器进程，修改宿主机的文件目录，doctor通过改变进程访问文件目录的根节点，结合namespace来隔离不同容器进程，可以访问的文件目录，通过namespace，docker隔离了进程，网络和文件目录，但是在进程运行中的CPU和内存等还是共享状态，docker通过control groups，也就是c groups来对进程使用的资源进行限制。包括CPU、内存和网络带宽等。\ndocker是如何把镜像运行起来的呢？docker的镜像是分层结构。例如一个服务镜像，可以由操作系统层、技术环境层、web容器层、服务代码层，层层依赖构成，通过UnionFS就是联合文件系统把Image子中不同的分层作为不同的制度目录，而Container是在只读镜像目录上创建的可读可写的目录。通过这种方式把进项运行起来的。docker提供了aufs 、OverlayFs、DeviceMapper等多种不同的存储驱动实现。\n另一个知识点是Kubernetes，Kubernetes也叫k8s，因为k与s之间一共有8个字母，k8s是一个容器集群管理系统，它不是一个pass平台，pass平台是可以运行在k8s上的，按照刚docker的介绍方式，这里也分为三点，k8s的作用，就是进行容器集群的管理，它只针对容器管理。不部署源码不编译应用。它能够实现服务容器的自动部署，与按指定条件进行自动扩缩容服务，来实现对应用的管理。支持应用的负载均衡、滚动更新、资源监控等。K8s的特点，一个是可移植性，支持在公有云、私有云、混合云中运行，第二个是可扩展。K8s采用模块化方式，差价化架构。可挂载可组合。第三个特点是自动化支持服务的自动部署、自动重启、自动复制、自动伸缩。K8s中的概念非常的多，这里列出了比较重要的几个，我逐个来说明，K8s是集群容器管理系统，容器首先需要运行在宿主机上，因此K8s首先要管理宿主机集群，可以把s分为master节点和Node节点，Node节点也叫work Node，master负责管理节点，管理k8s集群，master协调集群中所有的行为与活动。例如应用的运行、修改更新等，node的节点用来运行容器。Node上可以运行多个Pod。Pod是k8s创建或者部署的基本单位，Pod中可以运行多个container，一个container就是一个运行中的服务镜像，Pod中的container共享网络和存储 service是k8s中的一个逻辑概念，通过对不同的Pod添加标签来划分为不同的service。Deployment。表示用户对k8s机群的一次更新操作，可以是创建一个新的服务，更新一个服务，也可以是滚动升级一个服务。我们来结合k8s的架构理解这些概念。\n看到这张图，图左侧绿色的模块代表master节点，右侧蓝色的模块，代表运行容器的work Node节点。我们先来看master节点中的架构，灰色的部分是master中的模块。其中api server用户对k8s中资源操作的唯一入口。创建应用部署，管理部署状态等，都需要通过API server进行 api server提供了认证授权，访问控制，API注册和发现等机制。\nController manager负责维护集群的状态。比如故障检测，自动扩展、滚动更新等。Controller manager，包含多个可以扩展的controller。例如node controller。负责初始化弄的节点，获取运行中的node 信息，routercontrol，负责配置集群间通信的路由信息，service controller负责监听服务创建、更新删除等事件，来调整负载均衡信息等。\nscheduler负责资源的调度,按照预定的调度策略，选择哪个pod的运行在哪个节点上。另外图下方的绿色模块是用来保存整个集群状态的etcd。图最左侧的kubectl是用于运行k8s命令的管理工具.kubectl和APi server进行交互，通过API server下发对k8集群的指令，再来看右面的work node，刚才介绍概念时提过，note用来运行应用容器，所以note中必须要有一个容器运行时，可以是doctor，也可以是其他容器技术。node中部署应用时，每个应用都有一个pod组成。可以把pod看做一个虚拟服务器。上面可以运行一个或多个containert容器，当应用服务需要多个进程共同协作时，可以把这些协作的镜像打包放在一个pod中，共享pod存储和网络，比如scheduler代理模式，就是通过在服务的pod 中注入一个sidecar镜像。来实现与服务IP的绑定，进行流量控制的。\n看到右面图中灰色的两个node的模块，kubelet负责与master进行通信，它周期性的访问APIController进行检查和报告，执行容器的操作，维护容器的生命周期，也负责volume和网络的管理。kube-proxy处理网络代理。和每个容器的负载均衡，他通过改变IP table规则来控制在容器上的TCP和utp包，k 8s把所有对管理资源看作对象，对资源的管理就变成了对象属性的设置。k8s对象的配置采用yaml格式来描述。K 8s中的对象概念非常的多，大致可以分为4类，资源对象。例如。Pod、job。配置对象比如node，namespace、 service。存储对象例如Volume、present volume。策略对象例如 security context。Resource quarter、Limit range等。\n考察点\n 表达沟通 分布式架构的理解 了解系统优化的常用方法 对工作的熟悉程度 解决问题能力  第一。要对分布式架构有自己的理解比如系统可用性、扩展性，比如故障的应对方法，包括熔断、容灾、流量迁移、机房多活等。再比如架构设计中的解耦合等。\n第二。要了解系统架构优化的常用方法。比如。并行、异步、水平扩展和 垂直扩展、预处理、缓存、分区等。\n第三。会考察对你负责项目的了解程度，是否有责任心。如果连自己负责的项目的部署规模定位量级都不清楚，怎么能有很强的责任心。\n最后一个是解决问题的能力，看你是否会灵活运用各种知识的能力\n加分项\n 关注业界最新趋势 如果有方案对比选型会更好  比如在介绍项目架构时有两个方案。一个是同步方案，一个是异步方案。这两个方案各有什么优缺点？最后结合业务场景实际需求请求量级选择了其中的某一种。\n面试技巧\n 交代背景: STAR法则 描述架构:架构图或交互流程图 做了什么:重点突出 结果如何:用实例佐证 如何改进:存在的问题与解决方法  面试时，你一定会遇到介绍项目这个问题，我见过的大多数人在这里表现的并不好，要么讲不清楚项目的结构和交互流程，要么不能理解项目的架构为什么要这样设计，要么没有思考过项目中存在哪些问题，有哪些可以改进的地方。同样不仅是针对面试，在工作中我们更应该搞清楚这些问题，尤其是工作1~3年的工程师们，这个部分我着重说一下，在面试中如何更好的介绍自己负责的项目。图中的这些方法是根据面试考察点总结的，我会提示每个方法要重点体现出哪些能力。\n第一步。要简单交代项目的背景，让面试官可以快速的进入到项目上下文，更容易理解项目架构，一般采用四大法则来进行介绍，situation介绍项目的背景。比如这个项目是研发一个短视频案，配合公司主客户端来交叉提高用户量和活跃度。Task，来介绍自己的任务。比如。我在这个项目中负责了后端服务的架构设计和研发，action介绍自己做了哪些工作。比如。当时用了两周时间做架构设计，4周时间做研发，两周时间测试上线。Result介绍结果。这个也是大部分人容易忽视的地方。比如项目上线后两个月用户数达到了100万。后端服务接口总量峰值在5万，主要接口服务sla p99小于50毫秒。注意背景介绍是为了后面详细介绍做铺垫。简洁明了就行了。这部分主要体现出你的表达能力。\n第二步。重点介绍项目的架构，这也是面试官最想了解的部分。务必要结合架构图交互流程图来介绍。避免对一些关键问题理解歧义。架构图要注意边界清晰。就是你的服务和你依赖的其他外部服务之间的边界，以及你的服务内部模块之间的边界都要描述清楚，这有利于你下一步介绍自己做了哪些内容。这一步要体现出你对项目架构的理解。\n第三步。介绍你在这个项目中具体做了哪些内容。例如。我设计了整个架构。或者我实现了架构图中的某几个具体的模块。注意这一步是你面试中的绝对加分点，必须要把握住。这里要突出你在项目中做的最具有挑战性的点，优雅的架构设计，或者独特有效的解决方案。比如在数据量非常大的场景下。通过优化redis存储结构，减少了70%的redis使用容量。比如,对查询接口应用了双发功能，使p三个9降低了60%。再比如。使用的trees功能，来快速定位问题等。\n第三步要体现出你的实现能力和亮点。\n第4步，你要为你第三步介绍的优秀架构或者解决方案提供证明。比如前面介绍了系统架构中使用了模块化设计来提高扩展性，那这里就可以说系统上线后，通过这种模块化方式，我支持了7个新业务的接入，来体现你设计的架构的优点。这里要注意。所有的结果必须是可以量化的。不要用性能大幅提升，极大提高灵活性，这里很虚的描述。好一点的表述可以是这样。通过增加二级缓存，对后端服务的调用请求，从7000qps降低到600qps。这一步要体现出你对项目的掌握能力和了解程度。\n第5步。思考项目中存在哪些问题。或者还有哪些可以进行优化的点。例如。现在项目的qps还是不高，某些任务是同步处理的，会有一定效率问题，这些处理步骤可以异步执行。如果请求量级增加，可以考虑使用kafka进行异步处理，处理时还应该考虑消息重复的问题。可以把处理逻辑设计成幂等性等。这一步要体现出。你对项目的思考以及总结反思能力。如果我作为面试官，遇到一位按照上面5个方向来交流的候选人，一定会非常看好的。\n面试技巧\n 提前思考、提前准备 项目在精不在多 我了解的,就是我的 体现对架构的理解,对设计的思考  再来介绍几个备战面试的小技巧。第一点，肯定要提前思考，提前准备。像项目架构图怎么画更容易理解。项目中到底哪个设计最有亮点。项目还存在哪些可以改进的地方等问题，可能要花很多时间才能找到比较理想的答案。在面试现场临时回答难度非常大，一定要根据我前面的方法提前准备。\n第二点。要记住项目在精不在多。有的人在介绍项目时会抛出好几个项目。但每个项目介绍的都很潦草，在面试中，面试官想通过项目介绍来考察你的各方面能力，一个重点项目就足够了，一定要选你最了解，最能代表你能力的来介绍。\n第三点，我了解就是我的有的，同学可能因为机遇的原因，没有付出过重点的项目，不过项目介绍这么重要的考察点，也不能白在这里丢分，你可以多了解一下其他同事或者其他团队负责的项目，只要你能把项目细节搞明白，把架构理解透，那么知识就是你的，依然可以拿来进行介绍。\n第4点，要重点体现对架构的理解，对设计的思考。这会让面试官觉得你很有潜力。你可以在介绍项目设计思路时做适当的延伸。例如你可以说。在我的业务场景下，可以容忍低概率的消息丢失。所以基于性能优先的考虑，我去掉了kafaka的aCK应答。如果是严格要求不丢消息的场景，我会使用同步应答，并且使用最高消息可靠性等级。\n技术人行走职场的建议 先来看怎么写简历，大部分候选人都是倒在了简历筛选这一关，hr或者面试官一般只会在简历上停留10~30秒，如果简历不吸引人，再优秀的候选人也会错失良机。那么一份好的简历都有哪些特点？首先结构清晰，主次分明，简历可以分为基本信息，项目经历、自我总结等部分，各个部分要做到主次分明，特别是项目介绍，建议按照发生时间倒序来排列，最新的项目放在最前，多个项目之间也要分主次，重点的项目最能体现你能力和工作成果的项目，要详细介绍，无论是面试还是简历，都可以使用star法则。在简历中，star法则的各个要素可以更加精炼。\n第二个特点，语句通顺，没有错别字，尤其是一些英文名称的拼写。语句不通或者太过于口语化，这样的项目尽量简洁。同一类型的项目建议不要重复，另外技术工作里有很多英文单词，要注意检查拼写和大小写，要让面试官第一印象觉得你是个严谨的人。\n第三个特点，less is more，少即是多。简历的内容不是越多越好，建议不要超过两页。如果不能让面试官快速找到想要的信息，马上就会被pass。简历一定都是体现你能力的关键信息。可有可无的信息一律都要删除。比如。教育背景只保留到高等教育阶段即可。高中就不需要出现。如果是社招，大学里无关紧要的证书就不用体现等。\n第4个特点是所有的结果都是可以量化的，这点是很多人都会忽视的地方。简历里不能只说做了什么。要说做成了什么，可量化的结果更加真实可信，比如完成了15个功能模块的设计与开发，比如优化后响应时间提升了70%等，最好用数字来体现。\n第5个特点是自我评价部分更加务实。而不是空洞的描述。像性格开朗，责任心强。善于组织和协调沟通，能良好的与团队协作，这些看上去挺像那么回事，但比较空洞，千篇一律，没有特点，你可以考虑使用关键词加说明的形式，分条来写自我评价。比如这样说，项目经验丰富，主导过授权认证，支付、视频、账户等项目的落地。对不同类型的项目架构方案和实现有深刻的理解。\n知道了好简历的特点，但是还不够。下面这些技巧可以帮你进一步打磨简历。第一个技巧，你要了解工作岗位的要求，针对岗位来调整简历。好的简历不一定是通用的，要根据应聘的公司和岗位做针对性的优化，提高匹配度，有个重要的原则。就是要突出你非常适合这个岗位，简历中要强调你的优势、技能、特长。正好是招聘职位所需要的，这样会极大的提高成功率。\n第二个技巧，要想在海量简历中脱颖而出，你必须塑造自己的特点，引起面试官的兴趣，先审视自己，寻找自己的优点。比如你参与过非常多的项目，那么实战经验绝对是你的加分项，如果你没有太多项目经验，那你是不是逻辑清晰，思维敏捷，或者你的自我学习能力非常强，阅读过很多开源框架的代码。另外如果你参与过github开源项目。或者经常撰写技术博客，一定要在简历中体现，这也是面试官非常关注的点。但切记你简历中突出的点。也会是面试官重点考察的点，要能把握住。不要给自己挖坑。第三个技巧是你可以换一个视角。\n找经验丰富的朋友来帮忙review你的简历，听哪里不足或修改建议。如果当你没有参与过比较重大的项目，或者项目经验并没有太多出彩的地方是怎么办？第4个技巧。建议你看看负责过的项目的上下游。是否有比较有特色的服务。或者你熟悉的其他小组是否有重点的项目，正所谓他山之石可以攻玉。你可以向同事请教学习，了解那些项目的架构，存在的问题，思考解决的方案。面试时你可以参与者的角度进行介绍。这不是鼓励你去造假。而是能够体现出你对技术的热情和好学。但要记住，如果不能做到真正的了解，结果可能适得其反。\n第5个技巧，如果你的简历中存在硬伤是怎么办？这时可以考虑另辟蹊径。比如你项目经验丰富，技术能力高超，但是学历不高，这样简历很可能通不过出差，连面试的机会都很难获得。这时找朋友内推，或者直接投递简历给公司内部的技术人员，是非常有效的手段。你可以多加入一些技术交流群，就有机会联系到目标公司的技术人员，帮忙内推。不过要注意技术人员对技术能力比较注重。技术能力一般的话从这条路很难走通。\n前面讲了很多面试前的准备工作，不过你也不要忽略了面试后需要做什么。这里我给几点建议，第一个，面试结束后，一般面试官都会询问候选人有没有哪些想知道的问题，这也是一个表现的机会，千万不要什么都不问，你可以提前准备1~2个问题，可以是对面试中的问题进行补充和延伸。例如，刚才面试中提到的问题，我觉得还可以如何设计，您看这样是否可行，能否给一些建议，这样可以体现出你对技术的兴趣和执着，也可以对面试公司的技术或者架构进行简单的询问。例如我听说您的公司对某框架进行了改造，我想了解一下，主要是想解决什么样的问题。这可以体现出你对业界技术趋势的了解。也可以获取一些建议。比如您看我在这次面试中哪些地方需要进行改进。也可以询问一下面试的岗位职责。主要负责哪些业务线和工作，使用何种技术栈等。另外如果是hr面试，可以询问一下。关于岗位的职业发展和职业晋升途径等问题。表现出职业规划意识和上进心。第二点，面试结束后，一定不要马上询问面试结果，这是缺乏耐心的一种表现。第三点，在面试结束后，回家一定要做面试复盘和总结。每次面试。不论成功与否都非常有意义。面试结束后。要对面试中的问题进行记录，回答不上来的问题，要及时查阅资料，或者源码来搞明白，补充自己的知识短板，思考自己在面试中有哪些行为触发了面试官的不满。在下次面试时。可以扬长避短。如果你通过努力成功进入到了心仪的公司。一定不要懈怠放松。职场成长和新技术学习一样，不进则退。那么在职场中应该如何保持竞争力，如何提升自己？\n 有策略的努力:方向、计划、机会 打造自己的技术品牌 总结与反思  首先就是要明确努力的方向，你要主动从业务角度，产品角度来思考问题，思考如何能在业务角度更好的为公司产生价值。\n比如。如果能通过优化业务的交互和处理流程。可以为公司节省30%的服务器成本，那么就应该持续思考。要如何解决在新流程下的技术难题。当有多个方向时，要衡量可行性，难度与收益，优先突破最有价值的方向。比如降低运行成本和提高研发效率来比较，可以优先以降低成本为方向，有了方向以后。要把方向转化为可执行的计划。规定时间和阶段，按计划分步完成。有时候这些计划会与本职工作产生冲突。要协调好时间和效率，不要影响日常工作。最后。这种有价值的方向可能并不容易发现。又或者因为某些原因无法进行，这时候不要急躁。可以调整为学习某个在自己职业规划中必须要掌握的新技术。\n这里给不同工作经验的朋友一些建议，工作1~2年内。以学习知识为主。先打好基础，注意知识广度的培养，保持对新技术的好奇心，切记心浮气躁。工作三年以后需要多一些主动思考。培养自我学习能力。要有意识的提升团队协作，跨团队沟通，项目设计等能力，工作5年以上，要重点树立起自己的技术品牌。要经常思考业务或者项目中存在什么样的问题。如何解决？解决后的收益是什么？对于管理能力要有意识的加强。\n第二个可以提高的点。是要努力打造自己的技术品牌和技术口碑。积累自己的技术价值。比如工作中有强烈的责任心。只要交代给你的事情，一定会言出必行负责到底。再比如经常协助同事排查解决技术难题，经常做一些有技术深度的分享，或者技术问题排查案例的分享等，不要简单的认为这份工作不合适。我就再找另一个，没必要那么辛苦，打造什么技术品牌。\n要知道你后续的职场人脉都是建立在你的技术品牌基础之上的。维持好技术品牌，会对你的职业中后期发展大有裨益。第三个建议，要经常进行总结与自我反思，真正的成长都是在总结与反思之后获得的。某项工作或阶段性任务完成时，都要及时总结，既有助于发现改进空间，又有利于后续准备进行素材，你可以分这几条进行总结，获得了哪些收益？开发中遇到了哪些问题？哪些问题是在设计初期就可以避免的，哪些问题要提早解决。\n在开发过程中自己有哪些地方做得不好。后续要如何进行改进等。再比如。完成一次项目重构，可以总结一下。旧的项目中都存在哪些问题？重构时哪些地方？获得的收益最明显等。下面我分享几个我的高校学习的小tips。\n 积极的心态 目标要集中、简单 制定计划、规律执行 正确的方法 要有阶段性产出物 不断总结与改进  第一，必须要有积极主动的心态，如果主观上不想去做一件事情，肯定无法做到有效率。现在种树是为了日后乘凉。第二。要把任务分解成多个简单一的目标，争取每次只做一件事，按自己的待办事项表，一项进行处理，越专注效率就会越高。第三要规划好时间计划。并按规律的执行，这样可以有效避免拖延症。注意时间计划中要安排出充足的休息时间，会休息才能更好的工作。第四，要使用正确的方法执行工作或学习任务。比如学习时可以通过断点调试，阅读源码。画类关系图、流程图、架构图等方式来进行。第五，要阶段的产出，这样会让自己经常获得成就感，能够更好的坚持执行计划，阶段的产出物可以是定期的工作记录，小组内的技术分享，总结的技术博客等。第六，要做好总结与改进。刚开始执行计划时可能还不太习惯。效率并不太高，随着按阶段不断总结和改进，工作和学习效率也会不断提高。\n我感觉在职场打拼就好比下棋，没有人天生就是高手，你必须多看多学，多实战切磋才能不断进步。而且高手在落子的时候，永远思考的都是下一步。想到的可能性越多，体力也就越高。\n","id":1,"section":"posts","summary":"操作系统与计算机网络 TCP是传输层协议。对应osI网络模型的第4层传输层。 TCP协议的特点是基于链接。也就是传输数据前需要先建立好链接，然后","tags":["杂七杂八"],"title":"复习知识点总结","uri":"https://mumulx.github.io/2020/06/%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/","year":"2020"},{"content":" 网络通信基础\nSocket入门 什么是Socket?\nSocket就是为网络服务提供的一种机制。 通讯的两端都有Sokcet. 网络通讯其实就是Sokcet间的通讯 数据在两个Sokcet间通过I0传输。\n（可以跨语言传输）\nsocket编程网络模型\n什么是网络模型?\n应用层：Http：Http协议 传输层：tcp：Tcp协议 网络层：Ip：Ip协议 链路层：网络层\u0026ndash;以太网\n任何计算机语言通讯，底层都使用socket技术。 Java、C#、C Socket技术遵循一个规划二进制+IP+端口号\nisocket网络编程中也服务器端、客户端\nsocket分为两个非常核心tcp\u0026mdash;\u0026mdash;- udp（IO流传输） tcp与UDP区别区别:\n udp面向无连接——不会建立连接限制传输64k——不可靠协议（会丢包） tcp协议面向连接协议三次握手字节流传输 (udp效率比tcp协议高tcp协议比udp协议靠谐。  http协议的底层使用的时tcp协议进行连接\n使用UDP协议完成客户端与服务器端进行通讯\n一次完整的通信是有三种socket的(服务端有两种，客户端有一种)\n//创建服务端连接 ServerSocket serverSocket = new ServerSocket(8080); //接收客户端请求阻塞功能 具体的请求是通过它来实现的 Socket accept = serverSocket.accept(); //客户端的socket Socket socket = new Socket(\u0026quot;127.0.0.1\u0026quot;, 8080);  Udp协议 package com.mumulx.socket.demo01; /* * Created by IntelliJ IDEA. * User: 木木 * Date: 2020/5/28 * Time: 14:58 */ /*先写服务器端*/ import javax.print.DocFlavor; import java.io.IOException; import java.net.*; /* * 在启动了服务端后是不能通过浏览器进行访问的，因为http协议的底层使用的时tcp协议进行连接 tcp与udp二者不能互通 * */ class UdpServer{ public static void main(String[] args) throws IOException { //1. ip地址+端口号 System.out.println(\u0026quot;udp服务器已经启动。。。。。8080\u0026quot;); //创建服务器端口，默认使用本机Ip地址 DatagramSocket ds = new DatagramSocket(8080); //服务器接受客户端1024个字节 byte[] bytes = new byte[1024]; //定义数据包 DatagramPacket dp = new DatagramPacket(bytes, bytes.length); //接受客户端请求，将数据封装给数据暴 如果客户端不往服务器端发送请求，就会一直阻塞着 ds.receive(dp); System.out.format(\u0026quot;来源IP地址：%s,端口号：%d %n\u0026quot;,dp.getAddress(),dp.getPort()); String s = new String(dp.getData(), 0, dp.getLength()); System.out.println(\u0026quot;服务器端接收到了数据： \u0026quot;+s); //关闭连接 ds.close(); } } /*Udp协议 只管发送 * 速度较快 * */ public class UdpClient { public static void main(String[] args) throws IOException { System.out.println(\u0026quot;Udp客户端启动连接.....\u0026quot;); //不传入端口号 作用客户端 创建一个socket客户端 DatagramSocket ds = new DatagramSocket(); String str = \u0026quot;test\u0026quot;; byte[] bytes = str.getBytes(); DatagramPacket dp = new DatagramPacket(bytes, bytes.length, InetAddress.getByName(\u0026quot;127.0.0.1\u0026quot;), 8080); ds.send(dp); ds.close(); } }  Tcp协议 TCP协议采用三次捂手成功之后，才开始进行数据传输。 最好一次就会进行四次挥手。\nTCP的三次握手与四次挥手理解\nTCP握手协议. 在TCP/IP协议中，TCP 协议采用三次握手建立一一个连接。\n第一次握手:建立连接时，客户端发送SYN包(SYN=J)到服务器，并进入SYN_ SEND 状态，等待服务器确认;\n第二次握手:服务器收到SYN包，必须确认客户的SYN (ACK=J+1) ，同时自己也发送一个SYN包(SYN=K) ，即SYN+ACK包，此时服务器V状态;\n第三次握手:客户端收到服务器的SYN+ACK 包，向服务器发送确认包ACK(ACK=K+1),此包发送完毕，客户端和服务器进ESTABLISHED状态，完成三次握手。\n完成三次握手，客户端与服务器开始传送数据,。\n四次分手:\n由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN 只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。\n(1)客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。\n(2)服务器B收到这个FIN，它发回一个ACK, 确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。\n(3)服务器B关闭与客户端A的连接，发送一个FIN给客户端A。\n(4) 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。\n1.为什么建立连接协议是三次握手，而关闭连接却是四次握手呢?\n这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN (ACK 起应答作用，而SYN起同步作用)放在一个报文里来发送。\n但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了;但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的.。\n2.为什么TIME WAIT状态还需要等2MSL后才能返回到CLOSED状态？ 这是因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态(就好比从SYN SEND 状态到ESTABLISH状态那样) ;但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ ACK 状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME _WAIT状态的作用就是用来重发可能丢失的ACK报文。。\nTCP协议进行客户端与服务器端进行通讯.\ntomcat使用的时http协议进行通信的\npackage com.mumulx.socket.demo01; /* * Created by IntelliJ IDEA. * User: 木木 * Date: 2020/5/28 * Time: 15:47 */ import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.ServerSocket; import java.net.Socket; import java.sql.SQLOutput; /*可以通过浏览器进行通信 * 127.0.0.1:8080 * */ class TcpServer{ public static void main(String[] args) throws IOException { System.out.println(\u0026quot;Tcp协议服务器端启动。。\u0026quot;); //创建服务端连接 ServerSocket serverSocket = new ServerSocket(8080); //接收客户端请求阻塞功能 Socket accept = serverSocket.accept();//accept也是阻塞的 InputStream inputStream = accept.getInputStream(); //将字节流转换成String类型 byte[] bytes = new byte[1024]; String result = new String(bytes, 0, inputStream.read(bytes));//read是阻塞的 System.out.println(\u0026quot;服务端接收客户端内容\u0026quot; + result); serverSocket.close(); } } /*没有启动服务端时 启动客户端会报错java.net.ConnectException: Connection refused: connect*/ public class TcpClient { public static void main(String[] args) throws IOException { System.out.println(\u0026quot;socket tcp 客户端启动....\u0026quot;); Socket socket = new Socket(\u0026quot;127.0.0.1\u0026quot;, 8080); OutputStream outputStream = socket.getOutputStream(); outputStream.write(\u0026quot;hahahhaha\u0026quot;.getBytes()); socket.close(); } }  tcp支持，怎么解决tcp协议同时支持多个请求\n同时支持多个请求使用线程池还是多线程好？线程池（可以节约内存）\n/*多个连接*/ class TcpServer1 { public static void main(String[] args) throws IOException { System.out.println(\u0026quot;Tcp协议服务器端启动。。\u0026quot;); ExecutorService executorService = Executors.newCachedThreadPool(); //创建服务端连接 ServerSocket serverSocket = new ServerSocket(8080); try { while (true) { //接收客户端请求阻塞功能 Socket accept = serverSocket.accept(); executorService.execute(()-\u0026gt;{ InputStream inputStream = null; try { inputStream = accept.getInputStream(); //将字节流转换成String类型 byte[] bytes = new byte[1024]; String result = new String(bytes, 0, inputStream.read(bytes)); System.out.println(\u0026quot;服务端接收客户端内容\u0026quot; + result); OutputStream outputStream = accept.getOutputStream(); outputStream.write(\u0026quot;接收到请求\u0026quot;.getBytes()); } catch (IOException e) { e.printStackTrace(); } }); } } catch (IOException e) { e.printStackTrace(); } finally { serverSocket.close(); } } }  NIO BIO、NI0和AIO的区别?\nNIO编程jdk1 .4在IO基础之上进行改进(NIO中有一个非阻塞IO、面向缓冲区)\nIO阻塞、面向流\nNIO效率高\nNIO结构图\n什么是NIO? Java NIO(New 10)是-一个可以替代标准Java IO API的IO API (从Java 1.4开始)，Java NIO提供了与标准IO 不同的IO 工作方式。 Java NIO: Channels and Buffers (通道和缓冲区)。\n标准的10基于字节流和字符流进行操作的，而NI0是基于通道(Channe|) 和缓冲区(Buffer) 进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。\nJava NI0: Non-blocking IO (非阻塞IO)。\nJava NIO可以让你非阻塞的使用IO ， 例如:当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。\nJava NIO: Selectors (选择器)。\nJava NIO引入了选择器的概念，选择器用于监听多个通道的事件(比如:连接打开，数据到达)。因此，单个的线程可以监听多个数据通道。\n注意:传统IO是单向。NIO 类似。\n区别\n   IO NIO     面向流 面向缓冲区   阻塞IO 非阻塞IO   无 选择器    断点续传:多线程+文件拼接。将一个文件拆分成多个线程(多个请求分段下载) 最好拼接成一个文件\nBuffer的数据存取 一个用于特定基本数据类行的容器。有java.nio 包定义的，所有缓冲区都是抽象类Buffer的子类。。\npackage com.mumulx.nio; import org.junit.Test; import java.nio.ByteBuffer; /* * Created by IntelliJ IDEA. * User: 木木 * Date: 2020/5/28 * Time: 16:36 */ /*缓冲区介绍*/ public class BuffTest { /*Buffer类中含有着四个参数 * private int mark = -1; private int position = 0;//混充去正在操作的位置 默认从0开始 private int limit;//界面(缓冲区可用大小) private int capacity;//缓冲区最大的容量，以但声明不能改变 * * 核心方法 * put 往buff中存放数据 * get 获取数据 * * */ @Test public void test() { try { //初始化ByteBuffer大小 ByteBuffer allocate = ByteBuffer.allocate(1024); System.out.println(allocate.position()); System.out.println(allocate.limit()); System.out.println(allocate.capacity()); System.out.println(\u0026quot;往buffer中存放数据\u0026quot;); allocate.put(\u0026quot;hahah\u0026quot;.getBytes()); System.out.println(\u0026quot;----------------\u0026quot;); System.out.println(allocate.position()); System.out.println(allocate.limit()); System.out.println(allocate.capacity()); System.out.println(\u0026quot;读取值\u0026quot;); /* byte[] bytes = new byte[allocate.limit()];//从5开始读 allocate.get(bytes); System.out.println(new String(bytes, 0, bytes.length)); //会报错java.nio.BufferUnderflowException */ /*读取值时要开启读取模式*/ allocate.flip();//开启读取模式将position的值变为0 从0开始读 byte[] bytes = new byte[allocate.limit()]; allocate.get(bytes); System.out.println(new String(bytes, 0, bytes.length)); System.out.println(allocate.position()); System.out.println(allocate.limit());//读取之后limit的值变为了5 System.out.println(allocate.capacity()); System.out.println(\u0026quot;************重复读取\u0026quot;); /* //读取值之后position的值又变成5了 byte[] bytes1 = new byte[allocate.limit()];//重复读取会报错java.nio.BufferUnderflowException allocate.get(bytes); System.out.println(new String(bytes1, 0, bytes.length));*/ /*可以设置重复读取*/ allocate.rewind();//设置重复读取 从上一次的下标的位置开始读取 byte[] bytes1 = new byte[allocate.limit()];//重复读取会报错java.nio.BufferUnderflowException allocate.get(bytes1); System.out.println(new String(bytes1, 0, bytes.length)); /*清空缓存区 只把下标还原了，数据被遗忘了*/ System.out.println(\u0026quot;清空缓存区\u0026quot;); allocate.clear(); System.out.println(allocate.position()); System.out.println(allocate.limit()); System.out.println(allocate.capacity()); System.out.println((char) allocate.get());//清空之后 值仍然存在 我们还可以取出 } catch (Exception e) { e.printStackTrace(); } } public static void main(String[] args) { /*缓冲区是NIO 提高给传输文件和通道一起配合使用，存储数据 * Buffer * ByteBuffer * LongBuffer * IntegerBuffer * FloatBuffer * DoubleBuffer * * */ } }  结果\n0 1024 1024 往buffer中存放数据 ---------------- 5 1024 1024 读取值 hahah 5 5 1024 ************重复读取 hahah 清空缓存区 0 1024 1024 h  make与rest用法 标记(mark) 与重置(reset) :标记是一个索引，通过Buffer中的mark()方法指定Buffer中一-个特定的position,之后可以通过调用reset()方法恢复到这个position。\npackage com.mumulx.nio; import java.nio.ByteBuffer; /* * Created by IntelliJ IDEA. * User: 木木 * Date: 2020/5/28 * Time: 20:44 */ public class BuffTest02 { public static void main(String[] args) { ByteBuffer byteBuffer = ByteBuffer.allocate(1024); String str = \u0026quot;abcd\u0026quot;; byteBuffer.put(str.getBytes()); //开启读模式 byteBuffer.flip(); byte []bytes = new byte[byteBuffer.limit()]; byteBuffer.mark();//打印一个标记，标记位置为0 byteBuffer.get(bytes,0,2);//从position开始（0）读取3个字节存储到bytes 0-2 获取完毕后position为2 System.out.println(new String(bytes,0,2)); System.out.println(byteBuffer.position()); byteBuffer.reset();//重置 还原到mark标记的位置，position为0 byteBuffer.get(bytes,2,2);//从position（0）开始两个字节 读取到bytes的2-4中 System.out.println(new String(bytes,2,2)); System.out.println(byteBuffer.position()); } }  结果\nab 2 ab 2  直接缓冲区与非直接缓冲的区别 非直接缓冲区:通过allocate() 方法分配缓冲区，将缓冲区建立在JVM的内存中。.\n直接缓冲区:通过allocateDirect() 方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率。\nByteBuffer byteBuffer = ByteBuffer.allocate(1024);//非直接缓冲区 ByteBuffer byteBuffer1 = ByteBuffer.allocateDirect(1024);//直接缓冲区  缓存区分为另种第一种直接缓存区、非缓冲区\n非直接缓冲区主要存放在jvm缓冲区中来回拷贝。\n直接缓冲区\u0026mdash;存放物理内存 不需要来回拷贝\n存放在物理内存比jvm缓冲区速度快\n数据放在非直接缓冲区比直接缓冲区更加安全。\n直接缓存区非常占内存\n字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则Java 虚拟机会尽最大努力直接在此缓冲区上执行本 机1/0操作。也就是说，在每次调用基础操作系统的一个本机1/0 操作之前(或之后)，虛拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中(或从中间缓冲区中复制内容)。\n直接字节缓冲区可以通过调用此类的allocateDirect() 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机1/0 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。\n直接字节缓冲区还可以通过FileChannel 的map() 方法将文件区域直接映射到内存中来创建。该方法返回MappedByteBuffer,。Java 平台的实现有助于通过JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。\n字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其isDirect() 方法来确定。提供此方法是为了能够在性能关键型代码 中执行显式缓冲区管理。。\nIO中的缓冲区\u0026ndash;非直接缓冲区\n通道（Channel）的原理获取 通道表示打开到10 设备(例如:文件、套接字)的连接。若需要使用NI0系统，需要获取用于连接10 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。Channe|负 责传输，Buffer 负 责存储。通道是由java. nio. channels包定义的。Channe| 表示I0源与目标打开的连接。Channe| 类似于传统的“流”。只不过Channel 本身不能直接访问数据，Channel只能与Buffer进行交互。\njava. nio. channe Is. Channel接口:。 FileChannel SocketChannel ServerSocketChannel DatagramChannel  获取通道。 1. Java针对支持通道的类提供了getChannel() 方法。\n本地10:\nFilelnputStream/File0utputStream.\nRandomAccessFilew\n网络IO:。\nSocket\nServerSocket DatagramSocket\n 在JDK 1.7中的NI0.2针对各个通道提供了静态方法open()\n 在JDK1.7中的N10.2的Files工具类的newByteChannel ()。\n  获取代码运行时间\n1）、创建一个 Timer 工具类对象，执行一些操作然后调用 Timer 的 duration() 方法产生以毫秒为单位的运行时间。\n// onjava/Timer.java package onjava; import static java.util.concurrent.TimeUnit.*; public class Timer { private long start = System.nanoTime(); public long duration() { return NANOSECONDS.toMillis(System.nanoTime() - start); } public static long duration(Runnable test) { Timer timer = new Timer(); test.run(); return timer.duration(); } }  2)、是以毫秒为单位计算的。\n//伪代码 long startTime=System.currentTimeMillis(); //获取开始时间 doSomeThing(); //测试的代码段 long endTime=System.currentTimeMillis(); //获取结束时间 System.out.println(\u0026quot;程序运行时间： \u0026quot;+(end-start)+\u0026quot;ms\u0026quot;);  3）、以纳秒为单位计算的。\n//伪代码 long startTime=System.nanoTime(); //获取开始时间 doSomeThing(); //测试的代码段 long endTime=System.nanoTime(); //获取结束时间 System.out.println(\u0026quot;程序运行时间： \u0026quot;+(end-start)+\u0026quot;ns\u0026quot;);  源码\npackage com.mumulx.nio; import org.junit.Test; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.nio.ByteBuffer; import java.nio.MappedByteBuffer; import java.nio.channels.FileChannel; import java.nio.file.Path; import java.nio.file.Paths; import java.nio.file.StandardOpenOption; import java.util.Timer; /* * Created by IntelliJ IDEA. * User: 木木 * Date: 2020/5/28 * Time: 21:20 */ public class BuffTest03 { /*非直接缓冲区 读写操作*/ @Test public static void test01() { try ( //读入流 FileInputStream fileInputStream = new FileInputStream(\u0026quot;1.png\u0026quot;); //写入流 FileOutputStream fileOutputStream = new FileOutputStream(\u0026quot;2.png\u0026quot;); //创建通道 FileChannel inChannel = fileInputStream.getChannel(); FileChannel outChannel = fileOutputStream.getChannel(); ) { //分配指定大小缓冲区 ByteBuffer buf = ByteBuffer.allocate(1024); while (inChannel.read(buf) != -1) { //开启读取模式 buf.flip(); //将数据写入到通道中 outChannel.write(buf); buf.clear(); } //关闭通道、关闭连接 } catch (IOException e) { e.printStackTrace(); } } /*直接缓冲区读写操作*/ @Test public static void test02() { try ( //创建管道 FileChannel inChannel = FileChannel.open(Paths.get(\u0026quot;1.png\u0026quot;), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(\u0026quot;2.png\u0026quot;),StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); ) { //定义映射文件 MappedByteBuffer inMap = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size()); MappedByteBuffer outMap = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size()); //直接对缓冲区进行操作 byte[] bytes = new byte[inMap.limit()]; inMap.get(bytes); outMap.put(bytes); } catch (IOException e) { e.printStackTrace(); } } }  分散读取与聚集写入 分散读取(scattering Reads): 将通道中的数据分散到多个缓冲区中\n聚集写入(gathering Writes): 将多个缓冲区的数据聚集到通道中\npackage com.mumulx.nio; import java.io.FileNotFoundException; import java.io.IOException; import java.io.RandomAccessFile; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; /* * Created by IntelliJ IDEA. * User: 木木 * Date: 2020/5/28 * Time: 21:55 */ public class BuffTest04 { public static void main(String[] args) { try( /*随机访问*/ RandomAccessFile raf = new RandomAccessFile(\u0026quot;test.txt\u0026quot;, \u0026quot;rw\u0026quot;); RandomAccessFile raf2 = new RandomAccessFile(\u0026quot;test2.txt\u0026quot;, \u0026quot;wr\u0026quot;); ) { //获取通道 FileChannel channel = raf.getChannel(); //分配指定大小指定缓冲区 ByteBuffer buf1 = ByteBuffer.allocate(100); ByteBuffer buf2 = ByteBuffer.allocate(1024); //分散读取 ByteBuffer[] bufs={buf1, buf2}; channel.read(bufs); for (ByteBuffer byteBuffer : bufs) { //切换成读模式 byteBuffer.flip(); } System.out.println(new String(bufs[0].array(), 0, bufs[0].limit())); System.out.println(\u0026quot;*********************************\u0026quot;); System.out.println(new String(bufs[1].array(), 1, bufs[1].limit())); System.out.println(\u0026quot;---------------聚集读取\u0026quot;); //获取通道 FileChannel channel1 = raf2.getChannel(); channel1.write(bufs); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } }  字符集Charset 编码:字符串-\u0026gt;字节数组。\n解码:字节数组-\u0026gt;字符串。\npackage com.mumulx.nio; import java.nio.ByteBuffer; import java.nio.CharBuffer; import java.nio.charset.CharacterCodingException; import java.nio.charset.Charset; import java.nio.charset.CharsetDecoder; import java.nio.charset.CharsetEncoder; /* * Created by IntelliJ IDEA. * User: 木木 * Date: 2020/5/28 * Time: 22:23 */ public class BuffTest05 { public static void main(String[] args) throws CharacterCodingException { //获取解码器 Charset charset = Charset.forName(\u0026quot;GBK\u0026quot;); //获取加密器 CharsetEncoder ce = charset.newEncoder(); //获取解码器 CharsetDecoder cd = charset.newDecoder(); CharBuffer charBuffer = CharBuffer.allocate(1024); charBuffer.put(\u0026quot;hahahha\u0026quot;); charBuffer.flip(); //编码加密 ByteBuffer buBuff = ce.encode(charBuffer); for (int i = 0; i \u0026lt;7 ; i++) { System.out.println(buBuff.get()); } buBuff.flip(); //编码解密 /* CharBuffer decode = cd.decode(buBuff); System.out.println(decode.toString());*/ CharBuffer decode = Charset.forName(\u0026quot;UTF-8\u0026quot;).newDecoder().decode(buBuff); System.out.println(decode.toString()); /*如果解码不是GBK的时候 会报错（中文会报错）*/ } }  NIO是通过通道(Channel)和缓冲(Buffer)进行操作的\n同步阻塞与同步非阻塞 NIO通道(传输数据) +缓冲区(存放数据) +直接缓冲区与非直接缓冲区\n非阻塞IO与阻塞IO区别\nIO (BIO)同步、阻塞IO\nNIO (1dk1.7之前)同步、 非阻塞IO\nJDK之后AIO (异步、非阻塞IO)\n伪异步形式缺点:没有真正解决阻塞IO核心。 缺点:占CUU内存 线程池:解决频繁创建线程，可以服用。\n/*多个连接*/ class TcpServer2 { public static void main(String[] args) throws IOException { System.out.println(\u0026quot;Tcp协议服务器端启动。。\u0026quot;); //创建服务端连接 ServerSocket serverSocket = new ServerSocket(8080); try { while (true) { //接收客户端请求阻塞功能 Socket accept = serverSocket.accept(); new Thread(()-\u0026gt;{ InputStream inputStream = null; try { inputStream = accept.getInputStream(); //将字节流转换成String类型 byte[] bytes = new byte[1024]; String result = new String(bytes, 0, inputStream.read(bytes)); System.out.println(\u0026quot;服务端接收客户端内容\u0026quot; + result); } catch (IOException e) { e.printStackTrace(); } },\u0026quot;new thread\u0026quot;); } } catch (IOException e) { e.printStackTrace(); } finally { serverSocket.close(); } } }  /*线程池*/ class TcpServer1 { public static void main(String[] args) throws IOException { System.out.println(\u0026quot;Tcp协议服务器端启动。。\u0026quot;); ExecutorService executorService = Executors.newCachedThreadPool(); //创建服务端连接 ServerSocket serverSocket = new ServerSocket(8080); try { while (true) { //接收客户端请求阻塞功能 Socket accept = serverSocket.accept(); executorService.execute(()-\u0026gt;{ InputStream inputStream = null; try { inputStream = accept.getInputStream(); //将字节流转换成String类型 byte[] bytes = new byte[1024]; String result = new String(bytes, 0, inputStream.read(bytes)); System.out.println(\u0026quot;服务端接收客户端内容\u0026quot; + result); OutputStream outputStream = accept.getOutputStream(); outputStream.write(\u0026quot;接收到请求\u0026quot;.getBytes()); } catch (IOException e) { e.printStackTrace(); } }); } } catch (IOException e) { e.printStackTrace(); } finally { serverSocket.close(); } } }  伪异步形式，不靠谱。线程池，没有真正核心解决阻塞IO问题\nNIO\u0026mdash;\u0026mdash;-同步非阻塞，用于网络相关\n选择器是管理通道的，在服务端。服务端直接与选择器进行通信\nIO(BIO()和NIO(区别:其本质就是阻塞和非阻塞的区别\n阻塞概念:应用程序在获取网络数据的时候，如果网络传输数据很慢，就会一直等待,直到传输完毕为止。\n非阻塞概念:应用程序直接可以获取已经准备就绪好的数据,无需等待。\nIO为同步阻塞形式,NIO为同步非阻塞形式, NIO并没有实现异步,在JDK1.7后升级NIO库包，支持异步非阻塞。\n模型NIO2. 0(AIO)。 BIO:同步阻塞式10,服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。\nNIO:同步非阻塞式IO,服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。\nAIO(NIO.2):异步非阻塞式IO,服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。\n同步时，应用程序会直接参与IO读写操作,并且我们的应用程序会直接阻塞到某一个方法上,直到数据准备就绪: 或者采用轮训的策略实时检查数据的就绪状态,如果就绪则获取数据。\n异步时,则所有的IO读写操作交给操作系统,与我们的应用程序没有直接关系，我们程序不需要关心IO读写，当操作系统完成了IO读写操作时,会给我们应用程序发送通知,我们的应用程序直接拿走数据极即可。\n伪异步\n由于BIO一个客户端需要一个线程去处理，因此我们进行优化，后端使用线程池来处理多个客户端的请求接入，形成客户端个数M:线程池最大的线程数N的比例关系，其中M可以远远大于N,通过线程池可以灵活的调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。\n原理:\n当有新的客户端接入时,将客户端的Socket封装成一个Task(该Task任务实现了java 的Runnable接口)投递到后端的线程池中进行处理，由 于线程池可以设置消息队列的大小以及线程池的最大值，因此，它的资源占用是可控的，无论多少个客户端的并发访问，都不会导致资源的耗尽或宕机。。\nIO模型关系\n    同步阻塞I/O(BIO) 伪异步I/O 非阻塞I/O(BIO) 异步I/O(AIO)     客户端个数：I/O线程 1:1 M:N(其中M可以大于N) M:(1个I/O线程处理多个客户端连接) M:0(不需要启动额外的I/O线程，被动回调)   I/O类型（阻塞） 阻塞I/O 阻塞I/O 非阻塞I/O 非阻塞I/O    选择器Key NIO的SelectionKey(选择键)\nSelectionKey.OP_ACCEPT;//可接收连接 SelectionKey.OP_CONNECT;//可连接 SelectionKey.OP_READ;//可读 SelectionKey.OP_WRITE;//可写  小结代码\npackage com.mumulx.nio; /* * Created by IntelliJ IDEA. * User: 木木 * Date: 2020/5/29 * Time: 10:42 */ import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.*; import java.util.Date; import java.util.Iterator; /* Nio异步通信*/ class NioClient { public static void main(String[] args) { System.out.println(\u0026quot;客户端已经启动\u0026quot;); try ( //1.创建socket通道 SocketChannel schannel = SocketChannel.open(new InetSocketAddress(\u0026quot;127.0.0.1\u0026quot;, 8080)); ){ //2.切换异步非阻塞 schannel.configureBlocking(false);//jdk1.7以上 客户端调用非阻塞是防止read方法不会阻塞 //3.指定缓冲区大小 ByteBuffer buff = ByteBuffer.allocate(1024); buff.put(new Date().toString().getBytes()); //4.切换到读取模式 buff.flip(); schannel.write(buff); //schannel.write(ByteBuffer.wrap(new Date().toString().getBytes())); buff.clear(); } catch (IOException e) { e.printStackTrace(); } } } /*NIO服务端 * * tcp协议：可以通过浏览器进行访问 * */ class NioServer{ public static void main(String[] args) { System.out.println(\u0026quot;服务端已经启动了。。。\u0026quot;); try { //1.创建服务通道 ServerSocketChannel sChannel = ServerSocketChannel.open(); //2.切换异步通信 sChannel.configureBlocking(false);//jdk1.7以上 //3.绑定连接 sChannel.bind(new InetSocketAddress(8080)); //4.获取选择器 Selector selector = Selector.open(); //5.将通道注册到选择器中 并监听已经接收到了的时间 sChannel.register(selector, SelectionKey.OP_ACCEPT); //6.轮询获取“已经准备就绪的事件” while (selector.select() \u0026gt; 0) { //7.获取当前选择器，有注册已经监听到事件 Iterator\u0026lt;SelectionKey\u0026gt; iterator = selector.selectedKeys().iterator(); while (iterator.hasNext()) { //8.获取准备就绪事件 SelectionKey sk = iterator.next(); //9.判断事件准备就绪 if (sk.isAcceptable()) { //10.若接收就绪，可以获取客户端连接 SocketChannel socketChannel = sChannel.accept(); //11.设置为阻塞事件 socketChannel.configureBlocking(false);//异步非阻塞IO 设置Bio的Socket accept = serverSocket.accept();不阻塞 //12.将该通道注册到服务器上 socketChannel.register(selector, SelectionKey.OP_READ); } else if (sk.isReadable()) { //13.获取当前选择“准备就绪”的通道 SocketChannel socketChannel = (SocketChannel)sk.channel(); //14.读取数据 int len = 0; ByteBuffer buffer = ByteBuffer.allocate(1024); while ((len = socketChannel.read(buffer)) \u0026gt; 0) { buffer.flip(); System.out.println(new String(buffer.array(), 0, len)); buffer.clear(); } } iterator.remove(); } } } catch (IOException e) { e.printStackTrace(); } } } public class NIOTest { }  NIO通过设置来实现非阻塞 客户端\n//2.切换异步非阻塞 schannel.configureBlocking(false);//jdk1.7以上 客户端调用非阻塞是防止read方法不会阻塞  bio\ninputStream = accept.getInputStream(); //将字节流转换成String类型 byte[] bytes = new byte[1024]; String result = new String(bytes, 0, inputStream.read(bytes));  服务端\n//11.设置为阻塞事件 socketChannel.configureBlocking(false);//异步非阻塞IO 设置Bio的Socket accept = serverSocket.accept();不阻塞  bio\n//接收客户端请求阻塞功能 Socket accept = serverSocket.accept();  一次请求做的事情\n单线程模式\nNetty 讲讲Netty的特点?\n高并发\nNetty是一 款基于NIO (Nonblocking I/O， 非阻塞I0)开发的网络通信框架，对比于BIO (Blocking I/O， 阻塞I0)，他的并发性能得到了很大提高。\n传输快\nNetty的传输快其实也是依赖了NIO的一一个特性一零拷贝。\n封装好 Netty封装了NI0操作的很多细节，提供易于使用的API.\n什么是Netty:\nNetty是一个基于JAVA NI0类库的异步通信框架，它的架构特点是:异步非阻塞、基于事件驱动、高性能、高可靠性和高可定制性。\n为什么netty? 传统NIO非阻塞代码bug、 进行一些封装。事件驱动\nnetty框架是一个通讯框架，NIO框架也是通讯框架。\nspringcloud使用的http协议\nNetty应用场景\n 分布式开源框架中dubbo、Zookeeper,RocketMQ底层rpc通讯使用就是netty。。 游戏开发中，底层使用netty通讯。。  netty特征是异步通讯框架、异步非阻塞、高可用、事件驱动。\ninetty应用场景\nrpc远程调用框架dubbo底层就是通过nettynetty用的底层优势nio。\nzk、消息中间(roketmq) 、主流rpc、通讯都会采用netty。\n游戏开发服务器端都是通过netty通讯。\n为什么选择了netty\n在本小节，我们总结下为什么不建议开发者直接使用JDK的NIO类库进行开发的原因:。 1)NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、 SocketChannel、ByteBuffer等;。 2)需要具备其它的额外技能做铺垫，例如熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序;。 3)可 靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等，NIO 编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大;。 4) JDK NIO的BUG，例如臭名昭著的epollbug，它会导致Selector空轮询，最终导致CPU100%。官方声称在JDK1.6版本的update18修复了该问题，但是直到JDK1.7版本该问题仍旧存在，只不过该bug发生概变低\n服务端 package com.mumulx.netty; import org.jboss.netty.bootstrap.ServerBootstrap; import org.jboss.netty.channel.*; import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory; import org.jboss.netty.handler.codec.string.StringDecoder; import org.jboss.netty.handler.codec.string.StringEncoder; import java.net.InetSocketAddress; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /* * Created by IntelliJ IDEA. * User: 木木 * Date: 2020/5/29 * Time: 11:35 */ /*快速重写父类方法快捷键alt+shift+s * ctrl+alt+r * */ class ServerHanlder extends SimpleChannelHandler { /*通道被关闭的时候会触发*/ @Override public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception { super.channelClosed(ctx, e); System.out.println(\u0026quot;channelClosed\u0026quot;); } /*必须要建立连接，关闭通道的时候才会触发*/ @Override public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception { super.channelDisconnected(ctx, e); System.out.println(\u0026quot;channelDisconnected\u0026quot;); } /*接受出现异常*/ @Override public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception { super.exceptionCaught(ctx, e); System.out.println(\u0026quot;exceptionCaught\u0026quot;); } /*接收客户端数据*/ @Override public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception { /**/ super.messageReceived(ctx, e); System.out.println(\u0026quot;messageReceived :参数：\u0026quot;); System.out.println(e.getMessage()); ctx.getChannel().write(\u0026quot;hello world\u0026quot;); } } public class NettyServer { public static void main(String[] args) { //1.创建服务对象 ServerBootstrap serverBootstrap = new ServerBootstrap(); //2.创建两个线程池，第一个监听端口号Nio监听 ExecutorService boos = Executors.newCachedThreadPool(); ExecutorService wook = Executors.newCachedThreadPool(); //3.将线程池放到工程中 serverBootstrap.setFactory(new NioServerSocketChannelFactory(boos,wook)); //4.设置管道工程 serverBootstrap.setPipelineFactory(new ChannelPipelineFactory() { @Override //设置管道 public ChannelPipeline getPipeline() throws Exception { ChannelPipeline pipeline = Channels.pipeline(); //传输数据的时候直接为string类型 pipeline.addLast(\u0026quot;decoder\u0026quot;, new StringDecoder()); pipeline.addLast(\u0026quot;encoder\u0026quot;,new StringEncoder()); //设置事件监听类 pipeline.addLast(\u0026quot;serverHanlder\u0026quot;, new ServerHanlder()); return pipeline; } }); //绑定端口号 serverBootstrap.bind(new InetSocketAddress(8080)); System.out.println(\u0026quot;服务器端已经被启动....\u0026quot;); /*//是非阻塞的 while (true) { try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026quot;每隔0.5秒打印......\u0026quot;); }*/ } }  客户端 package com.mumulx.netty; import org.jboss.netty.bootstrap.ClientBootstrap; import org.jboss.netty.bootstrap.ServerBootstrap; import org.jboss.netty.channel.*; import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory; import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory; import org.jboss.netty.handler.codec.string.StringDecoder; import org.jboss.netty.handler.codec.string.StringEncoder; import java.net.InetSocketAddress; import java.util.Scanner; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /* * Created by IntelliJ IDEA. * User: 木木 * Date: 2020/5/29 * Time: 16:46 */ class ClientHanlder extends SimpleChannelHandler { /*通道被关闭的时候会触发*/ @Override public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception { super.channelClosed(ctx, e); System.out.println(\u0026quot;channelClosed\u0026quot;); } /*必须要建立连接，关闭通道的时候才会触发*/ @Override public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception { super.channelDisconnected(ctx, e); System.out.println(\u0026quot;channelDisconnected\u0026quot;); } /*接受出现异常*/ @Override public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception { super.exceptionCaught(ctx, e); System.out.println(\u0026quot;exceptionCaught\u0026quot;); } /*接收客户端数据*/ @Override public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception { /**/ super.messageReceived(ctx, e); System.out.println(\u0026quot;messageReceived\u0026quot;); System.out.println(\u0026quot;服务端向客户端回复的内容\u0026quot;); System.out.println(e.getMessage()); } } public class NettyClient { public static void main(String[] args) { //1.创建服务对象 ClientBootstrap clientBootstrap = new ClientBootstrap(); //2.创建两个线程池，第一个监听端口号Nio监听 ExecutorService boos = Executors.newCachedThreadPool(); ExecutorService wook = Executors.newCachedThreadPool(); //3.将线程池放到工程中 clientBootstrap.setFactory(new NioClientSocketChannelFactory(boos,wook)); //4.设置管道工程 clientBootstrap.setPipelineFactory(new ChannelPipelineFactory() { @Override //设置管道 public ChannelPipeline getPipeline() throws Exception { ChannelPipeline pipeline = Channels.pipeline(); //传输数据的时候直接为string类型 pipeline.addLast(\u0026quot;decoder\u0026quot;, new StringDecoder()); pipeline.addLast(\u0026quot;encoder\u0026quot;,new StringEncoder()); //设置事件监听类 pipeline.addLast(\u0026quot;clientHanlder\u0026quot;, new ClientHanlder()); return pipeline; } }); //绑定端口号 ChannelFuture connect = clientBootstrap.connect(new InetSocketAddress(\u0026quot;127.0.0.1\u0026quot;, 8080)); Channel channel = connect.getChannel(); Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\u0026quot;请输入内容\u0026quot;); channel.write(scanner.next()); } } }  io与Nio的区别\n最大区别：非阻塞、通道、缓冲区\n长连接与短连接 [HTTP长连接、短连接究竟是什么\n粘包与拆包 netty5.0\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactId\u0026gt;network\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;com.mumulx\u0026lt;/groupId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;artifactId\u0026gt;nettywork01\u0026lt;/artifactId\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/io.netty/netty-all --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.netty\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;netty-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.0.0.Alpha2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.jboss.marshalling/jboss-marshalling --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.jboss.marshalling\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jboss-marshalling\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.19.GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.jboss.marshalling/jboss-marshalling-serial --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.jboss.marshalling\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jboss-marshalling-serial\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.19.GA\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt;  package com.mumulx; import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.*; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.string.StringDecoder; /* * Created by IntelliJ IDEA. * User: 木木 * Date: 2020/5/29 * Time: 19:30 */ public class NettyServer01 { public static void main(String[] args) { System.out.println(\u0026quot;服务端已经启动..........\u0026quot;); //1.创建两个线程池，一个负责接收客户端，一个进行传输 NioEventLoopGroup pGroup = new NioEventLoopGroup(); NioEventLoopGroup cGroup = new NioEventLoopGroup(); //2.创建辅助类 ServerBootstrap b = new ServerBootstrap(); b.group(pGroup,cGroup).channel(NioServerSocketChannel.class).option(ChannelOption.SO_BACKLOG,1024) //3.设置缓冲区与发送区大小 .option(ChannelOption.SO_SNDBUF,3*1024).option(ChannelOption.SO_RCVBUF,32*1024) .childHandler(new ChannelInitializer\u0026lt;SocketChannel\u0026gt;() { @Override protected void initChannel(SocketChannel socketChannel) throws Exception { socketChannel.pipeline().addLast(new StringDecoder());//设置返回结果为String类型 socketChannel.pipeline().addLast(new ServerHandler()); } }); try { //启动 ChannelFuture cf = b.bind(8080).sync(); //关闭 cf.channel().closeFuture().sync(); pGroup.shutdownGracefully(); cGroup.shutdownGracefully(); } catch (InterruptedException e) { e.printStackTrace(); } } } class ServerHandler extends ChannelHandlerAdapter { /*当通道被调用，执行方法（拿到数据）*/ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { String value = (String) msg; System.out.println(\u0026quot;服务器端收到客户端的msg:\u0026quot;+value); //ctx.writeAndFlush(\u0026quot;hao\u0026quot;); ctx.write(\u0026quot;hahah \u0026quot;); ctx.flush(); super.channelRead(ctx, msg); } }  package com.mumulx; import io.netty.bootstrap.Bootstrap; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.ChannelInitializer; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; import io.netty.handler.codec.string.StringDecoder; /* * Created by IntelliJ IDEA. * User: 木木 * Date: 2020/5/29 * Time: 19:48 */ /*长连接：与服务端连接后不断开 * * 客户端端断开后客户端端会报异常io.netty.channel.DefaultChannelPipeline$TailContext exceptionCaught（关闭时没有四次挥手） * * * */ class ClientHandler extends ChannelHandlerAdapter { /*接受数据*/ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { super.channelRead(ctx, msg); String value = (String) msg; System.out.println(\u0026quot;client msg:\u0026quot; + value); } } public class NettyClient01 { public static void main(String[] args) { System.out.println(\u0026quot;客户端已经启动：\u0026quot;); //创建负责接受客户端连接 NioEventLoopGroup pGroup = new NioEventLoopGroup(); Bootstrap b = new Bootstrap(); b.group(pGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer\u0026lt;SocketChannel\u0026gt;() { @Override protected void initChannel(SocketChannel socketChannel) throws Exception { socketChannel.pipeline().addLast(new StringDecoder()); socketChannel.pipeline().addLast(new ClientHandler()); } }); try { ChannelFuture cf = b.connect(\u0026quot;127.0.0.1\u0026quot;, 8080).sync(); /*这是两次请求*/ cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja01\u0026quot;.getBytes())); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja02\u0026quot;.getBytes())); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja03 \u0026quot;.getBytes())); Thread.sleep(1000); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja04 \u0026quot;.getBytes())); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja05 \u0026quot;.getBytes())); //等待客户端端口号关闭 cf.channel().closeFuture().sync(); pGroup.shutdownGracefully(); } catch (InterruptedException e) { e.printStackTrace(); } } }  为什么时两次请求呢？底层会优化。自动粘包\n一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和封包问题。。 下面可以看一张图，是客户端向服务端发送包:。\n1.第一种情况，Data1和Data2都分开发送到了Server端，没有产生粘包和拆包的情况。 2.第二种情况，bata1和Data2数据粘在了一起，打成了一个大的包发送到Server端,这个情况就是粘包。 3.第三种情况，Data2被分离成Data2_ 1和Data2_ 2， 并且Data2 1在Data1之前到达了服务端，这种情况就产生了拆包。\n由于网络的复杂性，可能数据会被分离成N多个复杂的拆包/粘包的情况，所以在做TCP服务器的时候就需要首先解决拆包\n解决办法.\n消息定长，报文大小固定长度，不够空格补全，发送和接收方遵循相同的约定，这样即使粘包了通过接收方编程实现获取定长报文也能区分。(很少使用)\nsc.pipeline().addLast(new FixedLengthFrameDecoder(10));//达到10个长度就发  包尾添加特殊分隔符，例如每条报文结東都添加回车换行符(例如FTP协议)或者指定特殊字符作为报文分隔符，接收方通过特殊分隔符切分报文区分。\nb.group(pGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer\u0026lt;SocketChannel\u0026gt;() { @Override protected void initChannel(SocketChannel socketChannel) throws Exception { /*解决粘包 客户端服务端都需要添加*/ ByteBuf buf = Unpooled.copiedBuffer(\u0026quot;_mumu\u0026quot;.getBytes()); socketChannel.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,buf)); socketChannel.pipeline().addLast(new StringDecoder()); socketChannel.pipeline().addLast(new ClientHandler()); } });  将消息分为消息头和消息体，消息头中包含表示信息的总长度(或者消息体长度)的字段，\n将消息分为消息头和消息体，消息头中包含表示信息的总长度(或者消息体长度)的字段，\npackage com.mumulx; import io.netty.bootstrap.Bootstrap; import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelHandlerAdapter; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.ChannelInitializer; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; import io.netty.handler.codec.DelimiterBasedFrameDecoder; import io.netty.handler.codec.string.StringDecoder; /* * Created by IntelliJ IDEA. * User: 木木 * Date: 2020/5/29 * Time: 19:48 */ /*长连接：与服务端连接后不断开 * * 客户端端断开后客户端端会报异常io.netty.channel.DefaultChannelPipeline$TailContext exceptionCaught（关闭时没有四次挥手） * * * */ class ClientHandler extends ChannelHandlerAdapter { /*接受数据*/ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { super.channelRead(ctx, msg); String value = (String) msg; System.out.println(\u0026quot;client msg:\u0026quot; + value); } } public class NettyClient01 { public static void main(String[] args) { System.out.println(\u0026quot;客户端已经启动：\u0026quot;); //创建负责接受客户端连接 NioEventLoopGroup pGroup = new NioEventLoopGroup(); Bootstrap b = new Bootstrap(); b.group(pGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer\u0026lt;SocketChannel\u0026gt;() { @Override protected void initChannel(SocketChannel socketChannel) throws Exception { /*解决粘包 客户端与服务端都需要添加 当数据中含有后缀时才接受，否则阻塞掉 */ ByteBuf buf = Unpooled.copiedBuffer(\u0026quot;_mumu\u0026quot;.getBytes());// socketChannel.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,buf)); socketChannel.pipeline().addLast(new StringDecoder()); socketChannel.pipeline().addLast(new ClientHandler()); } }); try { ChannelFuture cf = b.connect(\u0026quot;127.0.0.1\u0026quot;, 8080).sync(); /*这是两次请求 cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja01\u0026quot;.getBytes())); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja02\u0026quot;.getBytes())); Thread.sleep(1000); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja03 \u0026quot;.getBytes())); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja04 \u0026quot;.getBytes())); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja05 \u0026quot;.getBytes())); *//* 这是一次请求 cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja01\u0026quot;.getBytes())); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja02\u0026quot;.getBytes())); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja03 \u0026quot;.getBytes())); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja04 \u0026quot;.getBytes())); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja05 \u0026quot;.getBytes())); */ /*这是五次请求 通过后缀解决粘包问题 cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja01_mumu\u0026quot;.getBytes())); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja02_mumu\u0026quot;.getBytes())); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja03_mumu\u0026quot;.getBytes())); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja04_mumu\u0026quot;.getBytes())); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja05_mumu\u0026quot;.getBytes()));*/ //cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja06\u0026quot;.getBytes()));//这样服务端是接受不到这个数据的 ，会阻塞掉 /*这样就发过去了 二者会拼接*/ cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;hahja06\u0026quot;.getBytes())); cf.channel().writeAndFlush(Unpooled.wrappedBuffer(\u0026quot;_mumu\u0026quot;.getBytes())); //等待客户端端口号关闭 cf.channel().closeFuture().sync(); pGroup.shutdownGracefully(); } catch (InterruptedException e) { e.printStackTrace(); } } }  TcP粘包拆包间题\nnetty当中的解码器\n FixedLengthFrameDecoder 基于固定长度的解码器 LineBasedFrameDecoder基于行(\\n,\\r) 的解码器 DelimiterBasedFrameDecoder 基于分隔符的解码器(二 or 三failFast属性判断是否抛出异常，必然成立一个将抛出常) 一：找到分隔符，超过最大长度，直接跳过本次要读取的数据(跳过到分隔符之前的数据)，抛出异常 二: 没有找到分割符，超过最大长度，直接跳过整个buffer中的数据，设置开启丢弃模式，根据fai1Fast属性判断是否马上抛出异常 三：找到了分隔符，处于了丢弃模式，设置关闭丢弃模式，跳过本次要读取的数据(跳过到分隔符之前的数据)，设置已经丢弃的字节长度为0，根据fai1Fast属性判断是否马上抛出异常 四:没有找到分割符，没有处于丢弃模式，累加丢弃的字节，丢弃整个buffer中的数据 LengthFieldBasedFrameDecoder 基于长度的解码器  Netty 的线程模型是什么? 这个要看我们如何编码; NioEventLoopGroup默 认线程数为cpu核心数的两倍 如果用了两个NioEventloopGroup，且指定工作线程数不为一，则是主从多线程模型; 如果用了两个NioEventLoopGroup，且指定工作线程数为一，则是主从单线程模型 如果用了一个NioEventLoopGroup，且指定线程数不为一，则是多线程模型 如果用了一个NioEventLoopGroup，且指定线程数为一，则是单线程模型\nnetty bossGroup默认为CPU核 数的两陪的作用?\nhttps://stackoverflow.com/guestions/34275138/why-do-we-really-need-multiple-netty-boss-threads  Java通过Executors提供四种线程池，分别为:\n  newCachedThreadPool创建一个可 缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool创建一个定长线程池， 可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。 newsingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO， 优先级)执行。   序列化协议与自定义序列化协议 序列化定义\n序列化(serialization)就是将对象序列化为二进制形式(字节数组)，一般也将序列化称为编码(Encode) ,主要用于网络传输、数据持久化等;。\n反序列化(deserialization) 则是将从网络、磁盘等读取的字节数组还原成原始对象，以便后续业务的进行, 一般也将反序列化称为解码(Decode)，主要用于网絡传输对象的解码，以便完成远程调用。\n序列化协议“鼻祖\u0026rdquo; 我知道的第一种序列化协议就是Java 默认提供的序列化机制，需要序列化的Java对象只需要实现Serializable / Externalizable接口并生成序列化ID,这个类就能够通过Objectlnput 和ObjectQutput 序列化和反序列化，若对Java默认的序列化协议不了解，或是遗忘了，请参考:序列化详解。\n但是Java默认提供的序列化有很多问题，主要有以下几个缺点:。\n无法跨语言:我认为这对于Java序列化的发展是致命的“失误”，因为Java序列化后的字节数组，其它语言无法进行反序列化;\n序列化后的码流太大:相对于目前主流的序列化协议，Java 序列化后的码流太大;\n序列化的性能差:由于Java序列化采用同步阻塞|0,相对于目前主流的序列化协议，它的效率非常差。\n影响序列化性能的关键因素\n 序列化后的码流大小(网络带宽的占用) ; 序列化的性能(CPU资源占用) 是否支持跨语言(异构系统的对接和开发语言切换)。。  什么是序列化?\n序列化：将对象序列化成二进制文件，保存在硬盘上。\n反序列：将二进制文件(硬盘上)，反序列化成对象。\n序列化时要定义个final static:\n远程调用(网络通讯)\nhibernate\nrpc远程调用的时候现在springcloud (微服务)、dubbo (序列化)接口调用 \u0026ndash;服务器\npublic interface UserInterface { public void add()); }  客户端\n@auto private UserInterface userInterface;  dubbo netty\n序列化的协议：json、xml（数据交换格式）\n几种流行的序列化协议比较. XML (1) 定义:\nXML (Extensible Markup Language)是一种常用的序列化和反序列化协议，它历史悠久， 从1998年的1.0 版本被广泛使用至今。。\n(2)优点\n 人机可读性好。 可指定元素或特性的名称  (3)缺点。\n 序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息。 类必须有一个将由XmISerializer 序列化的默认构造函数。 只能序列化公共属性和字段, 不能序列化方法。 文件庞大，文件格式复杂，传输点带宽。  (4)使用场景。\n 当做配置文件存储数据。 实时数据转换。  JSON. (1)定义:\nJSON(JavaScript Object Notation, JS对象标记)是一种轻量级的数据交换格式。它基于ECMAScript (w3c制定的is规范)的一个子集，JSON 采用与编程语言无关的文本格式，但是也使用了类C语言(包括C，C++， C#, Java，JavaScript， Perl, Python 等)的习惯，简洁和清晰的层次结构使得JSON 成为理想的数据交换语言。\n(2)优点\n 前后兼容性高v 数据格式比较简单，易于读写。 序列化后数据较小，可扩展性好，兼容性好。 与XML相比，其协议比较简单，解析速度比较快,  (3) 缺点。\n 数据的描述性比XML差， 不适合性能要求为ms级别的情况。 额外空间开销比较大。  (4)适用场景(可替代XML)\n 跨防火墙访问。 可调式性要求高的情况。 基于Web browser的Ajax请求, 传输数据量相对小，实时性要求相对低(例如秒級别)的服务。  Fastjson. (1)定义\nFastison是一个Java语言编写的高性能功能完善的JSON库。它采用一-种“假定有序快速匹配”的算法,把JSON Parse的性能提升到极致。\n(2)优点。\n 接口简单易用。 目前java语言中最快的json库。  (3)缺点\n 过于注重快，而偏离了“标准”及功能性。 代码质量不高，文档不全。  (4)适用场景。\n 协议交互。 Web输出。 Android客户端  Thrift (1) 定义 Thrift并不仅仅是序列化协议，而是一个RPC框架。它可以让你选择客户端与服务端之间传输通信协议的类别，即文本(text)和二进制(binary)传输协议,为节约带宽，提供传输效率，- -般情况下使用二进制类型的传输协议。\n(2)优点\n 序列化后的体积小,速度快。 支持多种语言和丰富的数据类型。 对于数据字段的增删具有较强的兼容性。 支持二进制压縮編码。  (3)缺点。\n 使用者较少。 跨防火墙访问时，不安全。 不具有可读性，调试代码时相对困难。 不能与其他传输层协议共同使用(例如HTTP)。 无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议。  (4)适用场景。\n分布式系统的RPC解决方案\nAvro. (1) 定义\nAvro属于Apache Hadoop的一个子项目。Avro 提供两种序列化格式: JSON 格式或者Binary 格式。Binary格式在空间开销和解析性能方面可以和Protobuf媲美，Avro的产生解决了JSON的冗长和没有IDL的问题, (2)优点\n 支持丰富的数据类型。 简单的动态语言结合功能 具有自我描述属性 提高了数据解析速度w 快速可压縮的二进制数据形式 可以实现远程过程调用RPC 支持跨编程语言实现。  (3) 缺点。\n 对于习惯于静态类型语言的用户不直观。  (4)适用场景\n在Hadoop.中做Hive、Pig 和MapReduce的持久化数据格式。\nProtobuf. (1)定义\nprotocol buffers由爸歌开源而来，在爸歌内部久经考验。它将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POIO对象和Protobuf相关的方法和属性。\n(2)优点\n 序列化后码流小，性能高+ 结构化数据存储格式(XMLJSON等)。 通过标识字段的顺序，可以实现协议的前向兼容 结构化的文档更容易管理和维护。  (3) 缺点。\n 需要依赖于工具生成代码。 支持的语言相对较少，官方只支持Java、C++、Python+  (4)适用场景。\n 对性能要求高的RPC调用。 具有良好的跨防火墙的访问属性。 适合应用层对象的持久化。   其它   protostuff基于protobuf 协议，但不需要配置proto文件，直接导包即 Jboss marshaling可以直接序列化java类，无须 实java.io.Serializable接口。 Message pack 一个高效的二进制序列化格式w Hessian采用二进制协议的轻量級remotingonhttp工具。 kryo基于protobuf 协议,只支持java语言,需要注册(Registration),然后序列化(Output) ,反序列化(Input)。   性能比较 时间\n空间\n析上图知：\n XML序列化（Xstream）无论在性能和简洁性上比较差。 Thrift与Protobuf相比在时空开销方面都有一定的劣势。 Protobuf和Avro在两方面表现都非常优越。  9、选型建议 不同的场景适用的序列化协议：\n 对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。\n 基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。\n 对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。\n 当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。\n 对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在Hadoop子项目里，Avro会是更好的选择。\n 由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。\n 对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯。\n 如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。\n 如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。\n  何时接受客户端请求? 服务端(reactor线程)启动后就可以接收\n何时注册接受Socket 并注册到对应的EventLoop管理的selector ? 在channel通道创建和初始化完毕后，会通过group. register ()方法将channel通道注册到EventLoop线程池中;从线程池中轮询获取一 个线程EventLoop并与之绑定;而EventLoop线 程池会绑定一 个selector选择器\n客户端如何进行初始化?\n何时创建的DefaultChannelPipeline ? 服务端channel被反射创建时被创建\nByteBuf的分类: Pooled和Unpooled\u0026ndash;》Pooled从 已经分配好的内存取内存Unpooled新创建一块内存\nUnsafe和非Unsafe\u0026ndash;》Unsafe依赖于jdk底层Unsafe对象非Unsafe不依赖于jdk底层Unsafe对象\nHeap和Direct\u0026ndash;》Heap底层就是byte数组Direct依赖于Nio的ByteBuffer创建出DirectByteBuffer,堆外内存\nChannel与Socket是什么 关系?\nSocket:网络上的两个程序通过一一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket,\nChannel:一个链接，它提供了如下的功能。\n 获取当前链接的状态 配置当前链接参数 进行read, write, connect, bind等通道支持的操作。 该Channel关联的ChannelPipeLine处理所有的I0事件和绑定在这个channel的请求  channel与EventLoop是什么关系?\n一个Channe1在它的生命周期内只注册于一个EventLoop;\n一个EventLoop可能会被分配给一 个或多个Channel\nChannel与ChannelPipeline是什么关系?\n一个Channel包含了一个ChannelPipeline,而ChannelPipeline中又维护了一个由Channe lHandlercontext组成的双向链表， 这个链表的头是HeadContext,链表的尾是TailContext,并且么个ChannelHandlerContext中又关联着- - 个ChannelHandler; EventLoop与EventLoopGroup是什么关系? NioEventLoopGroup是NioEventLoop的组合，用于管理NioEventLoop\nEventLoop接口用于处理连接的生命周期中所发生的事件。一个EventLoop在它的生命周期内只和一一个Thread绑定。所有由EventLoop处理的I/0事件都将在它专有的Thread上被处理\n","id":2,"section":"posts","summary":"网络通信基础 Socket入门 什么是Socket? Socket就是为网络服务提供的一种机制。 通讯的两端都有Sokcet. 网络通讯其实就是Sok","tags":["Java"],"title":"网络通信与NIO","uri":"https://mumulx.github.io/2020/05/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8Enio/","year":"2020"},{"content":" 感谢该项目的开源从中学到了很多的知识，对于java也有了更深的了解\n已经看了两遍，里面写的很好，从中收获了跟多，也认识到了自己的许多不足。对于其中的知识还是有很多的不解，希望自己慢慢的进步。值得在看几遍，肯定会收获更多的知识\n原书地址\n第三章 万物皆对象 数据存储 那么，程序在运行时是如何存储的呢？尤其是内存是怎么分配的。有5个不同的地方可以存储数据：\n 寄存器（Registers）最快的存储区域，位于 CPU 内部 0。然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹（另一方面，C/C++ 允许开发者向编译器建议寄存器的分配）。 栈内存（Stack）存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存，这是一种快速有效的内存分配方法，速度仅次于寄存器。创建程序时，Java 系统必须准确地知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些 Java 数据，特别是对象引用，但 Java 对象却是保存在堆内存的。 堆内存（Heap）这是一种通用的内存池（也在 RAM 区域），所有 Java 对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。创建一个对象时，只需用 new 命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间（如果可以用 Java 在栈内存上创建对象，就像在 C++ 中那样的话）。随着时间的推移，Java 的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。 常量存储（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，可考虑将它们置于只读存储器 ROM （只读存储器，Read Only Memory）中 0。 非 RAM 存储（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：（1）序列化对象：对象被转换为字节流，通常被发送到另一台机器；（2）持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于 RAM 的对象。Java 为轻量级持久化提供了支持。而诸如 JDBC 和 Hibernate 这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。  基本类型的存储 有一组类型在 Java 中使用频率很高，它们需要特殊对待，这就是 Java 的基本类型。之所以这么说，是因为它们的创建并不是通过 new 关键字来产生。通常 new 出来的对象都是保存在堆内存中的，以此方式创建小而简单的变量往往是不划算的。所以对于这些基本类型的创建方法，Java 使用了和 C/C++ 一样的策略。也就是说，不是使用 new 创建变量，而是使用一个“自动”变量。 这个变量直接存储\u0026rdquo;值\u0026rdquo;，并置于栈内存中，因此更加高效。\nJava 确定了每种基本类型的内存占用大小。 这些大小不会像其他一些语言那样随着机器环境的变化而变化。这种不变性也是 Java 更具可移植性的一个原因。\n为什么Java中int型数据取值范围是[-2^{31}, 2^{31}-1]\n1Byte=8bit(一个字节占8位)\n   基本类型 大小 最小值 最大值 包装类型     boolean — — — Boolean   char 16 bits/2Byte Unicode 0 Unicode 216 -1 Character   byte 8 bits/1Byte -2^7 +2^7-1 Byte   short 16 bits/2Byte - 2^15 + 2^15 -1 Short   int 32 bits/4Byte - 2^31 + 2^31 -1 Integer   long 64 bits/8Byte - 2^63 + 2^63 -1 Long   float 32 bits/4Byte IEEE754 IEEE754 Float   double 64 bits/8Byte IEEE754 IEEE754 Double   void — — — Void    基本类型默认值 如果类的成员变量（字段）是基本类型，那么在类初始化时，这些类型将会被赋予一个初始值。\n   基本类型 初始值     boolean false   char \\u0000 (null)   byte (byte) 0   short (short) 0   int 0   long 0L   float 0.0f   double 0.0d    这些默认值仅在 Java 初始化类的时候才会被赋予。这种方式确保了基本类型的字段始终能被初始化（在 C++ 中不会），从而减少了 bug 的来源。但是，这些初始值对于程序来说并不一定是合法或者正确的。 所以，为了安全，我们最好始终显式地初始化变量。【局部变量一定要赋初值，全局变量不一定要赋初值】\n对于 Long 型数值，结尾使用大写 L 或小写 l 皆可（不推荐使用 l，因为容易与阿拉伯数值 1 混淆）。大写 F 或小写 f 表示 float 浮点数。大写 D 或小写 d 表示 double 双精度。\n下划线 Java 7 中有一个深思熟虑的补充：我们可以在数字字面量中包含下划线 _，以使结果更清晰。这对于大数值的分组特别有用。代码示例：\n// operators/Underscores.java public class Underscores { public static void main(String[] args) { double d = 341_435_936.445_667; System.out.println(d); int bin = 0b0010_1111_1010_1111_1010_1111_1010_1111; System.out.println(Integer.toBinaryString(bin)); System.out.printf(\u0026quot;%x%n\u0026quot;, bin); // [1] long hex = 0x7f_e9_b7_aa; System.out.printf(\u0026quot;%x%n\u0026quot;, hex); } }复制ErrorOK!  输出结果:\n3.41435936445667E8 101111101011111010111110101111 2fafafaf 7fe9b7aa复制ErrorOK!  下面是合理使用的规则：\n 仅限单 _，不能多条相连。 数值开头和结尾不允许出现 _。 F、D 和 L的前后禁止出现 _。 二进制前导 b 和 十六进制 x 前后禁止出现 _。  [1] 注意 %n的使用。熟悉 C 风格的程序员可能习惯于看到 \\n 来表示换行符。问题在于它给你的是一个“Unix风格”的换行符。此外，如果我们使用的是 Windows，则必须指定 \\r\\n。这种差异的包袱应该由编程语言来解决。这就是 Java 用 %n 实现的可以忽略平台间差异而生成适当的换行符，但只有当你使用 System.out.printf() 或 System.out.format() 时。对于 System.out.println()，我们仍然必须使用 \\n；如果你使用 %n，println() 只会输出 %n 而不是换行符。\n对象作用域 Java 对象与基本类型具有不同的生命周期。当我们使用 new 关键字来创建 Java 对象时，它的生命周期将会超出作用域。因此，下面这段代码示例：\n{ String s = new String(\u0026quot;a string\u0026quot;); } // 作用域终点复制ErrorOK!  上例中，引用 s 在作用域终点就结束了。但是，引用 s 指向的字符串对象依然还在占用内存。在这段代码中，我们无法在这个作用域之后访问这个对象，因为唯一对它的引用 s 已超出了作用域的范围。在后面的章节中，我们还会学习怎么在编程中传递和复制对象的引用。\n只要你需要，new 出来的对象就会一直存活下去。 相比在 C++ 编码中操作内存可能会出现的诸多问题，这些困扰在 Java 中都不复存在了。在 C++ 中你不仅要确保对象的内存在你操作的范围内存在，还必须在使用完它们之后，将其销毁。\n那么问题来了：我们在 Java 中并没有主动清理这些对象，那么它是如何避免 C++ 中出现的内存被填满从而阻塞程序的问题呢？答案是：Java 的垃圾收集器会检查所有 new 出来的对象并判断哪些不再可达，继而释放那些被占用的内存，供其他新的对象使用。也就是说，我们不必担心内存回收的问题了。你只需简单创建对象即可。当其不再被需要时，能自行被垃圾收集器释放。垃圾回收机制有效防止了因程序员忘记释放内存而造成的“内存泄漏”问题。\n== 和 != 比较的是对象引用，\n那么怎么比较两个对象的内容是否相同呢？你必须使用所有对象（不包括基本类型）中都存在的 equals() 方法，下面是如何使用 equals() 方法的示例：\nMath 库的静态方法 random()。该方法的作用是产生 0 和 1 之间 (包括 0，但不包括 1) 的一个 double 值。\n第六章 初始化和清理 在 Java 中，类的设计者通过构造器保证每个对象的初始化。如果一个类有构造器，那么 Java 会在用户使用对象之前（即对象刚创建完成）自动调用对象的构造器方法，从而保证初始化。\njvm new 字节码\njavanew一个对象的步骤\nthis创建时机\n返回值的重载 经常会有人困惑，\u0026rdquo;为什么只能通过类名和参数列表，不能通过方法的返回值区分方法呢?\u0026ldquo;。例如以下两个方法，它们有相同的命名和参数，但是很容易区分：\nvoid f(){} int f() {return 1;}复制ErrorOK!  有些情况下，编译器很容易就可以从上下文准确推断出该调用哪个方法，如 int x = f()。\n但是，你可以调用一个方法且忽略返回值。这叫做调用一个函数的副作用，因为你不在乎返回值，只是想利用方法做些事。所以如果你直接调用 f()，Java 编译器就不知道你想调用哪个方法，阅读者也不明所以。因为这个原因，所以你不能根据返回值类型区分重载的方法。为了支持新特性，Java 8 在一些具体情形下提高了猜测的准确度，但是通常来说并不起作用。\n假设现在在方法内部，你想获得对当前对象的引用。但是，对象引用是被秘密地传达给编译器——并不在参数列表中。方便的是，有一个关键字: this 。this 关键字只能在非静态方法内部使用。当你调用一个对象的方法时，this 生成了一个对象引用。你可以像对待其他引用一样对待这个引用。如果你在一个类的方法里调用其他该类中的方法，不要使用 this，直接调用即可，this 自动地应用于其他方法上了。\n在构造器中调用构造器 public class Flower { int petalCount = 0; String s = \u0026quot;initial value\u0026quot;; Flower(int petals) { petalCount = petals; System.out.println(\u0026quot;Constructor w/ int arg only, petalCount = \u0026quot; + petalCount); } Flower(String ss) { System.out.println(\u0026quot;Constructor w/ string arg only, s = \u0026quot; + ss); s = ss; } Flower(String s, int petals) { this(petals); //- this(s); // Can't call two! this.s = s; // Another use of \u0026quot;this\u0026quot; System.out.println(\u0026quot;String \u0026amp; int args\u0026quot;); } Flower() { this(\u0026quot;hi\u0026quot;, 47); System.out.println(\u0026quot;no-arg constructor\u0026quot;); } void printPetalCount() { //- this(11); // Not inside constructor! System.out.println(\u0026quot;petalCount = \u0026quot; + petalCount + \u0026quot; s = \u0026quot; + s); } public static void main(String[] args) { Flower x = new Flower(); x.printPetalCount(); } }  从构造器 Flower(String s, int petals) 可以看出，其中只能通过 this 调用一次构造器。另外，必须首先调用构造器，否则编译器会报错。这个例子同样展示了 this 的另一个用法。参数列表中的变量名 s 和成员变量名 s 相同，会引起混淆。你可以通过 this.s 表明你指的是成员变量 s，从而避免重复。你经常会在 Java 代码中看到这种用法，同时本书中也会多次出现这种写法。在 printPetalCount() 方法中，编译器不允许你在一个构造器之外的方法里调用构造器。\nstatic 的含义 记住了 this 关键字的内容，你会对 static 修饰的方法有更加深入的理解：static 方法中不会存在 this。你不能在静态方法中调用非静态方法（反之可以）。静态方法是为类而创建的，不需要任何对象。事实上，这就是静态方法的主要目的，静态方法看起来就像全局方法一样，但是 Java 中不允许全局方法，一个类中的静态方法可以被其他的静态方法和静态属性访问。一些人认为静态方法不是面向对象的，因为它们的确具有全局方法的语义。使用静态方法，因为不存在 this，所以你没有向一个对象发送消息。的确，如果你发现代码中出现了大量的 static 方法，就该重新考虑自己的设计了。然而，static 的概念很实用，许多时候都要用到它。至于它是否真的\u0026rdquo;面向对象\u0026rdquo;，就留给理论家去讨论吧。\n垃圾回收器 类的成员变量会再程序初始时赋一个初始值，而方法的局部变量就不会被赋初值\n多态 Java中除静态和final方法（private方法也是隐式的final）外，其他所有方法都是后期绑定。这意味着通常情况下，我们不需要判断后续绑定是否会发生-它自动发生。\nprivate方法只可以在类的内部使用，在类外根本访问不到， 而final方法可以在类外访问，但是不可以重写该方法，就是说可以使用该方法的功能但是不可以改变其功能，这就是private方法和final方法的最大区别\n为什么将一个对象指明为 final ？正如前一章所述，它可以防止方法被重写。但更重要的一点可能是，它有效地”关闭了“动态绑定，或者说告诉编译器不需要对其进行动态绑定。这可以让编译器为 final 方法生成更高效的代码。然而，大部分情况下这样做不会对程序的整体性能带来什么改变，因此最好是为了设计使用 final，而不是为了提升性能而使用。\nShape s = new Circle();  这会创建一个 Circle 对象，引用被赋值给 Shape 类型的变量 s，这看似错误（将一种类型赋值给另一种类型），然而是没问题的，因此从继承上可认为圆(Circle)就是一个形状(Shape)。因此编译器认可了赋值语句，没有报错。\n假设你调用了一个基类方法（在各个派生类中都被重写）：\ns.draw()复制ErrorOK!  你可能再次认为 Shape 的 draw() 方法被调用，因为 s 是一个 Shape 引用——编译器怎么可能知道要做其他的事呢？然而，由于后期绑定（多态）被调用的是 Circle 的 draw() 方法，这是正确的。\nprivate 方法可以当作是 final 的，结论是只有非私有方法才能被重建，但得小心重新改写私有方法的现象，编译器不报错，但不会按我们所预期的执行。为了清晰起见，派生类中的方法名采用与基类中私有方法名不同的命名。\n如果一个方法是静态（static）的，它的行为就不具有多态性：字类重写了父类的static方法，子类向上转型时，昂对新调用的方法是父类的静态方法。静态的方法只与类关联，与个别的对象无关。（静态方法会和类一起放到方法区中）\n在派生类的构造过程中总会调用基类的构造器。初始化会自动按继承层次结构上移，因此每个基类的构造器都会被调用到。这样做是可行的，因为构造器存在特殊的任务：检查对象是否被正确地构造。由于属性通常声明为私有，您必须假定派生类只能访问自己的成员而不能访问基类的成员。只有基类的构造器拥有适当的知识和权限。来初始化自身的元素。因此，必须获得调用所有构造器；否则就不能构造完整的对象。这就是编译器强制每个派生类部分必须调用构造器的原因。如果没有无参构造器，编译器就会报错（当类中排除构造器时，编译器会自动合成一个无参构造器）。\n磨对象的构造器调用顺序如下：\n 基类构造器被调用。这个步骤被递归归零重复，这样一来类层次的顶级父类会被最先构造，然后是它的派生类，以此类推，直到最容易的派生类。 按声明顺序初始化成员。 称为派生类构造器的方法体。  在构造器中必须确保所有的成员都已经完成。唯一能保证这点的方法就是首先调用基类的构造器。然后，在派生类的构造器中，所有你可以访问的基类成员都已经已经初始化。另一个在构造器中能知道所有成员都是有效的理由是：无论何时有可能的话，你应该在所有成员对象（通过组合将对象放置类中）定义处初始化它们（例如，示例中的b，c和l）。如果遵循这条实践，就可以帮助确保所有的基类成员和当前对象的成员对象都已经初始化。\n销毁的顺序应该与初始化的顺序相反，以防一个对象依赖另一个对象。对于属性来说，就这是因为因为基类（遵循C ++析构函数的形式），首先进行派生类的清理工作，然后才是基类的清理。派生类的清理可能调用基类的一些方法，所以基类组件这时得存活，不能过早地被销毁。输出显示了，Frog对象的所有部分都是按照创建的逆序销毁的。\n字类继承了父类，并重写了父类中的某一个方法，父类在构造函数中调用了该方法，在子类初始化时，父类构造其中调用的方法是字类重写过的方法。在对象初始化前，先对类中的变量进行初始化（0或与0等价的变量）\n初始化的实际过程是：\n 在所有事发生前，分配给对象的存储空间会被初始化为二进制0。 如前所述调用基类构造器。此时调用重写后的draw()方法（是的，在调用RoundGraph构造器之前调用），由步骤1可知，radius的值为0。 按声明顺序初始化成员。 最终调用派生类的构造器。  因此，编写构造器有一条良好的规范：做尽量少的事让对象进入良好状态。如果有可能的话，尽量不要调用类中的任何方法。在基类的构造器中能安全调用的只有基类的最后的方法（这也适用于可被看作是最后的私有方法）。这些方法不能被重写，因此不会产生意想不到的结果。你可能无法永远遵循这条规范，但应该朝着它努力。\nJava 5中约会了协变返回类型，这表示派生类的被重写方法可以返回基类方法返回类型的派生类型：\n学习过多态之后，一切看似都可以被继承，因为多态有助于简化的工具。这会给设计带来负担。事实上，如果利用现有类创建新类首先选择继承的话，事情会变得莫名的复杂。\n更好的方法是首先选择组合，特别是不知道该使用哪种方法时。组合不会强制设计是继承层次结构，而且组合更加灵活，因为可以动态地选择类型（从而选择相应的行为），而继承要求必须在编译时知道初始化类型。\n由于向上转换（在继承层次中向上移动）会丢失特定的类型信息，那么为了重新获取类型信息，就需要在继承层次中向下移动，使用*向下转换*。\n向上转换永远是安全的，因为基基类不会具有比派生类更多的接口。因此，每条发送给基类接口的消息都能被接收。但是对于向下转换，你无法知道一个形状是圆，它有可能是三角形，正方形或其他一些类型。\n在某些语言中（如C ++），必须执行一个特殊的操作来获得安全的向下转换，但是在Java中，每次转换都会被检查！所以只是进行一次普通的加括号形式的类型转换，在运行时这个转换仍会被检查，以确保它的确是希望的那种类型。如果不是，就会得到ClassCastException（类转换异常）。这种在运行时检查类型的行为可以运行时类型信息。\n深入理解Java封装、继承、多态\n第十章接口 我们将学习抽象类，一种介于普通类和接口之间的折中手段。虽然你的第一想法是创建接口，但对于具有属性和未实现方法的类来说，抽象类也是重要且必要的工具。您不可能总是使用纯粹的接口。\n创建一个抽象类是为了通过通用接口操纵一系列类\n抽象类中不一定有抽象方法，抽象方法一定在抽象类中\nJava提供了一个叫做*抽象方法*的机制，这个方法是不完整的：它只有声明没有方法体。\nabstract void f();  包含抽象方法的类称为*抽象类*。如果一个类包含一个或多个抽象方法，那么类本身也必须限定为抽象的，否则，编译器会报错。\n如果创建一个继承抽象类的新类并为之创建对象，那么就必须为基类的所有抽象方法提供方法定义。如果不这么做（可以选择不做），新类仍然是一个抽象类，编译器会强制我们为新类加上 abstract 关键字。\n事实上，接口只允许public方法，如果不加访问修饰符的话，接口的方法不是friendly。而是public。所以当实现一个接口时，来自接口中的方法必须被定义为公共。\nprivate abstract 被禁止了是有意义的，因为你不可能在 AbstractAccess 的任何子类中合法地定义它。\n然而，抽象类允许每件事：\n// interfaces/AbstractAccess.java abstract class AbstractAccess { private void m1() {} // private abstract void m1a(); // illegal protected void m2() {} protected abstract void m2a(); void m3() {} abstract void m3a(); public void m4() {} public abstract void m4a(); }复制错误OK！  private abstract被禁止了是有价值的，因为你不可能在AbstractAccess的任何子类中合法地定义它。\n将一个类说明为抽象并不强制类中的所有方法必须都是抽象方法。\n 抽象类不一定有抽象方法，有抽象方法的类一定是抽象类  接口中的方法是默认的修饰符是public abstract（也就是抽象方法）\nJava 8 允许在接口中添加静态方法。\nJava8新特性-接口中的静态方法与默认方法\ndefault 如果我们使用关键字default为newMethod()方法提供替代的实现，那么所有与接口有关的代码能正常工作，不应对，而且这些代码还可以调用新的方法newMethod()：\n// interfaces/InterfaceWithDefault.java interface InterfaceWithDefault { void firstMethod(); void secondMethod(); default void newMethod() { System.out.println(\u0026quot;newMethod\u0026quot;); } }  关键字default允许在接口中提供方法实现-在Java 8之前被禁止。\n 可以在接口中实现方法，只不过要加上关键字default，这样实现类即使不实现该方法，实现类的对象仍然可以使用该方法  java可以实现多实现\nclass MI implements One, Two, Three {}  方法签名包括方法名称和参数类型，返回类型不是方法签名的一部分。\n实现的多个接口中如果有方法签名相同的方法，可以使用super指定方法为某个接口中的默认实现（default）\npublic void f1() { Three.super.f1(); }  当然，你可以重定义f1()方法，但是也能像上例中那样使用super关键字选择基类实现中的一种。\nJava 8允许在接口中添加静态方法。这样做能适当地把工具功能插入接口中，从而操作接口，或者成为通用的工具：\npublic interface Operations { void execute(); static void runOps(Operations... ops) { for (Operations op: ops) { op.execute(); } } static void show(String msg) { System.out.println(msg); } }  这是模版方法设计模式的一个版本（在“设计模式”一章中详细描述），runOps()是一个模版方法。runOps()使用可变参数列表，因此我们可以选择任意多的操作参数并按顺序运行它们：\n接口中也可以定义变量\n接口的成员特点： A:成员变量 只能是常量。默认修饰符 public static final B:成员方法 只能是抽象方法。默认修饰符 public abstract\ninterface Instrument { // Compile-time constant: int VALUE = 5; // static \u0026amp; final public static final default void play(Note n) // Automatically public System.out.println(this + \u0026quot;.play() \u0026quot; + n); } default void adjust() { System.out.println(\u0026quot;Adjusting \u0026quot; + this); } void eat();　//注意:要给出初始值 public abstract }  抽象类和接口    特性 接口 抽象类     组合 新类可以组合多个接口 只能继承单一抽象类   状态 不能包含属性（除了静态属性，不支持对象状态） 可以包含属性，非抽象方法可能引用这些属性   默认方法和抽象方法 不需要在子类中实现替代方法。替代方法可以引用其他接口的方法 必须在子类中实现抽象方法   构造器 没有构造器 可以有构造器   可见性 隐式public 可以是受保护的或友元    抽象类仍然是一个类，在创建新类时只能继承它一个。而创建类的过程中可以实现多个接口。\n有一次实际经验：可以进行地抽象。因此，更高级使用接口而不是抽象类。只有当必要时才使用抽象类。除非必须使用，否则不要用接口和抽象类。大多数时候，普通类已经做得很好，如果不行的话，再移动到接口或抽象类中。\n通过这种方式结合具体类和接口时，需要将具体类放在前面，后面跟着接口（否则编译器会报错）。\n同时继承父类和实现接口时，需要将继承父类写在前面，实现接口写在后面\nclass Hero extends ActionCharacter implements CanFight, CanSwim, CanFly {}  interface I3 { int f(); } class C { public int f() { return 1; } } class C4 extends C implements I3 { // 完全相同，没问题 @Override public int f() { return 1; } }  关于Random r = new Random(47)中47的意思 https://blog.csdn.net/zhang41228/article/details/77069734\nhttps://www.cnblogs.com/java-zy/p/8204512.html\n通过Math.random()来获取随机数。实际上，它返回的是0(包含)到1(不包含)【0，1）之间的double值。使用方法如下：\nfinal double d = Math.random();  第十一章内部类 当生成一个内部类的对象时，此对象与制造它的外围对象（包围对象）之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。从而，内部类还拥有其外围类的所有元素的访问权。\n内部类的对象只能在相关外围类的对象相关联的情况下才能被创造（就像你应该看到的，内部类是非静态类时）。内置内部类对象时，需要一个指向其外围类对象的引用，如果编译器访问不到这个引用就会报错。不过有时时候这都无需程序员操心。\n如果您需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。任何运行时预算。以下的示例展示了如何使用.this：\n// innerclasses/DotThis.java // Accessing the outer-class object public class DotThis { void f() { System.out.println(\u0026quot;DotThis.f()\u0026quot;); } public class Inner { public DotThis outer() { return DotThis.this; // A plain \u0026quot;this\u0026quot; would be Inner's \u0026quot;this\u0026quot; } } public Inner inner() { return new Inner(); } public static void main(String[] args) { DotThis dt = new DotThis(); DotThis.Inner dti = dt.inner(); dti.outer().f(); } }  要想直接创建内部类的对象，你不能按照自己想象的方式，去引用外部类的名字DotNew，或者必须使用外部类的对象来创建该内部类对象，就像在上面的程序中所看到的的那样。这也解决了内部类名称作用域的问题，因此你不必声明（实际上你不能声明）dn.new DotNew.Inner。\n你必须在新表达式中提供对其他外部类对象的引用，这是需要使用.new语法，就像下面这样：\n// innerclasses/DotNew.java // Creating an inner class directly using .new syntax public class DotNew { public class Inner {} public static void main(String[] args) { DotNew dn = new DotNew(); DotNew.Inner dni = dn.new Inner(); } }  如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是final的（即，它在初始化后不会改变，因此可以被视为final） ，就像你在destination()的参数中看到的那样。这里省略掉final也没问题，但是通常最好加上final作为一种暗示。\n在匿名类中定义定义时，还能够执行初始化操作：\n// innerclasses/Parcel9.java public class Parcel9 { // Argument must be final or \u0026quot;effectively final\u0026quot; // to use within the anonymous inner class: public Destination destination(final String dest) { return new Destination() { private String label = dest; @Override public String readLabel() { return label; } }; } public static void main(String[] args) { Parcel9 p = new Parcel9(); Destination d = p.destination(\u0026quot;Tasmania\u0026quot;); } }  下例是带实例初始化的“包裹”形式。注意destination()的参数必须是final的，因为它们是在匿名类内部使用的（译者注：即使不加final，Java 8的编译器也会为我们自动加上final，以保证数据的一致性）。\n// innerclasses/Parcel10.java // Using \u0026quot;instance initialization\u0026quot; to perform // construction on an anonymous inner class public class Parcel10 { public Destination destination(final String dest, final float price) { return new Destination() { private int cost; // Instance initialization for each object: { cost = Math.round(price); if(cost \u0026gt; 100) System.out.println(\u0026quot;Over budget!\u0026quot;); } private String label = dest; @Override public String readLabel() { return label; } }; } public static void main(String[] args) { Parcel10 p = new Parcel10(); Destination d = p.destination(\u0026quot;Tasmania\u0026quot;, 101.395F); } }  嵌套类 如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为静态的，这通常称为嵌套类。想要理解静态应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。而，当内部类是静态的时，就不是这样了。\n 要创建嵌套类的对象，并且不需要其外围类的对象。 不能从嵌套类的对象中访问非静态的外围类对象。  普通内部类的细分与方法，只能放在类的外部基础上，所以普通的内部类不能有静态数据和静态分支，也不能包含嵌套类。 。但是嵌入类可以包含所有这些东西：\n// innerclasses/Parcel11.java // Nested classes (static inner classes) public class Parcel11 { private static class ParcelContents implements Contents { private int i = 11; @Override public int value() { return i; } } protected static final class ParcelDestination implements Destination { private String label; private ParcelDestination(String whereTo) { label = whereTo; } @Override public String readLabel() { return label; } // Nested classes can contain other static elements: public static void f() {} static int x = 10; static class AnotherLevel { public static void f() {} static int x = 10; } } public static Destination destination(String s) { return new ParcelDestination(s); } public static Contents contents() { return new ParcelContents(); } public static void main(String[] args) { Contents c = contents(); Destination d = destination(\u0026quot;Tasmania\u0026quot;); } }  在main()中，没有任何Parcel11的对象是必需的；或者使用选择静态成员的普通语法来调用方法-这些方法返回对Contents和Destination的引用。\n就像你在本章前面看到的那样，在一个普通的（非静态）内部类中，通过一个特殊的此引用可以链接到其外围类对象。嵌套类就没有这个特殊的此引用，这使得它是一个静态方法。\n接口内部的类 public interface ClassInInterface { void howdy(); class Test implements ClassInInterface { @Override public void howdy() { System.out.println(\u0026quot;Howdy!\u0026quot;); } public static void main(String[] args) { new Test().howdy(); } } }  一般说来，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。\n内部类必须要回答的一个问题是：如果只是需要一个对接口的引用，为什么不通过外围类实现那个接口呢？答案是：“如果这能满足需求，那么就应该这样做。”那么内部类实现一个接口与外围类实现此接口有什么区别呢？答案是：另外不是总能吸收到接口带来的方便，有时需要用到接口的实现。所以，使用内部类最吸引人的原因是：\n 每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。\n 如果没有内部类提供的，可以继承多个特定的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类可以多重继承的解决方案变得完整。接口解决了部分，而内部类有效地实现了“多重继承”。进而，内部类允许继承多个非接口类型（译注：类或抽象类）。\n如果拥有的是抽象的类或具体的类，而不是接口，那么只能使用内部类才能实现多重继承：\njava8提供了闭包，没有提供指针的概念\n内部类也可以被继承\n如果创建了一个内部类，然后继承其外围类并重新定义此内部类时，会发生什么呢？从而，内部类可以被覆盖吗？这看起来是个很有用的思想，但是“覆盖”内部类就好像它是外围类的一个方法，其实并不起什么作用：\n内部类是延时加载的，也就是说只会在第一次使用时加载。不使用就不加载，所以可以很好的实现单例模式。\njava构造函数的执行时机  先执行内部静态对象的构造方法，如果有多个按定义的先后顺序执行；静态对象在构造的时候也是也先执行其内部的静态对象。 再调用父类的构造方法（父类还有父类的话，从最开始的基类开始调用），如果没有明显指定调用父类自定义的构造方法，那么编译器会调用默认的父类构造方法super()。但是如果要调用父类自定义的构造方法，要在子类的构造方法中明确指定。 按声明顺序将成员引用对象变量初始化。 最后调用自身的构造方法。  局部内部类 前面提到过，可以在代码块里创建内部类，典型的方式是在一个方法体的里面创建。局部内部类不能有访问说明符，因为它不是外围类的一部分；但是它可以访问内部代码块内的常量，以及此外围类的所有成员。下面的示例对局部内部类与匿名内部类的创建进行了比较。\n第十二章集合 java.util库提供了一套相当完整的*集合类*（集合类）来解决这个问题，其中基本的类型有List，Set，Queue和Map。这些类型也被*容器类*（container classes）\n可以把ArrayList命名为“可以自动扩充自身尺寸的数组”来看待使用。ArrayList的相当简单：创建一个实例，用add()插入对象;然后用get()。来访问这些对象，此时需要使用索引，就像数组那样，但是不需要方括号0ArrayList还有一个size()方法，来说明集合中包含了多少个元素，所以不会不小心因数组越界而引发错误（通过抛出*运行时异常*，异常章节介绍了异常）。\n看到可以new ArrayList\u0026lt;\u0026gt;()这有时被称为“菱形语法”（菱形语法）在Java 7中之前，必须要在两端都进行类型声明，如下所示。：\nArrayList\u0026lt;Apple\u0026gt; apples = new ArrayList\u0026lt;Apple\u0026gt;();  之后不需要在右侧声明\nArrayList\u0026lt;Apple\u0026gt; apples = new ArrayList\u0026lt;\u0026gt;();  使用泛型，从列表中获取元素不需要强制类型转换。因为清单知道它持有什么类型，当因此调用get()时，它会替你执行转型。因此，使用泛型，你不仅知道编译器将检查放入集合的对象类型，而且在使用集合中的对象时也可以获得更清晰的语法。\n当指定了某个类型为泛型参数时，并同时只能将重定向类型的对象放入集合中。向上转换也可以像作用于其他类型一样作用于泛型：\nGrannySmith@15db9742  程序的输出是从对象默认的toString()方法产生的，该方法打印类名，后边跟着对象的散列码的无符号十六进制表示（散列这个码的英文通过hashCode()方法产生的）\n 集合（集合）：一个独立元素的序列，这些元素都服从一条或多条规则列表必须以插入的顺序保存元素，设置不能包含重复元素，队列按照*排队规则*来确定对象产生的顺序（通常与它们被插入的顺序相同）。 映射（MAP） ：一组成对的“键值对”对象，允许使用键来查找值的ArrayList。使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起 映射允许我们使用一个对象来查找另一个对象，它也被细分*关联*数组（associative array），因为指向对象和其他对象关联在一起；或者称为*字典*（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。Map是强大的编程工具。\nList\u0026lt;Apple\u0026gt; apples = new ArrayList\u0026lt;\u0026gt;();复制错误OK！   请注意，ArrayList已经被向上转换为List，这与之前示例中的处理方式正好相反。使用接口的目的是，如果想要改变具体实现，只需在创建时修改它就行了，就像下面这样：\n在java.util包中的数组和集合类中都有很多实用的方法，可以在一个集合中添加一组元素。\nArrays.asList()方法接受一个包含一个逗号或逗号分隔的元素列表（使用可变参数），将其转换为列表对象。Collections.addAll()方法接受一个Collection对象，以及一个或另一个逗号分隔的列表，将其中元素添加到Collection中。下边的示例展示了这两个方法，以及更通用的addAll()方法，所有收藏类型都包含该方法：\npublic class AddingGroups { public static void main(String[] args) { Collection\u0026lt;Integer\u0026gt; collection = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(1, 2, 3, 4, 5)); Integer[] moreInts = { 6, 7, 8, 9, 10 }; collection.addAll(Arrays.asList(moreInts)); // Runs significantly faster, but you can't // construct a Collection this way: Collections.addAll(collection, 11, 12, 13, 14, 15); Collections.addAll(collection, moreInts); // Produces a list \u0026quot;backed by\u0026quot; an array: List\u0026lt;Integer\u0026gt; list = Arrays.asList(16,17,18,19,20); list.set(1, 99); // OK -- modify an element // list.add(21); // Runtime error; the underlying // array cannot be resized. } }  使用必须Arrays.toString()来生成数组的柯林斯打印形式但是打印集合无需任何帮助下面的英文一个例子，这个例子中也介绍了基本的Java的集合。：\npublic class PrintingCollections { static Collection fill(Collection\u0026lt;String\u0026gt; collection) { collection.add(\u0026quot;rat\u0026quot;); collection.add(\u0026quot;cat\u0026quot;); collection.add(\u0026quot;dog\u0026quot;); collection.add(\u0026quot;dog\u0026quot;); return collection; } static Map fill(Map\u0026lt;String, String\u0026gt; map) { map.put(\u0026quot;rat\u0026quot;, \u0026quot;Fuzzy\u0026quot;); map.put(\u0026quot;cat\u0026quot;, \u0026quot;Rags\u0026quot;); map.put(\u0026quot;dog\u0026quot;, \u0026quot;Bosco\u0026quot;); map.put(\u0026quot;dog\u0026quot;, \u0026quot;Spot\u0026quot;); return map; } public static void main(String[] args) { System.out.println(fill(new ArrayList\u0026lt;\u0026gt;())); System.out.println(fill(new LinkedList\u0026lt;\u0026gt;())); System.out.println(fill(new HashSet\u0026lt;\u0026gt;())); System.out.println(fill(new TreeSet\u0026lt;\u0026gt;())); System.out.println(fill(new LinkedHashSet\u0026lt;\u0026gt;())); System.out.println(fill(new HashMap\u0026lt;\u0026gt;())); System.out.println(fill(new TreeMap\u0026lt;\u0026gt;())); System.out.println(fill(new LinkedHashMap\u0026lt;\u0026gt;())); } } /* Output: [rat, cat, dog, dog] [rat, cat, dog, dog] [rat, cat, dog] [cat, dog, rat] [rat, cat, dog] {rat=Fuzzy, cat=Rags, dog=Spot} {cat=Rags, dog=Spot, rat=Fuzzy} {rat=Fuzzy, cat=Rags, dog=Spot} */  ArrayList和LinkedList都是List的类型，从输出中可以修剪，它们都按插入顺序保存元素。两者之间的区别在于执行某些类型的操作时的性能，而且LinkedList包含操作的多于ArrayList。\nHashSet的，TreeSet中和LinkedHashSet是设置的类型。从输出中可以看到，Set仅保存每个相同项中的一个，并且不同的Set实现存储元素的方式也不同。HashSet的使用相当复杂的方法存储元素。这种技术是检索元素的最快方法，因此，存储顺序看上去没有什么意义（通常只关心某事物是否是集合的成员，而存储顺序并不重要。。如果存储顺序很重要，则可以使用TreeSet，则按按比较结果的升序保存对象）或LinkedHashSet，它按被添加的先后顺序保存对象。\nMap（称为也。*关联数组*）使用*键*来查找对象，就像一个简单的数据库。关联所的对象称为*值*。假设有一个Map将美国州名与它们的首府联系在一起，如果想要俄亥俄州（Ohio）的首府，可以使用“ Ohio”作为键来查找，几乎就像使用数组下标一样。正是由于这种行为，对于每个键，地图只存储了一次。\nMap.put(key, value)添加一个所要添加的值插入它与一个键（找到查找值）相关联。Map.get(key)生成与该键相关联的值。上面的示例仅添加键值对，并没有执行查找。这将在稍稍后展示。\n请注意，这里没有指定（或考虑）Map的大小，因为它会自动调整大小。此外，Map还知道如何打印自己，它会显示相关联的键和值。\n本例使用了Map的三种基本风格：HashMap，TreeMap和LinkedHashMap。\n键和值保存在HashMap中中的顺序不是插入顺序，因为HashMap的实现使用了非常快速的算法来控制顺序。TreeMap中通过比较结果的升序来保存键，LinkedHashMap的在保持HashMap的查找速度的同时按键的插入顺序保存键。\n有两种类型的List：\n 基本的ArrayList，擅长长访问元素，但在List中间插入和删除元素时速度较慢。 LinkedList的，它通过代价较低的在List中间进行的插入和删除操作，提供了优化的顺序访问。LinkedList的对于随机访问来说相对较慢，但它具有比ArrayList的更大的特征集。  下面的示例引入typeinfo.pets，超前使用了类型信息一章中的类库。这个类库包含了Pet类层次结构，并且使用了随机生成的Pet对象的一些工具类。此时不需要了解完整的详细信息，只需要知道两点：\n 有一个宠物类，以及Pet的各种子类型。 静态的Pets.arrayList()方法返回一个填充了随机选取的宠物对象的ArrayList：  对于LinkedList，在列表中间插入和删除都是廉价操作（在本例中，除了对列表中间进行的真正的随机访问），但对于ArrayList，这可是代价高昂的操作。这是否意味着永远不应该在ArrayList的中间插入元素，并最好是转换为LinkedList？不，它只是意味着你应该认识这个问题，如果你开始在某个ArrayList中间执行很多插入操作，并且程序开始变慢，那么你应该看看你的列表实现有可能就是罪魁祸首（发现这种情况的最佳方式）是一个使用分析器profiler）。优化是一个很棘手的问题，最好的策略就是置之不顾，直到发现必须要去担心它了（尽管去理解这些问题总是一个很好的主意）。\n因此，查找通常是Set最重要的操作，因此通常会选择HashSet实现，该实现针对快速查找进行了优化。\nSet，与Collection 相同的接口，因此没有任何额外的功能，不像前面两种不同类型的List那样。实际上，Set就是一个Collection ，只是行为不同。（这是继承和多态思想的典型应用：表现不同的行为）。Set根据对象的“值”确定归属性，\n字符串对象似乎没有排序要对结果进行排序，一种方法是使用。TreeSet中而不是HashSet的：\nTreeSet可以对字符串进行排序\n通过使用containsKey()和containsValue()方法去测试一个Map，以查看它是否包含某个键或某个值：\nLinkedList实现了队列接口，并提供了一些方法以支持行为，因此LinkedList可以利用队列的一种实现。通过将LinkedList向上转换为Queue\nJava 提供了许多保存对象的方法：\n 数组将数字索引与对象相关联。它保存类型明确的对象，因此在查找对象时不必对结果做类型转换。它可以是多维的，可以保存基本类型的数据。虽然可以在运行时创建数组，但是一旦创建数组，就无法更改数组的大小。 Collection 保存单一的元素，而 Map 包含相关联的键值对。使用 Java 泛型，可以指定集合中保存的对象的类型，因此不能将错误类型的对象放入集合中，并且在从集合中获取元素时，不必进行类型转换。各种 Collection 和各种 Map 都可以在你向其中添加更多的元素时，自动调整其尺寸大小。集合不能保存基本类型，但自动装箱机制会负责执行基本类型和集合中保存的包装类型之间的双向转换。 像数组一样， List 也将数字索引与对象相关联，因此，数组和 List 都是有序集合。 如果要执行大量的随机访问，则使用 ArrayList ，如果要经常从表中间插入或删除元素，则应该使用 LinkedList 。 队列和堆栈的行为是通过 LinkedList 提供的。 Map 是一种将对象（而非数字）与对象相关联的设计。 HashMap 专为快速访问而设计，而 TreeMap 保持键始终处于排序状态，所以没有 HashMap 快。 LinkedHashMap 按插入顺序保存其元素，但使用散列提供快速访问的能力。 Set 不接受重复元素。 HashSet 提供最快的查询速度，而 TreeSet 保持元素处于排序状态。 LinkedHashSet 按插入顺序保存其元素，但使用散列提供快速访问的能力。 不要在新代码中使用遗留类 Vector ，Hashtable 和 Stack 。  forin的原理\nJDK5以后引入了forin语句，目的是为了简化迭代器遍历，其本质仍然是迭代器遍历。\n如果一个对象想使用forin语句进行遍历，则对象类必须满足两个条件：实现Iterable接口和实现Iterator方法。之所以ArrayList集合类能够实现forin语句遍历，就是因为其满足上述两个条件\n第十三章函数式编程 尽管Java不是函数式语言，但Java 8 Lambda表达式和方法引用（方法参考）允许您以函数式编程。\nOO（面向对象，面向对象）是抽象数据，FP（功能编程，函数式编程）是抽象行为。\nLambda表达式 Lambda 表达式是使用最小可能语法编写的函数定义：\n Lambda 表达式产生函数，而不是类。 在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。 Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。  我们在 Strategize.java 中看到了一个 Lambda 表达式，但还有其他语法变体：\n// functional/LambdaExpressions.java interface Description { String brief(); } interface Body { String detailed(String head); } interface Multi { String twoArg(String head, Double d); } public class LambdaExpressions { static Body bod = h -\u0026gt; h + \u0026quot; No Parens!\u0026quot;; // [1] static Body bod2 = (h) -\u0026gt; h + \u0026quot; More details\u0026quot;; // [2] static Description desc = () -\u0026gt; \u0026quot;Short info\u0026quot;; // [3] static Multi mult = (h, n) -\u0026gt; h + n; // [4] static Description moreLines = () -\u0026gt; { // [5] System.out.println(\u0026quot;moreLines()\u0026quot;); return \u0026quot;from moreLines()\u0026quot;; }; public static void main(String[] args) { System.out.println(bod.detailed(\u0026quot;Oh!\u0026quot;)); System.out.println(bod2.detailed(\u0026quot;Hi!\u0026quot;)); System.out.println(desc.brief()); System.out.println(mult.twoArg(\u0026quot;Pi! \u0026quot;, 3.14159)); System.out.println(moreLines.brief()); } }复制ErrorOK!  输出结果：\nOh! No Parens! Hi! More details Short info Pi! 3.14159 moreLines() from moreLines()复制ErrorOK!  我们从三个接口开始，每个接口都有一个单独的方法（很快就会理解它的重要性）。但是，每个方法都有不同数量的参数，以便演示 Lambda 表达式语法。\n任何 Lambda 表达式的基本语法是：\n 参数。 接着 -\u0026gt;，可视为“产出”。 -\u0026gt; 之后的内容都是方法体。  [1] 当只用一个参数，可以不需要括号 ()。 然而，这是一个特例。 [2] 正常情况使用括号 () 包裹参数。 为了保持一致性，也可以使用括号 () 包裹单个参数，虽然这种情况并不常见。 [3] 如果没有参数，则必须使用括号 () 表示空参数列表。 [4] 对于多个参数，将参数列表放在括号 () 中。   到目前为止，所有 Lambda 表达式方法体都是单行。 该表达式的结果自动成为 Lambda 表达式的返回值，在此处使用 return 关键字是非法的。 这是 Lambda 表达式缩写用于描述功能的语法的另一种方式。\n[5] 如果在 Lambda 表达式中确实需要多行，则必须将这些行放在花括号中。 在这种情况下，就需要使用 return。\nLambda 表达式通常比匿名内部类产生更易读的代码，因此我们将在本书中尽可能使用它们。\n递归函数是一个自我调用的函数。可以编写递归的 Lambda 表达式，但需要注意：递归方法必须是实例变量或静态变量，否则会出现编译时错误。 我们将为每个案例创建一个示例。\n这两个示例都需要一个接受 int 型参数并生成 int 的接口：\n// functional/IntCall.java interface IntCall { int call(int arg); }复制ErrorOK!  整数 n 的阶乘将所有小于或等于 n 的正整数相乘。 阶乘函数是一个常见的递归示例：\n// functional/RecursiveFactorial.java public class RecursiveFactorial { static IntCall fact; public static void main(String[] args) { fact = n -\u0026gt; n == 0 ? 1 : n * fact.call(n - 1); for(int i = 0; i \u0026lt;= 10; i++) System.out.println(fact.call(i)); } }复制ErrorOK!  输出结果：\n1 1 2 6 24 120 720 5040 40320 362880 3628800复制ErrorOK!  这里，fact 是一个静态变量。 注意使用三元 if-else。 递归函数将一直调用自己，直到 i == 0。所有递归函数都有“停止条件”，否则将无限递归并产生异常。\nstatic修饰的方法中不可以调用非static修饰的成员变量，方法中也不可以定义static修饰的局部变量\n自学 lambda:最大的作用是简化代码\n方法引用 Java 8 方法引用没有历史包袱。方法引用组成：类名或对象名，后面跟 :: [^4]，然后跟方法名称。\n方法签名相同\n// functional/MethodReferences.java import java.util.*; interface Callable { // [1] void call(String s); } class Describe { void show(String msg) { // [2] System.out.println(msg); } } public class MethodReferences { static void hello(String name) { // [3] System.out.println(\u0026quot;Hello, \u0026quot; + name); } static class Description { String about; Description(String desc) { about = desc; } void help(String msg) { // [4] System.out.println(about + \u0026quot; \u0026quot; + msg); } } static class Helper { static void assist(String msg) { // [5] System.out.println(msg); } } public static void main(String[] args) { Describe d = new Describe(); Callable c = d::show; // [6] c.call(\u0026quot;call()\u0026quot;); // [7] c = MethodReferences::hello; // [8] c.call(\u0026quot;Bob\u0026quot;); c = new Description(\u0026quot;valuable\u0026quot;)::help; // [9] c.call(\u0026quot;information\u0026quot;); c = Helper::assist; // [10] c.call(\u0026quot;Help!\u0026quot;); } }复制ErrorOK!  输出结果：\ncall() Hello, Bob valuable information Help!复制ErrorOK!  [1] 我们从单一方法接口开始（同样，你很快就会了解到这一点的重要性）。\n[2] show() 的签名（参数类型和返回类型）符合 Callable 的 call() 的签名。\n[3] hello() 也符合 call() 的签名。\n[4] help() 也符合，它是静态内部类中的非静态方法。\n[5] assist() 是静态内部类中的静态方法。\n[6] 我们将 Describe 对象的方法引用赋值给 Callable ，它没有 show() 方法，而是 call() 方法。 但是，Java 似乎接受用这个看似奇怪的赋值，因为方法引用符合 Callable 的 call() 方法的签名。\n[7] 我们现在可以通过调用 call() 来调用 show()，因为 Java 将 call() 映射到 show()。\n[8] 这是一个静态方法引用。\n[9] 这是 [6] 的另一个版本：对已实例化对象的方法的引用，有时称为*绑定方法引用*。\n[10] 最后，获取静态内部类的方法引用的操作与 [8] 中外部类方式一样。\n上例只是简短的介绍，我们很快就能看到方法引用的全部变化。\nRunnable接口 Runnable 接口自 1.0 版以来一直在 Java 中，因此不需要导入。它也符合特殊的单方法接口格式：它的方法 run() 不带参数，也没有返回值。因此，我们可以使用 Lambda 表达式和方法引用作为 Runnable：\n// functional/RunnableMethodReference.java // 方法引用与 Runnable 接口的结合使用 class Go { static void go() { System.out.println(\u0026quot;Go::go()\u0026quot;); } } public class RunnableMethodReference { public static void main(String[] args) { new Thread(new Runnable() { public void run() { System.out.println(\u0026quot;Anonymous\u0026quot;); } }).start(); new Thread( () -\u0026gt; System.out.println(\u0026quot;lambda\u0026quot;) ).start(); new Thread(Go::go).start(); } }复制ErrorOK!  输出结果：\nAnonymous lambda Go::go()复制ErrorOK!  Thread 对象将 Runnable 作为其构造函数参数，并具有会调用 run() 的方法 start()。 注意，只有匿名内部类才需要具有名为 run() 的方法。\n使用未绑定的引用时，函数方法的签名（接口中的单个方法）不再与方法引用的签名完全匹配。 理由是：你需要一个对象来调用方法。\nJava 8 引入了 java.util.function 包。它包含一组接口，这些接口是 Lambda 表达式和方法引用的目标类型。 每个接口只包含一个抽象方法，称为函数式方法。\n在编写接口时，可以使用 @FunctionalInterface 注解强制执行此“函数式方法”模式：\nJava格式 下表描述了 java.util.function 中的目标类型（包括例外情况）：\n   特征 函数式方法名 示例     无参数； 无返回值 Runnable (java.lang) run() Runnable   无参数； 返回类型任意 Supplier get() getAs类型() Supplier`` BooleanSupplier IntSupplier LongSupplier DoubleSupplier   无参数； 返回类型任意 Callable (java.util.concurrent) call() Callable``   1 参数； 无返回值 Consumer accept() Consumer IntConsumer LongConsumer DoubleConsumer   2 参数 Consumer BiConsumer accept() BiConsumer   2 参数 Consumer； 1 引用； 1 基本类型 Obj类型Consumer accept() ObjIntConsumer ObjLongConsumer ObjDoubleConsumer   1 参数； 返回类型不同 Function apply() To类型 和 类型To类型 applyAs类型() FunctionIntFunction LongFunction DoubleFunctionToIntFunction ToLongFunction ToDoubleFunction IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction   1 参数； 返回类型相同 UnaryOperator apply() UnaryOperator IntUnaryOperator LongUnaryOperator DoubleUnaryOperator   2 参数类型相同； 返回类型相同 BinaryOperator apply() BinaryOperator IntBinaryOperator LongBinaryOperator DoubleBinaryOperator   2 参数类型相同; 返回整型 Comparator (java.util) compare() Comparator   2 参数； 返回布尔型 Predicate test() Predicate BiPredicate IntPredicate LongPredicate DoublePredicate   参数基本类型； 返回基本类型 类型To类型Function applyAs类型() IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction   2 参数类型不同 Bi操作 (不同方法名) BiFunction BiConsumer BiPredicate ToIntBiFunction ToLongBiFunction ToDoubleBiFunction    java格式化输出https://www.cnblogs.com/Dhouse/p/7776780.html\n   转 换 符 说 明 示 例     %s 字符串类型 \u0026ldquo;mingrisoft\u0026rdquo;   %c 字符类型 \u0026rsquo;m\u0026rsquo;   %b 布尔类型 true   %d 整数类型（十进制） 99   %x 整数类型（十六进制） FF   %o 整数类型（八进制） 77   %f 浮点类型 99.99   %a 十六进制浮点类型 FF.35AE   %e 指数类型 9.38e+5   %g 通用浮点类型（f和e类型中较短的）    %h 散列码    %% 百分比类型 ％   %n 换行符    %tx 日期与时间类型（x代表不同的日期与时间转换符        标 志 说 明 示 例 结 果     + 为正数或者负数添加符号 (\u0026ldquo;%+d\u0026rdquo;,15) +15   − 左对齐 (\u0026ldquo;%-5d\u0026rdquo;,15) |15 |   0 数字前面补0 (\u0026ldquo;%04d\u0026rdquo;, 99) 0099   空格 在整数之前添加指定数量的空格 (\u0026ldquo;% 4d\u0026rdquo;, 99) | 99|   , 以“,”对数字分组 (\u0026ldquo;%,f\u0026rdquo;, 9999.99) 9,999.990000   ( 使用括号包含负数 (\u0026ldquo;%(f\u0026rdquo;, -99.99) (99.990000)   # 如果是浮点数则包含小数点，如果是16进制或8进制则添加0x或0 (\u0026ldquo;%#x\u0026rdquo;, 99)(\u0026ldquo;%#o\u0026rdquo;, 99) 0x630143   \u0026lt; 格式化前一个转换符所描述的参数 (\u0026ldquo;%f和%\u0026lt;3.2f\u0026rdquo;, 99.45) 99.450000和99.45   $ 被格式化的参数索引 (\u0026ldquo;%1$d,%2$s\u0026rdquo;, 99,\u0026ldquo;abc\u0026rdquo;) 99,abc    常见日期和时间组合的格式，如图所示。\n   转 换 符 说 明 示 例     c 包括全部日期和时间信息 星期六 十月 27 14:21:20 CST 2007   F “年-月-日”格式 2007-10-27   D “月/日/年”格式 10/27/07   r “HH:MM:SS PM”格式（12时制） 02:25:51 下午   T “HH:MM:SS”格式（24时制） 14:28:16   R “HH:MM”格式（24时制） 14:28    从 Lambda 表达式引用的局部变量必须是 final 或者是等同 final 效果的。\n这就叫做等同 final 效果（Effectively Final）。这个术语是在 Java 8 才开始出现的，表示虽然没有明确地声明变量是 final 的，但是因变量值没被改变过而实际有了 final 同等的效果。 如果局部变量的初始值永远不会改变，那么它实际上就是 final 的。\n实际上只要有内部类，就会有闭包（Java 8 只是简化了闭包操作）。在 Java 8 之前，变量 x 和 i 必须被明确声明为 final。在 Java 8 中，内部类的规则放宽，包括等同 final 效果。\n第十四章流式编程 peek 操作接收的是一个 Consumer 函数。顾名思义 peek 操作会按照 Consumer 函数提供的逻辑去消费流中的每一个元素，同时有可能改变元素内部的一些属性。这里我们要提一下这个 Consumer 以理解 什么是消费。\n参考博客\n参考博客\n 集合优化了对象的存储，而流和对象的处理有关。\n 流的一个核心好处是，它使得程序更加短小并且更易理解。当 Lambda 表达式和方法引用（method references）和流一起使用的时候会让人感觉自成一体。流使得 Java 8 更具吸引力。\n举个例子，假如你要随机展示 5 至 20 之间不重复的整数并进行排序。实际上，你的关注点首先是创建一个有序集合。围绕这个集合进行后续的操作。但是使用流式编程，你就可以简单陈述你想做什么：\n// streams/Randoms.java import java.util.*; public class Randoms { public static void main(String[] args) { new Random(47) .ints(5, 20) .distinct() .limit(7) .sorted() .forEach(System.out::println); } }  流式编程采用内部迭代，这是流式编程的核心特性之一。这种机制使得编写的代码可读性更强，也更能利用多核处理器的优势。通过放弃对迭代过程的控制，我们把控制权交给并行化机制。\n流是懒加载的。这代表着它只在绝对必要时才计算。你可以将流看作“延迟列表”。由于计算延迟，流使我们能够表示非常大（甚至无限）的序列，而不需要考虑内存问题。\n：在接口中添加被 default（默认）修饰的方法。通过这种方案，设计者们可以将流式（*stream*）方法平滑地嵌入到现有类中。流方法预置的操作几乎已满足了我们平常所有的需求。流操作的类型有三种：创建流，修改流元素（中间操作， Intermediate Operations），消费流元素（终端操作， Terminal Operations）。最后一种类型通常意味着收集流元素（通常是到集合中）。\nJava 8 采用的解决方案是：在接口中添加被 default（默认）修饰的方法。通过这种方案，设计者们可以将流式（*stream*）方法平滑地嵌入到现有类中。流方法预置的操作几乎已满足了我们平常所有的需求。流操作的类型有三种：创建流，修改流元素（中间操作， Intermediate Operations），消费流元素（终端操作， Terminal Operations）。最后一种类型通常意味着收集流元素（通常是到集合中）。\n随机数流 Random 类被一组生成流的方法增强了。代码示例：\n// streams/RandomGenerators.java import java.util.*; import java.util.stream.*; public class RandomGenerators { public static \u0026lt;T\u0026gt; void show(Stream\u0026lt;T\u0026gt; stream) { stream .limit(4) .forEach(System.out::println); System.out.println(\u0026quot;++++++++\u0026quot;); } public static void main(String[] args) { Random rand = new Random(47); show(rand.ints().boxed()); show(rand.longs().boxed()); show(rand.doubles().boxed()); // 控制上限和下限： show(rand.ints(10, 20).boxed()); show(rand.longs(50, 100).boxed()); show(rand.doubles(20, 30).boxed()); // 控制流大小： show(rand.ints(2).boxed()); show(rand.longs(2).boxed()); show(rand.doubles(2).boxed()); // 控制流的大小和界限 show(rand.ints(3, 3, 9).boxed()); show(rand.longs(3, 12, 22).boxed()); show(rand.doubles(3, 11.5, 12.3).boxed()); } }  为了消除冗余代码，我创建了一个泛型方法 show(Stream stream) （在讲解泛型之前就使用这个特性，确实有点作弊，但是回报是值得的）。类型参数 T 可以是任何类型，所以这个方法对 Integer、Long 和 Double 类型都生效。但是 Random 类只能生成基本类型 int， long， double 的流。幸运的是， boxed() 流操作将会自动地把基本类型包装成为对应的装箱类型，从而使得 show() 能够接受流。\n流的创建 你可以通过 Stream.of() 很容易地将一组元素转化成为流\n流的中间操作 流的中间操作时惰性的，也就是说没有终段操作流的中间操作时不会执行的\n流的终端操作 一个流只能有一个终端操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。终端操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect(副作用)。\n第十五章 异常  Java 的基本理念是“结构不佳的代码不能运行”\n Java字节码结构剖析五：异常表\n当抛出异常后，有几件事会随之发生。首先，同 Java 中其他对象的创建一样，将使用 new 在堆上创建异常对象。然后，当前的执行路径（它不能继续下去了）被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序。这个恰当的地方就是异常处理程序，它的任务是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去。\n所有标准异常类都有两个构造器：一个是无参构造器；另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器：\n多重捕获 public class MultiCatch { void x() throws Except1, Except2, Except3, Except4 {} void process() {} void f() { try { x(); } catch(Except1 | Except2 | Except3 | Except4 e) { process(); } } }  栈轨迹 try { throw new Exception(); } catch(Exception e) { for(StackTraceElement ste : e.getStackTrace()) System.out.println(ste.getMethodName()); }  在 Java 7 之前，try 总是后面跟着一个 {，但是现在可以跟一个带括号的定义 - 这里是我们创建的 FileInputStream 对象。括号内的部分称为资源规范头（resource specification header）。现在可用于整个 try 块的其余部分。更重要的是，无论你如何退出 try 块（正常或异常），都会执行前一个 finally 子句的等价物，但不会编写那些杂乱而棘手的代码。这是一项重要的改进。\n它是如何工作的？在 try-with-resources 定义子句中创建的对象（在括号内）必须实现 java.lang.AutoCloseable 接口，这个接口有一个方法：close()。当在 Java 7 中引入 AutoCloseable 时，许多接口和类被修改以实现它；查看 Javadocs 中的 AutoCloseable，可以找到所有实现该接口的类列表，其中包括 Stream 对象：\n// exceptions/StreamsAreAutoCloseable.java import java.io.*; import java.nio.file.*; import java.util.stream.*; public class StreamsAreAutoCloseable { public static void main(String[] args) throws IOException{ try( Stream\u0026lt;String\u0026gt; in = Files.lines( Paths.get(\u0026quot;StreamsAreAutoCloseable.java\u0026quot;)); PrintWriter outfile = new PrintWriter( \u0026quot;Results.txt\u0026quot;); // [1] ) { in.skip(5) .limit(1) .map(String::toLowerCase) .forEachOrdered(outfile::println); } // [2] } }   [1] 你在这里可以看到其他的特性：资源规范头中可以包含多个定义，并且通过分号进行分割（最后一个分号是可选的）。规范头中定义的每个对象都会在 try 语句块运行结束之后调用 close() 方法。 [2] try-with-resources 里面的 try 语句块可以不包含 catch 或者 finally 语句而独立存在。在这里，IOException 被 main() 方法抛出，所以这里并不需要在 try 后面跟着一个 catch 语句块。  Java 5 中的 Closeable 已经被修改，修改之后的接口继承了 AutoCloseable 接口。所以所有实现了 Closeable 接口的对象，都支持了 try-with-resources 特性。\n抛出异常的时候，异常处理系统会按照代码的书写顺序找出“最近”的处理程序。找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续查找。\n查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配。派生类的对象也可以匹配其基类的处理程序，就像这样：\n应该在下列情况下使用异常：\n 尽可能使用 try-with-resource。 在恰当的级别处理问题。（在知道该如何处理的情况下才捕获异常。） 解决问题并且重新调用产生异常的方法。 进行少许修补，然后绕过异常发生的地方继续执行。 用别的数据进行计算，以代替方法预计会返回的值。 把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。 把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。 终止程序。 进行简化。（如果你的异常模式使问题变得太复杂，那用起来会非常痛苦也很烦人。） 让类库和程序更安全。（这既是在为调试做短期投资，也是在为程序的健壮性做长期投资。）  第十六章 代码校验 业内普遍认为标准 Java 发行版本中的日志包 (java.util.logging) 的设计相当糟糕。 大多数人会选择其他的替代日志包。如 Simple Logging Facade for Java(SLF4J) ,它为多个日志框架提供了一个封装好的调用方式，这些日志框架包括 java.util.logging ， logback 和 **log4j **。 SLF4J 允许用户在部署时插入所需的日志框架。\nSLF4J 提供了一个复杂的工具来报告程序的信息，它的效率与前面示例中的技术几乎相同。 对于非常简单的信息日志记录，你可以执行以下操作：\n// validating/SLF4JLogging.java import org.slf4j.*; public class SLF4JLogging { private static Logger log = LoggerFactory.getLogger(SLF4JLogging.class); public static void main(String[] args) { log.info(\u0026quot;hello logging\u0026quot;); } } /* Output: 2017-05-09T06:07:53.418 [main] INFO SLF4JLogging - hello logging */  第十七章 文件 Java NIO？看这一篇就够了！\n好像 Java 设计者终于意识到了 Java 使用者多年来的痛苦，在 Java7 中对此引入了巨大的改进。这些新元素被放在 java.nio.file 包下面，过去人们通常把 nio 中的 n 理解为 new 即新的 io，现在更应该当成是 non-blocking 非阻塞 io(io就是input/output输入/输出)。java.nio.file 库终于将 Java 文件操作带到与其他编程语言相同的水平。最重要的是 Java8 新增的 streams 与文件结合使得文件操作编程变得更加优雅。我们将看一下文件操作的两个基本组件：\n 文件或者目录的路径； 文件本身。  Files 工具类包含大部分我们需要的目录操作和文件操作方法。出于某种原因，它们没有包含删除目录树相关的方法，因此我们将实现并将其添加到 onjava 库中。\nimport java.nio.file.*; import java.nio.file.attribute.BasicFileAttributes; import java.io.IOException; public class RmDir { public static void rmdir(Path dir) throws IOException { Files.walkFileTree(dir, new SimpleFileVisitor\u0026lt;Path\u0026gt;() { @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { Files.delete(file); return FileVisitResult.CONTINUE; } @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException { Files.delete(dir); return FileVisitResult.CONTINUE; } }); } }  读取文件 以字节为单位读取文件(FileInputStream) 常用于读二进制文件，如图片、声音、影像等文件。\nFile file = new File(\u0026quot;filePath\u0026quot;); try (InputStream in = new FileInputStream(file);) { // 一次读4个字节 byte[] bytes = new byte[4]; // 读取到的字节数量 int readCount = 0; // 读入4个字节到字节数组中 while ((readCount = in.read(bytes)) != -1) { System.out.write(bytes, 0, readCount); } } catch (Exception e) { e.printStackTrace(); }  以字符为单位读取文件(InputStreamReader) 常用于读文本，数字等类型的文件。\nFile file = new File(\u0026quot;filePath\u0026quot;); try (Reader reader = new InputStreamReader(new FileInputStream(file));) { // 一次读30个字符 char[] chars = new char[30]; // 读取到的字节数量 int readCount = 0; while ((readCount = reader.read(chars)) != -1) { for (int i = 0; i \u0026lt; readCount; i++) { System.out.print(chars[i]); } } } catch (Exception e) { e.printStackTrace(); }  以行为单位读取文件内容(BufferedReader) 常用于读面向行的格式化文件。\nFile file = new File(\u0026quot;filePath\u0026quot;); try (BufferedReader reader = new BufferedReader(new FileReader(file))) { String line = null; // 一次读入一行，直到读入null为文件结束 while ((line = reader.readLine()) != null) { System.out.println(line); } reader.close(); } catch (IOException e) { e.printStackTrace(); }  一次读取所有行(Files.readAllLines) 使用nio的Files.readAllLines可以一次性读取所有行\nList\u0026lt;String\u0026gt; lines = Files.readAllLines(Paths.get(\u0026quot;filePath\u0026quot;)); for (String line : lines) { System.out.println(line); }  写入文件 以字节为单位写文件(FileOutputStream) File file = new File(\u0026quot;D:/file.txt\u0026quot;); try (OutputStream out = new FileOutputStream(file);) { String content = \u0026quot;枫桥夜泊\\n张继\\n月落乌啼霜满天，\\n江枫渔火对愁眠。\u0026quot;; out.write(content.getBytes()); } catch (IOException e) { e.printStackTrace(); }  以字符为单位写文件(OutputStreamWriter) File file = new File(\u0026quot;D:/file.txt\u0026quot;); try (Writer writer = new OutputStreamWriter(new FileOutputStream(file));) { String content = \u0026quot;枫桥夜泊\\n张继\\n月落乌啼霜满天，\\n江枫渔火对愁眠。\u0026quot;; writer.write(content); } catch (IOException e) { e.printStackTrace(); }  以行为单位写文件(PrintWriter) try (PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(\u0026quot;D:/file.txt\u0026quot;)));) { writer.println(\u0026quot; 枫桥夜泊 \u0026quot;); // 写字符串 writer.print(true); // 写入布尔类型 writer.print(666); // 写入整数类型 writer.println(); // 换行 writer.flush(); // 写入刷新文件 } catch (IOException e) { e.printStackTrace(); }  另一种以行为单位写文件(FileWriter) String path = \u0026quot;filePath\u0026quot;; // 第二个参数true表示以追加形式写文件 try (FileWriter writer = new FileWriter(path, true);) { writer.write(\u0026quot;new line\u0026quot;); } catch (IOException e) { e.printStackTrace(); }  使用RandomAccessFile追加写入 try { String path = \u0026quot;filePath\u0026quot;; // 打开一个随机访问文件流，按读写方式 RandomAccessFile randomFile = new RandomAccessFile(path, \u0026quot;rw\u0026quot;); // 将写文件指针移到文件尾。 randomFile.seek(randomFile.length()); randomFile.writeBytes(\u0026quot;new string\u0026quot;); randomFile.close(); List\u0026lt;String\u0026gt; lines = Files.readAllLines(Paths.get(path)); for (String line : lines) { System.out.println(line); } } catch (IOException e) { e.printStackTrace(); }  FileWriter 与 PrintWriter 的区别 JAVA DOC 的定义  FileWriter is a convenience class for writing character files. The constructors of this class assume that the default character encoding and the default byte-buffer size are acceptable. To specify these values yourself, construct an OutputStreamWriter on a FileOutputStream.\nFileWriter 可以很方便的编写字符型文件，它的构造方法设置了默认的字符编码和字节缓冲区大小。如果要自行设置，可以在 FileOutputStream 上构造一个 OutputStreamWriter。 PrintWriter prints formatted representations of objects to a text-output stream. This class implements all of the print methods found in PrintStream. It does not contain methods for writing raw bytes, for which a program should use unencoded byte streams.\nPrintWriter 将对象以格式化的形式打印到文本输出流，该类实现了 PrintStream 中的所有 print 方法。它不包含写入原始字节的方法，对于字节，程序应该使用未编码的字节流进行写入。 主要的区别是PrintWriter提供了一些额外的方法用于格式化输出，如println、printf。 如果发生任何I/O异常，FileWriter会抛出IOException，而PrintWriter不会抛出IOException，它会设置一个boolean标志，该标志可以通过调用checkError()方法获取。 PrintWriter在每次写入数据后会自动调用flush()方法，而FileWriter则需要自行调用flush()方法。\n 第十八章 字符串  字符串操作毫无疑问是计算机程序设计中最常见的行为之一。\n 在 Java 大展拳脚的 Web 系统中更是如此。在本章中，我们将深入学习在 Java 语言中应用最广泛的 String 类，并研究与之相关的类及工具。\n字符串的不可变 String 对象是不可变的。查看 JDK 文档你就会发现，String 类中每一个看起来会修改 String 值的方法，实际上都是创建了一个全新的 String 对象，以包含修改后的字符串内容。而最初的 String 对象则丝毫未动。\n看看下面的代码：\n// strings/Immutable.java public class Immutable { public static String upcase(String s) { return s.toUpperCase(); } public static void main(String[] args) { String q = \u0026quot;howdy\u0026quot;; System.out.println(q); // howdy String qq = upcase(q); System.out.println(qq); // HOWDY System.out.println(q); // howdy } } /* Output: howdy HOWDY howdy */ 复制ErrorOK!  当把 q 传递给 upcase() 方法时，实际传递的是引用的一个拷贝。其实，每当把 String 对象作为方法的参数时，都会复制一份引用，而该引用所指向的对象其实一直待在单一的物理位置上，从未动过。\n回到 upcase() 的定义，传入其中的引用有了名字 s，只有 upcase() 运行的时候，局部引用 s 才存在。一旦 upcase() 运行结束，s 就消失了。当然了，upcase() 的返回值，其实是最终结果的引用。这足以说明，upcase() 返回的引用已经指向了一个新的对象，而 q 仍然在原来的位置。\nString 的这种行为正是我们想要的。例如：\nString s = \u0026quot;asdf\u0026quot;; String x = Immutable.upcase(s);复制ErrorOK!  难道你真的希望 upcase() 方法改变其参数吗？对于一个方法而言，参数是为该方法提供信息的，而不是想让该方法改变自己的。在阅读这段代码时，读者自然会有这样的感觉。这一点很重要，正是有了这种保障，才使得代码易于编写和阅读。\n+的重载与 StringBuilder String 对象是不可变的，你可以给一个 String 对象添加任意多的别名。因为 String 是只读的，所以指向它的任何引用都不可能修改它的值，因此，也就不会影响到其他引用。\n不可变性会带来一定的效率问题。为 String 对象重载的 + 操作符就是一个例子。重载的意思是，一个操作符在用于特定的类时，被赋予了特殊的意义（用于 String 的 + 与 += 是 Java 中仅有的两个重载过的操作符，Java 不允许程序员重载任何其他的操作符 [^1]）。\n操作符 + 可以用来连接 String：\n// strings/Concatenation.java public class Concatenation { public static void main(String[] args) { String mango = \u0026quot;mango\u0026quot;; String s = \u0026quot;abc\u0026quot; + mango + \u0026quot;def\u0026quot; + 47; System.out.println(s); } } /* Output: abcmangodef47 */复制ErrorOK!  可以想象一下，这段代码是这样工作的：String 可能有一个 append() 方法，它会生成一个新的 String 对象，以包含“abc”与 mango 连接后的字符串。该对象会再创建另一个新的 String 对象，然后与“def”相连，生成另一个新的对象，依此类推。\n这种方式当然是可行的，但是为了生成最终的 String 对象，会产生一大堆需要垃圾回收的中间对象。我猜想，Java 设计者一开始就是这么做的（这也是软件设计中的一个教训：除非你用代码将系统实现，并让它运行起来，否则你无法真正了解它会有什么问题），然后他们发现其性能相当糟糕。\n想看看以上代码到底是如何工作的吗？可以用 JDK 自带的 javap 工具来反编译以上代码。命令如下：\njavap -c Concatenation复制ErrorOK!  这里的 -c 标志表示将生成 JVM 字节码。我们剔除不感兴趣的部分，然后做细微的修改，于是有了以下的字节码：\npublic static void main(java.lang.String[]); Code: Stack=2, Locals=3, Args_size=1 0: ldc #2; //String mango 2: astore_1 3: new #3; //class StringBuilder 6: dup 7: invokespecial #4; //StringBuilder.\u0026quot;\u0026lt;init\u0026gt;\u0026quot;:() 10: ldc #5; //String abc 12: invokevirtual #6; //StringBuilder.append:(String) 15: aload_1 16: invokevirtual #6; //StringBuilder.append:(String) 19: ldc #7; //String def 21: invokevirtual #6; //StringBuilder.append:(String) 24: bipush 47 26: invokevirtual #8; //StringBuilder.append:(I) 29: invokevirtual #9; //StringBuilder.toString:() 32: astore_2 33: getstatic #10; //Field System.out:PrintStream; 36: aload_2 37: invokevirtual #11; //PrintStream.println:(String) 40: return复制ErrorOK!  如果你有汇编语言的经验，以上代码应该很眼熟(其中的 dup 和 invokevirtual 语句相当于Java虚拟机上的汇编语句。即使你完全不了解汇编语言也无需担心)。需要重点注意的是：编译器自动引入了 java.lang.StringBuilder 类。虽然源代码中并没有使用 StringBuilder 类，但是编译器却自作主张地使用了它，就因为它更高效。\n在这里，编译器创建了一个 StringBuilder 对象，用于构建最终的 String，并对每个字符串调用了一次 append() 方法，共计 4 次。最后调用 toString() 生成结果，并存为 s (使用的命令为 astore_2)。\n现在，也许你会觉得可以随意使用 String 对象，反正编译器会自动为你做性能优化。可是在这之前，让我们更深入地看看编译器能为我们优化到什么程度。下面的例子采用两种方式生成一个 String：方法一使用了多个 String 对象；方法二在代码中使用了 StringBuilder。\n// strings/WhitherStringBuilder.java public class WhitherStringBuilder { public String implicit(String[] fields) { String result = \u0026quot;\u0026quot;; for(String field : fields) { result += field; } return result; } public String explicit(String[] fields) { StringBuilder result = new StringBuilder(); for(String field : fields) { result.append(field); } return result.toString(); } }复制ErrorOK!  现在运行 javap -c WitherStringBuilder，可以看到两种不同方法（我已经去掉不相关的细节）对应的字节码。首先是 implicit() 方法：\npublic java.lang.String implicit(java.lang.String[]); 0: ldc #2 // String 2: astore_2 3: aload_1 4: astore_3 5: aload_3 6: arraylength 7: istore 4 9: iconst_0 10: istore 5 12: iload 5 14: iload 4 16: if_icmpge 51 19: aload_3 20: iload 5 22: aaload 23: astore 6 25: new #3 // StringBuilder 28: dup 29: invokespecial #4 // StringBuilder.\u0026quot;\u0026lt;init\u0026gt;\u0026quot; 32: aload_2 33: invokevirtual #5 // StringBuilder.append:(String) 36: aload 6 38: invokevirtual #5 // StringBuilder.append:(String;) 41: invokevirtual #6 // StringBuilder.toString:() 44: astore_2 45: iinc 5, 1 48: goto 12 51: aload_2 52: areturn复制ErrorOK!  注意从第 16 行到第 48 行构成了一个循环体。第 16 行：对堆栈中的操作数进行“大于或等于的整数比较运算”，循环结束时跳转到第 51 行。第 48 行：重新回到循环体的起始位置（第 12 行）。注意：StringBuilder 是在循环内构造的，这意味着每进行一次循环，会创建一个新的 StringBuilder 对象。\n下面是 explicit() 方法对应的字节码：\npublic java.lang.String explicit(java.lang.String[]); 0: new #3 // StringBuilder 3: dup 4: invokespecial #4 // StringBuilder.\u0026quot;\u0026lt;init\u0026gt;\u0026quot; 7: astore_2 8: aload_1 9: astore_3 10: aload_3 11: arraylength 12: istore 4 14: iconst_0 15: istore 5 17: iload 5 19: iload 4 21: if_icmpge 43 24: aload_3 25: iload 5 27: aaload 28: astore 6 30: aload_2 31: aload 6 33: invokevirtual #5 // StringBuilder.append:(String) 36: pop 37: iinc 5, 1 40: goto 17 43: aload_2 44: invokevirtual #6 // StringBuilder.toString:() 47: areturn复制ErrorOK!  可以看到，不仅循环部分的代码更简短、更简单，而且它只生成了一个 StringBuilder 对象。显式地创建 StringBuilder 还允许你预先为其指定大小。如果你已经知道最终字符串的大概长度，那预先指定 StringBuilder 的大小可以避免频繁地重新分配缓冲。\n因此，当你为一个类编写 toString() 方法时，如果字符串操作比较简单，那就可以信赖编译器，它会为你合理地构造最终的字符串结果。但是，如果你要在 toString() 方法中使用循环，且可能有性能问题，那么最好自己创建一个 StringBuilder 对象，用它来构建最终结果。请参考以下示例：\n// strings/UsingStringBuilder.java import java.util.*; import java.util.stream.*; public class UsingStringBuilder { public static String string1() { Random rand = new Random(47); StringBuilder result = new StringBuilder(\u0026quot;[\u0026quot;); for(int i = 0; i \u0026lt; 25; i++) { result.append(rand.nextInt(100)); result.append(\u0026quot;, \u0026quot;); } result.delete(result.length()-2, result.length()); result.append(\u0026quot;]\u0026quot;); return result.toString(); } public static String string2() { String result = new Random(47) .ints(25, 0, 100) .mapToObj(Integer::toString) .collect(Collectors.joining(\u0026quot;, \u0026quot;)); return \u0026quot;[\u0026quot; + result + \u0026quot;]\u0026quot;; } public static void main(String[] args) { System.out.println(string1()); System.out.println(string2()); } } /* Output: [58, 55, 93, 61, 61, 29, 68, 0, 22, 7, 88, 28, 51, 89, 9, 78, 98, 61, 20, 58, 16, 40, 11, 22, 4] [58, 55, 93, 61, 61, 29, 68, 0, 22, 7, 88, 28, 51, 89, 9, 78, 98, 61, 20, 58, 16, 40, 11, 22, 4] */ 复制ErrorOK!  在方法 string1() 中，最终结果是用 append() 语句拼接起来的。如果你想走捷径，例如：append(a + \u0026quot;: \u0026quot; + c)，编译器就会掉入陷阱，从而为你另外创建一个 StringBuilder 对象处理括号内的字符串操作。如果拿不准该用哪种方式，随时可以用 javap 来分析你的程序。\nStringBuilder 提供了丰富而全面的方法，包括 insert()、replace()、substring()，甚至还有reverse()，但是最常用的还是 append() 和 toString()。还有 delete()，上面的例子中我们用它删除最后一个逗号和空格，以便添加右括号。\nstring2() 使用了 Stream，这样代码更加简洁美观。可以证明，Collectors.joining() 内部也是使用的 StringBuilder，这种写法不会影响性能！\nStringBuilder是 Java SE5 引入的，在这之前用的是 StringBuffer。后者是线程安全的（参见并发编程），因此开销也会大些。使用 StringBuilder 进行字符串操作更快一点。\n意外递归 Java 中的每个类从根本上都是继承自 Object，标准集合类也是如此，它们都有 toString() 方法，并且覆盖了该方法，使得它生成的 String 结果能够表达集合自身，以及集合包含的对象。例如 ArrayList.toString()，它会遍历 ArrayList 中包含的所有对象，调用每个元素上的 toString() 方法：\n// strings/ArrayListDisplay.java import java.util.*; import java.util.stream.*; import generics.coffee.*; public class ArrayListDisplay { public static void main(String[] args) { List\u0026lt;Coffee\u0026gt; coffees = Stream.generate(new CoffeeSupplier()) .limit(10) .collect(Collectors.toList()); System.out.println(coffees); } } /* Output: [Americano 0, Latte 1, Americano 2, Mocha 3, Mocha 4, Breve 5, Americano 6, Latte 7, Cappuccino 8, Cappuccino 9] */ 复制ErrorOK!  如果你希望 toString() 打印出类的内存地址，也许你会考虑使用 this 关键字：\n// strings/InfiniteRecursion.java // Accidental recursion // {ThrowsException} // {VisuallyInspectOutput} Throws very long exception import java.util.*; import java.util.stream.*; public class InfiniteRecursion { @Override public String toString() { return \u0026quot; InfiniteRecursion address: \u0026quot; + this + \u0026quot;\\n\u0026quot; } public static void main(String[] args) { Stream.generate(InfiniteRecursion::new) .limit(10) .forEach(System.out::println); } } 复制ErrorOK!  当你创建了 InfiniteRecursion 对象，并将其打印出来的时候，你会得到一串很长的异常信息。如果你将该 InfiniteRecursion 对象存入一个 ArrayList 中，然后打印该 ArrayList，同样也会抛出异常。其实，当运行到如下代码时：\n\u0026quot;InfiniteRecursion address: \u0026quot; + this 复制ErrorOK!  这里发生了自动类型转换，由 InfiniteRecursion 类型转换为 String 类型。因为编译器发现一个 String 对象后面跟着一个 “+”，而 “+” 后面的对象不是 String，于是编译器试着将 this 转换成一个 String。它怎么转换呢？正是通过调用 this 上的 toString() 方法，于是就发生了递归调用。\n如果你真的想要打印对象的内存地址，应该调用 Object.toString() 方法，这才是负责此任务的方法。所以，不要使用 this，而是应该调用 super.toString() 方法。\n字符串操作 以下是 String 对象具备的一些基本方法。重载的方法归纳在同一行中：\n   方法 参数，重载版本 作用     构造方法 默认版本，String，StringBuilder，StringBuffer，char数组，byte数组 创建String对象   length()  String中字符的个数   charAt() int索引 获取String中索引位置上的char   getChars()，getBytes() 待复制部分的开始和结束索引，复制的目标数组，目标数组的开始索引 复制char或byte到一个目标数组中   toCharArray()  生成一个char[]，包含String中的所有字符   equals()，equalsIgnoreCase() 与之进行比较的String 比较两个String的内容是否相同。如果相同，结果为true   compareTo()，compareToIgnoreCase() 与之进行比较的String 按词典顺序比较String的内容，比较结果为负数、零或正数。注意，大小写不等价   contains() 要搜索的CharSequence 如果该String对象包含参数的内容，则返回true   contentEquals() 与之进行比较的CharSequence或StringBuffer 如果该String对象与参数的内容完全一致，则返回true   isEmpty()  返回boolean结果，以表明String对象的长度是否为0   regionMatches() 该String的索引偏移量，另一个String及其索引偏移量，要比较的长度。重载版本增加了“忽略大小写”功能 返回boolean结果，以表明所比较区域是否相等   startsWith() 可能的起始String。重载版本在参数中增加了偏移量 返回boolean结果，以表明该String是否以传入参数开始   endsWith() 该String可能的后缀String 返回boolean结果，以表明此参数是否是该字符串的后缀   indexOf()，lastIndexOf() 重载版本包括：char，char与起始索引，String，String与起始索引 如果该String并不包含此参数，就返回-1；否则返回此参数在String中的起始索引。lastIndexOf()是从后往前搜索   matches() 一个正则表达式 返回boolean结果，以表明该String和给出的正则表达式是否匹配   split() 一个正则表达式。可选参数为需要拆分的最大数量 按照正则表达式拆分String，返回一个结果数组   join()（Java8引入的） 分隔符，待拼字符序列。用分隔符将字符序列拼接成一个新的String 用分隔符拼接字符片段，产生一个新的String   substring()（即subSequence()） 重载版本：起始索引；起始索引+终止索引 返回一个新的String对象，以包含参数指定的子串   concat() 要连接的String 返回一个新的String对象，内容为原始String连接上参数String   replace() 要替换的字符，用来进行替换的新字符。也可以用一个CharSequence替换另一个CharSequence 返回替换字符后的新String对象。如果没有替换发生，则返回原始的String对象   replaceFirst() 要替换的正则表达式，用来进行替换的String 返回替换首个目标字符串后的String对象   replaceAll() 要替换的正则表达式，用来进行替换的String 返回替换所有目标字符串后的String对象   toLowerCase()，toUpperCase()  将字符的大小写改变后，返回一个新的String对象。如果没有任何改变，则返回原始的String对象   trim()  将String两端的空白符删除后，返回一个新的String对象。如果没有任何改变，则返回原始的String对象   valueOf()（static） 重载版本：Object；char[]；char[]，偏移量，与字符个数；boolean；char；int；long；float；double 返回一个表示参数内容的String   intern()  为每个唯一的字符序列生成一个且仅生成一个String引用   format() 要格式化的字符串，要替换到格式化字符串的参数 返回格式化结果String    从这个表可以看出，当需要改变字符串的内容时，String 类的方法都会返回一个新的 String 对象。同时，如果内容不改变，String 方法只是返回原始对象的一个引用而已。这可以节约存储空间以及避免额外的开销。\n本章稍后还将介绍正则表达式在 String 方法中的应用。\n格式化输出 在长久的等待之后，Java SE5 终于推出了 C 语言中 printf() 风格的格式化输出这一功能。这不仅使得控制输出的代码更加简单，同时也给与Java开发者对于输出格式与排列更强大的控制能力。\nprintf() C 语言的 printf() 并不像 Java 那样连接字符串，它使用一个简单的格式化字符串，加上要插入其中的值，然后将其格式化输出。 printf() 并不使用重载的 + 操作符（C语言没有重载）来连接引号内的字符串或字符串变量，而是使用特殊的占位符来表示数据将来的位置。而且它还将插入格式化字符串的参数，以逗号分隔，排成一行。例如：\nSystem.out.printf(\u0026quot;Row 1: [%d %f]%n\u0026quot;, x, y);复制ErrorOK!  这一行代码在运行的时候，首先将 x 的值插入到 %d_ 的位置，然后将 y 的值插入到 %f 的位置。这些占位符叫做*格式修饰符*，它们不仅指明了插入数据的位置，同时还指明了将会插入什么类型的变量，以及如何格式化。在这个例子中 %d 表示 x 是一个整数，%f 表示 y 是一个浮点数（float 或者 double）。\nSystem.out.format() Java SE5 引入了 format() 方法，可用于 PrintStream 或者 PrintWriter 对象（你可以在 附录:流式 I/O 了解更多内容），其中也包括 System.out 对象。format() 方法模仿了 C 语言的 printf()。如果你比较怀旧的话，也可以使用 printf()。以下是一个简单的示例：\n// strings/SimpleFormat.java public class SimpleFormat { public static void main(String[] args) { int x = 5; double y = 5.332542; // The old way: System.out.println(\u0026quot;Row 1: [\u0026quot; + x + \u0026quot; \u0026quot; + y + \u0026quot;]\u0026quot;); // The new way: System.out.format(\u0026quot;Row 1: [%d %f]%n\u0026quot;, x, y); // or System.out.printf(\u0026quot;Row 1: [%d %f]%n\u0026quot;, x, y); } } /* Output: Row 1: [5 5.332542] Row 1: [5 5.332542] Row 1: [5 5.332542] */复制ErrorOK!  可以看到，format() 和 printf() 是等价的，它们只需要一个简单的格式化字符串，加上一串参数即可，每个参数对应一个格式修饰符。\nString 类也有一个 static format() 方法，可以格式化字符串。\nFormatter 类 在 Java 中，所有的格式化功能都是由 java.util.Formatter 类处理的。可以将 Formatter 看做一个翻译器，它将你的格式化字符串与数据翻译成需要的结果。当你创建一个 Formatter 对象时，需要向其构造器传递一些信息，告诉它最终的结果将向哪里输出：\n// strings/Turtle.java import java.io.*; import java.util.*; public class Turtle { private String name; private Formatter f; public Turtle(String name, Formatter f) { this.name = name; this.f = f; } public void move(int x, int y) { f.format(\u0026quot;%s The Turtle is at (%d,%d)%n\u0026quot;, name, x, y); } public static void main(String[] args) { PrintStream outAlias = System.out; Turtle tommy = new Turtle(\u0026quot;Tommy\u0026quot;, new Formatter(System.out)); Turtle terry = new Turtle(\u0026quot;Terry\u0026quot;, new Formatter(outAlias)); tommy.move(0,0); terry.move(4,8); tommy.move(3,4); terry.move(2,5); tommy.move(3,3); terry.move(3,3); } } /* Output: Tommy The Turtle is at (0,0) Terry The Turtle is at (4,8) Tommy The Turtle is at (3,4) Terry The Turtle is at (2,5) Tommy The Turtle is at (3,3) Terry The Turtle is at (3,3) */复制ErrorOK!  格式化修饰符 %s 表明这里需要 String 参数。\n所有的 tommy 都将输出到 System.out，而所有的 terry 则都输出到 System.out 的一个别名中。Formatter 的重载构造器支持输出到多个路径，不过最常用的还是 PrintStream()（如上例）、OutputStream 和 File。你可以在 附录:流式 I/O 中了解更多信息。\n格式化修饰符 在插入数据时，如果想要优化空格与对齐，你需要更精细复杂的格式修饰符。以下是其通用语法：\n%[argument_index$][flags][width][.precision]conversion 复制ErrorOK!  最常见的应用是控制一个字段的最小长度，这可以通过指定 width 来实现。Formatter对象通过在必要时添加空格，来确保一个字段至少达到设定长度。默认情况下，数据是右对齐的，不过可以通过使用 - 标志来改变对齐方向。\n与 width 相对的是 precision*，用于指定最大长度。*width 可以应用于各种类型的数据转换，并且其行为方式都一样。precision 则不然，当应用于不同类型的数据转换时，precision 的意义也不同。在将 precision 应用于 String 时，它表示打印 string 时输出字符的最大数量。而在将 precision 应用于浮点数时，它表示小数部分要显示出来的位数（默认是 6 位小数），如果小数位数过多则舍入，太少则在尾部补零。由于整数没有小数部分，所以 precision 无法应用于整数，如果你对整数应用 *precision*，则会触发异常。\n下面的程序应用格式修饰符来打印一个购物收据。这是 Builder 设计模式的一个简单实现，即先创建一个初始对象，然后逐渐添加新东西，最后调用 build() 方法完成构建：\n// strings/ReceiptBuilder.java import java.util.*; public class ReceiptBuilder { private double total = 0; private Formatter f = new Formatter(new StringBuilder()); public ReceiptBuilder() { f.format( \u0026quot;%-15s %5s %10s%n\u0026quot;, \u0026quot;Item\u0026quot;, \u0026quot;Qty\u0026quot;, \u0026quot;Price\u0026quot;); f.format( \u0026quot;%-15s %5s %10s%n\u0026quot;, \u0026quot;----\u0026quot;, \u0026quot;---\u0026quot;, \u0026quot;-----\u0026quot;); } public void add(String name, int qty, double price) { f.format(\u0026quot;%-15.15s %5d %10.2f%n\u0026quot;, name, qty, price); total += price * qty; } public String build() { f.format(\u0026quot;%-15s %5s %10.2f%n\u0026quot;, \u0026quot;Tax\u0026quot;, \u0026quot;\u0026quot;, total * 0.06); f.format(\u0026quot;%-15s %5s %10s%n\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;-----\u0026quot;); f.format(\u0026quot;%-15s %5s %10.2f%n\u0026quot;, \u0026quot;Total\u0026quot;, \u0026quot;\u0026quot;, total * 1.06); return f.toString(); } public static void main(String[] args) { ReceiptBuilder receiptBuilder = new ReceiptBuilder(); receiptBuilder.add(\u0026quot;Jack's Magic Beans\u0026quot;, 4, 4.25); receiptBuilder.add(\u0026quot;Princess Peas\u0026quot;, 3, 5.1); receiptBuilder.add( \u0026quot;Three Bears Porridge\u0026quot;, 1, 14.29); System.out.println(receiptBuilder.build()); } } /* Output: Item Qty Price ---- --- ----- Jack's Magic Be 4 4.25 Princess Peas 3 5.10 Three Bears Por 1 14.29 Tax 2.80 ----- Total 49.39 */ 复制ErrorOK!  通过传入一个 StringBuilder 对象到 Formatter 的构造器，我们指定了一个容器来构建目标 String。你也可以通过不同的构造器参数，把结果输出到标准输出，甚至是一个文件里。\n正如你所见，通过相当简洁的语法，Formatter 提供了对空格与对齐的强大控制能力。在该程序中，为了恰当地控制间隔，格式化字符串被重复利用了多遍。\nFormatter 转换 下面的表格展示了最常用的类型转换：\n   类型 含义     d 整型（十进制）   c Unicode字符   b Boolean值   s String   f 浮点数（十进制）   e 浮点数（科学计数）   x 整型（十六进制）   h 散列码（十六进制）   % 字面值“%”    下面的程序演示了这些转换是如何工作的：\n// strings/Conversion.java import java.math.*; import java.util.*; public class Conversion { public static void main(String[] args) { Formatter f = new Formatter(System.out); char u = 'a'; System.out.println(\u0026quot;u = 'a'\u0026quot;); f.format(\u0026quot;s: %s%n\u0026quot;, u); // f.format(\u0026quot;d: %d%n\u0026quot;, u); f.format(\u0026quot;c: %c%n\u0026quot;, u); f.format(\u0026quot;b: %b%n\u0026quot;, u); // f.format(\u0026quot;f: %f%n\u0026quot;, u); // f.format(\u0026quot;e: %e%n\u0026quot;, u); // f.format(\u0026quot;x: %x%n\u0026quot;, u); f.format(\u0026quot;h: %h%n\u0026quot;, u); int v = 121; System.out.println(\u0026quot;v = 121\u0026quot;); f.format(\u0026quot;d: %d%n\u0026quot;, v); f.format(\u0026quot;c: %c%n\u0026quot;, v); f.format(\u0026quot;b: %b%n\u0026quot;, v); f.format(\u0026quot;s: %s%n\u0026quot;, v); // f.format(\u0026quot;f: %f%n\u0026quot;, v); // f.format(\u0026quot;e: %e%n\u0026quot;, v); f.format(\u0026quot;x: %x%n\u0026quot;, v); f.format(\u0026quot;h: %h%n\u0026quot;, v); BigInteger w = new BigInteger(\u0026quot;50000000000000\u0026quot;); System.out.println( \u0026quot;w = new BigInteger(\\\u0026quot;50000000000000\\\u0026quot;)\u0026quot;); f.format(\u0026quot;d: %d%n\u0026quot;, w); // f.format(\u0026quot;c: %c%n\u0026quot;, w); f.format(\u0026quot;b: %b%n\u0026quot;, w); f.format(\u0026quot;s: %s%n\u0026quot;, w); // f.format(\u0026quot;f: %f%n\u0026quot;, w); // f.format(\u0026quot;e: %e%n\u0026quot;, w); f.format(\u0026quot;x: %x%n\u0026quot;, w); f.format(\u0026quot;h: %h%n\u0026quot;, w); double x = 179.543; System.out.println(\u0026quot;x = 179.543\u0026quot;); // f.format(\u0026quot;d: %d%n\u0026quot;, x); // f.format(\u0026quot;c: %c%n\u0026quot;, x); f.format(\u0026quot;b: %b%n\u0026quot;, x); f.format(\u0026quot;s: %s%n\u0026quot;, x); f.format(\u0026quot;f: %f%n\u0026quot;, x); f.format(\u0026quot;e: %e%n\u0026quot;, x); // f.format(\u0026quot;x: %x%n\u0026quot;, x); f.format(\u0026quot;h: %h%n\u0026quot;, x); Conversion y = new Conversion(); System.out.println(\u0026quot;y = new Conversion()\u0026quot;); // f.format(\u0026quot;d: %d%n\u0026quot;, y); // f.format(\u0026quot;c: %c%n\u0026quot;, y); f.format(\u0026quot;b: %b%n\u0026quot;, y); f.format(\u0026quot;s: %s%n\u0026quot;, y); // f.format(\u0026quot;f: %f%n\u0026quot;, y); // f.format(\u0026quot;e: %e%n\u0026quot;, y); // f.format(\u0026quot;x: %x%n\u0026quot;, y); f.format(\u0026quot;h: %h%n\u0026quot;, y); boolean z = false; System.out.println(\u0026quot;z = false\u0026quot;); // f.format(\u0026quot;d: %d%n\u0026quot;, z); // f.format(\u0026quot;c: %c%n\u0026quot;, z); f.format(\u0026quot;b: %b%n\u0026quot;, z); f.format(\u0026quot;s: %s%n\u0026quot;, z); // f.format(\u0026quot;f: %f%n\u0026quot;, z); // f.format(\u0026quot;e: %e%n\u0026quot;, z); // f.format(\u0026quot;x: %x%n\u0026quot;, z); f.format(\u0026quot;h: %h%n\u0026quot;, z); } } /* Output: u = 'a' s: a c: a b: true h: 61 v = 121 d: 121 c: y b: true s: 121 x: 79 h: 79 w = new BigInteger(\u0026quot;50000000000000\u0026quot;) d: 50000000000000 b: true s: 50000000000000 x: 2d79883d2000 h: 8842a1a7 x = 179.543 b: true s: 179.543 f: 179.543000 e: 1.795430e+02 h: 1ef462c y = new Conversion() b: true s: Conversion@15db9742 h: 15db9742 z = false b: false s: false h: 4d5 */复制ErrorOK!  被注释的代码表示，针对相应类型的变量，这些转换是无效的。如果执行这些转换，则会触发异常。\n注意，程序中的每个变量都用到了 b 转换。虽然它对各种类型都是合法的，但其行为却不一定与你想象的一致。对于 boolean 基本类型或 Boolean 对象，其转换结果是对应的 true 或 false。但是，对其他类型的参数，只要该参数不为 null，其转换结果永远都是 true。即使是数字 0，转换结果依然为 true，而这在其他语言中（包括C），往往转换为 false。所以，将 b 应用于非布尔类型的对象时请格外小心。\n还有许多不常用的类型转换与格式修饰符选项，你可以在 JDK 文档中的 Formatter 类部分找到它们。\nString.format() Java SE5 也参考了 C 中的 sprintf() 方法，以生成格式化的 String 对象。String.format() 是一个 static 方法，它接受与 Formatter.format() 方法一样的参数，但返回一个 String 对象。当你只需使用一次 format() 方法的时候，String.format() 用起来很方便\n第十九章 类型信息  RTTI（RunTime Type Information，运行时类型信息）能够在程序运行时发现和使用类型信息\n RTTI 把我们从只能在编译期进行面向类型操作的禁锢中解脱了出来，并且让我们可以使用某些非常强大的程序。对 RTTI 的需要，揭示了面向对象设计中许多有趣（并且复杂）的特性，同时也带来了关于如何组织程序的基本问题。\n本章将讨论 Java 是如何在运行时识别对象和类信息的。主要有两种方式：\n “传统的” RTTI：假定我们在编译时已经知道了所有的类型； “反射”机制：允许我们在运行时发现和使用类的信息。  严格来说，Stream 实际上是把放入其中的所有对象都当做 Object 对象来持有，只是取元素时会自动将其类型转为 Shape。这也是 RTTI 最基本的使用形式，因为在 Java 中，所有类型转换的正确性检查都是在运行时进行的。这也正是 RTTI 的含义所在：在运行时，识别一个对象的类型。\n类是程序的一部分，每个类都有一个 Class 对象。换言之，每当我们编写并且编译了一个新类，就会产生一个 Class 对象（更恰当的说，是被保存在一个同名的 .class 文件中）。为了生成这个类的对象，Java 虚拟机 (JVM) 先会调用\u0026rdquo;类加载器\u0026rdquo;子系统把这个类加载到内存中。\n类加载器首先会检查这个类的 Class 对象是否已经加载，如果尚未加载，默认的类加载器就会根据类名查找 .class 文件（如果有附加的类加载器，这时候可能就会在数据库中或者通过其它方式获得字节码）。这个类的字节码被加载后，JVM 会对其进行验证，确保它没有损坏，并且不包含不良的 Java 代码(这是 Java 安全防范的一种措施)。一旦某个类的 Class 对象被载入内存，它就可以用来创建这个类的所有对象。\n其实构造器也是类的静态方法，虽然构造器前面并没有 static 关键字。所以，使用 new 操作符创建类的新对象，这个操作也算作对类的静态成员引用。\n无论何时，只要你想在运行时使用类型信息，就必须先得到那个 Class 对象的引用。Class.forName() 就是实现这个功能的一个便捷途径，因为使用该方法你不需要先持有这个类型 的对象。但是，如果你已经拥有了目标类的对象，那就可以通过调用 getClass() 方法来获取 Class 引用了，这个方法来自根类 Object，它将返回表示该对象实际类型的 Class 对象的引用。\n getName() 来产生完整类名，\ngetSimpleName() 产生不带包名的类名，\ngetCanonicalName() 也是产生完整类名（除内部类和数组外，对大部分类产生的结果与 getName() 相同）。\nisInterface() 用于判断某个 Class 对象代表的是否为一个接口。\nClass.getInterface() 方法返回的是存放 Class 对象的数组，里面的 Class 对象表示的是那个类实现的接口\ngetSuperclass() 方法来得到父类的 Class 对象，再用父类的 Class 对象调用该方法，重复多次，你就可以得到一个对象完整的类继承结构。\nnewInstance() 方法是实现“虚拟构造器”的一种途径，虚拟构造器可以让你在不知道一个类的确切类型的时候，创建这个类的对象。\n 注意，有一点很有趣：当使用 .class 来创建对 Class 对象的引用时，不会自动地初始化该 Class 对象。为了使用类而做的准备工作实际包含三个步骤：\n 加载，这是由类加载器执行的。该步骤将查找字节码（通常在 classpath 所指定的路径中查找，但这并非是必须的），并从这些字节码中创建一个 Class 对象。 链接。在链接阶段将验证类中的字节码，为 static 字段分配存储空间，并且如果需要的话，将解析这个类创建的对其他类的所有引用。 初始化。如果该类具有超类，则先初始化超类，执行 static 初始化器和 static 初始化块。  直到第一次引用一个 static 方法（构造器隐式地是 static）或者非常量的 static 字段，才会进行类初始化。\n初始化有效地实现了尽可能的“惰性”，从对 initable 引用的创建中可以看到，仅使用 .class 语法来获得对类对象的引用不会引发初始化。但与此相反，使用 Class.forName() 来产生 Class 引用会立即就进行初始化，如 initable3。\n了在使用 Class 引用时放松限制，我们使用了通配符，它是 Java 泛型中的一部分。通配符就是 ?，表示“任何事物”。因此，我们可以在上例的普通 Class 引用中添加通配符，并产生相同的结果：\n// typeinfo/WildcardClassReferences.java public class WildcardClassReferences { public static void main(String[] args) { Class\u0026lt;?\u0026gt; intClass = int.class; intClass = double.class; } }复制ErrorOK!  使用 Class 比单纯使用 Class 要好，虽然它们是等价的，并且单纯使用 Class 不会产生编译器警告信息。使用 Class 的好处是它表示你并非是碰巧或者由于疏忽才使用了一个非具体的类引用，而是特意为之。\n第二十章 泛型 这个概念称为元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象 或 信使 ）。\n下面是另一个实现 Supplier 接口的例子，它负责生成 Fibonacci 数列：\n// generics/Fibonacci.java // Generate a Fibonacci sequence import java.util.function.*; import java.util.stream.*; public class Fibonacci implements Supplier\u0026lt;Integer\u0026gt; { private int count = 0; @Override public Integer get() { return fib(count++); } private int fib(int n) { if(n \u0026lt; 2) return 1; return fib(n-2) + fib(n-1); } public static void main(String[] args) { Stream.generate(new Fibonacci()) .limit(18) .map(n -\u0026gt; n + \u0026quot; \u0026quot;) .forEach(System.out::print); } }  泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。\n流式编程实现Fibonacci\n// streams/Fibonacci.java import java.util.stream.*; public class Fibonacci { int x = 1; Stream\u0026lt;Integer\u0026gt; numbers() { return Stream.iterate(0, i -\u0026gt; { int result = x + i; x = i; return result; }); } public static void main(String[] args) { new Fibonacci().numbers() .skip(20) // 过滤前 20 个 .limit(10) // 然后取 10 个 .forEach(System.out::println); } }  如果方法是 static 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。\n要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：\n// generics/GenericMethods.java public class GenericMethods { public \u0026lt;T\u0026gt; void f(T x) { System.out.println(x.getClass().getName()); } public static void main(String[] args) { GenericMethods gm = new GenericMethods(); gm.f(\u0026quot;\u0026quot;); gm.f(1); gm.f(1.0); gm.f(1.0F); gm.f('c'); gm.f(gm); } } /* Output: java.lang.String java.lang.Integer java.lang.Double java.lang.Float java.lang.Character GenericMethods */  对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 *类型参数推断*。因此，对 f() 的调用看起来像普通的方法调用，并且 f() 看起来像被重载了无数次一样。它甚至会接受 GenericMethods 类型的参数。\n如果使用基本类型调用 f() ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。\n变长参数和泛型方法 泛型方法和变长参数列表可以很好地共存：\n// generics/GenericVarargs.java import java.util.ArrayList; import java.util.List; public class GenericVarargs { @SafeVarargs public static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; makeList(T... args) { List\u0026lt;T\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (T item : args) result.add(item); return result; } public static void main(String[] args) { List\u0026lt;String\u0026gt; ls = makeList(\u0026quot;A\u0026quot;); System.out.println(ls); ls = makeList(\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot;); System.out.println(ls); ls = makeList( \u0026quot;ABCDEFFHIJKLMNOPQRSTUVWXYZ\u0026quot;.split(\u0026quot;\u0026quot;)); System.out.println(ls); } } /* Output: [A] [A, B, C] [A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z] */  此处显示的 makeList() 方法产生的功能与标准库的 java.util.Arrays.asList() 方法相同。\n@SafeVarargs 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。\nJava 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此，List\u0026lt;String\u0026gt; 和 List\u0026lt;Integer\u0026gt; 在运行时实际上是相同的类型。它们都被擦除成原生类型 List。\n边界 `声明 T 必须是 HasF 类型或其子类。如果情况确实如此，就可以安全地在 **obj** 上调用f()` 方法。\n我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后你将看到）。我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例，T 擦除到了 HasF，就像在类的声明中用 HasF 替换了 T 一样。\n你想要使用泛型T中的方法和属性就首先需要确定该泛型中有，因此你需要泛型T继承一个含有该属性与方法的类，为它定义边界\n例如， List\u0026lt;T\u0026gt; 这样的类型注解会被擦除为 List，普通的类型变量在未指定边界的情况下会被擦除为 Object。\n第二十一章 数组 所以一个 ArrayList 的效率不如数组\nArrays.toString() 来将数组转换为可读字符串\n这个例子使用 Arrays.deepToString() 方法，将多维数组转换成 String 类型，就像输出中显示的那样。\nArrays.setAll(a[i][j], n -\u0026gt; val++);  Java 8 增加了 Arrays.setAll() 方法,其使用生成器来生成插入数组中的值。此生成器符合函数式接口 IntUnaryOperator ，只使用一个非 默认 的方法 ApplyAsint(int操作数) 。 Arrays.setAll() 传递当前数组索引作为操作数，因此一个选项是提供 n -\u0026gt; n 的 lambda 表达式来显示数组的索引（在上面的代码中很容易尝试）。这里，我们忽略索引，只是插入递增计数器的值。\nArrays工具类 您已经看到了 java.util.Arrays 中的 fill() 和 setAll()/parallelSetAll() 。该类包含许多其他有用的 静态 程序方法，我们将对此进行研究。\n概述:\n asList(): 获取任何序列或数组，并将其转换为一个 列表集合 （集合章节介绍了此方法）。 copyOf()：以新的长度创建现有数组的新副本。 copyOfRange()：创建现有数组的一部分的新副本。 equals()：比较两个数组是否相等。 deepEquals()：多维数组的相等性比较。 stream()：生成数组元素的流。 hashCode()：生成数组的哈希值(您将在附录中了解这意味着什么:理解equals()和hashCode())。 deepHashCode(): 多维数组的哈希值。 sort()：排序数组 parallelSort()：对数组进行并行排序，以提高速度。 binarySearch()：在已排序的数组中查找元素。 parallelPrefix()：使用提供的函数并行累积(以获得速度)。基本上，就是数组的reduce()。 spliterator()：从数组中产生一个Spliterator;这是本书没有涉及到的流的高级部分。 toString()：为数组生成一个字符串表示。你在整个章节中经常看到这种用法。 deepToString()：为多维数组生成一个字符串。你在整个章节中经常看到这种用法。对于所有基本类型和对象，所有这些方法都是重载的。  parallelSort() 算法将大数组拆分成更小的数组，直到数组大小达到极限，然后使用普通的 Arrays .sort() 方法。然后合并结果。该算法需要不大于原始数组的额外工作空间。\n一旦数组被排序，您就可以通过使用 Arrays.binarySearch() 来执行对特定项的快速搜索。但是，如果尝试在未排序的数组上使用 binarySearch()，结果是不可预测的。说明使用二分查找的前提是数组已经有序\n第二十二章 枚举 基本 enum 特性 我们已经在初始化和清理 这章章看到，调用 enum 的 values() 方法，可以遍历 enum 实例 .values() 方法返回 enum 实例的数组，而且该数组中的元素严格保持其在 enum 中声明时的顺序，因此你可以在循环中使用 values() 返回的数组。\n创建 enum 时，编译器会为你生成一个相关的类，这个类继承自 Java.lang.Enum。下面的例子演示了 Enum 提供的一些功能：\n// enums/EnumClass.java // Capabilities of the Enum class enum Shrubbery { GROUND, CRAWLING, HANGING } public class EnumClass { public static void main(String[] args) { for(Shrubbery s : Shrubbery.values()) { System.out.println( s + \u0026quot; ordinal: \u0026quot; + s.ordinal()); System.out.print( s.compareTo(Shrubbery.CRAWLING) + \u0026quot; \u0026quot;); System.out.print( s.equals(Shrubbery.CRAWLING) + \u0026quot; \u0026quot;); System.out.println(s == Shrubbery.CRAWLING); System.out.println(s.getDeclaringClass()); System.out.println(s.name()); System.out.println(\u0026quot;********************\u0026quot;); } // Produce an enum value from a String name: for(String s : \u0026quot;HANGING CRAWLING GROUND\u0026quot;.split(\u0026quot; \u0026quot;)) { Shrubbery shrub = Enum.valueOf(Shrubbery.class, s); System.out.println(shrub); } } }  使用 static import 能够将 enum 实例的标识符带入当前的命名空间，所以无需再用 enum 类型来修饰 enum 实例。这是一个好的想法吗？或者还是显式地修饰 enum 实例更好？这要看代码的复杂程度了。编译器可以确保你使用的是正确的类型，所以唯一需要担心的是，使用静态导入会不会导致你的代码令人难以理解。多数情况下，使用 static import 还是有好处的，不过，程序员还是应该对具体情况进行具体分析。\n注意，在定义 enum 的同一个文件中，这种技巧无法使用，如果是在默认包中定义 enum，这种技巧也无法使用（在 Sun 内部对这一点显然也有不同意见）。\npublic enum SpicinessEnum { NOT, MILD, MEDIUM, HOT, FLAMING } // enums/Burrito2.java // {java enums.Burrito2} package enums; import static enums.SpicinessEnum.*; public class Burrito2 {  我们已经知道，所有的 enum 都继承自 Java.lang.Enum 类。由于 Java 不支持多重继承，所以你的 enum 不能再继承其他类：\nenum NotPossible extends Pet { ... // Won't work  第二十三章 注解 元注解 Java 语言中目前有 5 种标准注解（前面介绍过），以及 5 种元注解。元注解用于注解其他的注解\n   注解 解释     @Target 表示注解可以用于哪些地方。可能的 ElementType 参数包括： CONSTRUCTOR：构造器的声明 FIELD：字段声明（包括 enum 实例） LOCAL_VARIABLE：局部变量声明 METHOD：方法声明 PACKAGE：包声明 PARAMETER：参数声明 TYPE：类、接口（包括注解类型）或者 enum 声明   @Retention 表示注解信息保存的时长。可选的 RetentionPolicy 参数包括： SOURCE：注解将被编译器丢弃 CLASS：注解在 class 文件中可用，但是会被 VM 丢弃。 RUNTIME：VM 将在运行期也保留注解，因此可以通过反射机制读取注解的信息。   @Documented 将此注解保存在 Javadoc 中   @Inherited 允许子类继承父类的注解   @Repeatable 允许一个注解可以被使用一次或者多次（Java 8）。    大多数时候，程序员定义自己的注解，并编写自己的处理器来处理他们。\n注解元素 在 UseCase.java 中定义的 @UseCase 的标签包含 int 元素 id 和 String 元素 description。注解元素可用的类型如下所示：\n 所有基本类型（int、float、boolean等） String Class enum Annotation 以上类型的数组  如果你使用了其他类型，编译器就会报错。注意，也不允许使用任何包装类型，但是由于自动装箱的存在，这不算是什么限制。注解也可以作为元素的类型。稍后你会看到，注解嵌套是一个非常有用的技巧。\n第二十四章 并发编程  并发是关于正确有效地控制对共享资源的访问。 并行是使用额外的资源来更快地产生结果。  并发通常意味着“不止一个任务正在执行中”，而并行性几乎总是意味着“不止一个任务同时执行。\n并发\n同时完成多个任务。在开始处理其他任务之前，当前任务不需要完成。并发解决了阻塞发生的问题。当任务无法进一步执行，直到外部环境发生变化时才会继续执行。最常见的例子是I/O，其中任务必须等待一些input（在这种情况下会被阻止）。这个问题产生在I/O密集型。\n并行\n同时在多个地方完成多个任务。这解决了所谓的计算密集型问题，如果将程序分成多个部分并在不同的处理器上编辑不同的部分，程序可以运行得更快。\n术语混淆的原因在上面的定义中显示：其中核心是“在同一时间完成多个任务。”并行性通过多个处理器增加分布。更重要的是，两者解决了不同类型的问题：解决I/O密集型问题，并行化可能对你没有任何好处，因为问题不是整体速度，而是阻塞。并且考虑到计算力限制问题并试图在单个处理器上使用并发来解决它可能会浪费时间。两种方法都试图在更短的时间内完成更多，但它们实现加速的方式是不同的，并且取决于问题所带来的约束。\n我们甚至可以尝试添加细致的粒度去定义（但是，这不是标准化的术语）：\n 纯并发：任务仍然在单个CPU上运行。纯并发系统产生的结果比顺序系统更快，但如果有更多的处理器，则运行速度不会更快 并发-并行：使用并发技术，结果程序利用更多处理器并更快地生成结果 并行-并发：使用并行编程技术编写，如果只有一个处理器，结果程序仍然可以运行（Java 8 Streams就是一个很好的例子）。 纯并行：除非有多个处理器，否则不会运行。  Runnable 和Callable区别 https://blog.csdn.net/u012894692/article/details/80215140\nexecute和submit的区别与联系 https://blog.csdn.net/mryang125/article/details/81879096\n附录:编程指南 附录:理解equals和hashCode方法 参考博客\n一个合适的 equals()函数必须满足以下五点条件：\n 反身性：对于任何 x， x.equals(x) 应该返回 true。 对称性：对于任何 x 和 y， x.equals(y) 应该返回 true当且仅当 y.equals(x) 返回 true 。 传递性：对于任何x,y,还有z，如果 x.equals(y) 返回 true 并且 y.equals(z) 返回 true，那么 x.equals(z) 应该返回 true。 一致性：对于任何 x和y，在对象没有被改变的情况下，多次调用 x.equals(y) 应该总是返回 true 或者false。 对于任何非null的x，x.equals(null)应该返回false。  下面是满足这些条件的测试，并且判断对象是否和自己相等（我们这里称呼其为右值）：\n 如果右值是null，那么不相等。 如果右值是this，那么两个对象相等。 如果右值不是同一个类型或者子类，那么两个对象不相等。 如果所有上面的检查通过了，那么你必须决定 右值 中的哪些字段是重要的，然后比较这些字段。 Java 7 引入了 Objects 类型来帮助这个流程，这样我们能够写出更好的 equals() 函数。  存储一组元素最快的数据结构是数组\n附录:对象序列化 Java 的对象序列化将那些实现了 Serializable 接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可通过网络进行，这意味着序列化机制能自动弥补不同操作系统之间的差异。也就是说，可以在运行 Windows 系统的计算机上创建一个对象，将其序列化，通过网络将它发送给一台运行 Unix 系统的计算机，然后在那里准确地重新组装，而却不必担心数据在不同机器上的表示会不同，也不必关心宇节的顺序或者其他任何细节。\n对象序列化的概念加入到语言中是为了支持两种主要特性。一是 Java 的远程方法调用（Remote Method Invocation，RMI），它使存活于其他计算机上的对象使用起来就像是存活于本机上一样。当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值。\n只要对象实现了 Serializable 接口（该接口仅是一个标记接口，不包括任何方法），对象的序列化处理就会非常简单。当序列化的概念被加入到语言中时，许多标准库类都发生了改变，以便具备序列化特性-其中包括所有基本数据类型的封装器、所有容器类以及许多其他的东西。甚至 Class 对象也可以被序列化。\n要序列化一个对象，首先要创建某些 OutputStream 对象，然后将其封装在一个 ObjectOutputStream 对象内。这时，只需调用 writeObject() 即可将对象序列化，并将其发送给 OutputStream（对象化序列是基于字节的，因要使用 InputStream 和 OutputStream 继承层次结构）。要反向进行该过程（即将一个序列还原为一个对象），需要将一个 InputStream 封装在 ObjectInputStream 内，然后调用 readObject()。和往常一样，我们最后获得的是一个引用，它指向一个向上转型的 Object，所以必须向下转型才能直接设置它们。\ntry( ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(\u0026quot;worm.dat\u0026quot;)) ) { out.writeObject(\u0026quot;Worm storage\\n\u0026quot;); out.writeObject(w); } try( ObjectInputStream in = new ObjectInputStream( new FileInputStream(\u0026quot;worm.dat\u0026quot;)) ) { String s = (String)in.readObject(); Worm w2 = (Worm)in.readObject(); System.out.println(s + \u0026quot;w2 = \u0026quot; + w2); }  恢复 b1 后，会调用 Blip1 默认构造器。这与恢复一个 Serializable 对象不同。对于 Serializable 对象，对象完全以它存储的二进制位为基础来构造，而不调用构造器。而对于一个 Externalizable 对象，所有普通的默认构造器都会被调用（包括在字段定义时的初始化），然后调用 readExternal() 必须注意这一点\u0026ndash;所有默认的构造器都会被调用，才能使 Externalizable 对象产生正确的行为。\n附录:流式IO I/O 流屏蔽了实际的 I/O 设备中处理数据的细节：\n 字节流对应原生的二进制数据； 字符流对应字符数据，它会自动处理与本地字符集之间的转换； 缓冲流可以提高性能，通过减少底层 API 的调用次数来优化 I/O。  从 JDK 文档的类层次结构中可以看到，Java 类库中的 I/O 类分成了输入和输出两部分。在设计 Java 1.0 时，类库的设计者们就决定让所有与输入有关系的类都继承自 InputStream，所有与输出有关系的类都继承自 OutputStream。所有从 InputStream 或 Reader 派生而来的类都含有名为 read() 的基本方法，用于读取单个字节或者字节数组。同样，所有从 OutputStream 或 Writer 派生而来的类都含有名为 write() 的基本方法，用于写单个字节或者字节数组。但是，我们通常不会用到这些方法，它们之所以存在是因为别的类可以使用它们，以便提供更有用的接口。\n输入流类型 InputStream 表示那些从不同数据源产生输入的类，如表 I/O-1 所示，这些数据源包括：\n 字节数组； String 对象； 文件； “管道”，工作方式与实际生活中的管道类似：从一端输入，从另一端输出； 一个由其它种类的流组成的序列，然后我们可以把它们汇聚成一个流； 其它数据源，如 Internet 连接。  每种数据源都有相应的 InputStream 子类。另外，FilterInputStream 也属于一种 InputStream，它的作用是为“装饰器”类提供基类。其中，“装饰器”类可以把属性或有用的接口与输入流连接在一起，这个我们稍后再讨论。\n表 I/O-1 InputStream 类型\n   类 功能 构造器参数 如何使用     ByteArrayInputStream 允许将内存的缓冲区当做 InputStream 使用 缓冲区，字节将从中取出 作为一种数据源：将其与 FilterInputStream 对象相连以提供有用接口   StringBufferInputStream 将 String 转换成 InputStream 字符串。底层实现实际使用 StringBuffer 作为一种数据源：将其与 FilterInputStream 对象相连以提供有用接口   FileInputStream 用于从文件中读取信息 字符串，表示文件名、文件或 FileDescriptor 对象 作为一种数据源：将其与 FilterInputStream 对象相连以提供有用接口   PipedInputStream 产生用于写入相关 PipedOutputStream 的数据。实现“管道化”概念 PipedOutputSteam 作为多线程中的数据源：将其与 FilterInputStream 对象相连以提供有用接口   SequenceInputStream 将两个或多个 InputStream 对象转换成一个 InputStream 两个 InputStream 对象或一个容纳 InputStream 对象的容器 Enumeration 作为一种数据源：将其与 FilterInputStream 对象相连以提供有用接口   FilterInputStream 抽象类，作为“装饰器”的接口。其中，“装饰器”为其它的 InputStream 类提供有用的功能。见表 I/O-3 见表 I/O-3 见表 I/O-3    输出流类型 如表 I/O-2 所示，该类别的类决定了输出所要去往的目标：字节数组（但不是 String，当然，你也可以用字节数组自己创建）、文件或管道。\n另外，FilterOutputStream 为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来，这些稍后会讨论。\n表 I/O-2：OutputStream 类型\n   类 功能 构造器参数 如何使用     ByteArrayOutputStream 在内存中创建缓冲区。所有送往“流”的数据都要放置在此缓冲区 缓冲区初始大小（可选） 用于指定数据的目的地：将其与 FilterOutputStream 对象相连以提供有用接口   FileOutputStream 用于将信息写入文件 字符串，表示文件名、文件或 FileDescriptor 对象 用于指定数据的目的地：将其与 FilterOutputStream 对象相连以提供有用接口   PipedOutputStream 任何写入其中的信息都会自动作为相关 PipedInputStream 的输出。实现“管道化”概念 PipedInputStream 指定用于多线程的数据的目的地：将其与 FilterOutputStream 对象相连以提供有用接口   FilterOutputStream 抽象类，作为“装饰器”的接口。其中，“装饰器”为其它 OutputStream 提供有用功能。见表 I/O-4 见表 I/O-4 见表 I/O-4    附录:标准IO 从标准输入中读取 遵循标准 I/O 模型，Java 提供了标准输入流 System.in、标准输出流 System.out 和标准错误流 System.err。在本书中，你已经了解到如何使用 System.out将数据写到标准输出。 System.out 已经预先包装0成了 PrintStream 对象。标准错误流 System.err 也预先包装为 PrintStream 对象，但是标准输入流 System.in 是原生的没有经过包装的 InputStream。这意味着尽管可以直接使用标准输出流 System.in 和标准错误流 System.err，但是在读取 System.in 之前必须先对其进行包装。\n附录:并发底层原理 ","id":3,"section":"posts","summary":"感谢该项目的开源从中学到了很多的知识，对于java也有了更深的了解 已经看了两遍，里面写的很好，从中收获了跟多，也认识到了自己的许多不足。对于","tags":["Java"],"title":"OnJava8学习与理解","uri":"https://mumulx.github.io/2020/05/onjava8/","year":"2020"},{"content":" 学习路线（掌握） JAVA语法 Java基础 JVM  类加载机制 字节码执行机制 JVM内存模型 GC垃圾回收 JVM性能监控与故障定位 JVM调优  多线程  并发编程的基础 线程池 锁 并发容器 原子类 JUC并发工具类### 数据结构和算法  数据结构  字符串 数组 链表 堆、栈、队列 二叉树 哈希 图  算法  排序\n 查找\n 贪心\n 分治\n 动态规划\n 回溯\n  计算机网络  ARP协议 IP、ICMP协议 TCP、UDP协议 DNS、HTTP/HTTPS协议 Session/Cookie  MySQL数据库  SQL语句的书写 SQL语句的优化 事务、隔离级别 索引 锁  操作系统  进程、线程 并发、锁 内存管理和调度 I/O原理  设计模式  单例 工厂 代理 策略 模板方法 观察者 适配器 责任链 建造者  模式类别  创建型模式:  单例模式 工厂模式 抽象工厂模式 建造者模式 原型模式  结构型模式:  适配器模式 桥接模式 装饰模式 组合模式 外观模式 享元模式 代理模式  行为型模式:  模板方法模式 命令模式 迭代器模式 观察者模式 中介者模式 备忘录模式 解释器模式 状态模式 策略模式 职责链模式 访问者模式   单例模式 在JUC中有详细介绍\n彻底玩转单例模式\n工厂模式 作用:\n 实现了创建者和调用者的分离 详细分类:  简单工厂模式 工厂方法模式 抽象工厂模式   OOP七大原则\n 开闭原则: -个软件的实体应当对扩展开放,对修改关闭 依赖倒转原则:要针对接口编程，不要针对实现编程 迪米特法则:只与你直接的朋友通信，而避免和陌生人通信  PBP/OBP/OOP的特征 PBP（基于过程）：函数、域与生命周期的概念、函数重载、函数模板、异常处理、范型算法。 OBP（基于对象）：类（接口）、类的生命周期、类模板。 OOP（面向对象）：继承、多态。 三个概念步步深入，后者包括前者。其目的是实现软件开发的可重用性，解决软件危机（软件工程思想未引入之前）。 OOP不可避免设计原则的发展与设计模式的产生，这是OOP独具的特征决定的（正如前面所说，特征的产生是由其产生目的决定的）。\nOOP的方法论（高内聚、低耦合、易复用） OOP的方法论－－如何实现基于OOP特征的抽象?\nOOP设计原则：\nOCP（Open-Closed Principle），开放封闭原则：软件实体应该扩展开放、修改封闭。 实现：合理划分构件，一种可变性不应当散落在代码的很多角落里，而应当被封装到一个对象里；一种可变性不应当与另一个可变性混合在一起。\nDIP(Dependency Inversion Principle)，依赖倒置原则：摆脱面向过程编程思想中高层模块依赖于低层实现，抽象依赖于具体细节。OOP中要做到的是，高层模块不依赖于低层模块实现，二者都依赖于抽象；抽象不依赖于具体实现细节，细节依赖于抽象。 实现：应该通过抽象耦合的方式，使具体类最大可能的仅与其抽象类（接口）发生耦合；程序在需要引用一个对象时,应当尽可能的使用抽象类型作为变量的静态类型,这就是针对接口编程的含义。\nLSP(Liskov Substitution Principle)，Liskov替换原则：继承思想的基础。“只有当衍生类可以替换掉基类，软件单位的功能不会受到影响时，基类才真正被复用，而衍生类也才能够在基类的基础上增加新的行为。”\nISP（Interface Insolation Principle），接口隔离原则：接口功能单一，避免接口污染。 实现：一个类对另外一个类的依赖性应当是建立在最小的接口上的。使用多个专门的接口比使用单一的总接口要好。\nSRP(Single Resposibility Principle)，单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。 如果一个类的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会抑止这个类完成其他职责的能力。\nCARP（Composite/Aggregate Reuse Principle），合成/聚合复用原则：设计模式告诉我们对象委托优于类继承，从UML的角度讲，就是关联关系优于继承关系。尽量使用合成/聚合、尽量不使用继承。 实现：在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，以整合其功能。\nLoD(Law Of Demeter or Principle of Least Knowledge)，迪米特原则或最少知识原则：就是说一个对象应当对其他对象尽可能少的了解。即只直接与朋友通信，或者通过朋友与陌生人通信。 朋友的定义（或关系）： （1）当前对象本身。 （2）以参量的形式传入到当前对象方法中的对象。 （3）当前对象的实例变量直接引用的对象。 （4）当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友。 （5）当前对象所创建的对象。 实现： （1）在类的划分上，应当创建有弱耦合的类。类之间的耦合越弱，就越有利于复用。 （2）在类的结构设计上，每一个类都应当尽量降低成员的访问权限。一个类不应当public自己的属性，而应当提供取值和赋值的方法让外界间接访问自己的属性。 （3）在类的设计上，只要有可能，一个类应当设计成不变类。 （4）在对其它对象的引用上，一个类对其它对象的引用应该降到最低。 （5）尽量限制局部变量的有效范围.\n 核心本质:\n  实例化对象不使用new,用工厂方法代替 将选择实现类, 创建对象统一管理和控制。 从而将调用者跟我们的实现类解耦。   三种模式:\n  简单工厂模式  用来生产同一等级结构中的任意产品(对于增加新的产品，需要覆盖已有代码)  工厂方法模式  用来生产同一等级结构中的固定产品(支持增加任意产品)  抽象工厂模式  围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。   XXXXFactory\n简单工厂模式 public interface Car { void name(); }  public class Tesla implements Car { @Override public void name() { System.out.println(\u0026quot;Tesla!!\u0026quot;); } }  public class WuLing implements Car{ @Override public void name() { System.out.println(\u0026quot;五菱宏光！\u0026quot;); } }  //简单工厂又叫做静态工厂，因为其中的方法都是静态的 //增加一个新的产品，如果你不修改代码，做不到! //开闭原则 public class CarFactory { /*方法一：车工厂，去里面拿车*/ public static Car getCar(String car) { if (car.equals(\u0026quot;五菱\u0026quot;)) { return new WuLing(); } else if (car.equals(\u0026quot;特斯拉\u0026quot;)) { return new Tesla(); } else { return null; } } //方法二 public static Car getWuling(){ return new WuLing(); } public static Car getTesla(){ return new Tesla(); } }  public class Consumer { public static void main(String[] args) { /*买车 接口，所有的实现类！我们要直到Car接口及其实现类 * 我们买车的时候只需要去买某种车，而不需要关注有那些车 * Car car = new WuLing(); Car car2 = new Tesla(); car.name(); car2.name(); */ /*使用工厂创建*/ Car car1 = CarFactory.getCar(\u0026quot;五菱\u0026quot;); } }  工厂方法模式 public interface Car { void name(); }  public class Tesla implements Car { @Override public void name() { System.out.println(\u0026quot;Tesla!!\u0026quot;); } }  public class WuLing implements Car { @Override public void name() { System.out.println(\u0026quot;五菱宏光！\u0026quot;); } }  public interface CarFactor { Car getCar(); }  public class TeslaFactory implements CarFactor { @Override public Car getCar() { return new Tesla(); } }  public class WulingFactory implements CarFactor { @Override public Car getCar() { return new WuLing(); } }  public class Consumer { public static void main(String[] args) { Car car = new WulingFactory().getCar(); Car car1 = new TeslaFactory().getCar(); System.out.println(car); System.out.println(car1); } }     结构复杂度: simple     代码复杂度 simple   编程复杂度: simple   管理上的复杂度 simple    根据设计原则:工厂方法模式! 根据实际业务:简单工厂模式!\n小结:\n 简单工厂模式(静态工厂模式)\n 虽然某种程度上不符合设计原则，但实际使用最多!  工厂方法模式\n 不修改已有类的前提下，通过增加新的工厂类实现扩展。  抽象工厂 模式\n 不可以增加产品，可以增加产品族!   应用场景:\n JDK中Calendar的getInstance方法 JDBC中的Connection对象的获取 Spring中IOC容器创建管理bean对象 反射中Class对象的newInstance方法  抽象工厂模式 定义:抽象工厂模式提供了一个创建一系列相关或者相互依赖对象的接口，无需指定它们具体的类\n适用场景:\n 客户端(应用层)不依赖于产品类实例如何被创建、实现等细节 强调一系列相关的产品对象(属于同一产品族) 一起使用创建对象需要大量的重复代码 提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体的实现  优点:\n 具体产品在应用层的代码隔离，无需关心创建的细节 将一个系列的产品统一到一起创建  缺点:\n 规定了所有可能被创建的产品集合，产品簇中扩展新的产品困难; 增加了系统的抽象性和理解难度  //手机产品接口 public interface IphoneProduct { void start(); void shutdown(); void callup(); void sendsms(); }  //路由器接口 public interface IrouterProduct { void start() ; void shutdown(); void openwifi(); void setting(); }  public class XiaomiPhone implements IphoneProduct { @Override public void start() { System.out.println(\u0026quot;开启小米手机\u0026quot;); } @Override public void shutdown() { System.out.println(\u0026quot;小米手机关机\u0026quot;); } @Override public void callup() { System.out.println(\u0026quot;小米手机打电话\u0026quot;); } @Override public void sendsms() { System.out.println(\u0026quot;小米手机发短信\u0026quot;); } }  public class XiaomiRouter implements IrouterProduct { @Override public void start() { System.out.println(\u0026quot;小米路由器启动\u0026quot;); } @Override public void shutdown() { System.out.println(\u0026quot;小米路由器关闭\u0026quot;); } @Override public void openwifi() { System.out.println(\u0026quot;小米路由器打开wifi\u0026quot;); } @Override public void setting() { System.out.println(\u0026quot;小米路由器设置\u0026quot;); } }  public class HuaWeiPhone implements IphoneProduct { @Override public void start() { System.out.println(\u0026quot;华为手机开启\u0026quot;); } @Override public void shutdown() { System.out.println(\u0026quot;华为手机关机\u0026quot;); } @Override public void callup() { System.out.println(\u0026quot;华为手机打电话\u0026quot;); } @Override public void sendsms() { System.out.println(\u0026quot;华为手机发短信\u0026quot;); } }  public class HuaWeiRouter implements IrouterProduct { @Override public void start() { System.out.println(\u0026quot;华为路由器开启\u0026quot;); } @Override public void shutdown() { System.out.println(\u0026quot;华为路由器关闭\u0026quot;); } @Override public void openwifi() { System.out.println(\u0026quot;华为路由器开启wifi\u0026quot;); } @Override public void setting() { System.out.println(\u0026quot;华为路由器设置\u0026quot;); } }  //抽象产品工厂 public interface IProductFactory { //生产手机 IphoneProduct iphoneProduct(); //生产路由器 IrouterProduct irouterProduct(); }  public class XiaomiFactory implements IProductFactory { @Override public IphoneProduct iphoneProduct() { return new XiaomiPhone(); } @Override public IrouterProduct irouterProduct() { return new XiaomiRouter(); } }  public class HuaWeiFactory implements IProductFactory { @Override public IphoneProduct iphoneProduct() { return new HuaWeiPhone(); } @Override public IrouterProduct irouterProduct() { return new HuaWeiRouter(); } }  public class Client { public static void main(String[] args) { System.out.println(\u0026quot;=====================小米系类产品\u0026quot;); XiaomiFactory xiaomiFactory = new XiaomiFactory(); IphoneProduct iphoneProduct = xiaomiFactory.iphoneProduct(); iphoneProduct.start(); IrouterProduct irouterProduct = xiaomiFactory.irouterProduct(); irouterProduct.start(); System.out.println(\u0026quot;==================华为系列产品\u0026quot;); HuaWeiFactory huaWeiFactory = new HuaWeiFactory(); IphoneProduct iphoneProduct1 = huaWeiFactory.iphoneProduct(); iphoneProduct1.start(); IrouterProduct irouterProduct1 = huaWeiFactory.irouterProduct(); irouterProduct1.start(); } }  建造者模式 建造者模式也属于创建型模式,它提供了一种创建对象的最佳方式。\n定义:将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\n主要作用:在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。\n用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象(把内部的建造过程和细 节隐藏起来)\n例子:\n 工厂(建造者模式) :负责制造汽车(组装过\u0026gt;程和细节在工厂内) 汽车购买者(用户) :你只需要说出你需要的\u0026gt;型号(对象的类型和内容)，然后直接购买就可以使用了(不需要知道汽车是怎么组装的 (车轮、车门、\u0026gt;发动机、方向盘等等) )  既然是建造者模式，那么我们还是继续造房吧，其实我也想不到更简单的例子。假设造房简化为如下步骤: (1)地基(2) 钢筋工程(3)铺电线(4) 粉刷; \u0026ldquo;如果”要盖一座房子，首先要找一个建筑公司或工程 承包商(指挥者)。承包商指挥工人(具体建造者)过来造房子(产品) ，最后验收。\npublic abstract class Builder { abstract void buildA();//地基 abstract void buildB();//钢筋工程 abstract void buildC();//铺电线 abstract void buildD();//粉刷 //完工了 abstract Product getProject(); }  @Setter @Getter @ToString public class Product { private String buildA; private String buildB; private String buildC; private String buildD; }  //具体的工人；具体的建造者 public class Worker extends Builder { //产品 private Product product; public Worker(){ //使用new创建，而不是通过参数传递 product = new Product(); } @Override void buildA() { product.setBuildA(\u0026quot;地基\u0026quot;); } @Override void buildB() { product.setBuildB(\u0026quot;B\u0026quot;); } @Override void buildC() { product.setBuildC(\u0026quot;C\u0026quot;); } @Override void buildD() { product.setBuildD(\u0026quot;D\u0026quot;); } @Override Product getProject() { return product; } }  //指挥:核心。负责指挥构建一一个工程， 工程如何构建，由它决定 public class Director { public Product build(Builder builder){ //指挥工人建房子 builder.buildA(); builder.buildB(); builder.buildC(); builder.buildD(); return builder.getProject(); } }  public class Test { public static void main(String[] args) { //指挥 Director director = new Director(); //指挥 具体的工人完成产品 Product build = director.build(new Worker()); System.out.println(build); } }  上面示例是Builder模式的常规用法，导演类Director在Builder模式中具有很重要的作用，它用于指导具 体构建者如何构建产品，控制调用先后次序,并向调用者返回完整的产品类,但是有些情况下需要简化系统 结构，可以把Director和抽象建造者进行结合。\n通过静态内部类方式实现零件无序装配构造,这种方式使用更加灵活，更符合定义。内部有复杂对象的默认 实现，使用时可以根据用户需求自由定义更改内容,并且无需改变具体的构造方式。就可以生产出不同复杂 产品\n比如:比如麦当劳的套餐，服务员(具体建造者)可以随意搭配任意几种产品(零件)组成一款套餐(产 品)，然后出售给客户。比第一 种方式少了指挥者,主要是因为第二种方式把指挥者交给用户来操作,使得 产品的创建更加简单灵活。\npublic abstract class Builder { abstract Builder buildA(String msg);//汉堡 abstract Builder buildB(String msg);//可乐 abstract Builder buildC(String msg);//薯条 abstract Builder buildD(String msg);//甜点 //生产了 abstract Product getProject(); }  //套餐 @Setter @Getter @ToString public class Product { //默认值 private String buildA=\u0026quot;汉堡\u0026quot;; private String buildB=\u0026quot;可乐\u0026quot;; private String buildC=\u0026quot;薯条\u0026quot;; private String buildD=\u0026quot;甜点\u0026quot;; }  //既是工人，又是指挥者 public class worker extends Builder { Product product; public worker(){ product = new Product(); } @Override Builder buildA(String msg) { product.setBuildB(msg); return this; } @Override Builder buildB(String msg) { product.setBuildA(msg); return this; } @Override Builder buildC(String msg) { product.setBuildC(msg); return this; } @Override Builder buildD(String msg) { product.setBuildD(msg); return this; } @Override Product getProject() { return product; } }  public class Test { public static void main(String[] args) { //服务员 worker worker = new worker(); //具有产品的默认值 在原来的基础上可以自由组合了，如果不组合，也有默认的套餐 //Product project = worker.getProject(); //链式编程 return this的功劳 Product project = worker .buildA(\u0026quot;AAAAAA\u0026quot;) .getProject(); System.out.println(project); } }  优点:\n 产品的建造和表示分离，实现了解耦。使用建造者模式可以使客户端不必知道产品内部组成的细节。 将复杂产品的创建步骤分解在不同的方法中， 使得创建过程更加清晰 具体的建造者类之间是相互独立的，这有利于系统的扩展。增加新的具体建造者无需修改原有类库的代码，符合“开闭原则”。  缺点:\n 建造者模式所创建的产品一-般具有较多的共同点，其组成部分相似;如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一-定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。  应用场景:\n 需要生成的产品对象有复杂的内部结构，这些产品对象具备共性; 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。 适合于一个具有较多的零件(属性)的产品(对象)的创建过程。  建造者与抽象工厂模式的比较:\n 与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回-系列相关的产品，这些产品位于不同的产品等级结构,构成了一个产品族。 在抽象工厂模式中，客户端实例化工厂类,然后调用工厂方法获取所需产品对象,而在建造者模式中,客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于- -步步构造一个复杂对象, 返回-一个完整的对象。 如果将抽象工厂模式看成汽车配件生产工厂,生产- -个产品族的产品，那么建造者模式就是一个汽车组装工厂,通过对部件的组装可以返回一辆完整的汽车!  原型模式 克隆（在js的继承中有原型的概念）\n/* 1. 实现一个接口 2. 重写一个方法 * **/ //Video:视频类 @Setter @Getter @AllArgsConstructor @NoArgsConstructor public class Video implements Cloneable{ private String name; private Date createTime; @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } }  /*客户端 ： 克隆*/ public class BiliBili { public static void main(String[] args) throws CloneNotSupportedException { //原型对象 Date date = new Date(); Video v1 = new Video(\u0026quot;hahah\u0026quot;, date); System.out.println(\u0026quot;v1====\u0026gt;\u0026quot;+v1); System.out.println(\u0026quot;v1====\u0026gt;hash\u0026quot;+v1.hashCode()); //v1可以克隆出v2 Video v2 = (Video)v1.clone(); System.out.println(\u0026quot;v2====\u0026gt;\u0026quot;+v2); //克隆出来的对象是属性值一摸一样的（但是hashcode是不同的） } }  这样的克隆是浅克隆，不仅会将对象的值克隆过来也会将属性值的引用也克隆过来\n当我们修改了v1属性date的时候会发现v2的date的值也会发生发了改变\n深克隆方法一：改造clone方法\n@Setter @Getter @AllArgsConstructor @NoArgsConstructor public class Video implements Cloneable{ private String name; private Date createTime; @Override protected Object clone() throws CloneNotSupportedException { //实现深克隆：或者使用序列化、反序列化 Object obj = super.clone(); Video v = (Video) obj; //将这个对象的属性也进行克隆 v.createTime = (Date)this.createTime.clone(); return obj; } }  在我们的spring框架中就体现了这点（Bean）：单例模式、原型模式\n原型模式+工厂模式===\u0026gt;new\u0026lt;=\u0026gt;原型模式clone\n适配器模式 结构性模式作用：\n从程序的结构上实现松耦合,从而可以扩大整体的类结构,用来解决更大的问题。\n//要被适配的类： 网线（许多笔记本电脑没有网线接口，因此需要usb转接） public class Adaptee { public void request() { System.out.println(\u0026quot;连接网线上网\u0026quot;); } }  /** * 1. 继承（类适配器，单继承） * 2. 组合（对象适配器，常用） * */ //真正的适配器！，需要连接USB，连接上网线 public class Adapter extends Adaptee implements NetToUsb{ @Override public void handleRequest() { super.request();//可以上网了 } }  //客户端类：想上网，插不上网线 public class Computer { //我们的电脑需要连接上转接器才可以上网 public void net(NetToUsb adapter) {//插上一个转接头 //上网的具体实现~，找一个转接头 adapter.handleRequest(); } public static void main(String[] args) { //电脑、适配器、网线~ Computer computer = new Computer();//电脑 Adaptee adaptee = new Adaptee();//网线 Adapter adapter = new Adapter();//适配器 computer.net(adapter); } }  public interface NetToUsb { //作用：处理请求，网线===》usb public void handleRequest(); }  使用组合\npublic interface NetToUsb { //作用：处理请求，网线===》usb public void handleRequest(); }  /** * 1. 继承（类适配器，单继承） * 2. 组合（对象适配器，常用） * */ //真正的适配器！，需要连接USB，连接上网线 @AllArgsConstructor public class Adapter implements NetToUsb{ private Adaptee adaptee; @Override public void handleRequest() { adaptee.request();//可以上网了 } }  //要被适配的类： 网线（许多笔记本电脑没有网线接口，因此需要usb转接） public class Adaptee { public void request() { System.out.println(\u0026quot;连接网线上网\u0026quot;); } }  //客户端类：想上网，插不上网线 public class Computer { //我们的电脑需要连接上转接器才可以上网 public void net(NetToUsb adapter) {//插上一个转接头 //上网的具体实现~，找一个转接头 adapter.handleRequest(); } public static void main(String[] args) { //电脑、适配器、网线~ Computer computer = new Computer();//电脑 Adaptee adaptee = new Adaptee();//网线 Adapter adapter = new Adapter(adaptee);//适配器 computer.net(adapter); } }  将一个类的接口转换成客户希望的另外一个接口。 Adapter模式使得原本由于接口不兼容而不能一起工作的 那些类可以在一起工作!\n角色分析\n 目标接口:客户所期待的接口，目标可以是具体的或抽象的类,也可以是接口。 需要适配的类: 需要适配的类或适配者类。 适配器:通过包装-一个需要适配的对象，把原接口转换成目标对象!  对象适配器优点\n 一个对象适配器可以把多个不同的适配者适配到同一个目标 可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据\u0026rdquo;里氏代换原则”，适配者的子类也可通过该适配器进行适配。  类适配器缺点\n 对于Java、 C#等不支持多重类继承的语言，一-次最 多只能适配一个适配者类，不能同时适配多个适配者; 在Java、 C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类,其使用有一定的局限性。  适用场景\n 系统需要使用一 -些现有的类，而这些类的接口(如方法名)不符合系统的需要，甚至没有这些类的源代码。 想创建一个可以重复使用的类，用于与- -些彼此之间没有太大关联的一-些类， 包括- -些可能在将来引进的类一起工作。  优先使用组合方法\nInputStreamReader(InputStream)使用了适配器\nspringMVC中就使用了适配器：处理器映射器、处理器适配器\nGUI中也含有了许多适配器\nspringboot自动装配中也使用了许多适配器\n代理模式 为什么要学习代理模式?因为这就是SpringAOP的底层! [SpringAOP 和SpringMVC]\n代理模式的分类:\n 静态代理 动态代理  静态代理 直接找房东租房\n//房东 public class Host { public void rent() { System.out.println(\u0026quot;房东要出租房间了\u0026quot;); } }  //我：要去租房 public class Client { public static void main(String[] args) { Host host = new Host(); host.rent(); } }  代理\n//我：要去租房 public class Client { public static void main(String[] args) { //房东要出租房子 Host host = new Host(); //代理，中介帮房东租房子，代理角色一般会有一些符数操作 Proxy proxy = new Proxy(host); //你不要面对房东直接去租房即可 proxy.rent(); } }  //中介 @AllArgsConstructor public class Proxy implements Rent{ private Host host; @Override public void rent() { seeHouse(); host.rent(); fare(); hetong(); } //看房 public void seeHouse(){ System.out.println(\u0026quot;中介带你看房\u0026quot;); } //收中介费 public void fare() { System.out.println(\u0026quot;收中介费\u0026quot;); } //签租赁合同 public void hetong() { System.out.println(\u0026quot;签租赁合同\u0026quot;); } }  //房东 public class Host { public void rent() { System.out.println(\u0026quot;房东要出租房间了\u0026quot;); } }  //租房的接口 public interface Rent { public void rent(); }  角色分析:\n 抽象角色: 一般会使用接口或者抽象类来解决 真实角色:被代理的角色 代理角色:代理真实角色，代理真实角色后，我们一般会做一些附属操作 客户:访问代理对象的人!  代理模式的好处:\n 可以使真实角色的操作更加纯粹!不用去关注一些公共的业务 公共也就就交给代理角色!实现了业务的分工! 公共业务发生扩展的时候，方便集中管理!|  缺点:\n 一个真实角色就会产生一个代理角色;代码量会翻倍开发效率会变低  代码步骤:\n 接口 真实角色 代理角色 客户端访问代理角色  加深理解 public interface UserService { void add(); void delete(); void update(); void query(); }  public class UserServiceImpl implements UserService { @Override public void add() { System.out.println(\u0026quot;add了一个用户\u0026quot;); } @Override public void delete() { System.out.println(\u0026quot;delete了一个用户\u0026quot;); } @Override public void update() { System.out.println(\u0026quot;update了一个用户\u0026quot;); } @Override public void query() { System.out.println(\u0026quot;query了一个用户\u0026quot;); } }  @Setter public class UserServiceProxy implements UserService { UserService userService = new UserServiceImpl(); @Override public void add() { msg(\u0026quot;add\u0026quot;); userService.add(); } @Override public void delete() { msg(\u0026quot;delete\u0026quot;); userService.delete(); } @Override public void update() { msg(\u0026quot;update\u0026quot;); userService.update(); } @Override public void query() { msg(\u0026quot;query\u0026quot;); userService.query(); } public void msg(String msg) { System.out.println(msg); } }  public class Client { public static void main(String[] args) { UserService userService = new UserServiceImpl(); //使用代理增加功能而不修改原有代码；只做增强，不做改变 UserServiceProxy userServiceProxy = new UserServiceProxy(); userServiceProxy.setUserService(userService); userServiceProxy.add(); } }  动态代理 底层使用反射\n 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是我们直接写好的! 动态代理分为两大类:基于接口的动态代理，基于类的动态代理  基于接口\u0026mdash;-JDK动态代理[我们在这里使用] 基于类: cglib java字节码实现: javasist   需要了解两个类: Proxy: 代理，InvocationHandler: 调用处理程序\nInvocationHandler\nProxy\n//租房的接口 public interface Rent { public void rent(); }  //房东 public class Host implements Rent { @Override public void rent() { System.out.println(\u0026quot;房东要出租房间了\u0026quot;); } }  //等会我们使用这个类，自动生成代理类 @Setter @Getter public class ProxyInvocationHandler implements InvocationHandler { //被代理的接口 private Rent rent; //生成得到代理类 public Object getProxy() { /** * * this.getClass().getClassLoader():加载的类的位置 * rent.getClass().getInterfaces()：要代理的接口 * this：代表自己的InvocationHandler，调用InvocationHandler来处理 * */ return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(),this); } //处理代理实例，并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { seeHouse(); //动态代理的本质，就是使用反射机制来实现的 Object invoke = method.invoke(rent, args); fare(); return invoke; } public void seeHouse() { System.out.println(\u0026quot;看房子啦~~\u0026quot;); } public void fare() { System.out.println(\u0026quot;收中介费了~~\u0026quot;); } }  public class Client { public static void main(String[] args) { //真实角色 Host host = new Host(); //代理角色：现在没有 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //通过调用程序处理角色来处理我们要调用的接口对象 pih.setRent(host); //获得代理类rent Rent rent = (Rent)pih.getProxy();//这里的就是动态生成的，我们并没有写 rent.rent(); } }  万能代理 //等会我们使用这个类，自动生成代理类 @Setter @Getter public class ProxyInvocationHandler implements InvocationHandler { //被代理的接口 private Object target; //生成得到代理类 public Object getProxy() { /** * * this.getClass().getClassLoader():加载的类的位置 * rent.getClass().getInterfaces()：要代理的接口 * this：代表自己的InvocationHandler，调用InvocationHandler来处理 * */ return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this); } //处理代理实例，并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //动态代理的本质，就是使用反射机制来实现的 Object invoke = method.invoke(target, args); return invoke; } }  public class Cleint { public static void main(String[] args) { //真实角色 UserService userService = new UserServiceImpl(); //代理角色，不存在 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //设置要代理的对象 pih.setTarget(userService); UserService proxy = (UserService)pih.getProxy(); proxy.query(); } }  动态代理的好处:\n 可以使真实角色的操作更加纯粹!不用去关注一些公共的业务 公共也就就交给代理角色!实现了业务的分工! 公共业务发生扩展的时候，方便集中管理! 一个动态代理类代理的是一一个接口， 一般就是对应的一类业务 一个动态代理类可以代理多个类,只要是实现了同一个接口即可!  桥接模式 桥接模式是将抽象部分与它的实现部分分离,使它们都可以独立地变化。它是一种对象结构型模式， 又称为柄体(Handle and Body)模式或接口(Interfce)模式。\n分析:这个场景中有两个变化的维度:品牌、类型。\n抽象出两个类：品牌类、类型类\n//品牌 public interface Brand { void info(); }  public class Apple implements Brand { @Override public void info() { System.out.println(\u0026quot;苹果\u0026quot;); } }  public class Lenovo implements Brand { @Override public void info() { System.out.println(\u0026quot;联想\u0026quot;); } }  //电脑类型 抽象的电脑类 @AllArgsConstructor @Setter @Getter public class Computer { //组合，品牌~桥 protected Brand brand; public void info(){ brand.info();//电脑自带的品牌 } } class Desktop extends Computer { public Desktop(Brand brand) { super(brand); } @Override public void info() { super.info(); System.out.println(\u0026quot;台式电脑\u0026quot;); } } class Laptop extends Computer { public Laptop(Brand brand) { super(brand); } @Override public void info() { super.info(); System.out.println(\u0026quot;笔记本点啊弄\u0026quot;); } }  public class Test { public static void main(String[] args) { //苹果笔记本 Computer computer = new Laptop(new Apple()); computer.info(); //联想笔记本 Computer computer1 = new Desktop(new Lenovo()); computer1.info(); } }  好处分析:\n 桥接模式偶尔类似于多继承方案，但是多继承方案违背了类的单- -职责原则，复用性比较差,类的个数也非常多，桥接模式是比多继承方案更好的解决方法。极大的减少了子类的个数，从而降低管理和维护的成本 桥接模式提高了系统的可扩充性,在两个变化维度中任意扩展一个维度, 都不需要修改原有系统。符合开闭原则，就像一座桥， 可以把两个变化的维度连接起来!  劣势分析:\n 桥接模式的弓|入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。  最佳实践:\n如果一个系统需要在构建的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立-个关联关系。抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将- -个抽象化子类的对象和一个实现化子类的对象进行组合,即系统需要对抽象化角色和实现化角色进行动态耦合。\n 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统,桥接模式尤为适用。  场景:\n Java语言通过Java虚拟机实现了平台的无关性。 AWT中的Peer架构 JDBC驱动程序也是桥接模式的应用之一。  ","id":4,"section":"posts","summary":"学习路线（掌握） JAVA语法 Java基础 JVM 类加载机制 字节码执行机制 JVM内存模型 GC垃圾回收 JVM性能监控与故障定位 JVM调优 多线程 并发编程","tags":["Java"],"title":"Java设计模式","uri":"https://mumulx.github.io/2020/05/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","year":"2020"},{"content":" JDK8 lambda :简化代码 lambda λ 组成 ：\n 逗号隔开的参数列表 (x,x,x) () 箭头符号 -\u0026gt;\n 方法体 （λ代码块）  示例\npackage lambda; public class Demo01 { public static void test01(){ new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026quot;run....\u0026quot;); } }).start(); } public static void test02(){ new Thread( // () -\u0026gt; { System.out.println(\u0026quot;run....\u0026quot;); } () -\u0026gt; System.out.println(\u0026quot;run....\u0026quot;) ).start(); ; } public static void main(String[] args) { // test01() ; test02() ; } }  new Thread( () -\u0026gt; System.out.println(\u0026quot;run....\u0026quot;) ).start(); ;  以上述为例， new Thread( )中是一个接口、抽象类。但是为了避免 不能区分 lambda到底是重写的哪个方法，语法上lambda要求 重写的 接口、抽象类中 有且只能有一个 抽象方法。\n仔细观察，lambda重写的接口、抽象类中 会标识一个@FunctionalInterface，称为函数式接口。\n函数式接口：标注@FunctionalInterface，有且只有一个 抽象方法。\nlambda表达式重写的 必须是 函数式接口（或者 只有一个抽象方法的抽象类）\n函数式接口要注意以下几点：\n 即使没有标注@FunctionalInterface，但是只有一个抽象方法，也称之为函数式接口(接口中的方法的默认修饰符为public abstract 特殊情况：如果某个接口中有多个抽象方法，但只有1个抽象方法是本接口新定义的，其他抽象方法和Object中已有的方法重复，那么该接口仍然是函数式接口。\npackage lambda; @FunctionalInterface public interface MyInterface {//everything is an Object public abstract void a() ;//本接口新定义的抽象 public abstract String toString() ;//和Object中重名(实际会调用Object中的toString()) public abstract boolean equals(Object obj) ;//和Object中重名 //重点：toString()和equals()看似是抽象方法，实则是 有方法体的具体方法 } class MyInterfaceImpl implements MyInterface{ @Override public void a() { System.out.println(\u0026quot;a...\u0026quot;); } } class TestMyInterface{ public static void main(String[] args) { MyInterfaceImpl impl = new MyInterfaceImpl(); impl.a(); impl.equals(\u0026quot;\u0026quot;) ; impl.toString(); } }   MyInterface中的a()方法是 自己定义的，而其他equals()、toString()方法可以理解为 从Object中继承而来，因此 MyInterface虽然显示了3个抽象，但其实只有1个抽象。\n() { return }\n函数式接口从哪来？\n JDK自带 (很多存在于java.util.function包中)  ​ 四大核心函数式接口\n 有参，无返回值 （消费型：传给你一个参数，你把他给弄没了）\n@FunctionalInterface public interface Consumer\u0026lt;T\u0026gt; { void accept(T t); ... }  无参，有返回值（供给型：什么都没给你，你却给我了一个东西）\n@FunctionalInterface public interface Supplier\u0026lt;T\u0026gt; { T get(); }   有参，有返回值 (函数型：)\n@FunctionalInterface public interface Function\u0026lt;T, R\u0026gt; { R apply(T t); ... }  断言式接口\n@FunctionalInterface public interface Predicate\u0026lt;T\u0026gt; { boolean test(T t); ... }   自定义\n  lambda表达式的使用方式 方式一 ​ 函数式接口 引用名 = lambda表达式 ；(先实现在使用)\n​ Predicate p = num -\u0026gt; num \u0026lt; 10 ;\npublic static void test01(){ // boolean test(T t); Predicate\u0026lt;Integer\u0026gt; p = (num) -\u0026gt; {return num \u0026lt; 10;} ; //Predicate\u0026lt;Integer\u0026gt; p = num -\u0026gt; num \u0026lt; 10 ; System.out.println( p.test( 3 ) ); }  public static void test02(){ //相当于将 MyMath中的add()方法进行了具体的实现 // MyMath math = (int n1,int n2) -\u0026gt; { return n1+n2 ;} ; MyMath math = (n1,n2) -\u0026gt; { return n1+n2 ;} ; System.out.println( math.add(1,100 ) ); }  示例\npackage lambda; import java.util.function.Consumer; import java.util.function.Function; import java.util.function.Predicate; import java.util.function.Supplier; public class Demo02 { public static void test01(){ // boolean test(T t); // Predicate\u0026lt;Integer\u0026gt; p = (num) -\u0026gt; {return num \u0026lt; 10;} ; Predicate\u0026lt;Integer\u0026gt; p = num -\u0026gt; num \u0026lt; 10 ; System.out.println( p.test( 3 ) ); } public static void test02(){ //相当于将 MyMath中的add()方法进行了具体的实现 // MyMath math = (int n1,int n2) -\u0026gt; { return n1+n2 ;} ; //lambda自带类型推断机制，因此参数的类型 可以省略 MyMath math = ( n1,n2) -\u0026gt; n1+n2 ; System.out.println( math.add(1,100 ) ); } public static void test03(){ // void accept(T t); Consumer\u0026lt;String\u0026gt; c = (x) -\u0026gt; System.out.println(\u0026quot;吃：\u0026quot;+x) ; c.accept(\u0026quot;苹果\u0026quot;); } public static void test04(){ Supplier\u0026lt;Integer\u0026gt; supplier = ()-\u0026gt; (int)(Math.random()*9000+1000) ; System.out.println( supplier.get() ); } public static void test05(){ Function\u0026lt;String,String\u0026gt; f = (s) -\u0026gt; s.toUpperCase() ; System.out.println( f.apply(\u0026quot;hello world\u0026quot;)); } public static void main(String[] args) { test05(); } }  方式二 new Thread( () -\u0026gt; System.out.println(\u0026quot;run....\u0026quot;) ).start(); ;  将lambda表达式所代表的函数式接口，作为一个方法的参数存在。\n理解：方法B( 方法A )：函数式编程。scala javascript本身就支持函数式编程。\n形式：方法( 函数式接口 )\npackage lambda; import java.util.function.Consumer; import java.util.function.Function; import java.util.function.Predicate; import java.util.function.Supplier; public class Demo02 { public static void test01(){ // boolean test(T t); // Predicate\u0026lt;Integer\u0026gt; p = (num) -\u0026gt; {return num \u0026lt; 10;} ; Predicate\u0026lt;Integer\u0026gt; p = num -\u0026gt; num \u0026lt; 10 ; System.out.println( p.test( 3 ) ); } public static void test02(){ //相当于将 MyMath中的add()方法进行了具体的实现 // MyMath math = (int n1,int n2) -\u0026gt; { return n1+n2 ;} ; MyMath math = (n1,n2) -\u0026gt; n1+n2 ; System.out.println( math.add(1,100 ) ); } public static void test03(){ // void accept(T t); Consumer\u0026lt;String\u0026gt; c = (x) -\u0026gt; System.out.println(\u0026quot;吃：\u0026quot;+x) ; c.accept(\u0026quot;苹果\u0026quot;); } public static void test04(){ Supplier\u0026lt;Integer\u0026gt; supplier = ()-\u0026gt; (int)(Math.random()*9000+1000) ; System.out.println( supplier.get() ); } public static void test05(){ Function\u0026lt;String,String\u0026gt; f = (s) -\u0026gt; s.toUpperCase() ; System.out.println( f.apply(\u0026quot;hello world\u0026quot;)); } public static void test06(){ String result = upper( (x)-\u0026gt; x.toUpperCase() ,\u0026quot;hello\u0026quot;); System.out.println(result); } // fun:函数的逻辑 ,str:hello public static String upper( Function\u0026lt;String,String\u0026gt; fun ,String str ){ return fun.apply( str ) ; } public static void test07(){ myPredicate( (x) -\u0026gt; x\u0026gt;18 , 10); } public static void myPredicate(Predicate\u0026lt;Integer\u0026gt; pre, Integer num ){ System.out.println( pre.test( num ) ); } public static void main(String[] args) { test07(); } }  JDK8其他新特性简介 接口 的默认方法与静态方法 在Java 8中，可以使用default关键字在接口中定义默认方法，并提供默认的实现。之后，该接口的所有实现类都会默认地使用该实现方法。当然，实现类也可以对该默认方法进行重写。例如：\npublic interface MyInterface { default String myFunction() { return \u0026quot;hello world\u0026quot;; } }  此外，还可以在接口中定义静态方法，并提供默认实现。例如：\npublic interface MyInterface { static String myFunction() { return \u0026quot;hello world\u0026quot;; } }  方法引用 Java 8还允许使用::来引用一个已经存在的方法，其语法如下：\n类名::方法名\n注意：只写方法名即可，不需要写括号。\n具体地讲，共有以下四种类型的引用。\n   类 型 示 例     引用静态方法 ContainingClass::staticMethodName   引用某个对象的实例方法 ContainingObject::instanceMethodName   引用某个类型的任意对象的实例方法 ContainingType::methodName   引用构造方法 ClassName::new    ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;() ; // list.add(...); 参数：String，返回值:boolean Predicate\u0026lt;String\u0026gt; pre = list::add ; // pre.test( ):参数：String，返回值:boolean pre.test(\u0026quot;a\u0026quot;) ; pre.test(\u0026quot;b\u0026quot;) ; System.out.println(list);  重复注解 自从Java 5引入了注解以后，注解就被广泛应用于各个框架之中。但Java 5引入的注解存在一个问题：在同一个地方不能多次使用同一个注解。而Java 8就打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解。\n在Java 8中使用@Repeatable注解定义重复注解，代码示例如下：\n@Repeatable(Authorities.class) public @interface Authority { String role(); } public @interface Authorities { Authority[] value(); } public class RepeatAnnotationUseNewVersion { @Authority(role=\u0026quot;Admin\u0026quot;) @Authority(role=\u0026quot;Manager\u0026quot;) public void doSomeThing(){ } }  在创建重复注解Authority时，加上@Repeatable并指向用于存储的注解Authorities。之后，在使用的时候，就可以重复使用Authority注解。\n其他 Java 8 还提供了Nashorn引擎便于在JVM上运行JavaScript代码，提供了新的Date API，提供了对高并发的新支持，类依赖分析器jdeps……\n集合 Collection：存储的数据是 不唯一、无序的对象\nList：存储的数据是 不唯一、有序的对象\nSet:存储的数据是 唯一、无序的对象\n唯一：不能重复\n有序：不是排序；是输入顺序 是否与 输出顺序一致的。\nHashXxx:底层借助了“哈希表” 的数据结构;默认不支持排序 TreeXxx:底层借助了“红黑色”的数据结构;默认支持排序\nset中的remove（）为什么只能根据 内容删？不能根据下标删？\npackage col; import java.util.ArrayList; import java.util.Collection; import java.util.HashSet; import java.util.LinkedList; public class Demo01 { public static void main(String[] args) { Collection list = new ArrayList(); list.add(\u0026quot;中国\u0026quot;) ; list.add(\u0026quot;美国\u0026quot;) ; list.add(\u0026quot;俄罗斯\u0026quot;) ; System.out.println(list); LinkedList list2 = new LinkedList(); list2.add(\u0026quot;hello\u0026quot;) ; list2.add(\u0026quot;world\u0026quot;) ; //LinkedList独有的方法 list2.addLast(\u0026quot;wh\u0026quot;); list2.addFirst(\u0026quot;hw\u0026quot;); // list2.remove(1) ; list2.remove(\u0026quot;world\u0026quot;); System.out.println(list2); HashSet set = new HashSet() ; set.add(\u0026quot;aa\u0026quot;) ; set.add(\u0026quot;bb\u0026quot;) ; set.add(\u0026quot;cc\u0026quot;) ; set.remove(\u0026quot;bb\u0026quot;) ;//因为 set是无序的，因此无法根据“下标”删。只能根据内容删 System.out.println(set); } }  map中的key是唯一的；value是不唯一的\n删除：\nCollection中的类（List、Set），删除的返回值是 boolean；\nMap中的类，是根据Key删除，返回值是value.\npackage col; import java.util.Collection; import java.util.HashMap; import java.util.Set; public class Demo02 { public static void main(String[] args) { HashMap map = new HashMap() ; map.put( \u0026quot;s01\u0026quot;,\u0026quot;张三\u0026quot;) ;//key:学号 ，value:姓名 map.put( \u0026quot;s02\u0026quot;,\u0026quot;李四\u0026quot;) ; map.put( \u0026quot;s03\u0026quot;,\u0026quot;王五\u0026quot;) ; map.put( \u0026quot;s04\u0026quot;,\u0026quot;王五\u0026quot;) ; System.out.println(map); Object v = map.get(\u0026quot;s01\u0026quot;);//根据key，找到value System.out.println( v); System.out.println(map.size()); //判断是否 包含了指定的Key System.out.println( map.containsKey(\u0026quot;s01\u0026quot;) ); //判断是否 包含了指定的value System.out.println( map.containsValue(\u0026quot;王五\u0026quot;) ); //将Map转为单值集合 //转为只包含了key的单值集合 Set set = map.keySet();//为什么是set，不是list?因为map中，key是唯一的 System.out.println(set); //转为只包含了value的单值集合 Collection values = map.values(); System.out.println(values); Object a = map.remove(\u0026quot;s01\u0026quot;);//删除的返回值，就是删除的 value对象 System.out.println(map); System.out.println(a); } }  如何遍历集合？list set map\n（1）循环for（普通for[只适用于‘有序’的集合]，增强for[建议]）\n（2）迭代器\npublic interface Iterator\u0026lt;E\u0026gt; {...}  package col; import java.util.*; public class Demo03 { public static void main(String[] args) { List list = new ArrayList() ; list.add(\u0026quot;aa\u0026quot;) ; list.add(\u0026quot;bb\u0026quot;) ; list.add(\u0026quot;cc\u0026quot;) ; //普通for for(int i=0;i\u0026lt;list.size();i++){ System.out.println( list.get(i)); } System.out.println(\u0026quot;增强for\u0026quot;); //增强for for(Object o :list){ System.out.println(o); } Set set = new HashSet() ; set.add(\u0026quot;A\u0026quot;); set.add(\u0026quot;b\u0026quot;); set.add(1); set.add(\u0026quot;D\u0026quot;); //普通for，不适用于 “无序”的集合 // for(int i=0;i\u0026lt;set.size();i++){ // System.out.println( set.get ); // } for(Object e : set){ System.out.println(e); } System.out.println(\u0026quot;迭代器\u0026quot;); Iterator iterator = set.iterator(); while(iterator.hasNext()){ Object o = iterator.next(); System.out.println(o); } } }  遍历map：将双值集合 ，转为单值集合。\nmap -\u0026gt; keySet\nmap-\u0026gt;values\nSystem.out.println(\u0026quot;遍历map。。。\u0026quot;); Map map = new HashMap() ; map.put(\u0026quot;s01\u0026quot;,\u0026quot;Zs\u0026quot;) ; map.put(\u0026quot;s02\u0026quot;,\u0026quot;ls\u0026quot;) ; map.put(\u0026quot;s03\u0026quot;,\u0026quot;ww\u0026quot;) ; Set set1 = map.keySet();//将双值集合 降成单值集合 for(Object o :set1){ System.out.println(\u0026quot;key:\u0026quot; +o); Object v = map.get(o);//map可以根据key，获取value; map.get(key) -\u0026gt;value System.out.println(\u0026quot;value:\u0026quot;+v); } // Collection values1 = map.values(); // Iterator iterator1 = values1.iterator(); // while(iterator1.hasNext()){ // System.out.println(\u0026quot;value: \u0026quot;+iterator1.next() ); // } System.out.println(\u0026quot;通过entry遍历..\u0026quot;); Set entries = map.entrySet(); for(Object e :entries){ Map.Entry et = (Map.Entry)e ; Object k = et.getKey(); Object v = et.getValue(); System.out.println(\u0026quot;k-\u0026quot;+k); System.out.println(\u0026quot;v-\u0026quot;+v); }  泛型 Collection、Map接口中都可以使用\n自jdk1.5开始提供。\n作用：\n（1）数据安全\n（2）防止类型转换时出错\nlist.add(默认是Object)\n如果加了Double泛型，则自动变成 list.add(double\u0026hellip;)，返回值类似，会直接返回double类型的数据\n简言之，以Double泛型为例。如果不加泛型，则默认操作的是Object类型，如果加了Double泛型，则默认操作的是Double类型。\npackage col; import java.util.*; public class Demo04 { public static void main(String[] args) { // List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;() ; List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;() ;//jdk1.7之后提供类型推断 list.add(\u0026quot;a\u0026quot;) ; // list.add(1) ; String s = list.get(0); System.out.println(s); Set\u0026lt;String\u0026gt; set =new HashSet\u0026lt;\u0026gt;() ; set.add(\u0026quot;aa\u0026quot;) ; //Key(学号s01),Value（名次） Map\u0026lt;String,Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;() ; map.put(\u0026quot;s01\u0026quot;,3); map.put(\u0026quot;s02\u0026quot;,1); map.put(\u0026quot;s03\u0026quot;,2); Set\u0026lt;Map.Entry\u0026lt;String,Integer\u0026gt;\u0026gt; entries = map.entrySet(); for(Map.Entry\u0026lt;String,Integer\u0026gt; entry :entries){ System.out.println( entry.getKey()); System.out.println( entry.getValue()); } System.out.println(\u0026quot;迭代器中...\u0026quot;); //取key Set\u0026lt;String\u0026gt; keys = map.keySet(); //遍历Key Iterator\u0026lt;String\u0026gt; iterator = keys.iterator(); while(iterator.hasNext()){ String key = iterator.next(); Integer value = map.get(key) ; System.out.println(key+\u0026quot;--\u0026quot;+value); } } }  示例：根据人的名字，查询这个人的全部信息。\npackage col; import javax.sound.midi.Soundbank; import java.util.HashMap; import java.util.Map; import java.util.Scanner; import java.util.Set; public class Demo05 { public static void main(String[] args) { Map\u0026lt;String,Person\u0026gt; map = new HashMap\u0026lt;\u0026gt;() ; Person p1 = new Person(\u0026quot;zs\u0026quot;,23,\u0026quot;xa\u0026quot;); Person p2 = new Person(\u0026quot;ls\u0026quot;,24,\u0026quot;bj\u0026quot;); Person p3 = new Person(\u0026quot;ww\u0026quot;,25,\u0026quot;sh\u0026quot;); Person p4 = new Person(\u0026quot;zl\u0026quot;,26,\u0026quot;sz\u0026quot;); Person p5 = new Person(\u0026quot;sq\u0026quot;,27,\u0026quot;tj\u0026quot;); //key:名字 value:人 map.put(\u0026quot;zs\u0026quot;,p1); map.put(\u0026quot;ls\u0026quot;,p2); map.put(\u0026quot;ww\u0026quot;,p3); map.put(\u0026quot;zl\u0026quot;,p4); map.put(\u0026quot;sq\u0026quot;,p5); System.out.println(\u0026quot;请输入人的名字：\u0026quot;); Scanner in = new Scanner(System.in) ; String name = in.next(); Person person = map.get(name); System.out.println(person);//如果不是null,在打印时会调用toString；如果是null，则不调用。 // System.out.println(person.toString()); // Set\u0026lt;String\u0026gt; names = map.keySet(); // //在names中查找name // for(String n :names){ // if(n.equals( name )){ // Person person = map.get(n); // System.out.println(person); // } // } } }  集合工具类 集合工具类Collections：排序、复制、翻转等操作\n数组工具类Arrays 排序、复制、翻转等操作 ,Arrays.sort(数组)\npackage col; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class Demo06 { public static void main(String[] args) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026quot;w\u0026quot;) ; list.add(\u0026quot;a\u0026quot;) ; list.add(\u0026quot;b\u0026quot;) ; list.add(\u0026quot;x\u0026quot;) ; list.add(\u0026quot;a\u0026quot;) ; list.add(\u0026quot;i\u0026quot;) ; Collections.sort(list); System.out.println(list); System.out.println( Collections.max(list) ); System.out.println( Collections.min(list) ); //二分查法(使用前，必须保证集合元素是 自然有序的) System.out.println( Collections.binarySearch( list,\u0026quot;i\u0026quot;) ); //混洗，洗牌：打乱已有顺序 Collections.shuffle(list); System.out.println(list); Collections.shuffle(list); System.out.println(list); Collections.reverse( list); System.out.println(list); Collections.swap(list, 2,3); System.out.println(list); Collections.replaceAll(list, \u0026quot;a\u0026quot;,\u0026quot;A\u0026quot;) ; System.out.println(list); Collections.fill(list,\u0026quot;H\u0026quot;); System.out.println(list); } }  package col; import java.util.Arrays; public class Demo07 { public static void main(String[] args) { int[] arr = new int[]{3,2,14,6,1}; Arrays.sort(arr); for(int i=0;i\u0026lt;arr.length;i++){ System.out.println(arr[i]); } // // Arrays.fill(arr,5); // for(int i=0;i\u0026lt;arr.length;i++){ // System.out.println(arr[i]); // } Arrays.sort(arr); //通过二分法，在arr中查找2的下标（前提是 数组已经排好序） int position = Arrays.binarySearch(arr, 2); System.out.println(position); } }  比较器\nlist.add(3) ; //2 4 3 1 9\nlist.add(\u0026ldquo;b\u0026rdquo;) ; //b c a d w\nCollections.sort(list) //能够识别一些自然顺序\n但是，如果集合中的元素是 用户自定义对象，如何排序？\nPerson p1 = new Person(3,\u0026ldquo;zs\u0026rdquo;,23,6) ;\nPerson p2 = new Person(2,\u0026ldquo;ls\u0026rdquo;,24,2) ;\nPerson p3 = new Person(1,\u0026ldquo;ww\u0026rdquo;,25,8) ;\nlist.add(p1);\nlist.add(p2);\nlist.add(p3);\nCollections.sort(list) //程序 无法知道 ，是根据什么排序？ -\u0026gt;自定义比较器， 自定义“比较时，根据学号排”\n自定义比较器：Comparable 、Comparator\nComparable: 内部比较器（侵入性，需要修改原有代码）\npackage col; public class Person implements Comparable{ private int id ; private String name ; private int age ; private String city; public Person() { } public Person(int id, String name, int age, String city) { this.id = id; this.name = name; this.age = age; this.city = city; } public Person( String name, int age, String city) { this.name = name; this.age = age; this.city = city; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } @Override public String toString() { return \u0026quot;Person{\u0026quot; + \u0026quot;id=\u0026quot; + id + \u0026quot;, name='\u0026quot; + name + '\\'' + \u0026quot;, age=\u0026quot; + age + \u0026quot;, city='\u0026quot; + city + '\\'' + '}'; } //重写比较器接口中的方法 /* {1,3,5,7 }升序 {7,5,3,1 }降序 //输入源 3 1 7 5 {3} 返回值： 1正数：当前对象大， 降序 -1负数：传入的对象大 ，升序 0：一样大 传入一个Person对象和当前对象进行比较 */ @Override public int compareTo(Object o) { Person inputPerson = (Person)o ; //根据学号，降序 int result = this.id \u0026gt; inputPerson.id ?-1 : ( this.id == inputPerson.id ?0:1 ) ; //如果学号相同，再根据姓名升序. za zs if(result == 0 ){ result = this.name .compareTo( inputPerson.name) ;//调用String已经重写过的compareTo() } return result; // return 1;//当前对象，比传入对象大 } }  思路：将比较的对象（Person）实现Comparable接口，重写连的compareTo()方法。在compareTo()中编写比较的逻辑。重点是返回值，-1 ，0,1 ；\nComparator：外部比较器 （无侵入性，不影响原有代码）\n1.先定义一个外部比较器\npackage col; import java.util.Comparator; public class MyComparatorWithId implements Comparator { @Override public int compare(Object o1, Object o2) { Student s1 = (Student)o1 ; Student s2 = (Student)o2 ; return s2.getId() - s1.getId() ; } }  2.使用外部比较器\npackage col; import java.util.ArrayList; import java.util.Collections; import java.util.List; //内部比较器 public class Demo08 { public static void main(String[] args) { List\u0026lt;Person\u0026gt; persons = new ArrayList\u0026lt;\u0026gt;() ; Person p1= new Person(10,\u0026quot;zs\u0026quot;,23,\u0026quot;xa\u0026quot;) ; Person p2= new Person(2,\u0026quot;ls\u0026quot;,24,\u0026quot;xa\u0026quot;) ; Person p3= new Person(2,\u0026quot;zs\u0026quot;,25,\u0026quot;xa\u0026quot;) ; persons.add(p1) ; persons.add(p2) ; persons.add(p3) ; Collections.sort( persons ); System.out.println(persons); System.out.println(\u0026quot;-------\u0026quot;); Student s1 = new Student(10,\u0026quot;zs\u0026quot;,23,\u0026quot;xa\u0026quot;) ; Student s2 = new Student(2,\u0026quot;zs\u0026quot;,26,\u0026quot;xa\u0026quot;) ; Student s3 = new Student(3,\u0026quot;zs\u0026quot;,24,\u0026quot;xa\u0026quot;) ; List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;() ; students.add(s1); students.add(s2); students.add(s3); Collections.sort( students,new MyComparatorWithId() );//给students使用了MyComparatorWithId比较器 System.out.println(students); } }  List list = new ArrayList\u0026lt;\u0026gt;() ;\n包装类（自动装箱、自动拆箱）\nevething is an Object，万物皆对象。 属性、方法\n自动装箱：基本类型 -\u0026gt;包装类型 ,int -\u0026gt;Integer\n自动拆箱：包装类型-\u0026gt;基本类型,Integer -\u0026gt;int\njava中 将8个基本类型，包装成了8个对象类型（引用类型）。这8个对象类型 就成为包装类\npackage col; public class BZL { public static void main(String[] args) { int i = 10 ; Integer j = new Integer(20) ; i = j ;//Integer-\u0026gt;int 自动拆箱 底层用的是intValue() j = i ;//int -\u0026gt;Integer 自动装箱 底层用的是valueOf() ,该方法中有个缓冲区 [-128,127],如果要装箱的数字 在缓冲区范围以内，则直接从缓冲区中取；否则，new Integer()一个新对象 Integer i1 = 100 ; Integer i2 = 100 ; Integer i3 = 1000 ; Integer i4 = 1000 ; System.out.println(i1 == i2); System.out.println(i3 == i4); } }  异常 简介 try { //一切正常，执行这里 }catch(Exception e) { //如果不正常，执行这里（异常） } int[] nums = new int[3] ; try { //nums[n]一切正常，执行这里 }catch(Exception e) { // nums[n]如果不正常，执行这里（异常） }  如果代码出现问题时，使用“异常机制”比 选择结构 更加方便。\n异常的继承结构图 运行时异常：代码在编辑（编译阶段）时 不报错，运行时才报错。语法上， 可以选择性处理。\n检查异常：代码在编辑（编译阶段）时报错。在编辑时，必须处理。（没有使用try catch包围）\n异常重点 try catch finally throws throw\n处理异常：try catch 或者 throws\ntry: 将可能发生异常的代码 用{}包裹起来\ncatch : 捕获特定类型的异常；捕获时，先写范围小的类型，后写范围大的类型\n如果try中的代码的确发生了异常，则程序 不再执行try中异常之后的代码，而是直接跳到cath中执行\npublic class Demo01 { public static void main(String[] args) { int[] nums = new int[3] ; System.out.println(nums[3]);//运行时异常，选择性处理 // // Class.forName(\u0026quot;ex.Demo01\u0026quot;);//检查异常，强制处理 } }  try catch 自己（当前方法）能够处理，使用try catch .\nthrows 自己（当前方法）不能处理，上交给 上级（方法调用处）处理 ,使用throws .\npublic static void test04() throws NullPointerException,ClassNotFoundException{//抛出异常，抛出给上级（方法调用处） Object obj = null ; obj.equals(\u0026quot;\u0026quot;) ;//空指针 Class.forName(\u0026quot;xxx\u0026quot;) ; } public static void main(String[] args) throws Exception{//继续往上抛出异常(JVM) test04();//异常 }  finally 无论正常，还是异常，始终都会执行的代码\n不论执行完try，还是执行完catch，最终都会执行finally的代码\n1.即使遇到return ,也仍然会执行finally\n2.除非虚拟机关闭，才不会执行finally\npackage ex; public class Demo02 { public static void test01(){ Object obj = null ; try { // System.out.println(\u0026quot;111\u0026quot;); obj.equals(\u0026quot;\u0026quot;);//可能产生异常的代码 // System.out.println(\u0026quot;222\u0026quot;); // System.out.println(\u0026quot;正常时，关闭资源。。。\u0026quot;); }catch (NullPointerException e){//捕获特定类型的异常 // System.out.println(\u0026quot;异常。。。\u0026quot;); // System.out.println(\u0026quot;发生了空指针异常。。\u0026quot;); // System.out.println(\u0026quot;异常时，关闭资源。。。\u0026quot;); }finally{ System.out.println(\u0026quot;无论正常，还是异常，始终都会执行的代码。。。\u0026quot;); } } public static int test02(){ try{ Object obj = null ; System.exit(1);//关闭jvm obj.equals(\u0026quot;\u0026quot;) ; return 1 ; }catch (NullPointerException e){ return 0 ; }finally{ System.out.println(\u0026quot;finally...\u0026quot;); } } public static void main(String[] args) { test02() ; } }  多个catch块 public static void test03(){ try{ Class.forName(\u0026quot;xxx\u0026quot;) ; Object obj = null ; obj.equals(\u0026quot;\u0026quot;) ;//空指针 int[] nums = new int[3] ; nums[3] = 3 ;//数组越界异常 }catch (NullPointerException e){//捕获空指针 System.out.println(\u0026quot;空指针异常..\u0026quot;); }catch (ArrayIndexOutOfBoundsException e){ System.out.println(\u0026quot;数组越界异常...\u0026quot;); }catch (Exception e) {//还有一些 根本临时想不到的异常 System.out.println(\u0026quot;其他异常。。。\u0026quot;); } }  throw 一般和 自定义异常 一起使用 throw: 声明异常\njdk中自带了很多类型的异常，但如果 这些内置的异常 仍然不能满足项目的需求，那么就需要创建 自定义异常。\n如何编写自定义异常：\n1类，继承Exception，调用super(“异常信息”)\npackage ex; //public class MyException extends Throwable{ //public class MyException extends NullPointerException{ public class MyException extends Exception{//推荐 public MyException(String message){//异常信息 super(message); } }  2.使用throw 声明一个自定义异常、并且进行try catch或throws\npackage ex; public class Demo03 { public static void main(String[] args) { int age = 188 ; //约定，年龄不能大于120 if(age\u0026lt;= 0 || age\u0026gt;120){ try { //手工声明一个异常 throw new MyException(\u0026quot;年龄不能大于120\u0026quot;); }catch ( MyException e ){ e.printStackTrace(); System.out.println(e.getMessage()); } } } }  在开发的过程中，要逐步积累异常，有助于提高我们的 排查bug的能力。\nJava注解 类：要给一个类增强一些功能？ 继承、实现一个接口 ,还可以使用注解\nclass A extends B\nclass A implements C\n可以通过使用注解 增强类、方法、属性的功能。\n内置注解 @Override ：可以确保 重写的方法 的确存在于父类/接口中，可以有效的避免 单词拼错等情况。 @Deprecated：给用于提示，该方法由于安全、性能问题等 已经不推荐使用了。此外，在版本升级时，如果要计划删除一些方法，也通常会在前一个版本中 将该方法加上@Deprecated，然后再在后续版本中删除。 @SuppressWarnings(value=\u0026quot;unchecked\u0026quot;)//压制警告 （虽然可以使用SuppressWarnings压制警告，但不建议使用。）//忽略对泛型等的检查操作。value值：unchecked ,deprecation(忽略一些过期的API) ，unused (是否未被使用) ，fallthrough（swtich 是否一致往下执行，而没有break）;path(忽略 对类路径不存在的检查) ，serialVersionUID（忽略 一个类可以序列化、但却没有序列化的 警告），all  package annotaion; import java.io.Serializable; import java.util.ArrayList; import java.util.List; class Father { public void eat() { System.out.println(\u0026quot;father eat...\u0026quot;); } } class Son extends Father{ @Override public void eat() { System.out.println(\u0026quot;son eat...\u0026quot;); } @Deprecated public void test(){ } } //压制警告 （虽然可以使用SuppressWarnings压制警告，但不建议使用。） @SuppressWarnings(value=\u0026quot;all\u0026quot;)//忽略对泛型等的检查操作 public class Demo01 { public static void main(String[] args) { int a = 1 ; Father f = new Son(); f.eat(); new Thread().stop(); new Son().test(); List list = new ArrayList(); } }  自定义注解 public @interface MyAnnotation { }  元注解 元数据：修饰数据的数据\n元注解：修饰注解的注解， @Target、@Retention、@Document、@Inherited\n@Target：限制注解 可以使用的位置 限制注解 能够使用哪些元素上（属性、方法、类）；如果一个注解没有@Target描述，则该注解 可以修饰任何类型的元素； 如果有@Target修饰，该注解就只能用于 被@Target修饰的地方\n哪些位置？ ElementType.枚举\n/* * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. */ package java.lang.annotation; /** * The constants of this enumerated type provide a simple classification of the * syntactic locations where annotations may appear in a Java program. These * constants are used in {@link Target java.lang.annotation.Target} * meta-annotations to specify where it is legal to write annotations of a * given type. * * \u0026lt;p\u0026gt;The syntactic locations where annotations may appear are split into * \u0026lt;em\u0026gt;declaration contexts\u0026lt;/em\u0026gt; , where annotations apply to declarations, and * \u0026lt;em\u0026gt;type contexts\u0026lt;/em\u0026gt; , where annotations apply to types used in * declarations and expressions. * * \u0026lt;p\u0026gt;The constants {@link #ANNOTATION_TYPE} , {@link #CONSTRUCTOR} , {@link * #FIELD} , {@link #LOCAL_VARIABLE} , {@link #METHOD} , {@link #PACKAGE} , * {@link #PARAMETER} , {@link #TYPE} , and {@link #TYPE_PARAMETER} correspond * to the declaration contexts in JLS 9.6.4.1. * * \u0026lt;p\u0026gt;For example, an annotation whose type is meta-annotated with * {@code @Target(ElementType.FIELD)} may only be written as a modifier for a * field declaration. * * \u0026lt;p\u0026gt;The constant {@link #TYPE_USE} corresponds to the 15 type contexts in JLS * 4.11, as well as to two declaration contexts: type declarations (including * annotation type declarations) and type parameter declarations. * * \u0026lt;p\u0026gt;For example, an annotation whose type is meta-annotated with * {@code @Target(ElementType.TYPE_USE)} may be written on the type of a field * (or within the type of the field, if it is a nested, parameterized, or array * type), and may also appear as a modifier for, say, a class declaration. * * \u0026lt;p\u0026gt;The {@code TYPE_USE} constant includes type declarations and type * parameter declarations as a convenience for designers of type checkers which * give semantics to annotation types. For example, if the annotation type * {@code NonNull} is meta-annotated with * {@code @Target(ElementType.TYPE_USE)}, then {@code @NonNull} * {@code class C {...}} could be treated by a type checker as indicating that * all variables of class {@code C} are non-null, while still allowing * variables of other classes to be non-null or not non-null based on whether * {@code @NonNull} appears at the variable's declaration. * * @author Joshua Bloch * @since 1.5 * @jls 9.6.4.1 @Target * @jls 4.1 The Kinds of Types and Values */ public enum ElementType { /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE }  自定义一个注解\n//修饰该注解 只能在 属性、方法上使用 @Target(value= {ElementType.FIELD ,ElementType.METHOD} ) public @interface MyAnnotation { /* 用定义方法的形式，定义一个属性 value 方法的名字，就是属性的名字；方法的返回值，就是属性的类型 */ String value() default \u0026quot;张三\u0026quot;;//String value = \u0026quot;张三\u0026quot; ； int age() default 22 ; }  使用\npublic class TestMyAnnotation { @MyAnnotation(value=\u0026quot;李四\u0026quot;,age=33) public void test(){ } }  @Retention:限制注解的生命周期 public enum RetentionPolicy { /** * Annotations are to be discarded by the compiler. jvm直接将该注解丢弃 ，写了跟没写一样 */ SOURCE, /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. .java -\u0026gt; .class 程序在编译时 会使用注解，在运行时不会使用 */ CLASS, /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * * @see java.lang.reflect.AnnotatedElement 程序在编译以及运行时，都会使用注解 */ RUNTIME }  自定义注解如何使用？ 结合反射使用。\n注解+反射 什么时候会真正使用？ 开发框架 ，instanceof判断类型\n使用注解案例\npackage annotaion; import java.lang.annotation.Annotation; public class TestMyAnnotation { @MyAnnotation(value=\u0026quot;李四\u0026quot;,age=33) @Deprecated public static void test() throws Exception{ Annotation[] annotations = Class.forName(\u0026quot;annotaion.TestMyAnnotation\u0026quot;).getMethod(\u0026quot;test\u0026quot;).getAnnotations(); for(Annotation a :annotations){ if(a instanceof MyAnnotation ){//@MyAnnotation System.out.println( ((MyAnnotation)a) .value() ); System.out.println( ((MyAnnotation)a) .age() ); }else{//@Deprecated System.out.println( \u0026quot;@Deprecated\u0026quot; ); } } } @SuppressWarnings(\u0026quot;all\u0026quot;) public static void main(String[] args) throws Exception { test() ; } }  运行结果\n李四 33 @Deprecated  @Document：\n​ javadoc：java帮助文档。 ABC.java -\u0026gt; 帮助文档\n​ 默认情况下，javadoc不包含 注解的解释；如果现在javadoc文档中 也包含对注解的说明，则需要使用 @Document标注\n例如，一下MyAnnotation注解，会在生成javadoc时，被显示在文档中\n@Documented public @interface MyAnnotation { }  @Inherited：继承\n@Inherited public @interface MyAnnotation { } @MyAnnotation public class A{} public class B extends A{}//默认情况下，B不会继承A中的注解；如果要想继承，则需要加@Inherited  IO 输入流InputStream 输出流OutputStream\njava.io.*  文件：硬盘上的文件 txt docx 电影 图片\n本章的核心：通过 IO 来操作文件。\nFile\nimport java.io.File; import java.io.IOException; public class Demo01 { public static void main(String[] args) { //file:文件\\目录\\不存在的文件或目录 // File file = new File(\u0026quot;d:/abc.txt\u0026quot;); File file = new File(\u0026quot;hello.txt\u0026quot;); System.out.println(\u0026quot;相对路径：\u0026quot;+file.getPath() ); System.out.println(\u0026quot;绝对路径：\u0026quot;+file.getAbsolutePath()); System.out.println(\u0026quot;文件名称：\u0026quot;+file.getName() ); System.out.println(\u0026quot;文件大小：\u0026quot;+file.length() );//单位字节 System.out.println( file.isFile()==true? \u0026quot;文件\u0026quot;:\u0026quot;非文件\u0026quot; ); System.out.println( file.isDirectory()==true? \u0026quot;目录\u0026quot;:\u0026quot;非目录\u0026quot; ); boolean flag = file.exists(); try { if(flag) { // file.delete(); //彻底删除（不过回收站） System.out.println(\u0026quot;删除成功\u0026quot;); } else { file.createNewFile(); System.out.println(\u0026quot;创建成功\u0026quot;); } } catch (IOException e) { e.printStackTrace(); } } }  相对路径/绝对路径：\n- 如果FIle（\u0026quot;绝对路径\u0026quot;）：getPath() 和getAbsolutePath()的结果一致，打印的都是绝对路径 - 如果FIle（\u0026quot;相对路径\u0026quot;）：getPath() 打印相对路径;getAbsolutePath（）打印绝对路径  流 流：是一种FIFO(先进先出)的数据结构\n分类：\n 说明：1.字节流就是 将内容转为了字节形式进行传输， 1 字节 -\u0026gt;8二进制 ，二进制可以传输任何类型的数据，因此字节流也可以传输任何类型的数据。\n2.字节流是8位通用字节流( 1 字节 -\u0026gt;8二进制 ) （字节流可以处理任何类型，处理文本文件以外的其他文件） ;字符流是16位的unicode字符流 （只用于处理字符，处理文本文件）\n3.在while循环中 分批次传输时，字节流使用的缓冲区是 byte[],字符流使用的缓冲区是 char[]\n  其他流  文件复制\n输入\nimport java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; public class InputStreamDemo { public static void main(String[] args) { InputStream in = null ; try { in = new FileInputStream(new File(\u0026quot;d:/abc.txt\u0026quot;)); // InputStream in = new FileInputStream(\u0026quot;d://abc.txt\u0026quot;); System.out.println(in.available());//file.length() byte[] buf = new byte[in.available()] ; in.read(buf);//将文件abc.txt内容读取到buf中 //buf :byte[] -\u0026gt;String System.out.println(new String(buf)); }catch (Exception e){ e.printStackTrace(); }finally { try { in.close(); } catch (IOException e) { e.printStackTrace(); } } } }  输出\nimport java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; public class OutputStreamDemo { public static void main(String[] args) { OutputStream out = null ; try { out = new FileOutputStream(\u0026quot;d:/xyz.txt\u0026quot;) ; out.write(\u0026quot;helloworld123\u0026quot;.getBytes()); //内存-\u0026gt;xyz.txt } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { try { out.close(); } catch (IOException e) { e.printStackTrace(); } } } }  文件复制\nimport java.io.*; public class FileCopy { //abc.txt-\u0026gt;内存-\u0026gt;xyz.txt public static void main(String[] args) { InputStream in = null ; OutputStream out = null ; try { //abc.txt-\u0026gt;内存 in = new FileInputStream(\u0026quot;d:/abc.txt\u0026quot;) ; out = new FileOutputStream(\u0026quot;d:/xyz.txt\u0026quot;) ; //开辟10字节的内存 byte []buf = new byte[10] ; int len = -1 ; ; while( (len= in.read(buf)) != -1){//in -\u0026gt;buf out.write(buf,0,len);//buf-\u0026gt;out } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { try { if(out !=null)out.close(); if(in !=null) in.close(); } catch (IOException e) { e.printStackTrace(); } } } }  使用字符流进行文件的复制\nimport java.io.*; public class FileCopyCharactor { public static void main(String[] args) { //文件-\u0026gt;内存（Reader） Reader reader = null ; Writer writer = null ; try { reader = new FileReader(\u0026quot;d:/个人介绍.txt\u0026quot;); writer = new FileWriter(\u0026quot;d:/个人完整介绍.txt\u0026quot;) ; char[] buf = new char[4]; StringBuffer sb = new StringBuffer() ; int len = -1 ; while((len =reader.read( buf)) != -1 ){ // str += buf ; sb.append(buf,0,len) ;//将每次读取到的 4个字符 拼接起来 } System.out.println(sb); //在内存中 替换占位符 String content = sb.toString() ; content= content.replace(\u0026quot;{name}\u0026quot;,\u0026quot;哈哈\u0026quot;) .replace(\u0026quot;{enterprise}\u0026quot;,\u0026quot;xx\u0026quot;) .replace(\u0026quot;{weixin}\u0026quot;,\u0026quot;xx\u0026quot;); //将替换后的内容 输出到文件 ，内存 -\u0026gt;文件（Writer） writer.write(content); System.out.println(\u0026quot;成功...\u0026quot;); // writer.flush(); 将管道中的数据 刷出到 文件中 } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { try { if(writer!=null) writer.close(); if(reader!=null) reader.close(); } catch (IOException e) { e.printStackTrace(); } } } }  自带缓冲区的字符流：缓冲区大小，一行\nBufferedReader /BufferedWriter\nimport java.io.*; public class FileCopyCharactorBuffered { public static void main(String[] args) { //文件-\u0026gt;内存（Reader） Reader reader = null ; Writer writer = null ; BufferedReader br = null ; BufferedWriter bw = null ; try { reader = new FileReader(\u0026quot;d:/个人介绍.txt\u0026quot;); writer = new FileWriter(\u0026quot;d:/个人完整介绍2.txt\u0026quot;) ; br = new BufferedReader( reader) ; bw = new BufferedWriter( writer); StringBuffer sb = new StringBuffer() ; String line = null ; while( (line= br.readLine()) != null ){ sb.append(line) ; } System.out.println(sb); //在内存中 替换占位符 String content = sb.toString() ; content= content.replace(\u0026quot;{name}\u0026quot;,\u0026quot;哈哈\u0026quot;) .replace(\u0026quot;{enterprise}\u0026quot;,\u0026quot;xx\u0026quot;) .replace(\u0026quot;{weixin}\u0026quot;,\u0026quot;xx\u0026quot;); //将替换后的内容 输出到文件 ，内存 -\u0026gt;文件（Writer） bw.write(content); System.out.println(\u0026quot;成功...\u0026quot;); // writer.flush(); 将管道中的数据 刷出到 文件中 } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { /* * 1先关出，再关入 * 2从外往内关 br外 = new BufferedReader( reader内) ; * */ try { if(bw != null) bw.close(); if(br!=null ) br.close(); if(writer!=null) writer.close(); if(reader!=null) reader.close(); } catch (IOException e) { e.printStackTrace(); } } } }  带缓冲区的字符流 对象 = new 带缓冲区的字符流(字符流) ；\n二进制流\nDataInputStream/DataOutputStream\n二进制流 对象 = new 二进制流(字节流) ；\nimport java.io.*; //二进制流 public class FileCopyData { //abc.txt-\u0026gt;内存-\u0026gt;xyz.txt public static void main(String[] args) { InputStream in = null ; OutputStream out = null ; InputStream dataInput = null ; OutputStream dataOutput = null ; try { //abc.txt-\u0026gt;内存 in = new FileInputStream(\u0026quot;d://xx.JPG\u0026quot;) ; dataInput = new DataInputStream(in) ;//字节流-\u0026gt;二进制流 out = new FileOutputStream(\u0026quot;e:/xx.jpg\u0026quot;) ; dataOutput = new DataOutputStream(out );//字节流-\u0026gt;二进制流 //开辟10字节的内存 byte []buf = new byte[10] ; int len = -1 ; while( (len= dataInput.read(buf)) != -1){//in -\u0026gt;buf dataOutput.write(buf,0,len);//buf-\u0026gt;out } System.out.println(\u0026quot;成功\u0026quot;); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { try { if(dataOutput !=null) dataOutput.close(); if(dataInput !=null) dataInput.close(); if(out !=null)out.close(); if(in !=null) in.close(); } catch (IOException e) { e.printStackTrace(); } } } }  装饰模式：IO设计的核心思想 在不影响原有对象的前提下，无侵入的给一个对象增一些额外的功能。（套娃！！）\nnew InputStreamReader( new FileInputStream(new File(\u0026ldquo;d:/abc.txt\u0026rdquo;)) ) ;\n装饰模式\n装饰者：需要持有主题（被装饰者）的一个引用。\n装饰主题接口\npackage decorator; public interface Phone { void call();//基础功能 }  装饰主题的基础功能\npackage decorator; public class ConcretePhone implements Phone { @Override public void call() { System.out.println(\u0026quot;打电话....\u0026quot;); } }  装饰者抽象类\npackage decorator; public abstract class SmartPhone implements Phone{ private Phone phone ;//装饰者 持有 主题的一个引用 public SmartPhone(){ } public SmartPhone(Phone phone){ this.phone = phone ; } //装饰者 包含 原主题已有的功能 @Override public void call() { phone.call(); } }  具体装饰者1\npackage decorator; public class ConcreteSmarPhone1 extends SmartPhone{ public ConcreteSmarPhone1(Phone phone){ super(phone) ; } public void call(){ super.call(); //额外的新功能 changeColor(); } public void changeColor(){ System.out.println(\u0026quot;智能变色...\u0026quot;); } }  具体装饰者2\npackage decorator; public class ConcreteSmarPhone2 extends SmartPhone{ public ConcreteSmarPhone2(Phone phone){ super(phone) ; } public void call(){ super.call(); //额外的新功能 changeSize(); } public void changeSize(){ System.out.println(\u0026quot;智能改变尺寸...\u0026quot;); } }  测试类\npackage decorator; public class Test { public static void main(String[] args) { ConcretePhone phone = new ConcretePhone(); //主题（被装饰者） phone.call(); System.out.println(\u0026quot;---\u0026quot;); ConcreteSmarPhone1 phone1 = new ConcreteSmarPhone1( phone ) ; phone1.call(); System.out.println(\u0026quot;---\u0026quot;); ConcreteSmarPhone2 phone2 = new ConcreteSmarPhone2( phone ) ; phone2.call(); System.out.println(\u0026quot;-------\u0026quot;); SmartPhone smart = new ConcreteSmarPhone2(new ConcreteSmarPhone1( phone )) ; smart.call(); } }  网络编程 ip地址：网络上的 唯一标识。\nip的组成：32位，由4个8位二进制组成 （每一位最大值是255，每一位十进制标识 0-255）\n‭11000000‬.‭10101000‬.‭00000001‬.‭01100100‬ 二进制不容易被记忆，改成十进制：192.168.1.100\n192.168.300.101 错 （每一位最大值是255，每一位十进制标识 0-255）\n协议： 为了让网络中不同计算机之间能够相互通信而建立的规则、标准、约定。本课程使用的TCP、UDP\n TCP协议：面向连接的、可靠的（不丢失、不重复、有序）、基于字节流的传输通信协议。传输速度相对慢。 UDP协议：无连接的协议。在传输数据之前，客户端和服务端之间不建立和维护连接。提供不可靠的数据传输。传输速度相对快。  socket（套接字）：基于TCP协议的网络通信，可以提供双向安全连接的网络通信。socket需要借助于数据流（字节流）来完成数据的传递工作\n可见：发送数据，OutputStream\n接受数据，InputStream\n本机默认ip：localhost 127.0.0.1\n案例：\n模板\n1.客户端建立连接 ；服务端准备服务（ip[默认本机]:端口）\n2.通过socket生成inputstream/outputstream（准备发送数据）\n3.使用inputstream/outputstream进行发送、接受数据\n4.关闭inputstream/outputstream、socket\n服务端（ServerSocket）\npackage demo01; import java.io.*; import java.net.ServerSocket; import java.net.Socket; public class MyServer { public static void main(String[] args) { // 1.准备服务.ip:默认本机127.0.0.1,端口8888 ServerSocket serverSocket = null ; Socket socket = null ; InputStream in = null ; BufferedReader reader = null ; OutputStream out = null ; try { serverSocket = new ServerSocket(8888) ; System.out.println(\u0026quot;服务器启动\u0026quot;); //准备完毕，可以监听客户端请求 socket = serverSocket.accept();//一直阻塞，直到有客户端连接 System.out.println(\u0026quot;服务端检测到客户端连接成功！\u0026quot;); // 2.通过socket生成inputstream/outputstream（准备发送数据） //3.使用inputstream/outputstream进行发送、接受数据 in = socket.getInputStream(); //带缓冲区的字符流（字节流-转换流-字符流） reader = new BufferedReader(new InputStreamReader(in)); String info = null ; while( (info=reader.readLine()) != null ){ System.out.println(\u0026quot;I am server,接受到客户端信息是：\u0026quot; + info); } socket.shutdownInput(); //服务端做出反馈 out = socket.getOutputStream(); out.write(\u0026quot;welcome client....\u0026quot;.getBytes()); socket.shutdownOutput(); } catch (IOException e) { e.printStackTrace(); }finally{ try { // 4.关闭inputstream/outputstream、socket if(reader !=null) reader.close(); if(out !=null) out.close(); if(in !=null) in.close(); if(socket !=null) socket.close(); if(serverSocket !=null) serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } }  客户端（Socket）\npackage demo01; import java.io.*; import java.net.Socket; public class MyClient { public static void main(String[] args) { Socket socket = null ; OutputStream out = null ; InputStream in = null ; BufferedReader reader = null ; try { socket = new Socket(\u0026quot;127.0.0.1\u0026quot;,8888); System.out.println(\u0026quot;客户端链接成功！\u0026quot;); out = socket.getOutputStream(); out.write( \u0026quot;hello server\u0026quot;.getBytes() ); socket.shutdownOutput(); //接收服务端的反馈 in = socket.getInputStream(); reader = new BufferedReader(new InputStreamReader(in)); String info = null; while( (info=reader.readLine()) != null ){ System.out.println(\u0026quot;I am client,接收到的服务端消息：\u0026quot;+info); } socket.shutdownInput(); } catch (IOException e) { e.printStackTrace(); }finally{ try { if(out!=null) out.close(); if(in!=null) in.close(); if(socket!=null) socket.close(); } catch (IOException e) { e.printStackTrace(); } } } }  对象流 网络传递一个对象： 1.将要传递的对象序列化 2.使用对象流（ObjectInputStream/ObjectOutputStream）\n对象\npackage demo02; import java.io.Serializable; public class Student implements Serializable {//将要传递的对象序列化 private int sid ; private String sname ; private int age ; public Student(){ } public Student(int sid, String sname, int age) { this.sid = sid; this.sname = sname; this.age = age; } public int getSid() { return sid; } public void setSid(int sid) { this.sid = sid; } public String getSname() { return sname; } public void setSname(String sname) { this.sname = sname; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \u0026quot;Student{\u0026quot; + \u0026quot;sid=\u0026quot; + sid + \u0026quot;, sname='\u0026quot; + sname + '\\'' + \u0026quot;, age=\u0026quot; + age + '}'; } }  服务端\npackage demo02; import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.net.ServerSocket; import java.net.Socket; public class MyServer { public static void main(String[] args) { ServerSocket serverScoket = null ; Socket socket = null ; InputStream in = null ; ObjectInputStream ois = null ; try { serverScoket = new ServerSocket( 8888) ; socket = serverScoket.accept(); //接受客户端发来的对象 in = socket.getInputStream(); //对象流 ois = new ObjectInputStream(in); try { Student student = (Student)ois.readObject();//读取对象 System.out.println(student); socket.shutdownInput(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } catch (IOException e) { e.printStackTrace(); }finally{ try { if(ois!=null) ois.close(); if(in!=null) in.close(); if(socket!=null) socket.close(); if(serverScoket!=null) serverScoket.close(); } catch (IOException e) { e.printStackTrace(); } } } }  客户端\npackage demo02; import java.io.IOException; import java.io.ObjectOutputStream; import java.io.OutputStream; import java.net.Socket; public class MyClient { public static void main(String[] args) { Socket socket = null ; OutputStream out = null ; ObjectOutputStream oos = null ; try { socket = new Socket(\u0026quot;localhost\u0026quot;,8888) ; Student student = new Student(1001,\u0026quot;zs\u0026quot;,23); out = socket.getOutputStream(); //将OutputStream转为对象流 oos = new ObjectOutputStream(out) ; oos.writeObject( student );//发送对象 socket.shutdownOutput(); } catch (IOException e) { e.printStackTrace(); } finally{ try { if(oos!=null) oos.close(); if(out!=null) out.close(); if(socket!=null) socket.close(); }catch (IOException e) { e.printStackTrace(); } } } }  多客户端问题 思路：客户端代码不变；服务端：每当有一个客户端，就开启一个新线程去处理（每个线程专门处理一个客户端对象）。\n服务端线程\npackage demo03; import java.io.*; import java.net.Socket; public class ServerThread extends Thread{ Socket socket ; public ServerThread(Socket socket){ this.socket = socket; } @Override public void run() { InputStream in =null ; ObjectInputStream ois = null ; OutputStream out = null ; try { //接受客户端数据（客户端—\u0026gt;服务端） in = socket.getInputStream(); ois = new ObjectInputStream(in) ; Student student = (Student)ois.readObject() ; System.out.println(student); socket.shutdownInput(); //给客户端反馈(服务端-\u0026gt;客户端) out = socket.getOutputStream(); out.write(\u0026quot;已收到....\u0026quot;.getBytes()); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } finally { try { out.close(); ois.close(); in.close(); socket.close(); ; } catch (IOException e) { e.printStackTrace(); } } } }  服务端\npackage demo03; import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; public class MyServer { public static void main(String[] args) { try { ServerSocket serverSocket = new ServerSocket(8888) ; while(true) { Socket socket = serverSocket.accept();//阻塞，接受客户端请求 ServerThread serverThread = new ServerThread(socket) ; serverThread.start(); } } catch (IOException e) { e.printStackTrace(); } } }  客户端\npackage demo03; import java.io.IOException; import java.io.InputStream; import java.io.ObjectOutputStream; import java.io.OutputStream; import java.net.Socket; public class MyClient { public static void main(String[] args) { Socket socket = null ; OutputStream out = null ; ObjectOutputStream oos = null ; try { socket = new Socket(\u0026quot;localhost\u0026quot;,8888) ; Student student = new Student(1001,\u0026quot;zs\u0026quot;,23); out = socket.getOutputStream(); //将OutputStream转为对象流 oos = new ObjectOutputStream(out) ; oos.writeObject( student );//发送对象 socket.shutdownOutput(); //接受服务端的反馈 InputStream in = socket.getInputStream(); byte[] buf = new byte[100] ; in.read(buf) ; System.out.println(\u0026quot;接收到的服务端反馈:\u0026quot; + new String(buf) ); } catch (IOException e) { e.printStackTrace(); } finally{ try { if(oos!=null) oos.close(); if(out!=null) out.close(); if(socket!=null) socket.close(); }catch (IOException e) { e.printStackTrace(); } } } }  UDP的实现 DatagramPacket（数据）：封装了数据报的数据、数据长度、目标地址和目标端口\nDatagramScoket（收发器）：接收和发送DatagramPacket中封装好的数据\n接收方\npackage demo04; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; public class Receive { public static void main(String[] args) { DatagramSocket ds = null ; byte[] data = new byte[64] ; //准备接收数据的对象 DatagramPacket dp = new DatagramPacket(data , data.length) ; //接收数据 try { ds = new DatagramSocket(9999 ); ds.receive( dp ); //显示接收到的数据 String receiveData = new String(dp.getData(), 0, data.length); System.out.println(\u0026quot;接收到的数据：\u0026quot;+receiveData); System.out.println(\u0026quot;显示发送方的信息：\u0026quot; + dp.getAddress().getHostAddress() ); } catch (SocketException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { ds.close(); } } }  发送方\npackage demo04; import java.io.IOException; import java.net.*; public class Send { public static void main(String[] args) { DatagramSocket ds = null ; //创建一个InetAddress对象 InetAddress ip = null ; try { ip = InetAddress.getByName(\u0026quot;127.0.0.1\u0026quot;); String msg = \u0026quot;helloserver..\u0026quot; ; DatagramPacket dp = new DatagramPacket(msg.getBytes(),msg.length(),ip,9999) ; ds = new DatagramSocket() ; ds.send( dp ); } catch (UnknownHostException e) { e.printStackTrace(); } catch (SocketException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally{ ds.close(); } } }  总结：发送数据使用的工具\ntcp：字节流\nudp:DatagramScoket\n网络编程中一些工具类 InetAddress\npublic static void main(String[] args) { InetAddress host = null; try { //本机 host = InetAddress.getLocalHost(); System.out.println(host); //网络中任意一台 InetAddress host163 = InetAddress.getByName(\u0026quot;www.163.com\u0026quot;); System.out.println(host163); } catch (UnknownHostException e) { e.printStackTrace(); } }  URL/URLConnection\n以下示例，注意点：输入流 url-内存； 输出流：内存-本地\npackage demo05; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.MalformedURLException; import java.net.URL; import java.net.URLConnection; public class URLDemo { public static void main(String[] args) { InputStream in = null ; URLConnection urlConnection = null; OutputStream out = null ; try { URL url = new URL(\u0026quot;https://www.163.com/\u0026quot;) ; urlConnection = url.openConnection(); in = urlConnection.getInputStream(); out = new FileOutputStream(\u0026quot;d:\\\\163.txt\u0026quot;); byte[] buf = new byte[64] ; int len = -1 ; while( (len = in.read(buf)) != -1 ){ out.write(buf,0,len); } } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally{ try { if(out!=null) out.close(); if(in!=null) in.close(); } catch (IOException e) { e.printStackTrace(); } } } }  ​\n","id":5,"section":"posts","summary":"JDK8 lambda :简化代码 lambda λ 组成 ： 逗号隔开的参数列表 (x,x,x) () 箭头符号 -\u0026gt; 方法体 （λ代码块） 示例 package lambda; public class Demo01 { public static void test01(){ new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026quot;run....\u0026quot;); } }).start(); } public static void test02(){ new Thread( // ()","tags":["Java"],"title":"Java知识点01","uri":"https://mumulx.github.io/2020/05/java%E7%9F%A5%E8%AF%86%E7%82%B901/","year":"2020"},{"content":" JVM性能调优 组成：类加载子系统；运行时数据区；执行引擎\n方法区 永久代 堆 jdk7\n元空间 直接内存native memory\njdk8 最小20. 75M 最大 无限\n方法区与永久代、元空间之间的关系\n方法区是一种规范，永久代与元空间是它的一种具体的实现，jdk8以前使用的是永久代，它存在堆上；jdk8以后使用元空间取代永久代，运行在内存上\n为甚要这样做 以前的机器是32位的能运行的最大内存是2^32，4G（应用层2G，内核层2G，如果java执行运行在内存上的化当死循环或其他什么情况会将内存占满，所以放在了堆内存上）\n现在的机器一般都是64位了(实际使用了48位，还有16位作为保留)，所以运行的最大内存位2^48即256T\n方法区中存放的是class对象（java文件被编译成class文件，class文件被类加载器加载成class content，然后被解析成class对象）\nJDK8 从永久代到元空间\nJvm：从软件的层面屏蔽不同操作系统在底层硬件指令上的区别\n栈（filo）：局部变量，为线程分配内存空间\n栈帧：一个方法对应一块栈帧内存区域\n深入理解Java虚拟机笔记\u0026mdash;运行时栈帧结构\n局部变量不像前面介绍的类变量那样存在“准备阶段”。类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的值。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的。\njava对象的组成\n mark word 在64位机器（永远）占8个字节 类型指针(KClass Pointer) 占 4bytes（如果是32G内存以下的，默认开启对象指针压缩，4个字节）  jdk中所有的数据都是8字节对齐（永远保证是8的整数倍）\n线性地址（即类型指针的大小）\n 开启指针压缩 8bytes 不开指针压缩 16bytes  开启指针压缩\n-XX:+/-UseCompressed0ops  空对象（没有任何普通属性的对象【不包括静态属性，静态属性是跟类绑定在一起的，存在方法区中】）占多少字节？\n 开启指针压缩 16bytes （8【mark word】+4【类型指针】+0【数组长度】+0【实例数据】+4【对齐填充】） 关闭指针压缩 16bytes （8【mark word】+8【类型指针】+0【数组长度】+0【实例数据】+0【对齐填充】）  普通对象占多少字节？\nint id;//占4个字节 byte b1;//占1个字节 byte b2;//占1个字节 String name;//占4个字节   开启指针压缩 24 bytes (8【mark word】+4【类型指针】+4【id】+1【b1】+1【b2】+4【name】+2【对齐填充】) 关闭指针压缩 32 bytes (8【mark word】+8【类型指针】+4【id】+1【b1】+1【b2】+4【name】+6【对齐填充】)  数组对象占多少字节？\n聊聊JVM（三）两种计算Java对象大小的方法\n数组对象结构是\n可以发现此时对象头中有对齐填充该中情况只会在【数组对象、未开启指针压缩】对象头中才有填充\n 对象头(_mark)， 8个字节\n Oop指针，如果是32G内存以下的，默认开启对象指针压缩，4个字节\n 数组长度，4个字节\n 数据区\n Padding(内存对齐)，按照8的倍数对齐\n   开启指针压缩 关闭指针压缩  对象指针【oop】（ordinary object pointer）[四个字节，支持的最大堆空间位4G]\n从0X0000\ntest1=16字节 test2=32字节 test3=24字节  内存地址\ntest1=0x00000 test2=0x10000 test3=0x30000  开启指针压缩后，会将后面的三个0截掉（jdk中所有的对象都是以8字节对齐，1000，所以后面永远有三个0；所以在存储的时候，会将内存地址的后三位补0）\ntest1=0x00 test2=0x10 test3=0x30  这样的话，在使用的时候在加上000\n一个oop能支持的最大空间是多少（oop在开启指针压缩后，最多存储35位(4字节*8+3个0)）2^35\n开启指针压缩如何扩容oop表示的最大的空间：左移\u0026mdash;补零（8字节对齐，扩大对齐字节 补的0就会增加 ，表示的最大空间也就随之增大；但是会浪费空间；因此使用8字节对齐是合理的）\nOOM OOM，全称“Out Of Memory”，翻译成中文就是“内存用完了”，内存溢出\n导致栈溢出的原因有哪些？\n 调用链过长（栈调用太深） 死循环 无限递归 a方法调用b方法，b方法调用a方法  jdk默认栈大小为：1M\njava -XX:+PrintFlagsFinal -version | grep ThreadStack  设置栈大小（最小为160k）\n-Xss160k  public class Test(){ privite int deep =0; public void aa(){ deep++; aa(); } public static void main(String[] args){ Test test = new Test(); try{ test.aa(); }catch(Throwable t){ System.out.println(test.deep);//此时输出的是栈深度 } } }   栈深度 772\n栈大小为 160k\n如何计算栈帧的大小：160*1024\u0026frasl;772\n 如何避免虚拟机栈溢出\n 避免死循环，递归给出口\n 如何调优：设置参数\n-Xss160k  class文件解析 class文件解析参照表\n深入理解JVM之Java字节码（.class）文件详解参考\n从一个class文件深入理解Java字节码结构参考\nJVM指令手册\n一个类可以声明的成员属性上限是多少?\n255:class文件中用于存储属性数量占两个字节，因此最大值为[0F0F]\n一个类 可以声明的方法上限是多少?\n255:class文件中用于存储方法数量占两个字节，因此最大值为[0F0F]\n一个方法的形参上限是多少?怎么算出来的?算上this呢?\n 255:class文件中用于存储方法数量占两个字节，因此最大值为[0F0F]\n java static方法的参数最多只能有255个，非static方法最多只能有254个 在计算args_size时，有判断方法是否为static方法，如果不是static方法，则会在方法原有参数数量上再加一，这是因为非static方法会添加一个默认参数到参数列表首位：方法的真正执行者，即方法所属类的实例对象this  code的attribute_length占四个字节，最大值为【0F0F0F0F】Java方法体的字节数不能超过65535字节\n  假设现在在方法内部，你想获得对当前对象的引用。但是，对象引用是被秘密地传达给编译器——并不在参数列表中。方便的是，有一个关键字: this 。this 关键字只能在非静态方法内部使用。当你调用一个对象的方法时，this 生成了一个对象引用。你可以像对待其他引用一样对待这个引用。如果你在一个类的方法里调用其他该类中的方法，不要使用 this，直接调用即可，this 自动地应用于其他方法上了。\n一个方法最多支持多少个局部变量?如果是long、double类 型呢?\n 255 其实255规定的是参数的最大单位数量，而非参数数量。long或double类型作为参数会占据两个两个单位的长度。  每个方法的局部变量表的size是如何计算出来的?\nJava中的异常是如何实现的?\n字节\u0026mdash;-位 1字节= 8位8个二进制位 0000 1111\n0 \u0026ndash; 2的8次方 无符号 0-255 有符号 -128 \u0026mdash; 127 255.255.255.255 JVM最多只会255个字节码指令\n255.255.255.255\nJVM最多只会255个字节码指令\njavap -c xx javap -verbose  字节码文件.class 深入理解Java虚拟机笔记\u0026mdash;class类文件魔数,版本,常量池\nJVM NEW的过程 Java中new一个对象的步骤：\nJVM this生成时机 java this关键字的本质\nthis其实就是通过方法体的第一个参数传递过来的，它指代调用该方法的对象。通过这个例子应该能够更加直观具体的体会this的含义了。\njava 在执行构造函数的时候会将，this作为参数列表的第一个参数传给构造函数，也就是说this在这个时候产生的\njvm new 字节码\njava new一个对象的步骤\nthis创建时机\nJVM探究  请你谈谈你对VM的理解? java8虚拟机和之 前的变化更新? 什么是00M,什么是栈溢出StackOverFlowError? 怎么分析? JVM的常用调优参数有哪些? 内存快照如何抓取，怎么分析Dump文件?知道吗? 谈谈JVM中， 类加载器你的认识?  JVM的位置 运行在操作系统上（jre包含了jvm）\nJVM的体系结构 栈，本地方法栈，程序计数器中没有垃圾\n所谓了jvm调优就是在堆中调优（最重要）和人方法区中调优\n本地方法接口（JNI）\n类加载器 类是一个模板是抽象的\nClass\u0026lt;? extends Car\u0026gt; aClass1 = car1. getClass(); ClassLoader classLoader = aClass1. getClassLoader(); System. out . print1n(classLoader);//AppClassLoader // System. out . println(classLoader . getParent()); //ExtClassLoader \\jre\\lib\\ext System. out . print1n(classLoader . getParent(). getParent()); //null 1. 不存在2.java程序获收不到rt.jar   虚拟机自带的加载器 启动类(根)加载器 扩展类加载器 应用程序加载器  双亲委派机制 package java.lang; public class String { //双亲委派机制:安全 // 1. APP（当前类）--\u0026gt;EXC（扩展）---B0OT(最终执行) public String toString() { return \u0026quot;Hello\u0026quot;; } pub1ic static void main(String[] args) { String s = new String(); s.tostring(); } } //我们自己写了一个与javaString同包同名的String类，想要调用他的toString方法，但是会报错，这是由于他的双亲委派机制，会向上寻找，最终执行的是java的String的方法。当且仅当根加载器，和扩展类加载器中都没有该类才会执行应用程序加载器 /* 1.类加载器收到类加载的请求 2.将这个请求向上委托给父类加载器去完成， -直向上委托，直到启动类加载器 3.启动加载器检查是否能够加载当前这个类，能加载就结束， 使用当前的加载器，否则， 抛出异常， 通知子加载器进行加载 4.重复步骤3 */  沙箱安全机制 参考\nNative public static void main(String[] args) { new Thread(()-\u0026gt;{ }, name: \u0026quot;my thread name\u0026quot;). start(); //线程start调用的就是start0方法，但是它又没有函数体 private native void start0();  native :凡是带了native 关键字的， 说java的作用范围达不到了，回去调用底层C语言的库!会进入本地方法栈会调用本地方法接口（JNI）\nJNI的作用：扩展Java的使用，融合不同变成语言为Java所用！\nJava诞生的时候C、C++ 横行，想要立足，必须要有调//C、C++的程序 它在内存区城中专门开辟了一块标记区城: Native Method Stack,登记native 方法 在最终执行的时候，加代本地方法库中的方法通过JNI\nPC寄存器 PC寄存器也叫程序计数器: Program Counter Register 每个线程都有一个程序计数器，是线程私有的,就是一一个指针, 指向方法区中的方法字节码(用来存储指向一条指令的地址,即即将要执行的指令代码)，在执行引擎中读取下一条指令,是一个非常小的（占用）内存空间，几乎可以忽略不计。\nJVM学习笔记 \u0026mdash;\u0026mdash;\u0026mdash; 程序计数器\n方法区 Method Area方法区\n方法区是被所有线程共享,所有字段和方法字节码，以及-些特殊方法，如构造函数,接口代码也在此定义, 简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间;\n静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存 中，和方法区无关\nstatic final, Class, 常量池\n方法区（关于java虚拟机内存的那些事）\n栈 栈:先进后出、后进先出:桶 队列:先进先出( FIFO : First Input First Output )\n喝多了吐就是栈，吃多了拉就是队列\n栈:栈内存，主管程序的运行，生命周期和线程同步; 线程结束，栈内存也就是释放，对于栈来说不存在垃圾回收\n栈: 8大基本类型 +对象引用+实例的方法\n每一个线程就会产生一个栈\njava每执行一个方法就会产生一个栈帧，按照栈先进后出的顺序慢慢被压栈，现在正在在执行的方法永远在栈的顶部\n栈运行原理:栈帧 栈满了: StackOverflowError\njava的本质是值传递\n简单类对象的实例化过程\n　1、在方法区加载类；\n　2、在栈内存申请空间，声明变量P；\n　3、在堆内存中开辟空间，分配对象地址；\n　4、在对象空间中，对对象的属性进行默认初始化，类成员变量显示初始化；\n　5、构造方法进栈，进行初始化；\n　6、初始化完成后，将堆内存中的地址赋给引用变量，构造方法出栈；\n子类对象的实例化过程\n　1、在方法区先加载父类，再加载子类；\n　2、在栈中申请空间，声明变量P；\n　3、在堆内存中开辟空间，分配对象地址；\n　4、在对象空间中，对对象的属性（包括父类的属性）进行默认初始化；\n　5、子类构造方法进栈；\n　6、显示初始化父类的属性；\n　7、父类构造方法进栈，执行完毕出栈；\n　8、显示初始化子类的属性；\n　9、初始化完毕后，将堆内存中的地址值赋给引用变量P，子类构造方法出栈；\n三种JVM 查看虚拟机版本\njava -version   Sun公司HotSpot Java HotSpot\u0026trade; 64-Bit Server VM (bui1d 25. 181-b13，mixed mode) BEA JRockit IBMJ9VM  我们学习都是: Hotspot\n堆 Heap, 一个JVM只有一个堆内存，堆内存的大小是可以调节的。\n类加载器读取了类文件后，一般会把什么东西放到堆中?类, 方法,常量,变量~,保存我们所有引用类型的真实对象;\n堆内存中还要细分为三个区域:\n 新生区(伊甸园区) 养老区 永久区  GC垃圾回收，主要是在伊甸园区和养老区~\n假设内存满了，会报错OOM（java.lang.OutOfMemoryError: Java heap space）,堆内存不够!\n在JDK8以后，永久存储区改了个名字(元空间)\n新生代  类:诞生和成长的地方，甚至死亡; 伊甸园，所有的对象都是在伊甸园区new出来的! 幸存者区(0,1)  真理:经过研究，99%的对象都是临时对象!\n参考三个代之间关系\n老年代 老年代里存放的都是存活时间较久的，大小较大的对象，因此年老代使用标记整理算法。当年老代容量满的时候，会触发一次Major GC（full GC），回收老年代和年轻代中不再被使用的对象资源。\n永久代 这个区域常驻内存的。用来存放JDK自身携带的Class对象。Interface元数据, 存储的是Java运行时的一些环境或类信息~，这个区域不存在垃圾回收！关闭虚拟机就会释放这个区域的内存\n一个启动类，加载了大量的第三方jar包，Romcat部署了太多的应用，大量动态生成的发射类。不断地被加载。直到内存满，就会出现OOM\n jdk1.6之前:永久代,常量池是在方法区;\n jdk1.7 .永久代，但是慢慢的退化了，去永久代， 常量池在堆中\n jdk1.8之后:无永久代，常量池在元空间\n  持久代又被称为非堆：其中有方法区，方法区中又有一部分区域为常量池\n持久代：逻辑上存在但是物理上不存在：即堆内存=新生区+老年代\npublic static void main(String[] args) { //返回虚拟机试图使用的最大内存 long max = Runtime . getRuntime() . maxMemory(); //字节 1024 * 1024 //返回jvm的初始化总内存 1ong total = Runtime . getRuntime(). totalMemory(); System . out. print1n( \u0026quot;max=\u0026quot;+max+\u0026quot;字节\\t\u0026quot;+( max/(double)1024/1024)+\u0026quot;MB\u0026quot;); System. out. print1n(\u0026quot;tota1=\u0026quot;+max+\u0026quot;字节\\t\u0026quot;+(total/ ( double)1024/1024)+\u0026quot;MB\u0026quot;); } //默认情况下:分配的总内存是电脑内存的1/4，而初始化的内存:1/64  遇到OOM怎么办\n 尝试扩大堆内存看结果\n-Xms1024m -Xmx1024m -XX:+PrintGCDetails  分析内存，看一下哪一个地方出现了问题（专业工具）\n  轻GC，重GC（full GC）\n伊甸园区满了会触发触发轻GC，将垃圾回收放到幸存区中，重复几次；当伊甸园区和两个幸存区都满了之后就会触发重GC，触发重GC之后就会触发轻GC了；就这样循环，直到重GC也清理不了了：年轻代满了，老年代也满了元数据也满了才会报错OOM\n堆内存调优 在一个项目中，突然出现了OOM故障,那么该如何排除~研究为什么出错\n 能够看到代码第几行出错：内存快照分析工具：MAT（eclipse），Jprofiler Debug，一行行分析代码！  MAT，Jprofile作用：\n 分析Dump内存文件,快速定位内存泄露; 获得堆中的数据 获得大的对象~  Throwable（异常地顶级接口）两大类：Exception 、 error\nidea安装jprofiler插件，win10安装jprofiler程序（安装位置不能有空格），在idea中设置win10安装jprofiler地exe\n-Xms1m -Xmx:8m -XX:+HeapDumpOnOutOfMemoryError  //-Xms1m -Xmx:8m -XX:+HeapDumpOnOutOfMemoryError pub1ic class Demo03 { byte[] array = new byte[1* 1024*1024]; //1m public static void main(String[] args) { ArrayList\u0026lt;Demo03\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); int count = 0; try { while (true){ list.add(new Demo03()); //问题所在 count = count+1; } }catch (Error e){ System.out.println(\u0026quot;count: \u0026quot;+count); e.printStackTrace(); } } }  在src同级目录下会出现一个文件\n// -Xms 设置初始化内存分配大小/164 // -Xmx 设置最大分配内存，默认1/4 // -XX: +PrintGCDetails //打E印IGC垃圾回收信息 // -XX; +HeapDumpOnOutOfMemoryError //oom DUMP 当出现OutOfMemoryError时就dump文件  GC 垃圾回收主要在堆中\nJVM在进行GC时，并不是对这三个区域统一一回收。 大部分时候，回收都是新生代~\n 新生代 幸存区(from,to) 老年区  GC两种类:轻GC (普通的GC)， 重GC (全局GC)\nGC题目:  JVM的内存模型和分区~详细到每个区放什么? 堆里面的分区有哪些? Eden, form, to, 老年区，说说他们的特点! GC的算法有哪些?标记清除法，标记整理,复制算法，引用计数器,怎么用地？ 轻GC和重GC分别在什么时候发生?  常用算法 引用计数法 用地较少\n[java中垃圾回收机制中的引用计数法和可达性分析法\n复制算法 幸存区（from和to地判断）：谁空谁是to\n始终保存幸存区中有一个是空的\n 好处:没有内存的碎片~\n 坏处:浪费了内存空间~多了一半空间永远是空的(to)\n  假设对象100%存货（极端情况这种算法的弊端就很大）\n复制算法最佳使用场景:对象存活度较低的时候;新生区\n标记清除法 世界上第一个GC算法，由 JohnMcCarthy 在1960年发布。\nGC算法精解（五分钟让你彻底明白标记/清除算法）\n 优点:不需要额外的空间!| 缺点:两次扫描，严重浪费时间，会产生内存碎片  标记压缩算法 标记-压缩算法\n再优化\n但是多了一个移动成本\n标记清除压缩算法 先标记清除几次，再进行压缩\n总结  内存效率:复制算法\u0026gt;标记清除算法\u0026gt;标记压缩算法(时间复杂度) 内存整齐度:复制算法=标记压缩算法\u0026gt;标记清除算法 内存利用率:标记压缩算法=标记清除算法\u0026gt;复制算法  思考一个问题:难道没有最优算法吗?\n答案：没有，没有最好的算法，只有最合适的算法\nGC :分代收集算法\n年轻代:\n 存活率低 复制算法!  老年代:\n 区域大:存活率 标记清除(内存碎片不是太多) +标记压缩混合实现  JMM java Memory Model(java内存模型)\n","id":6,"section":"posts","summary":"JVM性能调优 组成：类加载子系统；运行时数据区；执行引擎 方法区 永久代 堆 jdk7 元空间 直接内存native memory jdk8 最小20. 75M 最大 无限 方法区与永久代、元","tags":["Java"],"title":"Java进阶及JVM","uri":"https://mumulx.github.io/2020/05/java%E8%BF%9B%E9%98%B6jvm/","year":"2020"},{"content":" JUC 1 、什么是JUC java.util 工具包、包、分类\n业务：普通的线程代码 Thread\nRunnable 没有返回值、效率相比入 Callable 相对较低！\n2 、线程和进程  线程、进程，如果不能使用一句话说出来的技术，不扎实！\n 进程：一个程序，QQ.exe Music.exe 程序的集合；\n一个进程往往可以包含多个线程，至少包含一个！\nJava默认有几个线程？ 2 个 mian、GC\n线程：开了一个进程 Typora，写字，自动保存（线程负责的）\n对于Java而言：Thread、Runnable、Callable\nJava 真的可以开启线程吗？ 开不了,底层调用的是native方法，调用本地方法\npublic synchronized void start() { /** * This method is not invoked for the main method thread or \u0026quot;system\u0026quot; * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state \u0026quot;NEW\u0026quot;. */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } // 本地方法，底层的C++ ，Java 无法直接操作硬件 private native void start0();   并发、并行\n 并发编程：并发、并行\n并发（多线程操作同一个资源）\n CPU 一核 ，模拟出来多条线程，天下武功，唯快不破，快速交替  并行（多个人一起行走）\n CPU 多核 ，多个线程可以同时执行； 线程池  并发编程的本质： 充分利用CPU的资源\n所有的公司都很看重！\n企业，挣钱=\u0026gt; 提高效率，裁员，找一个厉害的人顶替三个不怎么样的人；\n人员（减） 、技术成本（高）\n 线程有几个状态\n //Thread.State public enum State { // 新生 NEW, // 运行 RUNNABLE, // 阻塞 BLOCKED, // 等待，死死地等 WAITING, // 超时等待 TIMED_WAITING, // 终止 TERMINATED; }   wait/sleep 区别\n 1 、来自不同的类\nwait =\u0026gt; Object\nsleep =\u0026gt; Thread\nTimeUnit.SECONDS.sleep(1);  2 、关于锁的释放\nwait 会释放锁，sleep 睡觉了，抱着锁睡觉，不会释放！\n3 、使用的范围是不同的\nwait:必须在同步代码块中\nsleep 可以再任何地方睡\n4 、是否需要捕获异常\nwait 不需要捕获异常\nsleep 必须要捕获异常\n都需要捕获中断异常，它们都可以被interrupted方法中断。\n3 、Lock锁（重点）  传统 Synchronized\n // 基本的卖票例子 import java.time.OffsetDateTime; /** * 真正的多线程开发，公司中的开发，降低耦合性 * 线程就是一个单独的资源类，没有任何附属的操作！ * 1、 属性、方法 */ public class SaleTicketDemo01 { public static void main(String[] args) { // 并发：多线程操作同一个资源类, 把资源类丢入线程 Ticket ticket = new Ticket(); // @FunctionalInterface 函数式接口，jdk1.8 lambda表达式 (参数)-\u0026gt;{ 代码 } new Thread(()-\u0026gt;{ for (int i = 1 ; i \u0026lt; 40 ; i++) { ticket.sale(); } },\u0026quot;A\u0026quot;).start(); new Thread(()-\u0026gt;{ for (int i = 1 ; i \u0026lt; 40 ; i++) { ticket.sale(); } },\u0026quot;B\u0026quot;).start(); new Thread(()-\u0026gt;{ for (int i = 1 ; i \u0026lt; 40 ; i++) { ticket.sale(); } },\u0026quot;C\u0026quot;).start(); } } // 资源类 OOP class Ticket { // 属性、方法 private int number = 30 ; // 卖票的方式 // synchronized 本质: 队列，锁 public synchronized void sale(){ if (number\u0026gt; 0 ){ System.out.println(Thread.currentThread().getName()+\u0026quot;卖出了\u0026quot;+(number--)+\u0026quot;票,剩余：\u0026quot;+number); } } }   Lock接口\n 公平锁：十分公平：可以先来后到 非公平锁：十分不公平：可以插队 （默认）\npackage com.kuang.demo01; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class SaleTicketDemo02 { public static void main(String[] args) { // 并发：多线程操作同一个资源类, 把资源类丢入线程 Ticket2 ticket = new Ticket2(); // @FunctionalInterface 函数式接口，jdk1.8 lambda表达式 (参数)-\u0026gt;{ 代码 } new Thread(()-\u0026gt;{for (int i = 1; i \u0026lt; 40 ; i++) ticket.sale();},\u0026quot;A\u0026quot;).start(); new Thread(()-\u0026gt;{for (int i = 1; i \u0026lt; 40 ; i++) ticket.sale();},\u0026quot;B\u0026quot;).start(); new Thread(()-\u0026gt;{for (int i = 1; i \u0026lt; 40 ; i++) ticket.sale();},\u0026quot;C\u0026quot;).start(); } // Lock三部曲 // 1、 new ReentrantLock(); // 2、 lock.lock(); // 加锁 // 3、 finally=\u0026gt; lock.unlock(); // 解锁 class Ticket2 { // 属性、方法 private int number = 30; Lock lock = new ReentrantLock(); public void sale(){ lock.lock(); // 加锁 try { // 业务代码 if (number\u0026gt;0){ System.out.println(Thread.currentThread().getName()+\u0026quot;卖出了\u0026quot;+ (number--)+\u0026quot;票,剩余：\u0026quot;+number); } } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); // 解锁 } } }   Synchronized 和 Lock 区别\n 1 、Synchronized 内置的Java关键字， Lock 是一个Java类\n2 、Synchronized 无法判断获取锁的状态，Lock 可以判断是否获取到了锁\n3 、Synchronized 会自动释放锁，lock 必须要手动释放锁！如果不释放锁， 死锁\n4 、Synchronized 线程 1 （获得锁，阻塞）、线程 2 （等待，傻傻的等）；Lock锁就不一定会等待下 去；\n5 、Synchronized 可重入锁，不可以中断的，非公平；Lock ，可重入锁，可以 判断锁，非公平（可以 自己设置）；\n6 、Synchronized 适合锁少量的代码同步问题，Lock 适合锁大量的同步代码！\n 锁是什么，如何判断锁的是谁！\n 4 、生产者和消费者问题 面试的：单例模式、排序算法、生产者和消费者、死锁\n 生产者和消费者问题 Synchronized 版\n /** * 线程之间的通信问题：生产者和消费者问题！ 等待唤醒，通知唤醒 * 线程交替执行 A B 操作同一个变量 num = 0 * A num+1 * B num-1 */ public class A { public static void main(String[] args) { Data data = new Data(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } },\u0026quot;A\u0026quot;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } },\u0026quot;B\u0026quot;).start(); } } // 判断等待，业务，通知 class Data{ // 数字 资源类 private int number = 0; //+1 public synchronized void increment() throws InterruptedException { if (number!=0){ //0 // 等待 this.wait(); } number++; System.out.println(Thread.currentThread().getName()+\u0026quot;=\u0026gt;\u0026quot;+number); // 通知其他线程，我+1完毕了 this.notifyAll(); } //-1 public synchronized void decrement() throws InterruptedException { if (number==0){ // 1 // 等待 this.wait(); } number--; System.out.println(Thread.currentThread().getName()+\u0026quot;=\u0026gt;\u0026quot;+number); // 通知其他线程，我-1完毕了 this.notifyAll(); } }   问题存在，A B C D 4 个线程！ 虚假唤醒\n if 改为 while 判断\npackage com.kuang.pc; /** * 线程之间的通信问题：生产者和消费者问题！ 等待唤醒，通知唤醒 * 线程交替执行 A B 操作同一个变量 num = 0 * A num+1 * B num-1 */ public class A { public static void main(String[] args) { Data data = new Data(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } },\u0026quot;A\u0026quot;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } },\u0026quot;B\u0026quot;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } },\u0026quot;C\u0026quot;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } },\u0026quot;D\u0026quot;).start(); } } // 判断等待，业务，通知 class Data{ // 数字 资源类 private int number = 0; //+1 public synchronized void increment() throws InterruptedException { while (number!=0){ //0 // 等待 this.wait(); } number++; System.out.println(Thread.currentThread().getName()+\u0026quot;=\u0026gt;\u0026quot;+number); // 通知其他线程，我+1完毕了 this.notifyAll(); } //-1 public synchronized void decrement() throws InterruptedException { while (number==0){ // 1 // 等待 this.wait(); } number--; System.out.println(Thread.currentThread().getName()+\u0026quot;=\u0026gt;\u0026quot;+number); // 通知其他线程，我-1完毕了 this.notifyAll(); } }   JUC版的生产者和消费者问题\n使用JUC的lock，就是要有一个try catch finally块，在try前lock.lock(),在try中写具体的业务代码，finnally中释放锁lock.unlock();\n 模板\n通过Lock 找到 Condition\n代码实现： package com.kuang.pc; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class B { public static void main(String[] args) { Data2 data = new Data2(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } },\u0026quot;A\u0026quot;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } },\u0026quot;B\u0026quot;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } },\u0026quot;C\u0026quot;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } },\u0026quot;D\u0026quot;).start(); } } // 判断等待，业务，通知 class Data2{ // 数字 资源类 private int number = 0; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); //condition.await(); // 等待 //condition.signalAll(); // 唤醒全部 //+1 public void increment() throws InterruptedException { lock.lock(); try { // 业务代码 while (number!=0){ //0 // 等待 condition.await(); } number++; System.out.println(Thread.currentThread().getName()+\u0026quot;=\u0026gt;\u0026quot;+number); // 通知其他线程，我+1完毕了 condition.signalAll(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } //-1 public synchronized void decrement() throws InterruptedException { lock.lock(); try { while (number==0){ // 1 // 等待 condition.await(); } number--; System.out.println(Thread.currentThread().getName()+\u0026quot;=\u0026gt;\u0026quot;+number); // 通知其他线程，我-1完毕了 condition.signalAll(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } }  任何一个新的技术，绝对不是仅仅只是覆盖了原来的技术，优势和补充！\n Condition 精准的通知和唤醒线程\n 代码测试： import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * A 执行完调用B，B执行完调用C，C执行完调用A */ public class C { public static void main(String[] args) { Data3 data = new Data3(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt;10 ; i++) { data.printA(); } },\u0026quot;A\u0026quot;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt;10 ; i++) { data.printB(); } },\u0026quot;B\u0026quot;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt;10 ; i++) { data.printC(); } },\u0026quot;C\u0026quot;).start(); } } class Data3{ // 资源类 Lock private Lock lock = new ReentrantLock(); private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); private int number = 1; // 1A 2B 3C public void printA(){ lock.lock(); try { // 业务，判断-\u0026gt; 执行-\u0026gt; 通知 while (number!=1){ // 等待 condition1.await(); } System.out.println(Thread.currentThread().getName()+\u0026quot;=\u0026gt;AAAAAAA\u0026quot;); // 唤醒，唤醒指定的人，B number = 2; condition2.signal(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } public void printB(){ lock.lock(); try { // 业务，判断-\u0026gt; 执行-\u0026gt; 通知 while (number!=2){ condition2.await(); } System.out.println(Thread.currentThread().getName()+\u0026quot;=\u0026gt;BBBBBBBBB\u0026quot;); // 唤醒，唤醒指定的人，c number = 3; condition3.signal(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } public void printC(){ lock.lock(); try { // 业务，判断-\u0026gt; 执行-\u0026gt; 通知 // 业务，判断-\u0026gt; 执行-\u0026gt; 通知 while (number!=3){ condition3.await(); } System.out.println(Thread.currentThread().getName()+\u0026quot;=\u0026gt;BBBBBBBBB\u0026quot;); // 唤醒，唤醒指定的人，c number = 1; condition1.signal(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } }  5 、 8 锁现象 如何判断锁的是谁！永远的知道什么锁，锁到底锁的是谁！\n深刻理解我们的锁（只会锁两个东西1.new出来的对象，class模板）\nimport java.util.concurrent.TimeUnit; /** * 8锁，就是关于锁的8个问题 * 1、标准情况下，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话 （锁的是同一个对象，谁先拿到锁谁就先执行） * 1、sendSms延迟4秒，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话（锁的是同一个对象，谁先拿到锁谁就先执行） */ public class Test1 { public static void main(String[] args) { Phone phone = new Phone(); //锁的存在 new Thread(()-\u0026gt;{ phone.sendSms(); },\u0026quot;A\u0026quot;).start(); // 捕获 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(()-\u0026gt;{ phone.call(); },\u0026quot;B\u0026quot;).start(); } } class Phone{ // synchronized 锁的对象是方法的调用者！、 // 两个方法用的是同一个锁，谁先拿到谁执行！ public synchronized void sendSms(){ try { TimeUnit.SECONDS.sleep(4); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026quot;发短信\u0026quot;); } public synchronized void call(){ System.out.println(\u0026quot;打电话\u0026quot;); } }  package com.kuang.lock8; import java.util.concurrent.TimeUnit; /** * 3、 增加了一个普通方法后！先执行发短信还是打电话？ 普通方法：打电话（这里没有锁！不是同步方法，不受锁的影响） * 4、 两个对象，两个同步方法， 发短信还是 打电话？ // 打电话（两个对象，两个调用者，两把锁！普通方法锁的是迪调用者） */ public class Test2 { public static void main(String[] args) { // 两个对象，两个调用者，两把锁！ Phone2 phone1 = new Phone2(); Phone2 phone2 = new Phone2(); //锁的存在 new Thread(()-\u0026gt;{ phone1.sendSms(); },\u0026quot;A\u0026quot;).start(); // 捕获 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(()-\u0026gt;{ phone2.call(); },\u0026quot;B\u0026quot;).start(); } } class Phone2{ // synchronized 锁的对象是方法的调用者！ public synchronized void sendSms(){ try { TimeUnit.SECONDS.sleep(4); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026quot;发短信\u0026quot;); } public synchronized void call(){ System.out.println(\u0026quot;打电话\u0026quot;); } // 这里没有锁！不是同步方法，不受锁的影响 public void hello(){ System.out.println(\u0026quot;hello\u0026quot;); } }  package com.kuang.lock8; import java.util.concurrent.TimeUnit; /** * 5、增加两个静态的同步方法，只有一个对象，先打印 发短信？打电话？ 发短信（静态方法锁的是class，谁先拿到锁谁先执行） * 6、两个对象！增加两个静态的同步方法， 先打印 发短信？打电话？\t发短信（静态方法锁的是class，谁先拿到锁谁先执行） */ public class Test3 { public static void main(String[] args) { // 两个对象的Class类模板只有一个，static，锁的是Class Phone3 phone1 = new Phone3(); Phone3 phone2 = new Phone3(); //锁的存在 new Thread(()-\u0026gt;{ phone1.sendSms(); },\u0026quot;A\u0026quot;).start(); // 捕获 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(()-\u0026gt;{ phone2.call(); },\u0026quot;B\u0026quot;).start(); } } // Phone3唯一的一个 Class 对象 class Phone3{ // synchronized 锁的对象是方法的调用者！ // static 静态方法 // 类一加载就有了！锁的是Class public static synchronized void sendSms(){ try { TimeUnit.SECONDS.sleep(4); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026quot;发短信\u0026quot;); } public static synchronized void call(){ System.out.println(\u0026quot;打电话\u0026quot;); } }  package com.kuang.lock8; import java.util.concurrent.TimeUnit; /** * 1、1个静态的同步方法，1个普通的同步方法 ，一个对象，先打印 发短信？打电话？ 打电话（二者锁的对象不一样，是两把锁：静态同步方法锁的是class，普通对象锁的是 调用者） * 2、1个静态的同步方法，1个普通的同步方法 ，两个对象，先打印 发短信？打电话？打电话（二者锁的对象不一样，是两把锁：静态同步方法锁的是class，普通对象锁的是 调用者） */ public class Test4 { public static void main(String[] args) { // 两个对象的Class类模板只有一个，static，锁的是Class Phone4 phone1 = new Phone4(); Phone4 phone2 = new Phone4(); //锁的存在 new Thread(()-\u0026gt;{ phone1.sendSms(); },\u0026quot;A\u0026quot;).start(); // 捕获 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(()-\u0026gt;{ phone2.call(); },\u0026quot;B\u0026quot;).start(); } } // Phone3唯一的一个 Class 对象 class Phone4{ // 静态的同步方法 锁的是 Class 类模板 public static synchronized void sendSms(){ try { TimeUnit.SECONDS.sleep(4); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026quot;发短信\u0026quot;); } // 普通的同步方法 锁的调用者 public synchronized void call(){ System.out.println(\u0026quot;打电话\u0026quot;); } }   小结\n new this 具体的一个手机\nstatic Class 唯一的一个模板\n6 、集合类不安全  List 不安全\n package com.kuang.unsafe; import java.util.*; import java.util.concurrent.CopyOnWriteArrayList; // java.util.ConcurrentModificationException 并发修改异常！ public class ListTest { public static void main(String[] args) { // 并发下 ArrayList 不安全的吗，Synchronized； /** * 解决方案； * 1、List\u0026lt;String\u0026gt; list = new Vector\u0026lt;\u0026gt;(); vector先于Arraylist出现 * 2、List\u0026lt;String\u0026gt; list = Collections.synchronizedList(new ArrayList\u0026lt;\u0026gt; ()); * 3、List\u0026lt;String\u0026gt; list = new CopyOnWriteArrayList\u0026lt;\u0026gt;()； */ // CopyOnWrite 写入时复制 COW 计算机程序设计领域的一种优化策略； //CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。 // 多个线程调用的时候，list，读取的时候，固定的，写入（覆盖） // 在写入的时候避免覆盖，造成数据问题！ // 读写分离 // CopyOnWriteArrayList 比 Vector Nb 在哪里？ /** Vector使用的是synchronized //效率低 CopyOnWriteArrayList使用的是Lock */ List\u0026lt;String\u0026gt; list = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;= 10; i++) { new Thread(()-\u0026gt;{ list.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(list); },String.valueOf(i)).start(); } } }  聊聊并发-Java中的Copy-On-Write容器\n学习方法推荐： 1 、先会用、 2 、货比 3 家，寻找其他解决方案， 3 、分析源码！\n Set 不安全\n blockingQueue：阻塞队列\npackage com.kuang.unsafe; import java.util.Collections; import java.util.HashSet; import java.util.Set; import java.util.UUID; import java.util.concurrent.CopyOnWriteArraySet; /** * 同理可证 ： ConcurrentModificationException 并发修改异常 * //1、Set\u0026lt;String\u0026gt; set = Collections.synchronizedSet(new HashSet\u0026lt;\u0026gt;()); * //2、Set\u0026lt;String\u0026gt; set = new CopyOnWriteArraySet\u0026lt;\u0026gt;(); */ public class SetTest { public static void main(String[] args) { // Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); // Set\u0026lt;String\u0026gt; set = Collections.synchronizedSet(new HashSet\u0026lt;\u0026gt;()); Set\u0026lt;String\u0026gt; set = new CopyOnWriteArraySet\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;=30 ; i++) { new Thread(()-\u0026gt;{ set.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(set); },String.valueOf(i)).start(); } } }  hashSet 底层是什么？\npublic HashSet() {//HashSet的底层就是HashMap map = new HashMap\u0026lt;\u0026gt;(); } // add set 本质就是 map key是无法重复的！ public boolean add(E e) { return map.put(e, PRESENT)==null; } private static final Object PRESENT = new Object(); // 不变得值！   Map 不安全\n 回顾Map基本操作\npackage com.kuang.unsafe; import java.util.Collections; import java.util.HashMap; import java.util.Map; import java.util.UUID; import java.util.concurrent.ConcurrentHashMap; // ConcurrentModificationException public class MapTest { public static void main(String[] args) { // map 是这样用的吗？ 不是，工作中不用 HashMap // 默认等价于什么？ new HashMap\u0026lt;\u0026gt;(16,0.75); // Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); //Map\u0026lt;String, String\u0026gt; map1 = Collections.synchronizedMap(map); // 唯一的一个家庭作业：研究ConcurrentHashMap的原理 Map\u0026lt;String, String\u0026gt; map = new ConcurrentHashMap\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;=30; i++) { new Thread(()-\u0026gt;{ map.put(Thread.currentThread().getName(),UUID.randomUUID().toString().substring(0,5)); System.out.println(map); },String.valueOf(i)).start(); } } }  7 、Callable ( 简单 ) 1 、可以有返回值\n2 、可以抛出异常\n3 、方法不同，run()/ call()\n 代码测试\n ![image-20200515124046297](/resources/技术收录/Java/java并发/image-20200515124046297.png\nimport java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; import java.util.concurrent.locks.ReentrantLock; /** * 1、探究原理 * 2、觉自己会用 */ public class CallableTest { public static void main(String[] args) throws ExecutionException, InterruptedException { // new Thread(new Runnable()).start(); // new Thread(new FutureTask\u0026lt;V\u0026gt;()).start(); // new Thread(new FutureTask\u0026lt;V\u0026gt;( Callable )).start(); new Thread().start(); // 怎么启动Callable MyThread thread = new MyThread(); FutureTask futureTask = new FutureTask(thread); // 适配类 new Thread(futureTask,\u0026quot;A\u0026quot;).start(); new Thread(futureTask,\u0026quot;B\u0026quot;).start(); // 结果会被缓存，效率高 Integer o = (Integer) futureTask.get(); //这个get 方法可能会产生阻塞！把他放到最后 // 或者使用异步通信来处理！ System.out.println(o); } } class MyThread implements Callable\u0026lt;Integer\u0026gt; { @Override public Integer call() { System.out.println(\u0026quot;call()\u0026quot;); // 会打印几个call // 耗时的操作 return 1024; } } class MyThread1 implements Runnable { @Override public void run() { } }  细节：\n1 、有缓存\n2 、结果可能需要等待，会阻塞！\n8 、常用的辅助类(必会) 8.1、CountDownLatch import java.util.concurrent.CountDownLatch; // 计数器 public class CountDownLatchDemo { public static void main(String[] args) throws InterruptedException { // 总数是6，必须要执行任务的时候，再使用！ CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 1; i \u0026lt;=6 ; i++) { new Thread(()-\u0026gt;{ System.out.println(Thread.currentThread().getName()+\u0026quot; Go out\u0026quot;); countDownLatch.countDown(); // 数量-1 },String.valueOf(i)).start(); } countDownLatch.await(); // 等待计数器归零，然后再向下执行 System.out.println(\u0026quot;Close Door\u0026quot;); } }  原理： countDownLatch.countDown(); // 数量-1 countDownLatch.await(); // 等待计数器归零，然后再向下执行，每次有线程调用 countDown() 数量-1，假设计数器变为0，countDownLatch.await() 就会被唤醒，继续执行！  8.2、CyclicBarrier 加法计数器\nimport java.util.concurrent.BrokenBarrierException; import java.util.concurrent.CyclicBarrier; public class CyclicBarrierDemo { public static void main(String[] args) { /** * 集齐7颗龙珠召唤神龙 */ // 召唤龙珠的线程 CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()-\u0026gt;{ System.out.println(\u0026quot;召唤神龙成功！\u0026quot;); }); for (int i = 1; i \u0026lt;=7 ; i++) { final int temp = i; // lambda能操作到 i 吗 new Thread(()-\u0026gt;{ System.out.println(Thread.currentThread().getName()+\u0026quot;收 集\u0026quot;+temp+\u0026quot;个龙珠\u0026quot;); try { cyclicBarrier.await(); // 等待 } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } }).start(); } } }  8.3、Semaphore Semaphore：信号量\n抢车位！\n6 车\u0026mdash;3个停车位置\nimport java.util.concurrent.Semaphore; import java.util.concurrent.TimeUnit; public class SemaphoreDemo { public static void main(String[] args) { // 线程数量：停车位! 限流！ Semaphore semaphore = new Semaphore(3); for (int i = 1; i \u0026lt;=6 ; i++) { new Thread(()-\u0026gt;{ // acquire() 得到 try { semaphore.acquire(); System.out.println(Thread.currentThread().getName()+\u0026quot;抢到车 位\u0026quot;); TimeUnit.SECONDS.sleep(2); System.out.println(Thread.currentThread().getName()+\u0026quot;离开车 位\u0026quot;); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); // release() 释放 } },String.valueOf(i)).start(); } } }  原理：  semaphore.acquire() 获得，假设如果已经满了，等待，等待被释放为止！\nsemaphore.release(); 释放，会将当前的信号量释放 + 1，然后唤醒等待的线程！ 作用： 多个共享资源互斥的使用！并发限流，控制最大的线程数！\n 9 、读写锁 ReadWriteLock\nimport java.util.HashMap; import java.util.Map; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantLock; import java.util.concurrent.locks.ReentrantReadWriteLock; /** * 独占锁（写锁） 一次只能被一个线程占有 * 共享锁（读锁） 多个线程可以同时占有 * ReadWriteLock * 读-读 可以共存！ * 读-写 不能共存！ * 写-写 不能共存！ */ public class ReadWriteLockDemo { public static void main(String[] args) { MyCache myCache = new MyCache(); // 写入 for (int i = 1; i \u0026lt;= 5 ; i++) { final int temp = i; new Thread(()-\u0026gt;{ myCache.put(temp+\u0026quot;\u0026quot;,temp+\u0026quot;\u0026quot;); },String.valueOf(i)).start(); } // 读取 for (int i = 1; i \u0026lt;= 5 ; i++) { final int temp = i; new Thread(()-\u0026gt;{ myCache.get(temp+\u0026quot;\u0026quot;); },String.valueOf(i)).start(); } } } // 加锁的 class MyCacheLock{ private volatile Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 读写锁： 更加细粒度的控制 private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); private Lock lock = new ReentrantLock(); // 存，写入的时候，只希望同时只有一个线程写 public void put(String key,Object value){ readWriteLock.writeLock().lock(); try { System.out.println(Thread.currentThread().getName()+\u0026quot;写入\u0026quot;+key); map.put(key,value); System.out.println(Thread.currentThread().getName()+\u0026quot;写入OK\u0026quot;); } catch (Exception e) { e.printStackTrace(); } finally { readWriteLock.writeLock().unlock(); } } // 取，读，所有人都可以读！ public void get(String key){ readWriteLock.readLock().lock(); try { System.out.println(Thread.currentThread().getName()+\u0026quot;读取\u0026quot;+key); Object o = map.get(key); System.out.println(Thread.currentThread().getName()+\u0026quot;读取OK\u0026quot;); } catch (Exception e) { e.printStackTrace(); } finally { readWriteLock.readLock().unlock(); } } } /** * 自定义缓存 */ class MyCache{ private volatile Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 存，写 public void put(String key,Object value){ System.out.println(Thread.currentThread().getName()+\u0026quot;写入\u0026quot;+key); map.put(key,value); System.out.println(Thread.currentThread().getName()+\u0026quot;写入OK\u0026quot;); } // 取，读 public void get(String key){ System.out.println(Thread.currentThread().getName()+\u0026quot;读取\u0026quot;+key); Object o = map.get(key); System.out.println(Thread.currentThread().getName()+\u0026quot;读取OK\u0026quot;); } }  10 、阻塞队列 阻塞队列：\nBlockingQueue BlockingQueue 不是新的东西\n什么情况下我们会使用 阻塞队列：多线程并发处理，线程池！\n学会使用队列\n添加、移除\n四组API\n方式 抛出异常 有返回值，不抛出异常 阻塞 等待 超时等待\n   方式 抛出异常 （不抛出异常）有返回值 阻塞等待 超时等待     添加 add oﬀer() put() oﬀer(,,)   移除 remove poll() take() poll(,)   检测队首元素 element peek - -    /** * 抛出异常 */ public static void test1(){ // 队列的大小 ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue\u0026lt;\u0026gt;(3); System.out.println(blockingQueue.add(\u0026quot;a\u0026quot;)); System.out.println(blockingQueue.add(\u0026quot;b\u0026quot;)); System.out.println(blockingQueue.add(\u0026quot;c\u0026quot;)); // IllegalStateException: Queue full 抛出异常！ // System.out.println(blockingQueue.add(\u0026quot;d\u0026quot;)); System.out.println(\u0026quot;=-===========\u0026quot;); System.out.println(blockingQueue.remove()); System.out.println(blockingQueue.remove()); System.out.println(blockingQueue.remove()); // java.util.NoSuchElementException 抛出异常！ // System.out.println(blockingQueue.remove()); }  /** * 有返回值，没有异常 */ public static void test2(){ // 队列的大小 ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue\u0026lt;\u0026gt;(3); System.out.println(blockingQueue.offer(\u0026quot;a\u0026quot;)); System.out.println(blockingQueue.offer(\u0026quot;b\u0026quot;)); System.out.println(blockingQueue.offer(\u0026quot;c\u0026quot;)); // System.out.println(blockingQueue.offer(\u0026quot;d\u0026quot;)); // false 不抛出异常！ System.out.println(\u0026quot;============================\u0026quot;); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); // null 不抛出异常！ }  /** * 等待，阻塞（一直阻塞） */ public static void test3() throws InterruptedException { // 队列的大小 ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue\u0026lt;\u0026gt;(3); // 一直阻塞 blockingQueue.put(\u0026quot;a\u0026quot;); blockingQueue.put(\u0026quot;b\u0026quot;); blockingQueue.put(\u0026quot;c\u0026quot;); // blockingQueue.put(\u0026quot;d\u0026quot;); // 队列没有位置了，一直阻塞 System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); // 没有这个元素，一直阻塞 }  /** * 等待，阻塞（等待超时） */ public static void test4() throws InterruptedException { // 队列的大小 ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue\u0026lt;\u0026gt;(3); blockingQueue.offer(\u0026quot;a\u0026quot;); blockingQueue.offer(\u0026quot;b\u0026quot;); blockingQueue.offer(\u0026quot;c\u0026quot;); // blockingQueue.offer(\u0026quot;d\u0026quot;,2,TimeUnit.SECONDS); // 等待超过2秒就退出 System.out.println(\u0026quot;===============\u0026quot;); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); blockingQueue.poll(2,TimeUnit.SECONDS); // 等待超过2秒就退出 }   SynchronousQueue 同步队列\n 没有容量，\n进去一个元素，必须等待取出来之后，才能再往里面放一个元素！(容量为1)\nimport java.sql.Time; import java.util.concurrent.BlockingQueue; import java.util.concurrent.SynchronousQueue; import java.util.concurrent.TimeUnit; /** * 同步队列 * 和其他的BlockingQueue 不一样， SynchronousQueue 不存储元素 * put了一个元素，必须从里面先take取出来，否则不能在put进去值！ */ public class SynchronousQueueDemo { public static void main(String[] args) { BlockingQueue\u0026lt;String\u0026gt; blockingQueue = new SynchronousQueue\u0026lt;\u0026gt;(); // 同步队列 new Thread(()-\u0026gt;{ try { System.out.println(Thread.currentThread().getName()+\u0026quot; put 1\u0026quot;); blockingQueue.put(\u0026quot;1\u0026quot;); System.out.println(Thread.currentThread().getName()+\u0026quot; put 2\u0026quot;); blockingQueue.put(\u0026quot;2\u0026quot;); System.out.println(Thread.currentThread().getName()+\u0026quot; put 3\u0026quot;); blockingQueue.put(\u0026quot;3\u0026quot;); } catch (InterruptedException e) { e.printStackTrace(); } },\u0026quot;T1\u0026quot;).start(); new Thread(()-\u0026gt;{ try { TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName()+\u0026quot;=\u0026gt;\u0026quot;+blockingQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName()+\u0026quot;=\u0026gt;\u0026quot;+blockingQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName()+\u0026quot;=\u0026gt;\u0026quot;+blockingQueue.take()); } catch (InterruptedException e) { e.printStackTrace(); } },\u0026quot;T2\u0026quot;).start(); } }  学了技术，不会用！ 看的少！\n11 、线程池(重点) 线程池：三大方法、 7 大参数、 4 种拒绝策略\n 池化技术\n 程序的运行，本质：占用系统的资源！ 优化资源的使用！=\u0026gt;池化技术\n线程池、连接池、内存池、对象池///\u0026hellip;.. 创建、销毁。十分浪费资源\n池化技术：事先准备好一些资源，有人要用，就来我这里拿，用完之后还给我。\n线程池的好处:\n1 、降低资源的消耗\n2 、提高响应的速度\n3 、方便管理。\n线程复用、可以控制最大并发数、管理线程\n 线程池：三大方法\n import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; // Executors 工具类、3大方法 public class Demo01 { public static void main(String[] args) { ExecutorService threadPool = Executors.newSingleThreadExecutor();// 单个线程 // ExecutorService threadPool = Executors.newFixedThreadPool(5); // 创建一个固定的线程池的大小 // ExecutorService threadPool = Executors.newCachedThreadPool(); // 可伸缩的，遇强则强，遇弱则弱 try { for (int i = 0; i \u0026lt; 100; i++) { // 使用了线程池之后，使用线程池来创建线程 threadPool.execute(()-\u0026gt;{ System.out.println(Thread.currentThread().getName()+\u0026quot; ok\u0026quot;); }); } } catch (Exception e) { e.printStackTrace(); } finally { // 线程池用完，程序结束，关闭线程池 threadPool.shutdown(); } } }   7 大参数\n 源码分析\npublic static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;())); } public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); } public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue\u0026lt;Runnable\u0026gt;()); } // 本质ThreadPoolExecutor（） public ThreadPoolExecutor(int corePoolSize, // 核心线程池大小 int maximumPoolSize, // 最大核心线程池大小 long keepAliveTime, // 超时了没有人调用就会释放 TimeUnit unit, // 超时单位 BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, // 阻塞队列 ThreadFactory threadFactory, // 线程工厂：创建线程的，一般不用动 RejectedExecutionHandler handle // 拒绝策略) { if (corePoolSize \u0026lt; 0 || maximumPoolSize \u0026lt;= 0 || maximumPoolSize \u0026lt; corePoolSize || keepAliveTime \u0026lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; }   手动创建一个线程池\n import java.util.concurrent.*; // Executors 工具类、3大方法 /** * new ThreadPoolExecutor.AbortPolicy() // 银行满了，还有人进来，不处理这个人的，抛出异常 * new ThreadPoolExecutor.CallerRunsPolicy() // 哪来的去哪里！ * new ThreadPoolExecutor.DiscardPolicy() //队列满了，丢掉任务，不会抛出异常！ * new ThreadPoolExecutor.DiscardOldestPolicy() //队列满了，尝试去和最早的竞争，也不会抛出异常！ */ public class Demo01 { public static void main(String[] args) { // 自定义线程池！工作 ThreadPoolExecutor ExecutorService threadPool = new ThreadPoolExecutor( 2, 5, 3, TimeUnit.SECONDS, new LinkedBlockingDeque\u0026lt;\u0026gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardOldestPolicy()); //队列满了，尝试去和 最早的竞争，也不会抛出异常！ try { // 最大承载：Deque + max // 超过 RejectedExecutionException for (int i = 1; i \u0026lt;= 9; i++) { // 使用了线程池之后，使用线程池来创建线程 threadPool.execute(()-\u0026gt;{ System.out.println(Thread.currentThread().getName()+\u0026quot; ok\u0026quot;); });   4 种拒绝策略\n /** * new ThreadPoolExecutor.AbortPolicy() // 银行满了，还有人进来，不处理这个人的，抛出异常 * new ThreadPoolExecutor.CallerRunsPolicy() // 哪来的去哪里！ * new ThreadPoolExecutor.DiscardPolicy() //队列满了，丢掉任务，不会抛出异常！ * new ThreadPoolExecutor.DiscardOldestPolicy() //队列满了，尝试去和最早的竞争，也不会抛出异常！ */   小结和拓展\n 线程池原理之七大参数和四种拒绝策略\n池的最大的大小如何去设置！\n了解：IO密集型，CPU密集型：（调优）\n什么是CPU密集型、IO密集型？\nimport java.util.concurrent.*; public class Demo01 { public static void main(String[] args) { // 自定义线程池！工作 ThreadPoolExecutor // 最大线程到底该如何定义 // 1、CPU 密集型，几核，就是几，可以保持CPu的效率最高！ // 2、IO 密集型 \u0026gt; 判断你程序中十分耗IO的线程，（大于这个线程数，一般设置为两倍） // 程序 15个大型任务 io十分占用资源！ // 获取CPU的核数 System.out.println(Runtime.getRuntime().availableProcessors()); ExecutorService threadPool = new ThreadPoolExecutor( 2, Runtime.getRuntime().availableProcessors(), 3, TimeUnit.SECONDS, new LinkedBlockingDeque\u0026lt;\u0026gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardOldestPolicy()); //队列满了，尝试去和最早的竞争，也不会抛出异常！ try { // 最大承载：Deque + max // 超过 RejectedExecutionException for (int i = 1; i \u0026lt;= 9; i++) { // 使用了线程池之后，使用线程池来创建线程 threadPool.execute(()-\u0026gt;{ System.out.println(Thread.currentThread().getName()+\u0026quot; ok\u0026quot;); }); } } catch (Exception e) { e.printStackTrace(); } finally { // 线程池用完，程序结束，关闭线程池 threadPool.shutdown(); } } }  12 、四大函数式接口（必需掌握） 新时代的程序员：lambda表达式、链式编程、函数式接口、Stream流式计算\n 函数式接口： 只有一个方法的接口\n 代码测试：  Function函数式接口\n import java.util.function.Function; /** * Function 函数型接口, 有一个输入参数，有一个输出 * 只要是 函数型接口 可以 用 lambda表达式简化 */ public class Demo01 { public static void main(String[] args) { // // Function\u0026lt;String,String\u0026gt; function = new Function\u0026lt;String,String\u0026gt;() { // @Override // public String apply(String str) { // return str; // } // }; Function\u0026lt;String,String\u0026gt; function = (str)-\u0026gt;{return str;}; System.out.println(function.apply(\u0026quot;asd\u0026quot;)); } }   断定型接口：有一个输入参数，返回值只能是 布尔值！\n import java.util.function.Predicate; /** * 断定型接口：有一个输入参数，返回值只能是 布尔值！ */ public class Demo02 { public static void main(String[] args) { // 判断字符串是否为空 // Predicate\u0026lt;String\u0026gt; predicate = new Predicate\u0026lt;String\u0026gt;(){ //// @Override //// public boolean test(String str) { //// return str.isEmpty(); //// } //// }; Predicate\u0026lt;String\u0026gt; predicate = (str)-\u0026gt;{return str.isEmpty(); }; System.out.println(predicate.test(\u0026quot;\u0026quot;)); } }   Consumer 消费型接口\n import java.util.function.Consumer; /** * Consumer 消费型接口: 只有输入，没有返回值 */ public class Demo03 { public static void main(String[] args) { // Consumer\u0026lt;String\u0026gt; consumer = new Consumer\u0026lt;String\u0026gt;() { // @Override // public void accept(String str) { // System.out.println(str); // } // }; Consumer\u0026lt;String\u0026gt; consumer = (str)-\u0026gt;{System.out.println(str);}; consumer.accept(\u0026quot;sdadasd\u0026quot;); } }   Supplier 供给型接口\n import java.util.function.Supplier; /** * Supplier 供给型接口 没有参数，只有返回值 */ public class Demo04 { public static void main(String[] args) { // Supplier supplier = new Supplier\u0026lt;Integer\u0026gt;() { // @Override // public Integer get() { // System.out.println(\u0026quot;get()\u0026quot;); // return 1024; // } // }; Supplier supplier = ()-\u0026gt;{ return 1024; }; System.out.println(supplier.get()); } }  13 、Stream流式计算  什么是Stream流式计算\n 大数据：存储 + 计算\n集合、MySQL 本质就是存储东西的；\n计算都应该交给流来操作！\nimport java.util.Arrays; import java.util.List; /** * 题目要求：一分钟内完成此题，只能用一行代码实现！ * 现在有5个用户！筛选： * 1、ID 必须是偶数 * 2、年龄必须大于23岁 * 3、用户名转为大写字母 * 4、用户名字母倒着排序 * 5、只输出一个用户！ */ public class Test { public static void main(String[] args) { User u1 = new User(1,\u0026quot;a\u0026quot;,21); User u2 = new User(2,\u0026quot;b\u0026quot;,22); User u3 = new User(3,\u0026quot;c\u0026quot;,23); User u4 = new User(4,\u0026quot;d\u0026quot;,24); User u5 = new User(6,\u0026quot;e\u0026quot;,25); // 集合就是存储 List\u0026lt;User\u0026gt; list = Arrays.asList(u1, u2, u3, u4, u5); // 计算交给Stream流 // lambda表达式、链式编程、函数式接口、Stream流式计算 list.stream() .filter(u-\u0026gt;{return u.getId()%2==0;}) .filter(u-\u0026gt;{return u.getAge()\u0026gt;23;}) .map(u-\u0026gt;{return u.getName().toUpperCase();}) .sorted((uu1,uu2)-\u0026gt;{return uu2.compareTo(uu1);}) .limit(1) .forEach(System.out::println); } }  // 有参，无参构造，get、set、toString方法！ @Data @NoArgsConstructor @AllArgsConstructor public class User { private int id; private String name; private int age; }  14 、ForkJoin  什么是 ForkJoin\n ForkJoin 在 JDK 1.7 ， 并行执行任务！提高效率。大数据量！\n大数据：Map Reduce （把大任务拆分为小任务）  ForkJoin 特点：工作窃取\n 这个里面维护的都是双端队列\n ForkJoin\n import java.util.concurrent.RecursiveTask; /** * 求和计算的任务！ * 3000 6000（ForkJoin） 9000（Stream并行流） * // 如何使用 forkjoin * // 1、forkjoinPool 通过它来执行 * // 2、计算任务 forkjoinPool.execute(ForkJoinTask task) * // 3. 计算类要继承 ForkJoinTask */ public class ForkJoinDemo extends RecursiveTask\u0026lt;Long\u0026gt; { private Long start; // 1 private Long end; // 1990900000 // 临界值 private Long temp = 10000L; public ForkJoinDemo(Long start, Long end) { this.start = start; this.end = end; } // 计算方法 @Override protected Long compute() { if ((end-start)\u0026lt;temp){ Long sum = 0L; for (Long i = start; i \u0026lt;= end; i++) { sum += i; } return sum; }else { // forkjoin 递归 long middle = (start + end) / 2; // 中间值 ForkJoinDemo task1 = new ForkJoinDemo(start, middle); task1.fork(); // 拆分任务，把任务压入线程队列 ForkJoinDemo task2 = new ForkJoinDemo(middle+1, end); task2.fork(); // 拆分任务，把任务压入线程队列 return task1.join() + task2.join(); } } }  测试：\nimport java.util.concurrent.ExecutionException; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.ForkJoinTask; import java.util.stream.DoubleStream; import java.util.stream.IntStream; import java.util.stream.LongStream; /** * 同一个任务，别人效率高你几十倍！ */ public class Test { public static void main(String[] args) throws ExecutionException,InterruptedException { // test1(); // 12224 // test2(); // 10038 // test3(); // 153 } // 普通程序员 public static void test1(){ Long sum = 0L; long start = System.currentTimeMillis(); for (Long i = 1L; i \u0026lt;= 10_0000_0000; i++) { sum += i; } long end = System.currentTimeMillis(); System.out.println(\u0026quot;sum=\u0026quot;+sum+\u0026quot; 时间：\u0026quot;+(end-start)); } // 会使用ForkJoin public static void test2() throws ExecutionException, InterruptedException { long start = System.currentTimeMillis(); ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinTask\u0026lt;Long\u0026gt; task = new ForkJoinDemo(0L, 10_0000_0000L); ForkJoinTask\u0026lt;Long\u0026gt; submit = forkJoinPool.submit(task);// 提交任务 Long sum = submit.get(); long end = System.currentTimeMillis(); System.out.println(\u0026quot;sum=\u0026quot;+sum+\u0026quot; 时间：\u0026quot;+(end-start)); } public static void test3(){ long start = System.currentTimeMillis(); // Stream并行流 () (] long sum = LongStream.rangeClosed(0L,10_0000_0000L).parallel().reduce(0, Long::sum); long end = System.currentTimeMillis(); System.out.println(\u0026quot;sum=\u0026quot;+\u0026quot;时间：\u0026quot;+(end-start)); } }  15 、异步回调  Future 设计的初衷： 对将来的某个事件的结果进行建模\n import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; /** * 异步调用： CompletableFuture * // 异步执行 * // 成功回调 * // 失败回调 */ public class Demo01 { public static void main(String[] args) throws ExecutionException, InterruptedException { // 没有返回值的 runAsync 异步回调 // CompletableFuture\u0026lt;Void\u0026gt; completableFuture = CompletableFuture.runAsync(()-\u0026gt;{ // try { // TimeUnit.SECONDS.sleep(2); // } catch (InterruptedException e) { // e.printStackTrace(); // } // System.out.println(Thread.currentThread().getName()+\u0026quot;runAsync=\u0026gt;Void\u0026quot;); // }); // // System.out.println(\u0026quot;1111\u0026quot;); // // completableFuture.get(); // 获取阻塞执行结果 // 有返回值的 supplyAsync 异步回调 // ajax，成功和失败的回调 // 返回的是错误信息； CompletableFuture\u0026lt;Integer\u0026gt; completableFuture = CompletableFuture.supplyAsync(()-\u0026gt;{ System.out.println(Thread.currentThread().getName()+\u0026quot;supplyAsync=\u0026gt;Integer\u0026quot;); int i = 10/0; return 1024; }); System.out.println(completableFuture.whenComplete((t, u) -\u0026gt; { System.out.println(\u0026quot;t=\u0026gt;\u0026quot; + t); // 正常的返回结果 System.out.println(\u0026quot;u=\u0026gt;\u0026quot; + u); // 错误信息：java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero }).exceptionally((e) -\u0026gt; { System.out.println(e.getMessage()); return 233; // 可以获取到错误的返回结果 }).get()); /** * succee Code 200 * error Code 404 500 */ } }  16 、JMM jmm:java内存模型（java memory model）\n 请你谈谈你对 Volatile 的理解\n Volatile 是 Java 虚拟机提供 轻量级的同步机制(synchronized)\n1 、保证可见性\n2 、不保证原子性\n3 、禁止指令重排\n 什么是JMM\n JMM ： Java内存模型，不存在的东西，概念！约定！\n关于JMM的一些同步的约定： 1 、线程解锁前，必须把共享变量 立刻 刷回主存。\n2 、线程加锁前，必须读取主存中的最新值到工作内存中！\n3 、加锁和解锁是同一把锁\n线程 工作内存 、 主内存\njmm8 种操作：\n内存交互操作有 8 种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类 型的变量来说，load、store、read和write操作在某些平台上允许例外）\n  lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态 unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量 才可以被其他线程锁定 read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便 随后的load动作使用 load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中 use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机 遇到一个需要使用到变量的值，就会使用到这个指令 assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变 量副本中 store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中， 以便后续的write使用 write （写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内 存的变量中   JMM对这八种指令的使用，制定了如下规则：\n  不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须 write 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存 不允许一个线程将没有assign的数据从工作内存同步回主内存 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量 对一个变量进行unlock操作之前，必须把此变量同步回主内存   问题： 程序不知道主内存的值已经被修改过了\n17 、Volatile  1 、保证可见性\n import java.util.concurrent.TimeUnit; public class JMMDemo { // 不加 volatile 程序就会死循环！ // 加 volatile 可以保证可见性 private volatile static int num = 0; public static void main(String[] args) { // main new Thread(()-\u0026gt;{ // 线程 1 对主内存的变化不知道的 while (num==0){ } }).start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } num = 1; System.out.println(num); } }  2 、不保证原子性（acid原则）\n原子性 : 不可分割\n线程A在执行任务的时候，不能被打扰的，也不能被分割。要么同时成功，要么同时失败。\n// volatile 不保证原子性 public class VDemo02 { // volatile 不保证原子性 synchronized可以保证 private volatile static int num = 0; public static void add(){ num++; } public static void main(String[] args) { //理论上num结果应该为 2 万 for (int i = 1; i \u0026lt;= 20; i++) { new Thread(()-\u0026gt;{ for (int j = 0; j \u0026lt; 1000 ; j++) { add(); } }).start(); } while (Thread.activeCount()\u0026gt;2){ // main gc Thread.yield(); } System.out.println(Thread.currentThread().getName() + \u0026quot; \u0026quot; + num); } }  如果不加 lock 和 synchronized ，怎么样保证原子性\n使用原子类，解决 原子性问题\nimport java.util.concurrent.atomic.AtomicInteger; // volatile 不保证原子性 public class VDemo02 { // volatile 不保证原子性 // 原子类的 Integer private volatile static AtomicInteger num = new AtomicInteger(); public static void add(){ // num++; // 不是一个原子性操作 num.getAndIncrement(); // AtomicInteger + 1 方法， CAS } public static void main(String[] args) { //理论上num结果应该为 2 万 for (int i = 1; i \u0026lt;= 20; i++) { new Thread(()-\u0026gt;{ for (int j = 0; j \u0026lt; 1000 ; j++) { add(); } }).start(); } while (Thread.activeCount()\u0026gt;2){ // main gc Thread.yield(); } System.out.println(Thread.currentThread().getName() + \u0026quot; \u0026quot; + num); } }  这些类的底层都直接和操作系统挂钩！在内存中修改值！Unsafe类是一个很特殊的存在！\n 指令重排\n 什么是 指令重排： 你写的程序，计算机并不是按照你写的那样去执行的。\n源代码\u0026ndash;\u0026gt;编译器优化的重排\u0026ndash;\u0026gt; 指令并行也可能会重排\u0026ndash;\u0026gt; 内存系统也会重排\u0026mdash;\u0026gt; 执行\n处理器在进行指令重排的时候，考虑：数据之间的依赖性！\nint x = 1; // 1 int y = 2; // 2 x = x + 5; // 3 y = x * x; // 4 我们所期望的：1234 但是可能执行的时候回变成 2134 1324 可不可能是 4123！  可能造成影响的结果： a b x y 这四个值默认都是 0 ；\n   线程A 线程B     x=a y=b   b=1 a=2    正常的结果： x = 0；y = 0；但是可能由于指令重排\n   线程A 线程B     b=1 a=2   x=a y=b    指令重排导致的诡异结果： x = 2；y = 1；\n 非计算机专业\n volatile可以避免指令重排：\n内存屏障。CPU指令。作用：\n1 、保证特定的操作的执行顺序！\n2 、可以保证某些变量的内存可见性 （利用这些特性volatile实现了可见性）\nVolatile 是可以保持 可见性。不能保证原子性，由于内存屏障，可以保证避免指令重排的现象产生！\n18 、彻底玩转单例模式 饿汉式 DCL懒汉式，深究！\n 饿汉式\n // 饿汉式单例 public class Hungry { // 可能会浪费空间 /* private byte[] data1 = new byte[1024*1024]; private byte[] data2 = new byte[1024*1024]; private byte[] data3 = new byte[1024*1024]; private byte[] data4 = new byte[1024*1024];*/ //单例模式最重要的思想就是构造器私有化 private Hungry(){ } //不管三七二十一上来就先new一个对象 private final static Hungry HUNGRY = new Hungry(); public static Hungry getInstance(){ return HUNGRY; } }   DCL 懒汉式\n import com.sun.corba.se.impl.orbutil.CorbaResourceUtil; import java.lang.reflect.Constructor; import java.lang.reflect.Field; // 懒汉式单例DCL // 道高一尺，魔高一丈！ public class LazyMan { private LazyMan(){ System.out.println(Thread.currentThread().getName()+\u0026quot;Ok\u0026quot;); } private static LazyMan lazyMan; public static LazyMan getInstance(){ if (lazyMan==null){ lazyMan = new LazyMan(); // 不是一个原子性操作 } return lazyMan; } //单线程下确实单例ok，但是在多线程下会出错 public static void main(String args[]){ for(int i=0;i\u0026lt;10;i++){ new Thread(()-\u0026gt;{ LazyMan.getInstance(); }).start(); } } }  加锁\nimport com.sun.corba.se.impl.orbutil.CorbaResourceUtil; import java.lang.reflect.Constructor; import java.lang.reflect.Field; // 懒汉式单例DCL // 道高一尺，魔高一丈！ public class LazyMan { private LazyMan(){ System.out.println(Thread.currentThread().getName()+\u0026quot;Ok\u0026quot;); } private static LazyMan lazyMan; // 双重检测锁模式的 懒汉式单例 DCL懒汉式 public static LazyMan getInstance(){ if (lazyMan==null){//第一层加测 synchronized (LazyMan.class){//锁 if (lazyMan==null){//第二层检测 lazyMan = new LazyMan(); // 不是一个原子性操作 } } } return lazyMan; } //这样的话理论上是没有什么问题的，但是有可能会出现问题 lazyMan = new LazyMan();不是原子性操作 /** * 1. 分配内存空间 * 2、执行构造方法，初始化对象 * 3、把这个对象指向这个空间 * 会发生指令重排现象 * 123 * 132 A * B // 此时lazyMan还没有完成构造 因此需要加 volatile */ public static void main(String args[]){ for(int i=0;i\u0026lt;10;i++){ new Thread(()-\u0026gt;{ LazyMan.getInstance(); }).start(); } } }  真正的DCL\nimport com.sun.corba.se.impl.orbutil.CorbaResourceUtil; import java.lang.reflect.Constructor; import java.lang.reflect.Field; // 懒汉式单例DCL // 道高一尺，魔高一丈！ public class LazyMan { private LazyMan(){ System.out.println(Thread.currentThread().getName()+\u0026quot;Ok\u0026quot;); } //加锁防止new的时候发生指令重排的现象 private volatile static LazyMan lazyMan; // 双重检测锁模式的 懒汉式单例 DCL懒汉式 public static LazyMan getInstance(){ if (lazyMan==null){//第一层加测 synchronized (LazyMan.class){//锁 if (lazyMan==null){//第二层检测 lazyMan = new LazyMan(); // 不是一个原子性操作 } } } return lazyMan; } //这样的话理论上是没有什么问题的，但是有可能会出现问题 lazyMan = new LazyMan();不是原子性操作 /** * 1. 分配内存空间 * 2、执行构造方法，初始化对象 * 3、把这个对象指向这个空间 * 会发生指令重排现象 * 123 * 132 A * B // 此时lazyMan还没有完成构造 因此需要加 volatile */ public static void main(String args[]){ for(int i=0;i\u0026lt;10;i++){ new Thread(()-\u0026gt;{ LazyMan.getInstance(); }).start(); } } }   静态内部类\n // 静态内部类 public class Holder { private Holder(){ } public static Holder getInstace(){ return InnerClass.HOLDER; } public static class InnerClass{ private static final Holder HOLDER = new Holder(); } }  但是者三种方法在反射面前都是不安全的\nimport com.sun.corba.se.impl.orbutil.CorbaResourceUtil; import java.lang.reflect.Constructor; import java.lang.reflect.Field; // 懒汉式单例DCL // 道高一尺，魔高一丈！ public class LazyMan { private LazyMan(){ System.out.println(Thread.currentThread().getName()+\u0026quot;Ok\u0026quot;); } private volatile static LazyMan lazyMan; // 双重检测锁模式的 懒汉式单例 DCL懒汉式 public static LazyMan getInstance(){ if (lazyMan==null){ synchronized (LazyMan.class){ if (lazyMan==null){ lazyMan = new LazyMan(); // 不是一个原子性操作 } } } return lazyMan; } // 反射！ public static void main(String[] args) throws Exception { LazyMan instance = LazyMan.getInstance(); Constructor\u0026lt;LazyMan\u0026gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null);//获取空参构造器 declaredConstructor.setAccessible(true); LazyMan instance2 = declaredConstructor.newInstance(); System.out.println(instance); System.out.println(instance2); } } //可以发现这两个对象不是同一个对象  解决：在构造器在判断一次\n三重检测：可以避免某一种反射的破坏\nimport com.sun.corba.se.impl.orbutil.CorbaResourceUtil; import java.lang.reflect.Constructor; import java.lang.reflect.Field; // 懒汉式单例DCL // 道高一尺，魔高一丈！ public class LazyMan { private LazyMan(){ synchronized (LazyMan.class){ if (lazyMan != null){ throw new RuntimeException(\u0026quot;不要试图使用反射破坏异常\u0026quot;); } } } private volatile static LazyMan lazyMan; // 双重检测锁模式的 懒汉式单例 DCL懒汉式 public static LazyMan getInstance(){ if (lazyMan==null){ synchronized (LazyMan.class){ if (lazyMan==null){ lazyMan = new LazyMan(); // 不是一个原子性操作 } } } return lazyMan; } // 反射！ public static void main(String[] args) throws Exception { LazyMan instance = LazyMan.getInstance(); Constructor\u0026lt;LazyMan\u0026gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null);//获取空参构造器 declaredConstructor.setAccessible(true); LazyMan instance2 = declaredConstructor.newInstance(); System.out.println(instance); System.out.println(instance2); } }  在我们两个对象都是使用反射获取的时候又会发生错误\nimport com.sun.corba.se.impl.orbutil.CorbaResourceUtil; import java.lang.reflect.Constructor; import java.lang.reflect.Field; // 懒汉式单例DCL // 道高一尺，魔高一丈！ public class LazyMan { private LazyMan(){ synchronized (LazyMan.class){ if (lazyMan != null){ throw new RuntimeException(\u0026quot;不要试图使用反射破坏异常\u0026quot;); } } } private volatile static LazyMan lazyMan; // 双重检测锁模式的 懒汉式单例 DCL懒汉式 public static LazyMan getInstance(){ if (lazyMan==null){ synchronized (LazyMan.class){ if (lazyMan==null){ lazyMan = new LazyMan(); // 不是一个原子性操作 } } } return lazyMan; } // 反射！ public static void main(String[] args) throws Exception { Constructor\u0026lt;LazyMan\u0026gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null);//获取空参构造器 declaredConstructor.setAccessible(true); LazyMan instance = declaredConstructor.newInstance(); LazyMan instance2 = declaredConstructor.newInstance(); System.out.println(instance); System.out.println(instance2); } }  解决：红绿灯\n可以定义一个变量（可以进行加密）qinjiang进行处理，如果不通过反编译的话，它是找不到qinjiang这个关键字的\nimport com.sun.corba.se.impl.orbutil.CorbaResourceUtil; import java.lang.reflect.Constructor; import java.lang.reflect.Field; // 懒汉式单例DCL // 道高一尺，魔高一丈！ public class LazyMan { private static boolean qinjiang = false; private LazyMan(){ synchronized (LazyMan.class){ if (qinjiang == false){ qinjiang = true; }else { throw new RuntimeException(\u0026quot;不要试图使用反射破坏异常\u0026quot;); } } } private volatile static LazyMan lazyMan; // 双重检测锁模式的 懒汉式单例 DCL懒汉式 public static LazyMan getInstance(){ if (lazyMan==null){ synchronized (LazyMan.class){ if (lazyMan==null){ lazyMan = new LazyMan(); // 不是一个原子性操作 } } } return lazyMan; } // 反射！ public static void main(String[] args) throws Exception { Constructor\u0026lt;LazyMan\u0026gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null);//获取空参构造器 declaredConstructor.setAccessible(true); LazyMan instance = declaredConstructor.newInstance(); LazyMan instance2 = declaredConstructor.newInstance(); System.out.println(instance); System.out.println(instance2); } }  再破坏一下，通过反射可以获取变量qinjiang，通过反射修改这个值\n这样的话反射又被破坏了\nimport com.sun.corba.se.impl.orbutil.CorbaResourceUtil; import java.lang.reflect.Constructor; import java.lang.reflect.Field; // 懒汉式单例DCL // 道高一尺，魔高一丈！ public class LazyMan { private static boolean qinjiang = false; private LazyMan(){ synchronized (LazyMan.class){ if (qinjiang == false){ qinjiang = true; }else { throw new RuntimeException(\u0026quot;不要试图使用反射破坏异常\u0026quot;); } } } private volatile static LazyMan lazyMan; // 双重检测锁模式的 懒汉式单例 DCL懒汉式 public static LazyMan getInstance(){ if (lazyMan==null){ synchronized (LazyMan.class){ if (lazyMan==null){ lazyMan = new LazyMan(); // 不是一个原子性操作 } } } return lazyMan; } // 反射！ public static void main(String[] args) throws Exception { // LazyMan instance = LazyMan.getInstance(); Field qinjiang = LazyMan.class.getDeclaredField(\u0026quot;qinjiang\u0026quot;); qinjiang.setAccessible(true); Constructor\u0026lt;LazyMan\u0026gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null);//获取空参构造器 declaredConstructor.setAccessible(true); LazyMan instance = declaredConstructor.newInstance(); qinjiang.set(instance,false); LazyMan instance2 = declaredConstructor.newInstance(); System.out.println(instance); System.out.println(instance2); } } /** * 1. 分配内存空间 * 2、执行构造方法，初始化对象 * 3、把这个对象指向这个空间 * * 123 * 132 A * B // 此时lazyMan还没有完成构造 */  究极解决办法使用枚举\n 单例不安全，反射\n枚举\n 我们观察反射newInstance的方法\n@CallerSensitive public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { if (!override) { if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) { Class\u0026lt;?\u0026gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, null, modifiers); } } if ((clazz.getModifiers() \u0026amp; Modifier.ENUM) != 0) throw new IllegalArgumentException(\u0026quot;Cannot reflectively create enum objects\u0026quot;); ConstructorAccessor ca = constructorAccessor; // read volatile if (ca == null) { ca = acquireConstructorAccessor(); } @SuppressWarnings(\u0026quot;unchecked\u0026quot;) T inst = (T) ca.newInstance(initargs); return inst; }  可以发现这里有一个会抛出一个枚举的异常（不能使用反射破坏枚举），所以我们有了一个解决的思路\nimport java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; // enum 是一个什么？ 本身也是一个Class类 public enum EnumSingle { INSTANCE; public EnumSingle getInstance(){ return INSTANCE; } } class Test{ public static void main(String[] args){ EnumSingle instance1 = EnumSingle.INSTANCE; EnumSingle instance2 = EnumSingle.INSTANCE; System.out.println(instance1); System.out.println(instance2); } } //结果发现这两个对象肯定是一致的  我们说反射不能破坏枚举，这里我们尝试使用反射破坏枚举\n通过class文件分析源码时有参构造还是无参构造：发现\nimport java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; // enum 是一个什么？ 本身也是一个Class类 public enum EnumSingle { INSTANCE; public EnumSingle getInstance(){ return INSTANCE; } } class Test{ public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { EnumSingle instance1 = EnumSingle.INSTANCE; Constructor\u0026lt;EnumSingle\u0026gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(null); declaredConstructor.setAccessible(true); EnumSingle instance2 = declaredConstructor.newInstance(); // NoSuchMethodException: com.kuang.single.EnumSingle.\u0026lt;init\u0026gt;() System.out.println(instance1); System.out.println(instance2); } }  结果发现此时抛出的异常和我们预想的异常不一样（枚举类中没有这样一个空参的构造方法）：idea欺骗了我们\n然后我们去反编译这个类看一下源码\njavap -p EnumSingle.class  但是我们发现这个代码中也有一个空参的构造方法，此时的我们就有点蒙，这个源码也欺骗了我们(因为程序执行的结果告诉我们它确实没有无参构造函数，运行的结果时不能欺骗我们的)\n这样的话，我们就需要一个更专业的软件jad.exe\n将jas.exe放到class文件目录\njad -sjava EnumSingle.class  得到源码文件\n枚举类型的最终反编译源码：\n// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov. // Jad home page: http://www.kpdus.com/jad.html // Decompiler options: packimports(3) // Source File Name: EnumSingle.java package com.kuang.single; public final class EnumSingle extends Enum { public static EnumSingle[] values() { return (EnumSingle[])$VALUES.clone(); } public static EnumSingle valueOf(String name) { return (EnumSingle)Enum.valueOf(com/kuang/single/EnumSingle, name); } private EnumSingle(String s, int i) { super(s, i); } public EnumSingle getInstance() { return INSTANCE; } public static final EnumSingle INSTANCE; private static final EnumSingle $VALUES[]; static { INSTANCE = new EnumSingle(\u0026quot;INSTANCE\u0026quot;, 0); $VALUES = (new EnumSingle[] { INSTANCE }); } }  枚举类本身就是一个class，只不过是继承了Enum类\n我们发现它确实有一个有参构造器(String ,int)\npackage com.kuang.single; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; // enum 是一个什么？ 本身也是一个Class类 public enum EnumSingle { INSTANCE; public EnumSingle getInstance(){ return INSTANCE; } } class Test{ public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { EnumSingle instance1 = EnumSingle.INSTANCE; Constructor\u0026lt;EnumSingle\u0026gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class,int.class);//一定不要写成Integer declaredConstructor.setAccessible(true); EnumSingle instance2 = declaredConstructor.newInstance(); // NoSuchMethodException: com.kuang.single.EnumSingle.\u0026lt;init\u0026gt;() System.out.println(instance1); System.out.println(instance2); } }  此时确实抛出了反射中异常\n19 、深入理解CAS  什么是 CAS\n 大厂你必须要深入研究底层！有所突破！ 修内功，操作系统，计算机网络原理\nimport java.util.concurrent.atomic.AtomicInteger; public class CASDemo { // CAS compareAndSet : 比较并交换！ public static void main(String[] args) { AtomicInteger atomicInteger = new AtomicInteger(2020); // 期望、更新 // public final boolean compareAndSet(int expect, int update) // 如果我期望的值达到了，那么就更新，否则，就不更新, CAS 是CPU的并发原语！ System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); atomicInteger.getAndIncrement() System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); } }   Unsafe 类\n 操作内存\n如果var1对象的内存地址偏移值var2还是我们期望的var5,我们就把var5+偏移量var4(1)\n CAS ： 比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就 一直循环！\n 缺点：\n1 、 循环会耗时\n2 、一次性只能保证一个共享变量的原子性\n3 、ABA问题\n CAS ： ABA 问题（狸猫换太子）\n 其中一个线程将A=1改为了A=3,又将A=3改为了A=1\nimport java.util.concurrent.atomic.AtomicInteger; public class CASDemo { // CAS compareAndSet : 比较并交换！ public static void main(String[] args) { AtomicInteger atomicInteger = new AtomicInteger(2020); // 期望、更新 // public final boolean compareAndSet(int expect, int update) // 如果我期望的值达到了，那么就更新，否则，就不更新, CAS 是CPU的并发原语！ // ============== 捣乱的线程 ================== System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(2021, 2020)); System.out.println(atomicInteger.get()); // ============== 期望的线程 ================== System.out.println(atomicInteger.compareAndSet(2020, 6666)); System.out.println(atomicInteger.get()); } }  20 、原子引用  解决ABA 问题，引入原子引用！ 对应的思想：乐观锁！\n 带版本号 的原子操作！\npackage com.kuang.cas; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicStampedReference; public class CASDemo { //AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题 // 正常在业务操作，这里面比较的都是一个个对象 static AtomicStampedReference\u0026lt;Integer\u0026gt; atomicStampedReference = new AtomicStampedReference\u0026lt;\u0026gt;(1,1); // CAS compareAndSet : 比较并交换！ public static void main(String[] args) { new Thread(()-\u0026gt;{ int stamp = atomicStampedReference.getStamp(); // 获得版本号 System.out.println(\u0026quot;a1=\u0026gt;\u0026quot;+stamp); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } atomicStampedReference.compareAndSet(1, 2, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1); System.out.println(\u0026quot;a2=\u0026gt;\u0026quot;+atomicStampedReference.getStamp()); System.out.println(atomicStampedReference.compareAndSet(2, 1, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1)); System.out.println(\u0026quot;a3=\u0026gt;\u0026quot;+atomicStampedReference.getStamp()); },\u0026quot;a\u0026quot;).start(); // 乐观锁的原理相同！ new Thread(()-\u0026gt;{ int stamp = atomicStampedReference.getStamp(); // 获得版本号 System.out.println(\u0026quot;b1=\u0026gt;\u0026quot;+stamp); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(atomicStampedReference.compareAndSet(1, 6,stamp, stamp + 1)); System.out.println(\u0026quot;b2=\u0026gt;\u0026quot;+atomicStampedReference.getStamp()); },\u0026quot;b\u0026quot;).start(); } }  注意：\nInteger 使用了对象缓存机制，默认范围是 -128 ~ 127 ，推荐使用静态工厂方法 valueOf 获取对象实 例，而不是 new，因为 valueOf 使用缓存，而 new 一定会创建新的对象分配新的内存空间；\n21 、各种锁的理解 1 、公平锁、非公平锁 公平锁： 非常公平， 不能够插队，必须先来后到！\n非公平锁：非常不公平，可以插队 （默认都是非公平）\nLock lock =new ReentrantLock();//默认就是非公平锁 public ReentrantLock() { sync = new NonfairSync(); } Lock lock =new ReentrantLock(true);//使用公平锁 public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); }  2 、可重入锁 可重入锁（递归锁）\n Synchronized\n import javax.sound.midi.Soundbank; // Synchronized public class Demo01 { public static void main(String[] args) { Phone phone = new Phone(); new Thread(()-\u0026gt;{ phone.sms(); },\u0026quot;A\u0026quot;).start(); new Thread(()-\u0026gt;{ phone.sms(); },\u0026quot;B\u0026quot;).start(); } } class Phone{ public synchronized void sms(){ System.out.println(Thread.currentThread().getName() + \u0026quot;sms\u0026quot;); call(); // 这里也有锁 } public synchronized void call(){ System.out.println(Thread.currentThread().getName() + \u0026quot;call\u0026quot;); } }   Lock 版\n import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class Demo02 { public static void main(String[] args) { Phone2 phone = new Phone2(); new Thread(()-\u0026gt;{ phone.sms(); },\u0026quot;A\u0026quot;).start(); new Thread(()-\u0026gt;{ phone.sms(); },\u0026quot;B\u0026quot;).start(); } } class Phone2{ Lock lock = new ReentrantLock(); public void sms(){ lock.lock(); // 细节问题：lock.lock(); lock.unlock(); // lock 锁必须配对，否则就会死在里面 lock.lock(); try { System.out.println(Thread.currentThread().getName() + \u0026quot;sms\u0026quot;); call(); // 这里也有锁 } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); lock.unlock(); } } public void call(){ lock.lock(); try { System.out.println(Thread.currentThread().getName() + \u0026quot;call\u0026quot;); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } }  3 、自旋锁 spinlock\n我们来自定义一个锁测试\nimport java.util.concurrent.atomic.AtomicReference; /** * 自旋锁 */ public class SpinlockDemo { // int 0 // Thread null AtomicReference\u0026lt;Thread\u0026gt; atomicReference = new AtomicReference\u0026lt;\u0026gt;(); // 加锁 public void myLock(){ Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + \u0026quot;==\u0026gt; mylock\u0026quot;); // 自旋锁 while (!atomicReference.compareAndSet(null,thread)){ } } // 解锁 // 加锁 public void myUnLock(){ Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + \u0026quot;==\u0026gt; myUnlock\u0026quot;); atomicReference.compareAndSet(thread,null); } }  测试\nimport java.util.concurrent.TimeUnit; import java.util.concurrent.locks.ReentrantLock; public class TestSpinLock { public static void main(String[] args) throws InterruptedException { // ReentrantLock reentrantLock = new ReentrantLock(); // reentrantLock.lock(); // reentrantLock.unlock(); // 底层使用的自旋锁CAS SpinlockDemo lock = new SpinlockDemo(); new Thread(()-\u0026gt; { lock.myLock(); try { TimeUnit.SECONDS.sleep(5); } catch (Exception e) { e.printStackTrace(); } finally { lock.myUnLock(); } },\u0026quot;T1\u0026quot;).start(); TimeUnit.SECONDS.sleep(1); new Thread(()-\u0026gt; { lock.myLock(); try { TimeUnit.SECONDS.sleep(1); } catch (Exception e) { e.printStackTrace(); } finally { lock.myUnLock(); } },\u0026quot;T2\u0026quot;).start(); } }  4 、死锁  死锁是什么\n 死锁测试，怎么排除死锁：\nimport com.sun.org.apache.xpath.internal.SourceTree; import java.util.concurrent.TimeUnit; public class DeadLockDemo { public static void main(String[] args) { String lockA = \u0026quot;lockA\u0026quot;; String lockB = \u0026quot;lockB\u0026quot;; new Thread(new MyThread(lockA, lockB), \u0026quot;T1\u0026quot;).start(); new Thread(new MyThread(lockB, lockA), \u0026quot;T2\u0026quot;).start(); } } class MyThread implements Runnable{ private String lockA; private String lockB; public MyThread(String lockA, String lockB) { this.lockA = lockA; this.lockB = lockB; } @Override public void run() { synchronized (lockA){ System.out.println(Thread.currentThread().getName() + \u0026quot;lock:\u0026quot;+lockA+\u0026quot;=\u0026gt;get\u0026quot;+lockB); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (lockB){ System.out.println(Thread.currentThread().getName() + \u0026quot;lock:\u0026quot;+lockB+\u0026quot;=\u0026gt;get\u0026quot;+lockA); } } } }  解决问题\n1 、使用 jps -l 定位进程号\n2 、使用 jstack 进程号 找到死锁问题\n面试，工作中！ 排查问题：\n1 、日志 9\n2 、堆栈 1\n","id":7,"section":"posts","summary":"JUC 1 、什么是JUC java.util 工具包、包、分类 业务：普通的线程代码 Thread Runnable 没有返回值、效率相比入 Callable 相对较低！ 2 、线程和进程 线程、进程，如果不能使用一句话说","tags":["Java","Java并发编程"],"title":"Java并发编程JUC","uri":"https://mumulx.github.io/2020/05/juc/","year":"2020"},{"content":" 1.概览 1.1 预备知识  希望你不是一个初学者\n线程安全问题，需要你接触过 Java Web 开发、Jdbc 开发、Web 服务器、分布式框架时才会遇到 基于 JDK 8，最好对函数式编程、lambda 有一定了解 采用了 slf4j 打印日志，这是好的实践 采用了 lombok 简化 java bean 编写 给每个线程好名字，这也是一项好的实践\n pom.xml 依赖如下\n\u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  logback.xml 配置如下\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;configuration xmlns=\u0026quot;http://ch.qos.logback/xml/ns/logback\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://ch.qos.logback/xml/ns/logback logback.xsd\u0026quot;\u0026gt; \u0026lt;appender name=\u0026quot;STDOUT\u0026quot; class=\u0026quot;ch.qos.logback.core.ConsoleAppender\u0026quot;\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;pattern\u0026gt;%date{HH:mm:ss} [%t] %logger - %m%n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;logger name=\u0026quot;c\u0026quot; level=\u0026quot;debug\u0026quot; additivity=\u0026quot;false\u0026quot;\u0026gt; \u0026lt;appender-ref ref=\u0026quot;STDOUT\u0026quot;/\u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;root level=\u0026quot;ERROR\u0026quot;\u0026gt; \u0026lt;appender-ref ref=\u0026quot;STDOUT\u0026quot;/\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/configuration\u0026gt;  2. 进程与线程 本章内容\n 进程和线程的概念\n并行和并发的概念\n线程基本应用\n 2.1 进程与线程 进程\n 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、 360 安全卫士等）  线程\n 一个进程之内可以分为一到多个线程。 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器  二者对比  进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间等，供其内部的线程共享 进程间通信较为复杂  同一台计算机的进程通信称为 IPC（Inter-process communication） 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP  线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低  2.2 并行与并发 单核 cpu 下，线程实际还是 串行执行 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是 同时运行的 。总结为一句话就是：微观串行，宏观并行，\n一般会将这种 线程轮流使用 CPU 的做法称为并发：concurrent\n   CPU 时间片1 时间片2 时间片3 时间片4     core 线程1 线程2 线程3 线程4    java并发\n多核 cpu下，每个 核（core）都可以调度运行线程，这时候线程可以是并行的。\n   CPU 时间片 1 时间片 2 时间片 3 时间片 4     core 1 线程 1 线程 1 线程 3 线程 3   core 2 线程2 线程4 线程2 线程4    引用 Rob Pike 的一段描述：\n 并发（concurrent）是同一时间应对（dealing with）多件事情的能力 并行（parallel）是同一时间动手做（doing）多件事情的能力  例子\n 家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发 家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一 个人用锅时，另一个人就得等待）\n雇了 3 个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行\n Rob Pike 资料\n golang 语言的创造者 Rob Pike - 百度百科  2.3 应用 * 应用之异步调用（案例 1 ） 应用之异步调用（案例 1 ）\n以调用方角度来讲，如果\n 需要等待结果返回，才能继续运行就是同步\n 不需要等待结果返回，就能继续运行就是异步\n  1) 设计 多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停\u0026hellip;\n2) 结论  比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程\n tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程\n ui 程序中，开线程进行其他操作，避免阻塞 ui 线程\n  应用之提高效率（案例 1 ） 应用之提高效率（案例 1 ）\n充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。\n计算 1 花费 10 ms 计算 2 花费 11 ms 计算 3 花费 9 ms 汇总需要 1 ms  如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms 但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1 ，线程 2 执行计算 2 ，线程 3 执行计算 3 ，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms 最后加上汇总时间只会花费 12ms\n注意\n需要在多核 cpu 才能提高效率，单核仍然时是轮流执行\n结论\n 单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活 多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】） 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义 IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化  3. Java 线程 本章内容\n 创建和运行线程 查看线程 线程 API 线程状态  3.1 创建和运行线程 java默认有两个线程（主线程Main线程和GC垃圾回收线程）\n方法一，直接使用 Thread 创建线程，启动线程\n// 创建线程对象 Thread t = new Thread() { public void run() { // 要执行的任务 } }; // 启动线程 t.start();  例如：\n// 构造方法的参数是给线程指定名字，推荐 Thread t1 = new Thread(\u0026quot;t1\u0026quot;) { @Override // run 方法内实现了要执行的任务 public void run() { log.debug(\u0026quot;hello\u0026quot;); } }; t1.start();  方法二，使用 Runnable 配合 Thread 把【线程】和【任务】（要执行的代码）分开\n Thread 代表线程 Runnable 可运行的任务（线程要执行的代码）\n// 创建任务对象 Runnable task2 = new Runnable() { @Override public void run() { log.debug(\u0026quot;hello\u0026quot;); } }; // 参数1 是任务对象; 参数2 是线程名字，推荐 Thread t2 = new Thread(task2, \u0026quot;t2\u0026quot;); t2.start();   Java 8 以后可以使用 lambda 精简代码\n// 创建任务对象 Runnable task2 = () -\u0026gt; log.debug(\u0026quot;hello\u0026quot;); // 参数1 是任务对象; 参数2 是线程名字，推荐 Thread t2 = new Thread(task2, \u0026quot;t2\u0026quot;); t2.start();   *原理之 Thread 与 Runnable 的关系  分析 Thread 的源码，理清它与 Runnable 的关系\nThread t = new Thread(()-\u0026gt;{ log.debug(\u0026quot;running\u0026quot;); }, \u0026quot;t2\u0026quot;); //会去调用 public Thread(Runnable target, String name) { init(null, target, name, 0); } private void init(ThreadGroup g, Runnable target, String name,long stackSize) { init(g, target, name, stackSize, null); } private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc) { //...... this.target = target;//在这对target进行赋值 //......... } //在run的时候使用了target成员变量 @Override public void run() { if (target != null) {//如果不为空则调用runnable的run方法 target.run(); } }  (java中提倡组合优先于继承)\n小结\n 方法 1 是把线程和任务合并在了一起，方法 2 是把线程和任务分开了 用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活  方法三，FutureTask 配合 Thread // 创建任务对象 FutureTask\u0026lt;Integer\u0026gt; task3 = new FutureTask\u0026lt;\u0026gt;(() -\u0026gt; { log.debug(\u0026quot;hello\u0026quot;); return 100; }); // 参数1 是任务对象; 参数2 是线程名字，推荐 new Thread(task3, \u0026quot;t3\u0026quot;).start(); // 主线程阻塞，同步等待 task 执行完毕的结果 Integer result = task3.get(); log.debug(\u0026quot;结果是:{}\u0026quot;, result)  FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况\nCallable\n3.2 观察多个线程同时运行  主要是理解交替执行\n 谁先谁后，不由我们控制(由底层的任务调度器进行决定)\n@Slf4j(topic = \u0026quot;c.TestMultiThread\u0026quot;) public class TestMultiThread { public static void main(String[] args) { new Thread(() -\u0026gt; { while(true) { log.debug(\u0026quot;running\u0026quot;); } },\u0026quot;t1\u0026quot;).start(); new Thread(() -\u0026gt; { while(true) { log.debug(\u0026quot;running\u0026quot;); } },\u0026quot;t2\u0026quot;).start(); } }   3.3 查看进程线程的方法 windows  任务管理器可以查看进程和线程数，也可以用来杀死进程 tasklist 查看进程 taskkill 杀死进程\ntasklist | findstr java taskkill /F /PID xxxxx   linux  ps -fe 查看所有进程\nps -re | grep xx\nps -fT -p  查看某个进程（PID）的所有线程 kill 杀死进程 top 按大写 H 切换是否显示线程 top -H -p  查看某个进程（PID）的所有线程\n Java(jdk提供)  jps 命令查看所有 Java 进程 jstack  查看某个 Java 进程（PID）的所有线程状态(某一个时刻的状态) jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）\n jconsole 远程监控配置\nwin+r ：jconsole   需要以如下方式运行你的 java 类\njava -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote - Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 - Dcom.sun.management.jmxremote.authenticate=是否认证 java类  java -Djava.rmi.server.hostname=xx.xx.xx.xx -Dcom.sun.management.jmxremote - Dcom.sun.management.jmxremote.port=123 -Dcom.sun.management.jmxremote.ssl=false - Dcom.sun.management.jmxremote.authenticate=false  修改 /etc/hosts 文件将 127.0.0.1 映射至主机名\n  如果要认证访问，还需要做如下步骤\n 复制 jmxremote.password 文件 修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写 连接时填入 controlRole（用户名），R\u0026amp;D（密码）  3.4 *原理之线程运行 栈与栈帧 Java Virtual Machine Stacks （Java 虚拟机栈）\n我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟 机就会为其分配一块栈内存。\n 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法\npublic class TestFrames { public static void main(String[] args) { Thread t1 = new Thread(){ @Override public void run() { method1(20); } }; t1.setName(\u0026quot;t1\u0026quot;); t1.start(); method1(10); } private static void method1(int x) { int y = x + 1; Object m = method2(); System.out.println(m); } private static Object method2() { Object n = new Object(); return n; } }   方法存在栈中（栈：是一种先进后出的结构）\n每调用一个方法，就生成一个栈帧，方法结束后就释放栈的空间\n程序计数器：每一行(句)代码，当前执行的是哪一代码\n 类加载，先将TestFrames类的字节码加载到java虚拟机中，加载到方法区中（二进制字节码）\nJava虚拟机去启动一个main的主线程，并且分配main线程栈内存，线程交给任务调度器，去调度执行\ncpu准备运行主线程中的代码，分配主方法main的栈帧内存（由xxx等组成）\nmain栈帧的局部变量表存放args引用java虚拟机产生的new String[]数组\n程序计数器运行 method1(10);，为method1分配栈帧内存，\n局部变量表中存放x,y,m(在栈帧创建时就为变量分配好内存)，返回地址就会指向方法区中的method1方法，执行完毕后执行method1后面的代码\n局部变量x赋值为10，执行method1中的每一行代码，读到程序计数器，由cpu进行执行（为y赋值）\n为method2生成栈帧，在堆中为n分配内存，n指向堆中的内存地址，menthod1中的m的地址就指向堆中的地址\nm2内存释放，m1释放内存，main运行结束\n 视频地址\n两个线程时的栈帧内存\npublic class TestFrames { public static void main(String[] args) { Thread t1 = new Thread(){ @Override public void run() { method1(20); } }; t1.setName(\u0026quot;t1\u0026quot;); t1.start(); method1(10); } private static void method1(int x) { int y = x + 1; Object m = method2(); System.out.println(m); } private static Object method2() { Object n = new Object(); return n; } }  断点的运行方式要设置成thread\n栈帧是以线程为单位，相互是独立的，每个线程都有自己的栈帧空间互不干扰，相互独立\n线程上下文切换（Thread Context Switch） 当任务调度器把时间片分给每个线程运行的时候，每个线程的时间片总会有用完的时候，用完了你就得把cpu的使用权交给其他的线程，当前线程就会发生一次上下文切换。\n因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码（从使用cpu到不使用cpu）\n 线程的 cpu 时间片用完 垃圾回收（暂停所有线程，运行垃圾回收线程，进行垃圾回收） 有更高优先级的线程需要运行 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法  当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的\n 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等 Context Switch 频繁发生会影响性能（因此线程数不是越多越好）  3.5 常见方法    方法名 static 功能说明 注意     start()  启动一个新线 程，在新的线程 运行 run 方法 中的代码 start 方法只是让线程进入就绪，里面代码不一定立刻 运行（CPU 的时间片还没分给它）。每个线程对象的 start方法只能调用一次，如果调用了多次会出现 IllegalThreadStateException   run()  新线程启动后会 调用的方法 如果在构造 Thread 对象时传递了 Runnable 参数，则 线程启动后会调用 Runnable 中的 run 方法，否则默 认不执行任何操作。但可以创建 Thread 的子类对象， 来覆盖默认行为   join())  等待线程运行结 束    join(longn)  等待线程运行结 束,最多等待 n 毫秒    getld0  获取线程长整型 的 id id 唯一   getName()  获取线程名    setName(String)  修改线程名    getPriority()  获取线程优先级    setPriority(int)  修改线程优先级 java中规定线程优先级是1~10 的整数，较大的优先级 能提高该线程被 CPU 调度的机率   getState0  获取线程状态 Java 中线程状态是用 6 个 enum 表示，分别为： NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED   isInterrupted(  判断是否被打 断， 不会清除 打断标记   isAlive0  线程是否存活 （还没有运行完 毕）    interrupt()  打断线程 如果被打断线程正在 sleep，wait，join 会导致被打断 的线程抛出 InterruptedException，并清除 打断标 记 ；如果打断的正在运行的线程，则会设置 打断标 记 ；park 的线程被打断，也会设置 打断标记   interrupted() static 判断当前线程是 否被打断 会清除 打断标记   currentThread) static 获取当前正在执 行的线程    sleep(long n) static 让当前执行的线 程休眠n毫秒， 休眠时让出 cpu 的时间片给其它 线程    yield() static 提示线程调度器 让出当前线程对 CPU的使用 主要是为了测试和调试    3.6 start 与 run 调用 run\n程序仍在 main 线程运行，FileReader.read() 方法调用还是同步的调用 start\n@Slf4j(topic = \u0026quot;c.Test4\u0026quot;) public class Test4 { public static void main(String[] args) { Thread t1 = new Thread(\u0026quot;t1\u0026quot;) { @Override public void run() { log.debug(\u0026quot;running...\u0026quot;); FileReader.read(Constants.MP4_FULL_PATH); } }; t1.start(); log.debug(\u0026quot;do other things...\u0026quot;); } }  程序在 t1 线程运行，FileReader.read() 方法调用是异步的\n调用start()方法后线程的状态会变为runnable，再次调用start方法就会报错（线程变为runnable的状态就不能再调用start方法了）。\n小结  直接调用 run 是在主线程中执行了 run，没有启动新的线程 使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码\n 3.7 sleep 与 yield sleep\n 调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞） 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException 睡眠结束后的线程未必会立刻得到执行(线程结束以后cpu也许正在执行别的代码，需要系统任务调度器分配时间片) 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性\n@Slf4j(topic = \u0026quot;c.Test6\u0026quot;) public class Test6 { public static void main(String[] args) { Thread t1 = new Thread(\u0026quot;t1\u0026quot;) { @Override public void run() { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } }; t1.start(); log.debug(\u0026quot;t1 state: {}\u0026quot;, t1.getState()); try { Thread.sleep(500);//在哪一个线程中调用该方法，哪一个线程就休眠 } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\u0026quot;t1 state: {}\u0026quot;, t1.getState()); } }  @Slf4j(topic = \u0026quot;c.Test7\u0026quot;) public class Test7 { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(\u0026quot;t1\u0026quot;) { @Override public void run() { log.debug(\u0026quot;enter sleep...\u0026quot;); try { Thread.sleep(2000);//当线程被唤醒会报InterruptedException异常 } catch (InterruptedException e) { log.debug(\u0026quot;wake up...\u0026quot;); e.printStackTrace(); } } }; t1.start(); Thread.sleep(1000); log.debug(\u0026quot;interrupt...\u0026quot;); t1.interrupt(); } }  @Slf4j(topic = \u0026quot;c.Test8\u0026quot;) public class Test8 { public static void main(String[] args) throws InterruptedException { log.debug(\u0026quot;enter\u0026quot;); TimeUnit.SECONDS.sleep(1); log.debug(\u0026quot;end\u0026quot;); // Thread.sleep(1000); } }   yield\n 调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程 具体的实现依赖于操作系统的任务调度器（将cpu使用权让出去之后，可能任务调度器又将时间片分配给了当前线程）   就绪状态:还是有机会被任务调度器调用，任务调度器还是会分时间片给该线程；将该时间点的cpu使用让出去，如果没有其他线程了，就会把时间片分给它，没有真正的等待时间\nTimed Waiting 状态（阻塞）：任务调度器不会分时间片；有休眠时间，有真正的等待时间\n 线程优先级  线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu空闲时，优先级几乎没作用（与yield相似）\n 1-10级看一下源码\n/* @see #MAX_PRIORITY * @see #MIN_PRIORITY * @see ThreadGroup#getMaxPriority() */ public final void setPriority(int newPriority) { ThreadGroup g; checkAccess(); if (newPriority \u0026gt; MAX_PRIORITY || newPriority \u0026lt; MIN_PRIORITY) { throw new IllegalArgumentException(); } if((g = getThreadGroup()) != null) { if (newPriority \u0026gt; g.getMaxPriority()) { newPriority = g.getMaxPriority(); } setPriority0(priority = newPriority); } } /** * The minimum priority that a thread can have. */ public final static int MIN_PRIORITY = 1; /** * The default priority that is assigned to a thread. */ public final static int NORM_PRIORITY = 5; /** * The maximum priority that a thread can have. */ public final static int MAX_PRIORITY = 10;  数字越大优先级越高\nRunnable task1 = () -\u0026gt; { int count = 0; for (;;) { System.out.println(\u0026quot;----\u0026gt;1 \u0026quot; + count++); } }; Runnable task2 = () -\u0026gt; { int count = 0; for (;;) { // Thread.yield(); System.out.println(\u0026quot; ----\u0026gt;2 \u0026quot; + count++); } }; Thread t1 = new Thread(task1, \u0026quot;t1\u0026quot;); Thread t2 = new Thread(task2, \u0026quot;t2\u0026quot;); // t1.setPriority(Thread.MIN_PRIORITY); // t2.setPriority(Thread.MAX_PRIORITY); t1.start(); t2.start();  数字越大优先级越高，默认优先级是5\n@Slf4j(topic = \u0026quot;c.Test9\u0026quot;) public class Test9 { public static void main(String[] args) { Runnable task1 = () -\u0026gt; { int count = 0; for (;;) { System.out.println(\u0026quot;----\u0026gt;1 \u0026quot; + count++); } }; Runnable task2 = () -\u0026gt; { int count = 0; for (;;) { // Thread.yield(); System.out.println(\u0026quot; ----\u0026gt;2 \u0026quot; + count++); } }; Thread t1 = new Thread(task1, \u0026quot;t1\u0026quot;); Thread t2 = new Thread(task2, \u0026quot;t2\u0026quot;); t1.setPriority(Thread.MIN_PRIORITY); t2.setPriority(Thread.MAX_PRIORITY); t1.start(); t2.start(); } }  * 应用之限制 应用之限制\n3.8 join 方法详解 为什么需要 join\n下面的代码执行，打印 r 是什么？\n@Slf4j(topic = \u0026quot;c.Test10\u0026quot;) public class Test10 { static int r = 0; public static void main(String[] args) throws InterruptedException { test1(); } private static void test1() throws InterruptedException { log.debug(\u0026quot;开始\u0026quot;); Thread t1 = new Thread(() -\u0026gt; { log.debug(\u0026quot;开始\u0026quot;); sleep(1); log.debug(\u0026quot;结束\u0026quot;); r = 10; },\u0026quot;t1\u0026quot;); t1.start(); //t1.join();//等待t1线程计算完成后，才恢复主线程 log.debug(\u0026quot;结果为:{}\u0026quot;, r); log.debug(\u0026quot;结束\u0026quot;); } } //结果为0  分析  因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 r=10 而主线程一开始就要打印 r 的结果，所以只能打印出 r=0\n 解决方法\n 用 sleep 行不行？为什么？ 用 join，加在 t1.start() 之后即可\n * 应用之同步（案例 1 ） 以调用方角度来讲，如果\n 需要等待结果返回，才能继续运行就是同步 不需要等待结果返回，就能继续运行就是异步\nstatic int r1 = 0; static int r2 = 0; public static void main(String[] args) throws InterruptedException { test2(); } private static void test2() throws InterruptedException { Thread t1 = new Thread(() -\u0026gt; { sleep(1); r1 = 10; }); Thread t2 = new Thread(() -\u0026gt; { sleep(2); r2 = 20; }); long start = System.currentTimeMillis(); t1.start(); t2.start(); t1.join(); t2.join(); long end = System.currentTimeMillis(); log.debug(\u0026quot;r1: {} r2: {} cost: {}\u0026quot;, r1, r2, end - start);//结果为2s }   分析如下\n 第一个 join：等待 t1 时, t2 并没有停止, 而在运行 第二个 join：1s 后, 执行到此, t2 也运行了 1s, 因此也只需再等待 1s\n 如果颠倒两个 join 呢？(结果一样)\n最终都是输出\n20:45:43.239 [main] c.TestJoin - r1: 10 r2: 20 cost: 2005  graph TB a(\u0026quot;main\u0026quot;)--\u0026gt; b(\u0026quot;t1.start\u0026quot;) b(\u0026quot;t1.start\u0026quot;)--1s后--\u0026gt;c(\u0026quot;r=10\u0026quot;) c(\u0026quot;r=10\u0026quot;)--t1终止--\u0026gt;d(\u0026quot;t1.join\u0026quot;) a(\u0026quot;main\u0026quot;)--\u0026gt;d(\u0026quot;t1.join\u0026quot;) a(\u0026quot;main\u0026quot;)--\u0026gt;e(\u0026quot;t2.start\u0026quot;) e(\u0026quot;t2.start\u0026quot;)--2s后--\u0026gt;f(\u0026quot;r=20\u0026quot;) f(\u0026quot;r=20\u0026quot;)--t2终止--\u0026gt;g(\u0026quot;t2.join-仅需等1s\u0026quot;) d(\u0026quot;t1.join\u0026quot;)--\u0026gt;g(\u0026quot;t2.join-仅需等1s\u0026quot;)  graph TB a(\u0026quot;main\u0026quot;)--\u0026gt; b(\u0026quot;t2.start\u0026quot;) b(\u0026quot;t1.start\u0026quot;)--2s后--\u0026gt;c(\u0026quot;r=20\u0026quot;) c(\u0026quot;r=20\u0026quot;)--t2终止--\u0026gt;d(\u0026quot;t2.join\u0026quot;) a(\u0026quot;main\u0026quot;)--\u0026gt;d(\u0026quot;t2.join\u0026quot;) a(\u0026quot;main\u0026quot;)--\u0026gt;e(\u0026quot;t1.start\u0026quot;) e(\u0026quot;t1.start\u0026quot;)--1s后--\u0026gt;f(\u0026quot;r=10\u0026quot;) f(\u0026quot;r=10\u0026quot;)--t1终止--\u0026gt;g(\u0026quot;t1.join-无需等待\u0026quot;) d(\u0026quot;t2.join\u0026quot;)--\u0026gt;g(\u0026quot;t1.join-无需等待\u0026quot;)  有时效的 join\nstatic int r1 = 0; static int r2 = 0; public static void main(String[] args) throws InterruptedException { test3(); } public static void test3() throws InterruptedException { Thread t1 = new Thread(() -\u0026gt; { sleep(2); r1 = 10; }); long start = System.currentTimeMillis(); t1.start(); // 线程执行结束会导致 join 结束 t1.join(1500); long end = System.currentTimeMillis(); log.debug(\u0026quot;r1: {} r2: {} cost: {}\u0026quot;, r1, r2, end - start); }  输出\n20:52:15.623 [main] c.TestJoin - r1: 0 r2: 0 cost: 1502  可以提前结束\n3.9 interrupt 方法详解 打断 sleep，wait，join （join底层就是wait）的线程，这几个方法都会让线程进入阻塞状态\n打断 sleep 的线程, 会清空打断状态，以 sleep 为例\n@Slf4j(topic = \u0026quot;c.Test11\u0026quot;) public class Test11 { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u0026gt; { log.debug(\u0026quot;sleep...\u0026quot;); try { Thread.sleep(5000); // wait, join ,sleep在被打断后会重置打断标记为false } catch (InterruptedException e) { e.printStackTrace(); } },\u0026quot;t1\u0026quot;); t1.start(); Thread.sleep(1000); log.debug(\u0026quot;interrupt\u0026quot;); t1.interrupt(); log.debug(\u0026quot;打断标记:{}\u0026quot;, t1.isInterrupted()); } }  打断正常运行的线程\n打断正常运行的线程, 不会清空打断状态，也不会停止线程。需要线程判断自己的打断标记是否被打断了，如果被打断了，自己则停止（要做一个乖宝宝）\n@Slf4j(topic = \u0026quot;c.Test12\u0026quot;) public class Test12 { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u0026gt; { while(true) { boolean interrupted = Thread.currentThread().isInterrupted();//Thread.currentThread()获取当前线程，被打断时打断标记会被标记成真true if(interrupted) { log.debug(\u0026quot;被打断了, 退出循环\u0026quot;); break; } } }, \u0026quot;t1\u0026quot;); t1.start(); Thread.sleep(1000); log.debug(\u0026quot;interrupt\u0026quot;); t1.interrupt(); } }  * 模式之两阶段终止 模式之两阶段终止\n打断 park 线程\n打断 park 线程, 不会清空打断状态\n@Slf4j(topic = \u0026quot;c.Test14\u0026quot;) public class Test14 { private static void test3() throws InterruptedException { Thread t1 = new Thread(() -\u0026gt; { log.debug(\u0026quot;park...\u0026quot;); LockSupport.park(); log.debug(\u0026quot;unpark...\u0026quot;); log.debug(\u0026quot;打断状态：{}\u0026quot;, Thread.currentThread().isInterrupted());//此时打断标记为真true，对park无效， LockSupport.park();没有用，就会执行log.debug(\u0026quot;unpark....\u0026quot;); // log.debug(\u0026quot;打断状态：{}\u0026quot;, Thread.interrupted());//Thread.interrupted()返回打断标记，然后将该打断标记设为假，打断标记为假park就生效了 LockSupport.park();又会执行，就不会执行log.debug(\u0026quot;unpark....\u0026quot;); LockSupport.park(); log.debug(\u0026quot;unpark....\u0026quot;); }, \u0026quot;t1\u0026quot;); t1.start(); sleep(1); t1.interrupt(); } public static void main(String[] args) throws InterruptedException { test3(); } }  提示\n可以使用 Thread.interrupted() 清除打断状态\n如果打断标记已经是 true, 则 park 会失效\n3.10 不推荐的方法 还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁\n   方法名 static 功能说明     stop()  停止线程运行(两阶段终止模式替代)   suspend()  挂起(暂停)线程运行（wait方法代替）   resume()  恢复线程运行(notify方法代替)    3.11 主线程与守护线程 默认情况下，Java 进程需要等待所有线程都运行结束，才会结束（即使main线程已经结束了，还有其他的额外的线程在运行，程序也不会停止）。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。\n例：\nlog.debug(\u0026quot;开始运行...\u0026quot;); Thread t1 = new Thread(() -\u0026gt; { log.debug(\u0026quot;开始运行...\u0026quot;); sleep(2); log.debug(\u0026quot;运行结束...\u0026quot;); }, \u0026quot;daemon\u0026quot;); t1.setDaemon(true);// 设置该线程为守护线程 默认不是守护线程 t1.start(); sleep(1); log.debug(\u0026quot;运行结束...\u0026quot;);  输出\n08:26:38.123 [main] c.TestDaemon - 开始运行... 08:26:38.213 [daemon] c.TestDaemon - 开始运行... 08:26:39.215 [main] c.TestDaemon - 运行结束...  注意  垃圾回收器线程就是一种守护线程\n Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求\n  3.12 五种状态 这是从 操作系统 层面来描述的\n 【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联\n 【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行，暂时还没有分配到时间片\n 【运行状态】指获取了 CPU 时间片运行中的状态；\n 当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换  【阻塞状态】\n 如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】\n 等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】\n 与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们\n  【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态\n  3.13 六种状态 这是从 Java API 层面来描述的\n根据 Thread.State 枚举，分为六种状态\n NEW 线程刚被创建，但是还没有调用 start() 方法 RUNNABLE 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行） BLOCKED，WAITING，TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节 详述 TERMINATED 当线程代码运行结束\npublic class TestState2 { public static void main(String[] args) throws InterruptedException { new Thread(() -\u0026gt; { FileReader.read(Constants.MP4_FULL_PATH); FileReader.read(Constants.MP4_FULL_PATH); FileReader.read(Constants.MP4_FULL_PATH); }, \u0026quot;t1\u0026quot;).start(); Thread.sleep(1000); System.out.println(\u0026quot;ok\u0026quot;); } } @Slf4j(topic = \u0026quot;c.TestState\u0026quot;) public class TestState { public static void main(String[] args) throws IOException { Thread t1 = new Thread(\u0026quot;t1\u0026quot;) { @Override public void run() { log.debug(\u0026quot;running...\u0026quot;); } }; Thread t2 = new Thread(\u0026quot;t2\u0026quot;) { @Override public void run() { while(true) { // runnable } } }; t2.start(); Thread t3 = new Thread(\u0026quot;t3\u0026quot;) { @Override public void run() { log.debug(\u0026quot;running...\u0026quot;); } }; t3.start(); Thread t4 = new Thread(\u0026quot;t4\u0026quot;) { @Override public void run() { synchronized (TestState.class) { try { Thread.sleep(1000000); // timed_waiting } catch (InterruptedException e) { e.printStackTrace(); } } } }; t4.start(); Thread t5 = new Thread(\u0026quot;t5\u0026quot;) { @Override public void run() { try { t2.join(); // waiting } catch (InterruptedException e) { e.printStackTrace(); } } }; t5.start(); Thread t6 = new Thread(\u0026quot;t6\u0026quot;) { @Override public void run() { synchronized (TestState.class) { // blocked try { Thread.sleep(1000000); } catch (InterruptedException e) { e.printStackTrace(); } } } }; t6.start(); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\u0026quot;t1 state {}\u0026quot;, t1.getState()); log.debug(\u0026quot;t2 state {}\u0026quot;, t2.getState()); log.debug(\u0026quot;t3 state {}\u0026quot;, t3.getState()); log.debug(\u0026quot;t4 state {}\u0026quot;, t4.getState()); log.debug(\u0026quot;t5 state {}\u0026quot;, t5.getState()); log.debug(\u0026quot;t6 state {}\u0026quot;, t6.getState()); System.in.read(); } }   3.14 习题 阅读华罗庚《统筹方法》，给出烧水泡茶的多线程解决方案，提示\n 参考图二，用两个线程（两个人协作）模拟烧水泡茶过程\n 文中办法乙、丙都相当于任务串行\n 而图一相当于启动了 4 个线程，有点浪费\n  用 sleep(n) 模拟洗茶壶、洗水壶等耗费的时间\n  附：华罗庚《统筹方法》\n 统筹方法，是一种安排工作进程的数学方法。它的实用范围极广泛，在企业管理和基本建设中，以及关系复\n杂的科研项目的组织与管理中，都可以应用。\n怎样应用呢？主要是把工序安排好。\n比如，想泡壶茶喝。当时的情况是：开水没有；水壶要洗，茶壶、茶杯要洗；火已生了，茶叶也有了。怎么\n办？\n办法甲：洗好水壶，灌上凉水，放在火上；在等待水开的时间里，洗茶壶、洗茶杯、拿茶叶；等水开\n了，泡茶喝。\n办法乙：先做好一些准备工作，洗水壶，洗茶壶茶杯，拿茶叶；一切就绪，灌水烧水；坐待水开了，泡\n茶喝。\n办法丙：洗净水壶，灌上凉水，放在火上，坐待水开；水开了之后，急急忙忙找茶叶，洗茶壶茶杯，泡\n茶喝。\n哪一种办法省时间？我们能一眼看出，第一种办法好，后两种办法都窝了工。\n这是小事，但这是引子，可以引出生产管理等方面有用的方法来。\n水壶不洗，不能烧开水，因而洗水壶是烧开水的前提。没开水、没茶叶、不洗茶壶茶杯，就不能泡茶，因而\n这些又是泡茶的前提。它们的相互关系，可以用下边的箭头图来表示：\n\u0026gt; graph LR \u0026gt; a(洗水壶1分钟) --\u0026gt; b(烧开水15分钟) \u0026gt; c(洗茶壶 1分钟) \u0026gt; d(洗茶杯 2分钟) \u0026gt; e(拿茶叶 1分钟) \u0026gt; b --\u0026gt; f(泡茶) \u0026gt; c --\u0026gt; f(泡茶) \u0026gt; d --\u0026gt; f(泡茶) \u0026gt; e --\u0026gt; f(泡茶) \u0026gt; ``` \u0026gt; \u0026gt; 从这个图上可以一眼看出，办法甲总共要16分钟（而办法乙、丙需要20分钟）。如果要缩短工时、提高工作 \u0026gt; \u0026gt; 效率，应当主要抓烧开水这个环节，而不是抓拿茶叶等环节。同时，洗茶壶茶杯、拿茶叶总共不过4分钟，大 \u0026gt; \u0026gt; 可利用“等水开”的时间来做。 \u0026gt; \u0026gt; 是的，这好像是废话，卑之无甚高论。有如走路要用两条腿走，吃饭要一口一口吃，这些道理谁都懂得。但 \u0026gt; \u0026gt; 稍有变化，临事而迷的情况，常常是存在的。在近代工业的错综复杂的工艺过程中，往往就不是像泡茶喝这 \u0026gt; \u0026gt; 么简单了。任务多了，几百几千，甚至有好几万个任务。关系多了，错综复杂，千头万绪，往往出现“万事俱 \u0026gt; \u0026gt; 备，只欠东风”的情况。由于一两个零件没完成，耽误了一台复杂机器的出厂时间。或往往因为抓的不是关 \u0026gt; \u0026gt; 键，连夜三班，急急忙忙，完成这一环节之后，还得等待旁的环节才能装配。 \u0026gt; \u0026gt; 洗茶壶，洗茶杯，拿茶叶，或先或后，关系不大，而且同是一个人的活儿，因而可以合并成为： \u0026gt; \u0026gt; ```mermaid \u0026gt; graph LR \u0026gt; a(洗水壶1分钟) --\u0026gt; b(烧开水15分钟) \u0026gt; c(洗茶壶,洗茶杯,拿茶叶 4分钟) \u0026gt; b --\u0026gt; f(泡茶) \u0026gt; c --\u0026gt; f(泡茶) \u0026gt; ``` \u0026gt; \u0026gt; 看来这是“小题大做”，但在工作环节太多的时候，这样做就非常必要了。 \u0026gt; \u0026gt; 这里讲的主要是时间方面的事，但在具体生产实践中，还有其他方面的许多事。这种方法虽然不一定能直接 \u0026gt; \u0026gt; 解决所有问题，但是，我们利用这种方法来考虑问题，也是不无裨益的。 解法 **应用篇-统筹** ## 本章小结 本章的重点在于掌握 * 线程创建 * 线程重要 api，如 start，run，sleep，join，interrupt 等 * 线程状态 * 应用方面 * 异步调用：主线程执行期间，其它线程异步执行耗时操作 * 提高效率：并行计算，缩短运算时间 * 同步等待：join * 统筹规划：合理使用线程，得到最优效果 * 原理方面 * 线程运行流程：栈、栈帧、上下文切换、程序计数器 * Thread 两种创建方式 的源码 * 模式方面 * 终止模式之两阶段终止 # 4. 共享模型之管程 ## 本章内容 * 共享问题 * synchronized * 线程安全分析 * Monitor * wait/notify * 线程状态转换 * 活跃性 * Lock Monitor两大作用：互斥、同步 synchronized：在JVM(c++)的层面上实现关联Monitor rentryLock:在Java层面上实现关联monitor ## 4.1 共享带来的问题 小故事 老王（操作系统）有一个功能强大的算盘（CPU），现在想把它租出去，赚一点外快 小南、小女（线程）来使用这个算盘来进行一些计算，并按照时间给老王支付费用 但小南不能一天 24 小时使用算盘，他经常要小憩一会（sleep），又或是去吃饭上厕所（阻塞 io 操作），有 时还需要一根烟，没烟时思路全无（wait）这些情况统称为（阻塞） 在这些时候，算盘没利用起来（不能收钱了），老王觉得有点不划算 另外，小女也想用用算盘，如果总是小南占着算盘，让小女觉得不公平 于是，老王灵机一动，想了个办法 [ 让他们每人用一会，轮流使用算盘 ] 这样，当小南阻塞的时候，算盘可以分给小女使用，不会浪费，反之亦然 最近执行的计算比较复杂，需要存储一些中间结果，而学生们的脑容量（工作内存）不够，所以老王申请了一个笔记本（主存），把一些中间结果先记在本上 计算流程是这样的 但是由于分时系统，有一天还是发生了事故 小南刚读取了初始值 0 做了个 +1 运算，还没来得及写回结果 老王说 [ 小南，你的时间到了，该别人了，记住结果走吧 ]，于是小南念叨着 [ 结果是 1 ，结果是1...] 不甘心地 到一边待着去了（上下文切换） 老王说 [ 小女，该你了 ]，小女看到了笔记本上还写着 0 做了一个 -1 运算，将结果 -1 写入笔记本 这时小女的时间也用完了，老王又叫醒了小南：[小南，把你上次的题目算完吧]，小南将他脑海中的结果 1 写入了笔记本 小南和小女都觉得自己没做错，但笔记本里的结果是 1 而不是 0 Java 的体现 两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？  java static int counter = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5000; i++) { counter++; } }, \u0026ldquo;t1\u0026rdquo;); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5000; i++) { counter\u0026ndash;; } }, \u0026ldquo;t2\u0026rdquo;); t1.start(); t2.start(); t1.join(); t2.join(); log.debug(\u0026ldquo;{}\u0026rdquo;,counter); }\n ### 问题分析 以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作，要彻底理解，必须从字节码来进行分析 例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：  getstatic i // 获取静态变量i的值 iconst_1 // 准备常量1 iadd // 自增 putstatic i // 将修改后的值存入静态变量i\n 而对应 i-- 也是类似：  getstatic i // 获取静态变量i的值 iconst_1 // 准备常量1 isub // 自减 putstatic i // 将修改后的值存入静态变量i\n 而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换： ![image-20200620162309624](/../content/posts/java并发编程.assets/image-20200620162309624.png) 如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题： 但多线程下这 8 行代码可能交错运行：  mermaid sequenceDiagram # 通过设定参与者(participants)的顺序控制展示模块顺序 participant 线程1 participant static i static i-\u0026gt;线程1:getstatic i 读取 0 线程1-\u0026gt;线程1:iconst_1 准备常数1 线程1-\u0026gt;线程1:iadd 加法，线程内i=1 线程1-\u0026gt;static i:putstatic i 写入1 static i -\u0026gt;线程1:getstatic i 读取1 线程1-\u0026gt;线程1:iconst_1准备常数 1 线程1-\u0026gt;线程1:isub 减法,线程内i=0 线程1-\u0026gt;static i:putstatic i 写入0\n  出现负数的情况：  mermaid sequenceDiagram # 通过设定参与者(participants)的顺序控制展示模块顺序 participant 线程1 participant 线程2 participant static i static i-\u0026gt;线程2:getstatic i 读取 0 线程2-\u0026gt;线程2:iconst_1 准备常数1 线程2-\u0026gt;线程2:iadd 加法，线程内i=1 线程2\u0026ndash;\u0026gt;线程1:上下文切换 static i-\u0026gt;线程1:getstatic i 读取 0 线程1-\u0026gt;线程1:iconst_1准备常数 1 线程1-\u0026gt;线程1:iadd 加法,线程内i=1 线程1-\u0026gt;static i:putstatic i 写入1 线程1\u0026ndash;\u0026gt;线程2:上下文切换 线程1-\u0026gt;static i:putstatic i 写入-1\n 出现正数的情况  mermaid sequenceDiagram # 通过设定参与者(participants)的顺序控制展示模块顺序 participant 线程1 participant 线程2 participant static i static i-\u0026gt;线程1:getstatic i 读取 0 线程1-\u0026gt;线程1:iconst_1 准备常数1 线程1-\u0026gt;线程1:iadd 加法，线程内i=1 线程1\u0026ndash;\u0026gt;线程2:上下文切换 static i-\u0026gt;线程2:getstatic i 读取 0 线程2-\u0026gt;线程2:iconst_1准备常数 1 线程1-\u0026gt;线程1:isub 减法,线程内i=-1 线程2-\u0026gt;static i:putstatic i 写入-1 线程2\u0026ndash;\u0026gt;线程1:上下文切换 线程1-\u0026gt;static i:putstatic i 写入1\n **临界区 Critical Section** * 一个程序运行多个线程本身是没有问题的 * 问题出在多个线程访问共享资源 * 多个线程读共享资源其实也没有问题 * 在多个线程对共享资源读写操作时发生指令交错，就会出现问题 * 一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区 例如，下面代码中的临界区  java static int counter = 0; static void increment() // 临界区 { counter++; } static void decrement() // 临界区 { counter\u0026ndash;; }\n **竞态条件 Race Condition** 多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件 ## 4.2 synchronized 解决方案 ### * 应用之互斥 为了避免临界区的竞态条件发生，有多种手段可以达到目的。 * 阻塞式的解决方案：synchronized，Lock * 非阻塞式的解决方案：原子变量 本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】（要配合对象使用）时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换 \u0026gt; 注意 \u0026gt; 虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的： \u0026gt; \u0026gt; * 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码 \u0026gt; * 同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点 synchronized 语法  java synchronized(对象) // 线程1， 线程2(blocked) { 临界区 }\n 解决  java static int counter = 0 ; static final Object room = new Object(); public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -\u0026gt; { for (int i = 0 ; i \u0026lt; 5000 ; i++) { synchronized (room) { counter++; } } }, \u0026ldquo;t1\u0026rdquo;); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0 ; i \u0026lt; 5000 ; i++) { synchronized (room) { counter\u0026ndash;; } } }, \u0026ldquo;t2\u0026rdquo;); t1.start(); t2.start(); t1.join(); t2.join(); log.debug(\u0026ldquo;{}\u0026rdquo;,counter); }\n 你可以做这样的类比： ![image-20200421093754691](/resources/技术收录/Java/java并发/image-20200421093754691.png) * synchronized(对象) 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人进行计算，线程 t1，t2 想象成两个人 * 当线程 t1 执行到 synchronized(room) 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行count++ 代码 * 这时候如果 t2 也运行到了 synchronized(room) 时，它发现门被锁住了，只能在门外等待，发生了上下文切换，阻塞住了 * 这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦），这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才能开门进入 * 当 t1 执行完 synchronized{} 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 count-- 代码 ### 用图来表示  mermaid sequenceDiagram # 通过设定参与者(participants)的顺序控制展示模块顺序 participant 线程1 participant 线程2 participant static i participant 锁对象 线程2-\u0026gt;锁对象:尝试获取锁 note over 线程2,锁对象: 拥有锁 static i-\u0026gt;线程2:getstatic i 读取 0 线程2-\u0026gt;线程2:iconst_1 准备常数1 线程2-\u0026gt;线程2:isub 减法，线程内i=-1 线程2\u0026ndash;\u0026gt;线程1:上下文切换 线程1-\u0026gt;锁对象:尝试获取锁，被阻塞(BLOCKED) 线程1\u0026ndash;\u0026gt;线程2:上下文切换 线程2-\u0026gt;static i:pitstatic i 写入-1 note over 线程2,锁对象:拥有锁 线程2-\u0026gt;锁对象:释放锁，并唤醒阻塞的线程 note over 线程1,锁对象:拥有锁 static i-\u0026gt;线程1:getstatic i 读取 -1 线程1-\u0026gt;线程1:iconst_1准备常数 1 线程1-\u0026gt;线程1:iadd 加法,线程内i=0 线程1-\u0026gt;static i:putstatic i 写入0 note over 线程1,锁对象:拥有锁 线程1\u0026ndash;\u0026gt;锁对象:释放锁，并唤醒阻塞的线程\n **思考** synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切 换所打断。 为了加深理解，请思考下面的问题 * 如果把 synchronized(obj) 放在 for 循环的外面，如何理解？（将synchronized范围内的代码作为一个整体）-- 原子性 * 如果 t1 synchronized(obj1) 而 t2 synchronized(obj2) 会怎样运作？(失效，因为是不同的对象)-- 锁对象 * 如果 t1 synchronized(obj) 而 t2 没有加会怎么样？如何理解？-- 锁对象 都要对这个对象进行加锁 ### 面向对象改进 把需要保护的共享变量放入一个类  java @Slf4j(topic = \u0026ldquo;c.Test17\u0026rdquo;) public class Test17 { public static void main(String[] args) throws InterruptedException { Room room = new Room(); Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5000; i++) { room.increment(); } }, \u0026ldquo;t1\u0026rdquo;);\n Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5000; i++) { room.decrement(); } }, \u0026quot;t2\u0026quot;); t1.start(); t2.start(); t1.join(); t2.join(); log.debug(\u0026quot;{}\u0026quot;, room.getCounter()); }  } class Room { private int counter = 0; /* public void increment() { synchronized (this){ counter++; } }\npublic void decrement() { synchronized (this){ counter--; } } public int getCounter() { synchronized (this){ return counter; } }*/ public synchronized void increment() { counter++; } public synchronized void decrement() { counter--; } public synchronized int getCounter() { return counter; }  }\n ## 4.3 方法上的 synchronized  java class Test{ public synchronized void test() {\n} } 等价于 class Test{ public void test() { synchronized(this) {\n } }  }\n  java class Test{ public synchronized static void test() { } } 等价于 class Test{ public static void test() { synchronized(Test.class) { } } }\n synchronized只能锁对象，加在普通方法上锁的是调用它的对象。加载类的静态方法上锁的是类的Class对象。 不加 synchronized 的方法 * 不加 synchronzied 的方法就好比不遵守规则的人，不去老实排队（好比翻窗户进去的），没办法保证原子性 ### 所谓的“线程八锁” 其实就是考察 synchronized 锁住的是哪个对象 情况 1 ： 12 或 21（不容易出现）;锁的都是n1这个对象，哪个线程先被调用，哪个就先打印。  java @Slf4j(topic = \u0026ldquo;c.Number\u0026rdquo;) class Number{ public synchronized void a() { log.debug(\u0026ldquo;1\u0026rdquo;); } public synchronized void b() { log.debug(\u0026ldquo;2\u0026rdquo;); } } public static void main(String[] args) { Number n1 = new Number(); new Thread(()-\u0026gt;{ n1.a(); }).start(); new Thread(()-\u0026gt;{ n1.b(); }).start(); }\n 情况 2 ：1s后--2 ，或 2-- 1s后 1；锁的都是n1这个对象，哪个线程先被调用，哪个就先打印。  java @Slf4j(topic = \u0026ldquo;c.Number\u0026rdquo;) class Number{ public synchronized void a() { sleep(1); log.debug(\u0026ldquo;1\u0026rdquo;); } public synchronized void b() { log.debug(\u0026ldquo;2\u0026rdquo;); } } public static void main(String[] args) { Number n1 = new Number(); new Thread(()-\u0026gt;{ n1.a(); }).start(); new Thread(()-\u0026gt;{ n1.b(); }).start(); }\n 情况 3 ：`3-1s-1-2` 或 `2-3-1s-1` 或 `3-2-1s-1`  java @Slf4j(topic = \u0026ldquo;c.Number\u0026rdquo;) class Number{ public synchronized void a() { sleep(1); log.debug(\u0026ldquo;1\u0026rdquo;); } public synchronized void b() { log.debug(\u0026ldquo;2\u0026rdquo;); } public void c() {//普通方法没锁 log.debug(\u0026ldquo;3\u0026rdquo;); } } public static void main(String[] args) { Number n1 = new Number(); new Thread(()-\u0026gt;{ n1.a(); }).start(); new Thread(()-\u0026gt;{ n1.b(); }).start(); new Thread(()-\u0026gt;{ n1.c(); }).start(); }\n 情况 4 ：2 1s 后 1  java @Slf4j(topic = \u0026ldquo;c.Number\u0026rdquo;) class Number{ public synchronized void a() { sleep(1); log.debug(\u0026ldquo;1\u0026rdquo;); } public synchronized void b() { log.debug(\u0026ldquo;2\u0026rdquo;); } } public static void main(String[] args) { Number n1 = new Number();//两个对象，两把锁 Number n2 = new Number(); new Thread(()-\u0026gt;{ n1.a(); }).start(); new Thread(()-\u0026gt;{ n2.b(); }).start(); }\n 情况 5 ：2 1s 后 1  java @Slf4j(topic = \u0026ldquo;c.Number\u0026rdquo;) class Number{ public static synchronized void a() {//锁住的是Number这个类对象(类对象在内存中只有一份) sleep(1); log.debug(\u0026ldquo;1\u0026rdquo;); } public synchronized void b() {//锁住的是当前对象 log.debug(\u0026ldquo;2\u0026rdquo;); } } public static void main(String[] args) { Number n1 = new Number(); new Thread(()-\u0026gt;{ n1.a(); }).start(); new Thread(()-\u0026gt;{ n1.b(); }).start(); }\n 情况 6 ：1s 后 12 ， 或 2 1s后 1  java @Slf4j(topic = \u0026ldquo;c.Number\u0026rdquo;) class Number{ public static synchronized void a() { sleep(1); log.debug(\u0026ldquo;1\u0026rdquo;); } public static synchronized void b() { log.debug(\u0026ldquo;2\u0026rdquo;); } } public static void main(String[] args) { Number n1 = new Number(); new Thread(()-\u0026gt;{ n1.a(); }).start(); new Thread(()-\u0026gt;{ n1.b(); }).start(); }\n 情况 7 ：2 1s 后 1  java @Slf4j(topic = \u0026ldquo;c.Number\u0026rdquo;) class Number{ public static synchronized void a() { sleep(1); log.debug(\u0026ldquo;1\u0026rdquo;); } public synchronized void b() { log.debug(\u0026ldquo;2\u0026rdquo;); } } public static void main(String[] args) { Number n1 = new Number(); Number n2 = new Number(); new Thread(()-\u0026gt;{ n1.a(); }).start(); new Thread(()-\u0026gt;{ n2.b(); }).start(); }\n 情况 8 ：1s 后 12 ， 或 2 1s后 1  java @Slf4j(topic = \u0026ldquo;c.Number\u0026rdquo;) class Number{ public static synchronized void a() { sleep(1); log.debug(\u0026ldquo;1\u0026rdquo;); } public static synchronized void b() { log.debug(\u0026ldquo;2\u0026rdquo;); } } public static void main(String[] args) { Number n1 = new Number(); Number n2 = new Number(); new Thread(()-\u0026gt;{ n1.a(); }).start(); new Thread(()-\u0026gt;{ n2.b(); }).start(); }\n ## 4.4 变量的线程安全分析 **成员变量和静态变量是否线程安全？** * 如果它们没有共享，则线程安全 * 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况 * 如果只有读操作，则线程安全 * 如果有读写操作，则这段代码是临界区，需要考虑线程安全 **局部变量是否线程安全？** * 局部变量是线程安全的 * 但局部变量引用的对象则未必 * 如果该对象没有逃离方法的作用范围，它是线程安全的 * 如果该对象逃离方法的作用范围(return)，需要考虑线程安全 **局部变量线程安全分析**  java public static void test1() { int i = 10; i++; }\n 每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享 将代码反编译后  java public static void test1(); descriptor: ()V flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=1, args_size=0 0: bipush 10 2: istore_0 3: iinc 0, 1 6: return LineNumberTable: line 10: 0 line 11: 3 line 12: 6 LocalVariableTable: Start Length Slot Name Signature 3 4 0 i I\n 如图 ![image-20200420130910826](/resources/技术收录/Java/java并发/image-20200420130910826.png) 局部变量的引用稍有不同 先看一个成员变量的例子  java class ThreadUnsafe { ArrayList list = new ArrayList\u0026lt;\u0026gt;(); public void method1(int loopNumber) { for (int i = 0; i \u0026lt; loopNumber; i++) { // { 临界区, 会产生竞态条件 method2(); method3(); // } 临界区 } } private void method2() { list.add(\u0026ldquo;1\u0026rdquo;); } private void method3() { list.remove(0); } }\n 执行  java static final int THREAD_NUMBER = 2; static final int LOOP_NUMBER = 200; public static void main(String[] args) { ThreadUnsafe test = new ThreadUnsafe(); for (int i = 0; i \u0026lt; THREAD_NUMBER; i++) { new Thread(() -\u0026gt; { test.method1(LOOP_NUMBER); }, \u0026ldquo;Thread\u0026rdquo; + i).start(); } }\n 其中一种情况是，如果线程 2 还未 add，线程1 remove 就会报错：  Exception in thread \u0026ldquo;Thread1\u0026rdquo; java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 at java.util.ArrayList.rangeCheck(ArrayList.java:657) at java.util.ArrayList.remove(ArrayList.java:496) at cn.itcast.n6.ThreadUnsafe.method3(TestThreadSafe.java:35) at cn.itcast.n6.ThreadUnsafe.method1(TestThreadSafe.java:26) at cn.itcast.n6.TestThreadSafe.lambda$main$0(TestThreadSafe.java:14) at java.lang.Thread.run(Thread.java:748)\n ### 分析： * 无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量 * method3 与 method2 分析相同 ![image-20200420131045455](/resources/技术收录/Java/java并发/image-20200420131045455.png) 将 list 修改为局部变量 那么就不会有上述问题了  java class ThreadSafe { public final void method1(int loopNumber) { ArrayList list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; loopNumber; i++) { method2(list); method3(list); } } private void method2(ArrayList list) { list.add(\u0026ldquo;1\u0026rdquo;); } private void method3(ArrayList list) { list.remove(0); } }\n 那么就不会有上述问题了 分析： * list 是局部变量，每个线程调用时会创建其不同实例，没有共享 * 而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象 * method3 的参数分析与 method2 相同 ![image-20200420131208734](/resources/技术收录/Java/java并发/image-20200420131208734.png) 方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会代理线程安全问题？ * 情况 1 ：有其它线程调用 method2 和 method3 * 情况 2 ：在 情况 1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即  java class ThreadSafe { public final void method1(int loopNumber) { ArrayList list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; loopNumber; i++) { method2(list); method3(list); } } private void method2(ArrayList list) { list.add(\u0026ldquo;1\u0026rdquo;); } private void method3(ArrayList list) { list.remove(0); } } class ThreadSafeSubClass extends ThreadSafe{ @Override public void method3(ArrayList list) { new Thread(() -\u0026gt; { list.remove(0); }).start(); } } public class TestThreadSafe { static final int THREAD_NUMBER = 2; static final int LOOP_NUMBER = 200; public static void main(String[] args) { ThreadSafeSubClass test = new ThreadSafeSubClass(); for (int i = 0; i \u0026lt; THREAD_NUMBER; i++) { new Thread(() -\u0026gt; { test.method1(LOOP_NUMBER); }, \u0026ldquo;Thread\u0026rdquo; + (i+1)).start(); } } }\n \u0026gt; 从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】 ### 常见线程安全类 \u0026gt; String \u0026gt; Integer \u0026gt; StringBuffer \u0026gt; Random \u0026gt; Vector \u0026gt; Hashtable \u0026gt; java.util.concurrent 包下的类 这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为  java Hashtable table = new Hashtable(); new Thread(()-\u0026gt;{ table.put(\u0026ldquo;key\u0026rdquo;, \u0026ldquo;value1\u0026rdquo;); }).start(); new Thread(()-\u0026gt;{ table.put(\u0026ldquo;key\u0026rdquo;, \u0026ldquo;value2\u0026rdquo;); }).start();\n * 它们的每个方法是原子的 * 但注意它们多个方法的组合不是原子的，见后面分析 **线程安全类方法的组合** 分析下面代码是否线程安全？  java Hashtable table = new Hashtable(); // 线程1，线程2 if( table.get(\u0026ldquo;key\u0026rdquo;) == null) { table.put(\u0026ldquo;key\u0026rdquo;, value); }\n ![image-20200620201831733](/../content/posts/java并发编程.assets/image-20200620201831733.png)  mermaid sequenceDiagram participant 线程1 participant 线程2 participant table1 participant table2 线程1-\u0026gt;table2:get(\u0026ldquo;key\u0026rdquo;)==null 线程2-\u0026gt;table2:get(\u0026ldquo;key\u0026rdquo;)==null 线程2-\u0026gt;table2:put(\u0026ldquo;key\u0026rdquo;,v2) 线程1-\u0026gt;table2:put(\u0026ldquo;key\u0026rdquo;,v1)\n ### 不可变类线程安全性 String、Integer 等都是不可变类，因为其内部的状态（属性）不可以改变，因此它们的方法都是线程安全的 有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安全的呢？  java public class Immutable{ private int value = 0; public Immutable(int value){ this.value = value; } public int getValue(){ return this.value; } }\n 如果想增加一个增加的方法呢？  java public class Immutable{ private int value = 0; public Immutable(int value){ this.value = value; } public int getValue(){ return this.value; }\npublic Immutable add(int v){ return new Immutable(this.value + v); }  }\n ### 实例分析 例 1 ：  java public class MyServlet extends HttpServlet { // 是否安全？不是 Map map = new HashMap\u0026lt;\u0026gt;(); // 是否安全？是 String S1 = \u0026ldquo;\u0026hellip;\u0026rdquo;; // 是否安全？是 final String S2 = \u0026ldquo;\u0026hellip;\u0026rdquo;; // 是否安全？不是 Date D1 = new Date(); // 是否安全？不是（引用是不可变的，但是日期内部的值(引用的对象改变了)是可以变化的） final Date D2 = new Date(); public void doGet(HttpServletRequest request, HttpServletResponse response) { // 使用上述变量 } }\n 例 2 ：  java public class MyServlet extends HttpServlet { // 是否安全？不是 private UserService userService = new UserServiceImpl();\npublic void doGet(HttpServletRequest request, HttpServletResponse response) { userService.update(...); }  } public class UserServiceImpl implements UserService { // 记录调用次数 private int count = 0; public void update() { // \u0026hellip; count++; } }\n 例 3 ：  java @Aspect @Component public class MyAspect { // 是否安全？不是；是单例的，意味着该类被共享，那么类中的成员变量也要被共享 private long start = 0L;\n@Before(\u0026quot;execution(* *(..))\u0026quot;) public void before() { start = System.nanoTime(); } @After(\u0026quot;execution(* *(..))\u0026quot;) public void after() { long end = System.nanoTime(); System.out.println(\u0026quot;cost time:\u0026quot; + (end-start)); }  }\n 例 4 ：  java public class MyServlet extends HttpServlet { // 是否安全，是：UserService虽然有成员变量，但它是私有的不能修改，也意味着它是不可变的 private UserService userService = new UserServiceImpl(); public void doGet(HttpServletRequest request, HttpServletResponse response) { userService.update(\u0026hellip;); } } public class UserServiceImpl implements UserService { // 是否安全:是，虽然它是成员变量，能被共享，但是它中没有可更改的属性（无状态的，无状态的一般都是线程安全的） private UserDao userDao = new UserDaoImpl(); public void update() { userDao.update(); } } public class UserDaoImpl implements UserDao { public void update() { String sql = \u0026ldquo;update user set password = ? where username = ?\u0026rdquo;; // 是否安全，是：，没有成员变量的类，一般都是线程安全的 try (Connection conn = DriverManager.getConnection(\u0026ldquo;\u0026rdquo;,\u0026ldquo;\u0026rdquo;,\u0026ldquo;\u0026rdquo;)){ // \u0026hellip; } catch (Exception e) { // \u0026hellip; } } }\n 例 5 ：  java public class MyServlet extends HttpServlet { // 是否安全 private UserService userService = new UserServiceImpl();\npublic void doGet(HttpServletRequest request, HttpServletResponse response) { userService.update(...); }  } public class UserServiceImpl implements UserService { // 是否安全 private UserDao userDao = new UserDaoImpl();\npublic void update() { userDao.update(); }  } public class UserDaoImpl implements UserDao { // 是否安全，否：没有将Connection作为方法内的局部变量，而是作为了类的成员变量 private Connection conn = null; public void update() throws SQLException { String sql = \u0026ldquo;update user set password = ? where username = ?\u0026rdquo;; conn = DriverManager.getConnection(\u0026ldquo;\u0026rdquo;,\u0026ldquo;\u0026rdquo;,\u0026ldquo;\u0026rdquo;); // \u0026hellip; conn.close(); } }\n 例 6 ：  java public class MyServlet extends HttpServlet { // 是否安全 private UserService userService = new UserServiceImpl();\npublic void doGet(HttpServletRequest request, HttpServletResponse response) { userService.update(\u0026hellip;); } } public class UserServiceImpl implements UserService { //线程安全：作为方法的局部变量 public void update() { UserDao userDao = new UserDaoImpl(); userDao.update(); } } public class UserDaoImpl implements UserDao { // 是否安全 private Connection = null; public void update() throws SQLException { String sql = \u0026ldquo;update user set password = ? where username = ?\u0026rdquo;; conn = DriverManager.getConnection(\u0026ldquo;\u0026rdquo;,\u0026ldquo;\u0026rdquo;,\u0026ldquo;\u0026rdquo;); // \u0026hellip; conn.close(); } }\n 例 7 ：  java public abstract class Test {\npublic void bar() { // 是否安全，否：虽然是局部变量，但是它还可能暴漏给其他线程 SimpleDateFormat sdf = new SimpleDateFormat(\u0026quot;yyyy-MM-dd HH:mm:ss\u0026quot;); foo(sdf); } public abstract foo(SimpleDateFormat sdf); public static void main(String[] args) { new Test().bar(); }  }\n 其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为**外星方法**  java public void foo(SimpleDateFormat sdf) { String dateStr = \u0026ldquo;1999-10-11 00:00:00\u0026rdquo;; for (int i = 0; i \u0026lt; 20; i++) { new Thread(() -\u0026gt; { try { sdf.parse(dateStr); } catch (ParseException e) { e.printStackTrace(); } }).start(); } }\n 请比较 JDK 中 String 类的实现  public final class String\n 为什么要定义成final：因为String本身是线程安全的，他的子类可能就会覆盖掉父类中的行为方法，导致不安全的发生（体现了闭合原则） 例 8 ：  java private static Integer i = 0; public static void main(String[] args) throws InterruptedException { List list = new ArrayList\u0026lt;\u0026gt;(); for (int j = 0; j \u0026lt; 2; j++) { Thread thread = new Thread(() -\u0026gt; { for (int k = 0; k \u0026lt; 5000; k++) { synchronized (i) { i++; } } }, \u0026ldquo;\u0026rdquo; + j); list.add(thread); } list.stream().forEach(t -\u0026gt; t.start()); list.stream().forEach(t -\u0026gt; { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); log.debug(\u0026ldquo;{}\u0026rdquo;, i); }\n ## 4.5 习题 ### 卖票练习 测试下面代码是否存在线程安全问题，并尝试改正 临界区：对共享变量有读写操作的代码片段称为临界区  java public class ExerciseSell { public static void main(String[] args) { //模拟多人买票 TicketWindow ticketWindow = new TicketWindow(2000); //使用的是ArrayList而不是线程安全的Vector是因为：list只会在主线程中使用，并没有被多个线程所共享 List list = new ArrayList\u0026lt;\u0026gt;(); // 用来存储买出去多少张票 List sellCount = new Vector\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 2000; i++) { Thread t = new Thread(() -\u0026gt; { // 分析这里的竞态条件 //非线程安全 int count = ticketWindow.sell(randomAmount());\n //线程安全的 sellCount.add(count); //不需要考虑二者的方法组合的线程安全问题：因为二者是两个不同的共享变量，他俩二者没有关系 }); //不影响 list.add(t); t.start(); } list.forEach((t) -\u0026gt; { try { //等待每一个线程都结束 t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); // 卖出去的票求和 log.debug(\u0026quot;selled count:{}\u0026quot;,sellCount.stream().mapToInt(c -\u0026gt; c).sum()); // 剩余票数 log.debug(\u0026quot;remainder count:{}\u0026quot;, ticketWindow.getCount()); } // Random 为线程安全 static Random random = new Random(); // 随机 1~5 public static int randomAmount() { return random.nextInt(5) + 1; }  } class TicketWindow { private int count; public TicketWindow(int count) { this.count = count; } public int getCount() { return count; } //属于临界区需要保护 /public int sell(int amount) { if (this.count \u0026gt;= amount) { this.count -= amount; return amount; } else { return 0; } }/ //对this对象进行加锁，保证线程安全 public synchronized int sell(int amount) { if (this.count \u0026gt;= amount) { this.count -= amount; return amount; } else { return 0; } } }\n 另外，用下面的代码行不行，为什么？  List sellCount = new ArrayList\u0026lt;\u0026gt;();\n 测试脚本  shell for /L %n in (1,1,10) do java -cp \u0026ldquo;.;C:\\Users\\manyh.m2\\repository\\ch\\qos\\logback\\logback\u0002classic\\1.2.3\\logback-classic-1.2.3.jar;C:\\Users\\manyh.m2\\repository\\ch\\qos\\logback\\logback\u0002core\\1.2.3\\logback-core-1.2.3.jar;C:\\Users\\manyh.m2\\repository\\org\\slf4j\\slf4j\u0002api\\1.7.25\\slf4j-api-1.7.25.jar\u0026rdquo; cn.itcast.n4.exercise.ExerciseSell\n ### 转账练习 测试下面代码是否存在线程安全问题，并尝试改正  java public class ExerciseTransfer { public static void main(String[] args) throws InterruptedException { Account a = new Account(1000); Account b = new Account(1000); Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { a.transfer(b, randomAmount()); } }, \u0026ldquo;t1\u0026rdquo;); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 1000; i++) { b.transfer(a, randomAmount()); } }, \u0026ldquo;t2\u0026rdquo;); t1.start(); t2.start(); t1.join(); t2.join(); // 查看转账2000次后的总金额 log.debug(\u0026ldquo;total:{}\u0026ldquo;,(a.getMoney() + b.getMoney())); } // Random 为线程安全 static Random random = new Random(); // 随机 1~100 public static int randomAmount() { return random.nextInt(100) +1; } } class Account { private int money; public Account(int money) { this.money = money; } public int getMoney() { return money; } public void setMoney(int money) { this.money = money; } //加锁，共享变量为：this.money和target中的money着两个对象，不能对这两个对象分别进行加锁，这样的话没用；二者有一个共同的属性Account这个类，因此可以对Account.class进行加锁。（效率不高，后面会详解） public void transfer(Account target, int amount) { /if (this.money \u0026gt; amount) { this.setMoney(this.getMoney() - amount); target.setMoney(target.getMoney() + amount); }/ synchronized(Account.class) { if (this.money \u0026gt;= amount) { this.setMoney(this.getMoney() - amount); target.setMoney(target.getMoney() + amount); } } } }\n 这样改正行不行，为什么？  java public synchronized void transfer(Account target, int amount) { if (this.money \u0026gt; amount) { this.setMoney(this.getMoney() - amount); target.setMoney(target.getMoney() + amount); } }\n 不行这样只是对synchronized（this）{}进行加锁 ## 4.6 Monitor 概念 ### Java 对象头 以 32 位虚拟机为例 Integer:8（对象头）+4（值） int:4 普通对象  java |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;| | Object Header (64 bits) | |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-| | Mark Word (32 bits) | Klass Word (32 bits)\t| |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-|\n Klass Word：指针，指向了该对象的class（该对象是什么类型的） Mark Word:见下面解析 数组对象  java |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;| | Object Header (96 bits) | |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;| | Mark Word(32bits)\t| Klass Word(32bits) | array length(32bits) | |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;|\n 其中 Mark Word 结构为  java |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;| | Mark Word (32 bits) | State | |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;| | hashcode:25 | age:4 | biased_lock:0 | 01 | Normal\t| |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;| | thread:23 | epoch:2 | age:4 | biased_lock:1 | 01 | Biased | |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;| | ptr_to_lock_record:30\t| 00 | Lightweight Locked | |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;| | ptr_to_heavyweight_monitor:30\t| 10 | Heavyweight Locked | |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;| | | 11 | Marked for GC| |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\n 普通对象是Normal；hashcode为hash值、age为垃圾回收的分代年龄、biased_lock对象是否启用偏向锁标记 当对象与系统的monitor关联后变为Heavyweight Locked；其中ptr_to_heavyweight_monitor存储的是指向monitor的指针 64 位虚拟机 Mark Word  java \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;| | Mark Word (64 bits) | State | |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;| | unused:25 | hashcode:31 | unused:1 | age:4 | biased_lock:0 | 01 | Normal | |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;| | thread:54 | epoch:2 | unused:1 | age:4 | biased_lock:1 | 01 | Biased | |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;| | ptr_to_lock_record:62 | 00 | Lightweight Locked | |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;| | ptr_to_heavyweight_monitor:62 | 10 | Heavyweight Locked | |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;| | | 11 | Marked for GC | |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\n - **原理之 Monitor(锁)** - 原理之 synchronized ### 小故事 故事角色 * 老王 - JVM * 小南 - 线程 * 小女 - 线程 * 房间 - 对象 * 房间门上 - 防盗锁 - Monitor * 房间门上 - 小南书包 - 轻量级锁 * 房间门上 - 刻上小南大名 - 偏向锁 * 批量重刻名 - 一个类的偏向锁撤销到达 20 阈值 * 不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向 小南要使用房间保证计算不被其它人干扰（原子性），最初，他用的是防盗锁，当上下文切换时，锁住门。这样，即使他离开了，别人也进不了门，他的工作就是安全的。 但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女晚上用。每次上锁太麻烦了，有没有更简单的办法呢？ 小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因此每次进门前得翻翻书包，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是自己的，那么就在门外等，并通知对方下次用锁门的方式。 后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍然觉得麻烦。 于是，小南干脆在门上刻上了自己的名字：【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦掉，升级为挂书包的方式。 同学们都放假回老家了，小南就膨胀了，在 20 个房间刻上了自己的名字，想进哪个进哪个。后来他自己放假回老家了，这时小女回来了（她也要用这些房间），结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字 后来，刻名的现象越来越频繁，老王受不了了：算了，这些房间都不能刻名了，只能挂书包 - 原理之 synchronized 进阶 ## 4.7 wait notify 小故事 - 为什么需要 wait * 由于条件不满足，小南不能继续进行计算 * 但小南如果一直占用着锁，其它人就得一直阻塞，效率太低 * 于是老王单开了一间休息室（调用 wait 方法），让小南到休息室（WaitSet）等着去了，但这时锁释放开， * 其它人可以由老王随机安排进屋 * 直到小M将烟送来，大叫一声 [ 你的烟到了 ] （调用 notify 方法） * 小南于是可以离开休息室，重新进入竞争锁的队列 **原理之 wait / notify** ### API 介绍 * obj.wait() 让进入 object 监视器的线程到 waitSet 等待 * obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒（随机挑选） * obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒 它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法 直接调用obj.wait()方法会报错的，这是因为obj对象还没有上锁，还没有和monitor进行关联。因此wait方法一定是要在同步代码块中执行的。  java final static Object obj = new Object(); public static void main(String[] args) { new Thread(() -\u0026gt; { synchronized (obj) { log.debug(\u0026ldquo;执行\u0026hellip;.\u0026rdquo;); try { obj.wait(); // 让线程在obj上一直等待下去 } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\u0026ldquo;其它代码\u0026hellip;.\u0026rdquo;); } }).start(); new Thread(() -\u0026gt; { synchronized (obj) { log.debug(\u0026ldquo;执行\u0026hellip;.\u0026rdquo;); try { obj.wait(); // 让线程在obj上一直等待下去 } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\u0026ldquo;其它代码\u0026hellip;.\u0026rdquo;); } }).start(); // 主线程两秒后执行 sleep(2); log.debug(\u0026ldquo;唤醒 obj 上其它线程\u0026rdquo;); synchronized (obj) { obj.notify(); // 唤醒obj上一个线程 // obj.notifyAll(); // 唤醒obj上所有等待线程 } }\n notify 的一种结果  20:00:53.096 [Thread-0] c.TestWaitNotify - 执行\u0026hellip;. 20:00:53.099 [Thread-1] c.TestWaitNotify - 执行\u0026hellip;. 20:00:55.096 [main] c.TestWaitNotify - 唤醒 obj 上其它线程 20:00:55.096 [Thread-0] c.TestWaitNotify - 其它代码\u0026hellip;.\n notifyAll 的结果  19:58:15.457 [Thread-0] c.TestWaitNotify - 执行\u0026hellip;. 19:58:15.460 [Thread-1] c.TestWaitNotify - 执行\u0026hellip;. 19:58:17.456 [main] c.TestWaitNotify - 唤醒 obj 上其它线程 19:58:17.456 [Thread-1] c.TestWaitNotify - 其它代码\u0026hellip;. 19:58:17.456 [Thread-0] c.TestWaitNotify - 其它代码\u0026hellip;.\n wait() 方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到notify 为止 * wait(long n) 有时限的等待, 到 n 毫秒后结束等待，或是被 notify（wait无参或0都是无限等待下去） ## 4.8 wait notify 的正确姿势 开始之前先看看 ### sleep(long n) 和 wait(long n) 的区别 * 1）sleep 是 Thread 的静态方法，而 wait 是 Object 的方法 * 2) sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 * 3) sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 4) 它们状态 TIMED_WAITING * 4） 他们的状态都是TIMED_WATING  java @Slf4j(topic = \u0026ldquo;c.Test19\u0026rdquo;) public class Test19 { static final Object lock = new Object(); public static void main(String[] args) { new Thread(() -\u0026gt; { synchronized (lock) { log.debug(\u0026ldquo;获得锁\u0026rdquo;); try { // Thread.sleep(20000); lock.wait(20000); } catch (InterruptedException e) { e.printStackTrace(); } } }, \u0026ldquo;t1\u0026rdquo;).start();\n Sleeper.sleep(1); synchronized (lock) { log.debug(\u0026quot;获得锁\u0026quot;); } }  }\n step 1  static final Object room = new Object(); static boolean hasCigarette = false; static boolean hasTakeout = false;\n 思考下面的解决方案好不好，为什么？  java new Thread(() -\u0026gt; { synchronized (room) { log.debug(\u0026ldquo;有烟没？[{}]\u0026ldquo;, hasCigarette); if (!hasCigarette) { log.debug(\u0026ldquo;没烟，先歇会！\u0026rdquo;); sleep(2); } log.debug(\u0026ldquo;有烟没？[{}]\u0026ldquo;, hasCigarette); if (hasCigarette) { log.debug(\u0026ldquo;可以开始干活了\u0026rdquo;); } } }, \u0026ldquo;小南\u0026rdquo;).start(); for (int i = 0; i \u0026lt; 5; i++) { new Thread(() -\u0026gt; { synchronized (room) { log.debug(\u0026ldquo;可以开始干活了\u0026rdquo;); } }, \u0026ldquo;其它人\u0026rdquo;).start(); } sleep(1); new Thread(() -\u0026gt; { // 这里能不能加 synchronized (room)？ hasCigarette = true; log.debug(\u0026ldquo;烟到了噢！\u0026rdquo;); }, \u0026ldquo;送烟的\u0026rdquo;).start();\n 输出  20:49:49.883 [小南] c.TestCorrectPosture - 有烟没？[false] 20:49:49.887 [小南] c.TestCorrectPosture - 没烟，先歇会！ 20:49:50.882 [送烟的] c.TestCorrectPosture - 烟到了噢！ 20:49:51.887 [小南] c.TestCorrectPosture - 有烟没？[true] 20:49:51.887 [小南] c.TestCorrectPosture - 可以开始干活了 20:49:51.887 [其它人] c.TestCorrectPosture - 可以开始干活了 20:49:51.887 [其它人] c.TestCorrectPosture - 可以开始干活了 20:49:51.888 [其它人] c.TestCorrectPosture - 可以开始干活了 20:49:51.888 [其它人] c.TestCorrectPosture - 可以开始干活了 20:49:51.888 [其它人] c.TestCorrectPosture - 可以开始干活了\n * 其它干活的线程，都要一直阻塞，效率太低 * 小南线程必须睡足 2s 后才能醒来，就算烟提前送到，也无法立刻醒来 * 加了 synchronized (room) 后，就好比小南在里面反锁了门睡觉，烟根本没法送进门，main 没加 synchronized 就好像 main 线程是翻窗户进来的 * 解决方法，使用 wait - notify 机制 step 2 思考下面的实现行吗，为什么？  java new Thread(() -\u0026gt; { synchronized (room) { log.debug(\u0026ldquo;有烟没？[{}]\u0026ldquo;, hasCigarette); if (!hasCigarette) { log.debug(\u0026ldquo;没烟，先歇会！\u0026rdquo;); try { room.wait(2000); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\u0026ldquo;有烟没？[{}]\u0026ldquo;, hasCigarette); if (hasCigarette) { log.debug(\u0026ldquo;可以开始干活了\u0026rdquo;); } } }, \u0026ldquo;小南\u0026rdquo;).start(); for (int i = 0; i \u0026lt; 5; i++) { new Thread(() -\u0026gt; { synchronized (room) { log.debug(\u0026ldquo;可以开始干活了\u0026rdquo;); } }, \u0026ldquo;其它人\u0026rdquo;).start(); } sleep(1); new Thread(() -\u0026gt; { synchronized (room) { hasCigarette = true; log.debug(\u0026ldquo;烟到了噢！\u0026rdquo;); room.notify(); } }, \u0026ldquo;送烟的\u0026rdquo;).start();\n 输出  20:51:42.489 [小南] c.TestCorrectPosture - 有烟没？[false] 20:51:42.493 [小南] c.TestCorrectPosture - 没烟，先歇会！ 20:51:42.493 [其它人] c.TestCorrectPosture - 可以开始干活了 20:51:42.493 [其它人] c.TestCorrectPosture - 可以开始干活了 20:51:42.494 [其它人] c.TestCorrectPosture - 可以开始干活了 20:51:42.494 [其它人] c.TestCorrectPosture - 可以开始干活了 20:51:42.494 [其它人] c.TestCorrectPosture - 可以开始干活了 20:51:43.490 [送烟的] c.TestCorrectPosture - 烟到了噢！ 20:51:43.490 [小南] c.TestCorrectPosture - 有烟没？[true] 20:51:43.490 [小南] c.TestCorrectPosture - 可以开始干活了\n * 解决了其它干活的线程阻塞的问题 * 但如果有其它线程也在等待条件呢？ step 3  java new Thread(() -\u0026gt; { synchronized (room) { log.debug(\u0026ldquo;有烟没？[{}]\u0026ldquo;, hasCigarette); if (!hasCigarette) { log.debug(\u0026ldquo;没烟，先歇会！\u0026rdquo;); try { room.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\u0026ldquo;有烟没？[{}]\u0026ldquo;, hasCigarette); if (hasCigarette) { log.debug(\u0026ldquo;可以开始干活了\u0026rdquo;); } else { log.debug(\u0026ldquo;没干成活\u0026hellip;\u0026rdquo;); } } }, \u0026ldquo;小南\u0026rdquo;).start(); new Thread(() -\u0026gt; { synchronized (room) { Thread thread = Thread.currentThread(); log.debug(\u0026ldquo;外卖送到没？[{}]\u0026ldquo;, hasTakeout); if (!hasTakeout) { log.debug(\u0026ldquo;没外卖，先歇会！\u0026rdquo;); try { room.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\u0026ldquo;外卖送到没？[{}]\u0026ldquo;, hasTakeout); if (hasTakeout) { log.debug(\u0026ldquo;可以开始干活了\u0026rdquo;); } else { log.debug(\u0026ldquo;没干成活\u0026hellip;\u0026rdquo;); } } }, \u0026ldquo;小女\u0026rdquo;).start(); sleep(1); new Thread(() -\u0026gt; { synchronized (room) { hasTakeout = true; log.debug(\u0026ldquo;外卖到了噢！\u0026rdquo;); room.notify(); } }, \u0026ldquo;送外卖的\u0026rdquo;).start();\n 输出  20:53:12.173 [小南] c.TestCorrectPosture - 有烟没？[false] 20:53:12.176 [小南] c.TestCorrectPosture - 没烟，先歇会！ 20:53:12.176 [小女] c.TestCorrectPosture - 外卖送到没？[false] 20:53:12.176 [小女] c.TestCorrectPosture - 没外卖，先歇会！ 20:53:13.174 [送外卖的] c.TestCorrectPosture - 外卖到了噢！ 20:53:13.174 [小南] c.TestCorrectPosture - 有烟没？[false] 20:53:13.174 [小南] c.TestCorrectPosture - 没干成活\u0026hellip;\n * notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程，称之为【虚假唤醒】 * 解决方法，改为 notifyAll step 4  java new Thread(() -\u0026gt; { synchronized (room) { hasTakeout = true; log.debug(\u0026ldquo;外卖到了噢！\u0026rdquo;); room.notifyAll(); } }, \u0026ldquo;送外卖的\u0026rdquo;).start();\n 输出  20:55:23.978 [小南] c.TestCorrectPosture - 有烟没？[false] 20:55:23.982 [小南] c.TestCorrectPosture - 没烟，先歇会！ 20:55:23.982 [小女] c.TestCorrectPosture - 外卖送到没？[false] 20:55:23.982 [小女] c.TestCorrectPosture - 没外卖，先歇会！ 20:55:24.979 [送外卖的] c.TestCorrectPosture - 外卖到了噢！ 20:55:24.979 [小女] c.TestCorrectPosture - 外卖送到没？[true] 20:55:24.980 [小女] c.TestCorrectPosture - 可以开始干活了 20:55:24.980 [小南] c.TestCorrectPosture - 有烟没？[false] 20:55:24.980 [小南] c.TestCorrectPosture - 没干成活\u0026hellip;\n * 用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新判断的机会了 * 解决方法，用 while + wait，当条件不成立，再次 wait step 5 将 if 改为 while  java if (!hasCigarette) { log.debug(\u0026ldquo;没烟，先歇会！\u0026rdquo;); try { room.wait(); } catch (InterruptedException e) { e.printStackTrace(); } }\n 改动后  java while (!hasCigarette) { log.debug(\u0026ldquo;没烟，先歇会！\u0026rdquo;); try { room.wait(); } catch (InterruptedException e) { e.printStackTrace(); } }\n 输出  20:58:34.322 [小南] c.TestCorrectPosture - 有烟没？[false] 20:58:34.326 [小南] c.TestCorrectPosture - 没烟，先歇会！ 20:58:34.326 [小女] c.TestCorrectPosture - 外卖送到没？[false] 20:58:34.326 [小女] c.TestCorrectPosture - 没外卖，先歇会！ 20:58:35.323 [送外卖的] c.TestCorrectPosture - 外卖到了噢！ 20:58:35.324 [小女] c.TestCorrectPosture - 外卖送到没？[true] 20:58:35.324 [小女] c.TestCorrectPosture - 可以开始干活了 20:58:35.324 [小南] c.TestCorrectPosture - 没烟，先歇会！\n  java synchronized(lock) { while(条件不成立) { lock.wait(); } // 干活 } //另一个线程 synchronized(lock) { lock.notifyAll(); }\n * **模式之保护性暂停** * **模式之生产者消费者** ## 4.9 Park \u0026amp; Unpark ### 基本使用 它们是 LockSupport 类中的方法  java // 暂停当前线程 LockSupport.park(); // 恢复某个线程的运行 可以在暂停之前调用，也可以在线程之后调用 LockSupport.unpark(暂停线程对象)\n 先 park 再 unpark  java Thread t1 = new Thread(() -\u0026gt; { log.debug(\u0026ldquo;start\u0026hellip;\u0026rdquo;); sleep(1); log.debug(\u0026ldquo;park\u0026hellip;\u0026rdquo;); LockSupport.park(); log.debug(\u0026ldquo;resume\u0026hellip;\u0026rdquo;); },\u0026ldquo;t1\u0026rdquo;); t1.start(); sleep(2); log.debug(\u0026ldquo;unpark\u0026hellip;\u0026rdquo;); LockSupport.unpark(t1);\n 输出  18:42:52.585 c.TestParkUnpark [t1] - start\u0026hellip; 18:42:53.589 c.TestParkUnpark [t1] - park\u0026hellip; 18:42:54.583 c.TestParkUnpark [main] - unpark\u0026hellip; 18:42:54.583 c.TestParkUnpark [t1] - resume\u0026hellip;\n 先 unpark 再 park  java Thread t1 = new Thread(() -\u0026gt; { log.debug(\u0026ldquo;start\u0026hellip;\u0026rdquo;); sleep(2); log.debug(\u0026ldquo;park\u0026hellip;\u0026rdquo;); LockSupport.park(); log.debug(\u0026ldquo;resume\u0026hellip;\u0026rdquo;); }, \u0026ldquo;t1\u0026rdquo;); t1.start(); sleep(1); log.debug(\u0026ldquo;unpark\u0026hellip;\u0026rdquo;); LockSupport.unpark(t1);\n 输出  18:43:50.765 c.TestParkUnpark [t1] - start\u0026hellip; 18:43:51.764 c.TestParkUnpark [main] - unpark\u0026hellip; 18:43:52.769 c.TestParkUnpark [t1] - park\u0026hellip; 18:43:52.769 c.TestParkUnpark [t1] - resume\u0026hellip;\n ### 特点 与 Object 的 wait \u0026amp; notify 相比 * wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用（在同步代码块中使用），而 park，unpark 不必 * park \u0026amp; unpark是以线程为单位来【阻塞】和【唤醒】线程，而 notify只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 * park \u0026amp; unpark 可以先 unpark，而 wait \u0026amp; notify 不能先 notify *** 原理之 park \u0026amp; unpark** ## 4.10 重新理解线程状态转换 ![image-20200420133945020](/resources/技术收录/Java/java并发/image-20200420133945020.png) 假设有线程 Thread t ### 情况 1 NEW --\u0026gt; RUNNABLE * 当调用 t.start() 方法时，由 NEW --\u0026gt; RUNNABLE ### 情况 2 RUNNABLE \u0026lt;--\u0026gt; WAITING t 线程用 synchronized(obj) 获取了对象锁后 * 调用 obj.wait() 方法时，t 线程从 RUNNABLE --\u0026gt; WAITING * 调用 obj.notify()，obj.notifyAll()，t.interrupt() 时 * 竞争锁成功，t 线程从 WAITING --\u0026gt; RUNNABLE * 竞争锁失败，t 线程从 WAITING --\u0026gt; BLOCKED  java @Slf4j(topic = \u0026ldquo;c.TestWaitNotify\u0026rdquo;) public class TestWaitNotify { final static Object obj = new Object(); public static void main(String[] args) { new Thread(() -\u0026gt; { synchronized (obj) { log.debug(\u0026ldquo;执行\u0026hellip;.\u0026rdquo;); try { obj.wait(); // 让线程在obj上一直等待下去 } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\u0026ldquo;其它代码\u0026hellip;.\u0026rdquo;); } },\u0026ldquo;t1\u0026rdquo;).start(); new Thread(() -\u0026gt; { synchronized (obj) { log.debug(\u0026ldquo;执行\u0026hellip;.\u0026rdquo;); try { obj.wait(); // 让线程在obj上一直等待下去 } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\u0026ldquo;其它代码\u0026hellip;.\u0026rdquo;); } },\u0026ldquo;t2\u0026rdquo;).start(); // 主线程两秒后执行 sleep(0.5); log.debug(\u0026ldquo;唤醒 obj 上其它线程\u0026rdquo;); synchronized (obj) { // obj.notify(); // 唤醒obj上一个线程 obj.notifyAll(); // 唤醒obj上所有等待线程 } } }\n ### 情况 3 RUNNABLE \u0026lt;--\u0026gt; WAITING * 当前线程调用 t.join() 方法时，当前线程从 RUNNABLE --\u0026gt; WAITING * 注意是当前线程在t 线程对象的监视器上等待 * t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING --\u0026gt; RUNNABLE ### 情况 4 RUNNABLE \u0026lt;--\u0026gt; WAITING * 当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE --\u0026gt; WAITING * 调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt()，会让目标线程从 WAITING --\u0026gt; RUNNABLE ### 情况 5 RUNNABLE \u0026lt;--\u0026gt; TIMED_WAITING t 线程用 synchronized(obj) 获取了对象锁后 * 调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE --\u0026gt; TIMED_WAITING * t 线程等待时间超过了 n 毫秒，或调用 obj.notify()，obj.notifyAll()，t.interrupt() 时 * 竞争锁成功，t 线程从 TIMED_WAITING --\u0026gt; RUNNABLE * 竞争锁失败，t 线程从 TIMED_WAITING --\u0026gt; BLOCKED ### 情况 6 RUNNABLE \u0026lt;--\u0026gt; TIMED_WAITING * 当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE --\u0026gt; TIMED_WAITING * 注意是当前线程在t 线程对象的监视器上等待 * 当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从TIMED_WAITING --\u0026gt; RUNNABLE ### 情况 7 RUNNABLE \u0026lt;--\u0026gt; TIMED_WAITING * 当前线程调用 Thread.sleep(long n)，当前线程从 RUNNABLE --\u0026gt; TIMED_WAITING * 当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING --\u0026gt; RUNNABLE ### 情况 8 RUNNABLE \u0026lt;--\u0026gt; TIMED_WAITING * 当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线程从 RUNNABLE --\u0026gt; TIMED_WAITING * 调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt()，或是等待超时，会让目标线程从TIMED_WAITING--\u0026gt; RUNNABLE ### 情况 9 RUNNABLE \u0026lt;--\u0026gt; BLOCKED * t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE --\u0026gt; BLOCKED * 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED --\u0026gt; RUNNABLE，其它失败的线程仍然 BLOCKED ### 情况 10 RUNNABLE \u0026lt;--\u0026gt; TERMINATED 当前线程所有代码运行完毕，进入TERMINATED ## 4.11 多把锁 ### 多把不相干的锁 一间大屋子有两个功能：睡觉、学习，互不相干。 现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低 解决方法是准备多个房间（多个对象锁） 例如  java class BigRoom { public void sleep() { synchronized (this) { log.debug(\u0026ldquo;sleeping 2 小时\u0026rdquo;); Sleeper.sleep(2); } } public void study() { synchronized (this) { log.debug(\u0026ldquo;study 1 小时\u0026rdquo;); Sleeper.sleep(1); } } }\n 执行  java BigRoom bigRoom = new BigRoom(); new Thread(() -\u0026gt; { bigRoom.compute(); },\u0026ldquo;小南\u0026rdquo;).start(); new Thread(() -\u0026gt; { bigRoom.sleep(); },\u0026ldquo;小女\u0026rdquo;).start();\n 某次结果  12:13:54.471 [小南] c.BigRoom - study 1 小时 12:13:55.476 [小女] c.BigRoom - sleeping 2 小时\n 改进  java class BigRoom { private final Object studyRoom = new Object(); private final Object bedRoom = new Object(); public void sleep() { synchronized (bedRoom) { log.debug(\u0026ldquo;sleeping 2 小时\u0026rdquo;); Sleeper.sleep(2); } } public void study() { synchronized (studyRoom) { log.debug(\u0026ldquo;study 1 小时\u0026rdquo;); Sleeper.sleep(1); } } }\n 某次执行结果  12:15:35.069 [小南] c.BigRoom - study 1 小时 12:15:35.069 [小女] c.BigRoom - sleeping 2 小时\n 二者之间没有相互关联 将锁的粒度细分 * 好处，是可以增强并发度 * 坏处，如果一个线程需要同时获得多把锁，就容易发生死锁 ## 4.12 活跃性 ### 死锁 有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁 t1 线程 获得 A对象 锁，接下来想获取 B对象的锁 t2 线程 获得 B对象 锁，接下来想获取 A对象的锁 例：  java\n@Slf4j(topic = \u0026ldquo;c.TestDeadLock\u0026rdquo;) public class TestDeadLock { public static void main(String[] args) { test1(); } private static void test1() { Object A = new Object(); Object B = new Object(); Thread t1 = new Thread(() -\u0026gt; { synchronized (A) { log.debug(\u0026ldquo;lock A\u0026rdquo;); sleep(1); synchronized (B) { log.debug(\u0026ldquo;lock B\u0026rdquo;); log.debug(\u0026ldquo;操作\u0026hellip;\u0026rdquo;); } } }, \u0026ldquo;t1\u0026rdquo;); Thread t2 = new Thread(() -\u0026gt; { synchronized (B) { log.debug(\u0026ldquo;lock B\u0026rdquo;); sleep(0.5); synchronized (A) { log.debug(\u0026ldquo;lock A\u0026rdquo;); log.debug(\u0026ldquo;操作\u0026hellip;\u0026rdquo;); } } }, \u0026ldquo;t2\u0026rdquo;); t1.start(); t2.start(); } }\n 结果  12:22:06.962 [t2] c.TestDeadLock - lock B 12:22:06.962 [t1] c.TestDeadLock - lock A\n #### 定位死锁 * 检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁： ##### jps jps查看所有的java进程  cmd \u0026gt; jps Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8 12320 Jps 22816 KotlinCompileDaemon 33200 TestDeadLock // JVM 进程 11508 Main 28468 Launcher\n 查看进程信息  jstack 进程号\n  cmd \u0026gt; jstack 33200 Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8 2018-12-29 05:51:40 Full thread dump Java HotSpot\u0026trade; 64-Bit Server VM (25.91-b14 mixed mode): \u0026ldquo;DestroyJavaVM\u0026rdquo; #13 prio=5 os_prio=0 tid=0x0000000003525000 nid=0x2f60 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE \u0026ldquo;Thread-1\u0026rdquo; #12 prio=5 os_prio=0 tid=0x000000001eb69000 nid=0xd40 waiting for monitor entry [0x000000001f54f000] java.lang.Thread.State: BLOCKED (on object monitor) at thread.TestDeadLock.lambda$main$1(TestDeadLock.java:28) - waiting to lock  (a java.lang.Object) - locked  (a java.lang.Object) at thread.TestDeadLock$$Lambda$2\u0026frasl;883049899.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) \u0026ldquo;Thread-0\u0026rdquo; #11 prio=5 os_prio=0 tid=0x000000001eb68800 nid=0x1b28 waiting for monitor entry [0x000000001f44f000] java.lang.Thread.State: BLOCKED (on object monitor) at thread.TestDeadLock.lambda$main$0(TestDeadLock.java:15) - waiting to lock  (a java.lang.Object) - locked  (a java.lang.Object) at thread.TestDeadLock$$Lambda$1\u0026frasl;495053715.run(Unknown Source) at java.lang.Thread.run(Thread.java:745)\n// 略去部分输出\nFound one Java-level deadlock: \u0026ldquo;Thread-1\u0026rdquo;: waiting to lock monitor 0x000000000361d378 (object 0x000000076b5bf1c0, a java.lang.Object), which is held by \u0026ldquo;Thread-0\u0026rdquo; \u0026ldquo;Thread-0\u0026rdquo;: waiting to lock monitor 0x000000000361e768 (object 0x000000076b5bf1d0, a java.lang.Object), which is held by \u0026ldquo;Thread-1\u0026rdquo;\nJava stack information for the threads listed above: \u0026ldquo;Thread-1\u0026rdquo;: at thread.TestDeadLock.lambda$main$1(TestDeadLock.java:28) - waiting to lock  (a java.lang.Object) - locked  (a java.lang.Object) at thread.TestDeadLock$$Lambda$2\u0026frasl;883049899.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) \u0026ldquo;Thread-0\u0026rdquo;: at thread.TestDeadLock.lambda$main$0(TestDeadLock.java:15) - waiting to lock  (a java.lang.Object) - locked  (a java.lang.Object) at thread.TestDeadLock$$Lambda$1\u0026frasl;495053715.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) Found 1 deadlock.\n * 避免死锁要注意加锁顺序 * 另外如果由于某个线程进入了死循环，导致其它线程一直等待，对于这种情况 linux 下可以通过 top 先定位到CPU 占用高的 Java 进程，再利用 top -Hp 进程id 来定位是哪个线程，最后再用 jstack 排查 ##### jconsole  win +r :jconsole\n 图形化界面，线程--\u0026gt;检测死锁：查看死锁 ### 哲学家就餐问题 ![image-20200420134728979](/resources/技术收录/Java/java并发/image-20200420134728979.png) 有五位哲学家，围坐在圆桌旁。 * 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 * 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 * 如果筷子被身边的人拿着，自己就得等待 筷子类  java class Chopstick { String name; public Chopstick(String name) { this.name = name; } @Override public String toString() { return \u0026ldquo;筷子{\u0026rdquo; + name + \u0026lsquo;}\u0026rsquo;; } }\n 哲学家类  java\n@Slf4j(topic = \u0026ldquo;c.Philosopher\u0026rdquo;) class Philosopher extends Thread { Chopstick left; Chopstick right; public Philosopher(String name, Chopstick left, Chopstick right) { super(name); this.left = left; this.right = right; } @Override public void run() { while (true) { //　尝试获得左手筷子 synchronized (left) { // 尝试获得右手筷子 synchronized (right) { eat(); } } } } Random random = new Random(); private void eat() { log.debug(\u0026ldquo;eating\u0026hellip;\u0026rdquo;); Sleeper.sleep(random.nextInt(5)); } }\n 就餐  java Chopstick c1 = new Chopstick(\u0026ldquo;1\u0026rdquo;); Chopstick c2 = new Chopstick(\u0026ldquo;2\u0026rdquo;); Chopstick c3 = new Chopstick(\u0026ldquo;3\u0026rdquo;); Chopstick c4 = new Chopstick(\u0026ldquo;4\u0026rdquo;); Chopstick c5 = new Chopstick(\u0026ldquo;5\u0026rdquo;); new Philosopher(\u0026ldquo;苏格拉底\u0026rdquo;, c1, c2).start(); new Philosopher(\u0026ldquo;柏拉图\u0026rdquo;, c2, c3).start(); new Philosopher(\u0026ldquo;亚里士多德\u0026rdquo;, c3, c4).start(); new Philosopher(\u0026ldquo;赫拉克利特\u0026rdquo;, c4, c5).start(); new Philosopher(\u0026ldquo;阿基米德\u0026rdquo;, c5, c1).start();\n 执行不多会，就执行不下去了  12:33:15.575 [苏格拉底] c.Philosopher - eating\u0026hellip; 12:33:15.575 [亚里士多德] c.Philosopher - eating\u0026hellip; 12:33:16.580 [阿基米德] c.Philosopher - eating\u0026hellip; 12:33:17.580 [阿基米德] c.Philosopher - eating\u0026hellip; // 卡在这里, 不向下运行\n 使用 jconsole 检测死锁，发现  名称: 阿基米德 状态: cn.itcast.Chopstick@1540e19d (筷子1) 上的BLOCKED, 拥有者: 苏格拉底 总阻止数: 2, 总等待数: 1 堆栈跟踪: cn.itcast.Philosopher.run(TestDinner.java:48)\n- 已锁定 cn.itcast.Chopstick@6d6f6e28 (筷子5) 名称: 苏格拉底 状态: cn.itcast.Chopstick@677327b6 (筷子2) 上的BLOCKED, 拥有者: 柏拉图 总阻止数: 2, 总等待数: 1 堆栈跟踪: cn.itcast.Philosopher.run(TestDinner.java:48)\n- 已锁定 cn.itcast.Chopstick@1540e19d (筷子1) 名称: 柏拉图 状态: cn.itcast.Chopstick@14ae5a5 (筷子3) 上的BLOCKED, 拥有者: 亚里士多德 总阻止数: 2, 总等待数: 0 堆栈跟踪: cn.itcast.Philosopher.run(TestDinner.java:48)\n- 已锁定 cn.itcast.Chopstick@677327b6 (筷子2) 名称: 亚里士多德 状态: cn.itcast.Chopstick@7f31245a (筷子4) 上的BLOCKED, 拥有者: 赫拉克利特 总阻止数: 1, 总等待数: 1 堆栈跟踪: cn.itcast.Philosopher.run(TestDinner.java:48)\n- 已锁定 cn.itcast.Chopstick@14ae5a5 (筷子3) 名称: 赫拉克利特 状态: cn.itcast.Chopstick@6d6f6e28 (筷子5) 上的BLOCKED, 拥有者: 阿基米德 总阻止数: 2, 总等待数: 0 堆栈跟踪: cn.itcast.Philosopher.run(TestDinner.java:48) - 已锁定 cn.itcast.Chopstick@7f31245a (筷子4)\n 这种线程没有按预期结束，执行不下去的情况，归类为【活跃性】问题，除了死锁以外，还有活锁和饥饿者两种情况 死锁是由于互相持有对方想要的锁，导致谁都无法继续向下运行，都阻塞住了 活锁是，线程都没有阻塞住，都在使用CPU，都在不断地运行，改变对方地结束条件，导致结束不了 ### 活锁 活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束，例如  java @Slf4j(topic = \u0026ldquo;c.TestLiveLock\u0026rdquo;) public class TestLiveLock { static volatile int count = 10; static final Object lock = new Object();\npublic static void main(String[] args) { new Thread(() -\u0026gt; { // 期望减到 0 退出循环 while (count \u0026gt; 0) { sleep(0.2); count--; log.debug(\u0026quot;count: {}\u0026quot;, count); } }, \u0026quot;t1\u0026quot;).start(); new Thread(() -\u0026gt; { // 期望超过 20 退出循环 while (count \u0026lt; 20) { sleep(0.2); count++; log.debug(\u0026quot;count: {}\u0026quot;, count); } }, \u0026quot;t2\u0026quot;).start(); }  }\n 解决办法：增加随机地睡眠时间，避免活锁地产生 ### 饥饿 很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束，饥饿的情况不 易演示，讲读写锁时会涉及饥饿问题 下面我讲一下我遇到的一个线程饥饿的例子，先来看看使用顺序加锁的方式解决之前的死锁问题  mermaid sequenceDiagram # 通过设定参与者(participants)的顺序控制展示模块顺序 participant 线程1 participant 线程2 participant 对象A participant 对象B 线程1\u0026ndash;\u0026gt;对象A:尝试获取锁 note over 线程1,对象A: 拥有锁 线程2-\u0026gt;对象B:尝试获取锁 note over 线程2,对象B:拥有锁 线程1-\u0026gt;对象B:尝试获取锁 线程2-\u0026gt;对象A:尝试获取锁\n 顺序加锁的解决方案  mermaid sequenceDiagram # 通过设定参与者(participants)的顺序控制展示模块顺序 participant 线程1 participant 线程2 participant 对象A participant 对象B 线程1\u0026ndash;\u0026gt;对象A:尝试获取锁 note over 线程1,对象A: 拥有锁 线程2-\u0026gt;对象A:尝试获取锁 线程2-\u0026gt;对象A:阻塞 线程1-\u0026gt;对象B:尝试获取锁 note over 线程1,对象B:拥有锁\n  java\npublic class TestDeadLock { public static void main(String[] args) { Chopstick c1 = new Chopstick(\u0026ldquo;1\u0026rdquo;); Chopstick c2 = new Chopstick(\u0026ldquo;2\u0026rdquo;); Chopstick c3 = new Chopstick(\u0026ldquo;3\u0026rdquo;); Chopstick c4 = new Chopstick(\u0026ldquo;4\u0026rdquo;); Chopstick c5 = new Chopstick(\u0026ldquo;5\u0026rdquo;); new Philosopher(\u0026ldquo;苏格拉底\u0026rdquo;, c1, c2).start(); new Philosopher(\u0026ldquo;柏拉图\u0026rdquo;, c2, c3).start(); new Philosopher(\u0026ldquo;亚里士多德\u0026rdquo;, c3, c4).start(); new Philosopher(\u0026ldquo;赫拉克利特\u0026rdquo;, c4, c5).start(); new Philosopher(\u0026ldquo;阿基米德\u0026rdquo;, c1, c5).start(); } } @Slf4j(topic = \u0026ldquo;c.Philosopher\u0026rdquo;) class Philosopher extends Thread { Chopstick left; Chopstick right; public Philosopher(String name, Chopstick left, Chopstick right) { super(name); this.left = left; this.right = right; } @Override public void run() { while (true) { //　尝试获得左手筷子 synchronized (left) { // 尝试获得右手筷子 synchronized (right) { eat(); } } } } Random random = new Random(); private void eat() { log.debug(\u0026ldquo;eating\u0026hellip;\u0026rdquo;); Sleeper.sleep(0.5); } } class Chopstick { String name; public Chopstick(String name) { this.name = name; } @Override public String toString() { return \u0026ldquo;筷子{\u0026rdquo; + name + \u0026lsquo;}\u0026rsquo;; } }\n 虽然没有死锁，但是阿基米德执行地概率非常低，就是饥饿现象 ## 4.13 ReentrantLock 相对于 synchronized 它具备如下特点 * 可中断 * 可以设置超时时间（获取锁时获取不到直接进入entryList中等待，死等） * 可以设置为公平锁（防止线程饥饿，先进先出） * 支持多个条件变量（有多个休息室，waitSet） 与 synchronized 一样，都支持可重入(对一个对象进行重复加锁) synchronized 在关键字的级别保护临界区ReentrantLock在对象的级别保护临界区 基本语法  java //创建ReentrantLock对象 static ReentrantLock lock = new ReentrantLock(); // 获取锁 reentrantLock.lock(); try { // 临界区 } finally { // 释放锁 reentrantLock.unlock(); }\n ### 可重入 可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住  java static ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) { method1(); } public static void method1() { lock.lock(); try { log.debug(\u0026ldquo;execute method1\u0026rdquo;); method2(); } finally { lock.unlock(); } } public static void method2() { lock.lock(); try { log.debug(\u0026ldquo;execute method2\u0026rdquo;); method3(); } finally { lock.unlock(); } } public static void method3() { lock.lock(); try { log.debug(\u0026ldquo;execute method3\u0026rdquo;); } finally { lock.unlock(); } }\n 输出  17:59:11.862 [main] c.TestReentrant - execute method1 17:59:11.865 [main] c.TestReentrant - execute method2 17:59:11.865 [main] c.TestReentrant - execute method3\n ### 可打断 示例  java ReentrantLock lock = new ReentrantLock(); Thread t1 = new Thread(() -\u0026gt; { log.debug(\u0026ldquo;启动\u0026hellip;\u0026rdquo;); try { // 如果没有竞争那么此方法就会获取Lock对象 // 如果有竞争进入阻塞队列，可以被其他线程用interrupt方法打断 lock.lockInterruptibly(); } catch (InterruptedException e) { e.printStackTrace(); log.debug(\u0026ldquo;等锁的过程中被打断\u0026rdquo;); return; } try { log.debug(\u0026ldquo;获得了锁\u0026rdquo;); } finally { lock.unlock(); } }, \u0026ldquo;t1\u0026rdquo;); lock.lock(); log.debug(\u0026ldquo;获得了锁\u0026rdquo;); t1.start(); try { sleep(1); t1.interrupt();//打断锁，可以避免死锁地形成 log.debug(\u0026ldquo;执行打断\u0026rdquo;); } finally { lock.unlock(); }\n 输出  18:02:40.520 [main] c.TestInterrupt - 获得了锁 18:02:40.524 [t1] c.TestInterrupt - 启动\u0026hellip; 18:02:41.530 [main] c.TestInterrupt - 执行打断 java.lang.InterruptedException at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchr onizer.java:898) at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchron izer.java:1222) at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335) at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$0(TestInterrupt.java:17) at java.lang.Thread.run(Thread.java:748) 18:02:41.532 [t1] c.TestInterrupt - 等锁的过程中被打断\n 注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断  java ReentrantLock lock = new ReentrantLock(); Thread t1 = new Thread(() -\u0026gt; { log.debug(\u0026ldquo;启动\u0026hellip;\u0026rdquo;); lock.lock(); try { log.debug(\u0026ldquo;获得了锁\u0026rdquo;); } finally { lock.unlock(); } }, \u0026ldquo;t1\u0026rdquo;); lock.lock(); log.debug(\u0026ldquo;获得了锁\u0026rdquo;); t1.start(); try { sleep(1); t1.interrupt(); log.debug(\u0026ldquo;执行打断\u0026rdquo;); sleep(1); } finally { log.debug(\u0026ldquo;释放了锁\u0026rdquo;); lock.unlock(); }\n 输出  18:06:56.261 [main] c.TestInterrupt - 获得了锁 18:06:56.265 [t1] c.TestInterrupt - 启动\u0026hellip; 18:06:57.266 [main] c.TestInterrupt - 执行打断 // 这时 t1 并没有被真正打断, 而是仍继续等待锁 18:06:58.267 [main] c.TestInterrupt - 释放了锁 18:06:58.267 [t1] c.TestInterrupt - 获得了锁\n ### 锁超时 在获取锁的过程中，如果其他线程持有该对象的锁一直没有释放。尝试获得锁的线程也不会死等，只会等待一段时间，如果一段时间超过了，其他线程还没有释放锁，我们就放弃等待，表示此次获取锁失败 立刻失败  java ReentrantLock lock = new ReentrantLock(); Thread t1 = new Thread(() -\u0026gt; { log.debug(\u0026ldquo;启动\u0026hellip;\u0026rdquo;); if (!lock.tryLock()) { log.debug(\u0026ldquo;获取立刻失败，返回\u0026rdquo;); return; } try { log.debug(\u0026ldquo;获得了锁\u0026rdquo;); } finally { lock.unlock(); } }, \u0026ldquo;t1\u0026rdquo;); lock.lock(); log.debug(\u0026ldquo;获得了锁\u0026rdquo;); t1.start(); try { sleep(2); } finally { lock.unlock(); }\n 输出  18:15:02.918 [main] c.TestTimeout - 获得了锁 18:15:02.921 [t1] c.TestTimeout - 启动\u0026hellip; 18:15:02.921 [t1] c.TestTimeout - 获取立刻失败，返回\n 超时失败  java ReentrantLock lock = new ReentrantLock(); Thread t1 = new Thread(() -\u0026gt; { log.debug(\u0026ldquo;启动\u0026hellip;\u0026rdquo;); try { if (!lock.tryLock(1, TimeUnit.SECONDS)) { log.debug(\u0026ldquo;获取等待 1s 后失败，返回\u0026rdquo;); return; } } catch (InterruptedException e) { e.printStackTrace(); //支持打断 log.debug(\u0026ldquo;获取不到锁\u0026rdquo;); return; } try { log.debug(\u0026ldquo;获得了锁\u0026rdquo;); } finally { lock.unlock(); } }, \u0026ldquo;t1\u0026rdquo;); lock.lock(); log.debug(\u0026ldquo;获得了锁\u0026rdquo;); t1.start(); try { sleep(2); } finally { lock.unlock(); }\n 输出  18:19:40.537 [main] c.TestTimeout - 获得了锁 18:19:40.544 [t1] c.TestTimeout - 启动\u0026hellip; 18:19:41.547 [t1] c.TestTimeout - 获取等待 1s 后失败，返回\n 使用 tryLock 解决哲学家就餐问题  java class Chopstick extends ReentrantLock { String name; public Chopstick(String name) { this.name = name; } @Override public String toString() { return \u0026ldquo;筷子{\u0026rdquo; + name + \u0026lsquo;}\u0026rsquo;; } }\n  java public class Test23 {public static void main(String[] args) { Chopstick c1 = new Chopstick(\u0026ldquo;1\u0026rdquo;); Chopstick c2 = new Chopstick(\u0026ldquo;2\u0026rdquo;); Chopstick c3 = new Chopstick(\u0026ldquo;3\u0026rdquo;); Chopstick c4 = new Chopstick(\u0026ldquo;4\u0026rdquo;); Chopstick c5 = new Chopstick(\u0026ldquo;5\u0026rdquo;); new Philosopher(\u0026ldquo;苏格拉底\u0026rdquo;, c1, c2).start(); new Philosopher(\u0026ldquo;柏拉图\u0026rdquo;, c2, c3).start(); new Philosopher(\u0026ldquo;亚里士多德\u0026rdquo;, c3, c4).start(); new Philosopher(\u0026ldquo;赫拉克利特\u0026rdquo;, c4, c5).start(); new Philosopher(\u0026ldquo;阿基米德\u0026rdquo;, c5, c1).start(); } } @Slf4j(topic = \u0026ldquo;c.Philosopher\u0026rdquo;) class Philosopher extends Thread { Chopstick left; Chopstick right; public Philosopher(String name, Chopstick left, Chopstick right) { super(name); this.left = left; this.right = right; } @Override public void run() { while (true) { //　尝试获得左手筷子 if(left.tryLock()) { try { // 尝试获得右手筷子 if(right.tryLock()) { try { eat(); } finally { right.unlock(); } } } finally { left.unlock(); // 释放自己手里的筷子 } } } } Random random = new Random(); private void eat() { log.debug(\u0026ldquo;eating\u0026hellip;\u0026rdquo;); Sleeper.sleep(0.5); } } class Chopstick extends ReentrantLock { String name; public Chopstick(String name) { this.name = name; } @Override public String toString() { return \u0026ldquo;筷子{\u0026rdquo; + name + \u0026lsquo;}\u0026rsquo;; } }\n ### 公平锁 synchronized是一种不公平锁，当一个线程获得锁，其他线程就得进入等待队列中去等待，当锁的持有者释放锁的时候，这些线程就会一拥而上，谁先抢到锁谁就先执行。不会按照进入阻塞队列中的顺序先来先得。 再等待地时候是按照先到先得地顺序进行排队等候地，而非公平锁是随机选择在等待地锁 ReentrantLock 默认是不公平的  java ReentrantLock lock = new ReentrantLock(false); lock.lock(); for (int i = 0; i \u0026lt; 500; i++) { new Thread(() -\u0026gt; { lock.lock(); try { System.out.println(Thread.currentThread().getName() + \u0026ldquo; running\u0026hellip;\u0026rdquo;); } finally { lock.unlock(); } }, \u0026ldquo;t\u0026rdquo; + i).start(); } // 1s 之后去争抢锁 Thread.sleep(1000); new Thread(() -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026ldquo; start\u0026hellip;\u0026rdquo;); lock.lock(); try { System.out.println(Thread.currentThread().getName() + \u0026ldquo; running\u0026hellip;\u0026rdquo;); } finally { lock.unlock(); } }, \u0026ldquo;强行插入\u0026rdquo;).start(); lock.unlock();\n 强行插入，有机会在中间输出 \u0026gt; 注意：该实验不一定总能复现  t39 running\u0026hellip; t40 running\u0026hellip; t41 running\u0026hellip; t42 running\u0026hellip; t43 running\u0026hellip; 强行插入 start\u0026hellip; 强行插入 running\u0026hellip; t44 running\u0026hellip; t45 running\u0026hellip; t46 running\u0026hellip; t47 running\u0026hellip; t49 running\u0026hellip;\n 改为公平锁后  ReentrantLock lock = new ReentrantLock(true);\n 强行插入，总是在最后输出  t465 running\u0026hellip; t464 running\u0026hellip; t477 running\u0026hellip; t442 running\u0026hellip; t468 running\u0026hellip; t493 running\u0026hellip; t482 running\u0026hellip; t485 running\u0026hellip; t481 running\u0026hellip; 强行插入 running\u0026hellip;\n **公平锁一般没有必要，会降低并发度，后面分析原理时会讲解** ### 条件变量 synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待（waitSet就是synchronized中的条件变量，是单一的。就意味着只有一间休息室，要唤醒时，要么随机，要么全部唤醒） ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比 * synchronized 是那些不满足条件的线程都在一间休息室等消息 * 而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒 使用要点： \u0026gt; * await 前需要获得锁 \u0026gt; * await 执行后，会释放锁，进入 conditionObject 等待 \u0026gt; * await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁 \u0026gt; * 竞争 lock 锁成功后，从 await 后继续执行 例子：  java\n@Slf4j(topic = \u0026ldquo;c.Test24\u0026rdquo;) public class Test24 { static final Object room = new Object(); static boolean hasCigarette = false; static boolean hasTakeout = false; static ReentrantLock ROOM = new ReentrantLock(); // 等待烟的休息室 static Condition waitCigaretteSet = ROOM.newCondition(); // 等外卖的休息室 static Condition waitTakeoutSet = ROOM.newCondition();\npublic static void main(String[] args) { new Thread(() -\u0026gt; { ROOM.lock(); try { log.debug(\u0026quot;有烟没？[{}]\u0026quot;, hasCigarette); while (!hasCigarette) { log.debug(\u0026quot;没烟，先歇会！\u0026quot;); try { waitCigaretteSet.await(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\u0026quot;可以开始干活了\u0026quot;); } finally { ROOM.unlock(); } }, \u0026quot;小南\u0026quot;).start(); new Thread(() -\u0026gt; { ROOM.lock(); try { log.debug(\u0026quot;外卖送到没？[{}]\u0026quot;, hasTakeout); while (!hasTakeout) { log.debug(\u0026quot;没外卖，先歇会！\u0026quot;); try { waitTakeoutSet.await(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\u0026quot;可以开始干活了\u0026quot;); } finally { ROOM.unlock(); } }, \u0026quot;小女\u0026quot;).start(); sleep(1); new Thread(() -\u0026gt; { ROOM.lock(); try { hasTakeout = true; waitTakeoutSet.signal(); } finally { ROOM.unlock(); } }, \u0026quot;送外卖的\u0026quot;).start(); sleep(1); new Thread(() -\u0026gt; { ROOM.lock(); try { hasCigarette = true; waitCigaretteSet.signal(); } finally { ROOM.unlock(); } }, \u0026quot;送烟的\u0026quot;).start(); }  }\n 输出  10:41:08.694 c.Test24 [小南] - 有烟没？[false] 10:41:08.698 c.Test24 [小南] - 没烟，先歇会！ 10:41:08.698 c.Test24 [小女] - 外卖送到没？[false] 10:41:08.698 c.Test24 [小女] - 没外卖，先歇会！ 10:41:09.700 c.Test24 [小女] - 可以开始干活了 10:41:10.713 c.Test24 [小南] - 可以开始干活了\n ### * 同步模式之顺序控制 ## 本章小结 本章我们需要重点掌握的是 * 分析多线程访问共享资源时，哪些代码片段属于临界区 * 使用 synchronized 互斥解决临界区的线程安全问题 * 掌握 synchronized 锁对象语法 * 掌握 synchronzied 加载成员方法和静态方法语法 * 掌握 wait/notify 同步方法 * 使用 lock 互斥解决临界区的线程安全问题 * 掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量 * 学会分析变量的线程安全性、掌握常见线程安全类的使用 * 了解线程活跃性问题：死锁、活锁、饥饿 * 应用方面 * 互斥：使用 synchronized 或 Lock 达到共享资源互斥效果 * 同步：使用 wait/notify 或 Lock 的条件变量来达到线程间通信效果 * 原理方面 * monitor、synchronized 、wait/notify 原理 * synchronized 进阶原理 * park \u0026amp; unpark 原理 * 模式方面 * 同步模式之保护性暂停 * 异步模式之生产者消费者 * 同步模式之顺序控制 # 5. 共享模型之内存 本章内容 上一章讲解的 **Monitor** 主要关注的是访问共享变量时，保证临界区代码的**原子性** 这一章我们进一步深入学习共享变量在多线程间的【**可见性**】问题与多条指令执行时的【**有序性**】问题 ## 5.1 Java 内存模型 JMM 即 Java Memory Model，它定义了主存（所有线程都共享的数据：静态成员变量，成员变量等）、工作内存（每个线程私有的数据：局部变量等）抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。（为了简化Java程序员不要直接面对底层这些复杂的内存管理） JMM 体现在以下几个方面  原子性 - 保证指令不会受到线程上下文切换的影响 可见性 - 保证指令不会受 cpu 缓存的影响 有序性 - 保证指令不会受 cpu 指令并行优化的影响\n ## 5.2 可见性 退不出的循环 先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：  java static boolean run = true; public static void main(String[] args) throws InterruptedException { Thread t = new Thread(()-\u0026gt;{ while(run){ // \u0026hellip;. } }); t.start(); sleep(1); run = false; // 线程t不会如预想的停下来 }\n 为什么呢？分析一下： 1. 初始状态， t 线程刚开始从主内存（所有共享信息存储的位置）读取了 run 的值到工作内存（每个线程的私有 信息存储的位置）。 ![image-20200420145244825](/resources/技术收录/Java/java并发/image-20200420145244825.png) 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率 ![image-20200420145309010](/resources/技术收录/Java/java并发/image-20200420145309010.png) 1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是旧值 ![image-20200420145333934](/resources/技术收录/Java/java并发/image-20200420145333934.png) ### 解决方法 volatile（易变关键字：不能从缓存中进行读取了，每次都要从主内存中读取变量的最新值）  java\n@Slf4j(topic = \u0026ldquo;c.Test32\u0026rdquo;) public class Test32 { // 易变 volatile static boolean run = true;\npublic static void main(String[] args) throws InterruptedException { Thread t = new Thread(()-\u0026gt;{ while(true){ if(!run) { break; } } }); t.start(); sleep(1); run = false; // 线程t不会如预想的停下来 }  }\n 它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存 还可以使用synchronized保证  java @Slf4j(topic = \u0026ldquo;c.Test32\u0026rdquo;) public class Test32 { // 易变 static boolean run = true; final static Object lock = new Object(); public static void main(String[] args) throws InterruptedException { Thread t = new Thread(()-\u0026gt;{ while(true){ synchronized (lock){ if(!run) { break; } } } }); t.start(); sleep(1); synchronized (lock){ run = false; // 线程t不会如预想的停下来 } } }\n ### 可见性 vs 原子性 前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可 见， 不能保证原子性，仅用在一个写线程，多个读线程的情况： 上例从字节码理解是这样的：  getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true putstatic run // 线程 main 修改 run 为 false， 仅此一次 getstatic run // 线程 t 获取 run false\n 比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i-- ，volatile只能保证看到最新值，不能解决指令交错  // 假设i的初始值为 0 getstatic i // 线程2-获取静态变量i的值 线程内i=0\ngetstatic i // 线程1-获取静态变量i的值 线程内i=0 iconst_1 // 线程1-准备常量 1 iadd // 线程1-自增 线程内i=1 putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1\niconst_1 // 线程2-准备常量 1 isub // 线程2-自减 线程内i=-1 putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1\n \u0026gt; 注意 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 \u0026gt; synchronized 是属于重量级操作，性能相对更低 \u0026gt; \u0026gt; 如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 \u0026gt; 对 run 变量的修改了，想一想为什么？ System.out.println()源码  java public void println(String x) { synchronized (this) { print(x); newLine(); } }\n 可以发现println语句中有一个上锁的操作： 通过查资料发现，在使用了synchronized上锁这个操作后线程会做以下操作： 1.获得同步锁 2.清空工作内存 3.从主内存中拷贝对象副本到本地内存 4.执行代码（打印语句或加加操作） 5.刷新主内存数据 6.释放同步锁 这也就是System.out.println()为何会影响内存可见性的原因了。 ### * 原理之 CPU 缓存结构 * 模式之两阶段终止 - 模式之 Balking ## 5.3 有序性 JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码  java static int i; static int j; // 在某个线程内执行如下赋值操作 i = \u0026hellip;; j = \u0026hellip;;\n 可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是  i = \u0026hellip;; j = \u0026hellip;;\n 也可以是  j = \u0026hellip;; i = \u0026hellip;;\n 这种特性称之为『**指令重排**』，多线程下『指令重排』会影响正确性。为什么要有重排指令这项优化呢？从 CPU 执行指令的原理来理解一下吧 ### * 原理之指令级并行 ### 诡异的结果  java int num = 0 ; boolean ready = false; // 线程1 执行此方法 public void actor1(I_Result r) { if(ready) { r.r1 = num + num; } else { r.r1 = 1; } } // 线程2 执行此方法 public void actor2(I_Result r) { num = 2; ready = true; }\n I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？ 有同学这么分析 情况 1 ：线程 1 先执行，这时 ready = false，所以进入 else 分支结果为 1 情况 2 ：线程 2 先执行 num = 2，但没来得及执行 ready = true，线程 1 执行，还是进入 else 分支，结果为 1 情况 3 ：线程 2 执行到 ready = true，线程 1 执行，这回进入 if 分支，结果为 4 （因为 num 已经执行过了） 但我告诉你，结果还有可能是 0，信不信吧！ 这种情况下是：线程 2 执行 ready = true，切换到线程 1 ，进入 if 分支，相加为 0 ，再切回线程 2 执行 num = 2 相信很多人已经晕了 这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现： 借助 java 并发压测工具 jcstress https://wiki.openjdk.java.net/display/CodeTools/jcstress  mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jcstress - DarchetypeArtifactId=jcstress-java-test-archetype -DarchetypeVersion=0.5 -DgroupId=cn.itcast - DartifactId=ordering -Dversion=1.0\n 创建 maven 项目，提供如下测试类  java\n@JCStressTest @Outcome(id = {\u0026ldquo;1\u0026rdquo;, \u0026ldquo;4\u0026rdquo;}, expect = Expect.ACCEPTABLE, desc = \u0026ldquo;ok\u0026rdquo;) @Outcome(id = \u0026ldquo;0\u0026rdquo;, expect = Expect.ACCEPTABLE_INTERESTING, desc = \u0026ldquo;!!!!\u0026rdquo;) @State public class ConcurrencyTest {\nint num = 0; boolean ready = false; @Actor public void actor1(I_Result r) { if(ready) { r.r1 = num + num; } else { r.r1 = 1; } } @Actor public void actor2(I_Result r) { num = 2; ready = true; }  }\n 执行  mvn clean install java -jar target/jcstress.jar\n 会输出我们感兴趣的结果，摘录其中一次结果：  *** INTERESTING tests Some interesting behaviors observed. This is for the plain curiosity. 2 matching test results. [OK] test.ConcurrencyTest (JVM args: [-XX:-TieredCompilation]) Observed state Occurrences Expectation Interpretation 0 1,729 ACCEPTABLE_INTERESTING !!!! 1 42,617,915 ACCEPTABLE ok 4 5,146,627 ACCEPTABLE ok [OK] test.ConcurrencyTest (JVM args: []) Observed state Occurrences Expectation Interpretation 0 1,652 ACCEPTABLE_INTERESTING !!!! 1 46,460,657 ACCEPTABLE ok 4 4,571,072 ACCEPTABLE ok\n 可以看到，出现结果为 0 的情况有 638 次，虽然次数相对很少，但毕竟是出现了。 #### 解决方法 volatile 修饰的变量，可以禁用指令重排  java\n@JCStressTest @Outcome(id = {\u0026ldquo;1\u0026rdquo;, \u0026ldquo;4\u0026rdquo;}, expect = Expect.ACCEPTABLE, desc = \u0026ldquo;ok\u0026rdquo;) @Outcome(id = \u0026ldquo;0\u0026rdquo;, expect = Expect.ACCEPTABLE_INTERESTING, desc = \u0026ldquo;!!!!\u0026rdquo;) @State public class ConcurrencyTest {\nint num = 0; volatile boolean ready = false;//保证之前的代码不会重新排序 @Actor public void actor1(I_Result r) { if(ready) { r.r1 = num + num; } else { r.r1 = 1; } } @Actor public void actor2(I_Result r) { num = 2; ready = true; }  }\n 结果为：  *** INTERESTING tests Some interesting behaviors observed. This is for the plain curiosity. 0 matching test results.\n ### * 原理之 volatile ### happens-before happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛 开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见 #### 规则1 线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见  java static int x; static Object m = new Object(); new Thread(()-\u0026gt;{ synchronized(m) { x = 10 ;//写 } },\u0026ldquo;t1\u0026rdquo;).start(); new Thread(()-\u0026gt;{ synchronized(m) { System.out.println(x);//读 } },\u0026ldquo;t2\u0026rdquo;).start();\n #### 规则2 线程对 volatile 变量的写，对接下来其它线程对该变量的读可见  java volatile static int x; new Thread(()-\u0026gt;{ x = 10; },\u0026ldquo;t1\u0026rdquo;).start(); new Thread(()-\u0026gt;{ System.out.println(x); },\u0026ldquo;t2\u0026rdquo;).start();\n #### 规则3 线程 start 前对变量的写，对该线程开始后对该变量的读可见  java static int x; x = 10; new Thread(()-\u0026gt;{ System.out.println(x); },\u0026ldquo;t2\u0026rdquo;).start();\n #### 规则4 线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）  java static int x; Thread t1 = new Thread(()-\u0026gt;{ x = 10; },\u0026ldquo;t1\u0026rdquo;); t1.start(); t1.join(); System.out.println(x);\n #### 规则5 线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）  java static int x; public static void main(String[] args) { Thread t2 = new Thread(()-\u0026gt;{ while(true) { if(Thread.currentThread().isInterrupted()) { System.out.println(x); break; } } },\u0026ldquo;t2\u0026rdquo;); t2.start(); new Thread(()-\u0026gt;{ sleep(1); x = 10; t2.interrupt(); },\u0026ldquo;t1\u0026rdquo;).start(); while(!t2.isInterrupted()) { Thread.yield(); } System.out.println(x); }\n #### 规则6 对变量默认值（0，false，null）的写，对其它线程对该变量的读可见 #### 规则7 具有传递性，如果 x hb-\u0026gt; y 并且 y hb-\u0026gt; z 那么有 x hb-\u0026gt; z ，配合 volatile 的防指令重排，有下面的例子  java volatile static int x; static int y; new Thread(()-\u0026gt;{ y = 10; x = 20;//写屏障之前都有序 //写屏障 },\u0026ldquo;t1\u0026rdquo;).start(); new Thread(()-\u0026gt;{ // x=20 对 t2 可见, 同时 y=10 也对 t2 可见 System.out.println(x); },\u0026ldquo;t2\u0026rdquo;).start();\n 变量都是指成员变量或静态成员变量 ## 习题 ### balking 模式习题 希望 doInit() 方法仅被调用一次，下面的实现是否有问题，为什么？ 有问题，  java public class TestVolatile { volatile boolean initialized = false; void init() { if (initialized) { return; } doInit();//t1执行到这就进行上下文切换 initialized = true; } private void doInit() { } }\n 解决办法  java public class TestVolatile { boolean initialized = false; static final Object lock = new Object(); void init() { synchronized(lock){ if (initialized) { return; } doInit(); initialized = true;\n}\n} private void doInit() { } }\n ### 线程安全单例习题 单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用getInstance）时的线程安全，并思考注释中的问题 \u0026gt; 饿汉式：类加载就会导致该单实例对象被创建 \u0026gt; 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建 #### 实现 1  java // 问题1：为什么加 final /怕将来它有子类，字类不适当的覆盖了父类中的方法，破坏了他的单例/ // 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例 增加readResolve方法 public final class Singleton implements Serializable { // 问题3：为什么设置为私有? 是否能防止反射创建新的实例? /*要设置为其他的，那么别的类就可以无限的创建它的对象；就不能是单例了 不能防止反射创建新的实例，反射可以暴力获取私有方法 */ private Singleton() {} // 问题4：这样初始化是否能保证单例对象创建时的线程安全? /*能 静态成员的初始化操作是在类加载前完成的；类加载的阶段由jvm保证代码的线程安全性 类加载阶段，对这些静态变量进行赋值都是线程安全的，可以相信jvm */ private static final Singleton INSTANCE = new Singleton(); // 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由 /*用方法可以提供更好的封装性，内部实现一些懒惰的初始化；直接提供静态成员变量将来就不能改进成懒惰的初始化方式了，然后还可以创建单例对象时进行更好的控制；还可以提供泛型的支持，用成员变量没法提供泛型的支持 */ public static Singleton getInstance() { return INSTANCE; } /*解决问题2：防止反序列化破坏单例 在反序列化的过程中一旦发现readResolve返回了一个对象，就会采用你返回的对象；不是反序列化字节码生成的对象；把readResolve方法返回的对象当作反序列化的结果；保证了我们即使使用的是反序列化，返回的也是同一个对象，而不是新的对象 */ public Object readResolve() { return INSTANCE; } }\n #### 实现 2  java // 问题1：枚举单例是如何限制实例个数的 /枚举中定义的枚举对象，你定义几个，将来就有几个对象；相当于是枚举类的静态成员变量/ // 问题2：枚举单例在创建时是否有并发问题 /没有，因为它也是静态成员变量，它的线程安全性也是在在类加载阶段完成的，所以他不会有多线程的并发问题，创建时是线程安全的/ // 问题3：枚举单例能否被反射破坏单例 /不能：/ // 问题4：枚举单例能否被反序列化破坏单例 /枚举类默认都是实现了序列化接口的，可以被序列化和反序列化的；但是枚举类在设计的时候就考虑到了序列化破坏单例的情况，所以它可以避免反序列化时出现问题，无需自己做额外的操作/ // 问题5：枚举单例属于懒汉式还是饿汉式 /*饿汉式的：类的静态成员对象在类加载的时候就进行创建了，也是饿汉式的/ // 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做 /加构造方法/ enum Singleton { INSTANCE; }\n 反编译后  java final enum cn/itcast/test/Singleton extends java/lang/Enum { //可以发现它就是枚举类中的一个静态的成员变量 public final static enum Lcn/itcast/test/Singleton; INSTANCE\n 枚举的父类Enum实现了Serializable接口  java public abstract class Enum\u0026gt; implements Comparable, Serializable {\n **下面对单件模式的懒汉式与饿汉式进行简单介绍：** 1、饿汉式：在程序启动或单件模式类被加载的时候，单件模式实例就已经被创建。 2、懒汉式：当程序第一次访问单件模式实例时才进行创建。 #### 实现 3 ：  java public final class Singleton { private Singleton() { } //一开始静态成员变量并没有赋值，在你第一次getInstance才去创建这个对象 private static Singleton INSTANCE = null; // 分析这里的线程安全, 并说明有什么缺点 /*是线程安全的：对Singleton类进行加锁，类和静态成员变量是一一对应的，对Singleton类加锁就相当于对静态成员变量INSTANCE进行加锁 一定不能将synchronized加在静态成员变量INSTANCE上，首先INSTANCE不是final的，他要重新赋一次值；还有它的值可能是null，null上不能加任何的synchronized：synchronized要找到一个对象，根据对象分配Monitor锁；null没有关联的对象，所以不行；synchronized不能锁在INSTANCE这个静态成员变量，要锁在一个相对不变的对象上\n锁住的对象有点大，第一次调用getInstance的时候要加锁，后面这个对象创建好了，第二次，第三次后续的调用仍然要加锁，导致性能较低 */ public static synchronized Singleton getInstance() { if( INSTANCE != null ){ return INSTANCE; } INSTANCE = new Singleton(); return INSTANCE; }  }\n 懒汉式单例 #### 实现 4 ：DCL double-checked locking 原理 构造过程是线程安全的  java public final class Singleton { private Singleton() { } // 问题1：解释为什么要加 volatile ? /*synchronized代码块中指令还是会重排序的，构造方法的指令和赋值指令还是会重排序的 重排序的话，第二个线程线程二如果在进synchronized代码块之前获取INSTANCE对象引用的时候就有可能是这样做的：先赋值操作，再构造方法，在synchronized代码块外面的线程来讲，获取的引用，可能还没有调用构造方法，因此就可能造成拿到的是一个不完整的对象就会有问题，因此要保证指令不要发生重排序；需要在INSTANCE前面加上volatile，防止在synchronized代码块内发生重排序；就不会将赋值方法放到构造方法的后面去；其他线程即使在synchronized代码块外拿到的引用肯定是已经调用完构造方法之后的引用，就不会有问题。 */ private static volatile Singleton INSTANCE = null; // 问题2：对比实现3, 说出这样做的意义 /** 当第一调用getInstance时INSTANCE是null进入下面的代码块，创建INSTANCE实例，后续的第二，第三次调用getInstance发现INSTANCE不为空直接就返回这个对象了；if判断没有加synchronized代码块性能上比较优越些 */ public static Singleton getInstance() { if (INSTANCE != null) { return INSTANCE; } synchronized (Singleton.class) { //(1) // 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗 /为了防止首次访问getInstance创建INSTANCE对象时多个线程并发的问题/ if (INSTANCE != null) { //(2) return INSTANCE; } INSTANCE = new Singleton(); //(3) return INSTANCE; } } }\n 问题三 比如说线程一执行到(1)的位置它发现INSTANCE对象是null，就锁住了Singleton，进入下面的代码执行，当它执行到(2)的时候发现INSTANCE还是null就继续向下执行，执行到(3)的位置去创建INSTANCE对象； 此时假设第二个线程开始执行，与此同时线程一在(3)的位置还没有赋值成功，线程二发现INSTANCE对象为空执行到(1)的位置，在(1)的位置阻塞着；等线程一在(3)的位置执行完了，锁释放开，INSTANCE变量也赋好值了；线程二就能继续向下执行，如果没有(2)位置的判断，线程2就会直接执行(3)位置的代码，又会创建一个INSTANCE对象，并且会覆盖掉线程一创建的INSTANCE实例； 所以(2)位置的第二次判断是为了防止第一次并发访问时的单例对象不要被重复创建 #### 实现 5 ： **推荐**  java public final class Singleton { private Singleton() { } // 问题1：属于懒汉式还是饿汉式 /*采用的是静态的内部类，静态内部类的目的是为了完成懒汉式的创建 类加载本身就是懒惰的，类总是在第一次被用到时才会触发类加载动作，如果只是用到外面的Singleton类，而没有使用getInstance方法，就不会触发内部的LazyHolder类的类加载方法，既然LazyHolder类的类加载动作没有被触发，那么LazyHolder中的静态成员变量也不会进行初始化操作；所以当你使用getInstance方法是才会进行LazyHolder类的类加载动作，才会对LazyHolder类中的静态变量进行初始化操作，所以这种操作是懒汉式的 */ private static class LazyHolder { static final Singleton INSTANCE = new Singleton(); } // 问题2：在创建时是否有并发问题 /没有：类加载时对静态成员变量的赋值操作是由JVM来保证它的线程安全性，不用担心他的线程安全性/ public static Singleton getInstance() { return LazyHolder.INSTANCE; } }\n ## 本章小结 都是由于java虚拟机进行的一些优化造成的多线程下的问题 本章重点讲解了 JMM 中的 * 可见性 - 由 JVM 缓存优化引起 * 有序性 - 由 JVM 指令重排序优化引起 * happens-before 规则 * 原理方面 * CPU 指令并行 * volatile * 模式方面 * 两阶段终止模式的 volatile 改进 * 同步模式之 balking # 6. 共享模型之无锁 ## 本章内容 * CAS 与 volatile * 原子整数 * 原子引用 * 原子累加器 * Unsafe ## 6.1 问题提出 有如下需求，保证 account.withdraw 取款方法的线程安全  java interface Account { // 获取余额 Integer getBalance(); // 取款 void withdraw(Integer amount); /** * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作 * 如果初始余额为 10000 那么正确的结果应当是 0 */ static void demo(Account account) { List ts = new ArrayList\u0026lt;\u0026gt;(); long start = System.nanoTime(); for (int i = 0; i \u0026lt; 1000; i++) { ts.add(new Thread(() -\u0026gt; { account.withdraw(10); })); } ts.forEach(Thread::start); ts.forEach(t -\u0026gt; { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); long end = System.nanoTime(); System.out.println(account.getBalance()+ \u0026ldquo; cost: \u0026ldquo; + (end-start)/1000_000 + \u0026ldquo; ms\u0026rdquo;); } }\n 原有实现并不是线程安全的  java class AccountUnsafe implements Account { private Integer balance; public AccountUnsafe(Integer balance) { this.balance = balance; } @Override public Integer getBalance() { return balance; } @Override public void withdraw(Integer amount) {//临界区，会有多个线程的读写操作 balance -= amount; } }\n 执行测试代码  java public static void main(String[] args) { Account.demo(new AccountUnsafe(10000)); }\n 某次的执行结果  java 330 cost: 306 ms\n ### 为什么不安全 withdraw 方法 对应的字节码  ALOAD 0 // \u0026lt;- this ALOAD 0 GETFIELD cn/itcast/AccountUnsafe.balance : Ljava/lang/Integer; // \u0026lt;- this.balance INVOKEVIRTUAL java/lang/Integer.intValue ()I // 拆箱 ALOAD 1 // \u0026lt;- amount INVOKEVIRTUAL java/lang/Integer.intValue ()I // 拆箱 ISUB // 减法 INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer; // 结果装箱 PUTFIELD cn/itcast/AccountUnsafe.balance : Ljava/lang/Integer; // -\u0026gt; this.balance\n 多线程执行流程  ALOAD 0 // thread-0 \u0026lt;- this ALOAD 0 GETFIELD cn/itcast/AccountUnsafe.balance // thread-0 \u0026lt;- this.balance INVOKEVIRTUAL java/lang/Integer.intValue // thread-0 拆箱 ALOAD 1 // thread-0 \u0026lt;- amount INVOKEVIRTUAL java/lang/Integer.intValue // thread-0 拆箱 ISUB // thread-0 减法 INVOKESTATIC java/lang/Integer.valueOf // thread-0 结果装箱 PUTFIELD cn/itcast/AccountUnsafe.balance // thread-0 -\u0026gt; this.balance\nALOAD 0 // thread-1 \u0026lt;- this ALOAD 0 GETFIELD cn/itcast/AccountUnsafe.balance // thread-1 \u0026lt;- this.balance INVOKEVIRTUAL java/lang/Integer.intValue // thread-1 拆箱 ALOAD 1 // thread-1 \u0026lt;- amount INVOKEVIRTUAL java/lang/Integer.intValue // thread-1 拆箱 ISUB // thread-1 减法 INVOKESTATIC java/lang/Integer.valueOf // thread-1 结果装箱 PUTFIELD cn/itcast/AccountUnsafe.balance // thread-1 -\u0026gt; this.balance\n * 单核的指令交错 * 多核的指令交错 ### 解决思路-锁 首先想到的是给 Account 对象加锁  java class AccountUnsafe implements Account { private Integer balance; public AccountUnsafe(Integer balance) { this.balance = balance; } @Override public synchronized Integer getBalance() { return balance; } @Override public synchronized void withdraw(Integer amount) { balance -= amount; } }\n 结果为  0 cost: 399 ms\n ### 解决思路-无锁  java class AccountSafe implements Account { private AtomicInteger balance; public AccountSafe(Integer balance) { this.balance = new AtomicInteger(balance); } @Override public Integer getBalance() { return balance.get(); } @Override public void withdraw(Integer amount) { while (true) { //获取余额的最新值 int prev = balance.get(); //修改后的余额 int next = prev - amount; //同步到主存中 if (balance.compareAndSet(prev, next)) { break; } } // 可以简化为下面的方法 // balance.addAndGet(-1 * amount); } }\n 执行测试代码  java public static void main(String[] args) { Account.demo(new AccountSafe(10000)); }\n 某次的执行结果  0 cost: 302 ms\n ## 6.2 CAS 与 volatile 前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？  java public void withdraw(Integer amount) { // 需要不断尝试，直到成功为止 while (true) { // 比如拿到了旧值 1000 int prev = balance.get(); // 在这个基础上 1000-10 = 990 int next = prev - amount; /* compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值 - 不一致了，next 作废，返回 false 表示失败 比如，别的线程已经做了减法，当前值已经被减成了 990 那么本线程的这次 990 就作废了，进入 while 下次循环重试 - 一致，以 next 设置为新值，返回 true 表示成功 比较并设置值(cas：方法名缩写) */ if (balance.compareAndSet(prev, next)) { break; } } }\n 其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。  mermaid sequenceDiagram # 通过设定参与者(participants)的顺序控制展示模块顺序 participant 线程1 participant Account对象 participant 线程2 线程1-\u0026gt;\u0026gt;Account对象:获取余额100 线程1-\u0026gt;\u0026gt;线程1:减10=90 线程2\u0026ndash;\u0026gt;\u0026gt;Account对象:已经修改为90了 线程1-\u0026gt;\u0026gt;Account对象:cas(100,90) 线程1-\u0026gt;\u0026gt;Account对象:获取余额90 线程1-\u0026gt;\u0026gt;线程1:减10=80 线程2\u0026ndash;\u0026gt;\u0026gt;Account对象:已经修改为80了 线程1-\u0026gt;\u0026gt;Account对象:cas(90,80) 线程1-\u0026gt;\u0026gt;Account对象:获取余额80 线程1-\u0026gt;\u0026gt;线程1:减10=70 线程1-\u0026gt;\u0026gt;Account对象:cas(80,70)\n ### 注意 \u0026gt; 其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交 \u0026gt; 换】的原子性。 \u0026gt; \u0026gt; 在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再 \u0026gt; 开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子 \u0026gt; 的。 ### 慢动作分析  java @Slf4j public class SlowMotion { public static void main(String[] args) { AtomicInteger balance = new AtomicInteger(10000); int mainPrev = balance.get(); log.debug(\u0026ldquo;try get {}\u0026rdquo;, mainPrev); new Thread(() -\u0026gt; { sleep(1000); int prev = balance.get(); balance.compareAndSet(prev, 9000); log.debug(balance.toString()); }, \u0026ldquo;t1\u0026rdquo;).start(); sleep(2000); log.debug(\u0026ldquo;try set 8000\u0026hellip;\u0026rdquo;); boolean isSuccess = balance.compareAndSet(mainPrev, 8000); log.debug(\u0026ldquo;is success ? {}\u0026rdquo;, isSuccess); if(!isSuccess){ mainPrev = balance.get(); log.debug(\u0026ldquo;try set 8000\u0026hellip;\u0026rdquo;); isSuccess = balance.compareAndSet(mainPrev, 8000); log.debug(\u0026ldquo;is success ? {}\u0026rdquo;, isSuccess); } } private static void sleep(int millis) { try { Thread.sleep(millis); } catch (InterruptedException e) { e.printStackTrace(); } } }\n 输出结果  2019-10-13 11:28:37.134 [main] try get 10000 2019-10-13 11:28:38.154 [t1] 9000 2019-10-13 11:28:39.154 [main] try set 8000\u0026hellip; 2019-10-13 11:28:39.154 [main] is success ? false 2019-10-13 11:28:39.154 [main] try set 8000\u0026hellip; 2019-10-13 11:28:39.154 [main] is success ? true\n **volatile**  java //AtomicInteger类中的value是使用volatile关键字修饰的 private volatile int value;\n 获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。 它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取 它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。 \u0026gt; 注意 \u0026gt; volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原 \u0026gt; 子性） **CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果** ### 为什么无锁效率高 * 无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时 候，发生上下文切换，进入阻塞。打个比喻 * 线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火， 等被唤醒又得重新打火、启动、加速... 恢复到高速运行，代价比较大 * 但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑 道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还 是会导致上下文切换。(所以在多核的情况下cas才能发挥优势，并且线程数不能炒超过cpu的核心数) ![image-20200420152048629](/resources/技术收录/Java/java并发/image-20200420152048629.png) ### CAS 的特点 结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。 * CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再 重试呗。 * synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想 改，我改完了解开锁，你们才有机会。 * CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思 * 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 * 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响 ## 6.3 原子整数 J.U.C 并发包提供了： \u0026gt; * AtomicBoolean \u0026gt; * AtomicInteger \u0026gt; * AtomicLong 以 AtomicInteger 为例  java AtomicInteger i = new AtomicInteger(0); // 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++ System.out.println(i.getAndIncrement()); // 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i System.out.println(i.incrementAndGet()); // 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 \u0026ndash;i System.out.println(i.decrementAndGet()); // 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i\u0026ndash; System.out.println(i.getAndDecrement()); // 获取并加值（i = 0, 结果 i = 5, 返回 0） System.out.println(i.getAndAdd(5)); // 加值并获取（i = 5, 结果 i = 0, 返回 0） System.out.println(i.addAndGet(-5)); // 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0） // 其中函数中的操作能保证原子，但函数需要无副作用 System.out.println(i.getAndUpdate(p -\u0026gt; p - 2)); // 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0） // 其中函数中的操作能保证原子，但函数需要无副作用 System.out.println(i.updateAndGet(p -\u0026gt; p + 2)); // 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0） // 其中函数中的操作能保证原子，但函数需要无副作用 // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 // getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final System.out.println(i.getAndAccumulate(10, (p, x) -\u0026gt; p + x)); // 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0） // 其中函数中的操作能保证原子，但函数需要无副作用 System.out.println(i.accumulateAndGet(-10, (p, x) -\u0026gt; p + x));\n ## 6.4 原子引用 为什么需要原子引用类型？ \u0026gt; * AtomicReference \u0026gt; * AtomicMarkableReference \u0026gt; * AtomicStampedReference 有如下方法  java public interface DecimalAccount { // 获取余额 BigDecimal getBalance(); // 取款 void withdraw(BigDecimal amount); /** * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作 * 如果初始余额为 10000 那么正确的结果应当是 0 */ static void demo(DecimalAccount account) { List ts = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 1000; i++) { ts.add(new Thread(() -\u0026gt; { account.withdraw(BigDecimal.TEN); })); } ts.forEach(Thread::start); ts.forEach(t -\u0026gt; { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); System.out.println(account.getBalance()); } }\n Cas不适合于大量线程的场景，它适用的场景为最大线程数不超过CPU核心数 试着提供不同的 DecimalAccount 实现，实现安全的取款操作 ### 不安全实现  java class DecimalAccountUnsafe implements DecimalAccount { BigDecimal balance; public DecimalAccountUnsafe(BigDecimal balance) { this.balance = balance; } @Override public BigDecimal getBalance() { return balance; } @Override public void withdraw(BigDecimal amount) { BigDecimal balance = this.getBalance(); this.balance = balance.subtract(amount); } }\n ### 安全实现-使用锁  java class DecimalAccountSafeLock implements DecimalAccount { private final Object lock = new Object(); BigDecimal balance; public DecimalAccountSafeLock(BigDecimal balance) { this.balance = balance; } @Override public BigDecimal getBalance() { return balance; } @Override public void withdraw(BigDecimal amount) { synchronized (lock) { BigDecimal balance = this.getBalance(); this.balance = balance.subtract(amount); } } }\n ### 安全实现-使用 CAS  java class DecimalAccountSafeCas implements DecimalAccount { AtomicReference ref; public DecimalAccountSafeCas(BigDecimal balance) { ref = new AtomicReference\u0026lt;\u0026gt;(balance); } @Override public BigDecimal getBalance() { return ref.get(); } @Override public void withdraw(BigDecimal amount) { while (true) { BigDecimal prev = ref.get(); BigDecimal next = prev.subtract(amount); if (ref.compareAndSet(prev, next)) { break; } } } }\n 测试代码  java DecimalAccount.demo(new DecimalAccountUnsafe(new BigDecimal(\u0026ldquo;10000\u0026rdquo;))); DecimalAccount.demo(new DecimalAccountSafeLock(new BigDecimal(\u0026ldquo;10000\u0026rdquo;))); DecimalAccount.demo(new DecimalAccountSafeCas(new BigDecimal(\u0026ldquo;10000\u0026rdquo;)));\n 运行结果  4310 cost: 425 ms 0 cost: 285 ms 0 cost: 274 ms\n ### ABA 问题及解决 ABA 问题  java static AtomicReference ref = new AtomicReference\u0026lt;\u0026gt;(\u0026ldquo;A\u0026rdquo;); public static void main(String[] args) throws InterruptedException { log.debug(\u0026ldquo;main start\u0026hellip;\u0026rdquo;); // 获取值 A // 这个共享变量被它线程修改过？ String prev = ref.get(); other(); sleep(1); // 尝试改为 C log.debug(\u0026ldquo;change A-\u0026gt;C {}\u0026rdquo;, ref.compareAndSet(prev, \u0026ldquo;C\u0026rdquo;)); } private static void other() { new Thread(() -\u0026gt; { log.debug(\u0026ldquo;change A-\u0026gt;B {}\u0026rdquo;, ref.compareAndSet(ref.get(), \u0026ldquo;B\u0026rdquo;)); }, \u0026ldquo;t1\u0026rdquo;).start(); sleep(0.5); new Thread(() -\u0026gt; { log.debug(\u0026ldquo;change B-\u0026gt;A {}\u0026rdquo;, ref.compareAndSet(ref.get(), \u0026ldquo;A\u0026rdquo;)); }, \u0026ldquo;t2\u0026rdquo;).start(); }\n 输出  11:29:52.325 c.Test36 [main] - main start\u0026hellip; 11:29:52.379 c.Test36 [t1] - change A-\u0026gt;B true 11:29:52.879 c.Test36 [t2] - change B-\u0026gt;A true 11:29:53.880 c.Test36 [main] - change A-\u0026gt;C true\n 主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程 希望： 只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号使用AtomicStampedReference原子引用 ### AtomicStampedReference  java static AtomicStampedReference ref = new AtomicStampedReference\u0026lt;\u0026gt;(\u0026ldquo;A\u0026rdquo;, 0); public static void main(String[] args) throws InterruptedException { log.debug(\u0026ldquo;main start\u0026hellip;\u0026rdquo;); // 获取值 A String prev = ref.getReference(); // 获取版本号 int stamp = ref.getStamp(); log.debug(\u0026ldquo;版本 {}\u0026rdquo;, stamp); // 如果中间有其它线程干扰，发生了 ABA 现象 other(); sleep(1); // 尝试改为 C log.debug(\u0026ldquo;change A-\u0026gt;C {}\u0026rdquo;, ref.compareAndSet(prev, \u0026ldquo;C\u0026rdquo;, stamp, stamp + 1)); } private static void other() { new Thread(() -\u0026gt; { log.debug(\u0026ldquo;change A-\u0026gt;B {}\u0026rdquo;, ref.compareAndSet(ref.getReference(), \u0026ldquo;B\u0026rdquo;, ref.getStamp(), ref.getStamp() + 1)); log.debug(\u0026ldquo;更新版本为 {}\u0026rdquo;, ref.getStamp()); }, \u0026ldquo;t1\u0026rdquo;).start(); sleep(0.5); new Thread(() -\u0026gt; { log.debug(\u0026ldquo;change B-\u0026gt;A {}\u0026rdquo;, ref.compareAndSet(ref.getReference(), \u0026ldquo;A\u0026rdquo;, ref.getStamp(), ref.getStamp() + 1)); log.debug(\u0026ldquo;更新版本为 {}\u0026rdquo;, ref.getStamp()); }, \u0026ldquo;t2\u0026rdquo;).start(); }\n 输出为  15:41:34.891 c.Test36 [main] - main start\u0026hellip; 15:41:34.894 c.Test36 [main] - 版本 0 15:41:34.956 c.Test36 [t1] - change A-\u0026gt;B true 15:41:34.956 c.Test36 [t1] - 更新版本为 1 15:41:35.457 c.Test36 [t2] - change B-\u0026gt;A true 15:41:35.457 c.Test36 [t2] - 更新版本为 2 15:41:36.457 c.Test36 [main] - change A-\u0026gt;C false\n AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -\u0026gt; B -\u0026gt; A -\u0026gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。 但是有时候，并不关心引用变量更改了几次，只是单纯的关心**是否更改过**，所以就有了AtomicMarkableReference  mermaid graph TD a(\u0026ldquo;保洁阿姨\u0026rdquo;)-. 倒空 .-\u0026gt;b(\u0026ldquo;垃圾袋\u0026rdquo;) c(\u0026ldquo;主人\u0026rdquo;)\u0026ndash;检查\u0026ndash;\u0026gt;b(\u0026ldquo;垃圾袋\u0026rdquo;) b(\u0026ldquo;垃圾袋\u0026rdquo;)\u0026ndash;还空\u0026ndash;\u0026gt;b(\u0026ldquo;垃圾袋\u0026rdquo;) b(\u0026ldquo;垃圾袋\u0026rdquo;)\u0026ndash;已满\u0026ndash;\u0026gt;d(\u0026ldquo;新垃圾袋\u0026rdquo;)\n ### AtomicMarkableReference  java class GarbageBag { String desc; public GarbageBag(String desc) { this.desc = desc; } public void setDesc(String desc) { this.desc = desc; } @Override public String toString() { return super.toString() + \u0026ldquo; \u0026rdquo; + desc; } }\n  java @Slf4j public class TestABAAtomicMarkableReference { public static void main(String[] args) throws InterruptedException { GarbageBag bag = new GarbageBag(\u0026ldquo;装满了垃圾\u0026rdquo;); // 参数2 mark 可以看作一个标记，表示垃圾袋满了 AtomicMarkableReference ref = new AtomicMarkableReference\u0026lt;\u0026gt;(bag, true); log.debug(\u0026ldquo;主线程 start\u0026hellip;\u0026rdquo;);\n GarbageBag prev = ref.getReference(); log.debug(prev.toString()); new Thread(() -\u0026gt; { log.debug(\u0026quot;打扫卫生的线程 start...\u0026quot;); bag.setDesc(\u0026quot;空垃圾袋\u0026quot;); while (!ref.compareAndSet(bag, bag, true, false)) {} log.debug(bag.toString()); }).start(); Thread.sleep(1000); log.debug(\u0026quot;主线程想换一只新垃圾袋？\u0026quot;); boolean success = ref.compareAndSet(prev, new GarbageBag(\u0026quot;空垃圾袋\u0026quot;), true, false); log.debug(\u0026quot;换了么？\u0026quot; + success); log.debug(ref.getReference().toString());  } }\n 输出  2019-10-13 15:30:09.264 [main] 主线程 start\u0026hellip; 2019-10-13 15:30:09.270 [main] cn.itcast.GarbageBag@5f0fd5a0 装满了垃圾 2019-10-13 15:30:09.293 [Thread-1] 打扫卫生的线程 start\u0026hellip; 2019-10-13 15:30:09.294 [Thread-1] cn.itcast.GarbageBag@5f0fd5a0 空垃圾袋 2019-10-13 15:30:10.294 [main] 主线程想换一只新垃圾袋？ 2019-10-13 15:30:10.294 [main] 换了么？false 2019-10-13 15:30:10.294 [main] cn.itcast.GarbageBag@5f0fd5a0 空垃圾袋\n ## 6.5 原子数组 * AtomicIntegerArray * AtomicLongArray * AtomicReferenceArray 有如下方法  java /** 参数1，提供数组、可以是线程不安全数组或线程安全数组 参数2，获取数组长度的方法 参数3，自增方法，回传 array, index 参数4，打印数组的方法 */ // supplier 提供者 无中生有 ()-\u0026gt;结果 // function 函数 一个参数一个结果 (参数)-\u0026gt;结果 , BiFunction (参数1,参数2)-\u0026gt;结果 // consumer 消费者 一个参数没结果 (参数)-\u0026gt;void, BiConsumer (参数1,参数2)-\u0026gt; private static  void demo( Supplier arraySupplier, FunctionlengthFun, BiConsumerputConsumer, Consumer printConsumer ) { List ts = new ArrayList\u0026lt;\u0026gt;(); T array = arraySupplier.get(); int length = lengthFun.apply(array); for (int i = 0; i \u0026lt; length; i++) { // 每个线程对数组作 10000 次操作 ts.add(new Thread(() -\u0026gt; { for (int j = 0; j \u0026lt; 10000; j++) { putConsumer.accept(array, j%length); } })); } ts.forEach(t -\u0026gt; t.start()); // 启动所有线程 ts.forEach(t -\u0026gt; { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); // 等所有线程结束 printConsumer.accept(array); }\n ### 不安全的数组  java demo( ()-\u0026gt;new int[10], (array)-\u0026gt;array.length, (array, index) -\u0026gt; array[index]++, array-\u0026gt; System.out.println(Arrays.toString(array)) );\n 结果  [9870, 9862, 9774, 9697, 9683, 9678, 9679, 9668, 9680, 9698]\n ### 安全的数组  java demo( ()-\u0026gt; new AtomicIntegerArray(10), (array) -\u0026gt; array.length(), (array, index) -\u0026gt; array.getAndIncrement(index), array -\u0026gt; System.out.println(array) );\n 结果  [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]\n ## 6.6 字段更新器 * AtomicReferenceFieldUpdater // 域 字段 * AtomicIntegerFieldUpdater * AtomicLongFieldUpdater 利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现 异常  java Exception in thread \u0026ldquo;main\u0026rdquo; java.lang.IllegalArgumentException: Must be volatile type\n  java public class Test5 { private volatile int field; public static void main(String[] args) { AtomicIntegerFieldUpdater fieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Test5.class, \u0026ldquo;field\u0026rdquo;); Test5 test5 = new Test5(); fieldUpdater.compareAndSet(test5, 0, 10); // 修改成功 field = 10 System.out.println(test5.field); // 修改成功 field = 20 fieldUpdater.compareAndSet(test5, 10, 20); System.out.println(test5.field); // 修改失败 field = 20 fieldUpdater.compareAndSet(test5, 10, 30); System.out.println(test5.field); } }\n 输出  10 20 20\n  java @Slf4j(topic = \u0026ldquo;c.Test40\u0026rdquo;) public class Test40 {\npublic static void main(String[] args) { Student stu = new Student(); AtomicReferenceFieldUpdater updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, \u0026quot;name\u0026quot;); System.out.println(updater.compareAndSet(stu, null, \u0026quot;张三\u0026quot;)); System.out.println(stu); }  }\nclass Student { volatile String name;\n@Override public String toString() { return \u0026quot;Student{\u0026quot; + \u0026quot;name='\u0026quot; + name + '\\'' + '}'; }  }\n ## 6.7 原子累加器 \u0026gt; * AtomicLong \u0026gt; * LongAdder ### 累加器性能比较  java private static  void demo(Supplier adderSupplier, Consumer action) { T adder = adderSupplier.get(); long start = System.nanoTime(); List ts = new ArrayList\u0026lt;\u0026gt;(); // 4 个线程，每人累加 50 万 for (int i = 0; i \u0026lt; 40; i++) { ts.add(new Thread(() -\u0026gt; { for (int j = 0; j \u0026lt; 500000; j++) { action.accept(adder); } })); } ts.forEach(t -\u0026gt; t.start()); ts.forEach(t -\u0026gt; { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); long end = System.nanoTime(); System.out.println(adder + \u0026ldquo; cost:\u0026rdquo; + (end - start)/1000_000); }\n 比较 AtomicLong 与 LongAdder  java for (int i = 0; i \u0026lt; 5; i++) { demo(() -\u0026gt; new LongAdder(), adder -\u0026gt; adder.increment()); } for (int i = 0; i \u0026lt; 5; i++) { demo(() -\u0026gt; new AtomicLong(), adder -\u0026gt; adder.getAndIncrement()); }\n 输出  1000000 cost:43 1000000 cost:9 1000000 cost:7 1000000 cost:7 1000000 cost:7 1000000 cost:31 1000000 cost:27 1000000 cost:28 1000000 cost:24 1000000 cost:22\n 性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]... 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。(累加单元不会超过CPU的核心数) - **源码之 LongAdder** LongAdder 是并发大师 @author Doug Lea （大哥李）的作品，设计的非常精巧 LongAdder 类有几个关键域  java // 累加单元数组, 懒惰初始化 transient volatile Cell[] cells; // 基础值, 如果没有竞争, 则用 cas 累加这个域 transient volatile long base; // 在 cells 创建或扩容时, 置为 1, 表示加锁（cas锁的加锁标记，来保护对某些资源访问时的线程安全） transient volatile int cellsBusy;\n transient关键字：在序列化时不会把这些信息进行序列化 **cas锁**  java // 不要用于实践！！！ public class LockCas { private AtomicInteger state = new AtomicInteger(0); public void lock() { while (true) { if (state.compareAndSet(0, 1)) { break; } } } public void unlock() { log.debug(\u0026ldquo;unlock\u0026hellip;\u0026rdquo;); state.set(0); } }\n 测试  java LockCas lock = new LockCas(); new Thread(() -\u0026gt; { log.debug(\u0026ldquo;begin\u0026hellip;\u0026rdquo;); lock.lock(); try { log.debug(\u0026ldquo;lock\u0026hellip;\u0026rdquo;); sleep(1); } finally { lock.unlock(); } }).start(); new Thread(() -\u0026gt; { log.debug(\u0026ldquo;begin\u0026hellip;\u0026rdquo;); lock.lock(); try { log.debug(\u0026ldquo;lock\u0026hellip;\u0026rdquo;); } finally { lock.unlock(); } }).start();\n 输出  18:27:07.198 c.Test42 [Thread-0] - begin\u0026hellip; 18:27:07.202 c.Test42 [Thread-0] - lock\u0026hellip; 18:27:07.198 c.Test42 [Thread-1] - begin\u0026hellip; 18:27:08.204 c.Test42 [Thread-0] - unlock\u0026hellip; 18:27:08.204 c.Test42 [Thread-1] - lock\u0026hellip; 18:27:08.204 c.Test42 [Thread-1] - unlock\u0026hellip;\n ### * 原理之伪共享 其中 Cell 即为累加单元  java //Contended注解：防止缓存行伪共享 //由于一个缓存行加入了多个cell对象称为伪共享 @sun.misc.Contended static final class Cell { volatile long value; Cell(long x) { value = x; }\n // 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值 final boolean cas(long prev, long next) { return UNSAFE.compareAndSwapLong(this, valueOffset, prev, next); } // 省略不重要代码 }   得从缓存说起 缓存与内存的速度比较 ![image-20200420160059673](/resources/技术收录/Java/java并发/image-20200420160059673.png) | 从CPU到 | 大约需要的时间 | | ------- | -------------------------------- | | 寄存器 | 1 cycle (4GHz 的 CPU 约为0.25ns) | | L1 | 3~4 cycle | | L2 | 10~20 cycle | | L3 | 40~45 cycle | | 内存 | 120~240 cycle | 因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。 而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（ 8 个 long） 缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中 CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效 ![image-20200420160303519](/resources/技术收录/Java/java并发/image-20200420160303519.png) 因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（ 16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：  Core-0 要修改 Cell[0] Core-1 要修改 Cell[1]\n 无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000，这时会让 Core-1 的缓存行失效 `@sun.misc.Contended` 用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的 padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效 ![image-20200420160325796](/resources/技术收录/Java/java并发/image-20200420160325796.png) 累加主要调用下面的方法  java public void add(long x) { // as 为累加单元数组 // b 为基础值 // x 为累加值 Cell[] as; long b, v; int m; Cell a; // 进入 if 的两个条件 // 1. as 有值, 表示已经发生过竞争, 进入 if // 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if if ((as = cells) != null || !casBase(b = base, b + x)) { // uncontended 表示 cell 没有竞争 boolean uncontended = true; if ( // as 还没有创建 as == null || (m = as.length - 1) \u0026lt; 0 || // 当前线程对应的 cell 还没有 (a = as[getProbe() \u0026amp; m]) == null || // cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell ) !(uncontended = a.cas(v = a.value, v + x)) ) { // 进入 cell 数组创建、cell 创建的流程 longAccumulate(x, null, uncontended); } } }\n add 流程图  mermaid graph LR a(\u0026ldquo;当前线程\u0026rdquo;)\u0026ndash;\u0026gt;b(cells) b(cells)\u0026ndash;为空\u0026ndash;\u0026gt;c(cas base 累加) b(cells)\u0026ndash;不为空\u0026ndash;\u0026gt;d(当前线程cell是否创建) c(cas base 累加)\u0026ndash;成功\u0026ndash;\u0026gt;e(return) c(cas base 累加)\u0026ndash;失败\u0026ndash;\u0026gt;f(longAccumulate) d(当前线程cell是否创建)\u0026ndash;创建了\u0026ndash;\u0026gt;g(cas cell累加) d(当前线程cell是否创建)\u0026ndash;没创建\u0026ndash;\u0026gt;f g\u0026ndash;成功\u0026ndash;\u0026gt;e g\u0026ndash;失败\u0026ndash;\u0026gt;f\n  java final void longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended) { int h; // 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell if ((h = getProbe()) == 0) { // 初始化 probe ThreadLocalRandom.current(); // h 对应新的 probe 值, 用来对应 cell h = getProbe(); wasUncontended = true; } // collide 为 true 表示需要扩容 boolean collide = false; for (;;) { Cell[] as; Cell a; int n; long v; // 已经有了 cells if ((as = cells) != null \u0026amp;\u0026amp; (n = as.length) \u0026gt; 0) { // 还没有 cell if ((a = as[(n - 1) \u0026amp; h]) == null) { // 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x // 成功则 break, 否则继续 continue 循环 //cells存在\u0026amp;cell没创建 if (cellsBusy == 0) { // Try to attach new Cell Cell r = new Cell(x); // Optimistically create if (cellsBusy == 0 \u0026amp;\u0026amp; casCellsBusy()) { boolean created = false; try { // Recheck under lock Cell[] rs; int m, j; if ((rs = cells) != null \u0026amp;\u0026amp; (m = rs.length) \u0026gt; 0 \u0026amp;\u0026amp; rs[j = (m - 1) \u0026amp; h] == null) { rs[j] = r; created = true; } } finally { cellsBusy = 0; } if (created) break; continue; // Slot is now non-empty } } collide = false; } // 有竞争, 改变线程对应的 cell 来重试 cas else if (!wasUncontended) wasUncontended = true; // cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null //cells存在\u0026amp;cells已创建 else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x)))) break; // 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas else if (n \u0026gt;= NCPU || cells != as) collide = false; // 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了 else if (!collide) collide = true; // 加锁 else if (cellsBusy == 0 \u0026amp;\u0026amp; casCellsBusy()) { try { if (cells == as) { // Expand table unless stale Cell[] rs = new Cell[n \u0026lt;\u0026lt; 1]; for (int i = 0; i \u0026lt; n; ++i) rs[i] = as[i]; cells = rs; } } finally { cellsBusy = 0; } collide = false; // 加锁成功, 扩容 continue; } // 改变线程对应的 cell h = advanceProbe(h); } // 还没有 cells, 尝试给 cellsBusy 加锁 //cellsBusy 0:未加锁；1：加锁 //cells == as 还没有其他线程改变cells数组 //casCellsBusy():尝试加锁 else if (cellsBusy == 0 \u0026amp;\u0026amp; cells == as \u0026amp;\u0026amp; casCellsBusy()) { // 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell // 成功则 break; boolean init = false; try { // 没有别人把cells创建好，那我们就创建 if (cells == as) { Cell[] rs = new Cell[2]; rs[h \u0026amp; 1] = new Cell(x); cells = rs; init = true; } } finally { cellsBusy = 0;//解锁 } if (init) break; } // 上两种情况失败, 尝试给 base 累加 // else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x)))){ break; } } }\n longAccumulate 流程图  mermaid graph LR a(\u0026ldquo;循环入口\u0026rdquo;)\u0026ndash;\u0026gt;b(cells不存在\u0026amp;未加锁\u0026amp;未新建) a\u0026ndash;失败\u0026ndash;\u0026gt;c(\u0026ldquo;cas base 累加\u0026rdquo;) b\u0026ndash;\u0026gt;d(\u0026ldquo;加锁\u0026rdquo;) d\u0026ndash;成功\u0026ndash;\u0026gt;e(创建cells并初始化一个cell) d\u0026ndash;失败\u0026ndash;\u0026gt;c c\u0026ndash;成功\u0026ndash;\u0026gt;f(returnn) e\u0026ndash;\u0026gt;f\n  mermaid graph LR a(\u0026ldquo;循环入口\u0026rdquo;)\u0026ndash;\u0026gt;b(cells不存在\u0026amp;cell没创建) c(\u0026ldquo;槽位为空\u0026rdquo;)\u0026ndash;失败\u0026ndash;\u0026gt;a d(\u0026ldquo;加锁\u0026rdquo;)\u0026ndash;失败\u0026ndash;\u0026gt;a b\u0026ndash;创建cell\u0026ndash;\u0026gt;d d\u0026ndash;成功\u0026ndash;\u0026gt;c c\u0026ndash;成功\u0026ndash;\u0026gt;f(return)\n 每个线程刚进入 longAccumulate 时，会尝试对应一个 cell 对象（找到一个坑位）  mermaid graph LR a(循环入口)\u0026ndash;cells存在\u0026amp;\u0026amp;cell已创建\u0026ndash;\u0026gt;b(cas cell 累加) b\u0026ndash;成功\u0026ndash;\u0026gt;c(return) b\u0026ndash;失败\u0026ndash;\u0026gt;d(是否超过CPU上限) d\u0026ndash;是\u0026ndash;\u0026gt;e(改变线程对应的cell) d\u0026ndash;否\u0026ndash;\u0026gt;f(加锁) f\u0026ndash;失败\u0026ndash;\u0026gt;e e\u0026ndash;\u0026gt;a f\u0026ndash;成功\u0026ndash;\u0026gt;g(扩容) g\u0026ndash;\u0026gt;a\n 获取最终结果通过 sum 方法  java public long sum() { Cell[] as = cells; Cell a; long sum = base; if (as != null) { for (int i = 0; i \u0026lt; as.length; ++i) { if ((a = as[i]) != null) sum += a.value; } } return sum; }\n ## 6.8 Unsafe **概述** Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得  java public class UnsafeAccessor { static Unsafe unsafe; static { try { Field theUnsafe = Unsafe.class.getDeclaredField(\u0026ldquo;theUnsafe\u0026rdquo;); theUnsafe.setAccessible(true); unsafe = (Unsafe) theUnsafe.get(null); } catch (NoSuchFieldException | IllegalAccessException e) { throw new Error(e); } } static Unsafe getUnsafe() { return unsafe; } }\n Unsafe CAS 操作  java @Data class Student { volatile int id; volatile String name; }\n  java Unsafe unsafe = UnsafeAccessor.getUnsafe(); Field id = Student.class.getDeclaredField(\u0026ldquo;id\u0026rdquo;); Field name = Student.class.getDeclaredField(\u0026ldquo;name\u0026rdquo;); // 获得成员变量的偏移量 long idOffset = UnsafeAccessor.unsafe.objectFieldOffset(id); long nameOffset = UnsafeAccessor.unsafe.objectFieldOffset(name); Student student = new Student(); // 使用 cas 方法替换成员变量的值 UnsafeAccessor.unsafe.compareAndSwapInt(student, idOffset, 0, 20); // 返回 true UnsafeAccessor.unsafe.compareAndSwapObject(student, nameOffset, null, \u0026ldquo;张三\u0026rdquo;); // 返回 true System.out.println(student);\n 输出  Student(id=20, name=张三)\n 使用自定义的 MyAtomicInteger 实现之前线程安全的原子整数 Account 实现  java @Slf4j(topic = \u0026ldquo;c.Test42\u0026rdquo;) public class Test42 { public static void main(String[] args) { Account.demo(new MyAtomicInteger(10000)); } } class MyAtomicInteger implements Account { private volatile int value; private static final long valueOffset; private static final Unsafe UNSAFE; static { UNSAFE = UnsafeAccessor.getUnsafe(); try { valueOffset = UNSAFE.objectFieldOffset(MyAtomicInteger.class.getDeclaredField(\u0026ldquo;value\u0026rdquo;)); } catch (NoSuchFieldException e) { e.printStackTrace(); throw new RuntimeException(e); } } public int getValue() { return value; } public void decrement(int amount) { while(true) { int prev = this.value; int next = prev - amount; if (UNSAFE.compareAndSwapInt(this, valueOffset, prev, next)) { break; } } } public MyAtomicInteger(int value) { this.value = value; } @Override public Integer getBalance() { return getValue(); } @Override public void withdraw(Integer amount) { decrement(amount); } }\n ## 本章小结 * CAS 与 volatile * API * 原子整数 * 原子引用 * 原子数组 * 字段更新器 * 原子累加器 * Unsafe * 原理方面 * LongAdder 源码 * 伪共享 # 7. 共享模型之不可变 ## 本章内容 可变类都不是线程安全的 * 不可变类的使用 * 不可变类设计 * 无状态类设计 ## 7.1 日期转换的问题 ### 问题提出 下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的  java SimpleDateFormat sdf = new SimpleDateFormat(\u0026ldquo;yyyy-MM-dd\u0026rdquo;); for (int i = 0; i \u0026lt; 10; i++) { new Thread(() -\u0026gt; { try { log.debug(\u0026ldquo;{}\u0026rdquo;, sdf.parse(\u0026ldquo;1951-04-21\u0026rdquo;)); } catch (Exception e) { log.error(\u0026ldquo;{}\u0026rdquo;, e); } }).start(); }\n 有很大几率出现 java.lang.NumberFormatException 或者出现不正确的日期解析结果，例如：  19:10:40.859 [Thread-2] c.TestDateParse - {} java.lang.NumberFormatException: For input string: \u0026ldquo;\u0026rdquo; at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Long.parseLong(Long.java:601) at java.lang.Long.parseLong(Long.java:631) at java.text.DigitList.getLong(DigitList.java:195) at java.text.DecimalFormat.parse(DecimalFormat.java:2084) at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2162) at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514) at java.text.DateFormat.parse(DateFormat.java:364) at cn.itcast.n7.TestDateParse.lambda$test1$0(TestDateParse.java:18) at java.lang.Thread.run(Thread.java:748) 19:10:40.859 [Thread-1] c.TestDateParse - {} java.lang.NumberFormatException: empty String at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1842) at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110) at java.lang.Double.parseDouble(Double.java:538) at java.text.DigitList.getDouble(DigitList.java:169) at java.text.DecimalFormat.parse(DecimalFormat.java:2089) at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2162) at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514) at java.text.DateFormat.parse(DateFormat.java:364) at cn.itcast.n7.TestDateParse.lambda$test1$0(TestDateParse.java:18) at java.lang.Thread.run(Thread.java:748) 19:10:40.857 [Thread-8] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 19:10:40.857 [Thread-9] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 19:10:40.857 [Thread-6] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 19:10:40.857 [Thread-4] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 19:10:40.857 [Thread-5] c.TestDateParse - Mon Apr 21 00:00:00 CST 178960645 19:10:40.857 [Thread-0] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 19:10:40.857 [Thread-7] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 19:10:40.857 [Thread-3] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951\n ### 思路 - 同步锁 这样虽能解决问题，但带来的是性能上的损失，并不算很好：  java SimpleDateFormat sdf = new SimpleDateFormat(\u0026ldquo;yyyy-MM-dd\u0026rdquo;); for (int i = 0; i \u0026lt; 50; i++) { new Thread(() -\u0026gt; { synchronized (sdf) { try { log.debug(\u0026ldquo;{}\u0026rdquo;, sdf.parse(\u0026ldquo;1951-04-21\u0026rdquo;)); } catch (Exception e) { log.error(\u0026ldquo;{}\u0026rdquo;, e); } } }).start(); }\n ### 思路 - 不可变 如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊！这样的对象在Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类：  java DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\u0026ldquo;yyyy-MM-dd\u0026rdquo;); for (int i = 0; i \u0026lt; 10; i++) { new Thread(() -\u0026gt; { LocalDate date = dtf.parse(\u0026ldquo;2018-10-01\u0026rdquo;, LocalDate::from); log.debug(\u0026ldquo;{}\u0026rdquo;, date); }).start(); }\n 可以看 DateTimeFormatter 的文档：  java @implSpec This class is immutable and thread-safe.\n 不可变对象，实际是另一种避免竞争的方式。  java\n@Slf4j(topic = \u0026ldquo;c.TestDateParse\u0026rdquo;) public class TestDateParse { public static void main(String[] args) { test3(); }\nprivate static void test1() { SimpleDateFormat sdf = new SimpleDateFormat(\u0026quot;yyyy-MM-dd\u0026quot;); for (int i = 0; i \u0026lt; 10; i++) { new Thread(() -\u0026gt; { try { log.debug(\u0026quot;{}\u0026quot;, sdf.parse(\u0026quot;1951-04-21\u0026quot;)); } catch (Exception e) { log.error(\u0026quot;{}\u0026quot;, e); } }).start(); } } private static void test2() { SimpleDateFormat sdf = new SimpleDateFormat(\u0026quot;yyyy-MM-dd\u0026quot;); for (int i = 0; i \u0026lt; 10; i++) { new Thread(() -\u0026gt; { synchronized (sdf) { try { log.debug(\u0026quot;{}\u0026quot;, sdf.parse(\u0026quot;1951-04-21\u0026quot;)); } catch (Exception e) { log.error(\u0026quot;{}\u0026quot;, e); } } }).start(); } } private static void test3() { DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\u0026quot;yyyy-MM-dd\u0026quot;); for (int i = 0; i \u0026lt; 10; i++) { new Thread(() -\u0026gt; { LocalDate date = dtf.parse(\u0026quot;2018-10-01\u0026quot;, LocalDate::from); log.debug(\u0026quot;{}\u0026quot;, date); }).start(); } }  }\n ## 7.2 不可变设计 另一个大家更为熟悉的 String 类也是不可变的，以它为例，说明一下不可变设计的要素  java public final class String implements java.io.Serializable, Comparable, CharSequence { /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0\n// ...  }\n final 的使用(final只能保证对象的引用时不能够改变的，但是它的内容是可以改变的) 发现该类、类中所有属性都是 final 的 * 属性用 final 修饰保证了该属性是只读的，不能修改 * 类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性 ### 保护性拷贝 但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例：  java public String substring(int beginIndex) { if (beginIndex \u0026lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } int subLen = value.length - beginIndex; if (subLen \u0026lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } return (beginIndex == 0) ? this : new String(value, beginIndex, subLen); }\n 发现其内部是调用 String 的构造方法创建了一个新字符串，再进入这个构造看看，是否对 final char[] value 做出 了修改：  java public String(char value[], int offset, int count) { if (offset \u0026lt; 0) { throw new StringIndexOutOfBoundsException(offset); } if (count \u0026lt;= 0) { if (count \u0026lt; 0) { throw new StringIndexOutOfBoundsException(count); } if (offset \u0026lt;= value.length) { this.value = \u0026ldquo;\u0026rdquo;.value; return; } } if (offset \u0026gt; value.length - count) { throw new StringIndexOutOfBoundsException(offset + count); } this.value = Arrays.copyOfRange(value, offset, offset+count); }\n 结果发现也没有，构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避 免共享的手段称之为【**保护性拷贝（defensive copy）**】 为了保证对象的不可变性，需要使用一种保护性拷贝的机制。在对象有修改发生的情况下会创建一个新的对象。这样虽然能避免共享保证这些方法的线程安全，但是也带来了一个严重的问题，就是对象创建的太频繁，对象的个数较多。因此对于这种不可变类的设计会关联一种设计模式：享元模式 ### * 模式之享元 ### * 原理之 final ## 7.3 无状态 在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这 种没有任何成员变量的类是线程安全的  因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】\n ## 本章小结 * 不可变类使用 * 不可变类设计 * 原理方面 * final * 模式方面 * 享元 # 8. 共享模型之工具 ## 8.1 线程池 类似享元模式的思想 ### 1. 自定义线程池  mermaid graph LR subgraph Blocking Queue task1(task 1)\u0026ndash;\u0026gt; task2(task 2)\ntask2\u0026ndash;\u0026gt;task3(task 3) end subgraph Thread Pool t1(t1) t2(t2) t3(t3) end t1(t1)\u0026ndash;poll\u0026ndash;\u0026gt;task1 t2(t2)-.poll.-\u0026gt;task1 t3(t3)-.poll.-\u0026gt;task1 task3\u0026ndash;put\u0026ndash;\u0026gt;main(main)\n 步骤 1 ：自定义拒绝策略接口  java @FunctionalInterface // 拒绝策略 interface RejectPolicy { void reject(BlockingQueue queue, T task); }\n 步骤 2 ：自定义任务队列  java @Slf4j(topic = \u0026ldquo;c.BlockingQueue\u0026rdquo;) class BlockingQueue { // 1. 任务队列 private Deque queue = new ArrayDeque\u0026lt;\u0026gt;();\n// 2. 锁 private ReentrantLock lock = new ReentrantLock(); // 3. 生产者条件变量 private Condition fullWaitSet = lock.newCondition(); // 4. 消费者条件变量 private Condition emptyWaitSet = lock.newCondition(); // 5. 容量 private int capcity; public BlockingQueue(int capcity) { this.capcity = capcity; } // 带超时阻塞获取 public T poll(long timeout, TimeUnit unit) { lock.lock(); try { // 将 timeout 统一转换为 纳秒 long nanos = unit.toNanos(timeout); while (queue.isEmpty()) { try { // 返回值是剩余时间 if (nanos \u0026lt;= 0) { return null; } nanos = emptyWaitSet.awaitNanos(nanos); } catch (InterruptedException e) { e.printStackTrace(); } } T t = queue.removeFirst(); fullWaitSet.signal(); return t; } finally { lock.unlock(); } } // 阻塞获取 public T take() { lock.lock(); try { while (queue.isEmpty()) { try { emptyWaitSet.await(); } catch (InterruptedException e) { e.printStackTrace(); } } T t = queue.removeFirst(); fullWaitSet.signal(); return t; } finally { lock.unlock(); } } // 阻塞添加 public void put(T task) { lock.lock(); try { while (queue.size() == capcity) { try { log.debug(\u0026quot;等待加入任务队列 {} ...\u0026quot;, task); fullWaitSet.await(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\u0026quot;加入任务队列 {}\u0026quot;, task); queue.addLast(task); emptyWaitSet.signal(); } finally { lock.unlock(); } } // 带超时时间阻塞添加 public boolean offer(T task, long timeout, TimeUnit timeUnit) { lock.lock(); try { long nanos = timeUnit.toNanos(timeout); while (queue.size() == capcity) { try { if(nanos \u0026lt;= 0) { return false; } log.debug(\u0026quot;等待加入任务队列 {} ...\u0026quot;, task); nanos = fullWaitSet.awaitNanos(nanos); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\u0026quot;加入任务队列 {}\u0026quot;, task); queue.addLast(task); emptyWaitSet.signal(); return true; } finally { lock.unlock(); } } public int size() { lock.lock(); try { return queue.size(); } finally { lock.unlock(); } } public void tryPut(RejectPolicy\u0026lt;T\u0026gt; rejectPolicy, T task) { lock.lock(); try { // 判断队列是否满 if(queue.size() == capcity) { rejectPolicy.reject(this, task); } else { // 有空闲 log.debug(\u0026quot;加入任务队列 {}\u0026quot;, task); queue.addLast(task); emptyWaitSet.signal(); } } finally { lock.unlock(); } }  }\n 步骤 3 ：自定义线程池  java @Slf4j(topic = \u0026ldquo;c.ThreadPool\u0026rdquo;) class ThreadPool { // 任务队列 private BlockingQueue taskQueue;\n// 线程集合 private HashSet\u0026lt;Worker\u0026gt; workers = new HashSet\u0026lt;\u0026gt;(); // 核心线程数 private int coreSize; // 获取任务时的超时时间 private long timeout; private TimeUnit timeUnit; private RejectPolicy\u0026lt;Runnable\u0026gt; rejectPolicy; // 执行任务 public void execute(Runnable task) { // 当任务数没有超过 coreSize 时，直接交给 worker 对象执行 // 如果任务数超过 coreSize 时，加入任务队列暂存 synchronized (workers) { if(workers.size() \u0026lt; coreSize) { Worker worker = new Worker(task); log.debug(\u0026quot;新增 worker{}, {}\u0026quot;, worker, task); workers.add(worker); worker.start(); } else {  // taskQueue.put(task); // 1) 死等 // 2) 带超时等待 // 3) 让调用者放弃任务执行 // 4) 让调用者抛出异常 // 5) 让调用者自己执行任务 taskQueue.tryPut(rejectPolicy, task); } } }\npublic ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapcity, RejectPolicy\u0026lt;Runnable\u0026gt; rejectPolicy) { this.coreSize = coreSize; this.timeout = timeout; this.timeUnit = timeUnit; this.taskQueue = new BlockingQueue\u0026lt;\u0026gt;(queueCapcity); this.rejectPolicy = rejectPolicy; } class Worker extends Thread{ private Runnable task; public Worker(Runnable task) { this.task = task; } @Override public void run() { // 执行任务 // 1) 当 task 不为空，执行任务 // 2) 当 task 执行完毕，再接着从任务队列获取任务并执行  // while(task != null || (task = taskQueue.take()) != null) { while(task != null || (task = taskQueue.poll(timeout, timeUnit)) != null) { try { log.debug(\u0026ldquo;正在执行\u0026hellip;{}\u0026rdquo;, task); task.run(); } catch (Exception e) { e.printStackTrace(); } finally { task = null; } } synchronized (workers) { log.debug(\u0026ldquo;worker 被移除{}\u0026rdquo;, this); workers.remove(this); } } } }\n 步骤 4 ：测试  java @Slf4j(topic = \u0026ldquo;c.TestPool\u0026rdquo;) public class TestPool { public static void main(String[] args) { ThreadPool threadPool = new ThreadPool(1, 1000, TimeUnit.MILLISECONDS, 1, (queue, task)-\u0026gt;{ // 1. 死等 // queue.put(task); // 2) 带超时等待 // queue.offer(task, 1500, TimeUnit.MILLISECONDS); // 3) 让调用者放弃任务执行 // log.debug(\u0026ldquo;放弃{}\u0026rdquo;, task); // 4) 让调用者抛出异常 // throw new RuntimeException(\u0026ldquo;任务执行失败 \u0026rdquo; + task); // 5) 让调用者自己执行任务 task.run(); }); for (int i = 0; i \u0026lt; 4; i++) { int j = i; threadPool.execute(() -\u0026gt; { try { Thread.sleep(1000L); } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\u0026ldquo;{}\u0026rdquo;, j); }); } } }\n ThreadPoolExecutor ![image-20200420163805818](/resources/技术收录/Java/java并发/image-20200420163805818.png) ### 1) 线程池状态 ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量 | 状态名 | 高3位 | 接受新任务 | 处理阻塞队列任务 | 说明 | | ---------- | ----- | ---------- | ---------------- | ------------------------------------------ | | RUNNING | 111 | Y | Y | | | SHUTDOWN | 000 | N | Y | 不会接收新任务，但会处理阻塞队列剩余 任务 | | STOP | 001 | N | N | 会中断正在执行的任务，并抛弃阻塞队列 任务 | | TIDYING | 010 | - | - | 任务全执行完毕，活动线程为 0 即将进入 终结 | | TERMINATED | 011 | - | - | 终结状态 | 从数字上比较，TERMINATED \u0026gt; TIDYING \u0026gt; STOP \u0026gt; SHUTDOWN \u0026gt; RUNNING 这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作 进行赋值  java // c 为旧值， ctlOf 返回结果为新值 ctl.compareAndSet(c, ctlOf(targetState, workerCountOf\u0026copy;))); // rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们 private static int ctlOf(int rs, int wc) { return rs | wc; }\n ### 2) 构造方法  java public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)\n * corePoolSize 核心线程数目 (最多保留的线程数) * maximumPoolSize 最大线程数目 * keepAliveTime 生存时间 - 针对救急线程 * unit 时间单位 - 针对救急线程 * workQueue 阻塞队列 * threadFactory 线程工厂 - 可以为线程创建时起个好名字 * handler 拒绝策略 工作方式：  mermaid graph LR subgraph 线程池c=2,m=3 a1(救急线程1) a2(核心线程1)\u0026ndash;\u0026gt;a3(任务1) a5(核心线程2)\u0026ndash;\u0026gt;a4(任务2) end subgraph 阻塞队列 q1(size=2) q2(任务3) 13(任务4) end\n * 线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。 * 当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排 队，直到有空闲的线程。 * 如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线 程来救急。 * 如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，其它 著名框架也提供了实现 * AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略 * CallerRunsPolicy 让调用者运行任务 * DiscardPolicy 放弃本次任务 * DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之 * Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方 便定位问题 * Netty 的实现，是创建一个新线程来执行任务 * ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略 * PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略 * 当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制。 ![image-20200420164754738](/resources/技术收录/Java/java并发/image-20200420164754738.png) 根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池 ### 3)newFixedThreadPool  java public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()); }\n 特点 * 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间 * 阻塞队列是无界的，可以放任意数量的任务 \u0026gt; 评价 适用于任务量已知，相对耗时的任务 创建的都是核心线程，因此即使线程池中没有任务执行了，程序也不会主动停止（非守护线程）  java private static void test2() throws InterruptedException { AtomicInteger num = new AtomicInteger(0); ExecutorService service = Executors.newFixedThreadPool(10, \u0026reg; -\u0026gt; { return new Thread(r, \u0026ldquo;t\u0026rdquo; + num.getAndIncrement()); }); CountDownLatch latch = new CountDownLatch(10); String[] all = new String[10]; Random r = new Random(); for (int j = 0; j \u0026lt; 10; j++) { int x = j; service.submit(() -\u0026gt; { for (int i = 0; i \u0026lt;= 100; i++) { try { Thread.sleep(r.nextInt(100)); } catch (InterruptedException e) { } all[x] = Thread.currentThread().getName() + \u0026ldquo;(\u0026rdquo; + (i + \u0026ldquo;%\u0026rdquo;) + \u0026ldquo;)\u0026rdquo;; System.out.print(\u0026rdquo;\\r\u0026rdquo; + Arrays.toString(all)); } latch.countDown(); }); } latch.await(); System.out.println(\u0026rdquo;\\n游戏开始\u0026hellip;\u0026ldquo;); service.shutdown(); }\n ### 4)newCachedThreadPool  java public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue()); }\n 特点 * 核心线程数是 0 ， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 * 全部都是救急线程（60s 后可以回收） * 救急线程可以无限创建 * 队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交 货） ```java SynchronousQueue\u0026lt;Integer\u0026gt; integers = new SynchronousQueue\u0026lt;\u0026gt;(); new Thread(() -\u0026gt; { try { log.debug(\u0026quot;putting {} \u0026quot;, 1); integers.put(1); log.debug(\u0026quot;{} putted...\u0026quot;, 1); log.debug(\u0026quot;putting...{} \u0026quot;, 2); integers.put(2); log.debug(\u0026quot;{} putted...\u0026quot;, 2); } catch (InterruptedException e) { e.printStackTrace(); } },\u0026quot;t1\u0026quot;).start(); sleep(1); new Thread(() -\u0026gt; { try { log.debug(\u0026quot;taking {}\u0026quot;, 1); integers.take(); } catch (InterruptedException e) { e.printStackTrace(); } },\u0026quot;t2\u0026quot;).start(); sleep(1); new Thread(() -\u0026gt; { try { log.debug(\u0026quot;taking {}\u0026quot;, 2); integers.take(); } catch (InterruptedException e) { e.printStackTrace(); } },\u0026quot;t3\u0026quot;).start(); ``` 输出  11:48:15.500 c.TestSynchronousQueue [t1] - putting 1 11:48:16.500 c.TestSynchronousQueue [t2] - taking 1 11:48:16.500 c.TestSynchronousQueue [t1] - 1 putted\u0026hellip; 11:48:16.500 c.TestSynchronousQueue [t1] - putting\u0026hellip;2 11:48:17.502 c.TestSynchronousQueue [t3] - taking 2 11:48:17.503 c.TestSynchronousQueue [t1] - 2 putted\u0026hellip;\n \u0026gt; 评价 \u0026gt; \u0026gt; 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1 分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况 ### 5)newSingleThreadExecutor  java public static ExecutorService newSingleThreadExecutor() {//使用了装饰器模式 return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue())); }\n 使用场景： 希望多个任务排队执行。线程数固定为 1 (即使某一次执行任务时出现一些异常或意想不到的错误，导致线程池中的线程崩溃，线程池也会重新创建一个线程来执行剩下的任务)，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。 区别： * 自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作 * Executors.newSingleThreadExecutor() 线程个数始终为 1 ，不能修改 * FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因 此不能调用 ThreadPoolExecutor 中特有的方法 * Executors.newFixedThreadPool(1) 初始时为 1 ，以后还可以修改 对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改  java ExecutorService pool = Executors.newSingleThreadExecutor(); pool.execute(() -\u0026gt; { log.debug(\u0026ldquo;1\u0026rdquo;); int i = 1 / 0; });\n pool.execute(() -\u0026gt; { log.debug(\u0026quot;2\u0026quot;); }); pool.execute(() -\u0026gt; { log.debug(\u0026quot;3\u0026quot;); });   ### 6) 提交任务  java // 执行任务 void execute(Runnable command); // 提交任务 task，用返回值 Future 获得任务执行结果  Future submit(Callable task); // 提交 tasks 中所有任务  List\u0026gt; invokeAll(Collection\u0026lt;? extends Callable\u0026gt; tasks) throws InterruptedException; // 提交 tasks 中所有任务，带超时时间  List\u0026gt; invokeAll(Collection\u0026lt;? extends Callable\u0026gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; // 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消  T invokeAny(Collection\u0026lt;? extends Callable\u0026gt; tasks) throws InterruptedException, ExecutionException; // 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间  T invokeAny(Collection\u0026lt;? extends Callable\u0026gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;\n  java\n@Slf4j(topic = \u0026ldquo;c.TestSubmit\u0026rdquo;) public class TestSubmit {\npublic static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService pool = Executors.newFixedThreadPool(1); } private static void method3(ExecutorService pool) throws InterruptedException, ExecutionException { String result = pool.invokeAny(Arrays.asList( () -\u0026gt; { log.debug(\u0026quot;begin 1\u0026quot;); Thread.sleep(1000); log.debug(\u0026quot;end 1\u0026quot;); return \u0026quot;1\u0026quot;; }, () -\u0026gt; { log.debug(\u0026quot;begin 2\u0026quot;); Thread.sleep(500); log.debug(\u0026quot;end 2\u0026quot;); return \u0026quot;2\u0026quot;; }, () -\u0026gt; { log.debug(\u0026quot;begin 3\u0026quot;); Thread.sleep(2000); log.debug(\u0026quot;end 3\u0026quot;); return \u0026quot;3\u0026quot;; } )); log.debug(\u0026quot;{}\u0026quot;, result); } private static void method2(ExecutorService pool) throws InterruptedException { List\u0026lt;Future\u0026lt;String\u0026gt;\u0026gt; futures = pool.invokeAll(Arrays.asList( () -\u0026gt; { log.debug(\u0026quot;begin\u0026quot;); Thread.sleep(1000); return \u0026quot;1\u0026quot;; }, () -\u0026gt; { log.debug(\u0026quot;begin\u0026quot;); Thread.sleep(500); return \u0026quot;2\u0026quot;; }, () -\u0026gt; { log.debug(\u0026quot;begin\u0026quot;); Thread.sleep(2000); return \u0026quot;3\u0026quot;; } )); futures.forEach( f -\u0026gt; { try { log.debug(\u0026quot;{}\u0026quot;, f.get()); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } }); } private static void method1(ExecutorService pool) throws InterruptedException, ExecutionException { Future\u0026lt;String\u0026gt; future = pool.submit(() -\u0026gt; { log.debug(\u0026quot;running\u0026quot;); Thread.sleep(1000); return \u0026quot;ok\u0026quot;; }); log.debug(\u0026quot;{}\u0026quot;, future.get()); }  }\n ### 7) 关闭线程池 shutdown  java /* 线程池状态变为 SHUTDOWN - 不会接收新任务 - 但已提交任务会执行完 - 此方法不会阻塞调用线程的执行 */ void shutdown();\n  java public void shutdown() { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { checkShutdownAccess(); // 修改线程池状态 advanceRunState(SHUTDOWN); // 仅会打断空闲线程 interruptIdleWorkers(); onShutdown(); // 扩展点 ScheduledThreadPoolExecutor } finally { mainLock.unlock(); } // 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等) tryTerminate(); }\n **shutdownNow**  java /* 线程池状态变为 STOP - 不会接收新任务 - 会将队列中的任务返回 - 并用 interrupt 的方式中断正在执行的任务 */ List shutdownNow();\n  java public List shutdownNow() {List tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { checkShutdownAccess(); // 修改线程池状态 advanceRunState(STOP); // 打断所有线程 interruptWorkers(); // 获取队列中剩余任务 tasks = drainQueue(); } finally { mainLock.unlock(); } // 尝试终结 tryTerminate(); return tasks; }\n  java void shutdown(); public void shutdown() { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { checkShutdownAccess(); // 修改线程池状态 advanceRunState(SHUTDOWN); // 仅会打断空闲线程 interruptIdleWorkers(); onShutdown(); // 扩展点 ScheduledThreadPoolExecutor } finally { mainLock.unlock(); } // 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等) tryTerminate(); }\n ### 其它方法  java // 不在 RUNNING 状态的线程池，此方法就返回 true boolean isShutdown(); // 线程池状态是否是 TERMINATED boolean isTerminated(); // 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事 情，可以利用此方法等待 boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;\n  java\n@Slf4j(topic = \u0026ldquo;c.TestShutDown\u0026rdquo;) public class TestShutDown {\npublic static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService pool = Executors.newFixedThreadPool(2); Future\u0026lt;Integer\u0026gt; result1 = pool.submit(() -\u0026gt; { log.debug(\u0026quot;task 1 running...\u0026quot;); Thread.sleep(1000); log.debug(\u0026quot;task 1 finish...\u0026quot;); return 1; }); Future\u0026lt;Integer\u0026gt; result2 = pool.submit(() -\u0026gt; { log.debug(\u0026quot;task 2 running...\u0026quot;); Thread.sleep(1000); log.debug(\u0026quot;task 2 finish...\u0026quot;); return 2; }); Future\u0026lt;Integer\u0026gt; result3 = pool.submit(() -\u0026gt; { log.debug(\u0026quot;task 3 running...\u0026quot;); Thread.sleep(1000); log.debug(\u0026quot;task 3 finish...\u0026quot;); return 3; }); log.debug(\u0026quot;shutdown\u0026quot;);  // pool.shutdown();//并不会等待其他线程结束（也就是不会等其他线程结束了之后再执行下面的代码，而会立即执行下面的代码） // pool.awaitTermination(3, TimeUnit.SECONDS);//如果需要等待 使用awaitTermination（这样的话不知道要等多久） 也可以使用feature的get方法阻塞住（不需要知道等多久，会一直等待结束） List runnables = pool.shutdownNow();//正在运行中的线程都会被打断 会返回还没有执行的线程 log.debug(\u0026ldquo;other\u0026hellip;. {}\u0026rdquo; , runnables); } }\n ### * 模式之 Worker Thread ### 8) 任务调度线程池 在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。  java public static void main(String[] args) { Timer timer = new Timer(); TimerTask task1 = new TimerTask() { @Override public void run() { log.debug(\u0026ldquo;task 1\u0026rdquo;); sleep(2); //任务一中出现了异常那么任务而也就没法接着执行下去 } }; TimerTask task2 = new TimerTask() { @Override public void run() { log.debug(\u0026ldquo;task 2\u0026rdquo;); } }; // 使用 timer 添加两个任务，希望它们都在 1s 后执行 // 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行 timer.schedule(task1, 1000); timer.schedule(task2, 1000); }\n 输出  20:46:09.444 c.TestTimer [main] - start\u0026hellip; 20:46:10.447 c.TestTimer [Timer-0] - task 1 20:46:12.448 c.TestTimer [Timer-0] - task 2\n 使用 ScheduledExecutorService 改写：  java //线程池大小为2 ScheduledExecutorService executor = Executors.newScheduledThreadPool(2); // 添加两个任务，希望它们都在 1s 后执行 executor.schedule(() -\u0026gt; { System.out.println(\u0026ldquo;任务1，执行时间：\u0026rdquo; + new Date()); try { Thread.sleep(2000); //即使线程池设为1，任务一中即使出现异常也不会中断 }catch (InterruptedException e) { } }, 1000, TimeUnit.MILLISECONDS); executor.schedule(() -\u0026gt; { System.out.println(\u0026ldquo;任务2，执行时间：\u0026rdquo; + new Date()); }, 1000, TimeUnit.MILLISECONDS);\n 输出  任务 1 ，执行时间：Thu Jan 03 12:45:17 CST 2019 任务 2 ，执行时间：Thu Jan 03 12:45:17 CST 2019\n scheduleAtFixedRate 例子： 每隔多少秒执行该任务(循环重复的执行)  java ScheduledExecutorService pool = Executors.newScheduledThreadPool(1); log.debug(\u0026ldquo;start\u0026hellip;\u0026rdquo;); pool.scheduleAtFixedRate(() -\u0026gt; { //任务执行时间过长的话会等待任务执行完在执行(不会在延迟) log.debug(\u0026ldquo;running\u0026hellip;\u0026rdquo;); }, 1, 1, TimeUnit.SECONDS);\n 输出  21:45:43.167 c.TestTimer [main] - start\u0026hellip; 21:45:44.215 c.TestTimer [pool-1-thread-1] - running\u0026hellip; 21:45:45.215 c.TestTimer [pool-1-thread-1] - running\u0026hellip; 21:45:46.215 c.TestTimer [pool-1-thread-1] - running\u0026hellip; 21:45:47.215 c.TestTimer [pool-1-thread-1] - running\u0026hellip;\n scheduleAtFixedRate 例子（任务执行时间超过了间隔时间）：  java ScheduledExecutorService pool = Executors.newScheduledThreadPool(1); log.debug(\u0026ldquo;start\u0026hellip;\u0026rdquo;); pool.scheduleAtFixedRate(() -\u0026gt; { log.debug(\u0026ldquo;running\u0026hellip;\u0026rdquo;); sleep(2); //任务执行时间过长的话会等待任务执行完在执行(会在执行完的基础上再延迟) }, 1, 1, TimeUnit.SECONDS);\n 输出分析：一开始，延时 1s，接下来，由于任务执行时间 \u0026gt; 间隔时间，间隔被『撑』到了 2s  21:44:30.311 c.TestTimer [main] - start\u0026hellip; 21:44:31.360 c.TestTimer [pool-1-thread-1] - running\u0026hellip; 21:44:33.361 c.TestTimer [pool-1-thread-1] - running\u0026hellip; 21:44:35.362 c.TestTimer [pool-1-thread-1] - running\u0026hellip; 21:44:37.362 c.TestTimer [pool-1-thread-1] - running\u0026hellip;\n scheduleWithFixedDelay 例子：  java ScheduledExecutorService pool = Executors.newScheduledThreadPool(1); log.debug(\u0026ldquo;start\u0026hellip;\u0026rdquo;); pool.scheduleWithFixedDelay(()-\u0026gt; { log.debug(\u0026ldquo;running\u0026hellip;\u0026rdquo;); sleep(2); }, 1, 1, TimeUnit.SECONDS);\n 输出分析：一开始，延时 1s，scheduleWithFixedDelay 的间隔是 上一个任务结束 \u0026lt;-\u0026gt; 延时 \u0026lt;-\u0026gt; 下一个任务开始 所 以间隔都是 3s  21:40:55.078 c.TestTimer [main] - start\u0026hellip; 21:40:56.140 c.TestTimer [pool-1-thread-1] - running\u0026hellip; 21:40:59.143 c.TestTimer [pool-1-thread-1] - running\u0026hellip; 21:41:02.145 c.TestTimer [pool-1-thread-1] - running\u0026hellip; 21:41:05.147 c.TestTimer [pool-1-thread-1] - running\u0026hellip;\n \u0026gt; 评价 整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放。用来执行延迟或反复执行的任务 ### 9) 正确处理执行任务异常 #### 方法 1 ：主动捉异常  java ExecutorService pool = Executors.newFixedThreadPool(1); pool.submit(() -\u0026gt; { try { log.debug(\u0026ldquo;task1\u0026rdquo;); int i = 1 / 0; } catch (Exception e) { log.error(\u0026ldquo;error:\u0026ldquo;, e); } });\n 输出  21:59:04.558 c.TestTimer [pool-1-thread-1] - task1 21:59:04.562 c.TestTimer [pool-1-thread-1] - error: java.lang.ArithmeticException: / by zero at cn.itcast.n8.TestTimer.lambda$main$0(TestTimer.java:28) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)\n #### 方法 2 ：使用 Future 在任务执行时出现的异常信息会封装再Future对象中，调用get方法拿到的就不是返回值了，是异常信息  java ExecutorService pool = Executors.newFixedThreadPool(1); Future f = pool.submit(() -\u0026gt; { log.debug(\u0026ldquo;task1\u0026rdquo;); int i = 1 / 0; return true; }); log.debug(\u0026ldquo;result:{}\u0026ldquo;, f.get());\n 输出  21:54:58.208 c.TestTimer [pool-1-thread-1] - task1 Exception in thread \u0026ldquo;main\u0026rdquo; java.util.concurrent.ExecutionException: java.lang.ArithmeticException: / by zero at java.util.concurrent.FutureTask.report(FutureTask.java:122) at java.util.concurrent.FutureTask.get(FutureTask.java:192) at cn.itcast.n8.TestTimer.main(TestTimer.java:31) Caused by: java.lang.ArithmeticException: / by zero at cn.itcast.n8.TestTimer.lambda$main$0(TestTimer.java:28) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748);\n ### * 应用之定时任务 ### Tomcat 线程池 Tomcat 在哪里用到了线程池呢  mermaid graph LR subgraph \u0026ldquo;Connentor(NIO EndPoint)\u0026rdquo; a1(LimitLatch)\u0026ndash;\u0026gt;b1(Acceptor) b1\u0026ndash;\u0026gt;c1(SocketChannel 1) b1\u0026ndash;\u0026gt;c2(SocketChannel 2) c1\u0026ndash;有读\u0026ndash;\u0026gt;d1(Poller) c2\u0026ndash;有读\u0026ndash;\u0026gt;d1 subgraph Excutor q1(worker1) q2(worker2) end d1\u0026ndash;socketProcesser\u0026ndash;\u0026gt;q1 d1\u0026ndash;socketProcesser\u0026ndash;\u0026gt;q2 end\n * LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲 * Acceptor 只负责【接收新的 socket 连接】 * Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】 * 一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理 * Executor 线程池中的工作线程最终负责【处理请求】 Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同 * 如果总线程数达到 maximumPoolSize * 这时不会立刻抛 RejectedExecutionException 异常 * 而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常 合理分工是实现高并发的基础 源码 tomcat-7.0.42  java public void execute(Runnable command, long timeout, TimeUnit unit) { submittedCount.incrementAndGet(); try { super.execute(command); } catch (RejectedExecutionException rx) { if (super.getQueue() instanceof TaskQueue) { final TaskQueue queue = (TaskQueue)super.getQueue(); try { if (!queue.force(command, timeout, unit)) { submittedCount.decrementAndGet(); throw new RejectedExecutionException(\u0026ldquo;Queue capacity is full.\u0026rdquo;); } } catch (InterruptedException x) { submittedCount.decrementAndGet(); Thread.interrupted(); throw new RejectedExecutionException(x); } } else { submittedCount.decrementAndGet(); throw rx; } } }\n TaskQueue.java  java public boolean force(Runnable o, long timeout, TimeUnit unit) throws InterruptedException { if ( parent.isShutdown() ) throw new RejectedExecutionException(\u0026ldquo;Executor not running, can\u0026rsquo;t force a command into the queue\u0026rdquo;); return super.offer(o,timeout,unit); //forces the item onto the queue, to be used if the task is rejected }\n Connector 配置 | 配置项 | 默认值 | 说明 | | ------------------- | ------ | -------------------------------------- | | acceptorThreadCount | 1 | acceptor 线程数量 | | pollerThreadCount | 1 | poller 线程数量 | | minSpareThreads | 10 | 核心线程数，即 corePoolSize | | maxThreads | 200 | 最大线程数，即 maximumPoolSize | | executor | - | Executor 名称，用来引用下面的 Executor | Executor 线程配置 | 配置项 | 默认值 | 说明 | | ----------------------- | ----------------- | ----------------------------------------- | | threadPriority | 5 | 线程优先级 | | daemon | true | 是否守护线程 | | minSpareThreads | 25 | 核心线程数，即 corePoolSize | | maxThreads | 200 | 最大线程数，即 maximumPoolSize | | maxIdleTime | 60000 | 线程生存时间，单位是毫秒，默认值即 1 分钟 | | maxQueueSize | Integer.MAX_VALUE | 队列长度 | | prestartminSpareThreads | false | 核心线程是否在服务器启动时启动 |  mermaid graph LR a(添加新任务)\u0026ndash;\u0026gt;b(提交任务\u0026lt;核心线程) b\u0026ndash;是\u0026ndash;\u0026gt;c(加入队列) b\u0026ndash;否\u0026ndash;\u0026gt;d(提交任务\u0026lt;最大线程) d\u0026ndash;否\u0026ndash;\u0026gt;c d\u0026ndash;是\u0026ndash;\u0026gt;e(创建急救线程)\n tomcat中的线程是守护线程这就意味着一但tomcat的主线程停止，那么这些守护线程也都会停止。普通的线程池都是非守护线程。 tomcat会先给最大线程进行比较然后创建救急线程，然后再加入队列。 ### Fork/Join 1. 概念 Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型 运算 所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计 算，如归并排序、斐波那契数列、都可以用分治思想进行求解 Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运 算效率 **Fork/Join 默认会创建与 cpu 核心数大小相同的线程池** **使用** 提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下 面定义了一个对 1~n 之间的整数求和的任务  java\n@Slf4j(topic = \u0026ldquo;c.TestForkJoin2\u0026rdquo;) public class TestForkJoin2 {\npublic static void main(String[] args) { ForkJoinPool pool = new ForkJoinPool(4); System.out.println(pool.invoke(new MyTask(5))); // new MyTask(5) 5+ new MyTask(4) 4 + new MyTask(3) 3 + new MyTask(2) 2 + new MyTask(1) }  }\n// 1~n 之间整数的和 @Slf4j(topic = \u0026ldquo;c.MyTask\u0026rdquo;) class MyTask extends RecursiveTask {\nprivate int n; public MyTask(int n) { this.n = n; } @Override public String toString() { return \u0026quot;{\u0026quot; + n + '}'; } @Override protected Integer compute() { // 如果 n 已经为 1，可以求得结果了 if (n == 1) { log.debug(\u0026quot;join() {}\u0026quot;, n); return n; } // 将任务进行拆分(fork) AddTask1 t1 = new AddTask1(n - 1); t1.fork(); log.debug(\u0026quot;fork() {} + {}\u0026quot;, n, t1); // 合并(join)结果 int result = n + t1.join(); log.debug(\u0026quot;join() {} + {} = {}\u0026quot;, n, t1, result); return result; }  }\n 结果  [ForkJoinPool-1-worker-0] - fork() 2 + {1} [ForkJoinPool-1-worker-1] - fork() 5 + {4} [ForkJoinPool-1-worker-0] - join() 1 [ForkJoinPool-1-worker-0] - join() 2 + {1} = 3 [ForkJoinPool-1-worker-2] - fork() 4 + {3} [ForkJoinPool-1-worker-3] - fork() 3 + {2} [ForkJoinPool-1-worker-3] - join() 3 + {2} = 6 [ForkJoinPool-1-worker-2] - join() 4 + {3} = 10 [ForkJoinPool-1-worker-1] - join() 5 + {4} = 15 15\n 用图来表示  mermaid graph LR a(\u0026ldquo;t1 5 + {4}\u0026rdquo;)-.15.-\u0026gt;b(\u0026ldquo;结果\u0026rdquo;) a\u0026ndash;\u0026ldquo;{4}\u0026rdquo;\u0026ndash;\u0026gt;c(\u0026ldquo;t2 4 + {3}\u0026rdquo;) c-.\u0026ldquo;10\u0026rdquo;.-\u0026gt;a c\u0026ndash;\u0026ldquo;{3}\u0026rdquo;\u0026ndash;\u0026gt;d(\u0026ldquo;t3 3 + {2}\u0026rdquo;) d-.6.-\u0026gt;c d\u0026ndash;\u0026ldquo;{2}\u0026rdquo;\u0026ndash;\u0026gt;e(\u0026ldquo;t0 2 + {1}\u0026rdquo;) e-.3.-\u0026gt;d e\u0026ndash;\u0026ldquo;{1}\u0026rdquo;\u0026ndash;\u0026gt;f(t0) f-.1.-\u0026gt;e\n 改进  java @Slf4j(topic = \u0026ldquo;c.AddTask\u0026rdquo;) class AddTask3 extends RecursiveTask { int begin; int end; public AddTask3(int begin, int end) { this.begin = begin; this.end = end; } @Override public String toString() { return \u0026ldquo;{\u0026rdquo; + begin + \u0026ldquo;,\u0026rdquo; + end + \u0026lsquo;}\u0026rsquo;; } @Override protected Integer compute() { if (begin == end) { log.debug(\u0026ldquo;join() {}\u0026rdquo;, begin); return begin; } if (end - begin == 1) { log.debug(\u0026ldquo;join() {} + {} = {}\u0026rdquo;, begin, end, end + begin); return end + begin; } int mid = (end + begin) / 2; AddTask3 t1 = new AddTask3(begin, mid); t1.fork(); AddTask3 t2 = new AddTask3(mid + 1, end); t2.fork(); log.debug(\u0026ldquo;fork() {} + {} = ?\u0026rdquo;, t1, t2); int result = t1.join() + t2.join(); log.debug(\u0026ldquo;join() {} + {} = {}\u0026rdquo;, t1, t2, result); return result; } }\n 然后提交给 ForkJoinPool 来执行  java public static void main(String[] args) { ForkJoinPool pool = new ForkJoinPool(4); System.out.println(pool.invoke(new AddTask3(1, 10))); }\n 结果  [ForkJoinPool-1-worker-0] - join() 1 + 2 = 3 [ForkJoinPool-1-worker-3] - join() 4 + 5 = 9 [ForkJoinPool-1-worker-0] - join() 3 [ForkJoinPool-1-worker-1] - fork() {1,3} + {4,5} =? [ForkJoinPool-1-worker-2] - fork() {1,2} + {3,3} =? [ForkJoinPool-1-worker-2] - join() {1,2} + {3,3} = 6 [ForkJoinPool-1-worker-1] - join() {1,3} + {4,5} = 15 15\n ### 用图来表示  mermaid graph LR a(\u0026ldquo;t1 {1,3} + {4,5}\u0026rdquo;)\u0026ndash;\u0026ldquo;{1,3}\u0026rdquo;\u0026ndash;\u0026gt;b(\u0026ldquo;t2 {1,2} + {3,3}\u0026rdquo;) b\u0026ndash;\u0026ldquo;{3,3}\u0026rdquo;\u0026ndash;\u0026gt;c(\u0026ldquo;t0\u0026rdquo;) a\u0026ndash;\u0026ldquo;{4,5}\u0026rdquo;\u0026ndash;\u0026gt;d(\u0026ldquo;t3\u0026rdquo;) a-.\u0026ldquo;15\u0026rdquo;.-\u0026gt;e(结果) d-.9.-\u0026gt;a b-.6.-\u0026gt;a b\u0026ndash;\u0026ldquo;{1,2}\u0026rdquo;\u0026ndash;\u0026gt;c c-.3.-\u0026gt;b c-.3.-\u0026gt;b\n ## 8.2 J.U.C ### 1.* AQS 原理 ### 2.* ReentrantLock 原理 ### 3.读写锁 #### 3.1 ReentrantReadWriteLock 当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。 类似于数据库中的 select ... from ... lock in share mode 提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法  java class DataContainer { private Object data; //读写锁 private ReentrantReadWriteLock rw = new ReentrantReadWriteLock(); //读锁 private ReentrantReadWriteLock.ReadLock r = rw.readLock(); //写锁 private ReentrantReadWriteLock.WriteLock w = rw.writeLock(); public Object read() { log.debug(\u0026ldquo;获取读锁\u0026hellip;\u0026rdquo;); r.lock(); try { log.debug(\u0026ldquo;读取\u0026rdquo;); sleep(1); return data; } finally { log.debug(\u0026ldquo;释放读锁\u0026hellip;\u0026rdquo;);r.unlock(); } } public void write() { log.debug(\u0026ldquo;获取写锁\u0026hellip;\u0026rdquo;); w.lock(); try { log.debug(\u0026ldquo;写入\u0026rdquo;); sleep(1); } finally { log.debug(\u0026ldquo;释放写锁\u0026hellip;\u0026rdquo;); w.unlock(); } } }\n 测试 读锁-读锁 可以并发  java DataContainer dataContainer = new DataContainer(); new Thread(() -\u0026gt; { dataContainer.read(); }, \u0026ldquo;t1\u0026rdquo;).start(); new Thread(() -\u0026gt; { dataContainer.read(); }, \u0026ldquo;t2\u0026rdquo;).start();\n 输出结果，从这里可以看到 Thread-0 锁定期间，Thread-1 的读操作不受影响  14:05:14.341 c.DataContainer [t2] - 获取读锁\u0026hellip; 14:05:14.341 c.DataContainer [t1] - 获取读锁\u0026hellip; 14:05:14.345 c.DataContainer [t1] - 读取 14:05:14.345 c.DataContainer [t2] - 读取 14:05:15.365 c.DataContainer [t2] - 释放读锁\u0026hellip; 14:05:15.386 c.DataContainer [t1] - 释放读锁\u0026hellip;\n 测试 读锁-写锁 相互阻塞  java DataContainer dataContainer = new DataContainer(); new Thread(() -\u0026gt; { dataContainer.read(); }, \u0026ldquo;t1\u0026rdquo;).start(); Thread.sleep(100); new Thread(() -\u0026gt; { dataContainer.write(); }, \u0026ldquo;t2\u0026rdquo;).start();\n 输出结果  14:04:21.838 c.DataContainer [t1] - 获取读锁\u0026hellip; 14:04:21.838 c.DataContainer [t2] - 获取写锁\u0026hellip; 14:04:21.841 c.DataContainer [t2] - 写入 14:04:22.843 c.DataContainer [t2] - 释放写锁\u0026hellip; 14:04:22.843 c.DataContainer [t1] - 读取 14:04:23.843 c.DataContainer [t1] - 释放读锁\u0026hellip;\n 写锁-写锁 也是相互阻塞的，这里就不测试了 读读可以并发，读写、写写是互斥的 注意事项 * 读锁不支持条件变量 * 重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待 ```java r.lock(); try { // ... w.lock(); try { // ... } finally{ w.unlock(); } } finally{ r.unlock(); } ``` * 重入时降级支持：即持有写锁的情况下去获取读锁  java class CachedData { Object data; // 是否有效，如果失效，需要重新计算 data volatile boolean cacheValid; final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); void processCachedData() { rwl.readLock().lock(); if (!cacheValid) { // 获取写锁前必须释放读锁 rwl.readLock().unlock(); rwl.writeLock().lock(); try { // 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新 if (!cacheValid) { data = \u0026hellip; cacheValid = true; } // 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存 rwl.readLock().lock(); } finally {rwl.writeLock().unlock(); } } // 自己用完数据, 释放读锁 try { use(data); } finally { rwl.readLock().unlock(); } } }\n #### * 应用之缓存 #### * 读写锁原理 #### 3.2 StampedLock 该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用 加解读锁  java long stamp = lock.readLock(); lock.unlockRead(stamp);\n 加解写锁  java long stamp = lock.writeLock(); lock.unlockWrite(stamp);\n 乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通 过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。  java long stamp = lock.tryOptimisticRead(); // 验戳 if(!lock.validate(stamp)){ // 锁升级 }\n 提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法  java class DataContainerStamped { private int data;private final StampedLock lock = new StampedLock(); public DataContainerStamped(int data) { this.data = data; } public int read(int readTime) { long stamp = lock.tryOptimisticRead(); log.debug(\u0026ldquo;optimistic read locking\u0026hellip;{}\u0026rdquo;, stamp); sleep(readTime); if (lock.validate(stamp)) { log.debug(\u0026ldquo;read finish\u0026hellip;{}, data:{}\u0026ldquo;, stamp, data); return data; } // 锁升级 - 读锁 log.debug(\u0026ldquo;updating to read lock\u0026hellip; {}\u0026rdquo;, stamp); try { stamp = lock.readLock(); log.debug(\u0026ldquo;read lock {}\u0026rdquo;, stamp); sleep(readTime); log.debug(\u0026ldquo;read finish\u0026hellip;{}, data:{}\u0026ldquo;, stamp, data); return data; } finally { log.debug(\u0026ldquo;read unlock {}\u0026rdquo;, stamp); lock.unlockRead(stamp); } } public void write(int newData) { long stamp = lock.writeLock(); log.debug(\u0026ldquo;write lock {}\u0026rdquo;, stamp); try { sleep(2); this.data = newData; } finally { log.debug(\u0026ldquo;write unlock {}\u0026rdquo;, stamp); lock.unlockWrite(stamp); } } }\n 测试 读-读 可以优化  java public static void main(String[] args) { DataContainerStamped dataContainer = new DataContainerStamped(1); new Thread(() -\u0026gt; { dataContainer.read(1); }, \u0026ldquo;t1\u0026rdquo;).start(); sleep(0.5); new Thread(() -\u0026gt; { dataContainer.read(0); }, \u0026ldquo;t2\u0026rdquo;).start(); }\n 输出结果，可以看到实际没有加读锁  15:58:50.217 c.DataContainerStamped [t1] - optimistic read locking\u0026hellip;256 15:58:50.717 c.DataContainerStamped [t2] - optimistic read locking\u0026hellip;256 15:58:50.717 c.DataContainerStamped [t2] - read finish\u0026hellip;256, data:1 15:58:51.220 c.DataContainerStamped [t1] - read finish\u0026hellip;256, data:1\n 测试 读-写 时优化读补加读锁  java public static void main(String[] args) { DataContainerStamped dataContainer = new DataContainerStamped(1); new Thread(() -\u0026gt; { dataContainer.read(1); }, \u0026ldquo;t1\u0026rdquo;).start(); sleep(0.5); new Thread(() -\u0026gt; { dataContainer.write(100); }, \u0026ldquo;t2\u0026rdquo;).start(); }\n 输出结果  15:57:00.219 c.DataContainerStamped [t1] - optimistic read locking\u0026hellip;256 15:57:00.717 c.DataContainerStamped [t2] - write lock 384 15:57:01.225 c.DataContainerStamped [t1] - updating to read lock\u0026hellip; 256 15:57:02.719 c.DataContainerStamped [t2] - write unlock 384 15:57:02.719 c.DataContainerStamped [t1] - read lock 513 15:57:03.719 c.DataContainerStamped [t1] - read finish\u0026hellip;513, data:1000 15:57:03.719 c.DataContainerStamped [t1] - read unlock 513\n 注意 \u0026gt; StampedLock 不支持条件变量 \u0026gt; StampedLock 不支持可重入 ### 4.Semaphore #### 基本使用 信号量，用来限制能同时访问共享资源的线程上限。  java public static void main(String[] args) { // 1. 创建 semaphore 对象 Semaphore semaphore = new Semaphore(3); // 2. 10个线程同时运行 for (int i = 0; i \u0026lt; 10; i++) { new Thread(() -\u0026gt; { // 3. 获取许可 try { semaphore.acquire(); } catch (InterruptedException e) { e.printStackTrace(); } try { log.debug(\u0026ldquo;running\u0026hellip;\u0026rdquo;); sleep(1); log.debug(\u0026ldquo;end\u0026hellip;\u0026rdquo;); } finally { // 4. 释放许可 semaphore.release(); } }).start(); } }\n 输出  07:35:15.485 c.TestSemaphore [Thread-2] - running\u0026hellip; 07:35:15.485 c.TestSemaphore [Thread-1] - running\u0026hellip; 07:35:15.485 c.TestSemaphore [Thread-0] - running\u0026hellip; 07:35:16.490 c.TestSemaphore [Thread-2] - end\u0026hellip; 07:35:16.490 c.TestSemaphore [Thread-0] - end\u0026hellip; 07:35:16.490 c.TestSemaphore [Thread-1] - end\u0026hellip; 07:35:16.490 c.TestSemaphore [Thread-3] - running\u0026hellip; 07:35:16.490 c.TestSemaphore [Thread-5] - running\u0026hellip; 07:35:16.490 c.TestSemaphore [Thread-4] - running\u0026hellip; 07:35:17.490 c.TestSemaphore [Thread-5] - end\u0026hellip; 07:35:17.490 c.TestSemaphore [Thread-4] - end\u0026hellip; 07:35:17.490 c.TestSemaphore [Thread-3] - end\u0026hellip; 07:35:17.490 c.TestSemaphore [Thread-6] - running\u0026hellip; 07:35:17.490 c.TestSemaphore [Thread-7] - running\u0026hellip; 07:35:17.490 c.TestSemaphore [Thread-9] - running\u0026hellip; 07:35:18.491 c.TestSemaphore [Thread-6] - end\u0026hellip; 07:35:18.491 c.TestSemaphore [Thread-7] - end\u0026hellip; 07:35:18.491 c.TestSemaphore [Thread-9] - end\u0026hellip; 07:35:18.491 c.TestSemaphore [Thread-8] - running\u0026hellip; 07:35:19.492 c.TestSemaphore [Thread-8] - end\u0026hellip;\n #### * 应用 --限制 -- 限制对共享资源的使用 #### * Semaphore 原理 ### 5.CountdownLatch 用来进行线程同步协作，等待所有线程完成倒计时。 其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一  java public static void main(String[] args) throws InterruptedException { CountDownLatch latch = new CountDownLatch(3); new Thread(() -\u0026gt; { log.debug(\u0026ldquo;begin\u0026hellip;\u0026rdquo;); sleep(1); latch.countDown(); log.debug(\u0026ldquo;end\u0026hellip;{}\u0026rdquo;, latch.getCount()); }).start(); new Thread(() -\u0026gt; { log.debug(\u0026ldquo;begin\u0026hellip;\u0026rdquo;); sleep(2); latch.countDown(); log.debug(\u0026ldquo;end\u0026hellip;{}\u0026rdquo;, latch.getCount()); }).start(); new Thread(() -\u0026gt; { log.debug(\u0026ldquo;begin\u0026hellip;\u0026rdquo;); sleep(1.5); latch.countDown(); log.debug(\u0026ldquo;end\u0026hellip;{}\u0026rdquo;, latch.getCount()); }).start(); log.debug(\u0026ldquo;waiting\u0026hellip;\u0026rdquo;); latch.await(); log.debug(\u0026ldquo;wait end\u0026hellip;\u0026rdquo;); }\n 输出  18:44:00.778 c.TestCountDownLatch [main] - waiting\u0026hellip; 18:44:00.778 c.TestCountDownLatch [Thread-2] - begin\u0026hellip; 18:44:00.778 c.TestCountDownLatch [Thread-0] - begin\u0026hellip; 18:44:00.778 c.TestCountDownLatch [Thread-1] - begin\u0026hellip; 18:44:01.782 c.TestCountDownLatch [Thread-0] - end\u0026hellip;2 18:44:02.283 c.TestCountDownLatch [Thread-2] - end\u0026hellip;1 18:44:02.782 c.TestCountDownLatch [Thread-1] - end\u0026hellip;0 18:44:02.782 c.TestCountDownLatch [main] - wait end\u0026hellip;\n 可以配合线程池使用，改进如下  java public static void main(String[] args) throws InterruptedException { CountDownLatch latch = new CountDownLatch(3); ExecutorService service = Executors.newFixedThreadPool(4); service.submit(() -\u0026gt; { log.debug(\u0026ldquo;begin\u0026hellip;\u0026rdquo;); sleep(1); latch.countDown(); log.debug(\u0026ldquo;end\u0026hellip;{}\u0026rdquo;, latch.getCount()); }); service.submit(() -\u0026gt; { log.debug(\u0026ldquo;begin\u0026hellip;\u0026rdquo;); sleep(1.5); latch.countDown(); log.debug(\u0026ldquo;end\u0026hellip;{}\u0026rdquo;, latch.getCount()); }); service.submit(() -\u0026gt; { log.debug(\u0026ldquo;begin\u0026hellip;\u0026rdquo;); sleep(2); latch.countDown(); log.debug(\u0026ldquo;end\u0026hellip;{}\u0026rdquo;, latch.getCount()); }); service.submit(()-\u0026gt;{ try { log.debug(\u0026ldquo;waiting\u0026hellip;\u0026rdquo;); latch.await(); log.debug(\u0026ldquo;wait end\u0026hellip;\u0026rdquo;); } catch (InterruptedException e) { e.printStackTrace(); } }); }\n 输出  18:52:25.831 c.TestCountDownLatch [pool-1-thread-3] - begin\u0026hellip; 18:52:25.831 c.TestCountDownLatch [pool-1-thread-1] - begin\u0026hellip; 18:52:25.831 c.TestCountDownLatch [pool-1-thread-2] - begin\u0026hellip; 18:52:25.831 c.TestCountDownLatch [pool-1-thread-4] - waiting\u0026hellip; 18:52:26.835 c.TestCountDownLatch [pool-1-thread-1] - end\u0026hellip;2 18:52:27.335 c.TestCountDownLatch [pool-1-thread-2] - end\u0026hellip;1 18:52:27.835 c.TestCountDownLatch [pool-1-thread-3] - end\u0026hellip;0 18:52:27.835 c.TestCountDownLatch [pool-1-thread-4] - wait end\u0026hellip;\n #### * 应用之同步等待多线程准备完毕  java AtomicInteger num = new AtomicInteger(0); ExecutorService service = Executors.newFixedThreadPool(10, \u0026reg; -\u0026gt; { return new Thread(r, \u0026ldquo;t\u0026rdquo; + num.getAndIncrement()); }); CountDownLatch latch = new CountDownLatch(10); String[] all = new String[10]; Random r = new Random(); for (int j = 0; j \u0026lt; 10; j++) { int x = j; service.submit(() -\u0026gt; { for (int i = 0; i \u0026lt;= 100; i++) { try { Thread.sleep(r.nextInt(100)); } catch (InterruptedException e) { } all[x] = Thread.currentThread().getName() + \u0026ldquo;(\u0026rdquo; + (i + \u0026ldquo;%\u0026rdquo;) + \u0026ldquo;)\u0026rdquo;; System.out.print(\u0026rdquo;\\r\u0026rdquo; + Arrays.toString(all)); } latch.countDown(); }); } latch.await(); System.out.println(\u0026rdquo;\\n游戏开始\u0026hellip;\u0026ldquo;); service.shutdown();\n 中间输出  [t0(52%), t1(47%), t2(51%), t3(40%), t4(49%), t5(44%), t6(49%), t7(52%), t8(46%), t9(46%)]\n 最后输出  [t0(100%), t1(100%), t2(100%), t3(100%), t4(100%), t5(100%), t6(100%), t7(100%), t8(100%), t9(100%)] 游戏开始\u0026hellip;\n *** 应用之同步等待多个远程调用结束**  java\n@RestController public class TestCountDownlatchController {\n@GetMapping(\u0026quot;/order/{id}\u0026quot;) public Map\u0026lt;String, Object\u0026gt; order(@PathVariable int id) { HashMap\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026quot;id\u0026quot;, id); map.put(\u0026quot;total\u0026quot;, \u0026quot;2300.00\u0026quot;); sleep(2000); return map; } @GetMapping(\u0026quot;/product/{id}\u0026quot;) public Map\u0026lt;String, Object\u0026gt; product(@PathVariable int id) { HashMap\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); if (id == 1) { map.put(\u0026quot;name\u0026quot;, \u0026quot;小爱音箱\u0026quot;); map.put(\u0026quot;price\u0026quot;, 300); } else if (id == 2) { map.put(\u0026quot;name\u0026quot;, \u0026quot;小米手机\u0026quot;); map.put(\u0026quot;price\u0026quot;, 2000); } map.put(\u0026quot;id\u0026quot;, id); sleep(1000); return map; } @GetMapping(\u0026quot;/logistics/{id}\u0026quot;) public Map\u0026lt;String, Object\u0026gt; logistics(@PathVariable int id) { HashMap\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026quot;id\u0026quot;, id); map.put(\u0026quot;name\u0026quot;, \u0026quot;中通快递\u0026quot;); sleep(2500); return map; } private void sleep(int millis) { try { Thread.sleep(millis); } catch (InterruptedException e) { e.printStackTrace(); } }  }\n rest 远程调用  java private static void test3() throws InterruptedException, ExecutionException { RestTemplate restTemplate = new RestTemplate(); log.debug(\u0026ldquo;begin\u0026rdquo;); ExecutorService service = Executors.newCachedThreadPool(); CountDownLatch latch = new CountDownLatch(4); Future\u0026gt; f1 = service.submit(() -\u0026gt; { Mapresponse = restTemplate.getForObject(\u0026ldquo;http://localhost:8080/order/{1}\u0026quot;, Map.class, 1); return response; }); Future\u0026gt; f2 = service.submit(() -\u0026gt; { Mapresponse1 = restTemplate.getForObject(\u0026ldquo;http://localhost:8080/product/{1}\u0026quot;, Map.class, 1); return response1; }); Future\u0026gt; f3 = service.submit(() -\u0026gt; { Mapresponse1 = restTemplate.getForObject(\u0026ldquo;http://localhost:8080/product/{1}\u0026quot;, Map.class, 2); return response1; }); Future\u0026gt; f4 = service.submit(() -\u0026gt; { Mapresponse3 = restTemplate.getForObject(\u0026ldquo;http://localhost:8080/logistics/{1}\u0026quot;, Map.class, 1); return response3; });\n System.out.println(f1.get()); System.out.println(f2.get()); System.out.println(f3.get()); System.out.println(f4.get()); log.debug(\u0026quot;执行完毕\u0026quot;); service.shutdown(); }   执行结果  19:51:39.711 c.TestCountDownLatch [main] - begin {total=2300.00, id=1} {price=300, name=小爱音箱, id=1} {price=2000, name=小米手机, id=2} {name=中通快递, id=1} 19:51:42.407 c.TestCountDownLatch [main] - 执行完毕\n ### 6.CyclicBarrier 循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行  java CyclicBarrier cb = new CyclicBarrier(2); // 个数为2时才会继续执行 new Thread(()-\u0026gt;{ System.out.println(\u0026ldquo;线程1开始..\u0026rdquo;+new Date()); try { cb.await(); // 当个数不足时，等待 } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } System.out.println(\u0026ldquo;线程1继续向下运行\u0026hellip;\u0026rdquo;+new Date()); }).start(); new Thread(()-\u0026gt;{ System.out.println(\u0026ldquo;线程2开始..\u0026rdquo;+new Date()); try { Thread.sleep(2000); } catch (InterruptedException e) { } try { cb.await(); // 2 秒后，线程个数够2，继续运行 } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } System.out.println(\u0026ldquo;线程2继续向下运行\u0026hellip;\u0026rdquo;+new Date()); }).start();\n \u0026gt; **注意** CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是可以重用的 CyclicBarrier 可以被比 \u0026gt; \u0026gt; 喻为『人满发车』  java\n@Slf4j(topic = \u0026ldquo;c.TestCyclicBarrier\u0026rdquo;) public class TestCyclicBarrier {\npublic static void main(String[] args) { //二者的计数要一样才会有效果 ExecutorService service = Executors.newFixedThreadPool(2); CyclicBarrier barrier = new CyclicBarrier(2, ()-\u0026gt; { log.debug(\u0026quot;task1, task2 finish...\u0026quot;); }); //当线程数为newFixedThreadPool(3);的时候会执行task1(1s) task2(2s) task1(1s),那么此时的先结束的两个是test1和第二轮的test1，就不是task1和task2 for (int i = 0; i \u0026lt; 3; i++) { // task1 task2 task1 service.submit(() -\u0026gt; { log.debug(\u0026quot;task1 begin...\u0026quot;); sleep(1); try { barrier.await(); // 2-1=1 } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } }); service.submit(() -\u0026gt; { log.debug(\u0026quot;task2 begin...\u0026quot;); sleep(2); try { barrier.await(); // 1-1=0 } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } }); } service.shutdown(); } private static void test1() { ExecutorService service = Executors.newFixedThreadPool(5); for (int i = 0; i \u0026lt; 3; i++) { CountDownLatch latch = new CountDownLatch(2); service.submit(() -\u0026gt; { log.debug(\u0026quot;task1 start...\u0026quot;); sleep(1); latch.countDown(); }); service.submit(() -\u0026gt; { log.debug(\u0026quot;task2 start...\u0026quot;); sleep(2); latch.countDown(); }); try { latch.await(); } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\u0026quot;task1 task2 finish...\u0026quot;); } service.shutdown(); }  }\n ### 7. 线程安全集合类概述  mermaid graph TB a(遗留的安全集合)\u0026ndash;\u0026gt;b(Hashtable) a\u0026ndash;\u0026gt;c(Ventor) a2(修饰的安全集合)\u0026ndash;使用Collections的方法修饰\u0026ndash;\u0026gt;b2(SynchronizedMap) a2\u0026ndash;使用Collections的方法修饰\u0026ndash;\u0026gt;c2(SynchronizedList) a3(J.U.C安全集合)\u0026ndash;\u0026gt;b3(Blocking类) a3\u0026ndash;\u0026gt;c3(CopyOnWrite类) a3\u0026ndash;\u0026gt;d3(Concurrent类)\n 线程安全集合类可以分为三大类： * 遗留的线程安全集合如 Hashtable，Vector * 使用 Collections 装饰的线程安全集合，如： * Collections.synchronizedCollection * Collections.synchronizedList * Collections.synchronizedMap * Collections.synchronizedSet * Collections.synchronizedNavigableMap * Collections.synchronizedNavigableSet * Collections.synchronizedSortedMap * Collections.synchronizedSortedSet * java.util.concurrent.* 重点介绍java.util.concurrent.* 下的线程安全集合类，可以发现它们有规律，里面包含三类关键词： Blocking、CopyOnWrite、Concurrent * Blocking 大部分实现基于锁，并提供用来阻塞的方法 * CopyOnWrite 之类容器修改开销相对较重（适用于读多写少的场景） * Concurrent 类型的容器（推荐使用） * 内部很多操作使用 cas 优化，一般可以提供较高吞吐量 * 弱一致性 * 遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍 历，这时内容是旧的 * 求大小弱一致性，size 操作未必是 100% 准确 * 读取弱一致性 \u0026gt; 遍历时如果发生了修改，对于非安全容器来讲，使用 fail-fast 机制也就是让遍历立刻失败，抛出 \u0026gt; ConcurrentModificationException，不再继续遍历 ### 8.ConcurrentHashMap 练习：单词计数 生成测试数据  java static final String ALPHA = \u0026ldquo;abcedfghijklmnopqrstuvwxyz\u0026rdquo;; public static void main(String[] args) { int length = ALPHA.length(); int count = 200; List list = new ArrayList\u0026lt;\u0026gt;(length * count); for (int i = 0; i \u0026lt; length; i++) { char ch = ALPHA.charAt(i); for (int j = 0; j \u0026lt; count; j++) { list.add(String.valueOf(ch)); } } Collections.shuffle(list); for (int i = 0; i \u0026lt; 26; i++) { try (PrintWriter out = new PrintWriter( new OutputStreamWriter( new FileOutputStream(\u0026ldquo;tmp/\u0026rdquo; + (i+1) + \u0026ldquo;.txt\u0026rdquo;)))) { String collect = list.subList(i * count, (i + 1) * count).stream() .collect(Collectors.joining(\u0026rdquo;\\n\u0026rdquo;)); out.print(collect); } catch (IOException e) { } } }\n 模版代码，模版代码中封装了多线程读取文件的代码  java private static  void demo(Supplier\u0026gt; supplier, BiConsumer,List\u0026gt; consumer) { MapcounterMap = supplier.get(); List ts = new ArrayList\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;= 26; i++) { int idx = i; Thread thread = new Thread(() -\u0026gt; { List words = readFromFile(idx); consumer.accept(counterMap, words); }); ts.add(thread); } ts.forEach(t-\u0026gt;t.start()); ts.forEach(t-\u0026gt; { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); System.out.println(counterMap); } public static List readFromFile(int i) { ArrayList words = new ArrayList\u0026lt;\u0026gt;(); try (BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(\u0026ldquo;tmp/\u0026rdquo; + i +\u0026ldquo;.txt\u0026rdquo;)))) { while(true) { String word = in.readLine(); if(word == null) { break; } words.add(word); } return words; } catch (IOException e) { throw new RuntimeException(e); } }\n 你要做的是实现两个参数 * 一是提供一个 map 集合，用来存放每个单词的计数结果，key 为单词，value 为计数 * 二是提供一组操作，保证计数的安全性，会传递 map 集合以及 单词 List 正确结果输出应该是每个单词出现 200 次  {a=200, b=200, c=200, d=200, e=200, f=200, g=200, h=200, i=200, j=200, k=200, l=200, m=200, n=200, o=200, p=200, q=200, r=200, s=200, t=200, u=200, v=200, w=200, x=200, y=200, z=200}\n 下面的实现为：  java demo( // 创建 map 集合 // 创建 ConcurrentHashMap 对不对？ () -\u0026gt; new HashMap(), // 进行计数 (map, words) -\u0026gt; { for (String word : words) { Integer counter = map.get(word); int newValue = counter == null ? 1 : counter + 1; map.put(word, newValue); } } );\n 有没有问题？请改进 参考解答 1  java demo( //LongAdder累加器 () -\u0026gt; new ConcurrentHashMap(), (map, words) -\u0026gt; { for (String word : words) { // 注意不能使用 putIfAbsent，此方法返回的是上一次的 value，首次调用返回 null //如果缺少一个key，则计算生成一个value，然后将key value放入map map.computeIfAbsent(word, (key) -\u0026gt; new LongAdder()).increment(); } } );\n 参考解答 2  java demo( () -\u0026gt; new ConcurrentHashMap(), (map, words) -\u0026gt; { for (String word : words) { // 函数式编程，无需原子变量 map.merge(word, 1, Integer::sum); } } );\n #### * ConcurrentHashMap 原理 ### 9.BlockingQueue #### * BlockingQueue 原理 ### 10.ConcurrentLinkedQueue ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 * 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行 * dummy 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争 * 只是这【锁】使用了 cas 来实现 事实上，ConcurrentLinkedQueue 应用还是非常广泛的 例如之前讲的 Tomcat 的 Connector 结构时，Acceptor 作为生产者向 Poller 消费者传递事件信息时，正是采用了 ConcurrentLinkedQueue 将 SocketChannel 给 Poller 使用 **CopyOnWriteArrayList** CopyOnWriteArraySet 是它的马甲 底层实现采用了 写入时拷贝 的思想，增删改操作会将底层数组拷贝一份，更 改操作在新数组上执行，这时不影响其它线程的并发读，读写分离。 以新增为例：  java public boolean add(E e) { synchronized (lock) { // 获取旧的数组 Object[] es = getArray(); int len = es.length; // 拷贝新的数组（这里是比较耗时的操作，但不影响其它读线程） es = Arrays.copyOf(es, len + 1); // 添加新元素 es[len] = e; // 替换旧的数组 setArray(es); return true; } }\n 其它读操作并未加锁，例如：  java public void forEach(Consumer\u0026lt;? super E\u0026gt; action) { Objects.requireNonNull(action); for (Object x : getArray()) { @SuppressWarnings(\u0026ldquo;unchecked\u0026rdquo;) E e = (E) x; action.accept(e); } }\n 适合『读多写少』的应用场景 get 弱一致性 ![image-20200420185306331](/resources/技术收录/Java/java并发/image-20200420185306331.png) | 时间点 | 操作 | | ------ | ---------------------------- | | 1 | Thread-0 getArray() | | 2 | Thread-1 getArray() | | 3 | Thread-1 setArray(arrayCopy) | | 4 | Thread-0 array[index] | \u0026gt; 不容易测试，但问题确实存在 迭代器弱一致性  java CopyOnWriteArrayList list = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); Iterator iter = list.iterator(); new Thread(() -\u0026gt; { list.remove(0); System.out.println(list); }).start();\nsleep1s(); while (iter.hasNext()) { System.out.println(iter.next()); }\n```\n 不要觉得弱一致性就不好\n 数据库的 MVCC 都是弱一致性的表现\n 并发高和一致性是矛盾的，需要权衡\n   ","id":8,"section":"posts","summary":"1.概览 1.1 预备知识 希望你不是一个初学者 线程安全问题，需要你接触过 Java Web 开发、Jdbc 开发、Web 服务器、分布式框架时才会遇到 基于 JDK 8，最好对函","tags":["Java","Java并发编程"],"title":"Java并发编程","uri":"https://mumulx.github.io/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","year":"2020"},{"content":" 原理篇 指令级并行原理 1. 名词 Clock Cycle Time\n主频的概念大家接触的比较多，而 CPU 的 Clock Cycle Time（时钟周期时间），等于主频的倒数，意思是 CPU 能 够识别的最小时间单位，比如说 4G 主频的 CPU 的 Clock Cycle Time 就是 0.25 ns，作为对比，我们墙上挂钟的 Cycle Time 是 1s\n例如，运行一条加法指令一般需要一个时钟周期时间\nCPI\n有的指令需要更多的时钟周期时间，所以引出了 CPI （Cycles Per Instruction）指令平均时钟周期数\nIPC\nIPC（Instruction Per Clock Cycle） 即 CPI 的倒数，表示每个时钟周期能够运行的指令数\nCPU 执行时间\n程序的 CPU 执行时间，即我们前面提到的 user + system 时间，可以用下面的公式来表示\n2. 鱼罐头的故事 加工一条鱼需要 50 分钟，只能一条鱼、一条鱼顺序加工\n可以将每个鱼罐头的加工流程细分为 5 个步骤：\n 去鳞清洗 10分钟 蒸煮沥水 10分钟 加注汤料 10分钟 杀菌出锅 10分钟 真空封罐 10分钟  即使只有一个工人，最理想的情况是：他能够在 10 分钟内同时做好这 5 件事，因为对第一条鱼的真空装罐，不会\n影响对第二条鱼的杀菌出锅\u0026hellip;\n3. 指令重排序优化 事实上，现代处理器会设计为一个时钟周期完成一条执行时间最长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为：取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 这 5 个阶段\n术语参考：\n  instruction fetch (IF) instruction decode (ID) execute (EX) memory access (MEM) register write back (WB)   在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行，这一技术在 80\u0026rsquo;s 中 叶到 90\u0026rsquo;s 中叶占据了计算架构的重要地位。\n提示： 分阶段，分工是提升效率的关键！  指令重排的前提是，重排指令不能影响结果，例如\n// 可以重排的例子 int a = 10; // 指令1 int b = 20; // 指令2 System.out.println( a + b ); // 不能重排的例子 int a = 10; // 指令1 int b = a - 5; // 指令2  参考： Scoreboarding and the Tomasulo algorithm (which is similar to scoreboarding but makes use of register renaming) are two of the most common techniques for implementing out-of-order execution and instruction-level parallelism.  4. 支持流水线的处理器 现代 CPU 支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间最长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。\n提示：\n奔腾四（Pentium 4）支持高达 35 级流水线，但由于功耗太高被废弃  5. SuperScalar 处理器 大多数处理器包含多个执行单元，并不是所有计算功能都集中在一起，可以再细分为整数运算单元、浮点数运算单元等，这样可以把多条指令也可以做到并行获取、译码等，CPU 可以在一个时钟周期内，执行多于一条指令，IPC\u0026gt; 1\nCPU 缓存结构原理 1. CPU 缓存结构 查看 cpu 缓存\nroot@yihang01 ~ lscpu Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 1 On-line CPU(s) list: 0 Thread(s) per core: 1 Core(s) per socket: 1 Socket(s): 1 NUMA node(s): 1 Vendor ID: GenuineIntel CPU family: 6 Model: 142 Model name: Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz Stepping: 11 CPU MHz: 1992.002 BogoMIPS: 3984.00 Hypervisor vendor: VMware Virtualization type: full L1d cache: 32K L1i cache: 32K L2 cache: 256K L3 cache: 8192K NUMA node0 CPU(s): 0  速度比较\n   从 cpu 到 大约需要的时钟周期     寄存器 1 cycle   L1 3~4 cycle   L2 10~20 cycle   L3 40~45 cycle   内存 120~240 cycle    查看 cpu 缓存行\nroot@yihang01 ~ cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size 64  cpu 拿到的内存地址格式是这样的\n[高位组标记][低位索引][偏移量]  2. CPU 缓存读 读取数据流程如下\n 根据低位，计算在缓存中的索引 判断是否有效  0去内存读取新数据更新缓存行 1 再对比高位组标记是否一致 一致，根据偏移量返回缓存数据 不一致，去内存读取新数据更新缓存行   3. CPU 缓存一致性 MESI 协议\n E、S、M 状态的缓存行都可以满足 CPU 的读请求\n E 状态的缓存行，有写请求，会将状态改为 M，这时并不触发向主存的写\n E 状态的缓存行，必须监听该缓存行的读操作，如果有，要变为 S 状态\n   M 状态的缓存行，必须监听该缓存行的读操作，如果有，先将其它缓存（S 状态）中该缓存行变成 I 状态（即6的流程），写入主存，自己变为 S 状态\n S 状态的缓存行，有写请求，走 4. 的流程\n S 状态的缓存行，必须监听该缓存行的失效操作，如果有，自己变为 I 状态\n I 状态的缓存行，有读请求，必须从主存读取\n  4. 内存屏障 Memory Barrier（Memory Fence）\n 可见性  写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中 而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据  有序性  写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前   volatile 原理 volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）\n 对 volatile 变量的写指令后会加入写屏障 对 volatile 变量的读指令前会加入读屏障  1. 如何保证可见性  写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中\npublic void actor2(I_Result r) { num = 2; ready = true; // ready 是 volatile 赋值带写屏障 // 写屏障 }   而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据\npublic void actor1(I_Result r) { // 读屏障 // ready 是 volatile 读取值带读屏障 if(ready) { r.r1 = num + num; } else { r.r1 = 1; } }  sequenceDiagram participant t1 线程 participant num=0 participant volatile ready=false participant t2 线程 t1 线程--\u0026gt;\u0026gt;t1 线程:num=2 t1 线程-\u0026gt;\u0026gt;volatile ready=false:ready=true note over t1 线程,volatile ready=false:写屏障 note over num=0,t2 线程:写屏障 t2 线程-\u0026gt;\u0026gt;volatile ready=false:读取ready=true t2 线程-\u0026gt;\u0026gt;num=0:读取num=2    2. 如何保证有序性  写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后\npublic void actor2(I_Result r) { num = 2; ready = true; // ready 是 volatile 赋值带写屏障 // 写屏障 }  读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前\npublic void actor1(I_Result r) { // 读屏障 // ready 是 volatile 读取值带读屏障 if(ready) { r.r1 = num + num; } else { r.r1 = 1; } }  sequenceDiagram participant t1 线程 participant num=0 participant volatile ready=false participant t2 线程 t1 线程--\u0026gt;\u0026gt;t1 线程:num=2 t1 线程-\u0026gt;\u0026gt;volatile ready=false:ready=true note over t1 线程,volatile ready=false:写屏障 note over num=0,t2 线程:写屏障 t2 线程-\u0026gt;\u0026gt;volatile ready=false:读取ready=true t2 线程-\u0026gt;\u0026gt;num=0:读取num=2   还是那句话，不能解决指令交错（原子性）：\n 写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去 而有序性的保证也只是保证了本线程内相关代码不被重排序\nsequenceDiagram participant t1 线程 participant volatile i=0 participant t2 线程 t2 线程--\u0026gt;\u0026gt;volatile i=0:读取i=0 t1 线程-\u0026gt;\u0026gt;volatile i=0:读取i=0 t1 线程-\u0026gt;\u0026gt;t1 线程:i+1 t1 线程-\u0026gt;\u0026gt;volatile i=0:写入i=1 t2 线程--\u0026gt;\u0026gt;t2 线程:i+1 t2 线程--\u0026gt;\u0026gt;volatile i=0:写入i=-1   3. double-checked locking 问题 以著名的 double-checked locking 单例模式为例\npublic final class Singleton { private Singleton() { } private static Singleton INSTANCE = null; public static Singleton getInstance() { //这个是有问题的 if(INSTANCE == null) { // t2 没有完全将INSTANCE交给synchronized管理 // 首次访问会同步，而之后的使用没有 synchronized synchronized(Singleton.class) { if (INSTANCE == null) { // t1 INSTANCE = new Singleton(); } } } return INSTANCE; } }  以上的实现特点是：\n 懒惰实例化 首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁 有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外  但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：\n0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton; 3: ifnonnull 37 6: ldc #3 // class cn/itcast/n5/Singleton 8: dup 9: astore_0 10: monitorenter 11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton; 14: ifnonnull 27 17: new #3 // class cn/itcast/n5/Singleton 20: dup 21: invokespecial #4 // Method \u0026quot;\u0026lt;init\u0026gt;\u0026quot;:()V 24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton; 27: aload_0 28: monitorexit 29: goto 37 32: astore_1 33: aload_0 34: monitorexit 35: aload_1 36: athrow 37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton; 40: areturn  其中\n17 表示创建对象，将对象引用入栈 // new Singleton 20 表示复制一份对象引用 // 引用地址 21 表示利用一个对象引用，调用构造方法 24 表示利用一个对象引用，赋值给 static INSTANCE  也许 jvm 会优化为：先执行 24 ，再执行 21 。如果两个线程 t1，t2 按如下时间序列执行：\nsequenceDiagram participant t1 participant INSTANCE participant t2 t1-\u0026gt;\u0026gt;t1:17:new t1-\u0026gt;\u0026gt;t1:20:dup t1 -\u0026gt;\u0026gt; INSTANCE : 24:putstatic(给INSTANCE赋值) t2 -\u0026gt;\u0026gt; INSTANCE : θ: getstatic(获取INSTANCE 引用) t2 -\u0026gt;\u0026gt; t2 : 3: ifnonnull 37(判断不为空,跳转37行) t2 -\u0026gt;\u0026gt; INSTANCE : 37: getstatic(获取INSTANCE 引用) t2 -\u0026gt;\u0026gt; t2 : 40: areturn(返回) t2-\u0026gt;\u0026gt;t2:使用对象 t1-\u0026gt;\u0026gt;t1:21: Invokespecial(调用构造方法)  关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取 INSTANCE 变量的值\n这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初 始化完毕的单例\n对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效\nsynchronized确实可以保证共享变量的原子性，可见性，有序性；前提是要将这个共享变量完全交给synchronized管理。在本实例中 if(INSTANCE == null) { // t2 没有完全将INSTANCE交给synchronized管理；因此不能保证它的有序性\n4. double-checked locking 解决 private Singleton() { } //添加volatile保证有序性 private static volatile Singleton INSTANCE = null; public static Singleton getInstance() { // 实例没创建，才会进入内部的 synchronized代码块 if (INSTANCE == null) { synchronized (Singleton.class) { // t2 // 也许有其它线程已经创建实例，所以再判断一次 if (INSTANCE == null) { // t1 INSTANCE = new Singleton(); } } } return INSTANCE; } }  字节码上看不出来 volatile 指令的效果\n// -------------------------------------\u0026gt; 加入对 INSTANCE 变量的读屏障 0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton; 3: ifnonnull 37 6: ldc #3 // class cn/itcast/n5/Singleton 8: dup 9: astore_0 10: monitorenter -----------------------\u0026gt; 保证原子性、可见性 11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton; 14: ifnonnull 27 17: new #3 // class cn/itcast/n5/Singleton 20: dup 21: invokespecial #4 // Method \u0026quot;\u0026lt;init\u0026gt;\u0026quot;:()V 24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton; // -------------------------------------\u0026gt; 加入对 INSTANCE 变量的写屏障 27: aload_0 28: monitorexit ------------------------\u0026gt; 保证原子性、可见性 29: goto 37 32: astore_1 33: aload_0 34: monitorexit 35: aload_1 36: athrow 37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton; 40: areturn  如上面的注释内容所示，读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面 两点：\n 可见性  写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中 而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据  有序性  写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前  更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性\nsequenceDiagram participant t1 participant INSTANCE participant t2 t1-\u0026gt;\u0026gt;t1:17:new t1-\u0026gt;\u0026gt;t1:20:dup t1-\u0026gt;\u0026gt;t1:21: invokespecial(调用构造方法) t1 --\u0026gt;\u0026gt; INSTANCE : 24:putstatic(给INSTANCE赋值，带写屏障) t2 --\u0026gt;\u0026gt; INSTANCE : θ: getstatic(获取INSTANCE 引用，带读屏障) t2 -\u0026gt;\u0026gt; t2 : 3: ifnonnull 37(判断不为空,跳转37行) t2 --\u0026gt;\u0026gt; INSTANCE : 37: getstatic(获取INSTANCE 引用) t2 -\u0026gt;\u0026gt; t2 : 40: areturn(返回) t2-\u0026gt;\u0026gt;t2:使用对象   volatile ：在jdk1.5之后才能生效\nfinal 原理 1. 设置 final 变量的原理 理解了 volatile 原理，再对比 final 的实现就比较简单了\npublic class TestFinal { final int a = 20; }  字节码\n0: aload_0 1: invokespecial #1 // Method java/lang/Object.\u0026quot;\u0026lt;init\u0026gt;\u0026quot;:()V 4: aload_0 5: bipush 20 7: putfield #2 // Field a:I \u0026lt;-- 写屏障 10: return  写屏障能够解决两个问题：1.写屏障之前的指令不会被重排序到写屏障之后；2.写屏障能够保证写屏障之前的修改操作（赋值操作）在写屏障之后会被同步到主存中去，就是对其他线程可见。\n当没有使用final时，成员变量会先被赋予初始值（0,null等）然后才会将用户定义的值赋给变量。这样就产生了二异性，使用final就不会产生这样的冲突，会直接赋值为用户定义的值\n发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到 它的值时不会出现为 0 的情况\n2. 获取 final 变量的原理 public class TestFinal { static int A = 10; static int B = Short.MAX_VALUE+1; final int a = 20; final int b = Integer.MAX_VALUE; final void test1() { final int c = 30; new Thread(()-\u0026gt;{ System.out.println(c); }).start(); final int d = 30; class Task implements Runnable { @Override public void run() { System.out.println(d); } } new Thread(new Task()).start(); } } class UseFinal1 { public void test() { System.out.println(TestFinal.A); System.out.println(TestFinal.B); System.out.println(new TestFinal().a); System.out.println(new TestFinal().b); new TestFinal().test1(); } } class UseFinal2 { public void test() { System.out.println(TestFinal.A); } }  将final修饰的变量的值复制一份，复制到其它类中\n加上final会将较小的数值复制一份到方法栈中（性能较高），如果数值较大，会复制到类的常量池中（性能也能得到提升）。如果不加final在堆中访问较慢\nMonitor 原理 Monitor 被翻译为监视器或管程\n每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针\n Monitor 是操作系统提供的 synchronized 锁的对象是java提供  当线程执行到同步代码块的时候，就要对对象进行加锁。对象头中的markWord指向系统分配的Monitor。该线程就成功的拥有了这个monitor。Owner指向该线程（只能有一个主人）。当有其他线程来执行同步代码块的代码时，先判断锁的对象有没有关联monitor锁呢？看看这个monitor有没有主人，我们发现该monitor有主人了，其他线程就获得不了锁了，但是该线程也会与该monitor相关联，monitor中有一个属性entryList（等待队列、阻塞队列）的属性。其他线程就进入到了阻塞队列中进行等待。等待其他线程释放了minitor的锁，也就是释放了对owner的所有权，才能继续执行，进入blocked状态。\nMonitor 结构如下\n 刚开始 Monitor 中 Owner 为 null 当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner 在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入EntryList BLOCKED Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的是非公平的 图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析  同一个对象会关联同一个monitor\n注意：\n synchronized 必须是进入同一个对象的 monitor 才有上述的效果 不加 synchronized 的对象不会关联监视器，不遵从以上规则  synchronized 原理 static final Object lock = new Object(); static int counter = 0; public static void main(String[] args) { synchronized (lock) { counter++; } }  对应的字节码为\npublic static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=1 0: getstatic #2 // \u0026lt;- lock引用 （synchronized开始）--拿到lock对象 3: dup\t//--复制一份 4: astore_1 // lock引用 -\u0026gt; slot 1 --存储到slot 1中 为了解锁使用 5: monitorenter // 将 lock对象 MarkWord 置为 Monitor 指针（使用C实现这里看不到具体的步骤） --synchronized 6: getstatic #3 // \u0026lt;- i 9: iconst_1 // 准备常数 1 -------counter++操作 10: iadd // +1 11: putstatic #3 // -\u0026gt; i 14: aload_1 // \u0026lt;- lock引用 ---拿到4: astore_1 中存储的临时变量 15: monitorexit // 将 lock对象 MarkWord 重置（原先对象投中存储的是Normal那一行的数据，加锁后存储的 Heavyweight Locked哪一行的数据，恢复数据；原先的数据都存储在monitor中了）, 唤醒 EntryList 16: goto 24\t//--下面的代码保证即使同步代码块中出现了异常也能进行锁的释放 19: astore_2 // e -\u0026gt; slot 2 --异常变量存储起来 20: aload_1 // \u0026lt;- lock引用 --加载lock引用 ，锁对象的引用地址 21: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList 22: aload_2 // \u0026lt;- slot 2 (e) 23: athrow // throw e 24: return Exception table: from to target type 6 16 19 any 19 22 19 any LineNumberTable: line 8: 0 line 9: 6 line 10: 14 line 11: 24 LocalVariableTable: Start Length Slot Name Signature 0 25 0 args [Ljava/lang/String; StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 19 locals = [ class \u0026quot;[Ljava/lang/String;\u0026quot;, class java/lang/Object ] stack = [ class java/lang/Throwable ] frame_type = 250 /* chop */ offset_delta = 4  注意\n方法级别的 synchronized 不会在字节码指令中有所体现  synchronized 原理进阶 1. 轻量级锁 轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。\n轻量级锁对使用者是透明的，即语法仍然是 synchronized\n假设有两个方法同步块，利用同一个对象加锁\nstatic final Object obj = new Object(); public static void method1() { synchronized( obj ) { // 同步块 A method2(); } } public static void method2() { synchronized( obj ) { // 同步块 B } }  一个对象分为对象头(Mark Word(hash码 age 加锁的状态)和classWord（类型指针）)和对象体（对象的成员变量信息）\n执行到同步块 A时先在栈帧中产生一个锁记录的对象(jvm层面)[包含了1.对象指针：加锁的对象的地址；2.记录对象的markword],然后将锁记录对象的指针指向该对象，然后将锁记录中的数据(00:轻量级锁)和对象中的数据进行交换（01：没有加锁）（表示加锁），交换成功则表示加锁成功\n执行到method1方法时会在栈中开辟一个栈帧空间。\n创建锁记录（Lock Recoyige rd）对象，每个线程都的栈帧都会包含一个锁记录（不可见的，不是java层面的，是jvm层面的）的结构，内部可以存储锁定对象的。\n锁记录包含两部分：对象指针、存储将来我们要加锁对象的mark word（原来的值是一个轻量级锁的信息）\nMark Word\n让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word（表示对象已加锁），将 Mark Word 的值存入锁记录（为了解锁）\n如果 cas 替换成功，对象头中存储了锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下\n如果 cas 失败，有两种情况\n 如果是其它线程已经持有了该 Object 的轻量级锁（对象头为00），这时表明有竞争，进入锁膨胀过程 如果是自己执行了 synchronized 锁重入（调用了method2方法；同一个线程又对同一个对象进行了加锁），那么再添加一条 Lock Record 作为重入的计数  方法二中又调用了一次synchronized,又要产生一个栈帧，这个栈帧还要对对象进行加锁，然后将锁记录对象的指针指向该对象，然后进行数据的交换（这次交换肯定失败），然后再锁记录中存储null(作用：用于锁重入的计数)\n当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，直接清除掉该锁记录，这时重置锁记录，表示重入计数减一\n当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象 头\n 成功，则解锁成功 失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程  2. 锁膨胀 如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。\nstatic Object obj = new Object(); public static void method1() { synchronized( obj ) { // 同步块 } }  当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁\n轻量级锁（锁记录）没有阻塞的说法，重量级锁（monitor）才有阻塞的说法\n 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程\n 即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址（改变对象头信息） 然后自己进入 Monitor 的 EntryList BLOCKED   当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败（持有的是轻量级锁，而对象此时已经变味了重量级锁了）。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程   3. 自旋优化 重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋（循环几次）成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。使用自旋（适合在多核cpu下使用）可以避免上下文切换、阻塞的发生。自旋重试成功的情况\n   线程 1 （core 1 上） 对象 Mark 线程 2 （core 2 上）     - 10（重量锁） -   访问同步块，获取 monitor 10（重量锁）重量锁指针 -   成功（加锁） 10（重量锁）重量锁指针 -   执行同步块 10（重量锁）重量锁指针 -   执行同步块 10（重量锁）重量锁指针 访问同步块，获取 monitor   执行同步块 10（重量锁）重量锁指针 自旋重试   执行完毕 10（重量锁）重量锁指针 自旋重试   成功（解锁） 01（无锁） 自旋重试   - 10（重量锁）重量锁指针 成功（加锁）   - 10（重量锁）重量锁指针 执行同步块   - \u0026hellip; \u0026hellip;    自旋重试失败的情况\n   线程 1（core 1 上） 对象 Mark 线程 2（core 2 上）     - 10（重量锁） -   访问同步块，获取 monitor 10（重量锁）重量锁指针 -   成功（加锁） 10（重量锁）重量锁指针 -   执行同步块 10（重量锁）重量锁指针 -   执行同步块 10（重量锁）重量锁指针 访问同步块，获取 monitor   执行同步块 10（重量锁）重量锁指针 自旋重试   执行同步块 10（重量锁）重量锁指针 自旋重试   执行同步块 10（重量锁）重量锁指针 自旋重试   执行同步块 10（重量锁）重量锁指针 阻塞   - \u0026hellip; \u0026hellip;     自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会 高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。 Java 7 之后不能控制是否开启自旋功能  4. 偏向锁 偏向锁和轻量级锁的前提都是多个线程访问同一个对象是错开的。\n轻量级锁在没有竞争时（就自己这个线程），每次重入（锁重入）仍然需要执行 CAS 操作。\nJava 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。\n例如：\nstatic final Object obj = new Object(); public static void m1() { synchronized( obj ) { // 同步块 A m2(); } } public static void m2() { synchronized( obj ) { // 同步块 B m3(); } } public static void m3() { synchronized( obj ) {// 同步块 C } }  偏向状态 回忆一下对象头格式\n|--------------------------------------------------------------------|--------------------| | Mark Word (64 bits)\t| State | |--------------------------------------------------------------------|--------------------| | unused:25 | hashcode:31 | unused:1 | age:4 | biased_lock:0\t| 01 | Normal | |--------------------------------------------------------------------|--------------------| | thread:54 | epoch:2 | unused:1 | age:4 | biased_lock:1 | 01 |\tBiased | |--------------------------------------------------------------------|--------------------| | ptr_to_lock_record:62\t| 00 | Lightweight Locked | |--------------------------------------------------------------------|--------------------| | ptr_to_heavyweight_monitor:62 | 10 | Heavyweight Locked | |--------------------------------------------------------------------|--------------------| | | 11 | Marked for GC | |--------------------------------------------------------------------|--------------------|   Normal：普通对象；biased_lock为0\n Biased:偏向锁；biased_lock为1\n  二者的最后两位都是01\n一个对象创建时：\n 如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101 ，这时它的 thread、epoch、age 都为 0 偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 - XX:BiasedLockingStartupDelay=0 来禁用延迟 如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001 ，这时它的 hashcode、 age 都为 0 ，第一次用到 hashcode 时才会赋值  1 ） 测试延迟特性\n2 ） 测试偏向锁\nclass Dog {}  利用 jol 第三方工具来查看对象头信息（注意这里我扩展了 jol 让它输出更为简洁）\n// 添加虚拟机参数 -XX:BiasedLockingStartupDelay=0 public static void main(String[] args) throws IOException { Dog d = new Dog(); ClassLayout classLayout = ClassLayout.parseInstance(d); new Thread(() -\u0026gt; { log.debug(\u0026quot;synchronized 前\u0026quot;); System.out.println(classLayout.toPrintableSimple(true)); synchronized (d) { log.debug(\u0026quot;synchronized 中\u0026quot;); System.out.println(classLayout.toPrintableSimple(true)); } log.debug(\u0026quot;synchronized 后\u0026quot;); System.out.println(classLayout.toPrintableSimple(true)); }, \u0026quot;t1\u0026quot;).start();}  输出\n11:08:58.117 c.TestBiased [t1] - synchronized 前 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101 11:08:58.121 c.TestBiased [t1] - synchronized 中 00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101 11:08:58.121 c.TestBiased [t1] - synchronized 后 00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101  注意\n处于偏向锁的对象解锁后，线程 id 仍存储于对象头中\n3 ）测试禁用\n在上面测试代码运行时在添加 VM 参数 - XX:-UseBiasedLocking 禁用偏向锁\n输出\n11:13:10.018 c.TestBiased [t1] - synchronized 前 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 11:13:10.021 c.TestBiased [t1] - synchronized 中 00000000 00000000 00000000 00000000 00100000 00010100 11110011 10001000 11:13:10.021 c.TestBiased [t1] - synchronized 后 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001  4）测试 hashCode\nd.hashCode();//会禁用这个对象的偏向锁  正常状态对象一开始是没有 hashCode 的(默认31位都是0)，第一次调用才生成（将值填充到31位中）\n当一个可偏向的对象调用了它的hashcode方法之后，它就会撤销这个对象的偏向状态（对象头从biased\u0026mdash;\u0026gt;Normal）\n撤销 - 调用对象 hashCode 调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被 撤销\n 轻量级锁会在锁记录中记录 hashCode 重量级锁会在 Monitor 中记录 hashCode  在调用 hashCode 后使用偏向锁，记得去掉 - XX:-UseBiasedLocking（+是启用；-是禁用）\n输出\n11:22:10.386 c.TestBiased [main] - 调用 hashCode:1778535015 11:22:10.391 c.TestBiased [t1] - synchronized 前 00000000 00000000 00000000 01101010 00000010 01001010 01100111 00000001 11:22:10.393 c.TestBiased [t1] - synchronized 中 00000000 00000000 00000000 00000000 00100000 11000011 11110011 01101000 11:22:10.393 c.TestBiased [t1] - synchronized 后 00000000 00000000 00000000 01101010 00000010 01001010 01100111 00000001  撤销 - 其它线程使用对象 当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁\nprivate static void test2() throws InterruptedException { Dog d = new Dog(); Thread t1 = new Thread(() -\u0026gt; { synchronized (d) { log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); } synchronized (TestBiased.class) { TestBiased.class.notify(); } // 如果不用 wait/notify 使用 join 必须打开下面的注释 // 因为：t1 线程不能结束，否则底层线程可能被 jvm 重用作为 t2 线程，底层线程 id 是一样的 /*try { System.in.read(); } catch (IOException e) { e.printStackTrace(); }*/ }, \u0026quot;t1\u0026quot;); t1.start(); Thread t2 = new Thread(() -\u0026gt; { synchronized (TestBiased.class) { try { TestBiased.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) { log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); } log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); }, \u0026quot;t2\u0026quot;); t2.start(); }  输出\n[t1] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101 [t2] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101 [t2] - 00000000 00000000 00000000 00000000 00011111 10110101 11110000 01000000 [t2] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001  撤销 - 调用 wait/notify wait/notify只有重量级锁才有\npublic static void main(String[] args) throws InterruptedException { Dog d = new Dog(); Thread t1 = new Thread(() -\u0026gt; { log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) { log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); try { d.wait(); } catch (InterruptedException e) { e.printStackTrace(); } log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); } }, \u0026quot;t1\u0026quot;); t1.start(); new Thread(() -\u0026gt; { try { Thread.sleep(6000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (d) { log.debug(\u0026quot;notify\u0026quot;); d.notify(); } }, \u0026quot;t2\u0026quot;).start(); }  输出\n[t1] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101 [t1] - 00000000 00000000 00000000 00000000 00011111 10110011 11111000 00000101 [t2] - notify [t1] - 00000000 00000000 00000000 00000000 00011100 11010100 00001101 11001010  批量重偏向 如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对的 Thread ID\n当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程\nprivate static void test3() throws InterruptedException { Vector\u0026lt;Dog\u0026gt; list = new Vector\u0026lt;\u0026gt;(); Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 30; i++) { Dog d = new Dog();//这三十个对象开始都是偏向线程t1的 list.add(d); synchronized (d) { log.debug(i + \u0026quot;\\t\u0026quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); } } synchronized (list) { list.notify(); } }, \u0026quot;t1\u0026quot;); t1.start(); Thread t2 = new Thread(() -\u0026gt; { synchronized (list) { try { list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\u0026quot;===============\u0026gt; \u0026quot;); for (int i = 0; i \u0026lt; 30; i++) { Dog d = list.get(i); log.debug(i + \u0026quot;\\t\u0026quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) {//会先升级为轻量级锁 log.debug(i + \u0026quot;\\t\u0026quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); } log.debug(i + \u0026quot;\\t\u0026quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); } }, \u0026quot;t2\u0026quot;); t2.start(); }  输出\n[t1] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t1] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - ===============\u0026gt; [t2] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 0 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 0 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 1 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 1 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 2 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 2 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 3 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 3 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 4 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 4 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 5 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 5 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 6 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 6 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 7 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 7 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 8 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 8 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 9 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 9 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 10 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 10 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 11 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 11 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 12 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 12 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 13 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 13 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 14 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 14 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 15 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 15 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 16 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 16 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 17 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 17 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 18 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 [t2] - 18 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 [t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 [t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 [t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101  批量撤销 当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的\nstatic Thread t1,t2,t3; private static void test4() throws InterruptedException { Vector\u0026lt;Dog\u0026gt; list = new Vector\u0026lt;\u0026gt;(); int loopNumber = 39; t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; loopNumber; i++) { Dog d = new Dog(); list.add(d); synchronized (d) { log.debug(i + \u0026quot;\\t\u0026quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); } } LockSupport.unpark(t2); }, \u0026quot;t1\u0026quot;); t1.start(); t2 = new Thread(() -\u0026gt; { LockSupport.park(); log.debug(\u0026quot;===============\u0026gt; \u0026quot;); for (int i = 0; i \u0026lt; loopNumber; i++) { Dog d = list.get(i); log.debug(i + \u0026quot;\\t\u0026quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) { log.debug(i + \u0026quot;\\t\u0026quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); } log.debug(i + \u0026quot;\\t\u0026quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); } LockSupport.unpark(t3); }, \u0026quot;t2\u0026quot;);t2.start(); t3 = new Thread(() -\u0026gt; { LockSupport.park(); log.debug(\u0026quot;===============\u0026gt; \u0026quot;); for (int i = 0; i \u0026lt; loopNumber; i++) { Dog d = list.get(i); log.debug(i + \u0026quot;\\t\u0026quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) { log.debug(i + \u0026quot;\\t\u0026quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); } log.debug(i + \u0026quot;\\t\u0026quot; + ClassLayout.parseInstance(d).toPrintableSimple(true)); } }, \u0026quot;t3\u0026quot;); t3.start(); t3.join(); log.debug(ClassLayout.parseInstance(new Dog()).toPrintableSimple(true));//第四十次撤销 }  参考资料\nhttps://github.com/farmerjohngit/myblog/issues/12 https://www.cnblogs.com/LemonFive/p/11246086.html https://www.cnblogs.com/LemonFive/p/11248248.html  5. 锁消除 锁消除\n@Fork(1) @BenchmarkMode(Mode.AverageTime) @Warmup(iterations=3) @Measurement(iterations=5) @OutputTimeUnit(TimeUnit.NANOSECONDS) public class MyBenchmark { static int x = 0; @Benchmark public void a() throws Exception { x++; } @Benchmark public void b() throws Exception { Object o = new Object(); //o是一个方法的局部变量，加锁没有意义。那么JIT（java即时编译器，就会优化代码） synchronized (o) { x++; } } }  java -jar benchmarks.jar\nBenchmark Mode Samples Score Score error Units c.i.MyBenchmark.a avgt 5 1.542 0.056 ns/op c.i.MyBenchmark.b avgt 5 1.518 0.091 ns/op  java -XX:-EliminateLocks -jar benchmarks.jar 关闭锁消除\nBenchmark Mode Samples Score Score error Units c.i.MyBenchmark.a avgt 5 1.507 0.108 ns/op c.i.MyBenchmark.b avgt 5 16.976 1.572 ns/op  锁粗化\n对相同对象多次加锁，导致线程发生多次重入，可以使用锁粗化方式来优化，这不同于之前讲的细分锁的粒度。\nwait notify 原理  Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 BLOCKED 线程会在 Owner 线程释放锁时唤醒 WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争  join 原理 运用了保护性暂停模式的原理\n//join源码 public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis \u0026lt; 0) { throw new IllegalArgumentException(\u0026quot;timeout value is negative\u0026quot;); } if (millis == 0) { while (isAlive()) { wait(0); } } else { while (isAlive()) { long delay = millis - now; if (delay \u0026lt;= 0) { break; } wait(delay); now = System.currentTimeMillis() - base; } } }  是调用者轮询检查线程 alive 状态\nt1.join();  等价于下面的代码\nsynchronized (t1) { // 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束 while (t1.isAlive()) { t1.wait(0); } }  注意\njoin 体现的是【保护性暂停】模式，请参考之  public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis \u0026lt; 0) { throw new IllegalArgumentException(\u0026quot;timeout value is negative\u0026quot;); } if (millis == 0) { while (isAlive()) { wait(0); } } else { while (isAlive()) { long delay = millis - now; if (delay \u0026lt;= 0) { break; } wait(delay); now = System.currentTimeMillis() - base; } } }  park unpark 原理 每个线程都有自己的一个 Parker 对象，由三部分组成 _counter，_cond 和 _mutex 打个比喻\n 线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中的备用干粮（ 0 为耗尽， 1 为充足）\n 调用 park 就是要看需不需要停下来歇息\n 如果备用干粮耗尽，那么钻进帐篷歇息 如果备用干粮充足，那么不需停留，继续前进  调用 unpark，就好比令干粮充足\n 如果这时线程还在帐篷，就唤醒让他继续前进 如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进 因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮     当前线程调用 Unsafe.park() 方法\n 检查 _counter ，本情况为 0 ，这时，获得 _mutex 互斥锁\n 线程进入 _cond 条件变量阻塞\n 设置 _counter = 0\n 调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1\n 唤醒 _cond 条件变量中的 Thread_0\n Thread_0 恢复运行\n 设置 _counter 为 0\n 调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1\n 当前线程调用 Unsafe.park() 方法\n 检查 _counter ，本情况为 1 ，这时线程无需阻塞，继续运行\n 设置 _counter 为 0\n  AQS 原理 1. 概述 全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架\n特点：\n 用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取 锁和释放锁  getState - 获取 state 状态 setState - 设置 state 状态 compareAndSetState - cas 机制设置 state 状态（防止多个线程同时来修改该值，但它仍然是阻塞式的） 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源  提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet  子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）\n  tryAcquire tryRelease tryAcquireShared tryReleaseShared isHeldExclusively   获取锁的姿势\n// 如果获取锁失败 if (!tryAcquire(arg)) { // 入队, 可以选择阻塞当前线程 park unpark机制 }  释放锁的姿势\n// 如果释放锁成功 if (tryRelease(arg)) { // 让阻塞线程恢复运行 }  2. 实现不可重入锁 自定义同步器\n// 独占锁 同步器类 class MySync extends AbstractQueuedSynchronizer { @Override protected boolean tryAcquire(int arg) { if(compareAndSetState(0, 1)) { // 加上了锁，并设置 owner 为当前线程 setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } @Override protected boolean tryRelease(int arg) { setExclusiveOwnerThread(null); setState(0);//使用了volatile 不会发生重排序private volatile int state;所以setState放在后面 return true; } @Override // 是否持有独占锁 protected boolean isHeldExclusively() { return getState() == 1; } public Condition newCondition() { return new ConditionObject(); } }  自定义锁\n有了自定义同步器，很容易复用 AQS ，实现一个功能完备的自定义锁\n// 自定义锁（不可重入锁 自己加的锁也能挡住自己） class MyLock implements Lock { // 独占锁 同步器类 class MySync extends AbstractQueuedSynchronizer { @Override//尝试获取锁 state 0：未加锁 1: 加锁 protected boolean tryAcquire(int arg) { //使用cas保证 修改值是原子性的 if(compareAndSetState(0, 1)) { // 加上了锁，并设置 owner 为当前线程 setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } @Override//尝试释放锁 protected boolean tryRelease(int arg) { setExclusiveOwnerThread(null); setState(0);//这是对一个volatile 成员变量的赋值操作 把它放在后面是为了 volatile后面会加上写屏障 return true; } @Override // 是否持有独占锁 protected boolean isHeldExclusively() { return getState() == 1; } //返回条件变量 public Condition newCondition() { return new ConditionObject(); } } private MySync sync = new MySync(); @Override // 加锁（不成功会进入等待队列） public void lock() { sync.acquire(1); } @Override // 加锁，可打断 public void lockInterruptibly() throws InterruptedException { sync.acquireInterruptibly(1); } @Override // 尝试加锁（一次） public boolean tryLock() { return sync.tryAcquire(1); } @Override // 尝试加锁，带超时 public boolean tryLock(long time, TimeUnit unit) throws InterruptedException { return sync.tryAcquireNanos(1, unit.toNanos(time)); } @Override // 解锁 public void unlock() { sync.release(1); } @Override // 创建条件变量 public Condition newCondition() { return sync.newCondition(); } }  测试一下\n@Slf4j(topic = \u0026quot;c.TestAqs\u0026quot;) public class TestAqs { public static void main(String[] args) { MyLock lock = new MyLock(); new Thread(() -\u0026gt; { lock.lock();//锁只能加一次，不可重入 try { log.debug(\u0026quot;locking...\u0026quot;); sleep(1); } finally { log.debug(\u0026quot;unlocking...\u0026quot;); lock.unlock(); } },\u0026quot;t1\u0026quot;).start(); new Thread(() -\u0026gt; { lock.lock(); try { log.debug(\u0026quot;locking...\u0026quot;); } finally { log.debug(\u0026quot;unlocking...\u0026quot;); lock.unlock(); } },\u0026quot;t2\u0026quot;).start(); } }  输出\n22:29:28.727 c.TestAqs [t1] - locking... 22:29:29.732 c.TestAqs [t1] - unlocking... 22:29:29.732 c.TestAqs [t2] - locking... 22:29:29.732 c.TestAqs [t2] - unlocking..  不可重入测试\n如果改为下面代码，会发现自己也会被挡住（只会打印一次 locking）\nlock.lock(); log.debug(\u0026quot;locking...\u0026quot;); lock.lock(); log.debug(\u0026quot;locking...\u0026quot;);  3. 心得 起源\n早期程序员会自己通过一种同步器去实现 另一种相近的同步器，例如用可重入锁去实现信号量，或反之。这显然不够优雅，于是在 JSR166（java 规范提案）中创建了 AQS，提供了这种通用的同步器机制。\n目标\nAQS 要实现的功能目标\n 阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire 获取锁超时机制 通过打断取消机制 独占机制及共享机制 条件不满足时的等待机制 要实现的性能目标\nInstead, the primary performance goal here is scalability: to predictably maintain efficiency even, or especially, when synchronizers are contended.   设计\nAQS 的基本思想其实很简单\n获取锁的逻辑\nwhile(state 状态不允许获取) { if(队列中还没有此线程) { 入队并阻塞 } } 当前线程出队  释放锁的逻辑\nif(state 状态允许了) { 恢复阻塞的线程(s) }  要点\n原子维护 state 状态 阻塞及恢复线程 维护队列  state 设计\nstate 使用 volatile 配合 cas 保证其修改时的原子性 state 使用了 32bit int 来维护同步状态，因为当时使用 long 在很多平台下测试的结果并不理想  阻塞恢复设计\n早期的控制线程暂停和恢复的 api 有 suspend 和 resume，但它们是不可用的，因为如果先调用的 resume 那么 suspend 将感知不到 解决方法是使用 park \u0026amp; unpark 来实现线程的暂停和恢复，具体原理在之前讲过了，先 unpark 再 park 也没 问题 park \u0026amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细 park 线程还可以通过 interrupt 打断  队列设计\n使用了 FIFO 先入先出队列，并不支持优先级队列 设计时借鉴了 CLH 队列，它是一种单向无锁队列\ngraph LR subgraph 初始 a1(head)--\u0026gt;b1(Dummy) c1(Dummy)--\u0026gt;b1 end subgraph 新节点 a2(head)--\u0026gt;b2(Dummy) c2(tail)--\u0026gt;d2(Node)--prev--\u0026gt;b2 end  队列中有 head 和 tail 两个指针节点，都用 volatile 修饰配合 cas 使用，每个节点有 state 维护节点状态\n入队伪代码，只需要考虑 tail 赋值的原子性\ndo { // 原来的 tail Node prev = tail; // 用 cas 在原来 tail 的基础上改为 node } while(tail.compareAndSet(prev, node))  出队伪代码\n// prev 是上一个节点 while((Node prev=node.prev).state != 唤醒状态) { } // 设置头节点 head = node;  CLH 好处：\n 无锁，使用自旋 快速，无阻塞  AQS 在一些方面改进了 CLH\nprivate Node enq(final Node node) { for (;;) { Node t = tail; // 队列中还没有元素 tail 为 null if (t == null) { // 将 head 从 null -\u0026gt; dummy if (compareAndSetHead(new Node())) tail = head; } else { // 将 node 的 prev 设置为原来的 tail node.prev = t; // 将 tail 从原来的 tail 设置为 node if (compareAndSetTail(t, node)) { // 原来 tail 的 next 设置为 node t.next = node; return t; } } } }  主要用到 AQS 的并发工具类\nReentrantLock 原理 1. 非公平锁实现原理 加锁解锁流程 先从构造器开始看，默认为非公平锁实现\npublic ReentrantLock() { sync = new NonfairSync(); }  NonfairSync 继承自 AQS\n没有竞争时\nfinal void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); }  当没有竞争的时候compareAndSetState直接成功，然后直接将setExclusiveOwnerThread设置为当前线程\n第一个竞争出现时\ncompareAndSetState不能成功，进入else，调用acquire方法\npublic final void acquire(int arg) {、 //tryAcquire方法尝试加锁 //acquireQueued方法尝试创建一个节点对象，加入到等待队列中去 if (!tryAcquire(arg) \u0026amp;\u0026amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); }  Thread-1 执行了\n CAS 尝试将 state 由 0 改为 1 ，结果失败 进入 tryAcquire 逻辑，这时 state 已经是 1 ，结果仍然失败 接下来进入 addWaiter 逻辑，构造 Node 队列  图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态 Node 的创建是懒惰的 其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程，第二个才是关联线程的，双向链表连接到队列的尾部   当前线程进入 acquireQueued 逻辑\nfinal boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor();//获取前驱结点 if (p == head \u0026amp;\u0026amp; tryAcquire(arg)) {//尝试获得锁 setHead(node); p.next = null; // help GC failed = false; return interrupted; } //尝试获得锁失败后，是否应该阻塞住呢？ //parkAndCheckInterrupt阻塞 if (shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } }   acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞\n 如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1 ，失败\n 进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1（它有责任唤醒他的后继的结点），这次返回 false\n shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1 ，失败\n 当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true\n 进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）\n  再次有多个线程经历上述过程竞争失败，变成这个样子\nThread-0 释放锁，进入 tryRelease 流程，如果成功\nprotected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); return free; }   设置 exclusiveOwnerThread 为 null state = 0  public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null \u0026amp;\u0026amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } private void unparkSuccessor(Node node) { int ws = node.waitStatus; if (ws \u0026lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; if (s == null || s.waitStatus \u0026gt; 0) { s = null; for (Node t = tail; t != null \u0026amp;\u0026amp; t != node; t = t.prev) if (t.waitStatus \u0026lt;= 0) s = t; } if (s != null) LockSupport.unpark(s.thread); }  当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程\n找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1\n回到 Thread-1 的 acquireQueued 流程\nfinal boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor();//获取前驱结点 if (p == head \u0026amp;\u0026amp; tryAcquire(arg)) {//尝试获得锁 setHead(node); p.next = null; // help GC failed = false; return interrupted; } //尝试获得锁失败后，是否应该阻塞住呢 //parkAndCheckInterrupt阻塞 if (shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } }  如果加锁成功（没有竞争），会设置\n exclusiveOwnerThread 为 Thread-1，state = 1 head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread 原本的 head 因为从链表断开，而可被垃圾回收  如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了\n如果不巧又被 Thread-4 占了先\n Thread-4 被设置为 exclusiveOwnerThread，state = 1 Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞  加锁源码 // Sync 继承自 AQS static final class NonfairSync extends Sync { private static final long serialVersionUID = 7316153563782823691L; // 加锁实现final void lock() { // 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else // 如果尝试失败，进入 ㈠ acquire(1); } // ㈠ AQS 继承过来的方法, 方便阅读, 放在此处 public final void acquire(int arg) { // ㈡ tryAcquire if ( !tryAcquire(arg) \u0026amp;\u0026amp; // 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤ acquireQueued(addWaiter(Node.EXCLUSIVE), arg) ) { selfInterrupt(); } } // ㈡ 进入 ㈢ protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); } //非公平锁会调用该方法获取锁 // ㈢ Sync 继承过来的方法, 方便阅读, 放在此处 final boolean nonfairTryAcquire(int acquires) {final Thread current = Thread.currentThread(); int c = getState(); // 如果还没有获得锁 if (c == 0) { // 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列 if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } // 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入 else if (current == getExclusiveOwnerThread()) { // state++ int nextc = c + acquires; if (nextc \u0026lt; 0) // overflow throw new Error(\u0026quot;Maximum lock count exceeded\u0026quot;); setState(nextc); return true; } // 获取失败, 回到调用处 return false; } // ㈣ AQS 继承过来的方法, 方便阅读, 放在此处 private Node addWaiter(Node mode) { // 将当前线程关联到一个 Node 对象上, 模式为独占模式 Node node = new Node(Thread.currentThread(), mode); // 如果 tail 不为 null, cas 尝试将 Node 对象加入 AQS 队列尾部 Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { // 双向链表 pred.next = node; return node; } } // 尝试将 Node 加入 AQS, 进入 ㈥ enq(node); return node; } // ㈥ AQS 继承过来的方法, 方便阅读, 放在此处 private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0） if (compareAndSetHead(new Node())) { tail = head; } } else { // cas 尝试将 Node 对象加入 AQS 队列尾部 node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } // ㈤ AQS 继承过来的方法, 方便阅读, 放在此处 final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); // 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取 if (p == head \u0026amp;\u0026amp; tryAcquire(arg)) { // 获取成功, 设置自己（当前线程对应的 node）为 head setHead(node); // 上一个节点 help GC p.next = null; failed = false; // 返回中断标记 false return interrupted;} if ( // 判断是否应当 park, 进入 ㈦ shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp; // park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧ parkAndCheckInterrupt() ) { interrupted = true; } } } finally { if (failed) cancelAcquire(node); } } // ㈦ AQS 继承过来的方法, 方便阅读, 放在此处 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { // 获取上一个节点的状态 int ws = pred.waitStatus; if (ws == Node.SIGNAL) { // 上一个节点都在阻塞, 那么自己也阻塞好了 return true; } // \u0026gt; 0 表示取消状态 if (ws \u0026gt; 0) { // 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试 do { node.prev = pred = pred.prev; } while (pred.waitStatus \u0026gt; 0); pred.next = node; } else { // 这次还没有阻塞 // 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false; } // ㈧ 阻塞当前线程 private final boolean parkAndCheckInterrupt() { LockSupport.park(this); return Thread.interrupted(); } }  注意\n是否需要 unpark 是由当前节点的前驱节点的 waitStatus == Node.SIGNAL 来决定，而不是本节点的 waitStatus 决定  解锁源码\n// Sync 继承自 AQS static final class NonfairSync extends Sync { // 解锁实现 public void unlock() { sync.release(1); } // AQS 继承过来的方法, 方便阅读, 放在此处 public final boolean release(int arg) { // 尝试释放锁, 进入 ㈠ if (tryRelease(arg)) { // 队列头节点 unpark Node h = head; if ( // 队列不为 null h != null \u0026amp;\u0026amp; // waitStatus == Node.SIGNAL 才需要 unpark h.waitStatus != 0 ) { // unpark AQS 中等待的线程, 进入 ㈡ unparkSuccessor(h); } return true; } return false; } // ㈠ Sync 继承过来的方法, 方便阅读, 放在此处 protected final boolean tryRelease(int releases) { // state-- int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; // 支持锁重入, 只有 state 减为 0, 才释放成功 if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); return free; } // ㈡ AQS 继承过来的方法, 方便阅读, 放在此处 private void unparkSuccessor(Node node) { // 如果状态为 Node.SIGNAL 尝试重置状态为 0 // 不成功也可以 int ws = node.waitStatus; if (ws \u0026lt; 0) { compareAndSetWaitStatus(node, ws, 0); } // 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的Node s = node.next; // 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点 if (s == null || s.waitStatus \u0026gt; 0) { s = null; for (Node t = tail; t != null \u0026amp;\u0026amp; t != node; t = t.prev) if (t.waitStatus \u0026lt;= 0) s = t; } if (s != null) LockSupport.unpark(s.thread); } }  2. 可重入原理 非公平锁的可重入源码\nstatic final class NonfairSync extends Sync { // ... // Sync 继承过来的方法, 方便阅读, 放在此处 final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState();//先获取状态 if (c == 0) {//首次获得锁 if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } // 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入 else if (current == getExclusiveOwnerThread()) { // state++ int nextc = c + acquires; if (nextc \u0026lt; 0) // overflow throw new Error(\u0026quot;Maximum lock count exceeded\u0026quot;); setState(nextc); return true; } return false; } // Sync 继承过来的方法, 方便阅读, 放在此处 protected final boolean tryRelease(int releases) { // state-- int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; // 支持锁重入, 只有 state 减为 0, 才释放成功 if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); return free; }  3. 可打断原理 不可打断模式 在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了\n// Sync 继承自 AQS static final class NonfairSync extends Sync { // ... //线程在没法获得锁时会进入该方法的循环内不断地尝试 final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); //进入循环后如果获得不了锁还是会阻塞住 //获得锁之后进入if语句块 if (p == head \u0026amp;\u0026amp; tryAcquire(arg)) { setHead(node); p.next = null; failed = false; // 还是需要获得锁后, 才能返回打断状态，返回acquire方法 return interrupted; } //尝试仍不成功会进入parkAndCheckInterrupt方法阻塞住，可以调用Interrupt方法被唤醒 //唤醒会返回一个结果true，就会进入if语句块 if (shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp;parkAndCheckInterrupt()) { //重置打断标记会进入下一次循环 // 如果是因为 interrupt 被唤醒, 返回打断状态为 true interrupted = true; } } } finally { if (failed) cancelAcquire(node); } } private final boolean parkAndCheckInterrupt() { // 如果打断标记已经是 true, 则 park 会失效 LockSupport.park(this); // interrupted 会清除打断标记 //返回一个boolean值是否打断过 return Thread.interrupted(); } public final void acquire(int arg) { //acquireQueued为真，进入if语句块中 if (!tryAcquire(arg) \u0026amp;\u0026amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) { // 如果打断状态为 true selfInterrupt(); } } static void selfInterrupt() { // 重新产生一次中断 Thread.currentThread().interrupt(); } }  可打断模式 static final class NonfairSync extends Sync { public final void acquireInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); // 如果没有获得到锁, 进入 ㈠ if (!tryAcquire(arg)) doAcquireInterruptibly(arg); } // ㈠ 可打断的获取锁流程 private void doAcquireInterruptibly(int arg) throws InterruptedException { final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try { for (;;) { final Node p = node.predecessor(); if (p == head \u0026amp;\u0026amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return; } if (shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp; parkAndCheckInterrupt()) { // 在 park 过程中如果被 interrupt 会进入此 // 这时候抛出异常, 而不会再次进入 for (;;) throw new InterruptedException(); } } } finally { if (failed) cancelAcquire(node); } } }  4. 公平锁实现原理 static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; final void lock() { acquire(1); } // AQS 继承过来的方法, 方便阅读, 放在此处 public final void acquire(int arg) { if ( !tryAcquire(arg) \u0026amp;\u0026amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg) ) { selfInterrupt(); } } //公平锁会调用该方法获得锁 // 与非公平锁主要区别在于 tryAcquire 方法的实现 protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { // 先检查 AQS 队列中是否有前驱节点, 没有才去竞争 if (!hasQueuedPredecessors() \u0026amp;\u0026amp;compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc \u0026lt; 0) throw new Error(\u0026quot;Maximum lock count exceeded\u0026quot;); setState(nextc); return true; } return false; } // ㈠ AQS 继承过来的方法, 方便阅读, 放在此处 public final boolean hasQueuedPredecessors() { Node t = tail; Node h = head; Node s; // h != t 时表示队列中有 Node return h != t \u0026amp;\u0026amp;( // (s = h.next) == null 表示队列中还有没有老二 (s = h.next) == null || // 或者队列中老二线程不是此线程 s.thread != Thread.currentThread() ); } }  5. 条件变量实现原理 每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject\nawait 流程 开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程\n创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部\npublic final void await() throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); //进入addConditionWaiter里面 Node node = addConditionWaiter(); //将结点上地所有地锁释放掉，可能发生锁重入 int savedState = fullyRelease(node); int interruptMode = 0; while (!isOnSyncQueue(node)) { LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } if (acquireQueued(node, savedState) \u0026amp;\u0026amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); } private Node addConditionWaiter() { Node t = lastWaiter; // If lastWaiter is cancelled, clean out. if (t != null \u0026amp;\u0026amp; t.waitStatus != Node.CONDITION) { unlinkCancelledWaiters(); t = lastWaiter; } //创建新地结点，关联当前地线程 Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node; } final int fullyRelease(Node node) { boolean failed = true; try { int savedState = getState(); if (release(savedState)) { failed = false; return savedState; } else { throw new IllegalMonitorStateException(); } } finally { if (failed) node.waitStatus = Node.CANCELLED; } }  接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁\nunpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功\npark 阻塞 Thread-0\nsignal 流程 假设 Thread-1 要来唤醒 Thread-0\npublic final void signal() { //是不是锁地持有者 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first); } private void doSignal(Node first) { do { if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null;//将指向的下一个结点为null，即不指向任何结点 //transferForSignal将该结点转移到竞争锁的链表中 } while (!transferForSignal(first) \u0026amp;\u0026amp; (first = firstWaiter) != null); }  进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node\n执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0 ，Thread-3 的 waitStatus 改为 -1\nThread-1 释放锁，进入 unlock 流程，略\n源码\npublic class ConditionObject implements Condition, java.io.Serializable { private static final long serialVersionUID = 1173984872572414699L; // 第一个等待节点 private transient Node firstWaiter; // 最后一个等待节点 private transient Node lastWaiter; public ConditionObject() { } // ㈠ 添加一个 Node 至等待队列 private Node addConditionWaiter() { Node t = lastWaiter; // 所有已取消的 Node 从队列链表删除, 见 ㈡if (t != null \u0026amp;\u0026amp; t.waitStatus != Node.CONDITION) { unlinkCancelledWaiters(); t = lastWaiter; } // 创建一个关联当前线程的新 Node, 添加至队列尾部 Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node; } // 唤醒 - 将没取消的第一个节点转移至 AQS 队列 private void doSignal(Node first) { do { // 已经是尾节点了 if ( (firstWaiter = first.nextWaiter) == null) { lastWaiter = null; } first.nextWaiter = null; } while ( // 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环 ㈢ !transferForSignal(first) \u0026amp;\u0026amp; // 队列还有节点 (first = firstWaiter) != null ); } // 外部类方法, 方便阅读, 放在此处 // ㈢ 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功 final boolean transferForSignal(Node node) { // 如果状态已经不是 Node.CONDITION, 说明被取消了 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; // 加入 AQS 队列尾部 Node p = enq(node); int ws = p.waitStatus; if ( // 上一个节点被取消 ws \u0026gt; 0 || // 上一个节点不能设置状态为 Node.SIGNAL !compareAndSetWaitStatus(p, ws, Node.SIGNAL) ) { // unpark 取消阻塞, 让线程重新同步状态 LockSupport.unpark(node.thread); } return true; } // 全部唤醒 - 等待队列的所有节点转移至 AQS 队列private void doSignalAll(Node first) { lastWaiter = firstWaiter = null; do { Node next = first.nextWaiter; first.nextWaiter = null; transferForSignal(first); first = next; } while (first != null); } // ㈡ private void unlinkCancelledWaiters() { // ... } // 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁 public final void signal() { if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first); } // 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁 public final void signalAll() { if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignalAll(first); } // 不可打断等待 - 直到被唤醒 public final void awaitUninterruptibly() { // 添加一个 Node 至等待队列, 见 ㈠ Node node = addConditionWaiter(); // 释放节点持有的锁, 见 ㈣ int savedState = fullyRelease(node); boolean interrupted = false; // 如果该节点还没有转移至 AQS 队列, 阻塞 while (!isOnSyncQueue(node)) { // park 阻塞 LockSupport.park(this); // 如果被打断, 仅设置打断状态 if (Thread.interrupted()) interrupted = true; } // 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列 if (acquireQueued(node, savedState) || interrupted) selfInterrupt(); }// 外部类方法, 方便阅读, 放在此处 // ㈣ 因为某线程可能重入，需要将 state 全部释放 final int fullyRelease(Node node) { boolean failed = true; try { int savedState = getState(); if (release(savedState)) { failed = false; return savedState; } else { throw new IllegalMonitorStateException(); } } finally { if (failed) node.waitStatus = Node.CANCELLED; } } // 打断模式 - 在退出等待时重新设置打断状态 private static final int REINTERRUPT = 1; // 打断模式 - 在退出等待时抛出异常 private static final int THROW_IE = -1; // 判断打断模式 private int checkInterruptWhileWaiting(Node node) { return Thread.interrupted() ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0; } // ㈤ 应用打断模式 private void reportInterruptAfterWait(int interruptMode) throws InterruptedException { if (interruptMode == THROW_IE) throw new InterruptedException(); else if (interruptMode == REINTERRUPT) selfInterrupt(); } // 等待 - 直到被唤醒或打断 public final void await() throws InterruptedException { if (Thread.interrupted()) { throw new InterruptedException(); } // 添加一个 Node 至等待队列, 见 ㈠ Node node = addConditionWaiter(); // 释放节点持有的锁 int savedState = fullyRelease(node); int interruptMode = 0; // 如果该节点还没有转移至 AQS 队列, 阻塞 while (!isOnSyncQueue(node)) { // park 阻塞 LockSupport.park(this);// 如果被打断, 退出等待队列 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } // 退出等待队列后, 还需要获得 AQS 队列的锁 if (acquireQueued(node, savedState) \u0026amp;\u0026amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; // 所有已取消的 Node 从队列链表删除, 见 ㈡ if (node.nextWaiter != null) unlinkCancelledWaiters(); // 应用打断模式, 见 ㈤ if (interruptMode != 0) reportInterruptAfterWait(interruptMode); } // 等待 - 直到被唤醒或打断或超时 public final long awaitNanos(long nanosTimeout) throws InterruptedException { if (Thread.interrupted()) { throw new InterruptedException(); } // 添加一个 Node 至等待队列, 见 ㈠ Node node = addConditionWaiter(); // 释放节点持有的锁 int savedState = fullyRelease(node); // 获得最后期限 final long deadline = System.nanoTime() + nanosTimeout; int interruptMode = 0; // 如果该节点还没有转移至 AQS 队列, 阻塞 while (!isOnSyncQueue(node)) { // 已超时, 退出等待队列 if (nanosTimeout \u0026lt;= 0L) { transferAfterCancelledWait(node); break; } // park 阻塞一定时间, spinForTimeoutThreshold 为 1000 ns if (nanosTimeout \u0026gt;= spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); // 如果被打断, 退出等待队列 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; nanosTimeout = deadline - System.nanoTime(); } // 退出等待队列后, 还需要获得 AQS 队列的锁 if (acquireQueued(node, savedState) \u0026amp;\u0026amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; // 所有已取消的 Node 从队列链表删除, 见 ㈡ if (node.nextWaiter != null) unlinkCancelledWaiters(); // 应用打断模式, 见 ㈤ if (interruptMode != 0) reportInterruptAfterWait(interruptMode); return deadline - System.nanoTime(); }// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos public final boolean awaitUntil(Date deadline) throws InterruptedException { // ... } // 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos public final boolean await(long time, TimeUnit unit) throws InterruptedException { // ... } // 工具方法 省略 ... }  读写锁原理 1. 图解流程 读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个\nt1 w.lock，t2 r.lock\npublic final void acquire(int arg) { if (!tryAcquire(arg) \u0026amp;\u0026amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } protected final boolean tryAcquire(int acquires) { Thread current = Thread.currentThread(); int c = getState(); int w = exclusiveCount(c); if (c != 0) { // (Note: if c != 0 and w == 0 then shared count != 0) if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w + exclusiveCount(acquires) \u0026gt; MAX_COUNT) throw new Error(\u0026quot;Maximum lock count exceeded\u0026quot;); // Reentrant acquire setState(c + acquires); return true; } if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) return false; setExclusiveOwnerThread(current); return true; }  1 ） t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，而读锁 使用的是 state 的高 16 位\n2 ）t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写 锁占据，那么 tryAcquireShared 返回\npublic final void acquireShared(int arg) { if (tryAcquireShared(arg) \u0026lt; 0) doAcquireShared(arg); } protected final int tryAcquireShared(int unused) { Thread current = Thread.currentThread(); int c = getState(); if (exclusiveCount(c) != 0 \u0026amp;\u0026amp; getExclusiveOwnerThread() != current) return -1; int r = sharedCount(c); if (!readerShouldBlock() \u0026amp;\u0026amp; r \u0026lt; MAX_COUNT \u0026amp;\u0026amp; compareAndSetState(c, c + SHARED_UNIT)) { if (r == 0) { firstReader = current; firstReaderHoldCount = 1; } else if (firstReader == current) { firstReaderHoldCount++; } else { HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; } return 1; } return fullTryAcquireShared(current); } private void doAcquireShared(int arg) { final Node node = addWaiter(Node.SHARED); boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head) { int r = tryAcquireShared(arg); if (r \u0026gt;= 0) { setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; } } if (shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } }   -1 表示失败\n 0 表示成功，但后继节点不会继续唤醒\n 正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1\n  3 ）这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态\n4 ）t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁\n5 ）如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一 次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park\nt3 r.lock，t4 w.lock\n这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子\nt1 w.unlock\npublic final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null \u0026amp;\u0026amp; h.waitStatus != 0) unparkSuccessor(h);//唤醒后继结点 return true; } return false; } protected final boolean tryRelease(int releases) { if (!isHeldExclusively()) throw new IllegalMonitorStateException(); int nextc = getState() - releases; boolean free = exclusiveCount(nextc) == 0; if (free) setExclusiveOwnerThread(null); setState(nextc); return free; }  这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子\n接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内parkAndCheckInterrupt() 处恢复运行\n这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一\n这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点\n事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行\n这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一\n这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点\n下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点\nt2 r.unlock，t3 r.unlock\nt2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零\nt3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入 doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即\n之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他 竞争，tryAcquire(1) 成功，修改头结点，流程结束\n2. 源码分析 写锁上锁流程 static final class NonfairSync extends Sync { // ... 省略无关代码 // 外部类 WriteLock 方法, 方便阅读, 放在此处 public void lock() { sync.acquire(1); } // AQS 继承过来的方法, 方便阅读, 放在此处 public final void acquire(int arg) { if ( // 尝试获得写锁失败 !tryAcquire(arg) \u0026amp;\u0026amp; // 将当前线程关联到一个 Node 对象上, 模式为独占模式 // 进入 AQS 队列阻塞 acquireQueued(addWaiter(Node.EXCLUSIVE), arg) ) { selfInterrupt(); } } // Sync 继承过来的方法, 方便阅读, 放在此处 protected final boolean tryAcquire(int acquires) { // 获得低 16 位, 代表写锁的 state 计数 Thread current = Thread.currentThread(); int c = getState();int w = exclusiveCount(c); if (c != 0) { if ( // c != 0 and w == 0 表示有读锁, 或者 w == 0 || // 如果 exclusiveOwnerThread 不是自己 current != getExclusiveOwnerThread() ) { // 获得锁失败 return false; } // 写锁计数超过低 16 位, 报异常 if (w + exclusiveCount(acquires) \u0026gt; MAX_COUNT) throw new Error(\u0026quot;Maximum lock count exceeded\u0026quot;); // 写锁重入, 获得锁成功 setState(c + acquires); return true; } if ( // 判断写锁是否该阻塞, 或者 writerShouldBlock() || // 尝试更改计数失败 !compareAndSetState(c, c + acquires) ) { // 获得锁失败 return false; } // 获得锁成功 setExclusiveOwnerThread(current); return true; } // 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞 final boolean writerShouldBlock() { return false; } }  写锁释放流程 static final class NonfairSync extends Sync { // ... 省略无关代码 // WriteLock 方法, 方便阅读, 放在此处 public void unlock() { sync.release(1); } // AQS 继承过来的方法, 方便阅读, 放在此处 public final boolean release(int arg) { // 尝试释放写锁成功if (tryRelease(arg)) { // unpark AQS 中等待的线程 Node h = head; if (h != null \u0026amp;\u0026amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } // Sync 继承过来的方法, 方便阅读, 放在此处 protected final boolean tryRelease(int releases) { if (!isHeldExclusively()) throw new IllegalMonitorStateException(); int nextc = getState() - releases; // 因为可重入的原因, 写锁计数为 0, 才算释放成功 boolean free = exclusiveCount(nextc) == 0; if (free) { setExclusiveOwnerThread(null); } setState(nextc); return free; } }  读锁上锁流程 static final class NonfairSync extends Sync { // ReadLock 方法, 方便阅读, 放在此处 public void lock() { sync.acquireShared(1); } // AQS 继承过来的方法, 方便阅读, 放在此处 public final void acquireShared(int arg) { // tryAcquireShared 返回负数, 表示获取读锁失败 if (tryAcquireShared(arg) \u0026lt; 0) { doAcquireShared(arg); } } // Sync 继承过来的方法, 方便阅读, 放在此处 protected final int tryAcquireShared(int unused) { Thread current = Thread.currentThread(); int c = getState(); // 如果是其它线程持有写锁, 获取读锁失败 if ( exclusiveCount(c) != 0 \u0026amp;\u0026amp; getExclusiveOwnerThread() != current ) { return -1;} int r = sharedCount(c); if ( // 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且 !readerShouldBlock() \u0026amp;\u0026amp; // 小于读锁计数, 并且 r \u0026lt; MAX_COUNT \u0026amp;\u0026amp; // 尝试增加计数成功 compareAndSetState(c, c + SHARED_UNIT) ) { // ... 省略不重要的代码 return 1; } return fullTryAcquireShared(current); } // 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁 // true 则该阻塞, false 则不阻塞 final boolean readerShouldBlock() { return apparentlyFirstQueuedIsExclusive(); } // AQS 继承过来的方法, 方便阅读, 放在此处 // 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞 final int fullTryAcquireShared(Thread current) { HoldCounter rh = null; for (;;) { int c = getState(); if (exclusiveCount(c) != 0) { if (getExclusiveOwnerThread() != current) return -1; } else if (readerShouldBlock()) { // ... 省略不重要的代码 } if (sharedCount(c) == MAX_COUNT) throw new Error(\u0026quot;Maximum lock count exceeded\u0026quot;); if (compareAndSetState(c, c + SHARED_UNIT)) { // ... 省略不重要的代码 return 1; } } } // AQS 继承过来的方法, 方便阅读, 放在此处 private void doAcquireShared(int arg) { // 将当前线程关联到一个 Node 对象上, 模式为共享模式 final Node node = addWaiter(Node.SHARED); boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head) {// 再一次尝试获取读锁 int r = tryAcquireShared(arg); // 成功 if (r \u0026gt;= 0) { // ㈠ // r 表示可用资源数, 在这里总是 1 允许传播 //（唤醒 AQS 中下一个 Share 节点） setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; } } if ( // 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL） shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp; // park 当前线程 parkAndCheckInterrupt() ) { interrupted = true; } } } finally { if (failed) cancelAcquire(node); } } // ㈠ AQS 继承过来的方法, 方便阅读, 放在此处 private void setHeadAndPropagate(Node node, int propagate) { Node h = head; // Record old head for check below // 设置自己为 head setHead(node); // propagate 表示有共享资源（例如共享读锁或信号量） // 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE // 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE if (propagate \u0026gt; 0 || h == null || h.waitStatus \u0026lt; 0 || (h = head) == null || h.waitStatus \u0026lt; 0) { Node s = node.next; // 如果是最后一个节点或者是等待共享读锁的节点 if (s == null || s.isShared()) { // 进入 ㈡ doReleaseShared(); } } } // ㈡ AQS 继承过来的方法, 方便阅读, 放在此处 private void doReleaseShared() { // 如果 head.waitStatus == Node.SIGNAL ==\u0026gt; 0 成功, 下一个节点 unpark// 如果 head.waitStatus == 0 ==\u0026gt; Node.PROPAGATE, 为了解决 bug, 见后面分析 for (;;) { Node h = head; // 队列还有节点 if (h != null \u0026amp;\u0026amp; h != tail) { int ws = h.waitStatus; if (ws == Node.SIGNAL) { if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases // 下一个节点 unpark 如果成功获取读锁 // 并且下下个节点还是 shared, 继续 doReleaseShared unparkSuccessor(h); } else if (ws == 0 \u0026amp;\u0026amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS } if (h == head) // loop if head changed break; } } }  读锁释放流程 static final class NonfairSync extends Sync { // ReadLock 方法, 方便阅读, 放在此处 public void unlock() { sync.releaseShared(1); } // AQS 继承过来的方法, 方便阅读, 放在此处 public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; } // Sync 继承过来的方法, 方便阅读, 放在此处 protected final boolean tryReleaseShared(int unused) { // ... 省略不重要的代码 for (;;) { int c = getState(); int nextc = c - SHARED_UNIT; if (compareAndSetState(c, nextc)) { // 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程 // 计数为 0 才是真正释放 return nextc == 0; }} } // AQS 继承过来的方法, 方便阅读, 放在此处 private void doReleaseShared() { // 如果 head.waitStatus == Node.SIGNAL ==\u0026gt; 0 成功, 下一个节点 unpark // 如果 head.waitStatus == 0 ==\u0026gt; Node.PROPAGATE for (;;) { Node h = head; if (h != null \u0026amp;\u0026amp; h != tail) { int ws = h.waitStatus; // 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0 // 防止 unparkSuccessor 被多次执行 if (ws == Node.SIGNAL) { if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); } // 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析 else if (ws == 0 \u0026amp;\u0026amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS } if (h == head) // loop if head changed break; } } }  Semaphore 原理 1. 加锁解锁流程 Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后 停车场显示空余车位减一\n刚开始，permits（state）为 3 ，这时 5 个线程来获取资源假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列 park 阻塞\n这时 Thread-4 释放了 permits，状态如下\n接下来 Thread-0 竞争成功，permits 再次设置为 0 ，设置自己为 head 节点，断开原来的 head 节点，unpark 接 下来的 Thread-3 节点，但由于 permits 是 0 ，因此 Thread-3 在尝试不成功后再次进入 park 状态\n2. 源码分析 static final class NonfairSync extends Sync { private static final long serialVersionUID = -2694183684443567898L; NonfairSync(int permits) { // permits 即 state super(permits); } // Semaphore 方法, 方便阅读, 放在此处 public void acquire() throws InterruptedException { sync.acquireSharedInterruptibly(1); } // AQS 继承过来的方法, 方便阅读, 放在此处 public final void acquireSharedInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) \u0026lt; 0) doAcquireSharedInterruptibly(arg); } // 尝试获得共享锁 protected int tryAcquireShared(int acquires) { return nonfairTryAcquireShared(acquires); } // Sync 继承过来的方法, 方便阅读, 放在此处 final int nonfairTryAcquireShared(int acquires) { for (;;) { int available = getState(); int remaining = available - acquires; if ( // 如果许可已经用完, 返回负数, 表示获取失败, 进入 doAcquireSharedInterruptibly remaining \u0026lt; 0 || // 如果 cas 重试成功, 返回正数, 表示获取成功 compareAndSetState(available, remaining)) { return remaining; } } } // AQS 继承过来的方法, 方便阅读, 放在此处 private void doAcquireSharedInterruptibly(int arg) throws InterruptedException { final Node node = addWaiter(Node.SHARED); boolean failed = true; try { for (;;) { final Node p = node.predecessor(); if (p == head) { // 再次尝试获取许可 int r = tryAcquireShared(arg); if (r \u0026gt;= 0) { // 成功后本线程出队（AQS）, 所在 Node设置为 head // 如果 head.waitStatus == Node.SIGNAL ==\u0026gt; 0 成功, 下一个节点 unpark // 如果 head.waitStatus == 0 ==\u0026gt; Node.PROPAGATE // r 表示可用资源数, 为 0 则不会继续传播 setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; } } // 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞 if (shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp; parkAndCheckInterrupt()) throw new InterruptedException(); } } finally { if (failed) cancelAcquire(node); } } // Semaphore 方法, 方便阅读, 放在此处 public void release() { sync.releaseShared(1); } // AQS 继承过来的方法, 方便阅读, 放在此处 public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; } // Sync 继承过来的方法, 方便阅读, 放在此处protected final boolean tryReleaseShared(int releases) { for (;;) { int current = getState(); int next = current + releases; if (next \u0026lt; current) // overflow throw new Error(\u0026quot;Maximum permit count exceeded\u0026quot;); if (compareAndSetState(current, next)) return true; } } }  3. 为什么要有 PROPAGATE 早期有 bug\nreleaseShared 方法\npublic final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { Node h = head; if (h != null \u0026amp;\u0026amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; }  doAcquireShared 方法\nprivate void doAcquireShared(int arg) { final Node node = addWaiter(Node.SHARED); boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head) { int r = tryAcquireShared(arg); if (r \u0026gt;= 0) { // 这里会有空档 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; } } if (shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } }  setHeadAndPropagate 方法\nprivate void setHeadAndPropagate(Node node, int propagate) { setHead(node); // 有空闲资源 if (propagate \u0026gt; 0 \u0026amp;\u0026amp; node.waitStatus != 0) { Node s = node.next; // 下一个 if (s == null || s.isShared()) unparkSuccessor(node); } }   假设存在某次循环中队列里排队的结点情况为 head(-1)-\u0026gt;t1(-1)-\u0026gt;t2(-1) 假设存在将要信号量释放的 T3 和 T4，释放顺序为先 T3 后 T4  正常流程\n产生 bug 的情况\n修复前版本执行流程\n T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head 的等待状态从 -1 变为 0 T1 由于 T3 释放信号量被唤醒，调用 tryAcquireShared，假设返回值为 0 （获取锁成功，但没有剩余资源 量） T4 调用 releaseShared(1)，此时 head.waitStatus 为 0 （此时读到的 head 和 1 中为同一个head），不满足 条件，因此不调用 unparkSuccessor(head) T1 获取信号量成功，调用 setHeadAndPropagate 时，因为不满足 propagate \u0026gt; 0（ 2 的返回值也就是 propagate（剩余资源量） == 0），从而不会唤醒后继结点， T2 线程得不到唤醒  bug 修复后\n Node h = head; // Record old head for check below // 设置自己为 head setHead(node); // propagate 表示有共享资源（例如共享读锁或信号量） // 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE // 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE if (propagate \u0026gt; 0 || h == null || h.waitStatus \u0026lt; 0 || (h = head) == null || h.waitStatus \u0026lt; 0) { Node s = node.next; // 如果是最后一个节点或者是等待共享读锁的节点 if (s == null || s.isShared()) { doReleaseShared(); } } } private void doReleaseShared() { // 如果 head.waitStatus == Node.SIGNAL ==\u0026gt; 0 成功, 下一个节点 unpark // 如果 head.waitStatus == 0 ==\u0026gt; Node.PROPAGATE for (;;) { Node h = head; if (h != null \u0026amp;\u0026amp; h != tail) { int ws = h.waitStatus; if (ws == Node.SIGNAL) { if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); } else if (ws == 0 \u0026amp;\u0026amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS } if (h == head) // loop if head changed break; } }   T3 调用 releaseShared()，直接调用了 unparkSuccessor(head)，head 的等待状态从 -1 变为 0 T1 由于 T3 释放信号量被唤醒，调用 tryAcquireShared，假设返回值为 0 （获取锁成功，但没有剩余资源 量） T4 调用 releaseShared()，此时 head.waitStatus 为 0 （此时读到的 head 和 1 中为同一个 head），调用 doReleaseShared() 将等待状态置为 PROPAGATE（-3） T1 获取信号量成功，调用 setHeadAndPropagate 时，读到 h.waitStatus \u0026lt; 0，从而调用 doReleaseShared() 唤醒 T2  ConcurrentHashMap 原理 1. JDK 7 HashMap 并发死链 测试代码\n注意\n 要在 JDK 7 下运行，否则扩容机制和 hash 的计算方法都变了\n 以下测试代码是精心准备的，不要随便改动\npublic static void main(String[] args) { // 测试 java 7 中哪些数字的 hash 结果相等 System.out.println(\u0026quot;长度为16时，桶下标为1的key\u0026quot;); for (int i = 0; i \u0026lt; 64; i++) { if (hash(i) % 16 == 1) { System.out.println(i); } } System.out.println(\u0026quot;长度为32时，桶下标为1的key\u0026quot;); for (int i = 0; i \u0026lt; 64; i++) { if (hash(i) % 32 == 1) { System.out.println(i); } } // 1, 35, 16, 50 当大小为16时，它们在一个桶内 final HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;Integer, Integer\u0026gt;(); // 放 12 个元素 map.put(2, null); map.put(3, null); map.put(4, null); map.put(5, null); map.put(6, null); map.put(7, null); map.put(8, null); map.put(9, null); map.put(10, null); map.put(16, null); map.put(35, null); map.put(1, null); System.out.println(\u0026quot;扩容前大小[main]:\u0026quot;+map.size()); new Thread() { @Override public void run() { // 放第 13 个元素, 发生扩容 map.put(50, null); System.out.println(\u0026quot;扩容后大小[Thread-0]:\u0026quot;+map.size()); } }.start(); new Thread() { @Override public void run() { // 放第 13 个元素, 发生扩容 map.put(50, null); System.out.println(\u0026quot;扩容后大小[Thread-1]:\u0026quot;+map.size()); } }.start(); } final static int hash(Object k) { int h = 0;if (0 != h \u0026amp;\u0026amp; k instanceof String) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); h ^= (h \u0026gt;\u0026gt;\u0026gt; 20) ^ (h \u0026gt;\u0026gt;\u0026gt; 12); return h ^ (h \u0026gt;\u0026gt;\u0026gt; 7) ^ (h \u0026gt;\u0026gt;\u0026gt; 4); }   死链复现\n调试工具使用 idea\n在 HashMap 源码 590 行加断点\nint newCapacity = newTable.length;  断点的条件如下，目的是让 HashMap 在扩容为 32 时，并且线程为 Thread-0 或 Thread-1 时停下来\nnewTable.length==32 \u0026amp;\u0026amp; (Thread.currentThread().getName().equals(\u0026quot;Thread-0\u0026quot;)|| Thread.currentThread().getName().equals(\u0026quot;Thread-1\u0026quot;) )  断点暂停方式选择 Thread，否则在调试 Thread-0 时，Thread-1 无法恢复运行\n运行代码，程序在预料的断点位置停了下来，输出\n长度为 16 时，桶下标为 1 的key 1 16 35 50 长度为 32 时，桶下标为 1 的key 1 35 扩容前大小[main]:12  接下来进入扩容流程调试\n在 HashMap 源码 594 行加断点\nEntry\u0026lt;K,V\u0026gt; next = e.next; // 593 if (rehash) // 594 // ...  这是为了观察 e 节点和 next 节点的状态，Thread-0 单步执行到 594 行，再 594 处再添加一个断点（条件 Thread.currentThread().getName().equals(\u0026ldquo;Thread-0\u0026rdquo;)）\n这时可以在 Variables 面板观察到 e 和 next 变量，使用 view as -\u0026gt; Object 查看节点状态\ne (1)-\u0026gt;(35)-\u0026gt;(16)-\u0026gt;null next (35)-\u0026gt;(16)-\u0026gt;null  在 Threads 面板选中 Thread-1 恢复运行，可以看到控制台输出新的内容如下，Thread-1 扩容已完成\nnewTable[1] (35)-\u0026gt;(1)-\u0026gt;null  扩容后大小:13  这时 Thread-0 还停在 594 处， Variables 面板变量的状态已经变化为\ne (1)-\u0026gt;null next (35)-\u0026gt;(1)-\u0026gt;null  为什么呢，因为 Thread-1 扩容时链表也是后加入的元素放入链表头，因此链表就倒过来了，但 Thread-1 虽然结 果正确，但它结束后 Thread-0 还要继续运行\n接下来就可以单步调试（F8）观察死链的产生了\n下一轮循环到 594 ，将 e 搬迁到 newTable 链表头\nnewTable[1] (1)-\u0026gt;null e (35)-\u0026gt;(1)-\u0026gt;null next (1)-\u0026gt;null  下一轮循环到 594 ，将 e 搬迁到 newTable 链表头\nnewTable[1] (35)-\u0026gt;(1)-\u0026gt;null e (1)-\u0026gt;null next null  再看看源码\ne.next = newTable[1]; // 这时 e (1,35) // 而 newTable[1] (35,1)-\u0026gt;(1,35) 因为是同一个对象 newTable[1] = e; // 再尝试将 e 作为链表头, 死链已成 e = next; // 虽然 next 是 null, 会进入下一个链表的复制, 但死链已经形成了  源码分析\nHashMap 的并发死链发生在扩容时\n// 将 table 迁移至 newTablevoid transfer(Entry[] newTable, boolean rehash) { int newCapacity = newTable.length; for (Entry\u0026lt;K,V\u0026gt; e : table) { while(null != e) { Entry\u0026lt;K,V\u0026gt; next = e.next; // 1 处 if (rehash) { e.hash = null == e.key ? 0 : hash(e.key); } int i = indexFor(e.hash, newCapacity); // 2 处 // 将新元素加入 newTable[i], 原 newTable[i] 作为新元素的 next e.next = newTable[i]; newTable[i] = e; e = next; } } }  假设 map 中初始元素是\n原始链表，格式：[下标] (key,next) [1] (1,35)-\u0026gt;(35,16)-\u0026gt;(16,null) 线程 a 执行到 1 处 ，此时局部变量 e 为 (1,35)，而局部变量 next 为 (35,16) 线程 a 挂起 线程 b 开始执行 第一次循环 [1] (1,null) 第二次循环 [1] (35,1)-\u0026gt;(1,null) 第三次循环 [1] (35,1)-\u0026gt;(1,null) [17] (16,null) 切换回线程 a，此时局部变量 e 和 next 被恢复，引用没变但内容变了：e 的内容被改为 (1,null)，而 next 的内 容被改为 (35,1) 并链向 (1,null) 第一次循环 [1] (1,null) 第二次循环，注意这时 e 是 (35,1) 并链向 (1,null) 所以 next 又是 (1,null) [1] (35,1)-\u0026gt;(1,null) 第三次循环，e 是 (1,null)，而 next 是 null，但 e 被放入链表头，这样 e.next 变成了 35 （2 处） [1] (1,35)-\u0026gt;(35,1)-\u0026gt;(1,35) 已经是死链了  小结\n 究其原因，是因为在多线程环境下使用了非线程安全的 map 集合 JDK 8 虽然将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）  2. JDK 8 ConcurrentHashMap 原始长度为16\n扩容时元素个数要超过容量的3/4；处理下标从最后进行处理处理结束后会加上一个头节点ForwardingNode，其他线程来的时候会发现该结点是ForwardingNode，就说明该结点已经被处理过了，就不会对这个链表做其他的操作了；将原先的链表进行搬迁操作，迁移到扩容之后的新的数组中；如果在扩容的过程中，其他线程来get去getkey，如果发现是ForwardingNode，就会去扩容后的新的数组中获取值找key\nTreeBin是非常有用的，我们都知道如果链表过长那么它的查找的速度是很低的；那么就可以使用红黑树的数据结构来替换掉一维的链表结构；红黑树是jdk8对hashMap的优化，除了能够增加查询的效率外，还能防止dos攻击(攻击者会构造很多hash码一样的对象，来往hashmap中填充，造成性能直线下降)；这时会有一个链表的长度预值：8；当链表的长度超过8的时候就会将链表的结构转换为红黑树，当然转换之前会尝试扩容，如果hash表的长度容量还没有达到64的时候，先不会把链表的结果变成红黑树，会先扩容。因为扩容能在一定的程度上减少链表的长度(一般能减一半)；当容量扩容到64的时候就不会使用扩容的方式了，就会将链表转换为红黑树；当然如果将来的链表有一些比如删除的操作，红黑树的结点的个数又小于8了，那么又会将红黑树的结构转换为链表\n重要属性和内部类\n// 默认为 0 // 当初始化时, 为 -1 // 当扩容时, 为 -(1 + 扩容线程数) // 当初始化或扩容完成后，为 下一次的扩容的阈值大小 private transient volatile int sizeCtl; // 整个 ConcurrentHashMap 就是一个 Node[] static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; {} // hash 表 transient volatile Node\u0026lt;K,V\u0026gt;[] table; // 扩容时的 新 hash 表 private transient volatile Node\u0026lt;K,V\u0026gt;[] nextTable; // 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点 static final class \u0026lt;K,V\u0026gt; extends Node\u0026lt;K,V\u0026gt; {} // 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node static final class ReservationNode\u0026lt;K,V\u0026gt; extends Node\u0026lt;K,V\u0026gt; {} // 作为 treebin 的头节点, 存储 root 和 first static final class TreeBin\u0026lt;K,V\u0026gt; extends Node\u0026lt;K,V\u0026gt; {} //红黑树中的每一个结点 作为 treebin 的节点, 存储 parent, left, right static final class TreeNode\u0026lt;K,V\u0026gt; extends Node\u0026lt;K,V\u0026gt; {}  重要方法 // 获取 Node[] 中第 i 个 Node static final \u0026lt;K,V\u0026gt; Node\u0026lt;K,V\u0026gt; tabAt(Node\u0026lt;K,V\u0026gt;[] tab, int i) // cas 修改 Node[](hash表中) 中第 i 个 Node 的值, c 为旧值, v 为新值 static final \u0026lt;K,V\u0026gt; boolean casTabAt(Node\u0026lt;K,V\u0026gt;[] tab, int i, Node\u0026lt;K,V\u0026gt; c, Node\u0026lt;K,V\u0026gt; v) // 直接修改 Node[] 中第 i 个 Node 的值, v 为新值 static final \u0026lt;K,V\u0026gt; void setTabAt(Node\u0026lt;K,V\u0026gt;[] tab, int i, Node\u0026lt;K,V\u0026gt; v)  构造器分析 可以看到实现了懒惰初始化，在构造方法中仅仅计算了 table 的大小，以后在第一次使用时才会真正创建\n/** initialCapacity：初始容量：map的初始大小 loadFactor：负载因子：3/4：0.75，表示扩容的预值 concurrencyLevel：并发度 */ public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { if (!(loadFactor \u0026gt; 0.0f) || initialCapacity \u0026lt; 0 || concurrencyLevel \u0026lt;= 0) throw new IllegalArgumentException(); if (initialCapacity \u0026lt; concurrencyLevel) // Use at least as many bins initialCapacity = concurrencyLevel; // as estimated threads long size = (long)(1.0 + (long)initialCapacity / loadFactor); //size的值不一定是2^n：hash算法要保证长度为2^n // tableSizeFor 仍然是保证计算的大小是 2^n, 即 16,32,64 ... int cap = (size \u0026gt;= (long)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)size); this.sizeCtl = cap; }  get 流程\npublic V get(Object key) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; e, p; int n, eh; K ek; // spread 方法能确保返回结果是正数(hash码) int h = spread(key.hashCode()); if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (e = tabAt(tab, (n - 1) \u0026amp; h)) != null) { // 如果头结点已经是要查找的 key if ((eh = e.hash) == h) { if ((ek = e.key) == key || (ek != null \u0026amp;\u0026amp; key.equals(ek))) return e.val; } // hash 为负数表示该 bin 在扩容中或是 treebin, 这时调用 find 方法来查找 else if (eh \u0026lt; 0) return (p = e.find(h, key)) != null ? p.val : null; // 正常遍历链表, 用 equals 比较 while ((e = e.next) != null) { if (e.hash == h \u0026amp;\u0026amp; ((ek = e.key) == key || (ek != null \u0026amp;\u0026amp; key.equals(ek)))) return e.val; } } return null; }  put 流程\n以下数组简称（table），链表简称（bin）\npublic V put(K key, V value) {return putVal(key, value, false); } final V putVal(K key, V value, boolean onlyIfAbsent) { //普通的hanshmap中允许有空的key和空的值的；但是ConcurrentHashMap不允许 if (key == null || value == null) throw new NullPointerException(); // 其中 spread 方法会综合高位低位, 具有更好的 hash 性 int hash = spread(key.hashCode()); int binCount = 0;//链表的长度 for (Node\u0026lt;K,V\u0026gt;[] tab = table;;) { // f 是链表头节点 // fh 是链表头结点的 hash // i 是链表在 table 中的下标 Node\u0026lt;K,V\u0026gt; f; int n, i, fh; // 要创建 table if (tab == null || (n = tab.length) == 0) // 初始化 table 使用了 cas, 无需 synchronized 创建成功, 进入下一轮循环 tab = initTable(); // 要创建链表头节点 else if ((f = tabAt(tab, i = (n - 1) \u0026amp; hash)) == null) { // 添加链表头使用了 cas, 无需 synchronized if (casTabAt(tab, i, null, new Node\u0026lt;K,V\u0026gt;(hash, key, value, null))) break; } // 帮忙扩容 else if ((fh = f.hash) == MOVED) // 帮忙之后, 进入下一轮循环 tab = helpTransfer(tab, f); else {//hashtable当前既不是处在扩容过程中，也不是table的初始化过程中而且，肯定是发生了桶下表的冲突 V oldVal = null; // 锁住链表头节点 synchronized (f) { // 再次确认链表头节点没有被移动 if (tabAt(tab, i) == f) { // 链表 if (fh \u0026gt;= 0) {//普通的结点 binCount = 1; // 遍历链表 for (Node\u0026lt;K,V\u0026gt; e = f;; ++binCount) { K ek; // 找到相同的 key if (e.hash == hash \u0026amp;\u0026amp; ((ek = e.key) == key || (ek != null \u0026amp;\u0026amp; key.equals(ek)))) { oldVal = e.val; // 更新 if (!onlyIfAbsent) e.val = value; break; } Node\u0026lt;K,V\u0026gt; pred = e; // 已经是最后的节点了, 新增 Node, 追加至链表尾 if ((e = e.next) == null) { pred.next = new Node\u0026lt;K,V\u0026gt;(hash, key, value, null); break; } } } // 红黑树 else if (f instanceof TreeBin) { Node\u0026lt;K,V\u0026gt; p; binCount = 2; // putTreeVal 会看 key 是否已经在树中, 是, 则返回对应的 TreeNode if ((p = ((TreeBin\u0026lt;K,V\u0026gt;)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } // 释放链表头节点的锁 } if (binCount != 0) { //链表中是有冲突的，长度是大于1的 if (binCount \u0026gt;= TREEIFY_THRESHOLD) // 如果链表长度 \u0026gt;= 树化阈值(8), 进行链表转为红黑树 treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } // 增加 size 计数 addCount(1L, binCount); return null; } private final Node\u0026lt;K,V\u0026gt;[] initTable() { Node\u0026lt;K,V\u0026gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) {//hsah表还没创建 if ((sc = sizeCtl) \u0026lt; 0) Thread.yield(); // 尝试将 sizeCtl 设置为 -1（表示初始化 table） else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { // 获得锁, 创建 table, 这时其它线程会在 while() 循环中 yield 直至 table 创建 try { if ((tab = table) == null || tab.length == 0) { //DEFAULT_CAPACITY:16 int n = (sc \u0026gt; 0) ? sc : DEFAULT_CAPACITY; Node\u0026lt;K,V\u0026gt;[] nt = (Node\u0026lt;K,V\u0026gt;[])new Node\u0026lt;?,?\u0026gt;[n]; table = tab = nt; sc = n - (n \u0026gt;\u0026gt;\u0026gt; 2); } } finally {sizeCtl = sc; } break; } } return tab; } // check 是之前 binCount 的个数 增加hash表中的元素的计数 //设置多个累加单元 private final void addCount(long x, int check) { CounterCell[] as; long b, s; if ( // 已经有了 counterCells, 向 cell 累加 (as = counterCells) != null || // 还没有, 向 baseCount 累加 !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x) ) { CounterCell a; long v; int m; boolean uncontended = true; if ( // 还没有 counterCells as == null || (m = as.length - 1) \u0026lt; 0 || // 还没有 cell (a = as[ThreadLocalRandom.getProbe() \u0026amp; m]) == null || // cell cas 增加计数失败 !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)) ) { // 创建累加单元数组和cell, 累加重试 fullAddCount(x, uncontended); return; } if (check \u0026lt;= 1) return; // 获取元素个数 s = sumCount(); } if (check \u0026gt;= 0) { Node\u0026lt;K,V\u0026gt;[] tab, nt; int n, sc; //扩容 while (s \u0026gt;= (long)(sc = sizeCtl) \u0026amp;\u0026amp; (tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026lt; MAXIMUM_CAPACITY) { int rs = resizeStamp(n); if (sc \u0026lt; 0) { if ((sc \u0026gt;\u0026gt;\u0026gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex \u0026lt;= 0) break; // newtable 已经创建了，帮忙扩容 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); } // 需要扩容，这时 newtable 未创建 else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs \u0026lt;\u0026lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); } } }  size 计算流程 size 计算实际发生在 put，remove 改变集合元素的操作之中\n 没有竞争发生，向 baseCount 累加计数 有竞争发生，新建 counterCells，向其中的一个 cell 累加计数\n counterCells 初始有两个 cell 如果计数竞争比较激烈，会创建新的 cell 来累加计数\npublic int size() { long n = sumCount(); return ((n \u0026lt; 0L) ? 0 : (n \u0026gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)n); } final long sumCount() { CounterCell[] as = counterCells; CounterCell a; // 将 baseCount 计数与所有 cell 计数累加 long sum = baseCount; if (as != null) { for (int i = 0; i \u0026lt; as.length; ++i) { if ((a = as[i]) != null) sum += a.value; } } return sum; }    Java 8\n数组（Node） +（ 链表 Node | 红黑树 TreeNode ） 以下数组简称（table），链表简称（bin）\n 初始化，使用 cas 来保证并发安全，懒惰初始化 table 树化，当 table.length \u0026lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length \u0026gt; 8 时，会将链表树化，树化过程 会用 synchronized 锁住链表头 put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素 添加至 bin 的尾部 get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新 table 进行搜索 扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可 做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1\u0026frasl;6 的节点会把复制到新 table 中 size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加 即可  源码分析 http://www.importnew.com/28263.html\n其它实现 Cliff Click\u0026rsquo;s high scale lib\n3. JDK 7 ConcurrentHashMap 它维护了一个 segment 数组，每个 segment 对应一把锁\n 优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 jdk8 中是类似的 缺点：Segments 数组默认大小为 16 ，这个容量初始化指定后就不能改变了，并且不是懒惰初始化\n 构造器分析\npublic ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { if (!(loadFactor \u0026gt; 0) || initialCapacity \u0026lt; 0 || concurrencyLevel \u0026lt;= 0) throw new IllegalArgumentException(); if (concurrencyLevel \u0026gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; // ssize 必须是 2^n, 即 2, 4, 8, 16 ... 表示了 segments 数组的大小 int sshift = 0; int ssize = 1; while (ssize \u0026lt; concurrencyLevel) { ++sshift; ssize \u0026lt;\u0026lt;= 1; } // segmentShift 默认是 32 - 4 = 28 this.segmentShift = 32 - sshift; // segmentMask 默认是 15 即 0000 0000 0000 1111 this.segmentMask = ssize - 1; if (initialCapacity \u0026gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; int c = initialCapacity / ssize; if (c * ssize \u0026lt; initialCapacity) ++c; int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap \u0026lt; c) cap \u0026lt;\u0026lt;= 1; // 创建 segments and segments[0] Segment\u0026lt;K,V\u0026gt; s0 = new Segment\u0026lt;K,V\u0026gt;(loadFactor, (int)(cap * loadFactor), (HashEntry\u0026lt;K,V\u0026gt;[])new HashEntry[cap]); Segment\u0026lt;K,V\u0026gt;[] ss = (Segment\u0026lt;K,V\u0026gt;[])new Segment[ssize]; UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss; }  构造完成，如下图所示\n可以看到 ConcurrentHashMap 没有实现懒惰初始化，空间占用不友好\n其中 this.segmentShift 和 this.segmentMask 的作用是决定将 key 的 hash 结果匹配到哪个 segment\n例如，根据某一 hash 值求 segment 位置，先将高位向低位移动 this.segmentShift 位\n结果再与 this.segmentMask 做位于运算，最终得到 1010 即下标为 10 的 segment\nput 流程\npublic V put(K key, V value) { Segment\u0026lt;K,V\u0026gt; s; if (value == null) throw new NullPointerException(); int hash = hash(key); // 计算出 segment 下标 int j = (hash \u0026gt;\u0026gt;\u0026gt; segmentShift) \u0026amp; segmentMask; // 获得 segment 对象, 判断是否为 null, 是则创建该 segment if ((s = (Segment\u0026lt;K,V\u0026gt;)UNSAFE.getObject (segments, (j \u0026lt;\u0026lt; SSHIFT) + SBASE)) == null) { // 这时不能确定是否真的为 null, 因为其它线程也发现该 segment 为 null, // 因此在 ensureSegment 里用 cas 方式保证该 segment 安全性 s = ensureSegment(j); } // 进入 segment 的put 流程 return s.put(key, hash, value, false); }  segment 继承了可重入锁（ReentrantLock），它的 put 方法为\nfinal V put(K key, int hash, V value, boolean onlyIfAbsent) { // 尝试加锁 HashEntry\u0026lt;K,V\u0026gt; node = tryLock() ? null : // 如果不成功, 进入 scanAndLockForPut 流程 // 如果是多核 cpu 最多 tryLock 64 次, 进入 lock 流程 // 在尝试期间, 还可以顺便看该节点在链表中有没有, 如果没有顺便创建出来 scanAndLockForPut(key, hash, value); // 执行到这里 segment 已经被成功加锁, 可以安全执行 V oldValue; try { HashEntry\u0026lt;K,V\u0026gt;[] tab = table; int index = (tab.length - 1) \u0026amp; hash; HashEntry\u0026lt;K,V\u0026gt; first = entryAt(tab, index); for (HashEntry\u0026lt;K,V\u0026gt; e = first;;) { if (e != null) { // 更新 K k; if ((k = e.key) == key || (e.hash == hash \u0026amp;\u0026amp; key.equals(k))) { oldValue = e.value; if (!onlyIfAbsent) { e.value = value; ++modCount; } break; } e = e.next; } else { // 新增 // 1) 之前等待锁时, node 已经被创建, next 指向链表头 if (node != null) node.setNext(first); else // 2) 创建新 node node = new HashEntry\u0026lt;K,V\u0026gt;(hash, key, value, first); int c = count + 1; // 3) 扩容 if (c \u0026gt; threshold \u0026amp;\u0026amp; tab.length \u0026lt; MAXIMUM_CAPACITY) rehash(node); else // 将 node 作为链表头 setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; } } } finally { unlock(); } return oldValue; }  rehash 流程\n发生在 put 中，因为此时已经获得了锁，因此 rehash 时不需要考虑线程安全\nprivate void rehash(HashEntry\u0026lt;K,V\u0026gt; node) { HashEntry\u0026lt;K,V\u0026gt;[] oldTable = table; int oldCapacity = oldTable.length; int newCapacity = oldCapacity \u0026lt;\u0026lt; 1; threshold = (int)(newCapacity * loadFactor); HashEntry\u0026lt;K,V\u0026gt;[] newTable = (HashEntry\u0026lt;K,V\u0026gt;[]) new HashEntry[newCapacity]; int sizeMask = newCapacity - 1; for (int i = 0; i \u0026lt; oldCapacity ; i++) { HashEntry\u0026lt;K,V\u0026gt; e = oldTable[i]; if (e != null) { HashEntry\u0026lt;K,V\u0026gt; next = e.next; int idx = e.hash \u0026amp; sizeMask; if (next == null) // Single node on list newTable[idx] = e; else { // Reuse consecutive sequence at same slot HashEntry\u0026lt;K,V\u0026gt; lastRun = e;int lastIdx = idx; // 过一遍链表, 尽可能把 rehash 后 idx 不变的节点重用 for (HashEntry\u0026lt;K,V\u0026gt; last = next; last != null; last = last.next) { int k = last.hash \u0026amp; sizeMask; if (k != lastIdx) { lastIdx = k; lastRun = last; } } newTable[lastIdx] = lastRun; // 剩余节点需要新建 for (HashEntry\u0026lt;K,V\u0026gt; p = e; p != lastRun; p = p.next) { V v = p.value; int h = p.hash; int k = h \u0026amp; sizeMask; HashEntry\u0026lt;K,V\u0026gt; n = newTable[k]; newTable[k] = new HashEntry\u0026lt;K,V\u0026gt;(h, p.key, v, n); } } } } // 扩容完成, 才加入新的节点 int nodeIndex = node.hash \u0026amp; sizeMask; // add the new node node.setNext(newTable[nodeIndex]); newTable[nodeIndex] = node; // 替换为新的 HashEntry table table = newTable; }  附，调试代码\npublic static void main(String[] args) { ConcurrentHashMap\u0026lt;Integer, String\u0026gt; map = new ConcurrentHashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 1000; i++) { int hash = hash(i); int segmentIndex = (hash \u0026gt;\u0026gt;\u0026gt; 28) \u0026amp; 15; if (segmentIndex == 4 \u0026amp;\u0026amp; hash % 8 == 2) { System.out.println(i + \u0026quot;\\t\u0026quot; + segmentIndex + \u0026quot;\\t\u0026quot; + hash % 2 + \u0026quot;\\t\u0026quot; + hash % 4 + \u0026quot;\\t\u0026quot; + hash % 8); } } map.put(1, \u0026quot;value\u0026quot;); map.put(15, \u0026quot;value\u0026quot;); // 2 扩容为 4 15 的 hash%8 与其他不同 map.put(169, \u0026quot;value\u0026quot;); map.put(197, \u0026quot;value\u0026quot;); // 4 扩容为 8 map.put(341, \u0026quot;value\u0026quot;); map.put(484, \u0026quot;value\u0026quot;); map.put(545, \u0026quot;value\u0026quot;); // 8 扩容为 16 map.put(912, \u0026quot;value\u0026quot;);map.put(941, \u0026quot;value\u0026quot;); System.out.println(\u0026quot;ok\u0026quot;); } private static int hash(Object k) { int h = 0; if ((0 != h) \u0026amp;\u0026amp; (k instanceof String)) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); // Spread bits to regularize both segment and index locations, // using variant of single-word Wang/Jenkins hash. h += (h \u0026lt;\u0026lt; 15) ^ 0xffffcd7d; h ^= (h \u0026gt;\u0026gt;\u0026gt; 10); h += (h \u0026lt;\u0026lt; 3); h ^= (h \u0026gt;\u0026gt;\u0026gt; 6); h += (h \u0026lt;\u0026lt; 2) + (h \u0026lt;\u0026lt; 14); int v = h ^ (h \u0026gt;\u0026gt;\u0026gt; 16); return v; }  get 流程\nget 时并未加锁，用了 UNSAFE 方法保证了可见性，扩容过程中，get 先发生就从旧表取内容，get 后发生就从新 表取内容\npublic V get(Object key) { Segment\u0026lt;K,V\u0026gt; s; // manually integrate access methods to reduce overhead HashEntry\u0026lt;K,V\u0026gt;[] tab; int h = hash(key); // u 为 segment 对象在数组中的偏移量 long u = (((h \u0026gt;\u0026gt;\u0026gt; segmentShift) \u0026amp; segmentMask) \u0026lt;\u0026lt; SSHIFT) + SBASE; // s 即为 segment if ((s = (Segment\u0026lt;K,V\u0026gt;)UNSAFE.getObjectVolatile(segments, u)) != null \u0026amp;\u0026amp; (tab = s.table) != null) { for (HashEntry\u0026lt;K,V\u0026gt; e = (HashEntry\u0026lt;K,V\u0026gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) \u0026amp; h)) \u0026lt;\u0026lt; TSHIFT) + TBASE); e != null; e = e.next) { K k; if ((k = e.key) == key || (e.hash == h \u0026amp;\u0026amp; key.equals(k))) return e.value; } } return null; }  size 计算流程\n 计算元素个数前，先不加锁计算两次，如果前后两次结果如一样，认为个数正确返回\n 如果不一样，进行重试，重试次数超过 3 ，将所有 segment 锁住，重新计算个数返回\npublic int size() { // Try a few times to get accurate count. On failure due to // continuous async changes in table, resort to locking. final Segment\u0026lt;K,V\u0026gt;[] segments = this.segments; int size; boolean overflow; // true if size overflows 32 bits long sum; // sum of modCounts long last = 0L; // previous sum int retries = -1; // first iteration isn't retry try { for (;;) { if (retries++ == RETRIES_BEFORE_LOCK) { // 超过重试次数, 需要创建所有 segment 并加锁 for (int j = 0; j \u0026lt; segments.length; ++j) ensureSegment(j).lock(); // force creation } sum = 0L; size = 0; overflow = false; for (int j = 0; j \u0026lt; segments.length; ++j) { Segment\u0026lt;K,V\u0026gt; seg = segmentAt(segments, j); if (seg != null) { sum += seg.modCount; int c = seg.count; if (c \u0026lt; 0 || (size += c) \u0026lt; 0) overflow = true; } } if (sum == last) break; last = sum; } } finally { if (retries \u0026gt; RETRIES_BEFORE_LOCK) { for (int j = 0; j \u0026lt; segments.length; ++j) segmentAt(segments, j).unlock(); } } return overflow ? Integer.MAX_VALUE : size; }   LinkedBlockingQueue 原理 1. 基本的入队出队 public class LinkedBlockingQueue\u0026lt;E\u0026gt; extends AbstractQueue\u0026lt;E\u0026gt; implements BlockingQueue\u0026lt;E\u0026gt;, java.io.Serializable { static class Node\u0026lt;E\u0026gt; {E item; /** * 下列三种情况之一 * - 真正的后继节点 * - 自己, 发生在出队时 * - null, 表示是没有后继节点, 是最后了 */ Node\u0026lt;E\u0026gt; next; Node(E x) { item = x; } } }  初始化链表 last = head = new Node(null); Dummy 节点用来占位，item 为 null\n当一个节点入队 last = last.next = node;\n再来一个节点入队 last = last.next = node;\n出队 Node\u0026lt;E\u0026gt; h = head; Node\u0026lt;E\u0026gt; first = h.next; h.next = h; // help GC head = first; E x = first.item; first.item = null; return x;  h = head\nfirst = h.next\nh.next = h\nhead = first\nE x = first.item; first.item = null; return x;  2. 加锁分析 ==高明之处==在于用了两把锁和 dummy 节点\n 用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行 用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行  消费者与消费者线程仍然串行 生产者与生产者线程仍然串行   线程安全分析\n 当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全。两把锁保证了入队和出队没有竞争 当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争 当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞\n// 用于 put(阻塞) offer(非阻塞) private final ReentrantLock putLock = new ReentrantLock(); // 用户 take(阻塞) poll(非阻塞) private final ReentrantLock takeLock = new ReentrantLock();   put 操作\npublic void put(E e) throws InterruptedException {if (e == null) throw new NullPointerException(); int c = -1; Node\u0026lt;E\u0026gt; node = new Node\u0026lt;E\u0026gt;(e); final ReentrantLock putLock = this.putLock; // count 用来维护元素计数 final AtomicInteger count = this.count; putLock.lockInterruptibly(); try { // 满了等待 while (count.get() == capacity) { // 倒过来读就好: 等待 notFull notFull.await(); } // 有空位, 入队且计数加一 enqueue(node); c = count.getAndIncrement(); // 除了自己 put 以外, 队列还有空位, 由自己叫醒其他 put 线程 if (c + 1 \u0026lt; capacity) notFull.signal(); } finally { putLock.unlock(); } // 如果队列中有一个元素, 叫醒 take 线程 if (c == 0) // 这里调用的是 notEmpty.signal() 而不是 notEmpty.signalAll() 是为了减少竞争 signalNotEmpty(); }  take 操作\npublic E take() throws InterruptedException { E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try { while (count.get() == 0) { notEmpty.await(); } x = dequeue(); c = count.getAndDecrement(); if (c \u0026gt; 1) notEmpty.signal(); } finally { takeLock.unlock(); } // 如果队列中只有一个空位时, 叫醒 put 线程 // 如果有多个线程进行出队, 第一个线程满足 c == capacity, 但后续线程 c \u0026lt; capacity if (c == capacity) // 这里调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争 signalNotFull() return x; }  3. 性能比较 主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较\n  Linked 支持有界，Array 强制有界 Linked 实现是链表，Array 实现是数组 Linked 是懒惰的，而 Array 需要提前初始化 Node 数组 Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的 Linked 两把锁，Array 一把锁   ConcurrentLinkedQueue 原理 1. 模仿 ConcurrentLinkedQueue 初始代码 package cn.itcast.concurrent.thirdpart.test; import java.util.Collection; import java.util.Iterator; import java.util.Queue; import java.util.concurrent.atomic.AtomicReference; public class Test3 { public static void main(String[] args) { MyQueue\u0026lt;String\u0026gt; queue = new MyQueue\u0026lt;\u0026gt;(); queue.offer(\u0026quot;1\u0026quot;); queue.offer(\u0026quot;2\u0026quot;); queue.offer(\u0026quot;3\u0026quot;); System.out.println(queue); } } class MyQueue\u0026lt;E\u0026gt; implements Queue\u0026lt;E\u0026gt; { @Override public String toString() { StringBuilder sb = new StringBuilder(); for (Node\u0026lt;E\u0026gt; p = head; p != null; p = p.next.get()) { E item = p.item; if (item != null) { sb.append(item).append(\u0026quot;-\u0026gt;\u0026quot;); } } sb.append(\u0026quot;null\u0026quot;); return sb.toString(); } @Override public int size() { return 0; } @Override public boolean isEmpty() { return false; } @Override public boolean contains(Object o) { return false; } @Override public Iterator\u0026lt;E\u0026gt; iterator() { return null; } @Override public Object[] toArray() { return new Object[0]; } @Override public \u0026lt;T\u0026gt; T[] toArray(T[] a) { return null; } @Override public boolean add(E e) { return false; } @Override public boolean remove(Object o) { return false; } @Override public boolean containsAll(Collection\u0026lt;?\u0026gt; c) { return false; } @Override public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { return false; } @Override public boolean removeAll(Collection\u0026lt;?\u0026gt; c) { return false; } @Override public boolean retainAll(Collection\u0026lt;?\u0026gt; c) { return false; } @Override public void clear() { } @Override public E remove() { return null; } @Override public E element() { return null; } @Override public E peek() { return null; } public MyQueue() { head = last = new Node\u0026lt;\u0026gt;(null, null); } private volatile Node\u0026lt;E\u0026gt; last; private volatile Node\u0026lt;E\u0026gt; head; private E dequeue() {/*Node\u0026lt;E\u0026gt; h = head; Node\u0026lt;E\u0026gt; first = h.next; h.next = h; head = first; E x = first.item; first.item = null; return x;*/ return null; } @Override public E poll() { return null; } @Override public boolean offer(E e) { return true; } static class Node\u0026lt;E\u0026gt; { volatile E item; public Node(E item, Node\u0026lt;E\u0026gt; next) { this.item = item; this.next = new AtomicReference\u0026lt;\u0026gt;(next); } AtomicReference\u0026lt;Node\u0026lt;E\u0026gt;\u0026gt; next; } }  offer\npublic boolean offer(E e) { Node\u0026lt;E\u0026gt; n = new Node\u0026lt;\u0026gt;(e, null); while(true) { // 获取尾节点 AtomicReference\u0026lt;Node\u0026lt;E\u0026gt;\u0026gt; next = last.next; // S1: 真正尾节点的 next 是 null, cas 从 null 到新节点 if(next.compareAndSet(null, n)) { // 这时的 last 已经是倒数第二, next 不为空了, 其它线程的 cas 肯定失败 // S2: 更新 last 为倒数第一的节点 last = n; return true; } } }  ","id":9,"section":"posts","summary":"原理篇 指令级并行原理 1. 名词 Clock Cycle Time 主频的概念大家接触的比较多，而 CPU 的 Clock Cycle Time（时钟周期时间），等于主频的倒数，意思是 CPU 能 够识别的最小时间单","tags":["Java","Java并发编程"],"title":"Java并发编程原理篇","uri":"https://mumulx.github.io/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86%E7%AF%87/","year":"2020"},{"content":" 应用篇 效率 1.使用多线程充分利用 CPU 1)环境搭建\n 基准测试工具选择，使用了比较靠谱的 JMH，它会执行程序预热，执行多次测试并平均\n cpu 核数限制，有两种思路\n 使用虚拟机，分配合适的核\n 使用 msconfig，分配合适的核，需要重启比较麻烦\n  并行计算方式的选择\n 最初想直接使用 parallel stream，后来发现它有自己的问题\n 改为了自己手动控制 thread，实现简单的并行计算\n  ​\n测试代码如下\nmvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jmh - DarchetypeArtifactId=jmh-java-benchmark-archetype -DgroupId=org.sample -DartifactId=test - Dversion= 1.0  代码\npackage org.sample; import java.util.Arrays; import java.util.concurrent.FutureTask; import org.openjdk.jmh.annotations.Benchmark; import org.openjdk.jmh.annotations.BenchmarkMode; import org.openjdk.jmh.annotations.Fork; import org.openjdk.jmh.annotations.Measurement; import org.openjdk.jmh.annotations.Mode; import org.openjdk.jmh.annotations.Warmup; @Fork( 1 ) @BenchmarkMode(Mode.AverageTime) @Warmup(iterations= 3 ) @Measurement(iterations= 5 ) public class MyBenchmark { static int[] ARRAY = new int[1000_000_00];//对一亿个数字进行求和 static { Arrays.fill(ARRAY, 1 ); } @Benchmark public int c() throws Exception { int[] array = ARRAY; FutureTask\u0026lt;Integer\u0026gt; t1 = new FutureTask\u0026lt;\u0026gt;(()-\u0026gt;{ int sum = 0; for(int i = 0; i \u0026lt; 250_000_00;i++) { sum += array[0+i]; } return sum; }); FutureTask\u0026lt;Integer\u0026gt; t2 = new FutureTask\u0026lt;\u0026gt;(()-\u0026gt;{ int sum = 0; for(int i = 0; i \u0026lt; 250_000_00;i++) { sum += array[250_000_00+i]; } return sum; }); FutureTask\u0026lt;Integer\u0026gt; t3 = new FutureTask\u0026lt;\u0026gt;(()-\u0026gt;{ int sum = 0; for(int i = 0; i \u0026lt; 250_000_00;i++) { sum += array[500_000_00+i]; } return sum; }); FutureTask\u0026lt;Integer\u0026gt; t4 = new FutureTask\u0026lt;\u0026gt;(()-\u0026gt;{ int sum = 0; for(int i = 0; i \u0026lt; 250_000_00;i++) { sum += array[750_000_00+i]; } return sum; }); new Thread(t1).start(); new Thread(t2).start(); new Thread(t3).start(); new Thread(t4).start(); return t1.get() + t2.get() + t3.get()+ t4.get(); } @Benchmark public int d() throws Exception { int[] array = ARRAY; FutureTask\u0026lt;Integer\u0026gt; t1 = new FutureTask\u0026lt;\u0026gt;(()-\u0026gt;{ int sum = 0; for(int i = 0; i \u0026lt; 1000_000_00;i++) { sum += array[0+i]; } return sum; }); new Thread(t1).start(); return t1.get(); } }  2) 双核 CPU（ 4 个逻辑CPU） C:\\Users\\lenovo\\eclipse-workspace\\test\u0026gt;java -jar target/benchmarks.jar # VM invoker: C:\\Program Files\\Java\\jdk-11\\bin\\java.exe # VM options: \u0026lt;none\u0026gt; # Warmup: 3 iterations, 1 s each # Measurement: 5 iterations, 1 s each # Threads: 1 thread, will synchronize iterations # Benchmark mode: Average time, time/op # Benchmark: org.sample.MyBenchmark.c # Run progress: 0.00% complete, ETA 00:00:16 # Fork: 1 of 1 # Warmup Iteration 1: 0.022 s/op # Warmup Iteration 2: 0.019 s/op # Warmup Iteration 3: 0.020 s/op Iteration 1: 0.020 s/op Iteration 2: 0.020 s/op Iteration 3: 0.020 s/op Iteration 4: 0.020 s/op Iteration 5: 0.020 s/op Result: 0.020 ±(99.9%) 0.001 s/op [Average] Statistics: (min, avg, max) = (0.020, 0.020, 0.020), stdev = 0.000 Confidence interval (99.9%): [0.019, 0.021] # VM invoker: C:\\Program Files\\Java\\jdk-11\\bin\\java.exe # VM options: \u0026lt;none\u0026gt; # Warmup: 3 iterations, 1 s each # Measurement: 5 iterations, 1 s each # Threads: 1 thread, will synchronize iterations # Benchmark mode: Average time, time/op # Benchmark: org.sample.MyBenchmark.d # Run progress: 50.00% complete, ETA 00:00:10 # Fork: 1 of 1 # Warmup Iteration 1: 0.042 s/op # Warmup Iteration 2: 0.042 s/op # Warmup Iteration 3: 0.041 s/op Iteration 1: 0.043 s/op Iteration 2: 0.042 s/op Iteration 3: 0.042 s/op Iteration 4: 0.044 s/op Iteration 5: 0.042 s/op Result: 0.043 ±(99.9%) 0.003 s/op [Average] Statistics: (min, avg, max) = (0.042, 0.043, 0.044), stdev = 0.001 Confidence interval (99.9%): [0.040, 0.045] # Run complete. Total time: 00:00:20 Benchmark Mode Samples Score Score error Units o.s.MyBenchmark.c avgt 5 0.020 0.001 s/op o.s.MyBenchmark.d avgt 5 0.043 0.003 s/op  可以看到多核下，效率提升还是很明显的，快了一倍左右\n3) 单核 CPU Benchmark Mode Samples Score Score error Units o.s.MyBenchmark.c avgt 5 0 .020 0 .001 s/op o.s.MyBenchmark.d avgt 5 0 .043 0 .003 s/op C:\\Users\\lenovo\\eclipse-workspace\\test\u0026gt;java -jar target/benchmarks.jar # VM invoker: C:\\Program Files\\Java\\jdk-11\\bin\\java.exe # VM options: \u0026lt;none\u0026gt; # Warmup: 3 iterations, 1 s each # Measurement: 5 iterations, 1 s each # Threads: 1 thread, will synchronize iterations # Benchmark mode: Average time, time/op # Benchmark: org.sample.MyBenchmark.c # Run progress: 0.00% complete, ETA 00:00: # Fork: 1 of 1 # Warmup Iteration 1: 0.064 s/op # Warmup Iteration 2: 0.052 s/op # Warmup Iteration 3: 1.127 s/op Iteration 1 : 0 .053 s/op Iteration 2 : 0 .052 s/op Iteration 3 : 0 .053 s/op Iteration 4 : 0 .057 s/op Iteration 5 : 0 .088 s/op Result: 0 .061 ±(99.9%) 0 .060 s/op [Average] Statistics: (min, avg, max) = (0.052, 0 .061, 0 .088), stdev = 0. Confidence interval (99.9%): [0.001, 0 .121] # VM invoker: C:\\Program Files\\Java\\jdk-11\\bin\\java.exe # VM options: \u0026lt;none\u0026gt; # Warmup: 3 iterations, 1 s each # Measurement: 5 iterations, 1 s each # Threads: 1 thread, will synchronize iterations # Benchmark mode: Average time, time/op # Benchmark: org.sample.MyBenchmark.d # Run progress: 50.00% complete, ETA 00:00: # Fork: 1 of 1 # Warmup Iteration 1: 0.054 s/op # Warmup Iteration 2: 0.053 s/op # Warmup Iteration 3: 0.051 s/op Iteration 1 : 0 .096 s/op Iteration 2 : 0 .054 s/op Iteration 3 : 0 .065 s/op Iteration 4 : 0 .050 s/op Iteration 5: 0.055 s/op Result: 0.064 ±(99.9%) 0.071 s/op [Average] Statistics: (min, avg, max) = (0.050, 0.064, 0.096), stdev = 0.018 Confidence interval (99.9%): [-0.007, 0.135] # Run complete. Total time: 00:00:22 Benchmark Mode Samples Score Score error Units o.s.MyBenchmark.c avgt 5 0.061 0.060 s/op o.s.MyBenchmark.d avgt 5 0.064 0.071 s/op  性能几乎是一样的\n限制 1. 限制对 CPU 的使用 sleep 实现\n在没有利用 cpu 来计算时，不要让 while(true) 空转浪费 cpu，这时可以使用 yield 或 sleep 来让出 cpu 的使用权 给其他程序\nwhile(true) { try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } }   可以用 wait 或 条件变量达到类似的效果 不同的是，后两种都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景 sleep 适用于无需锁同步的场景  wait 实现\nsynchronized(锁对象) { while(条件不满足) { try { 锁对象.wait(); } catch(InterruptedException e) { e.printStackTrace(); } } // do sth... }  条件变量实现\nlock.lock(); try { while(条件不满足) { try { 条件变量.await(); } catch (InterruptedException e) { e.printStackTrace(); } } // do sth... } finally { lock.unlock(); }  2. 限制对共享资源的使用 semaphore 实现\n 使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机 线程数量，并且仅是限制线程数，而不是限制资源数（例如连接数，请对比 Tomcat LimitLatch 的实现） 用 Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好， 注意下面的实现中线程数和数据库连接数是相等的\n@Slf4j(topic = \u0026quot;c.Pool\u0026quot;) class Pool { // 1. 连接池大小 private final int poolSize; // 2. 连接对象数组 private Connection[] connections; // 3. 连接状态数组 0 表示空闲， 1 表示繁忙 private AtomicIntegerArray states; private Semaphore semaphore; // 4. 构造方法初始化 public Pool(int poolSize) { this.poolSize = poolSize; // 让许可数与资源数一致 this.semaphore = new Semaphore(poolSize); this.connections = new Connection[poolSize]; this.states = new AtomicIntegerArray(new int[poolSize]); for (int i = 0; i \u0026lt; poolSize; i++) { connections[i] = new MockConnection(\u0026quot;连接\u0026quot; + (i+1)); } } // 5. 借连接 public Connection borrow() {// t1, t2, t3 // 获取许可 try { semaphore.acquire(); // 没有许可的线程，在此等待 } catch (InterruptedException e) { e.printStackTrace(); } for (int i = 0; i \u0026lt; poolSize; i++) { // 获取空闲连接 if(states.get(i) == 0) { if (states.compareAndSet(i, 0, 1)) { log.debug(\u0026quot;borrow {}\u0026quot;, connections[i]); return connections[i]; } } } // 不会执行到这里 return null; } // 6. 归还连接 public void free(Connection conn) { for (int i = 0; i \u0026lt; poolSize; i++) { if (connections[i] == conn) { states.set(i, 0); log.debug(\u0026quot;free {}\u0026quot;, conn); semaphore.release(); break; } } } }   3. 单位时间内限流 guava 实现\n@RestController public class TestController { private RateLimiter limiter = RateLimiter.create(50); @GetMapping(\u0026quot;/test\u0026quot;) public String test() { // limiter.acquire(); return \u0026quot;ok\u0026quot;; } }  没有限流之前\nab -c 10 -t 10 http://localhost:8080/test  结果\nThis is ApacheBench, Version 2.3 \u0026lt;$Revision: 1843412 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking localhost (be patient) Completed 5000 requests Completed 10000 requests Completed 15000 requests Completed 20000 requests Finished 24706 requests Server Software: Server Hostname: localhost Server Port: 8080 Document Path: /test Document Length: 2 bytes Concurrency Level: 10 Time taken for tests: 10.005 seconds Complete requests: 24706 Failed requests: 0 Total transferred: 3311006 bytes HTML transferred: 49418 bytes Requests per second: 2469.42 [#/sec] (mean) Time per request: 4.050 [ms] (mean) Time per request: 0.405 [ms] (mean, across all concurrent requests) Transfer rate: 323.19 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 1.4 0 16 Processing: 0 4 7.6 0 323 Waiting: 0 3 6.9 0 323 Total: 0 4 7.6 0 323 Percentage of the requests served within a certain time (ms) 50% 0 66% 2 75% 8 80% 8 90% 10 95% 16 98% 16 99% 16 100% 323 (longest request)  限流之后\nThis is ApacheBench, Version 2.3 \u0026lt;$Revision: 1843412 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking localhost (be patient) Finished 545 requests Server Software: Server Hostname: localhost Server Port: 8080 Document Path: /test Document Length: 2 bytes Concurrency Level: 10 Time taken for tests: 10.007 seconds Complete requests: 545 Failed requests: 0 Total transferred: 73030 bytes HTML transferred: 1090 bytes Requests per second: 54.46 [#/sec] (mean) Time per request: 183.621 [ms] (mean) Time per request: 18.362 [ms] (mean, across all concurrent requests) Transfer rate: 7.13 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 1.1 0 16 Processing: 0 179 57.0 199 211 Waiting: 0 178 57.6 198 211 Total: 0 179 56.9 199 211 Percentage of the requests served within a certain time (ms) 50% 199 66% 200 75% 200 80% 200 90% 201 95% 201 98% 202 99% 203 100% 211 (longest request)  互斥 1. 悲观互斥 互斥实际是悲观锁的思想\n例如，有下面取款的需求\ninterface Account { // 获取余额 Integer getBalance(); // 取款 void withdraw(Integer amount); /** * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作 * 如果初始余额为 10000 那么正确的结果应当是 0 */ static void demo(Account account) { List\u0026lt;Thread\u0026gt; ts = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 1000; i++) { ts.add(new Thread(() -\u0026gt; { account.withdraw(10); })); } long start = System.nanoTime(); ts.forEach(Thread::start); ts.forEach(t -\u0026gt; { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); long end = System.nanoTime(); System.out.println(account.getBalance() + \u0026quot; cost: \u0026quot; + (end-start)/1000_000 + \u0026quot; ms\u0026quot;); } }  用互斥来保护\nclass AccountSync implements Account { private Integer balance; public AccountUnsafe(Integer balance) { this.balance = balance; } @Override public Integer getBalance() { synchronized (this) { return this.balance; } } @Override public void withdraw(Integer amount) { synchronized (this) { this.balance -= amount; } } }  2. 乐观重试 另外一种是乐观锁思想，它其实不是互斥\nclass AccountCas implements Account { private AtomicInteger balance; public AccountCas(int balance) { this.balance = new AtomicInteger(balance); } @Override public Integer getBalance() { return balance.get(); } @Override public void withdraw(Integer amount) { while(true) { // 获取余额的最新值 int prev = balance.get(); // 要修改的余额 int next = prev - amount; // 真正修改 if(balance.compareAndSet(prev, next)) { break; } } } }  同步和异步 1. 需要等待结果 这时既可以使用同步处理，也可以使用异步来处理\n1.join 实现（同步） static int result = 0; private static void test1() throws InterruptedException { log.debug(\u0026quot;开始\u0026quot;); Thread t1 = new Thread(() -\u0026gt; { log.debug(\u0026quot;开始\u0026quot;); sleep(1); log.debug(\u0026quot;结束\u0026quot;); result = 10; }, \u0026quot;t1\u0026quot;); t1.start(); t1.join(); log.debug(\u0026quot;结果为:{}\u0026quot;, result); }  评价\n 需要外部共享变量，不符合面向对象封装的思想\n必须等待线程结束，不能配合线程池使用\n 2.Future 实现（同步） private static void test2() throws InterruptedException, ExecutionException { log.debug(\u0026quot;开始\u0026quot;); FutureTask\u0026lt;Integer\u0026gt; result = new FutureTask\u0026lt;\u0026gt;(() -\u0026gt; { log.debug(\u0026quot;开始\u0026quot;); sleep(1); log.debug(\u0026quot;结束\u0026quot;); return 10; }); new Thread(result, \u0026quot;t1\u0026quot;).start(); log.debug(\u0026quot;结果为:{}\u0026quot;, result.get()); }  评价\n \u0026gt; 规避了使用 join 之前的缺点 \u0026gt; 可以方便配合线程池使用 \u0026gt; ``` \u0026gt;  java private static void test3() throws InterruptedException, ExecutionException { ExecutorService service = Executors.newFixedThreadPool(1); log.debug(\u0026ldquo;开始\u0026rdquo;); Future result = service.submit(() -\u0026gt; { log.debug(\u0026ldquo;开始\u0026rdquo;); sleep(1); log.debug(\u0026ldquo;结束\u0026rdquo;); return 10; }); log.debug(\u0026ldquo;结果为:{}, result 的类型:{}\u0026ldquo;, result.get(), result.getClass()); service.shutdown(); }\n 评价 * 仍然是 main 线程接收结果 * get 方法是让调用线程同步等 ### 3. 自定义实现（同步） 见模式篇：保护性暂停模式 #### CompletableFuture 实现（异步）  java private static void test4() { // 进行计算的线程池 ExecutorService computeService = Executors.newFixedThreadPool(1); // 接收结果的线程池 ExecutorService resultService = Executors.newFixedThreadPool(1); log.debug(\u0026ldquo;开始\u0026rdquo;); CompletableFuture.supplyAsync(() -\u0026gt; { log.debug(\u0026ldquo;开始\u0026rdquo;); sleep(1); log.debug(\u0026ldquo;结束\u0026rdquo;); return 10; }, computeService).thenAcceptAsync((result) -\u0026gt; { log.debug(\u0026ldquo;结果为:{}\u0026ldquo;, result); }, resultService); }\n 输出  10:36:28.114 c.TestSync [main] - 开始 10:36:28.164 c.TestSync [pool-1-thread-1] - 开始 10:36:29.165 c.TestSync [pool-1-thread-1] - 结束 10:36:29.165 c.TestSync [pool-2-thread-1] - 结果为:10\n 评价 * 可以让调用线程异步处理结果，实际是其他线程去同步等待 * 可以方便地分离不同职责的线程池 * 以任务为中心，而不是以线程为中心 **BlockingQueue 实现（异步）**  java private static void test6() { ExecutorService consumer = Executors.newFixedThreadPool(1); ExecutorService producer = Executors.newFixedThreadPool(1); BlockingQueue queue = new SynchronousQueue\u0026lt;\u0026gt;(); log.debug(\u0026ldquo;开始\u0026rdquo;); producer.submit(() -\u0026gt; { log.debug(\u0026ldquo;开始\u0026rdquo;); sleep(1); log.debug(\u0026ldquo;结束\u0026rdquo;); try { queue.put(10); } catch (InterruptedException e) { e.printStackTrace(); } }); consumer.submit(() -\u0026gt; { try { Integer result = queue.take(); log.debug(\u0026ldquo;结果为:{}\u0026ldquo;, result); } catch (InterruptedException e) { e.printStackTrace(); } }); }\n ### 2. 不需等待结果 这时最好是使用异步来处理 ### 1. 普通线程实现  java @Slf4j(topic = \u0026ldquo;c.FileReader\u0026rdquo;) public class FileReader { public static void read(String filename) { int idx = filename.lastIndexOf(File.separator); String shortName = filename.substring(idx + 1); try (FileInputStream in = new FileInputStream(filename)) { long start = System.currentTimeMillis(); log.debug(\u0026ldquo;read [{}] start \u0026hellip;\u0026ldquo;, shortName); byte[] buf = new byte[1024]; int n = -1; do { n = in.read(buf); } while (n != -1); long end = System.currentTimeMillis(); log.debug(\u0026ldquo;read [{}] end \u0026hellip; cost: {} ms\u0026rdquo;, shortName, end - start); } catch (IOException e) { e.printStackTrace(); } } }\n 没有用线程时，方法的调用是同步的：  java @Slf4j(topic = \u0026ldquo;c.Sync\u0026rdquo;) public class Sync { public static void main(String[] args) { String fullPath = \u0026ldquo;E:\\1.mp4\u0026rdquo;; FileReader.read(fullPath); log.debug(\u0026ldquo;do other things \u0026hellip;\u0026rdquo;); } }\n 输出  18:39:15 [main] c.FileReader - read [1.mp4] start \u0026hellip; 18:39:19 [main] c.FileReader - read [1.mp4] end \u0026hellip; cost: 4090 ms 18:39:19 [main] c.Sync - do other things \u0026hellip;\n 使用了线程后，方法的调用时异步的： 输出  18:39:15 [main] c.FileReader - read [1.mp4] start \u0026hellip; 18:39:19 [main] c.FileReader - read [1.mp4] end \u0026hellip; cost: 4090 ms 18:39:19 [main] c.Sync - do other things \u0026hellip;\n 使用了线程后，方法的调用时异步的：  java private static void test1() { new Thread(() -\u0026gt; FileReader.read(Constants.MP4_FULL_PATH)).start(); log.debug(\u0026ldquo;do other things \u0026hellip;\u0026rdquo;); }\n 输出  18:41:53 [main] c.Async - do other things \u0026hellip; 18:41:53 [Thread-0] c.FileReader - read [1.mp4] start \u0026hellip; 18:41:57 [Thread-0] c.FileReader - read [1.mp4] end \u0026hellip; cost: 4197 ms\n ### 2. 线程池实现  java private static void test2() { ExecutorService service = Executors.newFixedThreadPool(1); service.execute(() -\u0026gt; FileReader.read(Constants.MP4_FULL_PATH)); log.debug(\u0026ldquo;do other things \u0026hellip;\u0026rdquo;); service.shutdown(); }\n 输出  11:03:31.245 c.TestAsyc [main] - do other things \u0026hellip; 11:03:31.245 c.FileReader [pool-1-thread-1] - read [1.mp4] start \u0026hellip; 11:03:33.479 c.FileReader [pool-1-thread-1] - read [1.mp4] end \u0026hellip; cost: 2235 ms\n ## 缓存 ### 1. 缓存更新策略 更新时，是先清缓存还是先更新数据库 先清缓存  mermaid sequenceDiagram participant B participant A participant 缓存 participant 数据库 B-\u0026gt;\u0026gt;缓存:1)清空缓存 A-\u0026gt;\u0026gt;数据库:2)查询数据库(x=1) A-\u0026gt;\u0026gt;缓存:3)将查询结果放入缓存(x=1) B-\u0026gt;\u0026gt;数据库:4)将新数据存入库(x=2) A-\u0026gt;\u0026gt;缓存:5)后续查询将一直是旧值(x=1)!\n 先更新数据库  mermaid sequenceDiagram participant B participant A participant 缓存 participant 数据库 B-\u0026gt;\u0026gt;数据库:1)将新数据存入库(x=2) A-\u0026gt;\u0026gt;缓存:2)查询缓存(x=1)！！ B-\u0026gt;\u0026gt;缓存:3)清空缓存(x=1) A-\u0026gt;\u0026gt;数据库:4)查询数据库(x=2) A-\u0026gt;\u0026gt;缓存:5)后续查询将一直是旧值(x=2)\n  java private static void test3() throws IOException { CompletableFuture.runAsync(() -\u0026gt; FileReader.read(Constants.MP4_FULL_PATH)); log.debug(\u0026ldquo;do other things \u0026hellip;\u0026rdquo;); System.in.read(); }\n 补充一种情况，假设查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询  mermaid sequenceDiagram participant B participant A participant 缓存 participant 数据库 A-\u0026gt;\u0026gt;数据库:1)缓存没有，查询数据库（x=1） B-\u0026gt;\u0026gt;数据库:2)将新数据村入库(x=2) B-\u0026gt;\u0026gt;缓存:3)清空缓存 A-\u0026gt;\u0026gt;缓存:4)将查询结果放入缓存(x=1) A-\u0026gt;\u0026gt;缓存:5)后续查询将一直是旧值(x=1)!!\n 这种情况的出现几率非常小，见 facebook 论文 ### 2. 读写锁实现一致性缓存 使用读写锁实现一个简单的按需加载缓存  java class GenericCachedDao { // HashMap 作为缓存非线程安全, 需要保护 HashMapmap = new HashMap\u0026lt;\u0026gt;(); ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); GenericDao genericDao = new GenericDao(); public int update(String sql, Object\u0026hellip; params) { SqlPair key = new SqlPair(sql, params); // 加写锁, 防止其它线程对缓存读取和更改 lock.writeLock().lock(); try { int rows = genericDao.update(sql, params); map.clear(); return rows; } finally { lock.writeLock().unlock(); } } public T queryOne(Class beanClass, String sql, Object\u0026hellip; params) { SqlPair key = new SqlPair(sql, params); // 加读锁, 防止其它线程对缓存更改 lock.readLock().lock(); try { T value = map.get(key); if (value != null) { return value; } } finally { lock.readLock().unlock(); } // 加写锁, 防止其它线程对缓存读取和更改 lock.writeLock().lock(); try { // get 方法上面部分是可能多个线程进来的, 可能已经向缓存填充了数据 // 为防止重复查询数据库, 再次验证 T value = map.get(key); if (value == null) { // 如果没有, 查询数据库 value = genericDao.queryOne(beanClass, sql, params); map.put(key, value); } return value; } finally { lock.writeLock().unlock(); } } // 作为 key 保证其是不可变的 class SqlPair { private String sql; private Object[] params; public SqlPair(String sql, Object[] params) { this.sql = sql; this.params = params; } @Override public boolean equals(Object o) { if (this == o) {return true; } if (o == null || getClass() != o.getClass()) { return false; } SqlPair sqlPair = (SqlPair) o; return sql.equals(sqlPair.sql) \u0026amp;\u0026amp; Arrays.equals(params, sqlPair.params); } @Override public int hashCode() { int result = Objects.hash(sql); result = 31 * result + Arrays.hashCode(params); return result; } } }\n 注意 * 以上实现体现的是读写锁的应用，保证缓存和数据库的一致性，但有下面的问题没有考虑适合读多写少，如果写操作比较频繁，以上实现性能低 * 没有考虑缓存容量 * 没有考虑缓存过期 * 只适合单机 * 并发性还是低，目前只会用一把锁 * 更新方法太过简单粗暴，清空了所有 key（考虑按类型分区或重新设计 key） * 乐观锁实现：用 CAS 去更新 ## 分治 ### 1. 案例 - 单词计数  java private static  void demo(Supplier\u0026gt; supplier, BiConsumer, List\u0026gt; consumer) { MapcounterMap = supplier.get(); List ts = new ArrayList\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;= 26; i++) { int idx = i; Thread thread = new Thread(() -\u0026gt; { List words = readFromFile(idx); consumer.accept(counterMap, words); }); ts.add(thread); } ts.forEach(t -\u0026gt; t.start()); ts.forEach(t -\u0026gt; { try {t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); System.out.println(counterMap); } public static List readFromFile(int i) { ArrayList words = new ArrayList\u0026lt;\u0026gt;(); try (BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(\u0026ldquo;tmp/\u0026rdquo; + i + \u0026ldquo;.txt\u0026rdquo;)))) { while (true) { String word = in.readLine(); if (word == null) { break; } words.add(word); } return words; } catch (IOException e) { throw new RuntimeException(e); } }\n 解法 1 ：  java demo( () -\u0026gt; new ConcurrentHashMap(), (map, words) -\u0026gt; { for (String word : words) { map.computeIfAbsent(word, (key) -\u0026gt; new LongAdder()).increment(); } } );\n 解法 2 ：  java Mapcollect = IntStream.range(1, 27).parallel() .mapToObj(idx -\u0026gt; readFromFile(idx)) .flatMap(list -\u0026gt; list.stream()) .collect(Collectors.groupingBy(Function.identity(), Collectors.summingInt(w -\u0026gt; 1)));\n ### 2. 案例 - 求和  java class AddTask3 extends RecursiveTask {\n int begin; int end; public AddTask3(int begin, int end) { this.begin = begin; this.end = end; } @Override public String toString() { return \u0026quot;{\u0026quot; + begin + \u0026quot;,\u0026quot; + end + '}'; } @Override protected Integer compute() { // 5, 5 if (begin == end) { log.debug(\u0026quot;join() {}\u0026quot;, begin); return begin; } // 4, 5 if (end - begin == 1) { log.debug(\u0026quot;join() {} + {} = {}\u0026quot;, begin, end, end + begin); return end + begin; } // 1 5 int mid = (end + begin) / 2; // 3 AddTask3 t1 = new AddTask3(begin, mid); // 1,3 t1.fork(); AddTask3 t2 = new AddTask3(mid + 1, end); // 4,5 t2.fork(); log.debug(\u0026quot;fork() {} + {} = ?\u0026quot;, t1, t2); int result = t1.join() + t2.join(); log.debug(\u0026quot;join() {} + {} = {}\u0026quot;, t1, t2, result); return result; }  }\n 然后提交给 ForkJoinPool 来执行  java public static void main(String[] args) { ForkJoinPool pool = new ForkJoinPool(4); System.out.println(pool.invoke(new AddTask3(1, 10))); }\n 结果  [ForkJoinPool-1-worker-0] - join() 1 + 2 = 3 [ForkJoinPool-1-worker-3] - join() 4 + 5 = 9 [ForkJoinPool-1-worker-0] - join() 3 [ForkJoinPool-1-worker-1] - fork() {1,3} + {4,5} = ? [ForkJoinPool-1-worker-2] - fork() {1,2} + {3,3} = ? [ForkJoinPool-1-worker-2] - join() {1,2} + {3,3} = 6 [ForkJoinPool-1-worker-1] - join() {1,3} + {4,5} = 15 15\n ## 统筹 ### 案例 - 烧水泡茶 #### 解法 1 ：join  java Thread t1 = new Thread(() -\u0026gt; { log.debug(\u0026ldquo;洗水壶\u0026rdquo;); sleep(1); log.debug(\u0026ldquo;烧开水\u0026rdquo;); sleep(15); }, \u0026ldquo;老王\u0026rdquo;); Thread t2 = new Thread(() -\u0026gt; { log.debug(\u0026ldquo;洗茶壶\u0026rdquo;); sleep(1); log.debug(\u0026ldquo;洗茶杯\u0026rdquo;); sleep(2); log.debug(\u0026ldquo;拿茶叶\u0026rdquo;); sleep(1); try { t1.join(); } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\u0026ldquo;泡茶\u0026rdquo;); }, \u0026ldquo;小王\u0026rdquo;); t1.start(); t2.start();\n 输出  19:19:37.547 [小王] c.TestMakeTea - 洗茶壶 19:19:37.547 [老王] c.TestMakeTea - 洗水壶 19:19:38.552 [小王] c.TestMakeTea - 洗茶杯 19:19:38.552 [老王] c.TestMakeTea - 烧开水 19:19:40.553 [小王] c.TestMakeTea - 拿茶叶 19:19:53.553 [小王] c.TestMakeTea - 泡茶\n #### 解法 1 的缺陷： * 上面模拟的是小王等老王的水烧开了，小王泡茶，如果反过来要实现老王等小王的茶叶拿来了，老王泡茶呢？代码最好能适应两种情况 * 上面的两个线程其实是各执行各的，如果要模拟老王把水壶交给小王泡茶，或模拟小王把茶叶交给老王泡茶呢 ### 解法 2 ：wait/notify  java class S2 { static String kettle = \u0026ldquo;冷水\u0026rdquo;; static String tea = null; static final Object lock = new Object(); static boolean maked = false; public static void makeTea() { new Thread(() -\u0026gt; { log.debug(\u0026ldquo;洗水壶\u0026rdquo;); sleep(1); log.debug(\u0026ldquo;烧开水\u0026rdquo;); sleep(5); synchronized (lock) { kettle = \u0026ldquo;开水\u0026rdquo;; lock.notifyAll(); while (tea == null) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } if (!maked) { log.debug(\u0026ldquo;拿({})泡({})\u0026rdquo;, kettle, tea); maked = true; } } }, \u0026ldquo;老王\u0026rdquo;).start(); new Thread(() -\u0026gt; { log.debug(\u0026ldquo;洗茶壶\u0026rdquo;); sleep(1); log.debug(\u0026ldquo;洗茶杯\u0026rdquo;); sleep(2); log.debug(\u0026ldquo;拿茶叶\u0026rdquo;); sleep(1); synchronized (lock) { tea = \u0026ldquo;花茶\u0026rdquo;; lock.notifyAll(); while (kettle.equals(\u0026ldquo;冷水\u0026rdquo;)) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } if (!maked) { log.debug(\u0026ldquo;拿({})泡({})\u0026rdquo;, kettle, tea); maked = true; } } }, \u0026ldquo;小王\u0026rdquo;).start(); } }\n 输出  20:04:48.179 c.S2 [小王] - 洗茶壶 20:04:48.179 c.S2 [老王] - 洗水壶 20:04:49.185 c.S2 [老王] - 烧开水 20:04:49.185 c.S2 [小王] - 洗茶杯 20:04:51.185 c.S2 [小王] - 拿茶叶 20:04:54.185 c.S2 [老王] - 拿(开水)泡(花茶)\n 解法 2 解决了解法 1 的问题，不过老王和小王需要相互等待，不如他们只负责各自的任务，泡茶交给第三人来做 ### 解法 3 ：第三者协调  java class S3 { static String kettle = \u0026ldquo;冷水\u0026rdquo;; static String tea = null; static final Object lock = new Object(); public static void makeTea() { new Thread(() -\u0026gt; { log.debug(\u0026ldquo;洗水壶\u0026rdquo;); sleep(1); log.debug(\u0026ldquo;烧开水\u0026rdquo;); sleep(5); synchronized (lock) { kettle = \u0026ldquo;开水\u0026rdquo;; lock.notifyAll(); } }, \u0026ldquo;老王\u0026rdquo;).start(); new Thread(() -\u0026gt; { log.debug(\u0026ldquo;洗茶壶\u0026rdquo;); sleep(1); log.debug(\u0026ldquo;洗茶杯\u0026rdquo;); sleep(2); log.debug(\u0026ldquo;拿茶叶\u0026rdquo;); sleep(1); synchronized (lock) { tea = \u0026ldquo;花茶\u0026rdquo;; lock.notifyAll(); } }, \u0026ldquo;小王\u0026rdquo;).start(); new Thread(() -\u0026gt; { synchronized (lock) { while (kettle.equals(\u0026ldquo;冷水\u0026rdquo;) || tea == null) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\u0026ldquo;拿({})泡({})\u0026rdquo;, kettle, tea); } }, \u0026ldquo;王夫人\u0026rdquo;).start(); } }\n 输出  20:13:18.202 c.S3 [小王] - 洗茶壶 20:13:18.202 c.S3 [老王] - 洗水壶 20:13:19.206 c.S3 [小王] - 洗茶杯 20:13:19.206 c.S3 [老王] - 烧开水 20:13:21.206 c.S3 [小王] - 拿茶叶 20:13:24.207 c.S3 [王夫人] - 拿(开水)泡(花茶)\n ## 定时 ### 1. 定期执行 如何让每周四 18:00:00 定时执行任务？  java // 获得当前时间 LocalDateTime now = LocalDateTime.now(); // 获取本周四 18:00:00.000 //LocalDateTime jdk1.8新增的线程安全类 LocalDateTime thursday = now.with(DayOfWeek.THURSDAY).withHour(18).withMinute(0).withSecond(0).withNano(0); // 如果当前时间已经超过 本周四 18:00:00.000， 那么找下周四 18:00:00.000 if(now.compareTo(thursday) \u0026gt;= 0) { thursday = thursday.plusWeeks(1); } // 计算时间差，即延时执行时间 long initialDelay = Duration.between(now, thursday).toMillis(); // 计算间隔时间，即 1 周的毫秒值 long oneWeek = 7 * 24 * 3600 * 1000; ScheduledExecutorService executor = Executors.newScheduledThreadPool(2); System.out.println(\u0026ldquo;开始时间：\u0026rdquo; + new Date()); executor.scheduleAtFixedRate(() -\u0026gt; { System.out.println(\u0026ldquo;执行时间：\u0026rdquo; + new Date()); }, initialDelay, oneWeek, TimeUnit.MILLISECONDS); ```\n","id":10,"section":"posts","summary":"应用篇 效率 1.使用多线程充分利用 CPU 1)环境搭建 基准测试工具选择，使用了比较靠谱的 JMH，它会执行程序预热，执行多次测试并平均 cpu 核数限制，有两","tags":["Java","Java并发编程"],"title":"Java并发编程应用篇","uri":"https://mumulx.github.io/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8%E7%AF%87/","year":"2020"},{"content":" 模式篇 同步模式之保护性暂停 1.定义 即 Guarded Suspension，用在一个线程等待另一个线程的执行结果\n要点\n 有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject 如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者） JDK 中，join 的实现、Future 的实现，采用的就是此模式 因为要等待另一方的结果，因此归类到同步模式  2.实现 class GuardedObject { //结果 private Object response; private final Object lock = new Object(); //获取结果 public Object get() { synchronized (lock) { // 条件不满足则等待，没有结果 while (response == null) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } return response; } } //产生结果 public void complete(Object response) { synchronized (lock) { // 条件满足，通知等待线程；给结果成员变量赋值 this.response = response; lock.notifyAll(); } } }  *应用 一个线程等待另一个线程的执行结果；线程1等待线程2的下载结果\npublic static void main(String[] args) { GuardedObject guardedObject = new GuardedObject(); new Thread(() -\u0026gt; { // 等待结果 log.debug(\u0026quot;等待结果\u0026quot;); List\u0026lt;String\u0026gt; list =(List\u0026lt;String\u0026gt;)guardedObject.get(); log.debug(\u0026quot;结果大小：{}\u0026quot;,list.size()); },\u0026quot;t1\u0026quot;).start(); new Thread(() -\u0026gt; { log.debug(\u0026quot;执行下载\u0026quot;); try { // 子线程执行下载 List\u0026lt;String\u0026gt; response = Downloader.download(); guardedObject.complete(list); } catch (IOException e) { e.printStackTrace(); } },\u0026quot;t2\u0026quot;).start(); log.debug(\u0026quot;waiting...\u0026quot;); }  public class Downloader { public static List\u0026lt;String\u0026gt; download() throws IOException { HttpURLConnection conn = (HttpURLConnection) new URL(\u0026quot;https://www.baidu.com/\u0026quot;).openConnection(); List\u0026lt;String\u0026gt; lines = new ArrayList\u0026lt;\u0026gt;(); try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) { String line; while ((line = reader.readLine()) != null) { lines.add(line); } } return lines; } }  执行结果\n08:42:18.568 [main] c.TestGuardedObject - waiting... 08:42:23.312 [Thread-0] c.TestGuardedObject - download complete... 08:42:23.312 [main] c.TestGuardedObject - get response: [3] lines  3.带超时版 GuardedObject 如果要控制超时时间呢\n// 增加超时效果 class GuardedObject { // 结果 private Object response; // 获取结果 // timeout 表示要等待多久 2000 public Object get(long timeout) { synchronized (this) { // 开始时间 15:00:00 long begin = System.currentTimeMillis(); // 经历的时间 long passedTime = 0; while (response == null) { // 这一轮循环应该等待的时间 long waitTime = timeout - passedTime; // 经历的时间超过了最大等待时间时，退出循环 if (waitTime\u0026lt;= 0) { break; } try { this.wait(waitTime); // 虚假唤醒 15:00:01 } catch (InterruptedException e) { e.printStackTrace(); } // 求得经历时间 passedTime = System.currentTimeMillis() - begin; // 15:00:02 1s } return response; } } // 产生结果 public void complete(Object response) { synchronized (this) { // 给结果成员变量赋值 this.response = response; this.notifyAll(); } } }  测试，没有超时\npublic static void main(String[] args) { GuardedObjectV2 v2 = new GuardedObjectV2(); new Thread(() -\u0026gt; { log.debug(\u0026quot;begin\u0026quot;); Object response = v2.get(2000); log.debug(\u0026quot;结果是\u0026quot;,response); },\u0026quot;t1\u0026quot;).start(); new Thread(() -\u0026gt; { log.debug(\u0026quot;begin t2\u0026quot;); Sleeper.sleep(1); v2.complete(new Object()); },\u0026quot;t2\u0026quot;).start(); }  *原理之 join\n4.多任务版 GuardedObject 图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右 侧的 t1，t3，t5 就好比邮递员\n如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类， 这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理\n新增 id 用来标识 Guarded Object\n// 增加超时效果 class GuardedObject { // 标识 Guarded Object private int id; public GuardedObject(int id) { this.id = id; } public int getId() { return id; } // 结果 private Object response; // 获取结果 // timeout 表示要等待多久 2000 public Object get(long timeout) { synchronized (this) { // 开始时间 15:00:00 long begin = System.currentTimeMillis(); // 经历的时间 long passedTime = 0; while (response == null) { // 这一轮循环应该等待的时间 long waitTime = timeout - passedTime; // 经历的时间超过了最大等待时间时，退出循环 if (timeout - passedTime \u0026lt;= 0) { break; } try { this.wait(waitTime); // 虚假唤醒 15:00:01 } catch (InterruptedException e) { e.printStackTrace(); } // 求得经历时间 passedTime = System.currentTimeMillis() - begin; // 15:00:02 1s } return response; } } // 产生结果 public void complete(Object response) { synchronized (this) { // 给结果成员变量赋值 this.response = response; this.notifyAll(); } } }  中间解耦类\nclass Mailboxes { private static Map\u0026lt;Integer, GuardedObject\u0026gt; boxes = new Hashtable\u0026lt;\u0026gt;(); private static int id = 1; // 产生唯一 id private static synchronized int generateId() { return id++;//自增不是原子性的，再多线程下有问题 } public static GuardedObject getGuardedObject(int id) { return boxes.remove(id); } public static GuardedObject createGuardedObject() { GuardedObject go = new GuardedObject(generateId()); //boxes对象是线程安全的 boxes.put(go.getId(), go); return go; } public static Set\u0026lt;Integer\u0026gt; getIds() { //boxes对象是线程安全的 return boxes.keySet(); } }  业务相关类\n@Slf4j(topic = \u0026quot;c.People\u0026quot;) class People extends Thread{ @Override public void run() { // 收信 GuardedObject guardedObject = Mailboxes.createGuardedObject(); log.debug(\u0026quot;开始收信 id:{}\u0026quot;, guardedObject.getId()); Object mail = guardedObject.get(5000); log.debug(\u0026quot;收到信 id:{}, 内容:{}\u0026quot;, guardedObject.getId(), mail); } } @Slf4j(topic = \u0026quot;c.Postman\u0026quot;) class Postman extends Thread { private int id; private String mail; public Postman(int id, String mail) { this.id = id; this.mail = mail; } @Override public void run() { GuardedObject guardedObject = Mailboxes.getGuardedObject(id); log.debug(\u0026quot;送信 id:{}, 内容:{}\u0026quot;, id, mail); guardedObject.complete(mail); } }  测试\npublic static void main(String[] args) throws InterruptedException { for (int i = 0; i \u0026lt; 3; i++) { new People().start(); } Sleeper.sleep(1); for (Integer id : Mailboxes.getIds()) { new Postman(id, \u0026quot;内容\u0026quot; + id).start(); } }  某次运行结果\n10:35:05.689 c.People [Thread-1] - 开始收信 id:3 10:35:05.689 c.People [Thread-2] - 开始收信 id:1 10:35:05.689 c.People [Thread-0] - 开始收信 id:2 10:35:06.688 c.Postman [Thread-4] - 送信 id:2, 内容:内容2 10:35:06.688 c.Postman [Thread-5] - 送信 id:1, 内容:内容1 10:35:06.688 c.People [Thread-0] - 收到信 id:2, 内容:内容2 10:35:06.688 c.People [Thread-2] - 收到信 id:1, 内容:内容1 10:35:06.688 c.Postman [Thread-3] - 送信 id:3, 内容:内容3 10:35:06.689 c.People [Thread-1] - 收到信 id:3, 内容:内容3  同步模式之 Balking 1. 定义 Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做 了，直接结束返回\n2. 实现 例如：\n*** 终止模式之两阶段终止模式**中的利用停止标记的优化\n@Slf4j(topic = \u0026quot;c.TwoPhaseTermination\u0026quot;) public class Test13 { public static void main(String[] args) throws InterruptedException { TwoPhaseTermination tpt = new TwoPhaseTermination(); tpt.start(); tpt.start(); tpt.start(); /*Thread.sleep(3500); log.debug(\u0026quot;停止监控\u0026quot;); tpt.stop();*/ } } @Slf4j(topic = \u0026quot;c.TwoPhaseTermination\u0026quot;) class TwoPhaseTermination { // 监控线程 private Thread monitorThread; // 停止标记 private volatile boolean stop = false; // 判断是否执行过 start 方法 private boolean starting = false; // 启动监控线程 public void start() { synchronized (this) { if (starting) { // false return; } starting = true; } monitorThread = new Thread(() -\u0026gt; { while (true) { Thread current = Thread.currentThread(); // 是否被打断 if (stop) { log.debug(\u0026quot;料理后事\u0026quot;); break; } try { Thread.sleep(1000); log.debug(\u0026quot;执行监控记录\u0026quot;); } catch (InterruptedException e) { e.printStackTrace(); } } }, \u0026quot;monitor\u0026quot;); monitorThread.start(); } // 停止监控线程 public void stop() { stop = true; monitorThread.interrupt(); } }  尽量让sychronized同步代码块中的代码尽可能的少，只保护需要保护的资源\n例二\n@RestController public class MonitorController { public static ArrayBlockingQueue\u0026lt;Info\u0026gt; QUEUE = new ArrayBlockingQueue(30); @Autowired private MonitorService monitorService; @GetMapping(\u0026quot;/info\u0026quot;) public List\u0026lt;Info\u0026gt; info() { ArrayList\u0026lt;Info\u0026gt; infos = new ArrayList\u0026lt;\u0026gt;(); QUEUE.drainTo(infos); return infos; } @GetMapping(\u0026quot;/start\u0026quot;) public void start() { monitorService.start(); } @GetMapping(\u0026quot;/stop\u0026quot;) public void stop() { monitorService.stop(); } }  @Service @Slf4j public class MonitorService { private volatile boolean stop; private volatile boolean starting; private Thread monitorThread; public void start() { // 缩小同步范围，提升性能 synchronized (this) { log.info(\u0026quot;该监控线程已启动?({})\u0026quot;, starting); if (starting) { return; } starting = true; } // 由于之前的 balking 模式，以下代码只可能被一个线程执行，因此无需互斥 monitorThread = new Thread(() -\u0026gt; { while (!stop) { report(); sleep(2); } // 这里的监控线程只可能启动一个，因此只需要用 volatile 保证 starting 的可见性 log.info(\u0026quot;监控线程已停止...\u0026quot;); starting = false; }); stop = false; log.info(\u0026quot;监控线程已启动...\u0026quot;); monitorThread.start(); } private void report() { Info info = new Info(); info.setTotal(Runtime.getRuntime().totalMemory()); info.setFree(Runtime.getRuntime().freeMemory()); info.setMax(Runtime.getRuntime().maxMemory()); info.setTime(System.currentTimeMillis()); MonitorController.QUEUE.offer(info); } private void sleep(long seconds) { try { TimeUnit.SECONDS.sleep(seconds); } catch (InterruptedException e) { } } public synchronized void stop() { stop = true; // 不加打断需要等到下一次 sleep 结束才能退出循环，这里是为了更快结束 monitorThread.interrupt(); } }  @Data public class Info { private long free; private long total; private long max; private long time; }  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;监控程序\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/js/echarts.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/js/jquery.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body style=\u0026quot;height: 500px; margin: 0\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;container\u0026quot; style=\u0026quot;height: 100%\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;开始\u0026quot; id=\u0026quot;start\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;停止\u0026quot; id=\u0026quot;stop\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; $(\u0026quot;#start\u0026quot;).click(function(){ $.get(\u0026quot;start\u0026quot;); }); $(\u0026quot;#stop\u0026quot;).click(function(){ $.get(\u0026quot;stop\u0026quot;); }); const dom = document.getElementById(\u0026quot;container\u0026quot;); const myChart = echarts.init(dom); option = null; let data = []; option = { title: { text: '动态数据 + 时间坐标轴' }, xAxis: { type: 'time', splitLine: { show: false } }, yAxis: { type: 'value', boundaryGap: [0, '100%'], splitLine: { show: false } }, series: [{ name: '总内存', type: 'line', showSymbol: true, areaStyle: {color: 'rgba(0, 200, 40, 0.7)'}, hoverAnimation: true, data: [] }, { name: '已使用', type: 'line', showSymbol: true, areaStyle: {color: 'rgba(0, 0, 200, 0.7)'}, hoverAnimation: true, data: [] }] }; setInterval(function () { $.get(\u0026quot;info\u0026quot;).done(function (infos) { while (data.length \u0026gt;= 10) { data.shift(); } data.push(...infos); let max = data.map(d =\u0026gt; [d.time, d.max]); let total = data.map(d =\u0026gt; [d.time, d.total]); let used = data.map(d =\u0026gt; [d.time, d.total - d.free]); myChart.setOption({ series: [{ data: total }, { data: used }] }); }); }, 2000); myChart.setOption(option, true); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  当前端页面多次点击按钮调用 start 时\n输出\n[http-nio-8080-exec-1] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(false) [http-nio-8080-exec-1] cn.itcast.monitor.service.MonitorService - 监控线程已启动... [http-nio-8080-exec-2] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(true) [http-nio-8080-exec-3] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(true) [http-nio-8080-exec-4] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(true)  它还经常用来实现线程安全的单例\npublic final class Singleton { private Singleton() { } private static Singleton INSTANCE = null; public static synchronized Singleton getInstance() { if (INSTANCE != null) { return INSTANCE; } INSTANCE = new Singleton(); return INSTANCE; } }  对比一下保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待。\n同步模式之顺序控制 1. 固定运行顺序 比如，必须先 2 后 1 打印\n1.1 wait notify 版 @Slf4j(topic = \u0026quot;c.Test25\u0026quot;) public class Test25 { static final Object lock = new Object(); // 表示 t2 是否运行过 static boolean t2runned = false; public static void main(String[] args) { Thread t1 = new Thread(() -\u0026gt; { synchronized (lock) { while (!t2runned) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\u0026quot;1\u0026quot;); } }, \u0026quot;t1\u0026quot;); Thread t2 = new Thread(() -\u0026gt; { synchronized (lock) { log.debug(\u0026quot;2\u0026quot;); t2runned = true; lock.notify(); } }, \u0026quot;t2\u0026quot;); t1.start(); t2.start(); } }  1.2 Park Unpark 版 可以看到，实现上很麻烦：\n 首先，需要保证先 wait 再 notify，否则 wait 线程永远得不到唤醒。因此使用了『运行标记』来判断该不该 wait 第二，如果有些干扰线程错误地 notify 了 wait 线程，条件不满足时还要重新等待，使用了 while 循环来解决 此问题 最后，唤醒对象上的 wait 线程需要使用 notifyAll，因为『同步对象』上的等待线程可能不止一个  可以使用 LockSupport 类的 park 和 unpark 来简化上面的题目：\n@Slf4j(topic = \u0026quot;c.Test26\u0026quot;) public class Test26 { public static void main(String[] args) { Thread t1 = new Thread(() -\u0026gt; { LockSupport.park(); log.debug(\u0026quot;1\u0026quot;); }, \u0026quot;t1\u0026quot;); t1.start(); new Thread(() -\u0026gt; { log.debug(\u0026quot;2\u0026quot;); LockSupport.unpark(t1); },\u0026quot;t2\u0026quot;).start(); } }  park 和 unpark 方法比较灵活，他俩谁先调用，谁后调用无所谓。并且是以线程为单位进行『暂停』和『恢复』， 不需要『同步对象』和『运行标记』\n2. 交替输出 线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现\n2.1 wait notify 版 @Slf4j(topic = \u0026quot;c.Test27\u0026quot;) public class Test27 { public static void main(String[] args) { WaitNotify wn = new WaitNotify(1, 5); new Thread(() -\u0026gt; { wn.print(\u0026quot;a\u0026quot;, 1, 2); }).start(); new Thread(() -\u0026gt; { wn.print(\u0026quot;b\u0026quot;, 2, 3); }).start(); new Thread(() -\u0026gt; { wn.print(\u0026quot;c\u0026quot;, 3, 1); }).start(); } } /* 输出内容 等待标记 下一个标记 a 1 2 b 2 3 c 3 1 */ class WaitNotify { // 打印 a 1 2 public void print(String str, int waitFlag, int nextFlag) { for (int i = 0; i \u0026lt; loopNumber; i++) { synchronized (this) { while(flag != waitFlag) { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(str); flag = nextFlag; this.notifyAll(); } } } // 等待标记 private int flag; // 2 // 循环次数 private int loopNumber; public WaitNotify(int flag, int loopNumber) { this.flag = flag; this.loopNumber = loopNumber; } }  2.2 Lock 条件变量版 public class Test30 { public static void main(String[] args) throws InterruptedException { AwaitSignal awaitSignal = new AwaitSignal(5); Condition a = awaitSignal.newCondition(); Condition b = awaitSignal.newCondition(); Condition c = awaitSignal.newCondition(); new Thread(() -\u0026gt; { awaitSignal.print(\u0026quot;a\u0026quot;, a, b); }).start(); new Thread(() -\u0026gt; { awaitSignal.print(\u0026quot;b\u0026quot;, b, c); }).start(); new Thread(() -\u0026gt; { awaitSignal.print(\u0026quot;c\u0026quot;, c, a); }).start(); Thread.sleep(1000); awaitSignal.lock(); try { System.out.println(\u0026quot;开始...\u0026quot;); a.signal(); } finally { awaitSignal.unlock(); } } } class AwaitSignal extends ReentrantLock{ //循环次数 private int loopNumber; public AwaitSignal(int loopNumber) { this.loopNumber = loopNumber; } // 参数1 打印内容， 参数2 进入哪一间休息室, 参数3 下一间休息室 public void print(String str, Condition current, Condition next) { for (int i = 0; i \u0026lt; loopNumber; i++) { lock(); try { current.await(); System.out.print(str); next.signal(); } catch (InterruptedException e) { e.printStackTrace(); } finally { unlock(); } } } }  注意\n该实现没有考虑 a，b，c 线程都就绪再开始  2.3 Park Unpark 版 @Slf4j(topic = \u0026quot;c.Test31\u0026quot;) public class Test31 { static Thread t1; static Thread t2; static Thread t3; public static void main(String[] args) { ParkUnpark pu = new ParkUnpark(5); t1 = new Thread(() -\u0026gt; { pu.print(\u0026quot;a\u0026quot;, t2); }); t2 = new Thread(() -\u0026gt; { pu.print(\u0026quot;b\u0026quot;, t3); }); t3 = new Thread(() -\u0026gt; { pu.print(\u0026quot;c\u0026quot;, t1); }); t1.start(); t2.start(); t3.start(); LockSupport.unpark(t1); } } class ParkUnpark { public void print(String str, Thread next) { for (int i = 0; i \u0026lt; loopNumber; i++) { LockSupport.park(); System.out.print(str); LockSupport.unpark(next); } } private int loopNumber; public ParkUnpark(int loopNumber) { this.loopNumber = loopNumber; } }  异步模式之生产者/消费者 1. 定义 异步的原因是，生产后可能不会立刻被消费。\n要点  与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应\n 消费队列可以用来平衡生产和消费的线程资源\n 生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据\n 消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据\n JDK 中各种阻塞队列，采用的就是这种模式\n  2. 实现 // 消息队列类 ， java 线程之间通信 @Slf4j(topic = \u0026quot;c.MessageQueue\u0026quot;) class MessageQueue { // 消息的队列集合 private LinkedList\u0026lt;Message\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 队列容量 private int capcity; public MessageQueue(int capcity) { this.capcity = capcity; } // 获取消息 public Message take() { // 检查队列是否为空 synchronized (list) { while(list.isEmpty()) { try { log.debug(\u0026quot;队列为空, 消费者线程等待\u0026quot;); list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 从队列头部获取消息并返回 Message message = list.removeFirst(); log.debug(\u0026quot;已消费消息 {}\u0026quot;, message); list.notifyAll(); return message; } } // 存入消息 public void put(Message message) { synchronized (list) { // 检查对象是否已满 while(list.size() == capcity) { try { log.debug(\u0026quot;队列已满, 生产者线程等待\u0026quot;); list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 将消息加入队列尾部 list.addLast(message); log.debug(\u0026quot;已生产消息 {}\u0026quot;, message); list.notifyAll(); } } } //线程安全(只能读取) final class Message { private int id; private Object value; public Message(int id, Object value) { this.id = id; this.value = value; } public int getId() { return id; } public Object getValue() { return value; } @Override public String toString() { return \u0026quot;Message{\u0026quot; + \u0026quot;id=\u0026quot; + id + \u0026quot;, value=\u0026quot; + value + '}'; } }  * 应用 public static void main(String[] args) { MessageQueue queue = new MessageQueue(2); for (int i = 0; i \u0026lt; 3; i++) { int id = i; new Thread(() -\u0026gt; { queue.put(new Message(id , \u0026quot;值\u0026quot;+id)); }, \u0026quot;生产者\u0026quot; + i).start(); } new Thread(() -\u0026gt; { while(true) { sleep(1); Message message = queue.take(); } }, \u0026quot;消费者\u0026quot;).start(); }  异步模式之工作线程 1. 定义 让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现 就是线程池，也体现了经典设计模式中的享元模式。\n例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）\n注意，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率\n例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成 服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工\n2. 饥饿 固定大小线程池会有饥饿现象\n 两个工人是同一个线程池中的两个线程 他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作  客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待 后厨做菜：没啥说的，做就是了  比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好 但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿\npublic class TestDeadLock { static final List\u0026lt;String\u0026gt; MENU = Arrays.asList(\u0026quot;地三鲜\u0026quot;, \u0026quot;宫保鸡丁\u0026quot;, \u0026quot;辣子鸡丁\u0026quot;, \u0026quot;烤鸡翅\u0026quot;); static Random RANDOM = new Random(); static String cooking() { return MENU.get(RANDOM.nextInt(MENU.size())); } public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(2); executorService.execute(() -\u0026gt; { log.debug(\u0026quot;处理点餐...\u0026quot;); Future\u0026lt;String\u0026gt; f = executorService.submit(() -\u0026gt; { log.debug(\u0026quot;做菜\u0026quot;); return cooking(); }); try { log.debug(\u0026quot;上菜: {}\u0026quot;, f.get()); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } }); /* executorService.execute(() -\u0026gt; { log.debug(\u0026quot;处理点餐...\u0026quot;); Future\u0026lt;String\u0026gt; f = executorService.submit(() -\u0026gt; { log.debug(\u0026quot;做菜\u0026quot;); return cooking(); }); try { log.debug(\u0026quot;上菜: {}\u0026quot;, f.get()); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } });*/ } }   输出\n17:21:27.883 c.TestDeadLock [pool-1-thread-1] - 处理点餐... 17:21:27.891 c.TestDeadLock [pool-1-thread-2] - 做菜 17:21:27.891 c.TestDeadLock [pool-1-thread-1] - 上菜: 烤鸡翅  当注释取消后，可能的输出\n17:08:41.339 c.TestDeadLock [pool-1-thread-2] - 处理点餐... 17:08:41.339 c.TestDeadLock [pool-1-thread-1] - 处理点餐...  解决方法可以增加线程池的大小，不过不是根本解决方案，还是前面提到的，不同的任务类型，采用不同的线程池，例如：\n@Slf4j(topic = \u0026quot;c.TestDeadLock\u0026quot;) public class TestStarvation { static final List\u0026lt;String\u0026gt; MENU = Arrays.asList(\u0026quot;地三鲜\u0026quot;, \u0026quot;宫保鸡丁\u0026quot;, \u0026quot;辣子鸡丁\u0026quot;, \u0026quot;烤鸡翅\u0026quot;); static Random RANDOM = new Random(); static String cooking() { return MENU.get(RANDOM.nextInt(MENU.size())); } public static void main(String[] args) { ExecutorService waiterPool = Executors.newFixedThreadPool(1); ExecutorService cookPool = Executors.newFixedThreadPool(1); waiterPool.execute(() -\u0026gt; { log.debug(\u0026quot;处理点餐...\u0026quot;); Future\u0026lt;String\u0026gt; f = cookPool.submit(() -\u0026gt; { log.debug(\u0026quot;做菜\u0026quot;); return cooking(); }); try { log.debug(\u0026quot;上菜: {}\u0026quot;, f.get()); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } }); waiterPool.execute(() -\u0026gt; { log.debug(\u0026quot;处理点餐...\u0026quot;); Future\u0026lt;String\u0026gt; f = cookPool.submit(() -\u0026gt; { log.debug(\u0026quot;做菜\u0026quot;); return cooking(); }); try { log.debug(\u0026quot;上菜: {}\u0026quot;, f.get()); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } }); } }  输出\n17:25:14.626 c.TestDeadLock [pool-1-thread-1] - 处理点餐... 17:25:14.630 c.TestDeadLock [pool-2-thread-1] - 做菜 17:25:14.631 c.TestDeadLock [pool-1-thread-1] - 上菜: 地三鲜 17:25:14.632 c.TestDeadLock [pool-1-thread-1] - 处理点餐... 17:25:14.632 c.TestDeadLock [pool-2-thread-1] - 做菜 17:25:14.632 c.TestDeadLock [pool-1-thread-1] - 上菜: 辣子鸡丁  3. 创建多少线程池合适  过小会导致程序不能充分地利用系统资源、容易导致饥饿 过大会导致更多的线程上下文切换，占用更多内存  3.1 CPU 密集型运算 通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费（进行数据分析）\n3.2 I/O 密集型运算 CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。\n经验公式如下\n线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间  例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式\n4 * 100% * 100% / 50% = 8  例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式\n4 * 100% * 100% / 10% = 40  4. 自定义线程池 graph LR subgraph Thread Pool t1(t1) t2(t2) t3(t3) end subgraph Blocking Queue task1(\u0026quot;task 1\u0026quot;)--\u0026gt;task2(\u0026quot;task 2\u0026quot;) task2--\u0026gt;task3(\u0026quot;task 3\u0026quot;) end t1--poll--\u0026gt;task1 t2-.poll.-\u0026gt;task1 t3-.poll.-\u0026gt;task1 task3--put--\u0026gt;main(main)  见并发编程\n终止模式之两阶段终止模式 Two Phase Termination\n在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。\n1. 错误思路  使用线程对象的 stop() 方法停止线程  stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁， 其它线程将永远无法获取锁  使用 System.exit(int) 方法停止线程  目的仅是停止一个线程，但这种做法会让整个程序都停止   2. 两阶段终止模式 Two Phase Termination 在一个线程T1中如何“优雅\u0026rdquo;终止线程T2?这里的[优雅]指的是给T2-个料理后事的机会。\n错误思路\n 使用线程对象的stop0方法停止线程  stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁  使用System.exit(int)方法停止线程  目的仅是停止一个线程，但这种做法会让整个程序都停止   2.1 利用 isInterrupted interrupt 可以打断正在执行的线程，无论这个线程是在 sleep，wait，还是正常运行\nclass TPTInterrupt { private Thread thread; public void start(){ thread = new Thread(() -\u0026gt; { while(true) { Thread current = Thread.currentThread(); if(current.isInterrupted()) { log.debug(\u0026quot;料理后事\u0026quot;); break; } try { Thread.sleep(1000); log.debug(\u0026quot;将结果保存\u0026quot;); } catch (InterruptedException e) { current.interrupt();} // 执行监控操作 } },\u0026quot;监控线程\u0026quot;); thread.start(); } public void stop() { thread.interrupt(); } }  调用\nTPTInterrupt t = new TPTInterrupt(); t.start(); Thread.sleep(3500); log.debug(\u0026quot;stop\u0026quot;); t.stop();  结果\n11:49:42.915 c.TwoPhaseTermination [监控线程] - 将结果保存 11:49:43.919 c.TwoPhaseTermination [监控线程] - 将结果保存 11:49:44.919 c.TwoPhaseTermination [监控线程] - 将结果保存 11:49:45.413 c.TestTwoPhaseTermination [main] - stop 11:49:45.413 c.TwoPhaseTermination [监控线程] - 料理后事  2.2 利用停止标记 // 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性 // 我们的例子中，即主线程把它修改为 true 对 t1 线程可见 @Slf4j(topic = \u0026quot;c.TwoPhaseTermination\u0026quot;) public class Test13 { public static void main(String[] args) throws InterruptedException { TwoPhaseTermination tpt = new TwoPhaseTermination(); tpt.start(); Thread.sleep(3500); log.debug(\u0026quot;停止监控\u0026quot;); tpt.stop(); } } @Slf4j(topic = \u0026quot;c.TwoPhaseTermination\u0026quot;) class TwoPhaseTermination { // 监控线程 private Thread monitorThread; // 停止标记 private volatile boolean stop = false; // 启动监控线程 public void start() { monitorThread = new Thread(() -\u0026gt; { while (true) { Thread current = Thread.currentThread(); // 是否被打断 if (stop) { log.debug(\u0026quot;料理后事\u0026quot;); break; } try { Thread.sleep(1000); log.debug(\u0026quot;执行监控记录\u0026quot;); } catch (InterruptedException e) { e.printStackTrace(); } } }, \u0026quot;monitor\u0026quot;); monitorThread.start(); } // 停止监控线程 public void stop() { stop = true; monitorThread.interrupt(); } }  案例：JVM 内存监控 线程安全单例 单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用getInstance）时的线程安全，并思考注释中的问题\n饿汉式：类加载就会导致该单实例对象被创建 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建  1. 饿汉单例 // 问题1：为什么加 final // 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例 public final class Singleton implements Serializable { // 问题3：为什么设置为私有? 是否能防止反射创建新的实例? private Singleton() {} // 问题4：这样初始化是否能保证单例对象创建时的线程安全? private static final Singleton INSTANCE = new Singleton(); // 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由 public static Singleton getInstance() { return INSTANCE; } public Object readResolve() { return INSTANCE; } }  2. 枚举单例 // 问题1：枚举单例是如何限制实例个数的 // 问题2：枚举单例在创建时是否有并发问题 // 问题3：枚举单例能否被反射破坏单例 // 问题4：枚举单例能否被反序列化破坏单例 // 问题5：枚举单例属于懒汉式还是饿汉式 // 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做 enum Singleton { INSTANCE; }  3. 懒汉单例  private Singleton() { } private static Singleton INSTANCE = null; // 分析这里的线程安全, 并说明有什么缺点 public static synchronized Singleton getInstance() { if( INSTANCE != null ){ return INSTANCE; } INSTANCE = new Singleton(); return INSTANCE; } }  4. DCL 懒汉单例 public final class Singleton { private Singleton() { } // 问题1：解释为什么要加 volatile ? private static volatile Singleton INSTANCE = null; // 问题2：对比实现3, 说出这样做的意义 public static Singleton getInstance() { if (INSTANCE != null) {return INSTANCE; } synchronized (Singleton.class) { // 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗 if (INSTANCE != null) { // t2 return INSTANCE; } INSTANCE = new Singleton(); return INSTANCE; } } }  5. 静态内部类懒汉单例 public final class Singleton { private Singleton() { } // 问题1：属于懒汉式还是饿汉式 private static class LazyHolder { static final Singleton INSTANCE = new Singleton(); } // 问题2：在创建时是否有并发问题 public static Singleton getInstance() { return LazyHolder.INSTANCE; } }  享元模式 1. 简介 定义 英文名称：Flyweight pattern. 当需要重用数量有限的同一类对象时\nwikipedia： A flyweight is an object that minimizes memory usage by sharing as much data as possible with other similar objects  出自 \u0026ldquo;Gang of Four\u0026rdquo; design patterns\n归类 Structual patterns\n2. 体现 2.1 包装类 在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对 象：\npublic static Long valueOf(long l) { final int offset = 128; if (l \u0026gt;= -128 \u0026amp;\u0026amp; l \u0026lt;= 127) { // will cache return LongCache.cache[(int)l + offset]; } return new Long(l); }  注意：\n  Byte, Short, Long 缓存的范围都是 -128~127 Character 缓存的范围是 0~127 Integer的默认范围是 -128~127  最小值不能变 但最大值可以通过调整虚拟机参数  -Djava.lang.Integer.IntegerCache.high 来改变  Boolean 缓存了 TRUE 和 FALSE   2.2 String 串池 2.3 BigDecimal BigInteger 这些类都是线程安全的，他们其中的每一个方法都是线程安全的，因此单独使用的时候不会有线程安全的问题，但是当它们在一起使用的时候（组合多个方法进行使用）就不能保证他们是线程安全的了。\n3. DIY 例如：一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。\n@Slf4j(topic = \u0026quot;c.Pool\u0026quot;) class Pool { // 1. 连接池大小 private final int poolSize; // 2. 连接对象数组 private Connection[] connections; // 3. 连接状态数组 0 表示空闲， 1 表示繁忙 private AtomicIntegerArray states; // 4. 构造方法初始化 public Pool(int poolSize) { this.poolSize = poolSize; this.connections = new Connection[poolSize]; this.states = new AtomicIntegerArray(new int[poolSize]); for (int i = 0; i \u0026lt; poolSize; i++) { connections[i] = new MockConnection(\u0026quot;连接\u0026quot; + (i+1)); } } // 5. 借连接 public Connection borrow() { while(true) { for (int i = 0; i \u0026lt; poolSize; i++) { // 获取空闲连接 if(states.get(i) == 0) { if (states.compareAndSet(i, 0, 1)) { log.debug(\u0026quot;borrow {}\u0026quot;, connections[i]); return connections[i]; } } } // 如果没有空闲连接，当前线程进入等待 synchronized (this) { try { log.debug(\u0026quot;wait...\u0026quot;); this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } // 6. 归还连接 public void free(Connection conn) { for (int i = 0; i \u0026lt; poolSize; i++) { if (connections[i] == conn) { states.set(i, 0); synchronized (this) { log.debug(\u0026quot;free {}\u0026quot;, conn); this.notifyAll(); } break; } } } } class MockConnection implements Connection { private String name; public MockConnection(String name) { this.name = name; } @Override public String toString() { return \u0026quot;MockConnection{\u0026quot; + \u0026quot;name='\u0026quot; + name + '\\'' + '}'; } }  使用连接池： Pool pool = new Pool(2); for (int i = 0; i \u0026lt; 5; i++) { new Thread(() -\u0026gt; { Connection conn = pool.borrow(); try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } pool.free(conn); }).start(); }  以上实现没有考虑：\n 连接的动态增长与收缩 连接保活（可用性检测） 等待超时处理 分布式 hash  对于关系型数据库，有比较成熟的连接池实现，例如c3p0, druid等 对于更通用的对象池，可以考虑使用apache commons pool，例如redis连接池可以参考jedis中关于连接池的实现\n","id":11,"section":"posts","summary":"模式篇 同步模式之保护性暂停 1.定义 即 Guarded Suspension，用在一个线程等待另一个线程的执行结果 要点 有一个结果需要从一个线程传递到另一个线程","tags":["Java","Java并发编程"],"title":"Java并发编程模式篇","uri":"https://mumulx.github.io/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E7%AF%87/","year":"2020"},{"content":" Nginx nginx 简介 什么是 nginx 和可以做什么事情 Nginx 是高性能的 HTTP 和反向代理的服务器，处理高并发能力是十分强大的，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。\n官网\n正向代理 Nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。\n正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。\n需要在客户端配置代理服务器进行指定网站访问\n反向代理 反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。\n动静分离 为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。\n负载均衡 客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。\n这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？\n我们首先想到的可能是升级服务器的配置，比如提高 CPU 执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？\n上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡\nNginx 的安装 Centos7\n参考博客\ngcc -v 没有的话需要安装 yum -y install gcc  yum install -y pcre pcre-devel yum install -y zlib zlib-devel yum install -y openssl openssl-devel cd /app tar -zxvf nginx-1.12.2.tar.gz cd nginx-1.12.2 ./configure make make install cd /usr/local/nginx/conf/ vi nginx.conf 修改监听端口 server { listen 80; server_name localhost;  启动\ncd /usr/local/nginx/sbin/ ./nginx  查看进程\nps -ef | grep nginx  访问\nhttp://centos7init:8888/  查看开放的端口号\nfirewall-cmd --list-all  设置开放的端口号\nfirewall-cmd --add-service=http –permanent firewall-cmd --add-port=8888/tcp --permanent  重启防火墙\nfirewall-cmd –reload  常用命令 cd /usr/local/nginx/sbin  查看nginx 版本号\n./nginx -v  启动 nginx\n./nginx  停止 nginx\n./nginx -s stop  重新加载 ngin\n./nginx -s reload  Nginx 的配置文件 配置文件位置\ncd /usr/local/nginx/conf/nginx.conf  配置文件中的内容 包含三部分内容\n全局块：\n从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。配置服务器整体运行的配置指令\n worker_processes 1;  这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约\nevents 块\nevents 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。\n影响 Nginx 服务器与用户的网络连接\n worker_connections 1024;  支持的最大连接数为 1024\nhttp 块\nhttp 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等.\n这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。 而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。\nhttp 全局块\n最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置\nserver 块\n这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。\n反向代理 实现效果：使用 nginx 反向代理，访问 www.123.com 直接跳转到 127.0.0.1:8080\n启动tomcat\nwindow配置域名解析centos7init\n配置nginx\n server { listen 80;//监听的端口号 server_name 192.168.2.150;//centos7ip地址 #charset koi8-r; #access_log logs/host.access.log main; location / { root html; proxy_pass http://127.0.0.1:8889;//代理ip index index.html index.htm; }  访问\nhttp://centos7init/  win10主机访问centos7init:80其实访问的是centos7ip地址:80;被nginx监听到(80端口，listen 80)反向代理到(http://127.0.0.1:8889)\n实现效果：使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中\nnginx 监听端口为 9001，\n访问 http://127.0.0.1:9001/edu/ 直接跳转到 127.0.0.1:8080\n访问 http://127.0.0.1:9001/vod/ 直接跳转到 127.0.0.1:8081\n配置两个tomcat\n配置nginx\n server { listen 9001; server_name 192.168.2.150; location ~ /edu/ { proxy_pass http://127.0.0.1:8080; } location ~ /vod/ { proxy_pass http://127.0.0.1:8081; } }  测试\nhttp://centos7init:9001/vod/index.html http://centos7init:9001/edu/index.html  语法\nlocal [ = | ~ | ~* | ^~] uri { }   = ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。\n ~：用于表示 uri 包含正则表达式，并且区分大小写。\n ~*：用于表示 uri 包含正则表达式，并且不区分大小写。\n ^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。\n  注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。\n负载均衡 首先准备两个同时启动的 Tomcat在两台 tomcat 里面 webapps 目录中，创建名称是 edu 文件夹，在 edu 文件夹中创建页面 index.html，用于测试\n在 nginx.conf 中进行配置\nhttp { #gzip on; # 负载均衡 upstream myserver{ server 192.168.2.150:8080; server 192.168.2.150:8081; }   server { listen 80; server_name 192.168.2.150; location / { # proxy_pass http://127.0.0.1:8889; # 负载均衡 proxy_pass http://myserver; index index.html index.htm; }  访问\nhttp://centos7init/edu/index.html  nginx 分配服务器策略 第一种 轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。\n第二种 weight weight 代表权重默认为 1,权重越高被分配的客户端越多\nupstream myserver{ server 192.168.2.150:8080 weight=10; server 192.168.2.150:8081 weight=10; }  第三种 ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器\nupstream myserver{ ip_hash; server 192.168.2.150:8080; server 192.168.2.150:8081; }  第四种 fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。\nupstream myserver{ server 192.168.2.150:8080; server 192.168.2.150:8081; fair; }  动静分离 Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用 Nginx 处理静态页面，Tomcat 处理动态页面。动静分离从目前实现角度来讲大致分为两种，一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；\n另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304，如果有修改，则直接从服务器重新下载，返回状态码 200。\n使用 在本地根目录路径新建文件夹edu文件夹下新建www(index.html)和image(54.jpg)文件夹\n配置nginx\n\tserver { listen 80; server_name 192.168.2.150; location /www/{ # 浏览器访问xx.xx.xx.xx/www/ root /edu/; #访问/edu/路径 index index.html index.htm; } location /image/{# 浏览器访问xx.xx.xx.xx/image/ root /edu/; # 访问/edu/路径 autoindex on;//将文件列出 }  测试\nhttp://centos7init/www/index.html/ http://centos7init/image/  Nginx配置高可用的集群 配置 两台服务器分别安装nginx\n分别安装keepalived\nyum install keepalived –y  安装之后，在etc里面生成目录keepalived，有文件keepalived.conf\ncd /etc/keepalived vi keepalived.conf  修改为\nglobal_defs {# 全局定义 notification_email { acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc } notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.17.129 smtp_connect_timeout 30 router_id LVS_DEVEL # 访问到主机 /etc/hosts文件 （127.0.0.1 LVS_DEVEL） } vrrp_script chk_http_port { script \u0026quot;/usr/local/src/nginx_check.sh\u0026quot; interval 2 #（检测脚本执行的间隔2s） weight 2 #权重 } vrrp_instance VI_1 { state MASTER # 备份服务器上将 MASTER 改为 BACKUP interface ens33 //网卡 通过ifconfig获得 virtual_router_id 51 # 主、备机的 virtual_router_id 必须相同 priority 100 # 主、备机取不同的优先级，主机值较大(100)，备份机值较小(90) advert_int 1 authentication { auth_type PASS # 校验方式为密码 1111 auth_pass 1111 } virtual_ipaddress { 192.168.17.50 // VRRP H 虚拟地址 } }  /usr/local/src/nginx_check.sh脚本文件\n#!/bin/bash A=`ps -C nginx –no-header |wc -l` if [ $A -eq 0 ];then /usr/local/nginx/sbin/nginx #nginx启动路径 sleep 2 if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then killall keepalived fi fi  从服务器\nglobal_defs {# 全局定义 notification_email { acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc } notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.17.129 smtp_connect_timeout 30 router_id LVS_DEVEL } vrrp_script chk_http_port { script \u0026quot;/usr/local/src/nginx_check.sh\u0026quot; interval 2 #（检测脚本执行的间隔） weight 2 } vrrp_instance VI_1 { state BACKUP # 备份服务器上将 MASTER 改为 BACKUP interface ens33 //网卡 通过ifconfig获得 virtual_router_id 51 # 主、备机的 virtual_router_id 必须相同 priority 90 # 主、备机取不同的优先级，主机值较大(100)，备份机值较小(90) advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.17.50 // VRRP H 虚拟地址 } }  脚本/usr/local/src/nginx_check.sh\n#!/bin/bash A=`ps -C nginx –no-header |wc -l` if [ $A -eq 0 ];then /usr/local/nginx/sbin/nginx #nginx启动路径 sleep 2 if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then killall keepalived fi fi  把两台服务器上 nginx 和 keepalived 启动\n启动 nginx：\n./nginx  启动 keepalived：\nsystemctl start keepalived.service  最终测试 在浏览器地址栏输入 虚拟 ip 地址\n192.168.17.50  查看虚拟ip绑定\nip a  把主服务器（192.168.17.129）nginx 和 keepalived 停止，再输入\n192.168.17.50  查看虚拟ip绑定\nip a  Nginx的原理 master-workers 的机制的好处\n首先，对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的worker 进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。\n需要设置多少个 worker\nNginx 同 redis 类似都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话下。每个 worker 的线程可以把一个 cpu 的性能发挥到极致。所以 worker 数和服务器的 cpu数相等是最为适宜的。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。\n设置worker 数量\nworker_processes 4 \\#work 绑定 cpu(4 work 绑定 4cpu)。 worker_cpu_affinity 0001 0010 0100 1000 \\#work 绑定 cpu (4 work 绑定 8cpu 中的 4 个) 。 worker_cpu_affinity 0000001 00000010 00000100 00001000  连接数 worker_connection\n这个值是表示每个 worker 进程所能建立连接的最大值，所以，一个 nginx 能建立的最大连接数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP 请 求 本 地 资 源 来 说 ， 能 够 支 持 的 最 大 并 发 数 量 是 worker_connections * worker_processes，如果是支持 http1.1 的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是： worker_connections * worker_processes /2，而如果是 HTTP 作 为反向代理来说，最大并发数量应该是 worker_connections * worker_processes/4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。\n","id":12,"section":"posts","summary":"Nginx nginx 简介 什么是 nginx 和可以做什么事情 Nginx 是高性能的 HTTP 和反向代理的服务器，处理高并发能力是十分强大的，能经受高负载的考验,有报告表明能支持高达 50,000 个并","tags":["J2EE"],"title":"Nginx进阶学习笔记","uri":"https://mumulx.github.io/2020/03/nginx%E7%AC%94%E8%AE%B0/","year":"2020"},{"content":" SpringSecurity 官网:\nSpringSecurity是强大的，且容易定制的实现认证，与授权的基于Spring 开发的框架。\nSpring Security的核心功能\n Authentication:认证，用户登陆的验证(解决你是谁的问题) Authorization: 授权，授权资源的访问权限(解决你能干什么的问题) 安全防护，防止跨站请求，session 攻击等  springsecurity与shiro\n 使用的方便度(shiro) 社区支持比较(几乎持平) 功能丰富性(spring security)  如果你只是想实现一个简单的web应用，shiro更 加的轻量级，学习成本也更低。如果您正在开发一个分布式的、微服务的、或者与Spring Cloud系列框架深度集成的项目，还是建议使用Spring Security。\n需求分析与环境准备  login.html登录页面，登录页面访问不受限制 在登录页面登录之后，进入index.html首页(登录验证Authentication) 首页可以看到syslog、sysuer. biz1. biz2四个页面选项 我们希望syslog (日志管理)和sysuser(用户管理)只有admin管理员可以访问(权限管理Authorization) biz1、 biz2普通的操作用户auser就可以访问(权限管理Authorization)  起一个新的spring boot2.0版本的web应用\n集成mybatis、lombok\n搭建\n添加依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  配置\n新建配置类SecurityConfig\n@Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.httpBasic() .and() .authorizeRequests().anyRequest() .authenticated(); } }  这样启动后访问\nhttp://localhost:8888/login.html  会让我们输入用户名密码\n用户名：user\n密码在控制台\n想要自定义密码\n添加配置，在spring下\n security: user: name: admin password: admin  H TTPBASIC模式登录认证 使用postman模拟访问\n新建get请求\nhttp://localhost:8888/index  Authorization\nType：Basic Auth\nusername：admin\npassword：admin\n查看响应，可以看到我们的html代码\n观察headers\nAuthorization：YWRtaW46YWRtaW4=\n搜索base64加密解密\nYWRtaW46YWRtaW4=\n可以解密密码\nadmin:admin\n这种方式时不安全的\nFORMLOGIN表单登录认证模式 三要素\n 登录认证逻辑(静态) 资源访问控制(动态) 用户角色权限(动态)  认证的方式有两种：权限、角色\n二者都可是实现\n配置类SecurityConfig\n@Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().disable()//关掉csrf，否则会将我们的请求当作是一个不合法的 .formLogin() //逻辑 .loginPage(\u0026quot;/login.html\u0026quot;)//登陆页面位置 .usernameParameter(\u0026quot;username\u0026quot;)//表单用户名name .passwordParameter(\u0026quot;password\u0026quot;)//表单密码name .loginProcessingUrl(\u0026quot;/login\u0026quot;)// 登录验证请求 post方式的表单action .defaultSuccessUrl(\u0026quot;/index\u0026quot;)//成功后的跳转页面 .failureUrl(\u0026quot;/login.html\u0026quot;) .and() //控制 .authorizeRequests() .antMatchers(\u0026quot;/login.html\u0026quot;,\u0026quot;login\u0026quot;).permitAll()//哪些请求不需要验证 .antMatchers(\u0026quot;/biz1\u0026quot;,\u0026quot;/biz2\u0026quot;)//需要对外暴漏的资源的路径，user用户和admin用户可以访问 .hasAnyAuthority(\u0026quot;ROLE_user\u0026quot;,\u0026quot;ROLE_admin\u0026quot;)//user用户和admin用户 权限 .antMatchers(\u0026quot;/syslog\u0026quot;,\u0026quot;/sususer\u0026quot;) // .antMatchers(\u0026quot;/syslog\u0026quot;).hasAuthority(\u0026quot;sys:log\u0026quot;)//通过权限进行配置 //.antMatchers(\u0026quot;/sysuser\u0026quot;).hasAuthority(\u0026quot;sys:user\u0026quot;) 前面是资源，后面是资源id .hasAnyRole(\u0026quot;admin\u0026quot;)//admin用户可以访问 .hasAnyAuthority(\u0026quot;ROLE_admin\u0026quot;)，另一种写法 角色 .anyRequest().authenticated() ; } //静态配置了两个用户 @Override public void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\u0026quot;user\u0026quot;)//用户user .password(passwordEncoder().encode(\u0026quot;123456\u0026quot;))//密码 .roles(\u0026quot;user\u0026quot;)//角色 .and() .withUser(\u0026quot;admin\u0026quot;)//用户 .password(passwordEncoder().encode(\u0026quot;123456\u0026quot;))//密码 //.authorities(\u0026quot;sys:log\u0026quot;,\u0026quot;sys:user\u0026quot;)权限 当用户有这个资源的id就可以访问这个资源，用户没有这个资源的id就不能访问这个资源 .roles(\u0026quot;admin\u0026quot;)//角色 .and() .passwordEncoder(passwordEncoder());//配置BCrypt加密 } @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } @Override public void configure(WebSecurity web) { //将项目中静态资源路径开放出来 web.ignoring() .antMatchers( \u0026quot;/css/**\u0026quot;, \u0026quot;/fonts/**\u0026quot;, \u0026quot;/img/**\u0026quot;, \u0026quot;/js/**\u0026quot;); } }  \u0026lt;form action=\u0026quot;/login\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;span\u0026gt;用户名称\u0026lt;/span\u0026gt;\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;username\u0026quot; /\u0026gt; \u0026lt;br\u0026gt; \u0026lt;span\u0026gt;用户密码\u0026lt;/span\u0026gt;\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;password\u0026quot; /\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;登陆\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  通过以下与表单进行绑定，表单的请求方式必须是post\n.usernameParameter(\u0026quot;username\u0026quot;)//表单用户名name .passwordParameter(\u0026quot;password\u0026quot;)//表单密码name .loginProcessingUrl(\u0026quot;/login\u0026quot;)// 登录验证请求 post方式的表单action  不需要我们进行登录用户名和密码的校验，springsecurity在我们请求时，自动帮我们进行认证处理\n测试\n访问\nhttp://localhost:8888/login.html  使用admin:admin进行登录，发现是可以全部访问的\n切换用户，user:123456\n只能访问业务一、业务二\n登录认证流程源码解析 public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter { //定义了默认的用户名密码name public static final String SPRING_SECURITY_FORM_USERNAME_KEY = \u0026quot;username\u0026quot;; public static final String SPRING_SECURITY_FORM_PASSWORD_KEY = \u0026quot;password\u0026quot;; private String usernameParameter = \u0026quot;username\u0026quot;; private String passwordParameter = \u0026quot;password\u0026quot;; private boolean postOnly = true; public UsernamePasswordAuthenticationFilter() { super(new AntPathRequestMatcher(\u0026quot;/login\u0026quot;, \u0026quot;POST\u0026quot;)); } public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException { //指定请求为post请求 if (this.postOnly \u0026amp;\u0026amp; !request.getMethod().equals(\u0026quot;POST\u0026quot;)) { throw new AuthenticationServiceException(\u0026quot;Authentication method not supported: \u0026quot; + request.getMethod()); } else { String username = this.obtainUsername(request); String password = this.obtainPassword(request); if (username == null) { username = \u0026quot;\u0026quot;; } if (password == null) { password = \u0026quot;\u0026quot;; } username = username.trim(); //构建了一个登录令牌，通过用户名密码 UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password); this.setDetails(request, authRequest); //返回一个登录认证的主体对象，贯穿过滤器，对它进行登录认证 return this.getAuthenticationManager().authenticate(authRequest); } }  public interface AuthenticationManager { //该方法进行认证 Authentication authenticate(Authentication var1) throws AuthenticationException; }  //实现了AuthenticationManager接口 public class ProviderManager implements AuthenticationManager, MessageSourceAware, InitializingBean { //存储了很多登录认证的实例 private List\u0026lt;AuthenticationProvider\u0026gt; providers;  AuthenticationProvider是一个接口，很多登录认证的方式实现了该接口  DaoAuthenticationProvider//从数据库加载信息 //加载信息 UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username);  过滤器\npublic class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter {  public abstract class AbstractAuthenticationProcessingFilter extends GenericFilterBean implements ApplicationEventPublisherAware, MessageSourceAware { //成功 private AuthenticationSuccessHandler successHandler = new SavedRequestAwareAuthenticationSuccessHandler(); //失败 private AuthenticationFailureHandler failureHandler = new SimpleUrlAuthenticationFailureHandler();  自定义登录验证结果处理 登陆成功的自定义结果处理接口: AuthenticationSuccesstlandler 登陆失败的自定义结果处理接口: AuthenticationfailureHandler  AuthenticationSuccesstlandler\n配置\n@Component public class MyAuthenticationSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler { @Value(\u0026quot;${spring.security.loginType}\u0026quot;) private String loginType; private static ObjectMapper objectMapper = new ObjectMapper(); @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws ServletException, IOException { if(loginType.equalsIgnoreCase(\u0026quot;JSON\u0026quot;)){ response.setContentType(\u0026quot;application/json;charset=UTF-8\u0026quot;); response.getWriter().write(objectMapper.writeValueAsString( AjaxResponse.success(\u0026quot;/index\u0026quot;) )); }else{ //跳转到登陆之前请求的页面 super.onAuthenticationSuccess(request,response,authentication); } } }  封装json\n@Data public class AjaxResponse { private boolean isok; private int code; private String message; private Object data; private AjaxResponse() { } //请求出现异常时的响应数据封装 public static AjaxResponse error(CustomException e) { AjaxResponse resultBean = new AjaxResponse(); resultBean.setIsok(false); resultBean.setCode(e.getCode()); if(e.getCode() == CustomExceptionType.USER_INPUT_ERROR.getCode()){ resultBean.setMessage(e.getMessage()); }else if(e.getCode() == CustomExceptionType.SYSTEM_ERROR.getCode()){ resultBean.setMessage(e.getMessage() + \u0026quot;,系统出现异常，请联系管理员电话：1375610xxxx进行处理!\u0026quot;); }else{ resultBean.setMessage(\u0026quot;系统出现未知异常，请联系管理员电话：13756108xxx进行处理!\u0026quot;); } return resultBean; } public static AjaxResponse success() { AjaxResponse resultBean = new AjaxResponse(); resultBean.setIsok(true); resultBean.setCode(200); resultBean.setMessage(\u0026quot;success\u0026quot;); return resultBean; } public static AjaxResponse success(Object data) { AjaxResponse resultBean = new AjaxResponse(); resultBean.setIsok(true); resultBean.setCode(200); resultBean.setMessage(\u0026quot;success\u0026quot;); resultBean.setData(data); return resultBean; } }  添加配置\nsecurity: loginType: JSON  SecurityConfig\n@Resource MyAuthenticationSuccessHandler myAuthenticationSuccessHandler; //.defaultSuccessUrl(\u0026quot;/index\u0026quot;)//成功后的跳转页面 .failureUrl(\u0026quot;/login.html\u0026quot;) .successHandler(myAuthenticationSuccessHandler)//不能与defaultSuccessUrl一起使用  测试\n访问\nhttp://localhost:8888/syslog  会自动跳转到login.html\n输入用户名密码user:123456\n相应\n{ isok: true, code: 200, message: \u0026quot;success\u0026quot;, data: \u0026quot;/index\u0026quot; }  将json改为html\n security: loginType: html  访问\nhttp://localhost:8888/syslog  自动跳转到ligin.html\n登录用户名密码admin:123456\n会直接跳转到\nhttp://localhost:8888/syslog  会返回上一次的请求路径\n配置生效\nsuper.onAuthenticationSuccess(request,response,authentication);  配置登录失败的请求\n配置类\n@Component public class MyAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler { @Value(\u0026quot;${spring.security.loginType}\u0026quot;) private String loginType; private static ObjectMapper objectMapper = new ObjectMapper(); public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException { String errorMsg = \u0026quot;用户名或者密码输入错误!\u0026quot;; if(exception instanceof SessionAuthenticationException){ errorMsg = exception.getMessage(); } if(loginType.equalsIgnoreCase(\u0026quot;JSON\u0026quot;)){ response.setContentType(\u0026quot;application/json;charset=UTF-8\u0026quot;); response.getWriter().write(objectMapper.writeValueAsString( AjaxResponse.error(new CustomException( CustomExceptionType.USER_INPUT_ERROR, errorMsg)) )); }else{ //跳转到登陆页面 super.onAuthenticationFailure(request,response,exception); } } }  //.defaultSuccessUrl(\u0026quot;/index\u0026quot;)//成功后的跳转页面 //.failureUrl(\u0026quot;/login.html\u0026quot;) .successHandler(myAuthenticationSuccessHandler)//不能与defaultSuccessUrl一起使用 .failureHandler(myAuthenticationFailureHandler)  更改为JSON方式而不是html方式\n security: loginType: JSON  login.html修改\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026quot;https://cdn.staticfile.org/jquery/1.12.3/jquery.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;业务系统登录\u0026lt;/h1\u0026gt; \u0026lt;form action=\u0026quot;/login\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;span\u0026gt;用户名称\u0026lt;/span\u0026gt;\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;username\u0026quot; id=\u0026quot;username\u0026quot;/\u0026gt; \u0026lt;br\u0026gt; \u0026lt;span\u0026gt;用户密码\u0026lt;/span\u0026gt;\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;password\u0026quot; id=\u0026quot;password\u0026quot;/\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; onclick=\u0026quot;login()\u0026quot; value=\u0026quot;登陆\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; function login() { var username = $(\u0026quot;#username\u0026quot;).val(); var password = $(\u0026quot;#password\u0026quot;).val(); if (username === \u0026quot;\u0026quot; || password === \u0026quot;\u0026quot;) { alert('用户名或密码不能为空'); return; } $.ajax({ type: \u0026quot;POST\u0026quot;, url: \u0026quot;/login\u0026quot;, data: { \u0026quot;username\u0026quot;: username, \u0026quot;password\u0026quot;: password, }, success: function (json) { if(json.isok){ location.href = json.data; }else{ alert(json.message) } }, error: function (e) { console.log(e.responseText); } }); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  SESSION管理及安全 Spring Security与session的创建使用\n always:如果当前请求没有session存在，Spring Security创建一个session。 never: Spring Security将永远不会主动创建session,但是如果session已经存 在，它将使用该session ifRequired (默认) :: Spring Security在需要时才创建session stateless: Spring Security不会创建或使用任何session。适合于接口型的无状态应用，该方式节省资源。  配置\n.and().sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)  会话超时配置 server.servlet.session.timeout= 15m //springboot spring.session.timeout = 15m\t 配置\nserver: port: 8888 servlet: session: timeout: 10s  .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED) .invalidSessionUrl(\u0026quot;/login/html\u0026quot;)//超时后返回登录页面  session保护  默认情况下，Spring Security启用了migrationSession保护方式。即对于同一个cookies的SESSIONID用户，每次登录验证将创建一个新的HTTP会话，旧的HTTP会话将无效，并且旧会话的属性将被复制。 设置为“none”时，原始会话不会无效 设置“newSession”后，将创建一个干净的会话，而不会复制旧会话中的任何属性  配置\n.invalidSessionUrl(\u0026quot;/login/html\u0026quot;)//超时后返回登录页面 .sessionFixation().migrateSession()//session保护  Cookie的安全  httpOnly:如果为true,则浏览器脚本将无法访问cookie secure:如果为true,则仅通过HTTPS连接发送cookie, HTTP无法携带cookie。  配置\nsession: timeout: 10s cookie: http-only: true secure: false  限制最大登录用户数量 实现SessionInformationExpiredStrategy接口\n配置\n.sessionFixation().migrateSession()//session保护 .maximumSessions(1) .maxSessionsPreventsLogin(false)//true:登录之后不能再登录，false：允许再次登录，但是前一次登录会下线 .expiredSessionStrategy(new MyExpiredSessionStrategy())//超时session响应策略  实现接口\npublic class MyExpiredSessionStrategy implements SessionInformationExpiredStrategy { private static ObjectMapper objectMapper = new ObjectMapper(); //session超时后会调用 @Override public void onExpiredSessionDetected(SessionInformationExpiredEvent event) throws IOException, ServletException { Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026quot;code\u0026quot;,0); map.put(\u0026quot;msg\u0026quot;,\u0026quot;您已经在另外一台电脑或浏览器登录，被迫下线！\u0026quot;); event.getResponse().setContentType(\u0026quot;application/json;charset=UTF-8\u0026quot;); event.getResponse().getWriter().write( objectMapper.writeValueAsString(map) ); } }  两个浏览器登录同一个用户，第一个用户会显示\n{ msg: \u0026quot;您已经在另外一台电脑或浏览器登录，被迫下线！\u0026quot;, code: 0 }  RBAC权限管理模型 Role-Based Access Control\n 用户:系统接口及访问的操作者 权限:能够访问某接口或者做某操作的授权资格 角色:具有一类相同操作权限的用户的总称  用户-一对多-\u0026gt;角色-多对多-\u0026gt;权限\n创建表格\n-- 导出 表 devicedb.sys_menu 结构 CREATE TABLE IF NOT EXISTS `sys_menu` ( `id` int(11) NOT NULL AUTO_INCREMENT, `menu_pid` int(11) NOT NULL COMMENT '父菜单ID', `menu_pids` varchar(64) NOT NULL COMMENT '当前菜单所有父菜单', `is_leaf` tinyint(4) NOT NULL COMMENT '0:不是叶子节点，1:是叶子节点', `menu_name` varchar(16) NOT NULL COMMENT '菜单名称', `url` varchar(64) DEFAULT NULL COMMENT '跳转URL', `icon` varchar(45) DEFAULT NULL, `icon_color` varchar(16) DEFAULT NULL, `sort` tinyint(4) DEFAULT NULL COMMENT '排序', `level` tinyint(4) NOT NULL COMMENT '菜单层级', `status` tinyint(4) NOT NULL COMMENT '0:启用,1:禁用', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COMMENT='系统菜单表'; -- 正在导出表 devicedb.sys_menu 的数据：~5 rows (大约) /*!40000 ALTER TABLE `sys_menu` DISABLE KEYS */; INSERT INTO `sys_menu` (`id`, `menu_pid`, `menu_pids`, `is_leaf`, `menu_name`, `url`, `icon`, `icon_color`, `sort`, `level`, `status`) VALUES (1, 0, '0', 0, '系统管理', NULL, NULL, NULL, 1, 1, 0), (2, 1, '1', 1, '用户管理', '/sysuser', NULL, NULL, 1, 2, 0), (3, 1, '1', 1, '日志管理', '/syslog', NULL, NULL, 2, 2, 0), (4, 1, '1', 1, '业务一', '/biz1', NULL, NULL, 3, 2, 0), (5, 1, '1', 1, '业务二', '/biz2', NULL, NULL, 4, 2, 0); /*!40000 ALTER TABLE `sys_menu` ENABLE KEYS */; -- 导出 表 devicedb.sys_org 结构 CREATE TABLE IF NOT EXISTS `sys_org` ( `id` int(11) NOT NULL AUTO_INCREMENT, `org_pid` int(11) NOT NULL COMMENT '上级组织编码', `org_pids` varchar(64) NOT NULL COMMENT '所有的父节点id', `is_leaf` tinyint(4) NOT NULL COMMENT '0:不是叶子节点，1:是叶子节点', `org_name` varchar(32) NOT NULL COMMENT '组织名', `address` varchar(64) DEFAULT NULL COMMENT '地址', `phone` varchar(13) DEFAULT NULL COMMENT '电话', `email` varchar(32) DEFAULT NULL COMMENT '邮件', `sort` tinyint(4) DEFAULT NULL COMMENT '排序', `level` tinyint(4) NOT NULL COMMENT '组织层级', `status` tinyint(4) NOT NULL COMMENT '0:启用,1:禁用', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8 COMMENT='系统组织结构表'; -- 正在导出表 devicedb.sys_org 的数据：~4 rows (大约) /*!40000 ALTER TABLE `sys_org` DISABLE KEYS */; INSERT INTO `sys_org` (`id`, `org_pid`, `org_pids`, `is_leaf`, `org_name`, `address`, `phone`, `email`, `sort`, `level`, `status`) VALUES (1, 0, '0', 0, '总部', NULL, NULL, NULL, 1, 1, 0), (2, 1, '1', 0, '研发部', NULL, NULL, NULL, 1, 2, 0), (3, 2, '1,2', 1, '研发一部', NULL, NULL, NULL, 1, 3, 0), (4, 2, '1,2', 1, '研发二部', NULL, NULL, NULL, 2, 3, 0); /*!40000 ALTER TABLE `sys_org` ENABLE KEYS */; -- 导出 表 devicedb.sys_role 结构 CREATE TABLE IF NOT EXISTS `sys_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `role_name` varchar(32) NOT NULL DEFAULT '0' COMMENT '角色名称(汉字)', `role_desc` varchar(128) NOT NULL DEFAULT '0' COMMENT '角色描述', `role_code` varchar(32) NOT NULL DEFAULT '0' COMMENT '角色的英文code.如：ADMIN', `sort` int(11) NOT NULL DEFAULT '0' COMMENT '角色顺序', `status` int(11) DEFAULT NULL COMMENT '0表示可用', `create_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '角色的创建日期', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='系统角色表'; -- 正在导出表 devicedb.sys_role 的数据：~2 rows (大约) /*!40000 ALTER TABLE `sys_role` DISABLE KEYS */; INSERT INTO `sys_role` (`id`, `role_name`, `role_desc`, `role_code`, `sort`, `status`, `create_time`) VALUES (1, '管理员', '管理员', 'admin', 1, 0, '2019-12-23 22:56:48'), (2, '普通用户', '普通用户', 'common', 2, 0, '2019-12-23 22:57:22'); /*!40000 ALTER TABLE `sys_role` ENABLE KEYS */; -- 导出 表 devicedb.sys_role_menu 结构 CREATE TABLE IF NOT EXISTS `sys_role_menu` ( `id` int(11) NOT NULL AUTO_INCREMENT, `role_id` int(11) NOT NULL DEFAULT '0' COMMENT '角色id', `menu_id` int(11) NOT NULL DEFAULT '0' COMMENT '权限id', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8 COMMENT='角色权限关系表'; -- 正在导出表 devicedb.sys_role_menu 的数据：~4 rows (大约) /*!40000 ALTER TABLE `sys_role_menu` DISABLE KEYS */; INSERT INTO `sys_role_menu` (`id`, `role_id`, `menu_id`) VALUES (1, 1, 2), (2, 1, 3), (3, 2, 4), (4, 2, 5); /*!40000 ALTER TABLE `sys_role_menu` ENABLE KEYS */; -- 导出 表 devicedb.sys_user 结构 CREATE TABLE IF NOT EXISTS `sys_user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(64) NOT NULL DEFAULT '0' COMMENT '用户名', `password` varchar(64) NOT NULL DEFAULT '0' COMMENT '密码', `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间', `org_id` int(11) NOT NULL COMMENT '组织id', `enabled` int(11) DEFAULT NULL COMMENT '0无效用户，1是有效用户', `phone` varchar(16) DEFAULT NULL COMMENT '手机号', `email` varchar(32) DEFAULT NULL COMMENT 'email', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='用户信息表'; -- 正在导出表 devicedb.sys_user 的数据：~2 rows (大约) /*!40000 ALTER TABLE `sys_user` DISABLE KEYS */; INSERT INTO `sys_user` (`id`, `username`, `password`, `create_time`, `org_id`, `enabled`, `phone`, `email`) VALUES (1, 'yanfa1', '$2a$10$xPNoI0sBxOY6Y5Nj1bF6iO6OePqJ8tAJUsD5x5wh6G1BPphhSLcae', '2019-12-24 01:10:14', 3, 1, NULL, NULL), (2, 'admin', '$2a$10$xPNoI0sBxOY6Y5Nj1bF6iO6OePqJ8tAJUsD5x5wh6G1BPphhSLcae', '2019-12-24 01:10:18', 1, 1, NULL, NULL); /*!40000 ALTER TABLE `sys_user` ENABLE KEYS */; -- 导出 表 devicedb.sys_user_role 结构 CREATE TABLE IF NOT EXISTS `sys_user_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `role_id` int(11) NOT NULL DEFAULT '0' COMMENT '角色自增id', `user_id` int(11) NOT NULL DEFAULT '0' COMMENT '用户自增id', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='用户角色关系表'; -- 正在导出表 devicedb.sys_user_role 的数据：~2 rows (大约) /*!40000 ALTER TABLE `sys_user_role` DISABLE KEYS */; INSERT INTO `sys_user_role` (`id`, `role_id`, `user_id`) VALUES (1, 2, 1), (2, 1, 2);  动态加载数据库数据进行认证与授权 UserDetailsService接 口有一个方法叫做loadUserByUsername, 我们实现动态加载用户、角色、权限信息就是通过实现该方法。函数见名知义:通过用户名加载用户。该方法的返回值就是UserDetails。，UserDetails就是用户信息，即:用户名、密码、该用户所具有的权限。\npublic interface UserDetails extends Serializable { //获取用户的权限集合 Collection\u0026lt;? extends GrantedAuthority\u0026gt; getAuthorities(); //获取密码 String getPassword(); //获取用户名 String getUsername(); //账号是否过期 boolean isAccountNonExpired(); //账号是否被锁定 boolean isAccountNonLocked(); //密码是否过期 boolean isCredentialsNonExpired(); //账号是否可用 boolean isEnabled(); }  配置mybatis\n依赖\n\u0026lt;!--mysql--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 数据源依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  配置\n@SpringBootApplication @MapperScan(basePackages = {\u0026quot;com.mumulx\u0026quot;})//mapper扫描包 public class BasicServerApplication {  spring: datasource: url: jdbc:mysql://localhost:3306/testdb?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;useSSL=false username: root password: xxx driver-class-name: org.gjt.mm.mysql.Driver type: com.alibaba.druid.pool.DruidDataSource  将之前的静态用户密码删除\n# user: # name: admin # password: admin  通过测试类获取加密密码字段插入数据库\n@RunWith(SpringRunner.class) @SpringBootTest public class BootLaunchApplicationTests { @Resource PasswordEncoder passwordEncoder; @Test public void contextLoads() { System.out.println(passwordEncoder.encode(\u0026quot;123456\u0026quot;)); } }  类\npublic class MyUserDetails implements UserDetails { String password; //密码 String username; //用户名 boolean accountNonExpired; //是否没过期 boolean accountNonLocked; //是否没被锁定 boolean credentialsNonExpired; //是否没过期 boolean enabled; //账号是否可用 Collection\u0026lt;? extends GrantedAuthority\u0026gt; authorities; //用户的权限集合 @Override public Collection\u0026lt;? extends GrantedAuthority\u0026gt; getAuthorities() { return authorities; } @Override public String getPassword() { return password; } @Override public String getUsername() { return username; } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return true; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return enabled; } public void setPassword(String password) { this.password = password; } public void setUsername(String username) { this.username = username; } public void setAccountNonExpired(boolean accountNonExpired) { this.accountNonExpired = accountNonExpired; } public void setAccountNonLocked(boolean accountNonLocked) { this.accountNonLocked = accountNonLocked; } public void setCredentialsNonExpired(boolean credentialsNonExpired) { this.credentialsNonExpired = credentialsNonExpired; } public void setEnabled(boolean enabled) { this.enabled = enabled; } public void setAuthorities(Collection\u0026lt;? extends GrantedAuthority\u0026gt; authorities) { this.authorities = authorities; } }  public interface MyUserDetailsServiceMapper { //根据userID查询用户信息 @Select(\u0026quot;SELECT username,password,enabled\\n\u0026quot; + \u0026quot;FROM sys_user u\\n\u0026quot; + \u0026quot;WHERE u.username = #{userId} or u.phone = #{userId}\u0026quot;) MyUserDetails findByUserName(@Param(\u0026quot;userId\u0026quot;) String userId); //根据userID查询用户角色列表 @Select(\u0026quot;SELECT role_code\\n\u0026quot; + \u0026quot;FROM sys_role r\\n\u0026quot; + \u0026quot;LEFT JOIN sys_user_role ur ON r.id = ur.role_id\\n\u0026quot; + \u0026quot;LEFT JOIN sys_user u ON u.id = ur.user_id\\n\u0026quot; + \u0026quot;WHERE u.username = #{userId} or u.phone = #{userId}\u0026quot;) List\u0026lt;String\u0026gt; findRoleByUserName(@Param(\u0026quot;userId\u0026quot;) String userId); //根据用户角色查询用户权限 @Select({ \u0026quot;\u0026lt;script\u0026gt;\u0026quot;, \u0026quot;SELECT url \u0026quot; , \u0026quot;FROM sys_menu m \u0026quot; , \u0026quot;LEFT JOIN sys_role_menu rm ON m.id = rm.menu_id \u0026quot; , \u0026quot;LEFT JOIN sys_role r ON r.id = rm.role_id \u0026quot;, \u0026quot;WHERE r.role_code IN \u0026quot;, \u0026quot;\u0026lt;foreach collection='roleCodes' item='roleCode' open='(' separator=',' close=')'\u0026gt;\u0026quot;, \u0026quot;#{roleCode}\u0026quot;, \u0026quot;\u0026lt;/foreach\u0026gt;\u0026quot;, \u0026quot;\u0026lt;/script\u0026gt;\u0026quot; }) List\u0026lt;String\u0026gt; findAuthorityByRoleCodes(@Param(\u0026quot;roleCodes\u0026quot;) List\u0026lt;String\u0026gt; roleCodes); }  @Component public class MyUserDetailsService implements UserDetailsService { @Resource private MyUserDetailsServiceMapper myUserDetailsServiceMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { //加载基础用户信息 MyUserDetails myUserDetails = myUserDetailsServiceMapper.findByUserName(username); //加载用户角色列表 List\u0026lt;String\u0026gt; roleCodes = myUserDetailsServiceMapper.findRoleByUserName(username); //通过用户角色列表加载用户的资源权限列表 List\u0026lt;String\u0026gt; authorties = myUserDetailsServiceMapper.findAuthorityByRoleCodes(roleCodes); //角色是一个特殊的权限，ROLE_前缀 roleCodes = roleCodes.stream() .map(rc -\u0026gt; \u0026quot;ROLE_\u0026quot; +rc) .collect(Collectors.toList()); authorties.addAll(roleCodes); myUserDetails.setAuthorities( AuthorityUtils.commaSeparatedStringToAuthorityList( String.join(\u0026quot;,\u0026quot;,authorties) ) ); return myUserDetails; } }  配置\nSecurityConfig\n@Resource MyUserDetailsService myUserDetailsService; @Override public void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(myUserDetailsService) .passwordEncoder(passwordEncoder()); }  //.antMatchers(\u0026quot;/syslog\u0026quot;,\u0026quot;/sususer\u0026quot;) //.hasAnyRole(\u0026quot;admin\u0026quot;)//admin用户可以访问 .hasAnyAuthority(\u0026quot;ROLE_admin\u0026quot;)，另一种写法 角色 .antMatchers(\u0026quot;/syslog\u0026quot;).hasAuthority(\u0026quot;/sys_log\u0026quot;)//通过权限进行配置 .antMatchers(\u0026quot;/sysuser\u0026quot;).hasAuthority(\u0026quot;/sys_user\u0026quot;) //前面是资源，后面是资源id  测试\n动态加载资源鉴权规则 将\n.antMatchers(\u0026quot;/biz1\u0026quot;,\u0026quot;/biz2\u0026quot;)//需要对外暴漏的资源的路径，user用户和admin用户可以访问 .hasAnyAuthority(\u0026quot;ROLE_user\u0026quot;,\u0026quot;ROLE_admin\u0026quot;)//user用户和admin用户 权限 //.antMatchers(\u0026quot;/syslog\u0026quot;,\u0026quot;/sususer\u0026quot;) //.hasAnyRole(\u0026quot;admin\u0026quot;)//admin用户可以访问 .hasAnyAuthority(\u0026quot;ROLE_admin\u0026quot;)，另一种写法 角色 .antMatchers(\u0026quot;/syslog\u0026quot;).hasAuthority(\u0026quot;/syslog\u0026quot;)//通过权限进行配置 .antMatchers(\u0026quot;/sysuser\u0026quot;).hasAuthority(\u0026quot;/sysuser\u0026quot;) //前面是资源，后面是资源id .anyRequest().authenticated()  变成动态的\n@Component(\u0026quot;rabcService\u0026quot;) public class MyRBACService { private AntPathMatcher antPathMatcher = new AntPathMatcher(); @Resource private MyRBACServiceMapper myRBACServiceMapper; /** * 判断某用户是否具有该request资源的访问权限 */ public boolean hasPermission(HttpServletRequest request, Authentication authentication){ //获取验证主体 Object principal = authentication.getPrincipal(); if(principal instanceof UserDetails){ String username = ((UserDetails)principal).getUsername(); List\u0026lt;String\u0026gt; urls = myRBACServiceMapper.findUrlsByUserName(username); return urls.stream().anyMatch( url -\u0026gt; antPathMatcher.match(url,request.getRequestURI()) ); } return false; } }  public interface MyRBACServiceMapper { @Select(\u0026quot;SELECT url\\n\u0026quot; + \u0026quot;FROM sys_menu m\\n\u0026quot; + \u0026quot;LEFT JOIN sys_role_menu rm ON m.id = rm.menu_id\\n\u0026quot; + \u0026quot;LEFT JOIN sys_role r ON r.id = rm.role_id\\n\u0026quot; + \u0026quot;LEFT JOIN sys_user_role ur ON r.id = ur.role_id\\n\u0026quot; + \u0026quot;LEFT JOIN sys_user u ON u.id = ur.user_id\\n\u0026quot; + \u0026quot;WHERE u.username = #{userId} or u.phone = #{userId}\u0026quot;) List\u0026lt;String\u0026gt; findUrlsByUserName(@Param(\u0026quot;userId\u0026quot;) String userId); }  配置\n.antMatchers(\u0026quot;/login.html\u0026quot;,\u0026quot;login\u0026quot;).permitAll()//哪些请求不需要验证 .antMatchers(\u0026quot;/index\u0026quot;).authenticated()// .anyRequest().access(\u0026quot;@rabcService.hasPermission(request,authentication)\u0026quot;)//除了上面的配置外的所有请求都需要通过rabcService的hasPermission方法进行判断是否有权限  测试\n权限表达式的使用方法 \u0026quot;@rabcService.hasPermission(request,authentication)\u0026quot;  //.antMatchers(\u0026quot;/login.html\u0026quot;,\u0026quot;login\u0026quot;).permitAll()//哪些请求不需要验证 .antMatchers(\u0026quot;/login.html\u0026quot;,\u0026quot;login\u0026quot;).access(\u0026quot;permitAll()\u0026quot;)//与上面写法等同  常用权限表达式\n   表达式 说明     hasRole([role]) 用户拥有制定的角色时返回true （Spring security默认会带有ROLE_前缀）   hasAnyRole([role1,role2]) 用户拥有任意一个制定的角色时返回true   hasAuthority([authority]) 等同于hasRole,但不会带有ROLE_前缀   hasAnyAuthority([auth1,auth2]) 等同于hasAnyRole   permitAll 永远返回true   denyAll 永远返回false   authentication 当前登录用户的authentication对象   fullAuthenticated 当前用户既不是anonymous也不是rememberMe用户时返回true   hasIpAddress(\u0026lsquo;192.168.1.0/24\u0026rsquo;)) 请求发送的IP匹配时返回true    权限表达式在全局配置中的使用 .antMatchers(\u0026quot;/login.html\u0026quot;,\u0026quot;login\u0026quot;).access(\u0026quot;permitAll()\u0026quot;)//与上面写法等同 .antMatchers(\u0026quot;/system/*\u0026quot;).access(\u0026quot;hasAnyRole('admin') or hasAnyAuthority('ROLE_admin')\u0026quot;)  方法级别的安全控制  @PreAuthorize @ PreFilter @ PostAuthorize @ PostFilter  开启\n@Configuration @EnableGlobalMethodSecurity(prePostEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter {  编写规则\n@Service public class MethodELService { //在该方法执行之前先进判断hasRole('admin') @PreAuthorize(\u0026quot;hasRole('admin')\u0026quot;) public List\u0026lt;PersonDemo\u0026gt; findAll(){ return null; } //先执行方法，方法执行完毕后对返回值进行判断 @PostAuthorize(\u0026quot;returnObject.name == authentication.name\u0026quot;) public PersonDemo findOne(){ String authName = getContext().getAuthentication().getName(); //System.out.println(authName); return new PersonDemo(\u0026quot;admin\u0026quot;); } //对参数ids进行过滤，过滤的规则为value=\u0026quot;filterObject%2==0\u0026quot; @PreFilter(filterTarget=\u0026quot;ids\u0026quot;, value=\u0026quot;filterObject%2==0\u0026quot;) public void delete(List\u0026lt;Integer\u0026gt; ids, List\u0026lt;String\u0026gt; usernames) { System.out.println(); } //针对返回值进行过滤，保留返回值中的name==authentication.name(认证主体的对象) @PostFilter(\u0026quot;filterObject.name == authentication.name\u0026quot;) public List\u0026lt;PersonDemo\u0026gt; findAllPD(){ List\u0026lt;PersonDemo\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new PersonDemo(\u0026quot;kobe\u0026quot;)); list.add(new PersonDemo(\u0026quot;admin\u0026quot;)); return list; } }  就是一个特殊的service，在controller中调用，当规则不符合时会抛出异常\n// 具体业务一 @GetMapping(\u0026quot;/biz1\u0026quot;) public String updateOrder() { /*List\u0026lt;Integer\u0026gt; ids = new ArrayList\u0026lt;\u0026gt;(); ids.add(1); ids.add(2); methodELService.delete(ids,null);*/ //List\u0026lt;PersonDemo\u0026gt; pds = methodELService.findAllPD(); // methodELService.findAll(); return \u0026quot;biz1\u0026quot;; }  REMEMBERME记住密码 最简实现\n后端配置\nhttp.rememberMe(); //实现记住我自动登录配置， 核心的代码只有这一行  前端实现\n\u0026lt;label\u0026gt;\u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;remember-me\u0026quot;/\u0026gt;记住密码\u0026lt;/1abe1\u0026gt;  开启\nspringsecurityConfig中\n@Override protected void configure(HttpSecurity http) throws Exception { http.rememberMe()//记住功能 .and().csrf().disable()//关掉csrf，否则会将我们的请求当作是一个不合法的 .formLogin()  页面添加组件\n\u0026lt;form action=\u0026quot;/login\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;span\u0026gt;用户名称\u0026lt;/span\u0026gt;\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;username\u0026quot; id=\u0026quot;username\u0026quot;/\u0026gt; \u0026lt;br\u0026gt; \u0026lt;span\u0026gt;用户密码\u0026lt;/span\u0026gt;\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;password\u0026quot; id=\u0026quot;password\u0026quot;/\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; onclick=\u0026quot;login()\u0026quot; value=\u0026quot;登陆\u0026quot;\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;remember-me\u0026quot;\u0026gt; 记住密码\u0026lt;/label\u0026gt; \u0026lt;/form\u0026gt; function login() { var username = $(\u0026quot;#username\u0026quot;).val(); var password = $(\u0026quot;#password\u0026quot;).val(); var rememberMe = $(\u0026quot;#remember-me\u0026quot;).is(\u0026quot;:checked\u0026quot;); if (username === \u0026quot;\u0026quot; || password === \u0026quot;\u0026quot;) { alert('用户名或密码不能为空'); return; } $.ajax({ type: \u0026quot;POST\u0026quot;, url: \u0026quot;/login\u0026quot;, data: { \u0026quot;username\u0026quot;: username, \u0026quot;password\u0026quot;: password, \u0026quot;remember-me\u0026quot;:rememberMe//名称一定是remember-me },  测试\n勾选记住密码后，会新增一个cookie\n值为\nYWRtaW46MTU4NDYyNDY1ODE2MTo2NTgyZGExZjRmYmQ5NWUyZTdmNjAwNGI4YjcxZDUzNg  使用base64进行解密后的到\nadmin:1584624658161:6582da1f4fbd95e2e7f6004b8b71d536 用户：时间（从xxx年到现在的总的秒数）：   RememberMeToken = username, expiry Time, signatureValue的Base64加密 signatureValue = username、 expirationTime和passwod和一个预定义的key,并将他们经过MD5进行签名。\nTokenBasedRememberMeServices类中 protected String makeTokenSignature(long tokenExpiryTime, String username, String password) { String data = username + \u0026quot;:\u0026quot; + tokenExpiryTime + \u0026quot;:\u0026quot; + password + \u0026quot;:\u0026quot; + this.getKey(); MessageDigest digest; try { digest = MessageDigest.getInstance(\u0026quot;MD5\u0026quot;); } catch (NoSuchAlgorithmException var8) { throw new IllegalStateException(\u0026quot;No MD5 algorithm available!\u0026quot;); } return new String(Hex.encode(digest.digest(data.getBytes()))); }   个性化配置\n tokenValiditySeconds用于设置token的有效期，默认是2周。 通过rememberMeParameter设置from表单“自动登录”勾选框的参数名称。 rememberMeCookieName设 置了保存在 浏览器端的cookie的名称。\nhttp.rememberMe() .rememberMeParameter(\u0026quot;remember-me\u0026quot;)//传参的名称即，ajax请求中\u0026quot;remember-me\u0026quot;:rememberMe .rememberMeCookieName(\u0026quot;remember-me-cookie\u0026quot;)//cookie的name .tokenValiditySeconds(2*24*60*60)//过期时间：两天   将cookie信息存放到内存中\n使用数据库实现remember 创建表\nCREATE TABLE `persistent_logins` ( `username` varchar(64) NOT NULL, `series` varchar(64) NOT NULL, `token` varchar(64) NOT NULL, `last_used` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`series`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;  配置\nSecurityConfig类 @Resource private DataSource dataSource;//对应的是application-dev.yml中的datasource @Bean public PersistentTokenRepository persistentTokenRepository(){ JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl(); tokenRepository.setDataSource(dataSource); return tokenRepository; }  rememberMeParameter(\u0026quot;remember-me\u0026quot;)//传参的名称即，ajax请求中\u0026quot;remember-me\u0026quot;:rememberMe .rememberMeCookieName(\u0026quot;remember-me-cookie\u0026quot;)//cookie的name .tokenValiditySeconds(2*24*60*60)//过期时间：两天 .tokenRepository(persistentTokenRepository())  测试\n数据库中增加了数据\n用户退出功能的实现 最简及最佳实践\n后端配置\n@Override protected void configure(final HttpSecurity http) throws Exception { http.logout(); }\t 前端代码\n\u0026lt;a href-=\u0026quot;/logout\u0026quot; \u0026gt;退出\u0026lt;/a\u0026gt;  配置\n@Override protected void configure(HttpSecurity http) throws Exception { http.logout()  index.html中增加代码\n\u0026lt;a href=\u0026quot;/logout\u0026quot;\u0026gt;退出\u0026lt;/a\u0026gt;  测试，将数据库中的信息删除\n页面返回到login.html\nlogout的默认行为\n 当前session失效，即: logout的 核心需求，session失 效就是访问权限的回收。 删除当前用户的remember-me“记住我”功能信息 clear清除当前的SecurityContext 重定向到登录页面，loginPage配置项指定的页面  个性化配置  通过指定logoutUr|配置改变退出请求的默认路径，当然html退出按钮的请求url也要修改 通过指定logoutSuccessUrl配置，来显式指定退出之后的跳转页面 还可以使用deleteCookies删除指定的cookie,参数为cookie的名称  配置\nhttp.logout() .logoutUrl(\u0026quot;/logout\u0026quot;)//a标签的href请求路径 .logoutSuccessUrl(\u0026quot;.login.html\u0026quot;)//成功后重定向的页面 .deleteCookies(\u0026quot;JSESSIONID\u0026quot;)//将JESSIONID一起删除  重定向的页面要设置访问权限\n.authorizeRequests() .antMatchers(\u0026quot;/login.html\u0026quot;,\u0026quot;login\u0026quot;).permitAll()//哪些请求不需要验证  LogoutSuccesshlandler  编码实现个性化退出功能 注意logoutSuccessUrl不要与logoutSuccessHandler一起使用，否则logoutSuccessHandler将失效。  当用户退出时还想做一些其他的操作\n配置\n@Component public class MyLogoutSuccessHandler implements LogoutSuccessHandler { @Override public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException { //写一些业务逻辑，比如：登录时间的统计 response.sendRedirect(\u0026quot;/login.html\u0026quot;); } }  springsecurityConfig\n@Resource MyLogoutSuccessHandler myLogoutSuccessHandler;  http.logout() .logoutUrl(\u0026quot;/logout\u0026quot;) //.logoutSuccessUrl(\u0026quot;/login.html\u0026quot;) .deleteCookies(\u0026quot;JSESSIONID\u0026quot;) .logoutSuccessHandler(myLogoutSuccessHandler)//与logoutSuccessUrl不能同时使用  图片验证码的实现方案 谜面用于展现，谜底用于校验\n 对于字符型验证码。比如:谜面是显示字符串\u0026rdquo;ABGH\u0026rdquo;的图片，谜底是字符串\u0026rdquo;ABGH\u0026rdquo; 对于计算类验证码。比如:谜面是“1+1=”的图片，谜底是“2” 对于拖拽类的验证码。比如:谜面是一个拖拽式的拼图，谜底是拼图位置的坐标  session存储验证码 图片验证码开发三部曲\n 验证码工具配置 验证码加载(重点) 验证码校验(重点)  验证码工具类库\n 生成验证码文字或其他用于校验的数据形式(即谜底) 生成验证码前端显示图片或拼图等(即谜面) 用于校验用户输入与谜底的校验方法(如果是纯文字，就自己比对以下就可以。如果是基于物理图形拖拽、旋转等方式，需要专用的校验方法)  使用\n添加依赖\n\u0026lt;!-- 验证码--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.penggle\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;kaptcha\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.2\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  配置\nyml配置方式不能实现，因此需要使用properties文件\n新建kaptcha.properties\nkaptcha.border=no kaptcha.border.color=105,179,90 kaptcha.image.width=100 kaptcha.image.height=45 kaptcha.session.key=code kaptcha.textproducer.font.color=blue kaptcha.textproducer.font.size=35 kaptcha.textproducer.char.length=4 kaptcha.textproducer.font.names=宋体,楷体,微软雅黑  配置加载类让spring认识该配置文件\nCaptchaConfig\n@Configuration @PropertySource(value = {\u0026quot;classpath:kaptcha.properties\u0026quot;}) public class CaptchaConfig { @Value(\u0026quot;${kaptcha.border}\u0026quot;) private String border; @Value(\u0026quot;${kaptcha.border.color}\u0026quot;) private String borderColor; @Value(\u0026quot;${kaptcha.textproducer.font.color}\u0026quot;) private String fontColor; @Value(\u0026quot;${kaptcha.image.width}\u0026quot;) private String imageWidth; @Value(\u0026quot;${kaptcha.image.height}\u0026quot;) private String imageHeight; @Value(\u0026quot;${kaptcha.session.key}\u0026quot;) private String sessionKey; @Value(\u0026quot;${kaptcha.textproducer.char.length}\u0026quot;) private String charLength; @Value(\u0026quot;${kaptcha.textproducer.font.names}\u0026quot;) private String fontNames; @Value(\u0026quot;${kaptcha.textproducer.font.size}\u0026quot;) private String fontSize; @Bean(name = \u0026quot;captchaProducer\u0026quot;) public DefaultKaptcha getKaptchaBean(){ DefaultKaptcha defaultKaptcha = new DefaultKaptcha(); Properties properties = new Properties(); properties.setProperty(\u0026quot;kaptcha.border\u0026quot;, border); properties.setProperty(\u0026quot;kaptcha.border.color\u0026quot;, borderColor); properties.setProperty(\u0026quot;kaptcha.textproducer.font.color\u0026quot;, fontColor); properties.setProperty(\u0026quot;kaptcha.image.width\u0026quot;, imageWidth); properties.setProperty(\u0026quot;kaptcha.image.height\u0026quot;, imageHeight); properties.setProperty(\u0026quot;kaptcha.session.key\u0026quot;, sessionKey); properties.setProperty(\u0026quot;kaptcha.textproducer.char.length\u0026quot;, charLength); properties.setProperty(\u0026quot;kaptcha.textproducer.font.names\u0026quot;, fontNames); properties.setProperty(\u0026quot;kaptcha.textproducer.font.size\u0026quot;,fontSize); defaultKaptcha.setConfig(new Config(properties)); return defaultKaptcha; } }  新建controller：CaptchaController\n@RestController public class CaptchaController { @Resource DefaultKaptcha captchaProducer; @RequestMapping(value=\u0026quot;/kaptcha\u0026quot;,method = RequestMethod.GET) public void kaptcha(HttpSession session, HttpServletResponse response) throws IOException { response.setDateHeader(\u0026quot;Expires\u0026quot;, 0); response.setHeader(\u0026quot;Cache-Control\u0026quot;, \u0026quot;no-store, no-cache, must-revalidate\u0026quot;); response.addHeader(\u0026quot;Cache-Control\u0026quot;, \u0026quot;post-check=0, pre-check=0\u0026quot;); response.setHeader(\u0026quot;Pragma\u0026quot;, \u0026quot;no-cache\u0026quot;); response.setContentType(\u0026quot;image/jpeg\u0026quot;); String capText = captchaProducer.createText(); session.setAttribute(MyContants.CAPTCHA_SESSION_KEY, new CaptchaCode(capText,2 * 60));//两分钟 //将验证码写回到浏览器中 try(ServletOutputStream out = response.getOutputStream()){ BufferedImage bufferedImage = captchaProducer.createImage(capText); ImageIO.write(bufferedImage,\u0026quot;jpg\u0026quot;,out); out.flush(); } } }  工具类MyContants\npublic class MyContants { public static final String CAPTCHA_SESSION_KEY = \u0026quot;captcha_key\u0026quot;; public static final String SMS_SESSION_KEY = \u0026quot;sms_key\u0026quot;; }  新建验证码：CaptchaCode\npublic class CaptchaCode { //验证码 private String code; //过期时间 private LocalDateTime expireTime; public CaptchaCode(String code, int expireAfterSeconds){ this.code = code; this.expireTime = LocalDateTime.now().plusSeconds(expireAfterSeconds); } //判断当前验证码是否过期 public boolean isExpired(){ return LocalDateTime.now().isAfter(expireTime); } public String getCode() { return code; } }  前端页面添加验证码login.html\n\u0026lt;form action=\u0026quot;/login\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;span\u0026gt;用户名称\u0026lt;/span\u0026gt;\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;username\u0026quot; id=\u0026quot;username\u0026quot;/\u0026gt; \u0026lt;br\u0026gt; \u0026lt;span\u0026gt;用户密码\u0026lt;/span\u0026gt;\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;password\u0026quot; id=\u0026quot;password\u0026quot;/\u0026gt; \u0026lt;br\u0026gt; \u0026lt;span\u0026gt;验证码\u0026lt;/span\u0026gt;\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;captchaCode\u0026quot; id=\u0026quot;captchaCode\u0026quot;/\u0026gt; \u0026lt;img src=\u0026quot;/kaptcha\u0026quot; id=\u0026quot;kaptcha\u0026quot; width=\u0026quot;100px\u0026quot; height=\u0026quot;45px\u0026quot;/\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; onclick=\u0026quot;login()\u0026quot; value=\u0026quot;登陆\u0026quot;\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;remember-me\u0026quot; id=\u0026quot;remember-me\u0026quot;\u0026gt; 记住密码\u0026lt;/label\u0026gt; \u0026lt;/form\u0026gt;  页面js\n//页面加载时加载验证码 window.onload = function () { var kaptchaImg = document.getElementById(\u0026quot;kaptcha\u0026quot;); kaptchaImg.onclick = function () { kaptchaImg.src = \u0026quot;/kaptcha?\u0026quot; + Math.floor(Math.random() * 100) } };  开放验证码访问路径SecurityConfig\n.antMatchers(\u0026quot;/login.html\u0026quot;,\u0026quot;login\u0026quot;,\u0026quot;/kaptcha\u0026quot;).permitAll()//哪些请求不需要验证  测试\n访问\nhttp://localhost:8888/login.html  验证码验证 图片验证码过滤器\n 编写自定义图片验证码过滤器CaptchaCodeFilter,过滤器中拦截登录请求 过滤器中从seesion获取验证码文字与用户输入比对，比对通过执行其他过滤器链 比对不通过，抛出SessionAuthenticationException异常，交给AuthenticationFailureHandler处理 最后将Captcha odeFilter放在UsernamePasswordAuthenticationFilter过滤器前执行。  新建过滤器CaptchaCodeFilter\n@Component public class CaptchaCodeFilter extends OncePerRequestFilter { @Resource MyAuthenticationFailureHandler myAuthenticationFailureHandler; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { if(StringUtils.equals(\u0026quot;/login\u0026quot;,request.getRequestURI()) \u0026amp;\u0026amp; StringUtils.equalsIgnoreCase(request.getMethod(),\u0026quot;post\u0026quot;)){ try{ //验证谜底与用户输入是否匹配 validate(new ServletWebRequest(request)); }catch(AuthenticationException e){ //交给登录失败处理类取值处理 myAuthenticationFailureHandler.onAuthenticationFailure( request,response,e ); return; } } filterChain.doFilter(request,response); } private void validate(ServletWebRequest request) throws ServletRequestBindingException { HttpSession session = request.getRequest().getSession(); String codeInRequest = ServletRequestUtils.getStringParameter( request.getRequest(),\u0026quot;captchaCode\u0026quot;); if(StringUtils.isEmpty(codeInRequest)){ throw new SessionAuthenticationException(\u0026quot;验证码不能为空\u0026quot;); } // 3. 获取session池中的验证码谜底 CaptchaCode codeInSession = (CaptchaCode) session.getAttribute(MyContants.CAPTCHA_SESSION_KEY); if(Objects.isNull(codeInSession)) { throw new SessionAuthenticationException(\u0026quot;验证码不存在\u0026quot;); } // 4. 校验服务器session池中的验证码是否过期 if(codeInSession.isExpired()) { session.removeAttribute(MyContants.CAPTCHA_SESSION_KEY); throw new SessionAuthenticationException(\u0026quot;验证码已经过期\u0026quot;); } // 5. 请求验证码校验 if(!StringUtils.equals(codeInSession.getCode(), codeInRequest)) { throw new SessionAuthenticationException(\u0026quot;验证码不匹配\u0026quot;); } } }  MyAuthenticationFailureHandler处理异常\nString errorMsg = \u0026quot;用户名或者密码输入错误!\u0026quot;; if(exception instanceof SessionAuthenticationException){ errorMsg = exception.getMessage(); }  SecurityConfig配置\n//验证码 @Resource CaptchaCodeFilter captchaCodeFilter; @Override protected void configure(HttpSecurity http) throws Exception { http.addFilterBefore(captchaCodeFilter, UsernamePasswordAuthenticationFilter.class) .logout()  前端页面传递验证码的值\nfunction login() { var username = $(\u0026quot;#username\u0026quot;).val(); var password = $(\u0026quot;#password\u0026quot;).val(); //验证码 var captchaCode = $(\u0026quot;#captchaCode\u0026quot;).val(); var rememberMe = $(\u0026quot;#remember-me\u0026quot;).is(\u0026quot;:checked\u0026quot;); if (username === \u0026quot;\u0026quot; || password === \u0026quot;\u0026quot;) { alert('用户名或密码不能为空'); return; } $.ajax({ type: \u0026quot;POST\u0026quot;, url: \u0026quot;/login\u0026quot;, data: { \u0026quot;username\u0026quot;: username, \u0026quot;password\u0026quot;: password, \u0026quot;captchaCode\u0026quot;:captchaCode, \u0026quot;remember-me\u0026quot;:rememberMe//名称一定是remember-me }, success: function (json) { if(json.isok){ location.href = json.data; }else{ alert(json.message) } }, error: function (e) { console.log(e.responseText); } }); }  测试\n共享session存储验证码 基于对称算法的验证码 短信验证码登录功能  输入手机号码，点击获取按钮，服务端接受请求发送短信 用户输入验证码点击登录 手机号码必须属于系统的注册用户，并且唯一 手机号与验证码正确性及其关系必须经过校验 登录后用户具有手机号对应的用户的角色及权限  实现步骤\n 获取短信验证码 短信验证码校验过滤器 短信验证码登录认证过滤器 综合配置  获取短信验证码 新建controller：SmsController\n@Slf4j @RestController public class SmsController { @Resource MyUserDetailsServiceMapper myUserDetailsServiceMapper; @RequestMapping(value = \u0026quot;/smscode\u0026quot;,method = RequestMethod.GET) public AjaxResponse sms(@RequestParam String mobile, HttpSession session){ //手机号是否已经被注册 MyUserDetails myUserDetails = myUserDetailsServiceMapper.findByUserName(mobile); if(myUserDetails == null){ return AjaxResponse.error( new CustomException(CustomExceptionType.USER_INPUT_ERROR, \u0026quot;您输入的手机号未曾注册\u0026quot;) ); } //四位随机数字 SmsCode smsCode = new SmsCode( RandomStringUtils.randomNumeric(4),60,mobile ); //TODO 调用短信服务提供商的接口发送短信（要进行购买，这里使用日志模拟） log.info(smsCode.getCode() + \u0026quot;+\u0026gt;\u0026quot; + mobile); session.setAttribute(MyContants.SMS_SESSION_KEY,smsCode); //AjaxResponse：封装了返回给前端页面信息的数据结构后，进行了统一 return AjaxResponse.success(\u0026quot;短信验证码已经发送\u0026quot;); } }  新建短信验证码实体类\npublic class SmsCode { private String code; //短信验证码 private LocalDateTime expireTime; //过期时间 private String mobile; public SmsCode(String code, int expireAfterSeconds,String mobile){ this.code = code; this.expireTime = LocalDateTime.now().plusSeconds(expireAfterSeconds); this.mobile = mobile; } public boolean isExpired(){ return LocalDateTime.now().isAfter(expireTime); } public String getCode() { return code; } public String getMobile() { return mobile; } }  修改mapper增加查询手机号功能\n//根据userID查询用户信息 @Select(\u0026quot;SELECT username,password,enabled\\n\u0026quot; + \u0026quot;FROM sys_user u\\n\u0026quot; + \u0026quot;WHERE u.username = #{userId} or u.phone = #{userId}\u0026quot;) MyUserDetails findByUserName(@Param(\u0026quot;userId\u0026quot;) String userId);  开放权限\n.antMatchers(\u0026quot;/login.html\u0026quot;,\u0026quot;login\u0026quot;,\u0026quot;/kaptcha\u0026quot;,\u0026quot;/smscode\u0026quot;).permitAll()//哪些请求不需要验证  短信验证码校验过滤器 短信验证码校验过滤器-校验规则\n 用户登录时手机号不能为空 用户登录时短信验证码不能为空 用户登陆时在session中必须存在对应的校验谜底(获取验证码时存放的) 用户登录时输入的短信验证码必须和 谜底”中的验证码一致 用户登录时输入的手机号必须和‘ “谜底”中保存的手机号一致 用户登录时输入的手机号必须是系统注册用户的手机号，并且唯一  SmsCodeValidateFilter\n@Component public class SmsCodeValidateFilter extends OncePerRequestFilter { @Resource MyUserDetailsServiceMapper myUserDetailsServiceMapper; @Resource MyAuthenticationFailureHandler myAuthenticationFailureHandler; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { if(StringUtils.equals(\u0026quot;/smslogin\u0026quot;,request.getRequestURI()) \u0026amp;\u0026amp; StringUtils.equalsIgnoreCase(request.getMethod(),\u0026quot;post\u0026quot;)){ try{ //验证谜底与用户输入是否匹配 validate(new ServletWebRequest(request)); }catch(AuthenticationException e){ myAuthenticationFailureHandler.onAuthenticationFailure( request,response,e ); return; } } filterChain.doFilter(request,response); } //验证规则 private void validate(ServletWebRequest request) throws ServletRequestBindingException { HttpSession session = request.getRequest().getSession(); SmsCode codeInSession = (SmsCode)session.getAttribute(MyContants.SMS_SESSION_KEY); String mobileInRequest = request.getParameter(\u0026quot;mobile\u0026quot;); String codeInRequest = request.getParameter(\u0026quot;smsCode\u0026quot;); if(StringUtils.isEmpty(mobileInRequest)){ throw new SessionAuthenticationException(\u0026quot;手机号码不能为空\u0026quot;); } if(StringUtils.isEmpty(codeInRequest)) { throw new SessionAuthenticationException(\u0026quot;短信验证码不能为空\u0026quot;); } if(Objects.isNull(codeInSession)) { throw new SessionAuthenticationException(\u0026quot;短信验证码不存在\u0026quot;); } if(codeInSession.isExpired()) { session.removeAttribute(MyContants.SMS_SESSION_KEY); throw new SessionAuthenticationException(\u0026quot;短信验证码已经过期\u0026quot;); } if(!codeInSession.getCode().equals(codeInRequest)) { throw new SessionAuthenticationException(\u0026quot;短信验证码不正确\u0026quot;); } if(!codeInSession.getMobile().equals(mobileInRequest)) { throw new SessionAuthenticationException(\u0026quot;短信发送目标与您输入的手机号不一致\u0026quot;); } MyUserDetails myUserDetails = myUserDetailsServiceMapper.findByUserName(mobileInRequest); if(Objects.isNull(myUserDetails)){ throw new SessionAuthenticationException(\u0026quot;您输入的手机号不是系统的注册用户\u0026quot;); } session.removeAttribute(MyContants.SMS_SESSION_KEY); } }  开放请求路径\n.antMatchers(\u0026quot;/login.html\u0026quot;,\u0026quot;login\u0026quot;,\u0026quot;/kaptcha\u0026quot;,\u0026quot;/smscode\u0026quot;,\u0026quot;/smslogin\u0026quot;).permitAll()//哪些请求不需要验证  短信验证码登录认证过滤器 短信验证码登录认证过滤器原理\n参照UsernamePasswordAuthenticationFilter类\npublic class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter { public static final String SPRING_SECURITY_FORM_USERNAME_KEY = \u0026quot;username\u0026quot;; public static final String SPRING_SECURITY_FORM_PASSWORD_KEY = \u0026quot;password\u0026quot;; private String usernameParameter = \u0026quot;username\u0026quot;; private String passwordParameter = \u0026quot;password\u0026quot;; private boolean postOnly = true; public UsernamePasswordAuthenticationFilter() { super(new AntPathRequestMatcher(\u0026quot;/login\u0026quot;, \u0026quot;POST\u0026quot;)); } public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException { if (this.postOnly \u0026amp;\u0026amp; !request.getMethod().equals(\u0026quot;POST\u0026quot;)) { throw new AuthenticationServiceException(\u0026quot;Authentication method not supported: \u0026quot; + request.getMethod()); } else { String username = this.obtainUsername(request); String password = this.obtainPassword(request); if (username == null) { username = \u0026quot;\u0026quot;; } if (password == null) { password = \u0026quot;\u0026quot;; } username = username.trim(); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password); this.setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); } } @Nullable protected String obtainPassword(HttpServletRequest request) { return request.getParameter(this.passwordParameter); } @Nullable protected String obtainUsername(HttpServletRequest request) { return request.getParameter(this.usernameParameter); } protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) { authRequest.setDetails(this.authenticationDetailsSource.buildDetails(request)); } public void setUsernameParameter(String usernameParameter) { Assert.hasText(usernameParameter, \u0026quot;Username parameter must not be empty or null\u0026quot;); this.usernameParameter = usernameParameter; } public void setPasswordParameter(String passwordParameter) { Assert.hasText(passwordParameter, \u0026quot;Password parameter must not be empty or null\u0026quot;); this.passwordParameter = passwordParameter; } public void setPostOnly(boolean postOnly) { this.postOnly = postOnly; } public final String getUsernameParameter() { return this.usernameParameter; } public final String getPasswordParameter() { return this.passwordParameter; } }  参考UsernamePasswordAuthenticationToken类\npublic class SmsCodeAuthenticationToken extends AbstractAuthenticationToken { private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID; //存放认证信息，认证之前放的是手机号，认证之后UserDetails private final Object principal; public SmsCodeAuthenticationToken(Object principal) { super(null); this.principal = principal; setAuthenticated(false); } public SmsCodeAuthenticationToken(Object principal, Collection\u0026lt;? extends GrantedAuthority\u0026gt; authorities) { super(authorities); this.principal = principal; super.setAuthenticated(true); // must use super, as we override } public Object getPrincipal() { return this.principal; } public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException { if (isAuthenticated) { throw new IllegalArgumentException( \u0026quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead\u0026quot;); } super.setAuthenticated(false); } @Override public void eraseCredentials() { super.eraseCredentials(); } @Override public Object getCredentials() { return null; } }  参照DaoAuthenticationProvider类\npublic class SmsCodeAuthenticationProvider implements AuthenticationProvider { private UserDetailsService userDetailsService; public void setUserDetailsService(UserDetailsService userDetailsService) { this.userDetailsService = userDetailsService; } protected UserDetailsService getUserDetailsService() { return userDetailsService; } @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException { SmsCodeAuthenticationToken authenticationToken = (SmsCodeAuthenticationToken)authentication; UserDetails userDetails = userDetailsService.loadUserByUsername((String) authenticationToken.getPrincipal()); if(userDetails == null){ throw new InternalAuthenticationServiceException(\u0026quot;无法根据手机号获取用户信息\u0026quot;); } SmsCodeAuthenticationToken authenticationResult = new SmsCodeAuthenticationToken(userDetails,userDetails.getAuthorities()); authenticationResult.setDetails(authenticationToken.getDetails()); return authenticationResult; } @Override public boolean supports(Class\u0026lt;?\u0026gt; authentication) { return SmsCodeAuthenticationToken.class.isAssignableFrom(authentication); } }  综合配置 新建验证码配置类SmsCodeSecurityConfig\n@Component public class SmsCodeSecurityConfig extends SecurityConfigurerAdapter\u0026lt;DefaultSecurityFilterChain,HttpSecurity\u0026gt; { @Resource MyAuthenticationSuccessHandler myAuthenticationSuccessHandler; @Resource MyAuthenticationFailureHandler myAuthenticationFailureHandler; @Resource MyUserDetailsService myUserDetailsService; @Resource SmsCodeValidateFilter smsCodeValidateFilter; @Override public void configure(HttpSecurity http) throws Exception { SmsCodeAuthenticationFilter smsCodeAuthenticationFilter = new SmsCodeAuthenticationFilter(); smsCodeAuthenticationFilter.setAuthenticationManager(http.getSharedObject(AuthenticationManager.class)); smsCodeAuthenticationFilter.setAuthenticationSuccessHandler(myAuthenticationSuccessHandler); smsCodeAuthenticationFilter.setAuthenticationFailureHandler(myAuthenticationFailureHandler); SmsCodeAuthenticationProvider smsCodeAuthenticationProvider = new SmsCodeAuthenticationProvider(); smsCodeAuthenticationProvider.setUserDetailsService(myUserDetailsService); http.addFilterBefore(smsCodeValidateFilter,UsernamePasswordAuthenticationFilter.class); http.authenticationProvider(smsCodeAuthenticationProvider) .addFilterAfter(smsCodeAuthenticationFilter,UsernamePasswordAuthenticationFilter.class); } }  总配置文件中进行配置\nSecurityConfig\n@Resource SmsCodeSecurityConfig smsCodeSecurityConfig; .formLogin() //逻辑 .loginPage(\u0026quot;/login.html\u0026quot;)//登陆页面位置 .usernameParameter(\u0026quot;username\u0026quot;)//表单用户名name .passwordParameter(\u0026quot;password\u0026quot;)//表单密码name .loginProcessingUrl(\u0026quot;/login\u0026quot;)// 登录验证请求 post方式的表单action //.defaultSuccessUrl(\u0026quot;/index\u0026quot;)//成功后的跳转页面 //.failureUrl(\u0026quot;/login.html\u0026quot;) .successHandler(myAuthenticationSuccessHandler)//不能与defaultSuccessUrl一起使用 .failureHandler(myAuthenticationFailureHandler) .and().apply(smsCodeSecurityConfig).and()  测试\n数据库添加用户yanfa1手机号123456789\n详述JWT使用场景及结构安全 session不适用的场景\n 比如:非浏览器的客户端、手机移动端等等，因为他们没有浏览器自动维护cookies的功能。 比如:集群应用，同一个应用部署甲、乙、丙三个主机上，实现负载均衡应用，其中一个挂掉了其他的还能负载工作。要知道session是保存在服务器内存里面的，三个主机一定是不同的内存。那么你登录的时候访问甲，而获取 接口数据的时候访问乙，就无法保证session的唯一性和共享性。  JWT安全加强\n 避免网络劫持，因为使用HTTP的header传递JWT，所以使用HTTPS传输更加安全。这样在网络层面避免了JWT的泄露。 secret是存放在服务器端的，所以只要应用服务器不被攻破，理论上JWT是安全的。因此要保证服务器的安全。那么有没有JWT加密算法被攻破的可能?当然有。但是对于JWT常用的算法要想攻破，目前已知的方法只能是暴力破解，白话说就是\u0026rdquo;试密码\u0026rdquo;。所以要定期更换secret并且保正secret的复杂度，等破解结果出来了，你的secret已经换了。  其实使用的方式很简单，就是用户名和密码换JWT令牌，然后，在后续的访问中携带JWT令牌，我们从JWT令牌中解析出来它的这个用户信息，然后进行授权，就是这样。他全程都不需要使用我们的，这个session去做这个状态保持了，那我们。\n使用Spring Security实现JWT原理 我们再回顾一下JWT认证流程，那就是客户端发起HTTP请求，然后HTTP请求中携带这个用户名和密码，然后，我们服务端校验的这个用户名和密码，然后如果他的这个校验合格，合格之后，我们就给他生成这个JWT令牌，这个JWT令牌，中间会包含这个用户名这个信息，然后或者是它的用户Id这样一个信息，总之是一些非敏感的这些数据。然后，把这个JWT令牌能返回给我们的客户端。客户端再次发起请求时的时候，他需要把他的JWT放到他的HTTP请求头里面，这个需要它编码自己编码客户端的这个程序自己编码去实现。然后，把这个JWT放到HTTP的请投里面，我们根据这个JWT的令牌，把这个令牌中间的这个用户名解密，进行一个解签，如果解签的结果，和我们的这个验证它是合法的，然后我们就授权他可以访问它需要访问的这个资源。然后，把这个访问的结果响应给我们的客户端。那这个是一个整体上的一个JWT的这样一个流程，那具体到我们的这个，整个的结合spring security去实现，它还更细节一些。\n我们管这个上面的这个123这三个流程，叫做认证的流程，然后，456这三个流程，叫做健全的流程，所以说，这个整个的JWT的这个使用过程中，，有两个流程，第1个流程是认证的流程，也就是说，是用户名和密码换取JWT令牌的这个过程，然后另外一个流程，是她来访问资源，然后我们鉴别这个JWT的合法性，然后给他一个结果。这个请求资源，响应结果这样的过程，那叫一个健全的流程，那我们分别来看一下这两个流程，结合spring security如何去实现JWT的认证流程？\n我们更细节的给大家来说一下，当客户端发起的这个登录请求，然后携带用户名和密码，当他发起这个请求的时候，我们需要自己去实现一个这个JwtAuthController这个controller的作用就是接收这个请求，然后，他去调用这个authenticationManager，它这个是这个spring security给我们提供了这样一个这个类.。他就是专门做这个认证的，然后我们调用这个认证的这个manager，我们在使用其中的这个userDetailsService方法,这个方法相信大家都很熟了，我们通过这个方法，根据用户名去加载用户信息、角色信息、权限信息，等这样一些信息，把这个信息加载回来之后，然后AuthenticationManager，根据这些信息，然后来校验当前的这个用户名和密码是否是合格的用户名密码，返回认证结果。\n如果认证失败，就是用户名和密码的校验失败，就是通知我们客户端反馈校验失败了，如果和用户名和密码认证成功之后，它就调用我们自己需要去写一个这个JWTTokenUtil这样一个util工具类。这个工具类，就是为我们生成令牌，然后ji校验令牌，然后在这样一些工具方法，放到这个工具里面，那我们调用jwtTkoenUtil生成JWT令牌，然后将JWT令牌响应给我们的客户端。这个就是整个认证流程的一个过程。\n这个过程我们就把它叫做我们JWT的认证流程，对应的是123这三部分，那我们再来看一下JWT的它这个鉴权流程\n当这个客户端它拿到了这个JWT令牌的时候，他就在后续的每一次访问我们系统资源的时候，都要把这个JWT令牌给携带者的，放到他的这个HTTP头请求的这个header里面。通过这个时序图，我们来看一下它的健权的流程，那它客户端发起，假如说他请求的资源是这个hello的这个资源，这个资源的定义在我们的一个controller里面叫HelloController，他访问的这个hello这样一个资源路径。他在请求的时候携带这个JWT，那我们在JwtAuthenticationTokenFilter类，这个filter过滤器也需要我们自己去实现。\n然后，我们在这个过滤器里面去检查这个用户是否携带了JWT令牌，如果携带了，我们就提取其中的这个用户信息。因为我们知道我们上一节给大家讲了，这个JWT里面，是可以通过它那个附加信息，也就是第2个解析段中，我们可以拿到它的这个用户，然后用户名我们根据他的这个用户名去掉用userdetailservice。userdetailservice加载这个用户的信息，就是用户角色权限这些东西，然后返回给这个filter，然后这个filter根据userDetail信息去交验令牌的合法性。\n他使用什么去校验呢？我们会写一个方法JwtTokenUtil来校验这个令牌的这个合法性，然后判断这个令牌是否进行是否合法，然后最后，如果它不合法的话，证明这个JWT有可能是超时了，或者是他自己伪造的一个这个令牌，然后我们就把这个结果返回给我们的客户端。如果这个JWT认证是合法的，然后，我们就可以通过UserDetails去构建一个UsernamePasswordAuthenticationToken。这个Token就是用来我们填充之后，表示我们认证通过了，这个Token中填写的是这个UserDetail信息，也就是说它的用户信息，角色信息，权限信息，都填充到这个usernamepasswordAuthenticationToken里面。\n那就下面就进行第9步，那我们这个filter就执行完了，然后，他继续执行spring security，其他的那个过滤器链中的这个过滤器。比如说，在他后面，会执行这个UserNamePAsswordAuthenticationFilter，他发现这个usernamePasswordAuthenticationToken已经被认证过，在这个位置已经被认证过的话，这个后续的过滤器都不会拦截hello的这个请求。然后，这个请求直接就到达我们的这个hello Controller。到了HelloController之后，他将最后的访问结果返回给我们的客户端，就是这样一个过程，这其中需要我们自己去实现的，有这个JwtAuthenticationTokenFilter过滤器，这个过滤器用来这个检查令牌的合法性，然后进行这个认证授权，也就是说他那个后续他能不能访问这个相关的这个接口，都由他去来去授权决定。那他如果授权通过的话，就可以访问这个hello Controller，如果不通过的话就直接返回。整个这个就是JWT，针对你资源访问鉴权的这样一个过程。\n还有一些，实际上还有一些其他的内容，比如JWT令牌如何刷新。这个有一个刷新的一个机制，因为我们的这个JWT令牌，通常有效期不会太长。我们不希望用户，使用APP的时候令牌就突然的过期了，他就必须重新登录，这样是很影响用户体验的。所以说，这个客户端需要在这个合适的时机，去刷新一下这个JWT令牌。但这个JWT令牌刷新的过程就非常简单，它就是我们需要写一个Controller就可以了。所以说，核心的这个过程，就是第1个就是认证，然后第2个就是鉴权，然后还有一个尾巴的东西，就是差一个小东西，就是这个令牌的刷新，我们在整个的后面那个编码过程中都会给大家讲解。\n编码实现 package com.mumulx.jwtserver.config.auth.jwt; import io.jsonwebtoken.Claims; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.stereotype.Component; import java.util.Date; import java.util.HashMap; import java.util.Map; @Data @ConfigurationProperties(prefix = \u0026quot;jwt\u0026quot;) @Component public class JwtTokenUtil { private String secret; private Long expiration; private String header; /** * 生成token令牌 * * @param userDetails 用户 * @return 令token牌 */ public String generateToken(UserDetails userDetails) { Map\u0026lt;String, Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(2); claims.put(\u0026quot;sub\u0026quot;, userDetails.getUsername()); claims.put(\u0026quot;created\u0026quot;, new Date()); return generateToken(claims); } /** * 从令牌中获取用户名 * * @param token 令牌 * @return 用户名 */ public String getUsernameFromToken(String token) { String username; try { Claims claims = getClaimsFromToken(token); username = claims.getSubject(); } catch (Exception e) { username = null; } return username; } /** * 判断令牌是否过期 * * @param token 令牌 * @return 是否过期 */ public Boolean isTokenExpired(String token) { try { Claims claims = getClaimsFromToken(token); Date expiration = claims.getExpiration(); return expiration.before(new Date()); } catch (Exception e) { return false; } } /** * 刷新令牌 * * @param token 原令牌 * @return 新令牌 */ public String refreshToken(String token) { String refreshedToken; try { Claims claims = getClaimsFromToken(token); claims.put(\u0026quot;created\u0026quot;, new Date()); refreshedToken = generateToken(claims); } catch (Exception e) { refreshedToken = null; } return refreshedToken; } /** * 验证令牌 * * @param token 令牌 * @param userDetails 用户 * @return 是否有效 */ public Boolean validateToken(String token, UserDetails userDetails) { String username = getUsernameFromToken(token); return (username.equals(userDetails.getUsername()) \u0026amp;\u0026amp; !isTokenExpired(token)); } /** * 从claims生成令牌,如果看不懂就看谁调用它 * * @param claims 数据声明 * @return 令牌 */ private String generateToken(Map\u0026lt;String, Object\u0026gt; claims) { Date expirationDate = new Date(System.currentTimeMillis() + expiration); return Jwts.builder().setClaims(claims) .setExpiration(expirationDate) .signWith(SignatureAlgorithm.HS512, secret) .compact(); } /** * 从令牌中获取数据声明,如果看不懂就看谁调用它 * * @param token 令牌 * @return 数据声明 */ private Claims getClaimsFromToken(String token) { Claims claims; try { claims = Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody(); } catch (Exception e) { claims = null; } return claims; } }  package com.mumulx.jwtserver.config.auth.jwt; import com.mumulx.jwtserver.config.exception.CustomExceptionType; import com.mumulx.jwtserver.config.exception.AjaxResponse; import com.mumulx.jwtserver.config.exception.CustomException; import org.apache.commons.lang3.StringUtils; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestHeader; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; import java.util.Map; @RestController public class JwtAuthController { @Resource JwtAuthService jwtAuthService; @RequestMapping(value = \u0026quot;/authentication\u0026quot;) public AjaxResponse login(@RequestBody Map\u0026lt;String,String\u0026gt; map){ String username = map.get(\u0026quot;username\u0026quot;); String password = map.get(\u0026quot;password\u0026quot;); if(StringUtils.isEmpty(username) || StringUtils.isEmpty(password)){ return AjaxResponse.error( new CustomException(CustomExceptionType.USER_INPUT_ERROR, \u0026quot;用户名或者密码不能为空\u0026quot;)); } try { return AjaxResponse.success(jwtAuthService.login(username, password)); }catch (CustomException e){ return AjaxResponse.error(e); } } @RequestMapping(value = \u0026quot;/refreshtoken\u0026quot;) public AjaxResponse refresh(@RequestHeader(\u0026quot;${jwt.header}\u0026quot;) String token){ return AjaxResponse.success(jwtAuthService.refreshToken(token)); } }  package com.mumulx.jwtserver.config.auth.jwt; import com.mumulx.jwtserver.config.auth.MyUserDetailsService; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import org.springframework.web.filter.OncePerRequestFilter; import javax.annotation.Resource; import javax.servlet.FilterChain; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @Component public class JwtAuthenticationTokenFilter extends OncePerRequestFilter { @Resource JwtTokenUtil jwtTokenUtil; @Resource MyUserDetailsService myUserDetailsService; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { String jwtToken = request.getHeader(jwtTokenUtil.getHeader()); if(!StringUtils.isEmpty(jwtToken)){ String username = jwtTokenUtil.getUsernameFromToken(jwtToken); if(username != null \u0026amp;\u0026amp; SecurityContextHolder.getContext().getAuthentication() == null){ UserDetails userDetails = myUserDetailsService.loadUserByUsername(username); if(jwtTokenUtil.validateToken(jwtToken,userDetails)){ //给使用该JWT令牌的用户进行授权 UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(userDetails,null,userDetails.getAuthorities()); SecurityContextHolder.getContext().setAuthentication(authenticationToken); } } } filterChain.doFilter(request,response); } }  package com.mumulx.jwtserver.config.auth.jwt; import com.mumulx.jwtserver.config.exception.CustomExceptionType; import com.mumulx.jwtserver.config.exception.CustomException; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.Authentication; import org.springframework.security.core.AuthenticationException; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.stereotype.Service; import javax.annotation.Resource; @Service public class JwtAuthService { @Resource AuthenticationManager authenticationManager; @Resource UserDetailsService userDetailsService; @Resource JwtTokenUtil jwtTokenUtil; /** * 登录认证换取JWT令牌 * @return JWT */ public String login(String username,String password) throws CustomException{ try { UsernamePasswordAuthenticationToken upToken = new UsernamePasswordAuthenticationToken(username, password); Authentication authentication = authenticationManager.authenticate(upToken); SecurityContextHolder.getContext().setAuthentication(authentication); }catch (AuthenticationException e){ throw new CustomException(CustomExceptionType.USER_INPUT_ERROR ,\u0026quot;用户名或者密码不正确\u0026quot;); } UserDetails userDetails = userDetailsService.loadUserByUsername(username); return jwtTokenUtil.generateToken(userDetails); } public String refreshToken(String oldToken){ if(!jwtTokenUtil.isTokenExpired(oldToken)){ return jwtTokenUtil.refreshToken(oldToken); } return null; } }  package com.mumulx.jwtserver.config; import com.mumulx.jwtserver.config.auth.MyLogoutSuccessHandler; import com.mumulx.jwtserver.config.auth.MyUserDetailsService; import com.zimug.jwtserver.config.auth.*; import com.mumulx.jwtserver.config.auth.jwt.JwtAuthenticationTokenFilter; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.config.BeanIds; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.builders.WebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; import org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl; import org.springframework.security.web.authentication.rememberme.PersistentTokenRepository; import org.springframework.security.web.csrf.CookieCsrfTokenRepository; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.CorsConfigurationSource; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import javax.annotation.Resource; import javax.sql.DataSource; import java.util.Arrays; @Configuration @EnableGlobalMethodSecurity(prePostEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter { @Resource MyLogoutSuccessHandler myLogoutSuccessHandler; @Resource MyUserDetailsService myUserDetailsService; @Resource private DataSource datasource; @Resource private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter; @Override protected void configure(HttpSecurity http) throws Exception { http.csrf() .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) .ignoringAntMatchers(\u0026quot;/authentication\u0026quot;) .and().cors().and() .addFilterBefore(jwtAuthenticationTokenFilter,UsernamePasswordAuthenticationFilter.class) .logout() .logoutUrl(\u0026quot;/signout\u0026quot;) //.logoutSuccessUrl(\u0026quot;/login.html\u0026quot;) .deleteCookies(\u0026quot;JSESSIONID\u0026quot;) .logoutSuccessHandler(myLogoutSuccessHandler) .and().rememberMe() .rememberMeParameter(\u0026quot;remember-me-new\u0026quot;) .rememberMeCookieName(\u0026quot;remember-me-cookie\u0026quot;) .tokenValiditySeconds(2 * 24 * 60 * 60) .tokenRepository(persistentTokenRepository()) .and() .authorizeRequests() .antMatchers(\u0026quot;/authentication\u0026quot;,\u0026quot;/refreshtoken\u0026quot;).permitAll() .antMatchers(\u0026quot;/index\u0026quot;).authenticated() .anyRequest().access(\u0026quot;@rabcService.hasPermission(request,authentication)\u0026quot;) .and().sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS); } @Override public void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(myUserDetailsService) .passwordEncoder(passwordEncoder()); } @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } @Override public void configure(WebSecurity web) { //将项目中静态资源路径开放出来 web.ignoring() .antMatchers( \u0026quot;/css/**\u0026quot;, \u0026quot;/fonts/**\u0026quot;, \u0026quot;/img/**\u0026quot;, \u0026quot;/js/**\u0026quot;); } @Bean public PersistentTokenRepository persistentTokenRepository(){ JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl(); tokenRepository.setDataSource(datasource); return tokenRepository; } @Bean(name = BeanIds.AUTHENTICATION_MANAGER) @Override public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } @Bean CorsConfigurationSource corsConfigurationSource() { CorsConfiguration configuration = new CorsConfiguration(); configuration.setAllowedOrigins(Arrays.asList(\u0026quot;http://localhost:8888\u0026quot;)); configuration.setAllowedMethods(Arrays.asList(\u0026quot;GET\u0026quot;,\u0026quot;POST\u0026quot;)); configuration.applyPermitDefaultValues(); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\u0026quot;/**\u0026quot;, configuration); return source; } }  解决跨域访问的问题 首先我们就得去了解一下这个浏览器的同源策略，所谓的这个同源策略，就是说在向服务端发起这个HTTP请求的时候。在浏览器里面，它这个要求域名、端口和协议必须是一致的，也就是说。你的你当前的这个应用，不能访问别人的这个数据资源，或者说不能访问别人的这个页面资源，否则浏览器就会去限制你。那我们来看一下这张图，假如说现在我们的这个应用是前后端分离的，相当于，我们前端的部署在一个主机上，然后它有一个，这样一个域名，然后什么端口，然后，我们后端部署在另外一个主机上，然后他也有自己的域名，然后有一些端口的信息，那当我们去请求的时候发生，在HTTP请求的时候，实际上是在浏览器上，去请求前端的页面，然后返回回来，浏览器响应这个页面。然后，浏览器在请求后端的这个数据的时候，这个浏览器上的这个他的这个同源策略就会去限制你，因为你最开始访问的是aaa.com，也就是说我们的前端这个应用，然后当你去请求数据的时候，你就发送给这个bbb.com，他认为你，请求别的应用资源，而不是你自己的应用资源，这个浏览器就会限制你，这个就是浏览器的这个同源策略。\n但是，这个同源策略，是有一些方案有一些方法去，可以去打破这个同学车里的这个限制的，，那我们来看一下有哪些这个打破同源策略限制这样一些方法。因为的确有这样的需求，就是说我们这个前后端应用是分开部署的，，所以说，它一定是这个不符合同源策略的，那我们还要去访问我们后端的这个服务，我们应该怎么去做？、\n第一类方案 第一类方案:前端解决方案 虽然浏览器对于不符合同源策略的访问是禁止的，但是仍然存在例外的情况，如以下资源引用的标签不受同源策略的限制:\n html的script标签 html的link标签 html的img标签 html的iframe标签:对于使用jsp、freemarker开 发的项目，这是实现跨域访问最常见的方法，  那么第1种方式，就是说浏览器这个在这个HTML里面，有一些标签它是不受同源策略的限制的。\n哪些标签不受同源策略的限制？，就是这些标签，比如说html里面的script标签，他可以去加载另外一个域下面的这个家族的脚本，然后link标签，可以加在另外一个域下面的css文件，或者是html的这个img标签，它可以加载另外一个域下面的这个图片，那还有一个比较重要的，就是iframe这个标签，它可以去加载一些页面，去加载一个另外应用的页面。就是内嵌的那种，这种方式，对于jsp和freemarker。这种开发的项目是实现这个跨越访问的比较常见的一种方法就是使用这个iframe，那我们这是第1种方案，这个方案我相信大家都比较熟悉了，就是说用这个html里面的特殊的这几个标签。这几个标签，它不受同源策略的限制。\n第二类方案 那第2种解决方案，就是说我们使用在前端应用和后端应用的前面，再放上一个代理，或者说我们管它叫负载均衡的服务器也可以。这个代理的作用就是什么？在浏览器或者是其他终端访问的前面，我们加上这样一个代理之后，浏览器看到的前端资源和后端服务，就是同一个域下面的。\n我们来看一下这个图，当你就是以往的，当你去访问前端资源的时候，然后你再去访问后端资源，因为这两个资源是部署在不同的这个服务器上的，所以说，它是一定是IP、域名、端口不一致。所以说，它受同源策略的限制，你先访问了前端资源，然后端的服务你就访问不了，但是，我们可以怎么去做，我们可以在前端的这个服务和后端资源的前面，加上一个代理。加上代理之后，它自己就有一个IP、端口。所以说，在我们一系列前端的浏览器，或者是一些前端的一些东西来看，它的这个都是一个来源，它都是从代理上来的。相当于，我们把后端的这部分，给他屏蔽掉，所以说，这样也是同源策略，这个也是符合同源策略，符合同源策略。\n这个源是哪？这个源就是我们的这个代理，就是我们这个代理，他IP和端口上是一致的，然后把后端屏蔽掉，这种方式也可以让浏览器认不出来后面的前端资源和后端资源。因为他都通过这个代理的IP和端口去访问，所以说，这个也是符合浏览器的同源策略。\n第三类方案 第三类方案: CORS\n Access-Control-Allow-Origin::允许哪些ip或域名可以跨域访问 Access-Control-Max-Age::表示在多少秒之内不需要重复校验该请求的跨域访问权限 Access-Control-Allow-Methods::表示允许跨域请求的HTTP方法，如:GET,POST,PUT,DELETE Access-Control-Allow-Headers::表示访问请求中允许携带哪些Header信息，如: Accept、 Accept-Language、 Content-Language、 Content-Type  第3种解决方案是什么？就是我们本节要给大家重点介绍的，这个叫cors，也就是跨站访问的这样一个配置。这个配置，我们可以在spring boot里面去实现，他的这个原理是什么？\n当我们的浏览器去加载前端资源的情况下，他访问的是aaa.com这个域名，前端的这个服务，把它的资源给返回给我们浏览器，然后渲染到浏览器上。他在发起后端请求的时候，他先去服务上做一个叫预检的这样一个步骤，她做预检的目的是什么？就是来判断一下，你这个后端的服务是否是可以提供给不同的域的。比如说aa.com域下面的服务去加载你BB.com域下的数据。如果预检通过的话，他就会返回预检通过了，如果预检通过之后，他就不再受同源策略的限制了，也就是说可以去访问的了。\n这个预检的功能就有点像什么？比如说，你到一个朋友家，然后想去朋友家去借书，你先给他打了个电话，然后他同意了。你见到他的父母，然后你就说我给那个谁已经打过电话，他同意我过来取一本书。这种情况下，他的父母会同意你把这本书取走，否则，你不是他家的人，然后，他就不会让你取这个资源，大概就是这样，用这样一个浅显的例子。就是说，你去朋友家借书，然后朋友不在家，你先给朋友打个电话，朋友说同意了，他有可能也会告诉一下他父母，等会我又有一个朋友，来回会来我们家里取书，这个书我可以借给他。那这个借书的这个人，实际上就是我们的浏览器，然后被借书的实际上就是相关技术的家庭。然后对家庭，后端服务，实际上是他的父母。后台服务，实际上是这个，而不是他的父母，是她自己，他进行一个预检，打电话就说是否同意我借这个书，他说同意，然后，等会他就可以去家里，然后去把这本书借回来，所以说，这种情况下，它就不受这个同源策略的限制。这个就是比较有钱比较浅显的这样一个理解吧\n那我们来，看一下，具体的话这个协议它实现是靠什么去实现的？也就是说在预检的过程中，它也会向我们的服务端发送请求，但是他发送请求之后，他不是真正去请求资源。他去判断这个资源，是否是可以打破同源策略，那我们通过哪些方式告诉他是否可以打破同源策略？就是在请求响应请求的响应里面加上请求头，然后告诉她哪些IP或者域名可以跨域访问，实际上就是打破同源策略。\n当浏览器向后端这个服务端发送这个预检请求的时候，它响应这些请求，将这些请求头响应给的浏览器。浏览器解析到这些请求头之后，它会二次发起请求，然后请求我们后台数据，此时，它携带的这些信息，就告诉浏览器，实际上它就不受同源策略限制了，所以可以跨域访问。那这个浏览器解析到这些请求头之后，就不做这个跨越这个同源策略的限制，允许跨域访问，那就是这样一个效果。\nspringboot环境下CORS实现方式 方式一 是全局配置，也就是说他对所有的请求权都生效的这个配置。\n/* * Created by IntelliJ IDEA. * User: 木木 * Date: 2020/6/13 * Time: 17:03 */ @Configuration public class GlobalCorsConfig { @Bean public CorsFilter corsFilter(){ CorsConfiguration config = new CorsConfiguration(); //开放哪些ip、端口、域名的访问权限，星号表示开放所有的域 config.addAllowedOrigin(\u0026quot;*\u0026quot;); //是否允许发送Cookie信息 config.setAllowCredentials(true); //开放哪些Http方法，允许跨域访问 config.addAllowedMethod(HttpMethod.GET); config.addAllowedMethod(HttpMethod.PUT); config.addAllowedMethod(HttpMethod.DELETE); config.addAllowedMethod(HttpMethod.POST); //允许Http请求中携带的哪些Header信息 config.addAllowedHeader(\u0026quot;*\u0026quot;); //暴漏哪些头部信息，（因为跨域访问默认是不能获取全部头信息） config.addExposedHeader(\u0026quot;*\u0026quot;); //添加映射路径，\u0026quot;/**\u0026quot;表示对所有的路径实行全局跨域访问权限的设置 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration(\u0026quot;/**\u0026quot;, config); return new CorsFilter(configSource); } }  方式二 /* * Created by IntelliJ IDEA. * User: 木木 * Date: 2020/6/13 * Time: 17:16 */ @Configuration public class GlobalCorsConfig02 { @Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurer() { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026quot;/**\u0026quot;)//添加映射路径，\u0026quot;/**\u0026quot;表示对所有的路径实行全局跨域访问权限的设置 .allowedOrigins(\u0026quot;*\u0026quot;)//开放哪些ip、端口、域名的访问权限，星号表示开放所有的域 .allowCredentials(true)//是否允许发送Cookie信息 .allowedMethods(\u0026quot;GET\u0026quot;, \u0026quot;POST\u0026quot;, \u0026quot;PUT\u0026quot;, \u0026quot;DELETE\u0026quot;)//开放哪些Http方法，允许跨域访问 .allowedHeaders(\u0026quot;*\u0026quot;)//允许Http请求中携带的哪些Header信息 .exposedHeaders(\u0026quot;*\u0026quot;);//暴漏哪些头部信息，（因为跨域访问默认是不能获取全部头信息） } }; } }  方式三 使用CrossOrigin注解(局部跨域配置)\n 将CrossOrigin注解加在Controller层的方法上，该方法定义的RequestMapping端点将支持跨域访问 将CrossOrigin注解加在Controller层的类定义处， 整个类所有的方法对应的RequestMapping端点都将支持跨域访问\n@RequestMapping(\u0026quot;/cors\u0026quot;) @ResponseBody @CrossOrigin(origins = \u0026quot;http://localhost:8080\u0026quot;,maxAge = 3600) public String cors() { return \u0026quot;cors\u0026quot;; }   方式四 使用httpServletResponse设置响应头，局部跨域配置\n@RequestMapping(\u0026quot;/cors\u0026quot;) @ResponseBody public String cors1(HttpServletResponse response) { //使用httpServletResponse设置响应头，最原始的方法也是最通用的方法 response.addHeader(\u0026quot;Access-Control-Allow-Origin\u0026quot;,\u0026quot;http://localhost:8888\u0026quot;); return \u0026quot;cors\u0026quot;; }  很不幸的是:在Spring Security环境 下以上四种方式全部失效\nspring security 解决跨域问题 在springsecurity配置类中增加\nhttp.cors.and().xxxxx  前面的四种方式再springsecurity中也可以生效，但是springSecurity更建议我们使用下面的方式（也算是第五种方式吧）：\n再增加一个方法\n@Bean CorsConfigurationSource corsConfigurationSource() { CorsConfiguration configuration = new CorsConfiguration(); configuration.setAllowedOrigins(Arrays.asList(\u0026quot;http://localhost:8888\u0026quot;)); configuration.setAllowedMethods(Arrays.asList(\u0026quot;GET\u0026quot;,\u0026quot;POST\u0026quot;)); configuration.applyPermitDefaultValues(); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\u0026quot;/**\u0026quot;, configuration); return source; }  跨站攻击防御  CORS(跨站资源共享)是局部打破同源策略的限制，使在一定规则下HTTP请求可以突破浏览器限制，实现跨站访问。 CSRF是一种网络攻击方式，也可以说是一种安全漏洞，这种安全漏洞在web开发中广泛存在。我们要需要堵上这个漏洞。  那第1个它是跨站资源共享是局部打破同源策略的限制，在一定的规则下，HTTP请求可以突破这个浏览器的限制，实现这个跨站的这种访问，这个是c or s跨站资源共享。\nCSRF叫做跨站资源跨站请求伪造，他准确的说是一种网络的这种攻击的一种方式，或者说是一种安全的这种漏洞，这种漏洞在我们的这个web开发这个应用中广泛的存在，我看过很多的应用，包括绝大部分的80%以上的开源软件，就是关于web开发的，都没有针对这个攻击方式进行防御，那我们本节来就来给大家讲一下，怎么针对这个攻击方式进行一下防御。。那我们要想知道怎么防御的话，我们得知道它怎么攻击，我们怎么攻击我给大家举了一个例子，就是对方如何利用这种方式去攻击，\n典型的跨站攻击\n 你登录了网站A，攻击者向你的网站A账户发送留言、或者伪造嵌入页面，带有危险操作链接。 当你在登录状态下点击了攻击者的连接，因此该链接对你网站A的账户进行了操作。 这个操作是你在网站A中主动发出的，并且也是针对网站A的HTTP链接请求，同源策略无法限制该请求。  当你作为一个用户登录了一个网站，然后攻击者向你的网站的那个账户上，发生了一些留言，或者一些伪造的这些那个嵌入式的这种页面，或者是一些危险的这种链接，你在登录状态下，然后你有意无意的吧，反正你就是点了这个链接，你就把这个链接给点击了。这个链接就是针对你的，当前你登陆了这个账户进行的操作，那这个就没有办法了，这个就是这个操作是你主动发出的，因为他是你点的，而且你已经登陆了，并且这个链接，应该是对这个当前的这个网站进行的操作，。同源策略也没有办法限制他，就是他这个链接就是针对你当前登陆这个网站进行了这个操作，而且是你主动点的，任何的策略都没有办法去限制他做任何的动作。所以说，假如说这个链接，就是一个转账的链接，那你的钱就被转走了，就是这么简单，所以说，你在网站上那个别人发给你的链接，你不要随便点，那这个就是他的一种的攻击方式，他伪造了这个，一个链接，这个链接是针对网站的这样一个链接，因为他可能对这个网站进行过一个分析，把这个链接发给一些用户，这个用户点了这个链接，就针对这个网站，它自己的这个账户进行操作，这也是典型的这种，跨站的请求的伪造的这种攻击方式。\n那么这种攻击方式？他有点像什么呢？他有点像那个，比如说你要办婚礼，你要办婚礼，然后有人，就伪造了自己的身份，他自己进去，还在办这个婚礼的时候，他进去混吃混喝。我举这么一个例子吧，，有点像这个。\n跨站攻击防御 为系统中的每一个连接请求加上一个token,这个token是随机的，服务端对该token进行验证。破坏者在留言或者伪造嵌入页面的时候，无法预先判断CSRF token的值是什么，所以当服务端校验CSRFtoken的时候也就无法通过。\n那我们怎么去防御它？那就是说我们这种防御的方式，就是说我们要给每一个来参加我们这个婚礼，或者是访问我们资源的这个用户，给他发上一个这样的一个请柬，你可以这么去认为，，这个请帖，实际上就是一个令牌，然后我们给她发生这样一个令牌，就说这个令牌是随机的。然后，它我们会对这个令牌进行验证，就有点像什么，就是我们随机制作了一批请柬，然后发给我，发给我们参加婚礼的嘉宾，然后我们把这个请柬全都发出去，这些请柬什么样的只有我自己知道，别人谁也不知道。那这个请柬在发送出去之后，完了到那天的时候，他们就会来参加我们的婚礼的宴请，然后当他进来的时候，就会有人，请出示你的请柬，然后如果这个请柬不是我们发送的，不是我们发的请柬，那他就进不来。\n所以说，这个跨站攻击防御，我们就，对它进行防御的这种方式，我们就是。给他在他我们给他发送请柬，就发生了一个这个令牌，在这令牌，在他来访问我们资源的时候，你要把这个CSRF这种跨站攻击防御的这个令牌带上，如果你不带的话我就不让你进来，就是这么个意思，那我们这个跨站攻击防御，那我们这个原理，大概就这个原理，\n我们知道了这个原理之后，我们来就来做一下怎么来对它进行防御，我们就来用我们的这个编码的方式来实现一下。\n.and().csrf().disable()//关闭了csrf  这个我们之前是把这个防御功能给它关掉了，我们在之前的代码把它关掉，如果不关掉的话，我们的请求像post、delete、put请求，都是发不进来的，都是发不进来的。这个跨站攻击防御，它不防get请求，他针对get请求是不做防御的。它只防put，post、delete这种修改数据的这种请求，所以说，我们把这个东西给它打开，\nhttp.csrf().and().xxxx//开启csrf  把这个功能开启之后，我们要做一些配置。我们既然要发送发送我们这个token，也就是说我们的令牌，我们的请柬。那我们的服务端要把请柬保存起来，我们就要用这样一个csrfTokenRepository\nhttp.csrf() .csrfTokenRepository(CookieCsrfTokenRespository.withHttpOnlyFalse()) .ignoringAntMatchers(\u0026quot;/authentication\u0026quot;)  我们在认证的时候它通过这个cookie，给我们返回了一个这样的令牌叫XSRF-TOKEN，也就是说这个跨站攻击防御的这样一个令牌，也就是说这个是我们的请柬，这是我们的请柬，发送请求的时候需要在请求头加上我们的token（别忘了加上我们的JWT令牌请求头），key为X-XSRF-TOKEN\n我们做了一个这样的配置叫做withHttpOnlyFalse这个的意思是告诉浏览器，我这个当前的这个cookie是可以被js脚本去读取的。我为什么可以允许去CS脚本去读取，因为我们要把它读取出来，然后放到我们的请求的这个位置上，我们要发送请求的时候，我们肯定要先从这个cokie里面把它给读取出来。所以说，这个withHttpOnlyFalse的意思就是说当前我们这个cookie当前我们的这个cookie，它是允许httpOnly为false（看XSRF-TOKEN的属性的时候）表示当前的这个cookie这条记录，可以被脚本读取，那样我们才能发起请求的时候才放在请求头。这个配置的目的，是为了前端能够正确的读到我们当前的这个令牌，所以说，我们做这样一个配置\n前端携带参数的方式 thymeleaf 再header中携带CSRF token\nvar headers={}; headers[\u0026quot;X-CSRF-TOKEN\u0026quot;]=\u0026quot;${_csrf.token}\u0026quot;; $ajax({ headers: headers, });  直接作为参数提交\n$ajax({ data: { \u0026quot;_csrf\u0026quot;: \u0026quot;${_csrf.token}\u0026quot;; } });  form表单隐藏字段\n\u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;${_csrf.parameterName}\u0026quot; value=\u0026quot;${_csrf_token}\u0026quot;\u0026gt;  JWT集群应用方案 我们来先回顾一下，JWT应用的这个授权验证流程。首先，我们浏览器通过用户名和密码，然后进行登录，然后登陆成功的话，我们会在这个Controller里面，生成一个JWT的令牌，然后返回给我们的浏览器。浏览器将这个浏览器端的这个前端程序，将这个JWT的令牌把它保存起来，然后，在以后每一次访问我们后端的任何的接口资源的时候，都要需要把这个zwt令牌带上。然后，我们的整个这个应用中，会有一个这样一个过滤器，然后来验证这个令牌的合法性，如果令牌和法，我们进行授权，他访问我们的这个资源，然后我们这个资源给他一个响应的结果。那这个，就是我们这样一个JWT的这样一个单体应用，它的这样一个请求与响应的过程。\n那假如说，我们想把我们的应用。部署成为一个集群，也就是说上面的那个就是我们的那一套代码的这个JWT的这一套代码，我们给他部署两份，形成一个集群应用，也就是应用a和应用b，代码是同一套的，但是我们部署两份，那我们有没有可能，是有这样的需求，因为我们部署两份的目的，就是让它达到一个负载均衡分流的这样一个效果，然后，一个应用承担一部分的流量，那我们有没有可能实现，浏览器进行授，进行认证的时候他访问的是应用a，然后他需要访问接口资源的时候，它这个请求分流到我们的应用B上。这种情况肯定是有的，那我们思考就是说这种情况，这个应用B鉴权，就是验证这个JWT令牌的时候是是可以通过吗？他能够访问我们的这个a进行这个认证，然后发令牌，然后拿他拿令牌上B去访问接口资源，这样可以吗?\n当然是可以的，因为，我们两个应用中都没有使用session去保存任何的状态信息所有的信息，都是我们从数据库去加载的，所以说状态信息这个保存的不是我们的问题，所有的我们都是通过一个用户名，然后去数据库里面去加载。只要这两个应用的使用的是同一个数据库里面的这种授权数据，甚至你使用的不是同一个库，但是数据是一样的，使用同一个签名使用同一个的这个密钥就是我们的那个secret，进行签名和解签。那就可以实现的这个应用a的认证，再应用b中被承认，这样一种效果。\n所以说，我们这个JWT的集群是特别容易去扩展的，然后我们只要保证我们的这个授权数据是同一套，然后我们签名和解签的密钥是一样的，然后，我们就可以把同一份代码然后部署多份，实现这样一个集群应用的这样一个效果。然后，我们前端进行一个负载均衡的这样一个分流，那我们这样这个集群应用特别容易扩散。\n那我们在思考一个问题还可以思考一个问题，那就是我们的应用，假如说应用a和应用b，它不是一套代码，他部署的是两套代码，然后，他也是使用的是JWT，那可以实现应用a认证，然后应用b然后进行授权访问吗？可以思考一下这个问题。\n给大家一个答案，这个仍然是可以的，应用a和应用b，虽然他们两个的业务资源的代码不一样，但是我们可以让他什么一样，我们可以让他Controller的这个代码是一样的，也就是说，你这个认证的代码要统一，就是说这个JWT颁发JWT令牌的这个代码，这两个control，要代码要一致，然后，你进行这个校验的这个future的这个代码要一致，然后，你使用同一套授权数据，然后，你使用同一个签名和签的这个密钥。然后你就可以实现这种，不是同一套的这个代码，然后部署多份，然后他们之间也是可以进行这个认证和授权的认证，然后鉴权接口资源访问，这样也是可以的。\n所以说，JWT这一套东西，它核心的HTTP之间交互的都是数据，只要你的这个令牌这个签名和解签，然后授权的这些数据是一套，然后你鉴权颁发，这些代码也都是一套的，那你就可以实现。虽然你的业务接口资源不一样。应用A是以自己的接口资源，应用B也是自己的接口资源。他们两个不一样没有关系，你只要保证其他的部分数据的授权数据，然后授权的conntroller，然后，这个包括我们的验证的这个filter，然后我们的密钥是一份。这两个应用，就可以实现互相承认的这样一种效果。\nJWT应用分布式部署的条件\n 认证Controller代码统一 鉴权Filter代码统一、校验规则是一样的。 使用同一套授权数据 同一个用于签名和解签的secret。  再来思考一个问题，基于刚才这个前提，我们完全可以把我们认证的这个部分，就是这个Controller就是颁发JWT令牌的这个Controller，单独给它抽出来形成一个应用，，也就是，这个是经常我们会听到大家说的这种叫做认证服务器进行认证服务器，他就是专门用户名和密码，然后发放在JWT令牌的这样一个认证服务器，然后，我们可以把它单独抽取出来，那我们甚至把它单独抽取出来之后，我们甚至还可以进一步把这个filter，他也是要求统一的吗？我们完全可以把这个验证的这个令牌验证的这个过滤器，把他这个代码也单独抽取出来，形成我们的这个服务网关而形成服务网关，当然，这个JWT这个过滤器的这个抽取过程，它不像这个Controller的这个抽取那么简单，因为这个服务网关不光有这个令牌验证的这个功能，它还有这个请求转发的这样一个功能，所以说，大家这个前端的这个，那就是服务网关了，这个需要在服务网关中进行这个过滤器的这样一个最大的信息平台的认证，我们通常管这个，抽取出来的内容，就是这个验证逻辑，加上我们这个请求转发逻辑，形成一个单独的这样一个前端，在这个接口资源的前面，我们管它叫服务网关，这个大家如果学过spring cloud的话，我们完全可以把这个JWT的令牌这个验证逻辑，放到这个服务网管理进行验证。那我们最后就剩下一些这个接口资源了，我们通常管它叫做这个资源服务器。\n","id":13,"section":"posts","summary":"SpringSecurity 官网: SpringSecurity是强大的，且容易定制的实现认证，与授权的基于Spring 开发的框架。 Spring Security的核心功能 Auth","tags":["Spring家族"],"title":"SpringSecurity自学笔记","uri":"https://mumulx.github.io/2020/03/springsecurity/","year":"2020"},{"content":" 源码\nSpringCloud 微服务架构4个核心问题?\n 服务很多，客户端该怎么访问? 这么多服务?服务之间如何通信? 这么多服务? 如何治理? 服务挂了怎么办?  解决方案:Spring Cloud生态!\nSpring Cloud NetFlix一站式解决方案！\napi网关，zuu1组件\nFeign \u0026mdash;Httpclinet \u0026mdash;- Http通信方式，同步，阻塞\n服务注册发现: Eureka\n熔断机制: Hystrix\nApache Dubbo Zookeeper半自动，需要整个别人的\nAPI:没有，找第三方组件，或者自己实现\nDubbo\nZookeeper\n没有:借助Hystrix\nDubbo这个方案并不完善~\nspring Cloud Alibaba一站式解决方案\n新概念:服务网格~Server Mesh\nistio\n万变不离其宗 1. API 2. HTTP,RPC 3. 注册和发现 4. 熔断机制\n归根结底的原因是：网络不可靠！\n微服务概述 什么是微服务\n什么是微服务?微服务(Microservice Architecture)是近几年流行的一种架构思想，关于它的概念很难一言以蔽 之。\n究竟什么是微服务呢?我们在此引用ThoughtWorks公司的首席科学家Martin Fowler于2014年提出的- -段话:\n原文：\n汉化:\n 就目前而言，对于微服务，业界并没有一个统- -的， 标准的定义 但通常而言，微服务架构是一 种架构模式，或者说是一-种架构风格， 它提倡将单- -的应用程序划分成- -组小 的服务，每个服务运行在其独立的自己的进程内，服务之间互相协调，互相配置，为用户提供最终价值。服务 之间采用轻量级的通信机制互相沟通，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产 环境中，另外，应尽量避免统- -的，集中式的服务管理机制，对具体的一个服务而言,应根据业务上下文,选 择合适的语言，工具对其进行构建,可以有一个非常轻 量级的集中式管理来协调这些服务，可以使用不同的语 言来编写服务,也可以使用不同的数据存储;  可能有的人觉得官方的话太过生涩，我们从技术维度来理解下:\n微服务化的核心就是将传统的一站式应用，根据业务拆分成: 个一 的服务,彻底地去耦合,每一个微服务提 供单个业务功能的服务，-个服务做-件事情,无识别结果种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁,拥有自己独立的数据库。\n微服务与微服务架构 微服务 强调的是服务的大小，他关注的是某-个点, 是具体解决某-个问题/提供落地对应服务的- 一个服务应用，狭义的 看，可以看做是IDEA中的-一个个微服务工程,或者Moudel\nIDEA工具里面使用Maven开发的一个个独立的小Moudle, 它具体是使用springboot开发的一个小模块，专业的事 情交给专业的模块来做，- 一个模块就做着一 -件事情\n强调的是-一个个的个体，每个个体完成-一个具体的任务或者功能!\n微服务架构 一种新的架构形式，Martin Fowler, 2014提出\n微服务优缺点 优点\n 每个服务足够内聚,足够小，代码容易理解，这样能聚焦-个指定的业务功能或业务需求; 开发简单,开发效率提高，-个服务可能就是专- -的只干一 -件事; 微服务能够被小团队单独开发,这个小团队是2~5人的开发人员组成; 微服务是松耦合的,是有功能意义的服务,无论是在开发阶段或部署阶段都是独立的。 微服务能使用不同的语言开发。 易于和第三方集成,微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如jenkins, Hudson, bamboo 微服务易于被一个开发人员理解，修改和维护,这样小团队能够更关注自己的工作成果。无需通过合作才能体 现价值。 微服务允许你利用融合最新技术。 微服务只是业务逻辑的代码，不会和HTML，CSsS 或其他界面混合 每个微服务都有自己的存储能力，可以有自己的数据库,也可以有统- -数据库  缺点:\n 开发人员要处理分布式系统的复杂性 多服务运维难度，随着服务的增加，运维的压力也在增大 系统部署依赖 服务间通信成本 数据一致性 系统集成测试 性能监控.  微服务技术    微服务条目 落地技术     微服务开发 springBoot、Spring、SpringMVC   服务配置与管理 Netflix公司的Archaius、阿里的Diamond等   服务注册与发现 Eureka、Consul、Zookeeper等   服务调用 Rest、RPC、gGPC   服务熔断器 Hystrix、Envoy等   负载均衡 Ribbon、Nginx等   服务接口调用（客户端调用服务的简化工具） Feign等   消息队列 kafka、rabbitMQ、Chef等   服务配置中心管理 Zuul等   服务路由（API网关） Zabbix、Nagios、Metrics、Specatator等   服务监控 Ziokin、Brave、Dapper   全链路追踪 Docker、OpenStack、Kubernets等   服务部署 SpringCloud Stream（封装Redis、Rabbit、Kafka等发送接收消息）   数据流操作开发包 SpringCloud Bus   时间消息总线     为什么选择SpringCloud作为微服务架构\n选型依据\n 整体解决方案和框架成熟度\n 社区热度\n 可维护性\n  学习曲线 当前各大IT公司用的微服务架构有哪些?\n 阿里: dubbo+HFS 京东: JSF 新浪: Motan 当当网DubboX  各微服务框架对比\n   功能点/服务框架 Netfix/SpringCloud Motan gRPC Thrift Dubbo/DubboX     功能定位 完整的微服务架构 RPC框架，但整合了ZK或Consul，实现集群环境的基本服务注册/发现 RPC框架 RPC框架 服务框架   支持Rest 是，Ribbon支持多种可拔插的序列化选择 否 否 否 否   支持RPC 否 是(Hession2)是 是 是 是   支持多语言 是（Rest形式） 否 是 是 否   负载均衡 是（服务端zuul+客户端Ribbon），zuul-服务，动态路由，云端负载均衡Eureka（针对中间层服务器） 是（客户端） 否 否 是（客户端）   配置服务 NEtfix Archaius，Spring Cloud Config Server集中配置 是（Zookeeper提供） 否 否 否   服务调用链监控 是（zuul），zuul提供边缘服务，API网关 否 否 否 否   高可用/容错 是（服务端Hystrlx+服务端Ribbon） 是（客户端） 否 否 是（客户端）   典型应用案例 Netflix Sina Google FaceBook    社区活跃程度 高 一般 高 一般 2017年后重启开始维护，之前终段了五年   学习难度 中等 低 高 高 低   文档丰富程度 高 一般 一般 一般 高   其他 Spring Cloud Bus为我们的应用程序带来了更多管理端点 支持降级 Netflix内部再开发继承gRPC IDL定义 时间的公司比较多    SpringCloud入门概述 SpringCloud是什么\nSpring官网:\nSpringCloiud,基于SpringBoot提供了-套微服务解决方案，包括服务注册与发现，配置中心，全链路监控,服务 网关，负载均衡，熔断器等组件,除了基于NetFlix的开源组件做高度抽象封装之外,还有一些选型中立的开源组 件。\nSpringCloud利用SpringBoot的开发便利性，巧妙地简化了分布式系统基础设施的开发, SpringCloud为开发人员 提供了快速构建分布式系统的-些工具，包括配置管理,服务发现，断路器，路由，微代理，事件总线,全局锁, 决策竞选，分布式会话等等,他们都可以用SpringBoot的开发风格做到一-键启动和部署。\nSpringBoot并没有重复造轮子，它只是将目前各家公司开发的比较成熟，经得起实际考研的服务框架组合起来, 通过SpringBoot风格进行再封装，屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂，易部署 和易维护的分布式系统开发工具包\nSpringCloud是分布式微服务架构下的一-站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家 桶。\nSpringCloud和SpringBoot关系  SpringBoot专注于 快速方便的开发单个个体微服务。 SpringCloud是关注全 局的微服务协调整理治理框架，它将SpringBoot开发的一 个个单体微服务整合并管理起 来,为各个微服务之间提供:配置管理，服务发现，断路器，路由，微代理，事件总线，全局锁，决策竞选, 分布式会话等等集成服务。 SpringBoot可以离开SpringClooud独立使用，开发项目，但是SpringCloud离不开SpringBoot, 属于依赖关 系\n SpringBoot专注于快速、 方便的开发单个个体微服务, SpringCloud关注全 局的服务治理框架\n  Dubbo 和SpringCloud技术选型 分布式+服务治理Dubbo\n目前成熟的互联网架构:应用服务化拆分+消息中间件\nDubbo和SpringCloud对比 可以看一- 下社区活跃度\nhttps://github.com/dubbo\nhttps://github.com/spring-cloud\n结果:\n    Dubbo Spring     服务注册中心 Zookeeper Spring Cloud Netflix Eureka   服务调用方式 RPC REST API   服务监控 Dubbo-monitor Spring Boot Admin   短路器 不完善 Spring Cloud Netflix Hystrix   服务网关 无 Spring Cloud Netflix Zuul   分布式配置 无 Spring Cloud Config   服务追踪 无 Spring Cloud Sleuth   消息总线 无 Spring Cloud Bus   数据流 无 Spring Cloud Stream   批量任务 无 Spring Cloud Task    最大区别: SpringCloud抛弃 了Dubbo的RPC通信，采用的是基于HTTP的REST方式。\n严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原 生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的 强依赖，这在强调快速演化的微服务环境下,显得更加合适。\n品牌机与组装机的区别\n很明显，Spring Cloud的功能比DUBBO更加强大，涵盖面更广，而且作为Spring的拳头项目，它也能够与Spring Framework. Spring Boot. Spring Data. Spring Batch等其他Spring项目完美融合,这些对于微服务而言是至 关重要的。使用Dubbo构建的微服务架构就像组装电脑，各环节我们的选择自由度很高,但是最终结果很有可能 因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果你是一名高手, 那这些都不是问题;而Spring Cloud就像品牌机，在Spring Source的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性,但是如 果要在使用非原装组件外的东西，就需要对其基础有足够的了解。\n社区支持与更新力度\n最为重要的是，DUBBO停止了5年左右的更新，虽然2017.7重启了。对于技术发展的新需求，需要由开发者自行 拓展升级(比如当当网弄出了DubboX)，这对于很多想要采用微服务架构的中小软件组织，显然是不太合适的, 中小公司没有这么强大的技术能力去修改Dubbo源码+周边的一整套解决方案,并不是每一个公司都有阿里的大牛 +真实的线上生产环境测试过。\n总结:\n曾风靡国内的开源RPC服务框架Dubbo在重启维护后，令许多用户为之雀跃，但同时，也迎来了一一些质疑的声 音。互联网技术发展迅速，Dubbo 是否还能跟上时代? Dubbo与Spring Cloud相比又有何优势和差异?是否会 有相关举措保证Dubbo的后续更新频率?\n人物: Dubbo重启维护开发的刘军,主要负责人之一\n刘军，阿里巴巴中间件高级研发工程师，主导了Dubbo重启维护以后的几个发版计划，专注于高性能RPC框架 和微服务相关领域。曾负责网易考拉RPC框架的研发及指导在内部使用，参与了服务治理平台、分布式跟踪系 统、分布式一致性框架等从无到有的设计与开发过程。\n解决的问题域不-样: Dubbo的定位是一 -款RPC框架, Spring Cloud的目标是微服务架构下的一站式解决方案\n设计模式+微服务拆分思想\nSpringCloud能干嘛  Distributed/versioned configuration (分布式/版本控制配置) Service registration and discovery (服务注册与发现) Routing (路由) Service-to-service calls (服务到服务的调用) Load balancing (负载均衡配置) Circuit Breakers (断路器) Distributed messaging (分布式消息管理)  SpringCloud在哪下 官网: http://projects.spring.io/spring-cloud/\n这玩意的版本号有点特别\nSpring Cloud是一个由众多独立了项目组成的大型综合项目，每个了项目有不同的发行节奏，都维护着自己的发布版 本号。spring Cloud通过一个资源清单BOM (Bi11 of Materials) 来管理每个版本的子项目清单。为避免与子项 目的发布号混淆，所以没有采用版本号的方式，而是通过命名的方式。\n这些版本名称的俞名方式采用了伦敦地铁站的名称，同时根据字母表的顺序来对应版本时间顺序，比如:最早的 Release版本: Ange1, 第二个Release版本: Brixton, 然后是Camden、Dalston、Edgware, 日前最新的是 Finch7ey版本。\n参考书:\n https://springcloud.cc/spring-cloud-netflix.html 中文API文档: https://springcloud.cc/spring-cloud-dalston.html SpringCloud中国社区 http://springcloud.cn/ SpringCloud中文网 https://springcloud.cc  SpringCloud版本选择 大版本说明\n   Spring Boot Spring Cloud 关系     1.2.x Angel版本（天使） 兼容Spring Boot 1.2.x   1.3.x Brixton版本（布里克斯顿） 兼容Spring Boot 1.3.x，也兼容Spring Boot 1.4.x   1.4.x Camden版本（卡姆登） 兼容Spring Boot 1.4.x，也兼容Spring Boot 1.5.x   1.5.x Dalstion版本（多尔斯顿） 兼容Spring Boot 1.5.x，不兼容Spring Boot 2.0.x   1.5.x Edware版本（埃奇韦尔） 兼容Spring Boot 1.5.x，不兼容Spring Boot 2.0.x   2.0.x Funchley版本（芬奇利） 兼容Spring Boot 2.0.x，不兼容Spring Boot 1.5.x   2.1.x GreenWich版本（格林威治）     实际开发版本关系\n实践 第一个springCloud项目 新建一个maven的父工程\n使用springcloud的版本为Greenwich.SR1\n添加依赖 \u0026lt;!-- 打包方式--\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;!-- 依赖版本控制--\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;junit.version\u0026gt;4.12\u0026lt;/junit.version\u0026gt; \u0026lt;log4j.version\u0026gt;1.2.17\u0026lt;/log4j.version\u0026gt; \u0026lt;lombok.version\u0026gt;1.16.20\u0026lt;/lombok.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!-- 依赖管理--\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- springcloud的依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;Greenwich.SR1\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- springboot的依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.4.RELEASE\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 数据库依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.46\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 数据源依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- springboot启动依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- junit测试依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${junit.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- lombok插件依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 日志依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${log4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt;  新建子模块（maven）springCloud-api 添加依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- 当前的module依赖，可以导入父工程依赖(如果父工程有此依赖)--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  数据库脚本 CREATE TABLE `dept` ( `dname` varchar(60) DEFAULT NULL, `deptno` bigint(20) NOT NULL AUTO_INCREMENT, `db_source` varchar(60) DEFAULT NULL, PRIMARY KEY (`deptno`) ) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8 COMMENT='部门表'; insert into `dept`(`dname`,`deptno`,`db_source`) values ('开发部',1,'db01'),('人事部',2,'db01'),('财务部',3,'db01'),('市场部',4,'db01'),('运维部',5,'db01'),('klz',10,'db01');  实体类\n@Data @NoArgsConstructor//无参构造 @Accessors(chain = true) //链式写法 //实现序列化的目的是为了保证流传输不出问题 public class Dept implements Serializable { /** * 链式写法 * dept.setDeptNo(11).setDname('sss').setDb_source() */ private long deptno; //主键 private String dname; //这个数据存在哪个数据库 private String db_source; /** * 链式写法 * dept.setDeptNo(11).setDname('sss').setDb_source() */ public Dept(String dname) { this.dname = dname; } }  新建子模块springcloud-provider-dept-8001(可以加上端口名)\n添加依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- 我们要拿到实体类，所以要配置api Module--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mumulx\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springCloud-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--junit--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mysql--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--数据源--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 日志--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--test--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--web--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shiro-spring-boot-web-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--web容器jetty--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jetty\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 热部署--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  server: port: 8001 # mybatis配置文件 mybatis: type-aliases-package: com.mumulx.springCloud.pojo config-location: classpath:mybatis/mybatis-config.xml mapper-locations: classpath:mybatis/mapper/*.xml #spring配置 spring: application: name: springboot-cloud-provider-dept datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: org.gjt.mm.mysql.Driver url: jdbc:mysql://localhost:3306/db01?useUnicode=true\u0026amp;characterEncoding=utf-8 username: root password: 111111  mybatis配置\n\u0026lt;!DOCTYPE configuration PUBLIC \u0026quot;-//mybatis.org//DTD Config 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026quot;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;!-- 设置二级缓存--\u0026gt; \u0026lt;setting name=\u0026quot;cacheEnabled\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;/configuration\u0026gt;  消费者\n添加依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- 实体类依赖，从api中导--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mumulx\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spirngboot的web依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 热部署依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  配置\n@Configuration public class ConfigBean { @Bean public RestTemplate getRestTemplate() { return new RestTemplate(); } }  @RestController public class DeptConsumerController { //消费者 没有servicec层 //RestTemplate ...方法供我们调用就可以了！ 注册sring中 //(url, 实体: Map, Class\u0026lt;T\u0026gt; ResponseType) @Autowired private RestTemplate restTemplate; private static final String REST_URL_PREFIX = \u0026quot;http://localhost:8001\u0026quot;; @RequestMapping(\u0026quot;/consumer/dept/get/{id}\u0026quot;) public Dept get(@PathVariable(\u0026quot;id\u0026quot;) Long id) { return restTemplate.getForObject(REST_URL_PREFIX + \u0026quot;/dept/get/\u0026quot;+id, Dept.class); } @RequestMapping(\u0026quot;/consumer/dept/add\u0026quot;) public boolean add(Dept dept) { return restTemplate.postForObject(REST_URL_PREFIX +\u0026quot;/dept/add\u0026quot;, dept, boolean.class); } @RequestMapping(\u0026quot;/consumer/dept/list\u0026quot;) public List\u0026lt;Dept\u0026gt; list() { return restTemplate.getForObject(REST_URL_PREFIX + \u0026quot;/dept/list\u0026quot;, List.class); } }  消费者 没有servicec层\nRestTemplate \u0026hellip;方法供我们调用就可以了！ 注册sring中\n(url, 实体: Map, Class ResponseType)\nEureka服务注册与发现 什么是Eureka  Eureka: 怎么读? Netflix 在设计Eureka时,遵循的就是AP原则 Eureka是Netflix的一 -个子模块, I也是核心模块之-。Eureka是一 个基于REST的服务，用于定位服务,以实现 云端中间层服务发现和故障转移,服务注册与发现对于微服务来说是非常重要的,有了服务发现与注册，只需 要使用服务的标识符，就可以访问到服务,而不需要修改服务调用的配置文件了，功能类似于Dubbo的注册 中心，比如Zookeeper;  原理讲解 Eureka的基本架构\n SpringCloud 封装了NetFlix公司开发的Eureka模块来实现服务注册和发现(对比Zookeeper) Eureka采用了C-S的架构设计，EurekaServer 作为服务注册功能的服务器，他是服务注册中心 而系统中的其他微服务。使用Eureka的客户端连接到EurekaServer并维持心跳连接。 这样系统的维护人 员就可以通过EurekaServer来监控系统中各个微服务是否正常运行，SpringCloud的一 些其他模块(比如 Zuu)_就可以通过EurekaServer来发现系统中的其他微服务，并执行相关的逻辑:\n Eureka 包含两个组件: Eureka Server和Eureka Client。\n Eureka Server提供服务注册服务,各个节点启动后，会在EurekaServer中进行注册， 这样Eureka Server 中的服务注册表中将会村粗所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。\n Eureka Client是-个Java客户端，用于简化EurekaServer的交互， 客户端同时也具备- -个内置的，使用轮 询负载算法的负载均衡器。在应用启动后，将会向EurekaServer发送心跳(默认周期为30秒)。如果 Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将 会从服务注册表中把这个 服务节点移除掉(默认周期为90秒)\n  三大角色\n Eureka Server:提供服务的注册于发现。 Service Provider:将自身服务注册到Eureka中,从而使消费方能够找到。 Service Consumer:服务消费方从Eureka中获取注册服务列表,从而找到消费服务。  新建一个项目之后的步骤\n 导入依赖 编写配日志文件 开启这个功能@Enablexxx 配置类  依赖\n\u0026lt;!-- 导包--\u0026gt; \u0026lt;!-- eureka依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 热部署--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;  配置\nserver: port: 7001 #eureka配置 eureka: instance: hostname: localhost #Eureka服务端的实例名称,localhost代表服务器的地址，最后要换的 client: register-with-eureka: false #表示是否向eureka注册中心注册自己 fetch-registry: false #fetch-registry如果为false, 则表示自己为注册中心 service-url: # 监控页面 defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/  访问\nhttp://localhost:7001/  注册，服务提供方添加配置\n#Eureka的配置，服务注册到哪里 eureka: client: service-url: defaultZone: http://localhost:7001/eureka/  添加依赖\n\u0026lt;!-- eureka依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-eureka\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  开启服务\n@EnableEurekaClient//开启服务 @SpringBootApplication public class SpringCloudProvider {  启动，先启动注册中心，在启动服务提供方\n完善7001的监控信息\n服务提供方添加依赖\n\u0026lt;!-- actutor完善监控信息(erekua的status指向网页的信息依赖)--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  添加配置\n#info配置 info: app.name: mumulx-springcloud company.name: com.mumulx  自我保护机制:好死不如赖活着\n一句话总结:某时刻某一个微服务不可以用了，eureka不会立刻清理，依旧会对该微服务的信息进行保存!\n默认情况下，如果EurekaServer在一 定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例(默认90秒)。但是当网络分区故障发生时，微服务与Eureka之间无法正常通行，以上行为可能变得非常危险了\u0026ndash;因为微服务本身其实是健康的，此时本不应该注销这个服务。Eureka通过 自我保护机制来解决这个问题\u0026ndash;当EurekaServer节点在短时间内丢失过多客户端时(可能发生了网络分区故障)， 那么这个节点就会进入自我保护模式。- -旦进入该模式，EurekaServer就会保护服务注册表中的信息，不再删除服务注册表中的数据(也就是不会注销任何微服务)。当网络故障恢复后，EurekaServer节 点会自动退出自我保护模式。\n在自我保护模式中, EurekaServer会保护服务注册表中的信息，不再注销任何服务实例。当它收到的心跳数重新恢复到阈值以上时,该EurekaServer节 点就会自动退出自我保护模式。它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。-句话:好死不如赖活着\n综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务(健康的微服务和不健康的微服务都会保留)，也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮和稳定\n在SpringCloud中，可以使用eureka. server. enable-self-preservation = false 禁用自我保护模式[不推荐关闭自我保护机制]\n获取微服务的一些信息 //获取一些配置信息，得到具体的微服务 @Autowired private DiscoveryClient client; @GetMapping(\u0026quot;/dept/discovery\u0026quot;) //注册进来的微服务，获取一些信息 public Object discovery() { //获得微服务列表的清单 List\u0026lt;String\u0026gt; services = client.getServices(); System.out.println(\u0026quot;discovery=\u0026gt;services\u0026quot; + services); //得到一个具体的微服务信息 List\u0026lt;ServiceInstance\u0026gt; instance = client.getInstances(\u0026quot;SPRINGCLOUD-PROVIDER-DEPT\u0026quot;); for (ServiceInstance serviceInstance : instance) { System.out.println( serviceInstance.getHost()+\u0026quot;\\t\u0026quot;+ serviceInstance.getPort()+\u0026quot;\\t\u0026quot;+ serviceInstance.getUri()+\u0026quot;\\t\u0026quot;+ serviceInstance.getServiceId() ); } return this.client; }  添加注解\n@EnableDiscoveryClient//服务发现 @SpringBootApplication  eureka集群 增加7002，7003.除了端口不一样其他都是相同的\n增加相互间的关系()\n7003\n# defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 单个 defaultZone: http://localhost:7001/eureka/,http://127.0.0.1:7002/eureka/ # 集群  服务提供方，分别向三个注册中心进行发送\n#Eureka的配置，服务注册到哪里 eureka: client: service-url: defaultZone: http://localhost:7001/eureka/,http://localhost:7002/eureka/,http://localhost:7003/eureka/ # 集群  对比zookeeper 回顾CAP原则\nRDBMS (Mysql. Oracle. sqlServer) ===\u0026gt;ACID .\nNoSQL (redis. mongdb) ===\u0026gt; CAP\nACID是什么?\n A (Atomicity) 原子性\n C (Consistency)- 致性\n I (Isolation) 隔离性\n D (Durability) 持久性\n  CAP是什么?\n C (Consistency) 强-致性\n A(Availability) 可用性\n P (Partition tolerance) 分区容错性\nCAP的三进二: CA、AP、CP\n  CAP理论的核心\n 一个分布式系统不可能同时很好的满足一 致性，可用性和分区容错性这三个需求 根据CAP原理,将NoSQL数据库分成了满足CA原则，满足CP原则和满足AP原则三大类: CA:单点集群，满足一致性,可用性的系统，通常可扩展性较差 CP:满足一致性，分区容错性的系统，通常性能不是特别高 AP:满足可用性，分区容错性的系统,通常可能对一致性要求低一些  回作为服务注册中心，Eureka比Zookeeper好在哪里?\n著名的CAP理论指出，-个分布式系统不可能同时满足C (- 致性)、A (可用性)、P (容错性)。 由于分区容错性P在分布式系统中是必须要保证的，因此我们只能在A和C之间进行权衡。\n Zookeeper保证的是CP; Eureka保证的是AP; .  Zookeeper保证的是CP\n当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。 但是zk会出现这样一种情况， 当master节点因为网络故障与其他节点失去联系时,剩余节点会重新进行leader选举。问题在于，选举leader的时间太长,30~120s，且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因为网络问题使得zk集群失去master节点是较大概率会发生的事件，虽然服务最终能够恢复,但是漫长的选举时间导致的注册长期不可用是不能容忍的。\nEureka保证的是AP\nEureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作,剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时,如果发现连接失败，则会自动切换至其他节点，只要有一台Eureka还在，就能保住注册服务的可用性，只不过查到的\n信息可能不是最新的，除此之外，Eureka还有一 种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障,此时会出现以下几种情况: 1. Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 2. Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上(即保证当前节点依然可用) 3. 当网络稳定时，当前实例新的注册信息会被同步到其他节点中\n因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪\nribbon ribbon是什么\n Spring Cloud Ribbon是基于Netlix Ribbon实现的一套客户端负载均衡的工具。\n 简单的说，Ribbon是Netflix发布的开源项目, 主要功能是提供客户端的软件负载均衡算法，将NetFlix的中间层服务连接在一起。Ribbon的客户端组件提供一系列完整的配置项如: 连接超时、重试等等。简单的说，就是在配置文件中列出LoadBalancer (简称LB:负载均衡)后面所有的机器，Ribbon会 自动的帮助你基于某种规则(如简单轮询，随机连接等等)去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法!\nribbon能干嘛?\n LB,即负载均衡(Load Balance) ，在微服务或分布式集群中经常用的-种应用。\n 负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高可用)。\n 常见的负载均衡软件有Nginx, Lvs等等\n dubbo. SpringCloud中均给我们提供了负载均衡, SpringCloud的负载均衡算法可以自定义\n 负载均衡简单分类:\n集中式LB\n 即在服务的消费方和提供方之间使用独立的LB设施，如Nginx, 由该设施负责把访问请求通过某种策 略转发至服务的提供方!  进程式LB\n 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选出一个合适的服务器。 ”Ribbon就属于进程内LB, 它只是一 个类库，集成于消费方进程,消费方通过它来获取到服务提供方的地址    使用 添加依赖（在消费方）\n\u0026lt;!-- Ribbon的依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Eureka依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  配置\n#Eureka配置 eureka: client: register-with-eureka: false #不向eureka注册自己 service-url: #做集群需要关联集群的eureka服务器的地址,其实端口号都应该是7001， #关联的只是服务器地址，这里因为只有一台电脑，就用了端口号代替 defaultZone: http://127.0.0.1:7001/eureka/,http://127.0.0.1:7002/eureka/,http://127.0.0.1:7003/eureka/ #常见错误 #参考文档博客园 https://www.cnblogs.com/cangqinglang/p/11704475.html  //负载均衡实现RestTemplate @Bean @LoadBalanced //Reibbon public RestTemplate getRestTemplate(){ return new RestTemplate(); }  controller使用负载均衡\n//Ribbon 我们这里的地址，应该是一个变量，通过服务名来访问 // private static final String REST_URL_PREFIX = \u0026quot;http://localhost:8001\u0026quot;; private static final String REST_URL_PREFIX = \u0026quot;http://SPRINGCLOUD-PROVIDER-DEPT\u0026quot;;  启动\n@SpringBootApplication @EnableEurekaClient//启动 public class SpringCloudConsumer {  IRule接口\n创建多个服务提供者 创建db02、db03数据库\nCREATE DATABASE /*!32312 IF NOT EXISTS*/`db02` /*!40100 DEFAULT CHARACTER SET utf8 */; USE `db02`; DROP TABLE IF EXISTS `dept`; CREATE TABLE `dept` ( `dname` varchar(60) DEFAULT NULL, `deptno` bigint(20) NOT NULL AUTO_INCREMENT, `db_source` varchar(60) DEFAULT NULL, PRIMARY KEY (`deptno`) ) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8 COMMENT='部门表'; insert into `dept`(`dname`,`deptno`,`db_source`) values ('开发部',1,'db02'),('人事部',2,'db02'),('财务部',3,'db02'),('市场部',4,'db02'),('运维部',5,'db02'),('klz',10,'db02'); CREATE DATABASE /*!32312 IF NOT EXISTS*/`db03` /*!40100 DEFAULT CHARACTER SET utf8 */; USE `db03`; DROP TABLE IF EXISTS `dept`; CREATE TABLE `dept` ( `dname` varchar(60) DEFAULT NULL, `deptno` bigint(20) NOT NULL AUTO_INCREMENT, `db_source` varchar(60) DEFAULT NULL, PRIMARY KEY (`deptno`) ) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8 COMMENT='部门表'; insert into `dept`(`dname`,`deptno`,`db_source`) values ('开发部',1,'db03'),('人事部',2,'db03'),('财务部',3,'db03'),('市场部',4,'db03'),('运维部',5,'db03'),('klz',10,'db03');  创建服务提供者8002、8003\n修改数据库和服务提供者id，端口号\nurl: jdbc:mysql://localhost:3306/db02?useUnicode=true\u0026amp;serverTimezone=GMT%2B8\u0026amp;characterEncoding=UTF-8\u0026amp;useSSL=false instance-id: springcloud-provider-dept8002 port: 8002  但是服务名一定是一致的\napplication: name: springcloud-provider-dept  测试\n可以发现\nSPRINGCLOUD-PROVIDER-DEPT\tn/a (3)\t(3)\tUP (3) - springcloud-provider-dept8001 , springcloud-provider-dept8003 , springcloud-provider-dept8002  启动客户端\u0026ndash;使用者80\n访问，可以发现数据是轮询的\nhttp://localhost/consumer/dept/list  自定义分配算法 注意IRule接口，具有以下实现类\nAbstractLoadBalancerRule\t一般 AvailabilityFilleringRule\t会先过滤掉，崩溃(跳闸)的服务，对剩下的进行轮询 BestAvailableRule ClientConfigEnabledRoundRobinRule PredicateBasedRule RandomRule\t随机 ResponseTimeWeightedRule RetryRule\t重试，会先按照轮询获取服务，如果服务获取失败，则会在指定的时间内进行重试 RoundRobinRule\t轮询 WeightedResponseTimeRule\t权重 ZoneAvoidanceRule  添加注解\n//规则，轮询 @Bean public IRule myRule(){ return new RandomRule(); }  自定义规则只需要实现IRule接口\nFooConf iguration必须是@Configuration.但请注意，它不在主应用程序上下文的@ComponentScan中，否则将由所有@RibbonClients共享,如果您使用@ComponentScan (或@SpringBootApplication) .则需要采取措施避免包含({例如将其放在一 个单独的， 不重叠的包中，或者指定要在@ComponentScan) .\n所以我们的自定义的类，不能放在启动类的目录下\nFeign负载均衡 简介\nfeign是声明式的web service客户端，它让微服务之间的调用变得更简单了，类似controller调用service。 SpringCloud集成了Ribbon和Eureka,可在使用Feign时提供负载均衡的http客户端。只需要创建一一个接口，然后添加注解即可!feign，主要是社区，大家都习惯面向接口编程。这个是很多开发人员的规范。调用微服务访问两种方法\n 微服务名字[ribbon]\n 接口和注解[feign ]\n  Feign能干什么?\nFeign旨在使编写Java Http客户端变得更容易\n前面在使用Ribbon + RestTemplate时, 利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止- -处， 往往一个接口会被多处调用,所以通常都会针对每个微服务自行封装-些客户端类来包装这些依赖服务的调用。 所以，Feign在此基础 上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义，在Feign的实现下，我们只需要创建一一个接口并使用注解的方式来配置它(类似于以前Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可。)即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon时，自动封装服务调用客户端的开发量。\nFeign集成了Ribbon\n利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息，并且通过轮询实现了客户端的负载均衡，而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法,优雅而且简单的实现了服务调用。\n使用 api添加service\n//@Component @FeignClient(value = \u0026quot;SPRINGCLOUD-PROVIDER-DEPT\u0026quot;) public interface DeptServiceFeign { @GetMapping(\u0026quot;/dept/get/{id}\u0026quot;) public Dept queryId(@PathVariable(\u0026quot;id\u0026quot;) Long id); @GetMapping(\u0026quot;/dept/list\u0026quot;) public List\u0026lt;Dept\u0026gt; queryAll(); @PostMapping(\u0026quot;/dept/list\u0026quot;) public boolean addDept(Dept dept); }  api 添加依赖\n\u0026lt;!--Feign依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-feign\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  创建module：springcloud-comsumer-feign、\n添加依赖\n\u0026lt;!--Feign依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-feign\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  controller调用\n@RestController public class DeptController { @Autowired private DeptServiceFeign service =null; @RequestMapping(\u0026quot;/consumer/dept/get/{id}\u0026quot;) public Dept get(@PathVariable(\u0026quot;id\u0026quot;) Long id) { return this.service.queryId(id); } @RequestMapping(\u0026quot;/consumer/dept/add\u0026quot;) public boolean add(Dept dept) { return this.service.addDept(dept); } @RequestMapping(\u0026quot;/consumer/dept/list\u0026quot;) public List\u0026lt;Dept\u0026gt; list() { return this.service.queryAll(); } }  启用\n@SpringBootApplication @EnableEurekaClient//启动 @EnableFeignClients(basePackages = \u0026quot;com.mumulx\u0026quot;) public class SpringCloudConsumerFeign { public static void main(String[] args) { SpringApplication.run(SpringCloudConsumerFeign.class, args); } }  测试\n启动7001、8001，feign\n访问\nhttp://localhost/consumer/dept/list  服务熔断 服务端\n分布式系统面临的问题\n复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免的失败!\n服务雪崩\n多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务,这就是所谓的\u0026rdquo;扇出”、如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应\u0026rdquo;。对于高流量的应用来说，单- -的后端依赖可能会导致所有服务器上的所有资源都在几秒中内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障，这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。\n我们需要:弃车保帅\n什么是Hystrix\nHystrix是一个用于处理分 布式系统的延迟和容错的开源库,在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等, Hystrix能够保证在一 个依赖出问题的情况下， 不会导致整体服务失败,避免级联故障,以提高分布式系统的弹性。\n\u0026ldquo;断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控(类似熔断保险丝)，向调用方返回一个服务预期的，可处理的备选响应(FallBack) ，而不是长时间的等待或者抛出调用方法无法处理的异常，这样就可以保证了服务调用方的线程不会被长时间，不必要的占用，从而避免了故障在分布式系统中的蔓延,乃至雪崩\n能干嘛\n 服务降级 服务熔断 服务限流 接近实时的监控  官网资料\n服务熔断\n是什么\n熔断机制是对应雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况， 当失败的调用到- -定阈值,缺省是5秒内20次调用失败就会启动熔断机制。熔断机制的注解是@HystrixCommand.\n使用 添加依赖  \u0026lt;!-- hystrix依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  @RestController public class DeptController { @Resource(name = \u0026quot;deptService\u0026quot;) private DeptServiceFeign deptService; @HystrixCommand(fallbackMethod = \u0026quot;getHystrix\u0026quot;)//指定备选方法 @GetMapping(\u0026quot;/dept/get/{id}\u0026quot;) public Dept get(@PathVariable(\u0026quot;id\u0026quot;) Long id){ Dept dept = deptService.queryId(id); if (dept == null) { throw new RuntimeException(\u0026quot;id=\u0026gt;\u0026quot; + id + \u0026quot;,不存在该用户，或信息无法找到\u0026quot;); } return dept; } //备选方法 public Dept getHystrix(@PathVariable(\u0026quot;id\u0026quot;) Long id){ return new Dept().setDeptno(id).setDname(\u0026quot;id=\u0026gt;\u0026quot;+id+\u0026quot;,没有对应的信息，null~~\u0026quot;).setDb_source(\u0026quot;不存在该数据库\u0026quot;); } }  @EnableEurekaClient//在服务启动后自动注册到eureka @SpringBootApplication @EnableDiscoveryClient//服务发现 @EnableCircuitBreaker//增加对熔断的支持 public class SpringCloudProvider8001 {  测试\n启动7001，7002，8001-hystrix\n服务降级 客户端\napi提供降级\n//降级 @Component public class DeptServiceFeignFallbackFactory implements FallbackFactory { @Override public DeptServiceFeign create(Throwable throwable) { // 谁失败了就返回谁 return new DeptServiceFeign() { @Override public Dept queryId(Long id) { return new Dept() .setDeptno(id) .setDname(\u0026quot;id=\u0026gt;\u0026quot;+id+\u0026quot;没有对应的信息，客户端提供了降级的信息，这个服务现在已经被关闭了\u0026quot;) .setDb_source(\u0026quot;n没有数据\u0026quot;); } @Override public List\u0026lt;Dept\u0026gt; queryAll() { return null; } @Override public boolean addDept(Dept dept) { return false; } }; } }  指定关系\n@FeignClient(value = \u0026quot;SPRINGCLOUD-PROVIDER-DEPT\u0026quot;,fallbackFactory = DeptServiceFeignFallbackFactory.class) public interface DeptServiceFeign {  feign开启\n# 开启降级 feign: hystrix: enabled: true  测试\n启动7001，7002，8001，feign\n访问\nhttp://localhost/consumer/dept/get/1  关闭8001\n继续访问\n{ deptno: 1, dname: \u0026quot;id=\u0026gt;1没有对应的信息，客户端提供了降级的信息，这个服务现在已经被关闭了\u0026quot;, db_source: \u0026quot;n没有数据\u0026quot; }  服务熔断:服务端某 个服务超时或者异常，引起熔脚，保险丝~\n服务降级:客户端从整体网站请求负载考虑，当某个服务熔断或者关闭之后，服务将不再被调用此时在客户端，我们可以准备一个FallbackFactory,返回一个默认的值( 缺省值)，整体的服务水平下降了但是，好歹能用\n监控 客户端\n添加依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- 我们需要拿到实体类,从api项目的pojo拿--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mumulx\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- junit--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mysql依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- druid数据源依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 日志核心依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- springboot启动依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spirngboot测试依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-test\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- springboot的web依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- jetty依赖相当于tomcat(springboot自带tomcat)--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jetty\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 热部署依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- eureka依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-eureka\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- actutor完善监控信息(erekua的status指向网页的信息依赖)--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Hystrix依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Hystrix监控依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-hystrix-dashboard\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  springcloud-consumer-hystrix-dashboard\n配置\nserver: port: 9001  启动类\n@SpringBootApplication(exclude= {DataSourceAutoConfiguration.class}) @EnableHystrixDashboard//开启监控 public class SpringCloudConsumerHystrixDashboard { public static void main(String[] args) { SpringApplication.run(SpringCloudConsumerHystrixDashboard.class,args); } }  服务提供者端添加依赖\n（以将添加过了）\n\u0026lt;!-- actutor完善监控信息(erekua的status指向网页的信息依赖)--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  测试\n启动9001\n访问\nhttp://localhost:9001/hystrix  8001-hystrix\n添加依赖\n\u0026lt;!-- hystrix依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;\t 启动类添加配置\n//增加一个servlet,将8001服务注册到dashboard流监控 @Bean public ServletRegistrationBean getServlet() { HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(\u0026quot;/actuator/hystrix.stream\u0026quot;); registrationBean.setName(\u0026quot;HystrixMetricsStreamServlet\u0026quot;); return registrationBean; }  启动7001，8001-hystrix、9001\n先访问\nhttp://localhost:8001/dept/get/5  访问的方法必须是支持熔断的\n即含有注解 @HystrixCommand(fallbackMethod = \u0026ldquo;getHystrix\u0026rdquo;)的\n@HystrixCommand(fallbackMethod = \u0026quot;getHystrix\u0026quot;)//指定备选方法 @GetMapping(\u0026quot;/dept/get/{id}\u0026quot;) public Dept get(@PathVariable(\u0026quot;id\u0026quot;) Long id){ Dept dept = deptService.queryId(id); if (dept == null) { throw new RuntimeException(\u0026quot;id=\u0026gt;\u0026quot; + id + \u0026quot;,不存在该用户，或信息无法找到\u0026quot;); } return dept; } //备选方法 public Dept getHystrix(@PathVariable(\u0026quot;id\u0026quot;) Long id){ return new Dept().setDeptno(id).setDname(\u0026quot;id=\u0026gt;\u0026quot;+id+\u0026quot;,没有对应的信息，null~~\u0026quot;).setDb_source(\u0026quot;不存在该数据库\u0026quot;); }  在监控\nhttp://localhost:8001/actuator/hystrix.stream  进入9001\n添加监控\nhttp://localhost:8001/actuator/hystrix.stream  Delay: 2000ms\nTitle: xxx\n进入后进行监控\nZuul路由网关 概述 什么是Zuul?\nZuul包含了对请求的路由和过滤两个最主要的功能:\n其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础， 而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础。Zuul和Eureka进行整合, 将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他微服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。\n注意: Zuul服务最终还是会注册进Eureka\n提供:代理+路由+过滤三大功能!\nZuul能干嘛?\n 路由 过滤  官网文档: \n代码 新建module：springcloud-zuul-9527\n添加依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- 我们需要拿到实体类,从api项目的pojo拿--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mumulx\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- springboot的web依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- jetty依赖相当于tomcat(springboot自带tomcat)--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jetty\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 热部署依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- actutor完善监控信息(erekua的status指向网页的信息依赖)--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Ribbon的依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Hystrix依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.reactivestreams\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;reactive-streams\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Hystrix监控依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-hystrix-dashboard\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Eureka依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-eureka\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Zuul依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-zuul\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  配置\nserver: port: 9527 spring: application: name: springCloud-zuul #Eureka的配置，服务注册到哪里 eureka: client: service-url: defaultZone: http://localhost:7001/eureka/,http://localhost:7002/eureka/,http://localhost:7003/eureka/ instance: instance-id: springcloud-zuul-9527 prefer-ip-address: true #info配置 info: app.name: mumulx-springcloud company.name: com.mumulx  开启\n@SpringBootApplication @EnableZuulProxy public class SpringCloudZuul9527 { public static void main(String[] args)  本地添加网关，C:\\Windows\\System32\\drivers\\etc\\hosts文件\n127.0.0.1 www.mywin10.com  测试：\n启动7001，8001-hystrix，9527\n访问\n方式一\nhttp://localhost:8001/dept/get/5  方式二\nhttp://www.mywin10.com:9527/springcloud-provider-dept/dept/get/2  这样就把真实的地址隐藏起来了\n但是这样暴漏了微服务的名称springcloud-provider-dept\n配置zuul\n增加9527配置\n# zuul配置 zuul: routes: mydept.serviceId: springcloud-provider-dept mydept.path: /mydept/** #将服务名改一个名字代替服务名 ignored-services: springcloud-provider-dept #忽略服务名，不能用服务名访问了，否则报500 prefix: #设置公共前缀  访问\nhttp://www.mywin10.com:9527/mydept/dept/get/2  这样就隐藏了ip和微服务的名称\nSpringCloud config分布式配置 概述 分布式系统面临的-配置文件的问题\n微服务意味着要将单体应用中的业务拆分成一个个子服务,每个服务的粒度相对较小，因此系统中会出现大量的服务，由于每个服务都需要必要的配置信息才能运行，所以一套集中式的， 动态的配置管理设施是必不可少的。SpringCloud提供了ConfigServer来解决这个问题,我们每一个微服务自 己带着- -个application.yml, 那上百的的配置文件要修改起来，岂不是要发疯!\n什么是SpringCloud config分布式配置中心\n可以将配置文件放在本地git仓库，也可以放在远程git仓库\nSpring Cloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环节提供了一个中心化的外部配置。\nSpring Cloud Config 分为服务端和客户端两部分;\n服务端也称为分布式配置中心，它是一 个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息,加密,解密信息等访问接口。\n客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。配置服务器默认采用git来存储配置信息,这样就有助于对环境配置进行版本管理。并且可以通过git客户端工具来方便的管理和访问配置内容.\nSpringCloud config分布式配置中心能干嘛\n 集中管理配置文件\n 不同环境，不同配置，动态化的配置更新，分环境部署,比如/dev /test/ /prod /beta /release\n 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件,服务会向配置中心统-拉取配置自己的信息。\n 当配置发生变动时，服务不需要重启，即可感知到配置的变化，并应用新的配置\n 将配置信息以REST接口的形式暴露\n  SpringCloud config分布式配置中心与github整合\n由于Spring Cloud Config默认使用Git来存储配置文件(也有其他方式，比如支持SVN和本地文件)，但是最推荐的还是Git，而且使用的是http / https访问的形式;\n使用 服务端 git新建仓库springCloud-config\n新建spring配置文件application.yml\nspring: profiles: active: dev --- #spring的配置 spring: profiles: dev application: name: springcloud-config-dev --- #spring的配置 spring: profiles: test application: name: springcloud-config-test  创建新module：springcloud-config-service-3344\n添加依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- web--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--config--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-config-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- actuator完善页面监控依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.11.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  配置\nserver: port: 3344 spring: application: name: springcloud-config-server-3344 #连接远端仓库 cloud: config: server: git: uri: https://github.com/mumulx/springCloud-config.git #是http，不是ssh  启用\n@SpringBootApplication @EnableConfigServer public class SpringCloudConfigServer3344 {  测试\n启动3344\n测试\n访问的三种方式\nhttp://localhost:3344/application-dev.yml http://localhost:3344/application/test/master http://localhost:3344/master/application-dev.yml  客户端 客户端去 请求服务端获取配置\n仓库新建config-server.yml\nspring: profiles: active: dev --- server: port: 8201 #spring的配置 spring: profiles: dev application: name: springcloud-provider-dept #Eureka的配置，服务注册在哪里 eureka: client: service-url: defaultZone: http://localhost:7002/eureka/,http://127.0.0.1:7003/eureka/ --- server: port: 8202 #spring的配置 spring: profiles: test application: name: springcloud-provider-dept #Eureka的配置，服务注册在哪里 eureka: client: service-url: defaultZone: http://localhost:7002/eureka/,http://127.0.0.1:7003/eureka/  git push\n新建module：springcloud-config-client-3355\n添加依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- web--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--config--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- actuator完善页面监控依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.11.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  bootstrap.yml与application.yml 配置\nbootstrap.yml\n#系统级别的配置(高于用户级别的配置) #只能识别application.yml和boostrap.yml,别的名字不能识别 spring: cloud: config: #springcloud-config采用的是sv(服务器客户端)的架构模式 #服务器(3344)连gitee，客户端(3355)连服务器 uri: http://localhost:3344 #服务器地址 name: config-client #需要从gitee上读取的资源名称 profile: dev #开发模式 test是测试模式 label: master #geitee的分支  application.yml\n#用户级别的配置 spring: application: name: springcloud-config-client-3355  编写controller获取配置信息ConfigClientController\n@RestController public class ConfigClientController { @Value(\u0026quot;${spring.application.name}\u0026quot;) private String applicationName; @Value(\u0026quot;${eureka.client.service-url.defaultZone}\u0026quot;) private String eurekaServer; @Value(\u0026quot;${server.port}\u0026quot;) private String port; @RequestMapping(\u0026quot;/config\u0026quot;) public String getConfig() { return \u0026quot;applicationName:\u0026quot;+applicationName+ \u0026quot;eurekaServer:\u0026quot;+eurekaServer+ \u0026quot;port:\u0026quot;+port; } }  测试\n启动3344，3355\n测试3344能获取配置\nhttp://localhost:3344/master/config-client-dev.yml  访问\nhttp://localhost:8201/config  获取配置信息，此时我们发现我们并没有配置8201的端口，但是客户端却是通过8201进行访问的\n使用springCloud-config将之前的模块优化\n新建配置文件config-eureka.yml、config-dept.yml\nconfig-eureka.yml\nspring: profiles: active: dev --- server: port: 7001 #spring的配置 spring: profiles: dev application: name: springcloud-config-eureka #eureka配置 eureka: instance: hostname: localhost #Eureka服务端的实例名称,localhost代表服务器的地址，最后要换的 client: register-with-eureka: false #表示是否向eureka注册中心注册自己 fetch-registry: false #fetch-registry如果为false, 则表示自己为注册中心 service-url: # 监控页面 #单机不做集群defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ #localhost代表服务器的地址，最后要换的 ,集群互相关联7001关联7002和7003 #其实用的端口号都应该是7001，关联的是不同服务器的地址，因为我只有一个电脑，就用了端口号代替 defaultZone: http://localhost:7002/eureka/,http://127.0.0.1:7003/eureka/ --- server: port: 7001 #spring的配置 spring: profiles: test application: name: springcloud-config-eureka #eureka配置 eureka: instance: hostname: localhost #Eureka服务端的实例名称,localhost代表服务器的地址，最后要换的 client: register-with-eureka: false #表示是否向eureka注册中心注册自己 fetch-registry: false #fetch-registry如果为false, 则表示自己为注册中心 service-url: # 监控页面 #单机不做集群defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ #localhost代表服务器的地址，最后要换的 ,集群互相关联7001关联7002和7003 #其实用的端口号都应该是7001，关联的是不同服务器的地址，因为我只有一个电脑，就用了端口号代替 defaultZone: http://localhost:7002/eureka/,http://127.0.0.1:7003/eureka/  config-dept.yml\nspring: profiles: active: dev --- Server: port: 8001 mybatis: # 指定全局配置文件位置 config-location: classpath:mybatis/mybatis-config.xml # 指定sql映射文件位置 mapper-locations: classpath:mybatis/mapper/*.xml # 指定实体类 type-aliases-package: com.mumulx.entity spring: profiles: dev application: name: springcloud-config-eureka datasource: # 数据源基本配置 username: root password: 135451 driver-class-name: org.gjt.mm.mysql.Driver url: jdbc:mysql://localhost:3306/db01?useUnicode=true\u0026amp;serverTimezone=GMT%2B8\u0026amp;characterEncoding=UTF-8\u0026amp;useSSL=false type: com.alibaba.druid.pool.DruidDataSource #Eureka的配置，服务注册到哪里 eureka: client: service-url: defaultZone: http://localhost:7001/eureka/,http://localhost:7002/eureka/,http://localhost:7003/eureka/ instance: instance-id: springcloud-provider-dept8001 prefer-ip-address: true #true，显示服务的ip地址 #info配置 info: app.name: mumulx-springcloud company.name: com.mumulx --- Server: port: 8001 mybatis: # 指定全局配置文件位置 config-location: classpath:mybatis/mybatis-config.xml # 指定sql映射文件位置 mapper-locations: classpath:mybatis/mapper/*.xml # 指定实体类 type-aliases-package: com.mumulx.entity spring: profiles: test application: name: springcloud-config-eureka datasource: # 数据源基本配置 username: root password: 135451 driver-class-name: org.gjt.mm.mysql.Driver url: jdbc:mysql://localhost:3306/db01?useUnicode=true\u0026amp;serverTimezone=GMT%2B8\u0026amp;characterEncoding=UTF-8\u0026amp;useSSL=false type: com.alibaba.druid.pool.DruidDataSource #Eureka的配置，服务注册到哪里 eureka: client: service-url: defaultZone: http://localhost:7001/eureka/,http://localhost:7002/eureka/,http://localhost:7003/eureka/ instance: instance-id: springcloud-provider-dept8001 prefer-ip-address: true #true，显示服务的ip地址 #info配置 info: app.name: mumulx-springcloud company.name: com.mumulx  新建module：springcloud-config-eureka-7001\n将7001全部复制到config-7001\n导包\n\u0026lt;!--config--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  新建bootstrap.yml\n#系统级别的配置(高于用户级别的配置) #只能识别application.yml和boostrap.yml,别的名字不能识别 spring: cloud: config: #springcloud-config采用的是sv(服务器客户端)的架构模式 #服务器(3344)连gitee，客户端(3355)连服务器 uri: http://localhost:3344 #服务器地址 name: config-eureka #需要从gitee上读取的资源名称 profile: dev #开发模式 test是测试模式 label: master #geitee的分支  application.yml\nspring: application: name: springcloud-config-eureka-7001  测试\n启动3344\n测试\nhttp://localhost:3344/master/config-eureka-dev.yml  可以获取eureka的配置信息\n启动config-7001\n测试\nhttp://localhost:7001/  新建module：springcloud-config-provider-8001\n将8001复制到config-8001\n导包\n\u0026lt;!--config--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  配置\nbootstrap.yml\n#系统级别的配置(高于用户级别的配置) #只能识别application.yml和boostrap.yml,别的名字不能识别 spring: cloud: config: #springcloud-config采用的是sv(服务器客户端)的架构模式 #服务器(3344)连gitee，客户端(3355)连服务器 uri: http://localhost:3344 #服务器地址 name: config-dept #需要从gitee上读取的资源名称 profile: dev #开发模式 test是测试模式 label: master #geitee的分支  application.yml\nspring: application: name: springcloud-config-provider-dept-8001  测试\n启动3344\nhttp://localhost:3344/master/config-dept-dev.yml  启动config-7001，config-8001\n查看是否注册进来\nhttp://localhost:7001/  是否可以使用\n","id":14,"section":"posts","summary":"源码 SpringCloud 微服务架构4个核心问题? 服务很多，客户端该怎么访问? 这么多服务?服务之间如何通信? 这么多服务? 如何治理? 服务挂了怎么办? 解决方案:Sp","tags":["Spring家族"],"title":"SpringCloud自学笔记","uri":"https://mumulx.github.io/2020/03/springbootcloud/","year":"2020"},{"content":" Redis Redis 是完全开源免费的，遵守BSD协议，是一个高性能的（noSQL）key-value数据库\nRedis 与其他 key - value 缓存产品有以下三个特点：\n Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。  BSD是\u0026rdquo;Berkeley Software Distribution\u0026rdquo;的缩写,意思是”伯克利软件发行版\u0026rdquo;。BSD开源协议是一个给于使用者很大自由的协议。 可以自由的使用,修改源代码,也可以将修改后的代码作为开源或者专有软件再发布。BSD代码鼓励代码共享.但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码,也允许使用或在BSD代码上开发商业软件发布和销售,因此是对商业集成很友好的协议。\nNoSQL,泛指非关系型的数据库。随着互联网web2. 0网站的兴起，传统的关系数据库在应付web2. 0网站,特别是超大规模和高并发的SNS类型的web2. 0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展. NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。\nNOSQL :\n非关系数据库:数据与数据之间没有关联关系。\nSQL :\n关系型数据库:表与表之间建立关联关系\nNoSQL的类别\n键值(key-value)存储数据库、列存储数据库、文档型数据库、图形（Graph）数据库\n安装 Redia官网\n下载\n安装gcc\ngcc的安装很简单,首先要确保root登录,其次就是Linux要能连外网\nyum -y install gcc automake autoconf 1ibtoo1 make  wget http://download.redis.io/releases/redis -5.0.7. tar.gz tar zxvf redis-5.0.7.tar.gz -C /app\t解压并移动文件到 cd /app cd redis-5.0.7 make\t编译  安装到指定位置\nmake PREFIX=/usr/loca1/redis instal1  启动服务端\ncd /usr/local/redis ./bin/redis-server  连接客户端\n./bin/redis-cli  赋值取值\nset name 1234 get name  启动Redis客户端命令语法:\nredis-cli -h IP地址 -p端口\t//默认IP本机 端口6379  ps -ef | grep -i redis\t查看进程  Redis配置详解 Redis默认定义了很多默认配置。但在实际开发中,一般我们都会通过手动配置完成。\n回到安装目录下找到解压文件中的reids.conf\nRedis的配置文件位于Redis安装目录下,文件名为redis.conf\n配置Redis 命令:解压目录下的redis.conf配置文件复制到安装文件的目录下\ncp /opt/redis-5.0.0/redis.conf /usr/1oca1/redis/  配置文件redis.conf Redis默认不是以守护进程的方式运行 ，可以通过该配置项修改，使用yes启用守护进程\ndaemonize no  当Redis以守护进程方式运行时 ，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定\npidfile /var/run/redis.pid  指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为 6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字\nport 6379  绑定的主机地址\nbind 127.0.0.1  当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能\ntimeout 300  指定日志记录级别, Redis总共支持四个级别: debug. verbose、 notice. warning，默认为verbose\nloglevel verbose  日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则 日志将会发送给/dev/nu11\nlogfile stdout  设置数据库的数量默认数据库为0，可以使用SELECT \u0026lt;dbid\u0026gt;命令在连接 上指定数据库id\ndatabases 16  指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\nsave \u0026lt;s econds\u0026gt; \u0026lt;changes\u0026gt;  Redis默认配置文件中提供了三个条件:\nsave 900 1 save 300 10 save 60 10000  分别表示900秒( 15分钟)内有1个更改，300秒( 5分钟)内有10个更改以及60秒内有10000个更改。\n.指定存储至本地数据库时是否压缩数据，默认为yes , Redis采用LZF (压缩算法)压缩，如果为了节省CPU时间， 可以关闭该选项，但会导致数据库文件变的巨大\nrdbcompression yes  指定本地数据库文件名,默认值为dump.rdb\ndbfilename dump.rdb  12.指定本地数据库存放目录\ndir ./  设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\nslaveof \u0026lt;masterip\u0026gt; \u0026lt;master port\u0026gt;  当master服务设置了 密码保护时，s1av服务连接master的密码\nmaster auth \u0026lt;master-passwor d\u0026gt;  设置Redis连接密码 ，如果配置了连接密码，客户端在连接Redis时需要通过AUTH \u0026lt;password\u0026gt; 命令提供密码， 默认关闭\nrequirepass foobared  设置同一时间最大客户端连接数,默认无限制，Redis可以同时打开的客户端连接数为Redi s进程可以打开的最大文 件描述符数,如果设置maxclients 0,表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端 返回max number of clients reached错误信息\nmaxclients 128  指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或 即将到期的Key，当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的vm机制，会把Key存放内存，value会存放在swap区\nmaxmemory \u0026lt;bytes\u0026gt;  指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断 电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间 内只存在于内存中。默认为no\nappendonly no  指定更新日志文件名，默认为appendonly. aof\nappendfilename appendonly.aof  指定更新日志条件，共有3个可选值:\nno :表示等操作系统进行数据缓存同步到磁盘(快) always :表示每次更新操作后手动调用fsync ()将数据写到磁盘(慢，安全) everysec :表示每秒同步一次(折衷，默认值) appendfsync everysec  指定是否启用虚拟内存机制，默认值为no,简单的介绍一- 下，VM机制将数据分页存放，由Redis将访问量较少的页即 冷数据swap到磁盘上,访问多的页面由磁盘自动换出到内存中(在后面的文章我会仔细分析Redis的VM机制)\nvm-enabled no  虚拟内存文件路径，默认值为/tmp/redis . swap，不可多个Redis实例共享\nvm-swap-file /tmp/redis . swap  将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小，所有索引数据都是内存存储的 (Redis的索引数揭就是keys)，也就是说,当vm-max- memory设置为0的时候，其实是所有value都存在于磁盘。默认值 为0\nvm-max -memory 0  Redis swap文件分成了 很多的page ,一个对象可以保存在多个page.上面,但一个page上不能被多个对象共享, vm-page-size是要根据存储的数据大小来设定的，作者建议如果存储很多小对象, page大小最好设置为32或者 64bytes ;如果存储很大大对象，则可以使用更大的page，如果不确定，就使用默认值\nvm-page-size 32  设置swap文件中的page数量， 由于页表( 一种表示页面空闲或使用的bitmap)是在放在内存中的，, 在磁盘上每8 个pages将消耗1byt e的内存。\nvm-pages 134217728  设置访问swap文件的线程数，最好不要超过机鼹的核数，如果设置为0,那么所有对swap文件的操作都是串行的，可能 会造成比较长时间的延迟。默认值为4\nvm-max-threads 4  设置在向客户端应答时，是否把较小的包合并为-一个包发送，默认为开启\nglueoutputbuf yes  指定在超过一定的数量或者最大的元素超过某-临界值时,采用一-种特殊的哈希算法\nhash-max-zipmap-entries 64 hash-max-zi pmap-value 512  指定是否激活重置哈希，默认为开启(后面在介绍Redis的哈希算法时具体介绍)\nactiver ehashing yes  指定包含其它的配置文件，可以在同一-主机上多个Redis实例之间使用同一-份配置文件,而同时各个实例又拥有自己 的特定配置文件\ninclude /path/to/1oca1.conf  Redis中的内存维护策略 redis作为优秀的中间缓存件,时常会存储大量的数据,即使采取了集群部署来动态扩容,也应该即时的整理内 存，维持系统性能。\n在redis中有两种解决方案\n一为数据设置超时时间 设置过期时间\nexpire key time (以秒为单位)--这是最常用的方式 setex(String key, int seconds, String value)--字符串独有的方式   除了字符串自己独有设置过期时间的方法外,其他方法都需要依靠expire方法来设置时间\n 如果没有设置时间.那缓存就是永不过期\n 如果设置了过期时间,之后又想让缓存永不过期,使用persist key\n  二采用LRU算法动态将不用的数据删除 内存管理的一种页面置换算法,对于在内存中但又不用的数据块(内存块)叫做LRU。\n操作系统会根据哪些数据属于LRU而将其移出内存而腾出空间来加载另外的数据。\n volatile-lru :设定超时时间的数据中删除最不常使用的数据. allkeys-lru :查询所有的key中最近最不常使用的数据进行删除,这是应用最广泛的策略. volatile-random :在已经设定了超时的数据中随机删除. allkeys-random :查询所有的key,之后随机删除. volatile-ttl :查询全部设定超时时间的数据,之后排序,将马上将要过期的数据进行删除操作. noeviction :如果设置为该属性.则不会进行删除操作,如果内存溢出则报错返回. volatile-lfu :从所有配置了过期时间的键中驱逐使用频率最少的键 allkeys-lfu :从所有键中驱逐使用频率最少的键  自定义配置Redis 进入对应的安装目录/usr/local/redis\n修改redis.conf配置文件yim redis.conf (进入命令模式通过/内容查找相应字符串)\ndaemonize no修改为 daemonize yes守护进程启动 bind 127.0.01 注释掉 允许除本机外的机器访问Redis服务 requirepass设置密码设定数据库密码(保证服务安全/有些情况下不设定密码是无法进行远程连接访问的)  Redis采用的是单进程多线程的模式。当redis.conf中选项daemonize设置 成yes时,代表开启守护进程模式。在该模式下, redis会在后台运行,并将进程pid号写入至redis.conf选项pidfile设置的文件中,此时redis将一直运行,除非手动kill该进程。但当daemonize选项设置 成no时,当前界面将进入redis的命令行界面, exit强制退出或者关闭连接I具(putty,xshell等)都会导致redis进程退出。服务端开发的大部分应用都是采用后台运行的模式\nrequirepass设置密码。因为redis速度相当快,所以一台比较好的服务器下,一个外部用户在一秒内可以进行15W次密码尝试,这意味着你需要设定非常强大的密码来防止暴力破解。可以通过redis的配置文件设置密码参数,这样客户端连接到redis服务就需要密码验证,这样可以让你的redis服务更安全\n启动redis服务 ./bin/redis-server ./redis.conf  关闭redis 第一种方式 （断电、非正常关闭。容易导致数据丢失）\n查看进行\nps -ef | grep -i redis  杀死进程\nkill -9 进程id  第二种方式 正常关闭、数据保存\n关闭redis服务，通过客户端进行shutdown\nredis-cli shutdown  如果redis设置了密码，需要先在客户端进行密码登录，在进行shutdown即可关闭客户端\n./redis-cli -a dsfsdf shutdown  远程连接 远程连接比较流行的软件:RedisDesktopManager\n默认不允许远程连接,需要修改一下信息才可以进行修改 ，\nbind 127.0.01 注释掉 允许除本机外的机器访问Redis服务 requirepass设置密码设定数据库密码(有 些情况下不设定密码是无法进行远程连接访问的)  开放端口\n开放6379端口(如下命令只针对Centos7以上)\n查看已经开放的端口:\nfirewa1l-cmd --1ist-ports  开启端口:\nfirewall-cmd --zone=public --add-port=6379/tcp --permanent  重启防火墙:\nfirewall-cmd --reload #重启 firewal1 systemct1 stop firewalld.service #停止 firewall systemct1 disable firewalld.service #禁止firewa11开机启动  Docker安装Redis 安装单机版Redis 启动docker\nsystemctl start docker  搜索redis\ndocker search redis  下载镜像\ndocker pull redis:latest  创建并运行容器\ndocker run -d --name redis6397 -p 6397:6397 redis --requirepass \u0026quot;xxxx\u0026quot;  测试\ndocker ps  docker exec -it redis6379 bash pwd exit docker exec -it redis6379 redis-cli -a xxxx  redis命令 Redis命令用于在redis服务上执行操作。要在redis服务上执行命令需要一一个 redis客户端。 Redis客户端在我们之前下载的的redis 的安装包中。\nRedis支持五种数据类型: string (字符串) , hash(哈希) , list (列表) , set(集合)及zset(sorted set :有序集合)等\n常用命令管理 Keys * ：返回满足的所有键，可以模胡匹配比如 keys abc*代表 abc 开头的 key exists key: 是否存在指定的 key，存在返回 1, 不存在返回 0 expire key second：设置某个 key 的过期时间单位为秒 del key：删除某个 key ttl key：查看剩余时间，当 key 不存在时，返回-2; 存在但没有设置剩余生存时间时，返回-1, 否则，以秒为单位，返回 key 的剩余生存时司。 persist key：取消过去时间 PEXPIRE key mi11iseconds 修改 key 的过期时间为毫秒 select：选择数据库数据库为 0-15（默认一共 16 个数括库）——\u0026gt; 设计成多个数据库实际上是为了数据库安全和备份 move key dbindex：将当前数据中的 key 转移到其他数据库 randomkey：随机返回一个 key rename key key2: 重命名 key echo：打印命令 dbsize：查看数据库的 key 数量 info：查看数据库信息 config get * 实时传储收到的请求，返回相关的配置 flushdb：清空当前数据库 flusha11: 清空所有数据库 type key：返回key所存储的值类型  应用场景 expire key seconds 、EXISTS Key\n 限时的优惠活动信息 网站数据缓存（对于一些需要定时更新的数据，例如：积分排行榜） 手机验证码 限制网站访客访问频率（例如：1分钟最多访问10次）  key的命名建议（命名规范） redis 单个key允许放入512M大小\nredis是非关系型数据库；数据与数据之间没有关联\n key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率\n key不要太短，太短的话影响可读性\n 在一个项目中，key最好使用统一的命名模式，例如user:123:password\n key的名称区分大小写\n  Redis数据类型 String类型 简介\n String类型使redis的最基本的数据类型，一个键最大存储512MB String数据结构式简单的key-value类型，value其不仅是String，也可以是数字，是包含很多种类型的特殊类型 String类型使二进制安全的，（字符串不是根据某种特殊的标志来解析的，无论输入是什么，总能保证输出是处理的原始输入而不是根据某种特殊格式来处理）的，可以包含任何数据，比如序列化的对象存储，比如一张图片进行二进制存储，比如一个简单的字符串，数值等。  String类型的常用命令 赋值语法 set key_name value  多次设置同一个name的值会被覆盖,且无视类型。Redis SET命令用于设置给定key的值。如果key已经存储值，SET就要写旧值，且无视类型\nsetnx key1 value  如果keyi1不存在，则设值 并返回1。\n如果key1存在，则不设置值并返回0。\n引申： 解决分布式锁方案之一，只有在key不存在时设置key的值。setnx（set if Not exists）命令在指定的key不存在时，为key设置指定的值。\nsetex key1 10 lx  设置key1的值为lx，过期时间为10秒，10秒后key1清除（key也清除）\nsetrange string range value  替换字符串\n取值语法 get key_name  redis get命令获取指定key的值；如果key不存在，返回nil；如果key存储的值不是字符串类型，返回一个错误\ngetrange key start end  用于获取存储在指定key中字符串的子字符串。字符串的截取范围由start和end两个偏移量决定（包括start和end在内）\ngetbit key offset  对key所存储的字符串值，获取指定偏移量上的位（bit）\ngetset 语法  getset key_name value  getset 命令用于设置指定key的值，并返回key的旧值，当key不存在时，返回nil\nstrlen key  返回key所存储的字符串值的长度\n删除语法 DEL key_name  删除指定的key，如果存在，返回值数据类型\n批量操作 批量写\nmset k1 v1 k2 v2 k3 v3 一次性写入多个值  批量读\nmget k1 k2 k3  getset name value  一次性设置和读取（返回旧值，写上新值）\n自增/自减: INCR KEY-Name:  Incr 命令将 key 中存的数字值 1, 如果 key 不存在，那么 key 的值会先被初始化为 0，然后再执行 INCR 操作\n自增\n INCRBY KEY Name 増量值Inorby  命令将 key 中储存的数字加上指定的增量值\n自滅\n DECR KEY_NAME 或 DECRBY KEY_NAME 减值  DECR 命令将 key 中储存的数字减 1\n（注意这些 key 对应的必须是数字类型字符串，否则会出错，)\n字符拼接： APPEND KEY_ NAME VALUE  Append 命令用于为指定的 key 追加至未尾，如果不存在，为其赋值\n字符长度： STRLEN key  String类型的应用场景  1、Stringi 通常用于保存单个字符串或 json 字符串数据 2、因 String 是二进制安全的，所以你完全可以把一个图片文件的内容作为字符串来存储 3、计数器（常规 key-value 线存应用。常规计数：微博数，粉丝数）  INCR 等指令本身就具有原子操作的特性，所以我们完全可以利用 Redis 的 INCR、INCRBY、DECR、DECRBY 等指令来实现原子计数的效果。假如，在某种场景下有 3 个客户端同时读取了 minum 的值（值为 2），然后对其同时进行了加 1 的操作，那么，最后 bynum 的值一定是 5。不少网站都利用 reds 的这个特性来实现业务上的统计计数需求。\nHash类型 Hash类型是String类型的field和value的映射表，或者说是一个String集合。\nhash适合用于存储对象，相比较而言，对一个对象类型的存储在hash类型比存储在String类型里占有更少的内存空间，并对整个对象的存取。\n可以看成具有key和value的map容器，该类型非常适合于存储值对象的信息\n如：uname，upass，age等。\nRedis中每个hash可以存储2的32次方-1键值对（40多亿）\nHash命令 field字段\n赋值命令 hset key field value ：为指定的key，设定field/value hmset key field value [field1 value2] …… ：同时将多个 field-value （域-值）对设置到哈希表key中。  取值命令 hget key field : 获取存储在hash中的值，根据field得到value hmget key field[field1] : 获取key所有给定字段的值 hgetall key：返回hash表中的所有的字段和值  hkeys key： 获取所有哈希表中的字段\nhlen key：获取哈希表中字段的数量\n删除语法 hdel key field1[field2] : 删除一个或多个hash表字段 del key ： 也可以删除 hash类型值整体删除  其他语法 hsetnx key field value: 只有字段field不存在时，设置哈希表字段的值 hincrby key field increment： 为哈希表key 中的指定字段的证书值加上增量 increment hincrbyfloat key field increment ： 为哈希表key中的指定字段的浮点数值加上增量 increment hexists key field ： 查看哈希表 key 中，指定的字段是否存在  应用场景  常用用于存储一个对象 为什么不用string存储一个对象呢？  Hash 是最接近关系数据库结构的数据类型，可以将数据库一条记录或程序中一个对象转换成 hashmap 存放在 redis 中\n用户 D 为查找的 key，存储的 value 用户对象包含姓名，年龄，生日等信息，如果用普通的 key-value结构来存储，主要有以下 2 种存储方式\n第一种方式将用户ID 作为查找 key，把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是, 増加了序列化/反序列化的开销,并且在需要修改其中一项信息时,需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS 等复杂问题（并发安全问题）。\n比如：\nuser对象有 id name age 三个字段\n将对象转成JSON字符串\n set user:1 {\u0026quot;id\u0026quot;,\u0026quot;name\u0026quot;:\u0026quot;lisi\u0026quot;,score:\u0026quot;20\u0026quot;}  取得时候：json转成对象\n第二种方法是这个用户信息对象有多少成员就存成多少个 key- value 对儿，用用户 ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户ID 为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。\nset user:1:id 1 set user:1:name lisi set user:1:score 20  总结：\nRedis提供的 Hash 很好的解決了这个问题，Redis 的 Hash 实际是内部存储的 Value 为一个 Hashmap,\n并提供了直接存取这个 Map 成员的接口\nspringboot1 对redis的连接默认采用jedis。在springboot2之后，默认采用lettuce。这一点也说明了lettuce与jedis的优劣。\nSET类型 基本概念  集合（set）用来保存多个的字符串元素 不允许重复 元素是无序，不能通过索引下标获取元素 一个集合最多可以存储2的32次方-1个元 素。 支持多个集合取交集、并集、差集  常用命令 基本操作 sadd key element [element ...] # 添加元素，返回结果为添加成功的元素个数 srem key element [element ...] # 删除元素，返回结果为删除成功的元素个数 scard key # 计算元素个数， sismember key element # 判定元素是否在集合中，如果给定元素element在集合内返回1，反之返回0 srandmember key [count] # 随机从集合返回指定个数元素，count为可选参数，如果不写，默认为1 spop key # 从集合随机弹出元素，![\\color{red}{Redis从3.2版本开始，spop smembers key # 获取所有元素  sadd myset 1 2 3 1 结果：\u0026quot;3\u0026quot; del myset  注意 smembers和lrange、hgetall都属于比较重的命令，如果元素过多存在阻 塞Redis的可能性，这时候可以使用sscan来完成\n集合间操作  求多个集合的交集：sinter key [key \u0026hellip;]\n 求多个集合的并集：suinon key [key \u0026hellip;]\n 求多个集合的差集：sdiff key [key \u0026hellip;]\n 将交集、并集、差集的结果保存\n sinterstore destination key [key ...] suionstore destination key [key ...] sdiffstore destination key [key ...]   说明：\n集合间的运算在元素较多的情况下会比较耗时，所以Redis提供了上面 三个命令(原命令+store)将集合间交集、并集、差集的结果保存在 destination key中\n应用场景 应用核心思想：set集合，不允许重复，元素是无序\n 网站访问的黑名单、白名单 访问的UV，IP （PV可以使用String的自增实现） 用户tag  ZSET类型 有序集合(sorted set) 一般将有序集合成为zsets，因为相关命令是以z开头的\n基本概念  String类型元素的集合 不允许重复成员 每个元素关联一个double类型的分数，redis通过此分数为集合成员从小到大排序 有序集合的成员是唯一的，但是分数（score）却可以重复 集合通过哈希表实现的 集合中最大成员为2的次方32 -1 ，共计 40多亿个成员  常用命令 赋值语法 ZADD key score1 member1 [score2 member2】：向有序集合添加一个或多个成员，或者更新已存在成员的分数  取值语法 ZCARD key：获取有序集合的成员数 ZCOUNT key min max：计算在有序集合中指定区间分数的成员数 ZRANK key member：返回有序集合中指定成员的索引 ZRANGE key start stop [WITHSCORES】：通过索引区间返回有序集合成指定区间内的成员（低到高） ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT】：通过分数返回有序集合指定区间内的成员 ZREVRANGE key start stop [WITHSCORES】：返回有序集中指定区间内的成员，通过索引，分数从高到底 （索引从0开始） ZREVRANGEBYSCORE key max min [WITHSCORES】：返回有序集中指定分数区间内的成员，分数从高到低排序  删除语法  DEL key 移除集合 ZREM key member [member\u0026hellip;】：移除有序集合中的一个或多个成员 ZREMRANGEBYRANK key start stop：移除有序集合中给定的排名区间的所有成员（第一名是 0)（低到高排序） ZREMRANGEBYSCORE key min max：移除有序集合中给定的分数区间的所有成员 ZエNCRBY key increment member：加 memeber 元素的分数 increment，返回值是更改后的分数  应用场景 排行榜，销量排名，积分排名\n1 如 twitter 的 public timeline 可以以发表时间作为 score：来存储，这样获取时就是自动按时间排好序的。\n2 比如一个存储全班同学成绩的 Sorted Set，其集合 value 可以是同学的学号，而 scorei就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。\n3 还可以用 Sorted Set 来做帯权重的队列，比如普通消息的 score 为 1, 重要消息的 score 为 2, 然后工作线程可以选择按 core 的倒序来获取工作务。让重要的任务优先执行。\n例子 学员成绩排行榜\n需求1：在zset 中插入6名学生成绩\nzadd z1 30 a 40 b 50 c 60 d 70 e  需求2：按成绩由高到低排序，查出前3名学生成绩\nzrevrange z1 0 2  需求3： 查询成绩在 60~80分之间的学生个数\nzcount z1 60 80  需求3： 查询成绩在 60~80分之间的学生信息\nZRANGEBYSCORE z1 60 80  Hyperloglog类型 基本概念  Redis 在 2.8.9 版本添加了 HyperLoglog 结构 Redis Hyperloglog 是用来做基数统计的算法 Hyperloglog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的 在 Redis 里面，每个 Hyper Loglog 键只需要花費 12 KB 内存，就可以计算接近 2 的64方个不同元素的基数。这和计算基数时，元素越多耗费內存就越多的集合形成鲜明对比。 但是，因为 Hyperloglog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 Hyperloglog 不能像集合那样，返回输入的各个元素  什么是基数？ 比如数据集{1,3,5,7,5,7,8｝，那么这个数据集的基数集为{1,3,5,7,8｝，基数（不重复元素）为 5。基数估计就是在误差可接受的范围内，快速计算基数\n为什么需要 Hyperloglog 如果要統计1亿个数据的基数值,大约需要内存100000008/1024/1024 s 12 M，内存減少占用的效果显著。 统计一个对象的基数值需要 12 M，如果统计 10000 个对象，就需要将近 1206, 同样不能广泛用于大数据场景。\n误差率 HyperLogLog内存占用量小得惊人，但是用如此小空间来估算如此巨大的数据，必然不是100%的正确，其中一定存在误差率。Redis官 方给出的数字是0.81%的失误率。\n基本命令 PFADD key element [element・】：添加指定元素到 Hyperloglog 中 PFCOUNT key [key,,】：返回给定 Hyper Loglog 的基数估算值 PFMERGE deskey sourcekey [sourcekey,】：将多个 Hyper Loglog 合并为一个 Hyperloglog  场景 HyperLogLog内存占用量非常小，但是存在错误率，开发者在进行数据结构选型时只需要确认如下几条即可:\n 只为了计算独立总数，不需要获取单条数据。 可以容忍一定误差率，毕竟HyperLogLog在内存的占用量上有很大的优势。 基数不大，数据量不大就用不上，会有点大材小用的浪费空间 统计注册IP数 统计每日访问IP数 统计页面实时UV数 统计在线用户数 统计用户每天搜索不同词条的个数 统计真实文章阅读数  总结 Hyper Loglog 是一种算法，并非 redis？独有\n目的是做基数统计，故不是集合，不会保存元数据，只记录数量而不是数值\n耗空间极小，支持输入非常体积的数据量\n核心是基数估算算法，主要表现为计算时内的使用和数据合并的处理，最终数值存在一定误差\n底层存储结构 redis 中每个 hyperloglog key 占用了 12 K 的内存用于标记基数（官方文档）\npfadd 命令并不会一次性分配 12 k 内存，而是随着基数的増加而逐浙増加内存分配；而 pfmerge 操作则会将 sourcekey 合并后存储在 12 k 大小的 key 中，这由 hyperloglog 合并操作的原理（两个hyperloglogg 合并时需要单独比较每个桶的值）可以很容易理解。\n误差说明：基数估计的结果是一个带有 0.81%标准错误（standard error）的近似值。是可接受的范围\nRedis 对 Hyper Loglog 的存储进行了优化，在计数比较小时，它的存储空间采用稀疏矩阵存储，空间占用很小，仅仅在计数慢慢变大，稀疏矩阵占用空间渐新超过了國值时オ会一次性转变成稠空矩阵，オ会占用 12 k 的空间\nSpringBoot整合Jedis Redis常用客户端 Jedis api在线网址: Hhtp://tool.oschina.net/uploads/apidocs/redis/clients/jedis/ledis html\nredisson官网地址: https://redisson.org/\nredisson git项目地址: https://github.com/redisson/redisson\nlettuce官网地址: https://lettuce.io/\nlettuce git项目地址: https://github.com/lettuce-io/lettuce-core\n首先,在spring boot2之后,对redis连接的支持,默认就采用了lettuce.这就-定程度说明了lettuce 和 Jedis的优劣。\n概念\nJedis：是老牌的 Redis 的Java 实现客户端，提供了比较全面的 Redis 命令的支持， Redisson：实现了分布式和可扩展的Java 数据结构。 Lettuce：高级 Redis 客户端，用于线程安全同步，异步和响应使用，支持集群，Sentinel，管道和编码器  优点：\nJedis：比较全面的提供了 Redis的操作特性\nRedisson：促使使用者对 Redist 的关注分离，提供很多分布式相关操作服务，例如，分布式锁，分布式集台，可通过 Redis 支持延退队列\nLettuce：基于 Netty 框架的事件驱动的通信层，其方法调用是异步的。Lettuce 的 API 是程安全的，所以可以操作单个 Lettuce 连接来完成各种操作\n总结：\n优先使用 Lettuce，如果需要分布式锁，分布式集合等分布式的高级特性，添加 Redisson 结合使用，因为 Redisson 本身对字符串的操作支持很差。\n在一些高并发的场景中，比如秒杀，抢票，抢购这些场景，都存在对核心资源，商品库存的争，控制不好，库存数量可能被减少到负数，出现超卖的情況，或者产生唯一的一个递增 ID，由于 web 应用部在多个机器上，简单的同步 加锁是无法实现的,给数据库加锁的话,对于高并发,1000/5的并发,数据库可能由行锁变成表锁，性能下降会历害。那相对而言，redis 的分布式锁，相对而言，是个很好的选择，redis官方推荐使用的 Redisson 就提供了分布式锁和相关服务。\n在官方网站列一些java客户端, 有: Jedis/Redisson/redis/JDBC.Reds 等，其中官方推荐使用 redis 和 Redisson。常用 edis。\n简介 我们在使用springboot搭建微服务的时候,在很多时候还是需要redis的高速缓存来缓存一些数据 ,存储一些高频率访问的数据,如果直接使用redis的话又比较麻烦,在这里,我们使用jedis来实现redis缓存来达到高效缓存的目的\n创建module\u0026ndash;\u0026gt;场景选择spring Web、Spring Boot DevTools、Lombok\n此时不要选择Redis\n1）、引入依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;redis.clients\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jedis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  2）、配置 spring: redis: port: 6389 password: xxx host: 222.22.22.22 jedis: pool: max-idle: 10 #最大空闲数 max-active: 10 #最大连接数 min-idle: 2 #最小连接数 timeout: 2000 # 连接超时  3）、配置类 import redis.clients.jedis.JedisPoolConfig; @Configuration public class JedisConfig { private Logger logger = LoggerFactory.getLogger(JedisConfig.class); /** * SpringSession 需要注意的就是redis需要2.8以上版本，然后开启事件通知，在redis配置文件里面加上 * notify-keyspace-events Ex * Keyspace notifications功能默认是关闭的（默认地，Keyspace 时间通知功能是禁用的，因为它或多或少会使用一些CPU的资源）。 * 或是使用如下命令： * redis-cli config set notify-keyspace-events Egx * 如果你的Redis不是你自己维护的，比如你是使用阿里云的Redis数据库，你不能够更改它的配置，那么可以使用如下方法：在applicationContext.xml中配置 * \u0026lt;util:constant static-field=\u0026quot;org.springframework.session.data.redis.config.ConfigureRedisAction.NO_OP\u0026quot;/\u0026gt; * @return */ @Value(\u0026quot;${spring.redis.host}\u0026quot;) private String host; @Value(\u0026quot;${spring.redis.port}\u0026quot;) private int port; @Value(\u0026quot;${spring.redis.password}\u0026quot;) private String password; @Value(\u0026quot;${spring.redis.timeout}\u0026quot;) private int timeout; @Value(\u0026quot;${spring.redis.jedis.pool.max-active}\u0026quot;) private int maxActive; @Value(\u0026quot;${spring.redis.jedis.pool.max-idle}\u0026quot;) private int maxIdle; @Value(\u0026quot;${spring.redis.jedis.pool.min-idle}\u0026quot;) private int minIdle; @Bean public JedisPool redisPoolFactory(){ JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxIdle(maxIdle); jedisPoolConfig.setMaxTotal(maxActive); jedisPoolConfig.setMinIdle(minIdle); JedisPool jedisPool = new JedisPool(jedisPoolConfig,host,port,timeout,password); logger.info(\u0026quot;JedisPool注入成功！\u0026quot;); logger.info(\u0026quot;redis地址：\u0026quot; + host + \u0026quot;:\u0026quot; + port); return jedisPool; } }  4）、测试 @SpringBootTest class SpringbootJedisApplicationTests { @Autowired private JedisPool jedisPool; @Test void contextLoads() { System.out.println(jedisPool); } }  SpringBoot中Redis使用lettuce java代码操作Redis，需要使用Jedis ,也就是redis支持java的第三方类库\n注意:Jedis2.7以上的版本才支持集群操作\nmaven配置 \u0026lt;!--默认就是lettuce客户端--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--redis依赖commons-pool这个依赖一定要添加--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-pool2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--测试库的信息--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  配置 server: port: 8080 spring: redis: port: 6389 password: xxx host: 22.22.22.22 lettuce: pool: max-idle: 10 #最大空闲数 max-active: 10 #最大连接数 min-idle: 2 #最小连接数 max-wait: 1000 #连接池最大阻塞等待事件（使用负值表示没有限制） timeout: 2000 # 连接超时  编写缓存配置类RedisConfig用于调优缓存默认配置，RedisTemplate的类型兼容性更高大家可以看到在redisTemplate(这个方法中用acksonjsonRedisSerializer更换掉了Redis默认的序列化方式: JdkSerializationRedisSerializer\nspring- data-redis中序列化类有以下几个:\nGenericToStringSerializer :可以将任何对象泛化为字符创并序列化 Jackson2JsonRediSrializer :序列化Object对象为json字符创(与JacksonsonRedisSerallzer相同) JdkSerializationRedisSerializer :序列化java对象 StringRedisSerializer :简单的字符串序列化 JdkSerializationRedisSerializer序列化被序列化对象必须实现Serializable接口,被序列化除属性内容还有其 他内容,长度长且不易阅读，默认就是采用这种序列化方式  存储内容如下:\n\u0026quot;\\xacxed\\x00\\x05sr\\x00!com.oreilly.springdata.redis.Userxb1lx1c \\Inlxcd\\xed%\\xd8\\x02Xx00x021x00\\x03ageLx00\\buserNametx00x12Ljava/ang/String;xplx00x00lx0 0lx 14t\\x00\\x05user1\u0026quot;  JacksonjsonRedisSerializer序列化;被序列化对象不需要实现Serializable接口,被序列化的结果清晰,容易阅 读，而且存储字节少,速度快  Redis的其他功能 Redis发布订阅 简介\nRedis发布订阅(pub/sub)是一种消息通信模式:发送者(pub)发送消息,订阅者(sub)接收消息。Redis客户端可以订阅任意数量的频道。\nRedis发布订阅(pub/sub)是一种消息通信模式:发送者(pub)发送消息,订阅者(sub)接收消息。\nRedis客户端可以订阅任意数量的频道。\n常用命令 订阅频道:\nSUBSCRIBE channe1 [channe1 ...] :订阅给定的一个或多个频道的信息 PSUBSCRIBE pattern [pattern ...] :订阅一个或多个符合给定模式的频道。  发布频道:\nPUBLISH channe1 message : 将信息发送到指定的频道。  退订频道:\nUNSUBSCRIBE [channe1 [channe1 ...]] :指退订给定的频道。 PUNSUBSCRIBE [pattern [pattern ...1]:退订所有给定模式的频道。  应用场景 这一功能最明显的用法就是构建实时消息系统,比如普通的即时聊天,群聊等功能\n 在一个博客网站中,有100个粉丝订阅了你.当你发布新文章,就可以推送消息给粉丝们。 微信公众号模式 微博，每个用户的粉丝都是该用户的订阅者，当用户发完微博,所有粉丝都将收到他的动态; 新闻,资讯站点通常有多个频道,每个频道就是一个主题 ,用户可以通过主题来做订阅(如RSS) ,这样当新闻 发布时,订阅者可以获得更新  Redis多数据库 一些基本概念  redis 数据库由整数索引标识，而不是一个数据库名称 默认情况下，一个客户端连接到数据库0 redis配置文件中下面的参数来控制数据库总数:\ndatabase 16 // 从0开始， 0~15   常用命令 select数据库 // 数据库的切换 ： select 数据库索引标识 移动数据（将当前key移动到另一个库）： move key名称 数据库索引标识 清空数据库： flushdb：清除当前数据库的所有key flushall：清除整个redis的数据库所有key  注意 redis为什么默认16个数据库？\n Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念\n 隔离业务或是隔离生产环境与测试环境\nredis之所以分这么多个数据库，也是为了区分业务，不同的业务存放在不同的库，但是一个redis，一般是给一个项目用，项目内的不同业务，单独用一个库，这样不会相互有数据交叉。现在很多微服务项目，一个项目里有多个微服务，redis统一由团队管理，每个服务连接自己的库就可以了。\n  Redis事务 redis事务可以一次执行多个命令，（按顺序地串行化执行，执行中不会被其他命令插入，不许加塞）\n一些概念 Redis 事务可以一次执行多个命令（允许在一次单独的步骤中执行一组命令），并且帯有以下两个重要的保证：\n Redis 会将一个事务中的所有命令序列化，然后按顺序执行 执行中不会被其它命令插入，不许出现加塞 行为  说明：\n批量操作在发送 EXEC 命令前被放入队列缓存。收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。\n常用命令 DISCARD ：取消事务，放弃执行事务块内的所有命令 EXEC：执行所有事务块内的命令 MULTI：标记一个事务决的开始 UNWATCH：取消 WATCH 命令对所有 key 的监视 WATCH key [key..] ：监视一个（或多个）key，如果在事务执行之前这个（或这些）key 被其他命令所改动，那么事务将被打断  执行过程 一个事务从开始到执行会经历一下三个阶段：\n 开始事务 命令入队 执行事 务  应用场景 一组命令必须同时都执行，或者都不执行\n我们想要保证一组命令在执行过程中不被其他命令插入\n秒杀\n总结 Redis提供了简单的事务，之所以说它简单，主要是因为它不支持事务 中的回滚特性，同时无法实现命令之间的逻辑关系计算，当然也体现了 Redis的“keep it simple”的特性，下一篇文章介绍的Lua脚本同样可以实现事务 的相关功能，但是功能要强大很多。\nRedis持久化 RDB \u0026ndash; 快照\n基本概念  默认的redis持久化机制\n RDB相当于快照，保存的是一种状态， 几十G数据 -\u0026gt; 几kb快照 这种方式就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb\n 优点：\n 快照保存数据极快，还原数据极快，适用于灾难备份  缺点：\n​ 小内存机器不适合使用，只有复合RDB机制要求的才会照快照\n  快照条件： 自动触发 服务器正常关机时\n ./bin/redis-cli shutdown  key 满足一定的条件，会进行快照\nvim redis.conf 搜索 save\nredis.conf中的save配置\nsave 900 1 //每 900 秒（15 分钟）至少 1 个 key 发生变化, 产生快照 save 300 10 //每300秒(5分钟)至少10个key发生变化,产生快照 save 60 10000 //毎60秒(1分钟)至少10000个key发生变化，产生快照  手动触发 包括save和bgsave命令。\n因为save会阻塞当前Redis节点，所以，Redis内部所有涉及RDB持久化的的操作都通过bgsave方式，save方式已废弃。\nAOF \u0026ndash; 操作记录（增量）\n由于快照方式是在一定间隔时间快照一次的，所以如果 redis 意外 down 掉的话，就会丢失最后一次快照之后的所有修改。如果应用要求不能丢失任何修改的话，可以采用 aof 持久化方式。\nAppend-only file: aof 比快照方式有更好的持久化性，是由于在使用 aof 持久化方式时，redis将每一个收到的写命令都通过 wrte 函数追加到文件中（默认是 appendonly. Aof）。当 redis 重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。\n触发条件 有三种方式如下（默认是：每秒 fsync 一次）\nappendonly yes/启用 aof 持久化方式  appendfsync always //收到写命令就立即写入磁盘，最慢，但是保证完全的持久化 appendfsync everysec //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中 appendfsync no //完全依赖os，性能最好，持久化没保证  产生的问题：\naof 的方式也同时带来了另ー个问题。持久化文件会变的越来越大。例如我们调用 incr test命令 100 次文件中必须保存全部的 100 条命令，其实有 99 条都是多余的。\nRedis-4.0以后的混合持久化\n简介\nredis4.0相对与3.X版本其中一个比较大的变化是4.0添加了新的混合持久化方式。前面已经详细介绍了AOF持久化以RDB持久化，这里介绍的混合持久化就是同时结合RDB持久化以及AOF持久化混合写入AOF文件。这样做的好处是可以结合rdb 和 aof 的优点, 快速加载同时避免丢失过多的数据，缺点是 aof 里面的 rdb 部分就是压缩格式不再是 aof 格式，可读性差。\n开启混合持久化\n4.0版本的混合持久化默认关闭的，通过aof-use-rdb-preamble配置参数控制，yes则表示开启，no表示禁用，默认是禁用的，可通过config set修改。\n混合持久化过程\n了解了AOF持久化过程和RDB持久化过程以后，混合持久化过程就相对简单了。\n混合持久化同样也是通过bgrewriteaof完成的，不同的是当开启混合持久化时，fork出的子进程先将共享的内存副本全量的以RDB方式写入aof文件，然后在将重写缓冲区的增量命令以AOF方式写入到文件，写入完成后通知主进程更新统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的的AOF文件。简单的说：新的AOF文件前半段是RDB格式的全量数据后半段是AOF格式的增量数据。\n主从分离 为什么需要主从分离\u0026mdash;单节点redis的问题\n 单机故障  ​\n如果发生机器故障，例如磁盘损坏，主板损坏等，未能在短时间内修复好，客户端将无法连接redis。 当然如果仅仅是redis节点挂掉了，可以进行问题排查然后重启，姑且不考虑这段时间对外服务的可用性，那还是可以接受的。而发生机器故障，基本是无济于事。除非把redis迁移到另一台机器上，并且还要考虑数据同步的问题。   容量瓶颈  ​\n假如一台机器是16G内存，redis使用了12G内存，而其他应用还需要使用内存，假设我们总共需要60G内存要如何去做呢，是否有必要购买64G内存的机器？   QPS瓶颈  ​\nredis官方数据显示可以达到10w的QPS，如果业务需要100w的QPS怎么去做呢？ 关于容量瓶颈和QPS瓶颈是redis分布式需要解决的问题，而机器故障就是高可用的问题了。  主从复制的用途  读写分离\nRedis实例划分为主节点(master)和从节点(slave)。默认 情况下，主节点负责写操作，从节点负责读操作\n 容灾备份\n  常见拓扑结构 一主一从 从节点也是可以对外提供服务的，主节点是有数据的，从节点可以通过复制操作将主节点的数据同步来，并且随着主节点数据不断写入，从节点数据也会做同步的更新。整体起到的就是数据备份的效果。\n应对高并发时的一种解决方法 \u0026mdash;\u0026ndash; 关闭 主节点的aof\n 关闭主节点的aof 只开启从节点的aof  重启服务时，先在从节点断开slaveof no one与主节点的复制关系，再重启主节点。防止复制主节点导致从节点数据丢失\n一主多从  一主多从结构(又称为星形拓扑结构)使得应用端可以利用多个从节点 实现读写分离 对于读占比较大的场景，可以把读命令发送到 从节点来分担主节点压力。 同时在日常开发中如果需要执行一些比较耗时的 读命令，如:keys、sort等，可以在其中一台从节点上执行，防止慢查询对 主节点造成阻塞从而影响线上服务的稳定性。 对于写并发量较高的场景，多个从节点会导致主节点写命令的多次发送从而过度消耗网络带宽，同时也加重了主节点的负载影响服务稳定性。  树状主从结构  树状主从结构(又称为树状拓扑结构)使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。 通过引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量。 数据写入节点A后会同步到B和C节点，B节点再把数据同步到D和E节 点，数据实现了一层一层的向下复制。 当主节点需要挂载多个从节点时为了 避免对主节点的性能干扰，可以采用树状主从结构降低主节点压力。  配置方式 方式一\n建立连复制\n修改redis.conf\n# 配置主节点的IP和端口号 slaveof 127.0.0.1 8000 # 从节点只做读的操作，保证主从数据的一致性 slave-read-only yes  redis-server启动命令 redis-server --slaveof {masterHost}{masterPort}  方式二\nredis-cli中直接使用命令 slaveof {masterHost}{masterPort}  注意：\nslaveof本身是异步命令，执行slaveof命令时，节点只保存主节点信息后 返回，后续复制流程在节点内部异步执行。\ninfo replication命令 查看复制状态信息\n断开复制\nslaveof no one  断开后的主要流程\n1)、断开与主节点复制关系。\n2)、从节点晋升为主节点。\n注意\n 从节点断开复制后并不会抛弃原有数据，只是无法再获取主节点上的数据变化。 切换主节点后的从节点会清空之前所有的数据，线上人工操作时小心slaveof在错 误的节点上执行或者指向错误的主节点。  传输延迟 主从节点一般部署在不同机器上，复制时的网络延迟就成为需要考虑的 问题，Redis为我们提供了repl-disable-tcp-nodelay参数用于控制是否关闭 TCP_NODELAY，默认关闭，说明如下:\n 当关闭时，主节点产生的命令数据无论大小都会及时地发送给从节 点，这样主从之间延迟会变小，但增加了网络带宽的消耗。适用于主从之间 的网络环境良好的场景，如同机架或同机房部署。 当开启时，主节点会合并较小的TCP数据包从而节省带宽。默认发送 时间间隔取决于Linux的内核，一般默认为40毫秒。这种配置节省了带宽但 增大主从之间的延迟。适用于主从网络环境复杂或带宽紧张的场景，如跨机 房部署。  复制过程步骤  从节点执行 slaveof 命令\n 从节点只是保存了 slaveof 命令中主节点的信息，并没有立即发起复制\n 从节点内部的定时任务发现有主节点的信息，开始使用 socket 连接主节点\n 连接建立成功后，发送 ping 命令，希望得到 ping 命令响应，否则会进行重连\n 如果主节点设置了权限，那么就需要从节点必须配置masterauth参数进行权限验证；如果验证失败，复制终止。\n 权限验证通过后，进行数据同步，这是耗时最长的操作，主节点将把所有的数据全部发送给从节点。\n 当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来，主节点就会持续的把写命令发 送给从节点，保证主从数据一致性。\n  数据同步 上面说的复制过程，其中有一个步骤是“同步数据集”，这个就是现在讲的‘数据间的同步’。同步过程分为『全量同步』与『部分同步』\n 全量复制:\n一般用于初次复制场景，Redis早期支持的复制功能只有全 量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会 对主从节点和网络造成很大的开销。\n 部分复制:\n用于处理在主从复制中因网络闪断等原因造成的数据丢失 场景，当从节点再次连上主节点后，如果条件允许，主节点会补发丢失数据 给从节点。因为补发的数据远远小于全量数据，可以有效避免全量复制的过 高开销。\n  当使用复制功能时，尽量采用2.8以上版本的Redis。\nredis 同步有 2 个命令：\nsync 和 psync，  前者是 redis 2.8 之前的同步命令，后者是 redis 2.8 为了优化 sync 新设计的命令。我们会重点关注 2.8 的 psync 命令。\npsync 命令需要 3 个组件支持：\n1）、主从节点各自复制偏移量\n参与复制的主从节点都会维护自身的复制偏移量。\n主节点在处理完写入命令后，会把命令的字节长度做累加记录，统计信息在 info replication 中的 masterreploffset 指标中。\n从节点每秒钟上报自身的的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。从节点在接收到主节点发送的命令后，也会累加自身的偏移量，统计信息在 info replication 中。 通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致。\n2）、主节点复制积压缓冲区\n复制积压缓冲区是一个保存在主节点的一个固定长度的先进先出的队列。默认大小 1MB。 这个队列在 slave 连接是创建。这时主节点响应写命令时，不但会把命令发送给从节点，也会写入复制缓冲区。他的作用就是用于部分复制和复制命令丢失的数据补救。通过 info replication 可以看到相关信息。\n3）、主节点运行 ID\n每个 redis 启动的时候，都会生成一个 40 位的运行 ID。运行 ID 的主要作用是用来识别 Redis 节点。如果使用 ip+port 的方式，那么如果主节点重启修改了 RDB/AOF 数据，从节点再基于偏移量进行复制将是不安全的。所以，当运行 id 变化后，从节点将进行全量复制。也就是说，redis 重启后，默认从节点会进行全量复制。\n如果在重启时不改变运行 ID 呢？\n可以通过 debug reload 命令重新加载 RDB 并保持运行 ID 不变。从而有效的避免不必要的全量复制。\n他的缺点则是：debug reload 命令会阻塞当前 Redis 节点主线程，因此对于大数据量的主节点或者无法容忍阻塞的节点，需要谨慎使用。一般通过故障转移机制可以解决这个问题。\n流程说明：从节点发送 psync 命令给主节点，runId 就是目标主节点的 ID，如果没有默认为 -1，offset 是从节点保存的复制偏移量，如果是第一次复制则为 -1.\n主节点会根据 runid 和 offset 决定返回结果：\n如果回复 +FULLRESYNC {runId} {offset} ，那么从节点将触发全量复制流程。\n如果回复 +CONTINUE，从节点将触发部分复制。\n如果回复 +ERR，说明主节点不支持 2.8 的 psync 命令，将使用 sync 执行全量复制。\n到这里，数据之间的同步就讲的差不多了，篇幅还是比较长的。主要是针对 psync 命令相关之间的介绍。\n全量复制 全量复制是 Redis 最早支持的复制方式，也是主从第一次建立复制时必须经历的的阶段。触发全量复制的命令是 sync 和 psync。\nredis 2.8 之前使用 sync 只能执行全量不同，2.8 之后同时支持全量同步和部分同步。\n发送 psync 命令（spync ？ -1）\n主节点根据命令返回 FULLRESYNC\n从节点记录主节点 ID 和 offset\n主节点 bgsave 并保存 RDB 到本地\n主节点发送 RBD 文件到从节点\n从节点收到 RDB 文件并加载到内存中\n主节点在从节点接受数据的期间，将新数据保存到“复制客户端缓冲区”，当从节点加载 RDB 完毕，再发送过去。（如果从节点花费时间过长，将导致缓冲区溢出，最后全量同步失败）\n从节点清空数据后加载 RDB 文件，如果 RDB 文件很大，这一步操作仍然耗时，如果此时客户端访问，将导致数据不一致，可以使用配置slave-server-stale-data 关闭.\n从节点成功加载完 RBD 后，如果开启了 AOF，会立刻做 bgrewriteaof。\n以上加粗的部分是整个全量同步耗时的地方。\n注意：\n如过 RDB 文件大于 6GB，并且是千兆网卡，Redis 的默认超时机制（60 秒），会导致全量复制失败。可以通过调大 repl-timeout 参数来解决此问题。\n无盘复制 为了降低主节点磁盘开销，Redis支持无盘复制，生成 的RDB文件不保存到硬盘而是直接通过网络发送给从节点，通过repl- diskless-sync参数控制，默认关闭。无盘复制适用于主节点所在机器磁盘性 能较差但网络带宽较充裕的场景。注意无盘复制目前依然处于试验阶段，线 上使用需要做好充分测试。\n部分复制 当从节点正在复制主节点时，如果出现网络闪断和其他异常，从节点会让主节点补发丢失的命令数据，主节点只需要将复制缓冲区的数据发送到从节点就能够保证数据的一致性，相比较全量复制，成本小很多。\n当从节点出现网络中断，超过了 repl-timeout 时间，主节点就会中断复制连接。\n主节点会将请求的数据写入到“复制积压缓冲区”，默认 1MB。\n当从节点恢复，重新连接上主节点，从节点会将 offset 和主节点 id 发送到主节点\n主节点校验后，如果偏移量的数后的数据在缓冲区中，就发送 cuntinue 响应 —— 表示可以进行部分复制\n主节点将缓冲区的数据发送到从节点，保证主从复制进行正常状态。\n心跳 主从节点在建立复制后，他们之间维护着长连接并彼此发送心跳命令。\n心跳的关键机制如下： 中从都有心跳检测机制，各自模拟成对方的客户端进行通信，通过 client list 命令查看复制相关客户端信息，主节点的连接状态为 flags = M，从节点的连接状态是 flags = S。\n主节点默认每隔 10 秒对从节点发送 ping 命令，可修改配置 repl-ping-slave-period 控制发送频率。\n从节点在主线程每隔一秒发送 replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量。\n主节点收到 replconf 信息后，判断从节点超时时间，如果超过 repl-timeout 60 秒，则判断节点下线。\n注意：为了降低主从延迟，一般把 redis 主从节点部署在相同的机房/同城机房，避免网络延迟带来的网络分区造成的心跳中断等情况。\n异步复制 主节点不但负责数据读写，还负责把写命令同步给从节点，写命令的发送过程是异步完成，也就是说主节点处理完写命令后立即返回客户端，并不等待从节点复制完成。\n异步复制的步骤很简单，如下：\n主节点接受处理命令\n主节点处理完后返回响应结果\n对于修改命令，异步发送给从节点，从节点在主线程中执行复制的命令。\n总结\n缺点:\n 由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。\n 当主机宕机之后，将不能进行写操作，需要手动将从机升级为主机，从机需要重新制定master\n  简单总结：\n一个master可以有多个Slave\n一个slave只能有一个master\n数据流向是单向的，只能从主到从\n哨兵模式 主从复制的优缺点 优点\n 从节点可作为主节点的备份：如果主节点废了，可以变从为主 从节点可以扩展主节点的读能力，分担负载  缺点\n 故障时需人工干预\n一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需 要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整 个过程都需要人工干预。\n 主节点的写能力受到单机的限制。\n ·主节点的存储能力受到单机的限制。\n  Redis Sentinel模式 自动化故障处理\n当主节点出现故障时，Redis Sentinel能自动完成故障发现和故障转移， 并通知应用方，从而实现真正的高可用。\n简述过程\nRedis Sentinel是一个分布式架构，其中包含若干个Sentinel节点和Redis 数据节点，每个Sentinel节点会对数据节点和其余Sentinel节点进行监控，当 它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还 会和其他Sentinel节点进行“协商”，当大多数Sentinel节点都认为主节点不可 达时，它们会选举出一个Sentinel节点来完成自动故障转移的工作，同时会 将这个变化实时通知给Redis应用方。整个过程完全是自动的，不需要人工 来介入，所以这套方案很有效地解决了Redis的高可用问题。\n版本预警\n建议使用2.8以上稳定版本的哨兵\nRedis Sentinel的主要功能 Sentinel 的主要功能包括 主节点存活检测、主从运行情况检测、自动故障转移 （failover）、主从切换。Redis 的 Sentinel 最小配置是 一主一从。\nRedis 的 Sentinel 系统可以用来管理多个 Redis 服务器，该系统可以执行以下四个任务：\n 监控 Sentinel 会不断的检查 主服务器 和 从服务器 是否正常运行。 通知 当被监控的某个 Redis 服务器出现问题，Sentinel 通过 API 脚本 向 管理员 或者其他的 应用程序 发送通知。 自动故障转移 当 主节点 不能正常工作时，Sentinel 会开始一次 自动的 故障转移操作，它会将与 失效主节点 是 主从关系 的其中一个 从节点 升级为新的 主节点，并且将其他的 从节点 指向 新的主节点。 配置提供者 在 Redis Sentinel 模式下，客户端应用 在初始化时连接的是 Sentinel 节点集合，从中获取 主节点 的信息。  关于部署的建议  Sentinel节点不应该部署在一台物理“机器”上。 特意强调物理机是因为一台物理机做成了若干虚拟机或者现今比较 流行的容器，它们虽然有不同的IP地址，但实际上它们都是同一台物理机， 同一台物理机意味着如果这台机器有什么硬件故障，所有的虚拟机都会受到 影响，为了实现Sentinel节点集合真正的高可用，请勿将Sentinel节点部署在 同一台物理机器上。\n 部署至少三个且奇数个的Sentinel节点。 3个以上是通过增加Sentinel节点的个数提高对于故障判定的准确性，因为领导者选举需要至少一半加1个节点，奇数个节点可以在满足该条件的基 础上节省一个节点。\n 只有一套Sentinel，还是每个主节点配置一套Sentinel?\n  方案一:\n一套Sentinel，很明显这种方案在一定程度上降低了维护成 本，因为只需要维护固定个数的Sentinel节点，集中对多个Redis数据节点进 行管理就可以了。但是这同时也是它的缺点，如果这套Sentinel节点集合出 现异常，可能会对多个Redis数据节点造成影响。还有如果监控的Redis数据 节点较多，会造成Sentinel节点产生过多的网络连接，也会有一定的影响。\n方案二:\n多套Sentinel，显然这种方案的优点和缺点和上面是相反的， 每个Redis主节点都有自己的Sentinel节点集合，会造成资源浪费。但是优点 也很明显，每套Redis Sentinel都是彼此隔离的。\n如果Sentinel节点集合监控的是同一个业务的多个主节点集合，那么使 用方案一、否则一般建议采用方案二。\n监控机制\u0026ndash;三个定时监控任务 1）、每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取 最新的拓扑结构\n作用：\n 从过主节点获取从节点信息 感知新增从节点 节点不可达或者故障转移后，可以通过info命令实时更新节点拓扑信息。  2)、每隔2秒，每个Sentinel节点会向Redis数据节点的sentinel:hello 频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息同时每个Sentinel节点也会订阅该频道，来了解其他 Sentinel节点以及它们对主节点的判断，所以这个定时任务可以完成以下两 个工作:\n 发现新的Sentinel节点:通过订阅主节点的sentinel:hello了解其他 的Sentinel节点信息，如果是新加入的Sentinel节点，将该Sentinel节点信息保 存起来，并与该Sentinel节点创建连接。 Sentinel节点之间交换主节点的状态，作为后面客观下线以及领导者选 528 举的依据。  3)、每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点 发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达。\n领导者Sentinel节点选举 Redis使用了Raft算法实 现领导者选举，因为Raft算法相对比较抽象和复杂，以及篇幅所限，所以这 里给出一个Redis Sentinel进行领导者选举的大致思路\n1)每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观 下线时候，会向其他Sentinel节点发送sentinel is-master-down-by-addr命令， 要求将自己设置为领导者。\n2)收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的sentinel is-master-down-by-addr命令，将同意该请求，否则拒绝。\n3)如果该Sentinel节点发现自己的票数已经大于等于max(quorum， num(sentinels)/2+1)，那么它将成为领导者。\n4)如果此过程没有选举出领导者，将进入下一次选举。\nRedis Clister集群 集群模式是实际使用最多的模式。\nRedis Cluster是社区版推出的Redis分布式集群解决方案,主要解决Redis分布式方面的需求,比如,当遇到单机 内存,并发和流量等瓶颈的时候, Redis Cluster能起到很好的负载均衡的目的。\n为什么使用redis-cluster ?\n 为了在大流量访问下提供稳定的业务，集群化是存储的必然形态 未来的发展趋势肯定是云计算和大数据的紧密结合 只有分布式架构能满足要求  集群描述  Twitter开发的twemproxy\n 豌豆荚开发的codis\n redis官方的redis-cluster\n亲儿子毕竟是更新最快，维护和支持新版本redis新特性好的，所以选择方案上业界一般选择redis-cluster\n  redis-cluster简介  redis-cluster是redis社区中推出的redis分布式集群解决方案 主要解决redis分布式的需求：  单机内存瓶颈 并发和流量瓶颈 同步复制带宽瓶颈等  redis3.0之后版本支持redis-cluster集群 至少需要3主（master）+3从（slave）才能建立集群 redis-cluster 采用无中心结构（类比区块链的去中心化）结构 每个节点保存数据和集群信息状态，每个节点和其他节点连接  结构 每个节点保存数据和集群信息状态，每个节点和其他节点连接\n其结构特点： 1、所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。 2、节点的fail是通过集群中超过半数的节点检测失效时才生效。 3、客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。 4、redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护node\u0026lt;-\u0026gt;slot\u0026lt;-\u0026gt;value。 5、Redis集群预分好16384个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。\n容错性 容错性指软件检测应用程序所在运行的软件或硬件中发生的错误并从错误中恢复的能力，通常可以从系统的可靠性，可用性，可测性的等几方面来衡量。\n 1 什么时候判断 master 不可用？  投票机制。投票过程是集群中所有 master 参与，如果半数以上 master 节点与 master节点通信超时（cluster-node-timeout）认为当前 master 节点挂掉\n 2 什么时候整个集群不可用（cluster state: fail)  如果集群任意 master 挂掉，且当前 master 没有 slave。集群进入fail状态也可以理解成集群的 Slot 映射 0-16383] 不完整时进入 fail 状态。如果集群超过半数以上 master 挂掉，无论是否有 slave，集群进入 fail 状态\n节点分配（数据分片） redis cluster节点分配 现在我们是三个主节点分别是：A, B, C 三个节点，它们可以是一台机器上的三个端口，也可以是三台不同的服务器。那么，采用哈希槽 (hash slot)的方式来分配16384个slot 的话，它们三个节点分别承担的slot 区间是：\n 节点A覆盖0－5460;\n 节点B覆盖5461－10922;\n 节点C覆盖10923－16383.\n获取数据:\n如果存入一个值，按照redis cluster哈希槽的算法： CRC16(\u0026lsquo;key\u0026rsquo;)384 = 6782。 那么就会把这个key 的存储分配到 B 上了。同样，当我连接(A,B,C)任何一个节点想获取\u0026rsquo;key\u0026rsquo;这个key时，也会这样的算法，然后内部跳转到B节点上获取数据\n  新增一个主节点: 新增一个节点D，redis cluster的这种做法是从各个节点的前面各拿取一部分slot到D上，我会在接下来的实践中实验。大致就会变成这样：\n 节点A覆盖1365-5460 节点B覆盖6827-10922 节点C覆盖12288-16383 节点D覆盖0-1364,5461-6826,10923-12287  同样删除一个节点也是类似，移动完成后就可以删除这个节点了。\nRedis Cluster主从模式 redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉\n上面那个例子里, 集群有ABC三个主节点, 如果这3个节点都没有加入从节点，如果B挂掉了，我们就无法访问整个集群了。A和C的slot也无法访问。\n所以我们在集群建立的时候，一定要为每个主节点都添加了从节点, 比如像这样, 集群包含主节点A、B、C, 以及从节点A1、B1、C1, 那么即使B挂掉系统也可以继续正确工作。\nB1节点替代了B节点，所以Redis集群将会选择B1节点作为新的主节点，集群将会继续正确地提供服务。 当B重新开启后，它就会变成B1的从节点。\n不过需要注意，如果节点B和B1同时挂了，Redis集群就无法继续正确地提供服务了。\n安装集群  Redis 5 直接 用redis-cli\n Redis version 3 or 4,\n需要\n 先安装一个Ruby环境\n 再redis-trib.rb（ruby语言开发）的工具\n   Redis version 3 or 4可参考此处\nredis5集群的安装 集群搭建参考官网\nredis集群需要至少要三个master节点,我们这里搭建三个master节点,并且给每个master再搭建一个slave节点，总共6个redis节点,这里用一台机器(可以多台机器部署,修改一下ip地址就可以了 )部署6个redis实例，三主三从，搭建集群的步骤如下:\n创建Redis节点安装目录\nmkdir -p /usr/local/redis-cluster  在redis-cluster目录下，分别创建7000-7005个文件夹\nmkdir 7000 7001 7002 7003 7004 7005  并将redis-conf拷贝到7000文件夹下\ncp /opt/redis-5.0.7/redis-conf ./7000  4.分别修改redis配置文件\n./7000/redis.conf\n#关闭保护模式用 于公网访问 protected-mode no port 7000 #开启集群模式 cluster-enabled yes cluster-config-file nodes-7000.conf cluster-node-timeout 5000 # 后台启动 daemonize yes pidfile /var/run/redis_7000.pid logfile 7000.log # 此处绑定 ip 可以是阿里内网 ip 和本地 ip 也可以直接注释掉该项 #bind127.0.0.1 # 用于连接主节点密码 masterauth fatsnake #设置redis密码各个节点请保持密码一致 requirepass fatsnake  依次修改并复制 6个redis.conf\ncp ./7000/redis.conf ./7001/ vim ./7000/redis.conf 执行 :%s/oldPort/newPort/g 全局替换端口 :wq 保存并退出 即可  依次启动6个节点\n将安装的 redis 目录下的 src 复制到 cluster文件目录下，方便启动服务端\ncd /opt/redis-5.0.7: 进入 redis 安装目录 cp -r ./src /usr/local/redid-cluster/ 将src文件复制到 redis- cluster 目录中 ./src/redis-server ./7000/redis.conf ./src/redis-server ./7001/redis.conf ./src/redis-server ./7002/redis.conf ./src/redis-server ./7003/redis.conf ./src/redis-server ./7004/redis.conf ./src/redis-server ./7005/redis.conf 启动后，可以用 PS 查看进程： ps -ef | grep redis  创建集群通信（见上文版本差异）\nredis5版本以后使用redis-cli客户端来创建集群 -a 参数为 集群密码\n./src/redis-cli --cluster create -a fatsnake 127.0.0.1:7000 127.0.0.1:7001 \\ 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \\ --cluster-replicas 1  cluster-replicas 1 代表 一个master后有几个slave，1代表为1个slave节点\n询问是否满意如此分配节点：输入yes之后，如图显示表示集群创建成功\nredis-cluster集群验证 再描述一遍集群特点\n Redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点\n 主节点提供数据存取，从节点则是从主节点拉取数据备份，从节点提供查询\n 当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉\n 集群如果有 ABC 三个主节点如果这 3 个节点都没有加入从节点，如果 B 桂掉了，我们就无法访问整个集群了。A 和C的slot（哈希槽） 也无法访问。 所以我们在集群建立的时候，一定要为每个主节点都添加了从节点，比如像这样集群包含主节点 A、B、C，以及从节点 A1、B1、C1, 那么即使 B 挂掉系统也可以继续正确工作。B1 节点替代了 B 节点，所以 Redis 集群将会选择 B1 节点作为新的主节点，集群将会继续正确地提供服务。当 B 新开启后，它就会变成 B1 的从节点。 不过需要注意，如果节点 B 和 B1 同时挂了，Redis 集群就无法继续正确地提供服务了。\n连接集群中的某个节点，验证\nredis-cli -h 127.0.0.1 -c -p 7000 -a fatsnake   参数说明：\n -h ： ip -c ： 添加此参数，可连接到集群 -a ：集群密码  redis cluster 在设计的时候，就考虑到了去中心化，去中间件，也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。毎个节点都和其他所有节点连接，而这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据\n基本命令 查看单节点状态\ninfo replication  查看集群状态 Cluster Nodes 命令 或者 Cluster Infor  说明：\nmyself 表示当前 操作节点\n唯一性节点ID说明：\n 每个 Redist 的节点都有一个 ID 值，此 ID 将被此特定 redis 实例永久使用，以便实例在集群上下文中具有唯一的名称。 每个节点都会记住使用此 ID 的每个其他节点，而不是通过 IP 或端口。 IP 地址和端口可能会发生变化，但唯一的节点标识符在节点的整个生命周期内都不会改变。我们简单地称这个标识符为节点 ID。  启动集群 // /Users/izaodao/Documents/redis-cluster目录下，自己写个启动集群脚本\n# redisAllStart.sh cd /Users/izaodao/Documents/redis-cluster ./src/redis-server ./7000/redis.conf ./src/redis-server ./7001/redis.conf ./src/redis-server ./7002/redis.conf ./src/redis-server ./7003/redis.conf ./src/redis-server ./7004/redis.conf ./src/redis-server ./7005/redis.conf  使用./src/redis-server ./7000/redis.conf命令可以将实例重新启动，启动完成之后，自动加入到集群当中\n创建集群 # createCluster.sh cd /Users/izaodao/Documents/redis-cluster ./src/redis-cli --cluster create -a fatsnake 127.0.0.1:7000 127.0.0.1:7001 \\ 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \\ --cluster-replicas 1  chmod u +x redisAllStart.sh : 将redisAllStart.sh变为可执行文件 ./redisAllStart.sh : 在当前目录下启动  关闭集群 // /Users/izaodao/Documents/redis-cluster目录下，自己写个关闭集群脚本\n# redisAllStop.sh.sh cd /Users/izaodao/Documents/redis-cluster ./src/redis-cli -c -h 127.0.0.1 -p 7000 -a fatsnake shutdown ./src/redis-cli -c -h 127.0.0.1 -p 7001 -a fatsnake shutdown ./src/redis-cli -c -h 127.0.0.1 -p 7002 -a fatsnake shutdown ./src/redis-cli -c -h 127.0.0.1 -p 7003 -a fatsnake shutdown ./src/redis-cli -c -h 127.0.0.1 -p 7004 -a fatsnake shutdown ./src/redis-cli -c -h 127.0.0.1 -p 7005 -a fatsnake shutdown  chmod u +x shutdown.sh : 将shutdown.sh变为可执行文件 ./shutdown.sh : 在当前目录下启动  说明：\n/src/redis-cli -c -h 127.0.0.1 -p 7000 -a 访问服务端密码 -c 表示集群模式 -h 指定ip 地址 -p 指定端口号\n*** 为什么不直接kill进程，因为影响redis数据持久化（aof、rdb），会丢数据 ***\n官方工具包 启动/关闭 ./redis-5.0.0/utils/create-cluster\n打开此文件修改端口为我们自己的\n集群伸缩 集群的伸缩： 如何进行给集群增加新的主从节点(集群扩容)以及如何从集群中删除节点(集群缩容)\n集群伸缩的原理是控制虚拟槽和数据在节点之间进行移动\n查看现有集群状态  登录集群节点\ncd /Users/izaodao/Documents/redis-cluster ./src/redis-cli -c -h 127.0.0.1 -p 7000 -a fatsnake  查看状态\ncluster nodes   集群为三主三从，端口号为7000、7001、7002、7003、7004、7005。\n本文中的例子：\n 新增主节点7006和从节点7007，并给7006分配4096个slots，设置7007为7006的从节点 然后再将这两个节点从集群中删除，一定要先删除主节点，再删除从节点，要不然故障转移会生效。  集群扩容 准备两个新节点\n在集群目录redis_cluster目录下增加redis7006和redis7007目录\n复制端口7000的redis.conf配置文件到redis7006和redis7007目录下，并修改配置文件中的端口为对应目录的端口号。\nmkdir redis7006 mkdir redis7007 cp ./7000/redis.conf ./7001/ vim ./7000/redis.conf 执行 :%s/oldPort/newPort/g 全局替换端口 :wq 保存并退出 即可  redis.conf 主要内容：\n#关闭保护模式用 于公网访问 protected-mode no port 7000 #开启集群模式 cluster-enabled yes cluster-config-file nodes-7000.conf cluster-node-timeout 5000 # 后台启动 daemonize yes pidfile /var/run/redis_7000.pid logfile 7000.log # 此处绑定 ip 可以是阿里内网 ip 和本地 ip 也可以直接注释掉该项 #bind127.0.0.1 # 用于连接主节点密码 masterauth fatsnake #设置redis密码各个节点请保持密码一致 requirepass fatsnake #设置节点持久化文件或是目录名，让各个节点分开：rdb文件名或者aof文件名 dbfilename dump_7000.rdb appendfilename \u0026quot;appendonly_7000.aof\u0026quot;  启动新节点\ncd /opt/redis-5.0.7 #: 进入 redis 安装目录 ./src/redis-server ./7006/redis.conf ./src/redis-server ./7007/redis.conf ps -ef | grep redis //查看新的redis节点是否启动成功  登录7006查看节点状态\n./src/redis-cli -c -h 127.0.0.1 -p 7006 -a fatsnake cluster nodes  只有节点自己孤独的自己\n添加节点\n（1）向集群中添加节点7006，注意一定要保证节点里面没有添加过任何数据，不然添加会报错。 添加 主节点 7006\ncd /usr/local/redis/redis/src redis-cli --cluster add-node -a fatsnake 127.0.0.1:7006 127.0.0.1:7000 //第一次节点为新增的节点 第二个节点为集群中的节点 -a 参数节点登录密码,没有请忽略  重新分配(迁移)哈希槽slot\nredis-cli --cluster reshard -a fatsnake 127.0.0.1:7000  (3) 添加新增节点的从节点\nredis-cli --cluster add-node -a fatsnake 127.0.0.1:7007 127.0.0.1:7000 --cluster-slave --cluster-master-id c2c7fed1eb89e1ecba3ceb8dc1098e0b796d0eb5  把节点7007节点加入到集群，并且是以从节点的形式存在，并且指定masterid为节点7006\n添加接电视遇到问题\n添加节点时对哈希槽检查报错处理：\n集群缩容 需要注意\n如果你要下线一对主从节点，请务必贤下线从节点（7007），并且讲主节点（7006）的slot的迁移到其他节点 如果先下线主节点（7006），会发生故障切换，原从节点（7007）会变为主节点\n删除从节点\nredis-cli --cluster del-node -a fatsnake 127.0.0.1:7007 7007节点id  删除主节点 将主节点7006的slots分配到其他主节点上\nredis-cli --cluster reshard -a fatsnake 127.0.0.1:7006  输入yes,表示接受这个计划，然后回车，完成7006节点的槽的移除。\n登录集群查看当前集群情况：\n节点7006上没有任何槽。\n使用del-node命令来删除7006主节点。\nredis-cli --cluster del-node -a fatsnake 127.0.0.1:7006 7006节点id  删除成功\n集群演变 单机版 核心技术：持久化\n持久化是最简单的高可用方法（有时甚至不被归为高可用的手段），主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。\n复制 复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷是故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。\n哨兵 在复制的基础上，哨兵实现了自动化的故障恢复。缺陷是写操作无法负载均衡；存储能力受到单机的限制。\n集群 通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案\nRedis集群相对单机在功能上存在一些限制，需要开发人员提前了解，\n在使用时做好规避。限制如下:\n1)、key批量操作支持有限。如mset、mget，目前只支持具有相同slot值的 key执行批量操作。对于映射为不同slot值的key由于执行mget、mget等操作可 能存在于多个节点上因此不被支持。\n2)、key事务操作支持有限。同理只支持多key在同一节点上的事务操 作，当多个key分布在不同的节点上时无法使用事务功能。\n3)、key作为数据分区的最小粒度，因此不能将一个大的键值对象如 hash、list等映射到不同的节点。\n4)、不支持多数据库空间。单机下的Redis可以支持16个数据库，集群模 式下只能使用一个数据库空间，即db0。\n5)、复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复 制结构。\n","id":15,"section":"posts","summary":"Redis Redis 是完全开源免费的，遵守BSD协议，是一个高性能的（noSQL）key-value数据库 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支","tags":["中间件"],"title":"Redis笔记","uri":"https://mumulx.github.io/2020/02/redis%E7%AC%94%E8%AE%B0/","year":"2020"},{"content":" [源码]()\nJPA 简介 JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。\nSun引入新的JPA ORM规范出于两个原因：其一，简化现有Java EE和Java SE应用开发工作；其二，Sun希望整合ORM技术，实现天下归一。\n回顾JDBC orm思想 ​ 主要目的：操作实体类就相当于操作数据库表\n​ 建立两个映射关系：\n​ 1)、实体类和表的映射关系\n​ 1）、实体类中属性和表中字段的映射关系\n​ 不再重点关注：sql语句 ​\n实现了ORM思想的框架：mybatis，hibernate\nhibernate框架介绍 ​ Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架\nJPA规范 ​ jpa规范，实现jpa规范，内部是由接口和抽象类组成\njpa的基本操作 ​ 案例：是客户的相关操作（增删改查）\n​ 客户表： ​\n/*创建客户表*/ CREATE TABLE cst_customer ( cust_id bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', cust_name varchar(32) NOT NULL COMMENT '客户名称(公司名称)', cust_source varchar(32) DEFAULT NULL COMMENT '客户信息来源', cust_industry varchar(32) DEFAULT NULL COMMENT '客户所属行业', cust_level varchar(32) DEFAULT NULL COMMENT '客户级别', cust_address varchar(128) DEFAULT NULL COMMENT '客户联系地址', cust_phone varchar(64) DEFAULT NULL COMMENT '客户联系电话', PRIMARY KEY (`cust_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;  搭建环境的过程 1）、创建maven工程导入坐标\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;cn.itcast\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jpa-day1\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.hibernate.version\u0026gt;5.0.7.Final\u0026lt;/project.hibernate.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- hibernate对jpa的支持包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-entitymanager\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.hibernate.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- c3p0 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-c3p0\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.hibernate.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- log日志 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Mysql and MariaDB --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt;  2）、需要配置jpa的核心配置文件\n 位置：配置到类路径下的一个叫做 META-INF 的文件夹下\n 命名：persistence.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;persistence xmlns=\u0026quot;http://java.sun.com/xml/ns/persistence\u0026quot; version=\u0026quot;2.0\u0026quot;\u0026gt; \u0026lt;!--需要配置persistence-unit节点 持久化单元： name：持久化单元名称 transaction-type：事务管理的方式 JTA：分布式事务管理 RESOURCE_LOCAL：本地事务管理 --\u0026gt; \u0026lt;persistence-unit name=\u0026quot;myJpa\u0026quot; transaction-type=\u0026quot;RESOURCE_LOCAL\u0026quot;\u0026gt; \u0026lt;!--jpa的实现方式 --\u0026gt; \u0026lt;provider\u0026gt;org.hibernate.jpa.HibernatePersistenceProvider\u0026lt;/provider\u0026gt; \u0026lt;!--可选配置：配置jpa实现方的配置信息--\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 数据库信息 用户名，javax.persistence.jdbc.user 密码， javax.persistence.jdbc.password 驱动， javax.persistence.jdbc.driver 数据库地址 javax.persistence.jdbc.url --\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.user\u0026quot; value=\u0026quot;root\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.password\u0026quot; value=\u0026quot;root\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.driver\u0026quot; value=\u0026quot;com.mysql.jdbc.Driver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.url\u0026quot; value=\u0026quot;jdbc:mysql:///jpa\u0026quot;/\u0026gt; \u0026lt;!--配置jpa实现方(hibernate)的配置信息 显示sql ： false|true 自动创建数据库表 ： hibernate.hbm2ddl.auto create : 程序运行时创建数据库表（如果有表，先删除表再创建） update ：程序运行时创建表（如果有表，不会创建表） none ：不会创建表 --\u0026gt; \u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;update\u0026quot; /\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/persistence-unit\u0026gt; \u0026lt;/persistence\u0026gt;   3）、编写客户的实体类\n4）、配置实体类和表，类中属性和表中字段的映射关系\n/** * 客户的实体类 * 配置映射关系 * 1.实体类和表的映射关系 * @Entity:声明实体类 * @Table : 配置实体类和表的映射关系 * name : 配置数据库表的名称 * 2.实体类中属性和表中字段的映射关系 */ @Entity @Table(name = \u0026quot;cst_customer\u0026quot;) public class Customer { /** * @Id：声明主键的配置 * @GeneratedValue:配置主键的生成策略 * strategy * GenerationType.IDENTITY ：自增，mysql * * 底层数据库必须支持自动增长（底层数据库支持的自动增长方式，对id自增） * GenerationType.SEQUENCE : 序列，oracle * * 底层数据库必须支持序列 * GenerationType.TABLE : jpa提供的一种机制，通过一张数据库表的形式帮助我们完成主键自增 * GenerationType.AUTO ： 由程序自动的帮助我们选择主键生成策略 * @Column:配置属性和字段的映射关系 * name：数据库表中字段的名称 */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \u0026quot;cust_id\u0026quot;) private Long custId; //客户的主键 @Column(name = \u0026quot;cust_name\u0026quot;) private String custName;//客户名称 @Column(name=\u0026quot;cust_source\u0026quot;) private String custSource;//客户来源 @Column(name=\u0026quot;cust_level\u0026quot;) private String custLevel;//客户级别 @Column(name=\u0026quot;cust_industry\u0026quot;) private String custIndustry;//客户所属行业 @Column(name=\u0026quot;cust_phone\u0026quot;) private String custPhone;//客户的联系方式 @Column(name=\u0026quot;cust_address\u0026quot;) private String custAddress;//客户地址 public Long getCustId() { return custId; } public void setCustId(Long custId) { this.custId = custId; } public String getCustName() { return custName; } public void setCustName(String custName) { this.custName = custName; } public String getCustSource() { return custSource; } public void setCustSource(String custSource) { this.custSource = custSource; } public String getCustLevel() { return custLevel; } public void setCustLevel(String custLevel) { this.custLevel = custLevel; } public String getCustIndustry() { return custIndustry; } public void setCustIndustry(String custIndustry) { this.custIndustry = custIndustry; } public String getCustPhone() { return custPhone; } public void setCustPhone(String custPhone) { this.custPhone = custPhone; } public String getCustAddress() { return custAddress; } public void setCustAddress(String custAddress) { this.custAddress = custAddress; } @Override public String toString() { return \u0026quot;Customer{\u0026quot; + \u0026quot;custId=\u0026quot; + custId + \u0026quot;, custName='\u0026quot; + custName + '\\'' + \u0026quot;, custSource='\u0026quot; + custSource + '\\'' + \u0026quot;, custLevel='\u0026quot; + custLevel + '\\'' + \u0026quot;, custIndustry='\u0026quot; + custIndustry + '\\'' + \u0026quot;, custPhone='\u0026quot; + custPhone + '\\'' + \u0026quot;, custAddress='\u0026quot; + custAddress + '\\'' + '}'; } }  操作 Jpa的操作步骤\n 加载配置文件创建工厂（实体管理器工厂）对象\n 通过实体管理器工厂获取实体管理器\n 获取事务对象，开启事务\n 完成增删改查操作\n 提交事务（回滚事务）\n 释放资源\n  增加 /** * 测试jpa的保存 * 案例：保存一个客户到数据库中 */ @Test public void testSave() { // //1.加载配置文件创建工厂（实体管理器工厂）对象 // EntityManagerFactory factory = Persistence.createEntityManagerFactory(\u0026quot;myJpa\u0026quot;); // //2.通过实体管理器工厂获取实体管理器 // EntityManager em = factory.createEntityManager(); EntityManager em = JpaUtils.getEntityManager(); //3.获取事务对象，开启事务 EntityTransaction tx = em.getTransaction(); //获取事务对象 tx.begin();//开启事务 //4.完成增删改查操作：保存一个客户到数据库中 Customer customer = new Customer(); customer.setCustName(\u0026quot;xxx\u0026quot;); customer.setCustIndustry(\u0026quot;zzz\u0026quot;); //保存， em.persist(customer); //保存操作 //5.提交事务 tx.commit(); //6.释放资源 em.close(); // factory.close(); }  查询 /** * 根据id查询客户 * 使用find方法查询： * 1.查询的对象就是当前客户对象本身 * 2.在调用find方法的时候，就会发送sql语句查询数据库 * 立即加载 */ @Test public void testFind() { //1.通过工具类获取entityManager EntityManager entityManager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = entityManager.getTransaction(); tx.begin(); //3.增删改查 -- 根据id查询客户 /** * find : 根据id查询数据 * class：查询数据的结果需要包装的实体类类型的字节码 * id：查询的主键的取值 */ Customer customer = entityManager.find(Customer.class, 1l); // System.out.print(customer); //4.提交事务 tx.commit(); //5.释放资源 entityManager.close(); } /** * 根据id查询客户 * getReference方法 * 1.获取的对象是一个动态代理对象 * 2.调用getReference方法不会立即发送sql语句查询数据库 * * 当调用查询结果对象的时候，才会发送查询的sql语句：什么时候用，什么时候发送sql语句查询数据库 * 延迟加载（懒加载） * * 得到的是一个动态代理对象 * * 什么时候用，什么使用才会查询 */ @Test public void testReference() { //1.通过工具类获取entityManager EntityManager entityManager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = entityManager.getTransaction(); tx.begin(); //3.增删改查 -- 根据id查询客户 /** * getReference : 根据id查询数据 * class：查询数据的结果需要包装的实体类类型的字节码 * id：查询的主键的取值 */ Customer customer = entityManager.getReference(Customer.class, 1l); System.out.print(customer); //4.提交事务 tx.commit(); //5.释放资源 entityManager.close(); }  删除 /** * 删除客户的案例 */ @Test public void testRemove() { //1.通过工具类获取entityManager EntityManager entityManager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = entityManager.getTransaction(); tx.begin(); //3.增删改查 -- 删除客户 //i 根据id查询客户 Customer customer = entityManager.find(Customer.class,1l); //ii 调用remove方法完成删除操作 entityManager.remove(customer); //4.提交事务 tx.commit(); //5.释放资源 entityManager.close(); }  更新 /** * 更新客户的操作 * merge(Object) */ @Test public void testUpdate() { //1.通过工具类获取entityManager EntityManager entityManager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = entityManager.getTransaction(); tx.begin(); //3.增删改查 -- 更新操作 //i 查询客户 Customer customer = entityManager.find(Customer.class,1l); //ii 更新客户 customer.setCustIndustry(\u0026quot;it教育\u0026quot;); entityManager.merge(customer); //4.提交事务 tx.commit(); //5.释放资源 entityManager.close(); }  jpa操作的操作步骤 1)、加载配置文件创建实体管理器工厂\nPersisitence：静态方法（根据持久化单元名称创建实体管理器工厂）\ncreateEntityMnagerFactory（持久化单元名称）\n作用：创建实体管理器工厂\n2）、根据实体管理器工厂，创建实体管理器\nEntityManagerFactory ：获取EntityManager对象\n方法：createEntityManager\n内部维护的很多的内容\n 内部维护了数据库信息，\n 维护了缓存信息\n 维护了所有的实体管理器对象\n 再创建EntityManagerFactory的过程中会根据配置创建数据库表\n  EntityManagerFactory的创建过程比较浪费资源\n特点：线程安全的对象\n多个线程访问同一个EntityManagerFactory不会有线程安全问题\n如何解决EntityManagerFactory的创建过程浪费资源（耗时）的问题？\n思路：创建一个公共的EntityManagerFactory的对象\n静态代码块的形式创建EntityManagerFactory\n3)、创建事务对象，开启事务 EntityManager对象：实体类管理器\n beginTransaction : 创建事务对象 presist ： 保存 merge ： 更新 remove ： 删除 find/getRefrence ： 根据id查询  Transaction 对象 ： 事务\nbegin：开启事务 commit：提交事务 rollback：回滚  创建一个工具类\n/** * 解决实体管理器工厂的浪费资源和耗时问题 * 通过静态代码块的形式，当程序第一次访问此工具类时，创建一个公共的实体管理器工厂对象 * * 第一次访问getEntityManager方法：经过静态代码块创建一个factory对象，再调用方法创建一个EntityManager对象 * 第二次方法getEntityManager方法：直接通过一个已经创建好的factory对象，创建EntityManager对象 */ public class JpaUtils { private static EntityManagerFactory factory; static { //1.加载配置文件，创建entityManagerFactory factory = Persistence.createEntityManagerFactory(\u0026quot;myJpa\u0026quot;); } /** * 获取EntityManager对象 */ public static EntityManager getEntityManager() { return factory.createEntityManager(); } }  4）、增删改查操作\n5）、提交事务\n6）、释放资源\njpql查询  sql：查询的是表和表中的字段\n jpql：查询的是实体类和类中的属性\n  jpql和sql语句的语法相似\n 查询全部 分页查询 统计查询 条件查询 排序  查询全部 /** * 查询全部 * jqpl：from cn.itcast.domain.Customer * sql：SELECT * FROM cst_customer */ @Test public void testFindAll() { //1.获取entityManager对象 EntityManager em = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.查询全部 String jpql = \u0026quot;from Customer \u0026quot;; Query query = em.createQuery(jpql);//创建Query查询对象，query对象才是执行jqpl的对象 //发送查询，并封装结果集 List list = query.getResultList(); for (Object obj : list) { System.out.print(obj); } //4.提交事务 tx.commit(); //5.释放资源 em.close(); }  排序查询 /** * 排序查询： 倒序查询全部客户（根据id倒序） * sql：SELECT * FROM cst_customer ORDER BY cust_id DESC * jpql：from Customer order by custId desc * * 进行jpql查询 * 1.创建query查询对象 * 2.对参数进行赋值 * 3.查询，并得到返回结果 */ @Test public void testOrders() { //1.获取entityManager对象 EntityManager em = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.查询全部 String jpql = \u0026quot;from Customer order by custId desc\u0026quot;; Query query = em.createQuery(jpql);//创建Query查询对象，query对象才是执行jqpl的对象 //发送查询，并封装结果集 List list = query.getResultList(); for (Object obj : list) { System.out.println(obj); } //4.提交事务 tx.commit(); //5.释放资源 em.close(); }  总数 /** * 使用jpql查询，统计客户的总数 * sql：SELECT COUNT(cust_id) FROM cst_customer * jpql：select count(custId) from Customer */ @Test public void testCount() { //1.获取entityManager对象 EntityManager em = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.查询全部 //i.根据jpql语句创建Query查询对象 String jpql = \u0026quot;select count(custId) from Customer\u0026quot;; Query query = em.createQuery(jpql); //ii.对参数赋值 //iii.发送查询，并封装结果 /** * getResultList ： 直接将查询结果封装为list集合 * getSingleResult : 得到唯一的结果集 */ Object result = query.getSingleResult(); System.out.println(result); //4.提交事务 tx.commit(); //5.释放资源 em.close(); }  分页查询 /** * 分页查询 * sql：select * from cst_customer limit 0,2 * jqpl : from Customer */ @Test public void testPaged() { //1.获取entityManager对象 EntityManager em = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.查询全部 //i.根据jpql语句创建Query查询对象 String jpql = \u0026quot;from Customer\u0026quot;; Query query = em.createQuery(jpql); //ii.对参数赋值 -- 分页参数 //起始索引 query.setFirstResult(0); //每页查询的条数 query.setMaxResults(2); //iii.发送查询，并封装结果 /** * getResultList ： 直接将查询结果封装为list集合 * getSingleResult : 得到唯一的结果集 */ List list = query.getResultList(); for(Object obj : list) { System.out.println(obj); } //4.提交事务 tx.commit(); //5.释放资源 em.close(); }  条件查询 /** * 条件查询 * 案例：查询客户名称以‘xxx’开头的客户 * sql：SELECT * FROM cst_customer WHERE cust_name LIKE ? * jpql : from Customer where custName like ? */ @Test public void testCondition() { //1.获取entityManager对象 EntityManager em = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.查询全部 //i.根据jpql语句创建Query查询对象 String jpql = \u0026quot;from Customer where custName like ? \u0026quot;; Query query = em.createQuery(jpql); //ii.对参数赋值 -- 占位符参数 //第一个参数：占位符的索引位置（从1开始），第二个参数：取值 query.setParameter(1,\u0026quot;xxx%\u0026quot;); //iii.发送查询，并封装结果 /** * getResultList ： 直接将查询结果封装为list集合 * getSingleResult : 得到唯一的结果集 */ List list = query.getResultList(); for(Object obj : list) { System.out.println(obj); } //4.提交事务 tx.commit(); //5.释放资源 em.close(); }  springDataJPA 简介 Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据库的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！\nSpring Data JPA 让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现,在实际的工作工程中，推荐使用Spring Data JPA + ORM（如：hibernate）完成操作，这样在切换不同的ORM框架时提供了极大的方便，同时也使数据库层操作更加简单，方便解耦\nSpringData Jpa 极大简化了数据库访问层代码。 如何简化的呢？ 使用了SpringDataJpa，我们的dao层中只需要写接口，就自动具有了增删改查、分页查询等方法。\nspringDataJPA和JPA和Hibernate之间的关系\nspringDataJPA只是将JPA规范的代码给封装起来了，底层使用的还是Hibernate进行操作的。\nJPA是一套规范，内部是有接口和抽象类组成的。hibernate是一套成熟的ORM框架，而且Hibernate实现了JPA规范，所以也可以称hibernate为JPA的一种实现方式，我们使用JPA的API编程，意味着站在更高的角度上看待问题（面向接口编程）\nSpring Data JPA是Spring提供的一套对JPA操作更加高级的封装，是在JPA规范下的专门用来进行数据持久化的解决方案。\n搭建环境 1)、创建工程导入坐标\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;cn.itcast\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jpa-day2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;spring.version\u0026gt;5.0.2.RELEASE\u0026lt;/spring.version\u0026gt; \u0026lt;hibernate.version\u0026gt;5.0.7.Final\u0026lt;/hibernate.version\u0026gt; \u0026lt;slf4j.version\u0026gt;1.6.6\u0026lt;/slf4j.version\u0026gt; \u0026lt;log4j.version\u0026gt;1.2.12\u0026lt;/log4j.version\u0026gt; \u0026lt;c3p0.version\u0026gt;0.9.1.2\u0026lt;/c3p0.version\u0026gt; \u0026lt;mysql.version\u0026gt;5.1.6\u0026lt;/mysql.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- junit单元测试 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spring beg --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.6.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-aop\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context-support\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spring对orm框架的支持包--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-orm\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-beans\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spring end --\u0026gt; \u0026lt;!-- hibernate beg --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${hibernate.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-entitymanager\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${hibernate.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-validator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.1.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- hibernate end --\u0026gt; \u0026lt;!-- c3p0 beg --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;c3p0\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;c3p0\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${c3p0.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- c3p0 end --\u0026gt; \u0026lt;!-- log end --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${log4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${slf4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-log4j12\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${slf4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- log end --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mysql.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spring data jpa 的坐标--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.data\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- el beg 使用spring data jpa 必须引入 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.el\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.el-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.glassfish.web\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.el\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- el end --\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt;  2）、配置spring的配置文件（配置spring Data jpa的整合）\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns:aop=\u0026quot;http://www.springframework.org/schema/aop\u0026quot; xmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot; xmlns:jdbc=\u0026quot;http://www.springframework.org/schema/jdbc\u0026quot; xmlns:tx=\u0026quot;http://www.springframework.org/schema/tx\u0026quot; xmlns:jpa=\u0026quot;http://www.springframework.org/schema/data/jpa\u0026quot; xmlns:task=\u0026quot;http://www.springframework.org/schema/task\u0026quot; xsi:schemaLocation=\u0026quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\u0026quot;\u0026gt; \u0026lt;!--spring 和 spring data jpa的配置--\u0026gt; \u0026lt;!-- 1.创建entityManagerFactory对象交给spring容器管理--\u0026gt; \u0026lt;bean id=\u0026quot;entityManagerFactoty\u0026quot; class=\u0026quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot; /\u0026gt; \u0026lt;!--配置的扫描的包（实体类所在的包） --\u0026gt; \u0026lt;property name=\u0026quot;packagesToScan\u0026quot; value=\u0026quot;cn.itcast.domain\u0026quot; /\u0026gt; \u0026lt;!-- jpa的实现厂家 --\u0026gt; \u0026lt;property name=\u0026quot;persistenceProvider\u0026quot;\u0026gt; \u0026lt;bean class=\u0026quot;org.hibernate.jpa.HibernatePersistenceProvider\u0026quot;/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--jpa的供应商适配器 --\u0026gt; \u0026lt;property name=\u0026quot;jpaVendorAdapter\u0026quot;\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter\u0026quot;\u0026gt; \u0026lt;!--配置是否自动创建数据库表 --\u0026gt; \u0026lt;property name=\u0026quot;generateDdl\u0026quot; value=\u0026quot;false\u0026quot; /\u0026gt; \u0026lt;!--指定数据库类型 --\u0026gt; \u0026lt;property name=\u0026quot;database\u0026quot; value=\u0026quot;MYSQL\u0026quot; /\u0026gt; \u0026lt;!--数据库方言：支持的特有语法 --\u0026gt; \u0026lt;property name=\u0026quot;databasePlatform\u0026quot; value=\u0026quot;org.hibernate.dialect.MySQLDialect\u0026quot; /\u0026gt; \u0026lt;!--是否显示sql --\u0026gt; \u0026lt;property name=\u0026quot;showSql\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--jpa的方言 ：高级的特性 --\u0026gt; \u0026lt;property name=\u0026quot;jpaDialect\u0026quot; \u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.orm.jpa.vendor.HibernateJpaDialect\u0026quot; /\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--2.创建数据库连接池 --\u0026gt; \u0026lt;bean id=\u0026quot;dataSource\u0026quot; class=\u0026quot;com.mchange.v2.c3p0.ComboPooledDataSource\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;user\u0026quot; value=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;111111\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jdbcUrl\u0026quot; value=\u0026quot;jdbc:mysql:///jpa\u0026quot; \u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;driverClass\u0026quot; value=\u0026quot;com.mysql.jdbc.Driver\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--3.整合spring dataJpa--\u0026gt; \u0026lt;jpa:repositories base-package=\u0026quot;cn.itcast.dao\u0026quot; transaction-manager-ref=\u0026quot;transactionManager\u0026quot; entity-manager-factory-ref=\u0026quot;entityManagerFactoty\u0026quot; \u0026gt;\u0026lt;/jpa:repositories\u0026gt; \u0026lt;!--4.配置事务管理器 --\u0026gt; \u0026lt;bean id=\u0026quot;transactionManager\u0026quot; class=\u0026quot;org.springframework.orm.jpa.JpaTransactionManager\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;entityManagerFactory\u0026quot; ref=\u0026quot;entityManagerFactoty\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 4.txAdvice--\u0026gt; \u0026lt;tx:advice id=\u0026quot;txAdvice\u0026quot; transaction-manager=\u0026quot;transactionManager\u0026quot;\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;tx:method name=\u0026quot;save*\u0026quot; propagation=\u0026quot;REQUIRED\u0026quot;/\u0026gt; \u0026lt;tx:method name=\u0026quot;insert*\u0026quot; propagation=\u0026quot;REQUIRED\u0026quot;/\u0026gt; \u0026lt;tx:method name=\u0026quot;update*\u0026quot; propagation=\u0026quot;REQUIRED\u0026quot;/\u0026gt; \u0026lt;tx:method name=\u0026quot;delete*\u0026quot; propagation=\u0026quot;REQUIRED\u0026quot;/\u0026gt; \u0026lt;tx:method name=\u0026quot;get*\u0026quot; read-only=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;tx:method name=\u0026quot;find*\u0026quot; read-only=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;tx:method name=\u0026quot;*\u0026quot; propagation=\u0026quot;REQUIRED\u0026quot;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; \u0026lt;!-- 5.aop--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026quot;pointcut\u0026quot; expression=\u0026quot;execution(* cn.itcast.service.*.*(..))\u0026quot; /\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026quot;txAdvice\u0026quot; pointcut-ref=\u0026quot;pointcut\u0026quot; /\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;!--5.声明式事务 --\u0026gt; \u0026lt;!-- 6. 配置包扫描--\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;cn.itcast\u0026quot; \u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;/beans\u0026gt;  3）、编写实体类（Customer），使用jpa注解配置映射关系\n/** * 1.实体类和表的映射关系 * @Eitity * @Table * 2.类中属性和表中字段的映射关系 * @Id * @GeneratedValue * @Column */ @Entity @Table(name=\u0026quot;cst_customer\u0026quot;) public class Customer { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name=\u0026quot;cust_id\u0026quot;) private Long custId; @Column(name=\u0026quot;cust_address\u0026quot;) private String custAddress; @Column(name=\u0026quot;cust_industry\u0026quot;) private String custIndustry; @Column(name=\u0026quot;cust_level\u0026quot;) private String custLevel; @Column(name=\u0026quot;cust_name\u0026quot;) private String custName; @Column(name=\u0026quot;cust_phone\u0026quot;) private String custPhone; @Column(name=\u0026quot;cust_source\u0026quot;) private String custSource; public Long getCustId() { return custId; } public void setCustId(Long custId) { this.custId = custId; } public String getCustAddress() { return custAddress; } public void setCustAddress(String custAddress) { this.custAddress = custAddress; } public String getCustIndustry() { return custIndustry; } public void setCustIndustry(String custIndustry) { this.custIndustry = custIndustry; } public String getCustLevel() { return custLevel; } public void setCustLevel(String custLevel) { this.custLevel = custLevel; } public String getCustName() { return custName; } public void setCustName(String custName) { this.custName = custName; } public String getCustPhone() { return custPhone; } public void setCustPhone(String custPhone) { this.custPhone = custPhone; } public String getCustSource() { return custSource; } public void setCustSource(String custSource) { this.custSource = custSource; } @Override public String toString() { return \u0026quot;Customer{\u0026quot; + \u0026quot;custId=\u0026quot; + custId + \u0026quot;, custAddress='\u0026quot; + custAddress + '\\'' + \u0026quot;, custIndustry='\u0026quot; + custIndustry + '\\'' + \u0026quot;, custLevel='\u0026quot; + custLevel + '\\'' + \u0026quot;, custName='\u0026quot; + custName + '\\'' + \u0026quot;, custPhone='\u0026quot; + custPhone + '\\'' + \u0026quot;, custSource='\u0026quot; + custSource + '\\'' + '}'; } }  操作 dao层接口 编写一个符合springDataJpa的dao层接口\n 只需要编写dao层接口，不需要编写dao层接口的实现类\n dao层接口规范\n 需要继承两个接口（JpaRepository，JpaSpecificationExecutor） 需要提供响应的泛型\n/** * 符合SpringDataJpa的dao层接口规范 * JpaRepository\u0026lt;操作的实体类类型，实体类中主键属性的类型\u0026gt; * * 封装了基本CRUD操作 * JpaSpecificationExecutor\u0026lt;操作的实体类类型\u0026gt; * * 封装了复杂查询（分页） */ public interface CustomerDao extends JpaRepository\u0026lt;Customer,Long\u0026gt; ,JpaSpecificationExecutor\u0026lt;Customer\u0026gt; { }    创建测试类 @RunWith(SpringJUnit4ClassRunner.class) //声明spring提供的单元测试环境 @ContextConfiguration(locations = \u0026quot;classpath:applicationContext.xml\u0026quot;)//指定spring容器的配置信息 public class CustomerDaoTest { }  查询 /** * 根据id查询 */ @Test public void testFindOne() { Customer customer = customerDao.findOne(4l); System.out.println(customer); } /** * 根据id从数据库查询 * @Transactional : 保证getOne正常运行 * * findOne： * em.find() :立即加载 * getOne： * em.getReference :延迟加载 * * 返回的是一个客户的动态代理对象 * * 什么时候用，什么时候查询 */ @Test @Transactional public void testGetOne() { Customer customer = customerDao.getOne(4l); System.out.println(customer); }  增加 /** * save : 保存或者更新 * 根据传递的对象是否存在主键id， * 如果没有id主键属性：保存 * 存在id主键属性，根据id查询数据，更新数据 */ @Test public void testSave() { Customer customer = new Customer(); customer.setCustName(\u0026quot;xxx\u0026quot;); customer.setCustLevel(\u0026quot;vip\u0026quot;); customer.setCustIndustry(\u0026quot;it教育\u0026quot;); customerDao.save(customer); }  更新 @Test public void testUpdate() { Customer customer = new Customer(); customer.setCustId(4l); customer.setCustName(\u0026quot;xxx\u0026quot;); customerDao.save(customer); }  删除 @Test public void testDelete () { customerDao.delete(3l); }  查询全部 /** * 查询所有 */ @Test public void testFindAll() { List\u0026lt;Customer\u0026gt; list = customerDao.findAll(); for(Customer customer : list) { System.out.println(customer); } }  查询总数 /** * 测试统计查询：查询客户的总数量 * count:统计总条数 */ @Test public void testCount() { long count = customerDao.count();//查询全部的客户数量 System.out.println(count); }  是否存在 /** * 测试：判断id为4的客户是否存在 * 1. 可以查询以下id为4的客户 * 如果值为空，代表不存在，如果不为空，代表存在 * 2. 判断数据库中id为4的客户的数量 * 如果数量为0，代表不存在，如果大于0，代表存在 */ @Test public void testExists() { boolean exists = customerDao.exists(4l); System.out.println(\u0026quot;id为4的客户 是否存在：\u0026quot;+exists); }  简单的增删改查dao接口只需要JpaRepository\u0026lt;Customer,Long\u0026gt; ,JpaSpecificationExecutor\u0026lt;Customer\u0026gt; 即可\n接口真正发挥作用:接口的实现类\n在程序执行的过程中,自动的帮助我们动态的生成了接口的实现类对象\n如何动态的生成实现类对象?\n动态代理(生成基于接口的实现类对象)\nspringDataJpa的运行过程和原理剖析 1. 通过JdkDynamicAopProxy的invoke方法创建了一个动态代理对象 2. SimpleJpaRepository当中封装了JPA的操作（借助JPA的api完成数据库的CRUD） 3. 通过hibernate完成数据库操作（封装了jdbc）  复杂查询 借助接口中的定义好的方法完成查询 如上面的增删改查\njpql的查询方式 jpql ： jpa query language （jpq查询语言）\n特点：语法或关键字和sql语句类似；查询的是类和类中的属性\n需要将JPQL语句配置到接口方法上\n 特有的查询：需要在dao接口上配置方法 在新添加的方法上，使用注解的形式配置jpql查询语句 注解 ： @Query  查询 /** * 案例：根据客户名称查询客户 * 使用jpql的形式查询 * jpql：from Customer where custName = ? * * 配置jpql语句，使用的@Query注解 */ @Query(value=\u0026quot;from Customer where custName = ?\u0026quot;) public Customer findJpql(String custName);  @Test public void testFindJPQL() { Customer customer = customerDao.findJpql(\u0026quot;xxx\u0026quot;); System.out.println(customer); }  多条件查询 /** * 案例：根据客户名称和客户id查询客户 * jpql： from Customer where custName = ? and custId = ? * * 对于多个占位符参数 * 赋值的时候，默认的情况下，占位符的位置需要和方法参数中的位置保持一致 * * 可以指定占位符参数的位置 * ? 索引的方式，指定此占位的取值来源 */ @Query(value = \u0026quot;from Customer where custName = ?2 and custId = ?1\u0026quot;) public Customer findCustNameAndId(Long id,String name);  @Test public void testFindCustNameAndId() { // Customer customer = customerDao.findCustNameAndId(\u0026quot;xxx\u0026quot;,1l); Customer customer = customerDao.findCustNameAndId(1l,\u0026quot;xxx\u0026quot;); System.out.println(customer); }  更新 /** * 使用jpql完成更新操作 * 案例 ： 根据id更新，客户的名称 * 更新4号客户的名称，将名称改为“黑马程序员” * * sql ：update cst_customer set cust_name = ? where cust_id = ? * jpql : update Customer set custName = ? where custId = ? * * @Query : 代表的是进行查询 * * 声明此方法是用来进行更新操作 * @Modifying * * 当前执行的是一个更新操作 * */ @Query(value = \u0026quot; update Customer set custName = ?2 where custId = ?1 \u0026quot;) @Modifying public void updateCustomer(long custId,String custName);  /** * 测试jpql的更新操作 * * springDataJpa中使用jpql完成 更新/删除操作 * * 需要手动添加事务的支持 * * 默认会执行结束之后，回滚事务 * @Rollback : 设置是否自动回滚 * false | true */ @Test @Transactional //添加事务的支持 @Rollback(value = false) public void testUpdateCustomer() { customerDao.updateCustomer(4l,\u0026quot;黑马程序员\u0026quot;); }  sql查询 /** * 使用sql的形式查询： * 查询全部的客户 * sql ： select * from cst_customer; * Query : 配置sql查询 * value ： sql语句 * nativeQuery ： 查询方式 * true ： sql查询 * false：jpql查询 * */ //@Query(value = \u0026quot; select * from cst_customer\u0026quot; ,nativeQuery = true) @Query(value=\u0026quot;select * from cst_customer where cust_name like ?1\u0026quot;,nativeQuery = true) public List\u0026lt;Object [] \u0026gt; findSql(String name);  //测试sql查询 @Test public void testFindSql() { List\u0026lt;Object[]\u0026gt; list = customerDao.findSql(\u0026quot;xx%\u0026quot;); for(Object [] obj : list) { System.out.println(Arrays.toString(obj)); } }  命名规则的查询 /** * 方法名的约定： * findBy : 查询 * 对象中的属性名（首字母大写） ： 查询的条件 * CustName * * 默认情况 ： 使用 等于的方式查询 * 特殊的查询方式 * * findByCustName -- 根据客户名称查询 * * 再springdataJpa的运行阶段 * 会根据方法名称进行解析 findBy from xxx(实体类) * 属性名称 where custName = * * 1.findBy + 属性名称 （根据属性名称进行完成匹配的查询=） * 2.findBy + 属性名称 + “查询方式（Like | isnull）” * findByCustNameLike * 3.多条件查询 * findBy + 属性名 + “查询方式” + “多条件的连接符（and|or）” + 属性名 + “查询方式” */ public Customer findByCustName(String custName); public List\u0026lt;Customer\u0026gt; findByCustNameLike(String custName); //使用客户名称模糊匹配和客户所属行业精准匹配的查询 public Customer findByCustNameLikeAndCustIndustry(String custName,String custIndustry);  //测试方法命名规则的查询 @Test public void testNaming() { Customer customer = customerDao.findByCustName(\u0026quot;xxx\u0026quot;); System.out.println(customer); } //测试方法命名规则的查询 @Test public void testFindByCustNameLike() { List\u0026lt;Customer\u0026gt; list = customerDao.findByCustNameLike(\u0026quot;xxx%\u0026quot;); for (Customer customer : list) { System.out.println(customer); } } //测试方法命名规则的查询 @Test public void testFindByCustNameLikeAndCustIndustry() { Customer customer = customerDao.findByCustNameLikeAndCustIndustry(\u0026quot;xxx%\u0026quot;, \u0026quot;yy\u0026quot;); System.out.println(customer); }  Specifications动态查询 方法列表 JpaSpecificationExecutor 方法列表\nT findOne(Specification\u0026lt;T\u0026gt; spec); //查询单个对象 List\u0026lt;T\u0026gt; findAll(Specification\u0026lt;T\u0026gt; spec); //查询列表 //查询全部，分页 //pageable：分页参数 //返回值：分页pageBean（page：是springdatajpa提供的） Page\u0026lt;T\u0026gt; findAll(Specification\u0026lt;T\u0026gt; spec, Pageable pageable); //查询列表 //Sort：排序参数 List\u0026lt;T\u0026gt; findAll(Specification\u0026lt;T\u0026gt; spec, Sort sort); long count(Specification\u0026lt;T\u0026gt; spec);//统计查询  Specification ：查询条件\n自定义我们自己的Specification实现类\n实现\n//root：查询的根对象（查询的任何属性都可以从根对象中获取） //CriteriaQuery：顶层查询对象，自定义查询方式（了解：一般不用） //CriteriaBuilder：查询的构造器，封装了很多的查询条件 Predicate toPredicate(Root\u0026lt;T\u0026gt; root, CriteriaQuery\u0026lt;?\u0026gt; query, CriteriaBuilder cb); //封装查询条件  动态查询 查询单个对象 /** * 根据条件，查询单个对象 * */ @Test public void testSpec() { //匿名内部类 /** * 自定义查询条件 * 1.实现Specification接口（提供泛型：查询的对象类型） * 2.实现toPredicate方法（构造查询条件） * 3.需要借助方法参数中的两个参数（ * root：获取需要查询的对象属性 * CriteriaBuilder：构造查询条件的，内部封装了很多的查询条件（模糊匹配，精准匹配） * ） * 案例：根据客户名称查询，查询客户名为xxx的客户 * 查询条件 * 1.查询方式 * cb对象 * 2.比较的属性名称 * root对象 */ Specification\u0026lt;Customer\u0026gt; spec = new Specification\u0026lt;Customer\u0026gt;() { @Override public Predicate toPredicate(Root\u0026lt;Customer\u0026gt; root, CriteriaQuery\u0026lt;?\u0026gt; query, CriteriaBuilder cb) { //1.获取比较的属性 Path\u0026lt;Object\u0026gt; custName = root.get(\u0026quot;custId\u0026quot;); //2.构造查询条件 ： select * from cst_customer where cust_name = 'xxx' /** * 第一个参数：需要比较的属性（path对象） * 第二个参数：当前需要比较的取值 */ Predicate predicate = cb.equal(custName, \u0026quot;xxx\u0026quot;);//进行精准的匹配 （比较的属性，比较的属性的取值） return predicate; } }; Customer customer = customerDao.findOne(spec); System.out.println(customer); }  多条件查询 /** * 多条件查询 * 案例：根据客户名（xx）和客户所属行业查询（it教育） */ @Test public void testSpec1() { /** * root:获取属性 * 客户名 * 所属行业 * cb：构造查询 * 1.构造客户名的精准匹配查询 * 2.构造所属行业的精准匹配查询 * 3.将以上两个查询联系起来 */ Specification\u0026lt;Customer\u0026gt; spec = new Specification\u0026lt;Customer\u0026gt;() { @Override public Predicate toPredicate(Root\u0026lt;Customer\u0026gt; root, CriteriaQuery\u0026lt;?\u0026gt; query, CriteriaBuilder cb) { Path\u0026lt;Object\u0026gt; custName = root.get(\u0026quot;custName\u0026quot;);//客户名 Path\u0026lt;Object\u0026gt; custIndustry = root.get(\u0026quot;custIndustry\u0026quot;);//所属行业 //构造查询 //1.构造客户名的精准匹配查询 Predicate p1 = cb.equal(custName, \u0026quot;xxx\u0026quot;);//第一个参数，path（属性），第二个参数，属性的取值 //2..构造所属行业的精准匹配查询 Predicate p2 = cb.equal(custIndustry, \u0026quot;it教育\u0026quot;); //3.将多个查询条件组合到一起：组合（满足条件一并且满足条件二：与关系，满足条件一或满足条件二即可：或关系） Predicate and = cb.and(p1, p2);//以与的形式拼接多个查询条件 // cb.or();//以或的形式拼接多个查询条件 return and; } }; Customer customer = customerDao.findOne(spec); System.out.println(customer); }  模糊查询 /** * 案例：完成根据客户名称的模糊匹配，返回客户列表 * 客户名称以 ’传智播客‘ 开头 * * equal ：直接的到path对象（属性），然后进行比较即可 * gt，lt,ge,le,like : 得到path对象，根据path指定比较的参数类型，再去进行比较 * 指定参数类型：path.as(类型的字节码对象) */ @Test public void testSpec3() { //构造查询条件 Specification\u0026lt;Customer\u0026gt; spec = new Specification\u0026lt;Customer\u0026gt;() { @Override public Predicate toPredicate(Root\u0026lt;Customer\u0026gt; root, CriteriaQuery\u0026lt;?\u0026gt; query, CriteriaBuilder cb) { //查询属性：客户名 Path\u0026lt;Object\u0026gt; custName = root.get(\u0026quot;custName\u0026quot;); //查询方式：模糊匹配 Predicate like = cb.like(custName.as(String.class), \u0026quot;传智播客%\u0026quot;); return like; } }; // List\u0026lt;Customer\u0026gt; list = customerDao.findAll(spec); // for (Customer customer : list) { // System.out.println(customer); // } //添加排序 //创建排序对象,需要调用构造方法实例化sort对象 //第一个参数：排序的顺序（倒序，正序） // Sort.Direction.DESC:倒序 // Sort.Direction.ASC ： 升序 //第二个参数：排序的属性名称 Sort sort = new Sort(Sort.Direction.DESC,\u0026quot;custId\u0026quot;); List\u0026lt;Customer\u0026gt; list = customerDao.findAll(spec, sort); for (Customer customer : list) { System.out.println(customer); } }  分页查询 /** * 分页查询 * Specification: 查询条件 * Pageable：分页参数 * 分页参数：查询的页码，每页查询的条数 * findAll(Specification,Pageable)：带有条件的分页 * findAll(Pageable)：没有条件的分页 * 返回：Page（springDataJpa为我们封装好的pageBean对象，数据列表，共条数） */ @Test public void testSpec4() { Specification spec = null; //PageRequest对象是Pageable接口的实现类 /** * 创建PageRequest的过程中，需要调用他的构造方法传入两个参数 * 第一个参数：当前查询的页数（从0开始） * 第二个参数：每页查询的数量 */ Pageable pageable = new PageRequest(0,2); //分页查询 Page\u0026lt;Customer\u0026gt; page = customerDao.findAll(null, pageable); System.out.println(page.getContent()); //得到数据集合列表 System.out.println(page.getTotalElements());//得到总条数 System.out.println(page.getTotalPages());//得到总页数 }  多表查询 表关系\n 一对一\n 一对多：\n 一的一方：主表\n 多的一方：从表\n 外键：需要再从表上新建一列作为外键，他的取值来源于主表的主键\n  多对多：\n 中间表：中间表中最少应该由两个字段组成，这两个字段做为外键指向两张表的主键，又组成了联合主键   实体类中的关系\n包含关系：可以通过实体类中的包含关系描述表关系\n继承关系\n分析步骤\n 明确表关系 确定表关系（描述 外键|中间表） 编写实体类，再实体类中描述表关系（包含关系） 配置映射关系  一对多 案例：客户和联系人的案例（一对多关系）\n客户：一家公司\n联系人：这家公司的员工\n一个客户可以具有多个联系人\n一个联系人从属于一家公司\n分析步骤\n 明确表关系\n​ 一对多关系\n 确定表关系（描述 外键|中间表）\n​ 主表：客户表\n​ 从表：联系人表\n​ 再从表上添加外键\n 编写实体类，再实体类中描述表关系（包含关系）\n​ 客户：再客户的实体类中包含一个联系人的集合\n​ 联系人：在联系人的实体类中包含一个客户的对象\n 配置映射关系\n​ 使用jpa注解配置一对多映射关系\n  创建表 /*创建客户表*/ CREATE TABLE cst_customer ( cust_id bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', cust_name varchar(32) NOT NULL COMMENT '客户名称(公司名称)', cust_source varchar(32) DEFAULT NULL COMMENT '客户信息来源', cust_industry varchar(32) DEFAULT NULL COMMENT '客户所属行业', cust_level varchar(32) DEFAULT NULL COMMENT '客户级别', cust_address varchar(128) DEFAULT NULL COMMENT '客户联系地址', cust_phone varchar(64) DEFAULT NULL COMMENT '客户联系电话', PRIMARY KEY (`cust_id`) ) ENGINE=InnoDB AUTO_INCREMENT=94 DEFAULT CHARSET=utf8; /*创建联系人表*/ CREATE TABLE cst_linkman ( lkm_id bigint(32) NOT NULL AUTO_INCREMENT COMMENT '联系人编号(主键)', lkm_name varchar(16) DEFAULT NULL COMMENT '联系人姓名', lkm_gender char(1) DEFAULT NULL COMMENT '联系人性别', lkm_phone varchar(16) DEFAULT NULL COMMENT '联系人办公电话', lkm_mobile varchar(16) DEFAULT NULL COMMENT '联系人手机', lkm_email varchar(64) DEFAULT NULL COMMENT '联系人邮箱', lkm_position varchar(16) DEFAULT NULL COMMENT '联系人职位', lkm_memo varchar(512) DEFAULT NULL COMMENT '联系人备注', lkm_cust_id bigint(32) NOT NULL COMMENT '客户id(外键)', PRIMARY KEY (`lkm_id`), KEY `FK_cst_linkman_lkm_cust_id` (`lkm_cust_id`), CONSTRAINT `FK_cst_linkman_lkm_cust_id` FOREIGN KEY (`lkm_cust_id`) REFERENCES `cst_customer` (`cust_id`) ON DELETE NO ACTION ON UPDATE NO ACTION ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;  实体类和Dao //配置客户和联系人之间的关系（一对多关系） /** * 使用注解的形式配置多表关系 * 1.声明关系 * @OneToMany : 配置一对多关系 * targetEntity ：对方对象的字节码对象 * 2.配置外键（中间表） * @JoinColumn : 配置外键 * name：外键字段名称 * referencedColumnName：参照的主表的主键字段名称 * * * 在客户实体类上（一的一方）添加了外键了配置，所以对于客户而言，也具备了维护外键的作用 */ // @OneToMany(targetEntity = LinkMan.class) // @JoinColumn(name = \u0026quot;lkm_cust_id\u0026quot;,referencedColumnName = \u0026quot;cust_id\u0026quot;) /** * 放弃外键维护权 * mappedBy：对方配置关系的属性名称\\ * cascade : 配置级联（可以配置到设置多表的映射关系的注解上） * CascadeType.all : 所有 * MERGE ：更新 * PERSIST ：保存 * REMOVE ：删除 * fetch : 配置关联对象的加载方式 * EAGER ：立即加载 * LAZY ：延迟加载 */ @OneToMany(mappedBy = \u0026quot;customer\u0026quot;,cascade = CascadeType.ALL) private Set\u0026lt;LinkMan\u0026gt; linkMans = new HashSet\u0026lt;\u0026gt;();  多对一 /** * 配置联系人到客户的多对一关系 * 使用注解的形式配置多对一关系 * 1.配置表关系 * @ManyToOne : 配置多对一关系 * targetEntity：对方的实体类字节码 * 2.配置外键（中间表） * * * 配置外键的过程，配置到了多的一方，就会在多的一方维护外键 * */ @ManyToOne(targetEntity = Customer.class,fetch = FetchType.LAZY) @JoinColumn(name = \u0026quot;lkm_cust_id\u0026quot;,referencedColumnName = \u0026quot;cust_id\u0026quot;) private Customer customer;  测试一对多 /** * 保存一个客户，保存一个联系人 * 效果：客户和联系人作为独立的数据保存到数据库中 * 联系人的外键为空 * 原因？ * 实体类中没有配置关系 */ @Test @Transactional //配置事务 @Rollback(false) //不自动回滚 public void testAdd() { //创建一个客户，创建一个联系人 Customer customer = new Customer(); customer.setCustName(\u0026quot;百度\u0026quot;); LinkMan linkMan = new LinkMan(); linkMan.setLkmName(\u0026quot;小李\u0026quot;); /** * 配置了客户到联系人的关系 * 从客户的角度上：发送两条insert语句，发送一条更新语句更新数据库（更新外键） * 由于我们配置了客户到联系人的关系：客户可以对外键进行维护 */ customer.getLinkMans().add(linkMan); customerDao.save(customer); linkManDao.save(linkMan); }  测试多对一 @Test @Transactional //配置事务 @Rollback(false) //不自动回滚 public void testAdd1() { //创建一个客户，创建一个联系人 Customer customer = new Customer(); customer.setCustName(\u0026quot;百度\u0026quot;); LinkMan linkMan = new LinkMan(); linkMan.setLkmName(\u0026quot;小李\u0026quot;); /** * 配置联系人到客户的关系（多对一） * 只发送了两条insert语句 * 由于配置了联系人到客户的映射关系（多对一） */ linkMan.setCustomer(customer); customerDao.save(customer); linkManDao.save(linkMan); }  /** * 会有一条多余的update语句 * * 由于一的一方可以维护外键：会发送update语句 * * 解决此问题：只需要在一的一方放弃维护权即可 */ @Test @Transactional //配置事务 @Rollback(false) //不自动回滚 public void testAdd2() { //创建一个客户，创建一个联系人 Customer customer = new Customer(); customer.setCustName(\u0026quot;百度\u0026quot;); LinkMan linkMan = new LinkMan(); linkMan.setLkmName(\u0026quot;小李\u0026quot;); linkMan.setCustomer(customer);//由于配置了多的一方到一的一方的关联关系（当保存的时候，就已经对外键赋值） customer.getLinkMans().add(linkMan);//由于配置了一的一方到多的一方的关联关系（发送一条update语句） customerDao.save(customer); linkManDao.save(linkMan); }  删除从表数据：可以随时任意删除。\n删除主表数据\n有从表数据\n1、在默认情况下，它会把外键字段置为null，然后删除主表数据。如果在数据库的表 结构上，外键字段有非空约束，默认情况就会报错了。\n2、如果配置了放弃维护关联关系的权利，则不能删除（与外键字段是否允许为null， 没有关系）因为在删除时，它根本不会去更新从表的外键字段了。\n3、如果还想删除，使用级联删除引用\n没有从表数据引用：随便删\n在实际开发中，级联删除请慎用！(在一对多的情况下)\n级联添加删除 /** * 级联添加：保存一个客户的同时，保存客户的所有联系人 * 需要在操作主体的实体类上，配置casacde属性 */ @Test @Transactional //配置事务 @Rollback(false) //不自动回滚 public void testCascadeAdd() { Customer customer = new Customer(); customer.setCustName(\u0026quot;百度1\u0026quot;); LinkMan linkMan = new LinkMan(); linkMan.setLkmName(\u0026quot;小李1\u0026quot;); linkMan.setCustomer(customer); customer.getLinkMans().add(linkMan); customerDao.save(customer); } /** * 级联删除： * 删除1号客户的同时，删除1号客户的所有联系人 */ @Test @Transactional //配置事务 @Rollback(false) //不自动回滚 public void testCascadeRemove() { //1.查询1号客户 Customer customer = customerDao.findOne(1l); //2.删除1号客户 customerDao.delete(customer); }  多对多 多对多操作\n案例：用户和角色（多对多关系）\n用户： 角色：  ​ 分析步骤\n 明确表关系\n​ 多对多关系\n 确定表关系（描述 外键|中间表）\n​ 中间间表\n 编写实体类，再实体类中描述表关系（包含关系）\n用户：包含角色的集合\n角色：包含用户的集合\n 配置映射关系\n  类 @Entity @Table(name = \u0026quot;sys_role\u0026quot;) public class Role { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \u0026quot;role_id\u0026quot;) private Long roleId; @Column(name = \u0026quot;role_name\u0026quot;) private String roleName; //配置多对多 @ManyToMany(mappedBy = \u0026quot;roles\u0026quot;) //配置多表关系 private Set\u0026lt;User\u0026gt; users = new HashSet\u0026lt;\u0026gt;(); public Long getRoleId() { return roleId; } public void setRoleId(Long roleId) { this.roleId = roleId; } public String getRoleName() { return roleName; } public void setRoleName(String roleName) { this.roleName = roleName; } public Set\u0026lt;User\u0026gt; getUsers() { return users; } public void setUsers(Set\u0026lt;User\u0026gt; users) { this.users = users; } }  @Entity @Table(name = \u0026quot;sys_user\u0026quot;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name=\u0026quot;user_id\u0026quot;) private Long userId; @Column(name=\u0026quot;user_name\u0026quot;) private String userName; @Column(name=\u0026quot;age\u0026quot;) private Integer age; /** * 配置用户到角色的多对多关系 * 配置多对多的映射关系 * 1.声明表关系的配置 * @ManyToMany(targetEntity = Role.class) //多对多 * targetEntity：代表对方的实体类字节码 * 2.配置中间表（包含两个外键） * @JoinTable * name : 中间表的名称 * joinColumns：配置当前对象在中间表的外键 * @JoinColumn的数组 * name：外键名 * referencedColumnName：参照的主表的主键名 * inverseJoinColumns：配置对方对象在中间表的外键 */ @ManyToMany(targetEntity = Role.class,cascade = CascadeType.ALL) @JoinTable(name = \u0026quot;sys_user_role\u0026quot;, //joinColumns,当前对象在中间表中的外键 joinColumns = {@JoinColumn(name = \u0026quot;sys_user_id\u0026quot;,referencedColumnName = \u0026quot;user_id\u0026quot;)}, //inverseJoinColumns，对方对象在中间表的外键 inverseJoinColumns = {@JoinColumn(name = \u0026quot;sys_role_id\u0026quot;,referencedColumnName = \u0026quot;role_id\u0026quot;)} ) private Set\u0026lt;Role\u0026gt; roles = new HashSet\u0026lt;\u0026gt;(); public Long getUserId() { return userId; } public void setUserId(Long userId) { this.userId = userId; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Set\u0026lt;Role\u0026gt; getRoles() { return roles; } public void setRoles(Set\u0026lt;Role\u0026gt; roles) { this.roles = roles; } }  dao public interface RoleDao extends JpaRepository\u0026lt;Role,Long\u0026gt; ,JpaSpecificationExecutor\u0026lt;Role\u0026gt; { } public interface UserDao extends JpaRepository\u0026lt;User,Long\u0026gt; ,JpaSpecificationExecutor\u0026lt;User\u0026gt; { }  测试 /** * 保存一个用户，保存一个角色 * * 多对多放弃维护权：被动的一方放弃 */ @Test @Transactional @Rollback(false) public void testAdd() { User user = new User(); user.setUserName(\u0026quot;小李\u0026quot;); Role role = new Role(); role.setRoleName(\u0026quot;java程序员\u0026quot;); //配置用户到角色关系，可以对中间表中的数据进行维护 1-1 user.getRoles().add(role); //配置角色到用户的关系，可以对中间表的数据进行维护 1-1 role.getUsers().add(user); userDao.save(user); roleDao.save(role); } //测试级联添加（保存一个用户的同时保存用户的关联角色） @Test @Transactional @Rollback(false) public void testCasCadeAdd() { User user = new User(); user.setUserName(\u0026quot;小李\u0026quot;); Role role = new Role(); role.setRoleName(\u0026quot;java程序员\u0026quot;); //配置用户到角色关系，可以对中间表中的数据进行维护 1-1 user.getRoles().add(role); //配置角色到用户的关系，可以对中间表的数据进行维护 1-1 role.getUsers().add(user); userDao.save(user); } /** * 案例：删除id为1的用户，同时删除他的关联对象 */ @Test @Transactional @Rollback(false) public void testCasCadeRemove() { //查询1号用户 User user = userDao.findOne(1l); //删除1号用户 userDao.delete(user); }  对象导航查询 //could not initialize proxy - no Session //测试对象导航查询（查询一个对象的时候，通过此对象查询所有的关联对象） @Test @Transactional // 解决在java代码中的no session问题 public void testQuery1() { //查询id为1的客户 Customer customer = customerDao.getOne(1l); //对象导航查询，此客户下的所有联系人 Set\u0026lt;LinkMan\u0026gt; linkMans = customer.getLinkMans(); for (LinkMan linkMan : linkMans) { System.out.println(linkMan); } } /** * 对象导航查询： * 默认使用的是延迟加载的形式查询的 * 调用get方法并不会立即发送查询，而是在使用关联对象的时候才会差和讯 * 延迟加载！ * 修改配置，将延迟加载改为立即加载 * fetch，需要配置到多表映射关系的注解上 * */ @Test @Transactional // 解决在java代码中的no session问题 public void testQuery2() { //查询id为1的客户 Customer customer = customerDao.findOne(1l); //对象导航查询，此客户下的所有联系人 Set\u0026lt;LinkMan\u0026gt; linkMans = customer.getLinkMans(); System.out.println(linkMans.size()); } /** * 从联系人对象导航查询他的所属客户 * * 默认 ： 立即加载 * 延迟加载： * */ @Test @Transactional // 解决在java代码中的no session问题 public void testQuery3() { LinkMan linkMan = linkManDao.findOne(2l); //对象导航查询所属的客户 Customer customer = linkMan.getCustomer(); System.out.println(customer); }  注意\n对象导航查询\n查询一个对象的同时，通过此对象查询他的关联对象\n案例：客户和联系人\n从一方查询多方\n 默认：使用延迟加载（）  从多方查询一方\n 默认：使用立即加载  SpringData 简介 Spring Data : Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。\nSpringData 项目所支持 NoSQL 存储：\n MongoDB （文档数据库） Neo4j（图形数据库） Redis（键/值存储） Hbase（列族数据库）  SpringData 项目所支持的关系数据存储技术：\n JDBC JPA  JPA Spring Data : 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就只是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！\n框架怎么可能代替开发者实现业务逻辑呢？比如：当有一个 UserDao.findUserById() 这样一个方法声明，大致应该能判断出这是根据给定条件的 ID 查询出满足条件的 User 对象。Spring Data JPA 做的便是规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。\n第一个springdata程序 使用 Spring Data JPA 进行持久层开发需要的四个步骤：\n 配置 Spring 整合 JPA\n 在 Spring 配置文件中配置 Spring Data，让 Spring 为声明的接口创建代理对象。配置了 \u0026lt;jpa:repositories\u0026gt; 后，Spring 初始化容器时将会扫描 base-package 指定的包目录及其子目录，为继承 Repository 或其子接口的接口创建代理对象，并将代理对象注册为 Spring Bean，业务层便可以通过 Spring 自动封装的特性来直接使用该对象。\n 声明持久层的接口，该接口继承 Repository，Repository 是一个标记型接口，它不包含任何方法，如必要，Spring Data 可实现 Repository 其他子接口，其中定义了一些常用的增删改查，以及分页相关的方法。\n 在接口中声明需要的方法。Spring Data 将根据给定的策略（具体策略稍后讲解）来为其生成实现代码。\n  jar包 antlr-2.7.7.jar c3p0-0.9.2.1.jar com.springsource.net.sf.cglib-2.2.0.jar com.springsource.org.aopallince.... com.springsource.org.aspectj.weave.. commons-logging-1.1.3.jar dom4j-1.6.1.jar hibernate-c3p0-4.2.4.Final.jar hibernate -commons-annotations-4.0.. hibernate-core- 4.2.4.Final.jar hibernate-entitymanager-4.2.4.Final.ja hibernate-jpa-2.0-api-1.0.1.Final.jar javassist-3.15.0-GA.jar jboss-logging-3.1.0.GA.jar jboss-transaction-api 1.1_ spec-1.0.1... mchange-commons-java-0.2.3.4.jar mysql-connectorjava-5.1.7-bin.jar slf4j-api-1.6.1jar spring-aop-4.0.0.RELEASEjar spring-aspects-4.0.0.RELEASE.jar spring-beans-4.0.0.RELEASE.jar spring-context-4.0.0.RELEASE.jar spring-core-4.0.0.RELEASE.jar spring-data-commons-1.6.2.RELEASE.. spring-data-jpa-1 .4.2.RELEASE.jar spring-expression-4.0.0.RELEASEjar spring-jdbc-4.0.0.RELEASE.jar spring-orm-4.0.0.RELEASE.jar spring-tx-4.0.0.RELEASE.jar spring-web-4.0.0.RELEASE.jar spring-webmvc-4.0.0.RELEASE.jar  spring配置文件 \u0026lt;!-- 配置自动扫描的包 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;com.atguigu.springdata\u0026quot;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;!-- 1. 配置数据源 --\u0026gt; \u0026lt;context:property-placeholder location=\u0026quot;classpath:db.properties\u0026quot;/\u0026gt; \u0026lt;bean id=\u0026quot;dataSource\u0026quot; class=\u0026quot;com.mchange.v2.c3p0.ComboPooledDataSource\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;user\u0026quot; value=\u0026quot;${jdbc.user}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${jdbc.password}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt;\t\u0026lt;property name=\u0026quot;driverClass\u0026quot; value=\u0026quot;${jdbc.driverClass}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jdbcUrl\u0026quot; value=\u0026quot;${jdbc.jdbcUrl}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 配置其他属性 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 2. 配置 JPA 的 EntityManagerFactory --\u0026gt; \u0026lt;bean id=\u0026quot;entityManagerFactory\u0026quot; class=\u0026quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jpaVendorAdapter\u0026quot;\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;packagesToScan\u0026quot; value=\u0026quot;com.atguigu.springdata\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jpaProperties\u0026quot;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;!-- 二级缓存相关 --\u0026gt; \u0026lt;!-- \u0026lt;prop key=\u0026quot;hibernate.cache.region.factory_class\u0026quot;\u0026gt;org.hibernate.cache.ehcache.EhCacheRegionFactory\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026quot;net.sf.ehcache.configurationResourceName\u0026quot;\u0026gt;ehcache-hibernate.xml\u0026lt;/prop\u0026gt; --\u0026gt; \u0026lt;!-- 生成的数据表的列的映射策略 --\u0026gt; \u0026lt;prop key=\u0026quot;hibernate.ejb.naming_strategy\u0026quot;\u0026gt;org.hibernate.cfg.ImprovedNamingStrategy\u0026lt;/prop\u0026gt; \u0026lt;!-- hibernate 基本属性 --\u0026gt; \u0026lt;prop key=\u0026quot;hibernate.dialect\u0026quot;\u0026gt;org.hibernate.dialect.MySQL5InnoDBDialect\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026quot;hibernate.show_sql\u0026quot;\u0026gt;true\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026quot;hibernate.format_sql\u0026quot;\u0026gt;true\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026quot;hibernate.hbm2ddl.auto\u0026quot;\u0026gt;update\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 3. 配置事务管理器 --\u0026gt; \u0026lt;bean id=\u0026quot;transactionManager\u0026quot; class=\u0026quot;org.springframework.orm.jpa.JpaTransactionManager\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;entityManagerFactory\u0026quot; ref=\u0026quot;entityManagerFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt;\t\u0026lt;/bean\u0026gt; \u0026lt;!-- 4. 配置支持注解的事务 --\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026quot;transactionManager\u0026quot;/\u0026gt; \u0026lt;!-- 5. 配置 SpringData --\u0026gt; \u0026lt;!-- 加入 jpa 的命名空间 --\u0026gt; \u0026lt;!-- base-package: 扫描 Repository Bean 所在的 package --\u0026gt; \u0026lt;jpa:repositories base-package=\u0026quot;com.atguigu.springdata\u0026quot; entity-manager-factory-ref=\u0026quot;entityManagerFactory\u0026quot;\u0026gt;\u0026lt;/jpa:repositories\u0026gt;  jdbc.user=root jdbc.password=root jdbc.driverClass=com.mysql.jdbc.Driver jdbc.jdbcUrl=jdbc:mysql:///jpa  实体类\n@Table(name=\u0026quot;JPA_PERSONS\u0026quot;) @Entity public class Person { private Integer id; private String lastName; private String email; private Date birth; private Address address; private Integer addressId; @GeneratedValue @Id public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Date getBirth() { return birth; } public void setBirth(Date birth) { this.birth = birth; } @Column(name=\u0026quot;ADD_ID\u0026quot;) public Integer getAddressId() { return addressId; } public void setAddressId(Integer addressId) { this.addressId = addressId; } @JoinColumn(name=\u0026quot;ADDRESS_ID\u0026quot;) @ManyToOne public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } @Override public String toString() { return \u0026quot;Person [id=\u0026quot; + id + \u0026quot;, lastName=\u0026quot; + lastName + \u0026quot;, email=\u0026quot; + email + \u0026quot;, brith=\u0026quot; + birth + \u0026quot;]\u0026quot;; } } @Table(name=\u0026quot;JPA_ADDRESSES\u0026quot;) @Entity public class Address { private Integer id; private String province; private String city; @GeneratedValue @Id public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getProvince() { return province; } public void setProvince(String province) { this.province = province; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } }  /** * 1. Repository 是一个空接口. 即是一个标记接口 * 2. 若我们定义的接口继承了 Repository, 则该接口会被 IOC 容器识别为一个 Repository Bean. * 纳入到 IOC 容器中. 进而可以在该接口中定义满足一定规范的方法. * * 3. 实际上, 也可以通过 @RepositoryDefinition 注解来替代继承 Repository 接口 */ //@RepositoryDefinition(domainClass=Person.class,idClass=Integer.class) public interface PersonRepsotory extends Repository\u0026lt;Person, Integer\u0026gt;{ //根据 lastName 来获取对应的 Person Person getByLastName(String lastName); }  Repository 接口概述 Repository 接口是 Spring Data 的一个核心接口，它不提供任何方法，开发者需要在自己定义的接口中声明需要的方法 public interface Repository\u0026lt;T, ID extends Serializable\u0026gt; { }\nSpring Data可以让我们只定义接口，只要遵循 Spring Data的规范，就无需写实现类。\n与继承 Repository 等价的一种方式，就是在持久层接口上使用 @RepositoryDefinition 注解，并为其指定 domainClass 和 idClass 属性。如下两种方式是完全等价的\nRepository 的子接口 基础的 Repository 提供了最基本的数据访问功能，其几个子接口则扩展了一些功能。它们的继承关系如下： Repository： 仅仅是一个标识，表明任何继承它的均为仓库接口类 CrudRepository： 继承 Repository，实现了一组 CRUD 相关的方法 PagingAndSortingRepository： 继承 CrudRepository，实现了一组分页排序相关的方法 JpaRepository： 继承 PagingAndSortingRepository，实现一组 JPA 规范相关的方法 自定义的 XxxxRepository 需要继承 JpaRepository，这样的 XxxxRepository 接口就具备了通用的数据访问控制层的能力。 JpaSpecificationExecutor： 不属于Repository体系，实现一组 JPA Criteria 查询相关的方法  SpringData 方法定义规范 在 Repository 子接口中声明方法\n 不是随便声明的. 而需要符合一定的规范 查询方法以 find | read | get 开头 涉及条件查询时，条件的属性用条件关键字连接 要注意的是：条件属性以首字母大写。 支持属性的级联查询. 若当前类有符合条件的属性, 则优先使用, 而不使用级联属性. 若需要使用级联属性, 则属性之间使用 _ 进行连接.  直接在接口中定义查询方法，如果是符合规范的，可以不用写实现，目前支持的关键字写法如下：\n关键字 //WHERE lastName LIKE ?% AND id \u0026lt; ? List\u0026lt;Person\u0026gt; getByLastNameStartingWithAndIdLessThan(String lastName, Integer id); //WHERE lastName LIKE %? AND id \u0026lt; ? List\u0026lt;Person\u0026gt; getByLastNameEndingWithAndIdLessThan(String lastName, Integer id); //WHERE email IN (?, ?, ?) And birth \u0026lt; ? List\u0026lt;Person\u0026gt; getByEmailInAndBirthLessThan(List\u0026lt;String\u0026gt; emails, Date birth);  @Test public void testKeyWords(){ List\u0026lt;Person\u0026gt; persons = personRepsotory.getByLastNameStartingWithAndIdLessThan(\u0026quot;X\u0026quot;, 10); System.out.println(persons); persons = personRepsotory.getByLastNameEndingWithAndIdLessThan(\u0026quot;X\u0026quot;, 10); System.out.println(persons); persons = personRepsotory.getByEmailInAndBirthLessThan(Arrays.asList(\u0026quot;AA@atguigu.com\u0026quot;, \u0026quot;FF@atguigu.com\u0026quot;, \u0026quot;SS@atguigu.com\u0026quot;), new Date()); System.out.println(persons.size()); }  级联 //WHERE a.id \u0026gt; ? List\u0026lt;Person\u0026gt; getByAddressIdGreaterThan(Integer id); //WHERE a.id \u0026gt; ? List\u0026lt;Person\u0026gt; getByAddress_IdGreaterThan(Integer id);  List\u0026lt;Person\u0026gt; persons = personRepsotory.getByAddressIdGreaterThan(1); System.out.println(persons); List\u0026lt;Person\u0026gt; persons = personRepsotory.getByAddress_IdGreaterThan(1); System.out.println(persons);  若Person类中含有属性addressId，而他的属性address含有属性id，则会使用Person类中addressId的属性进行查询。要想使用address对象中的属性id进行查询的时候需要使用_下划线进行分割\n流程解析\n假如创建如下的查询：findByUserDepUuid()，框架在解析该方法时，首先剔除 findBy，然后对剩下的属性进行解析，假设查询实体为Doc\n先判断 userDepUuid （根据 POJO 规范，首字母变为小写）是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，继续第二步；\n从右往左截取第一个大写字母开头的字符串(此处为Uuid)，然后检查剩下的字符串是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，则重复第二步，继续从右往左截取；最后假设 user 为查询实体的一个属性；\n接着处理剩下部分（DepUuid），先判断 user 所对应的类型是否有depUuid属性，如果有，则表示该方法最终是根据 “ Doc.user.depUuid” 的取值进行查询；否则继续按照步骤 2 的规则从右往左截取，最终表示根据 “Doc.user.dep.uuid” 的值进行查询。\n可能会存在一种特殊情况，比如 Doc包含一个 user 的属性，也有一个 userDep 属性，此时会存在混淆。可以明确在属性之间加上 \u0026ldquo;_\u0026rdquo; 以显式表达意图，比如 \u0026ldquo;findByUser_DepUuid()\u0026rdquo; 或者 \u0026ldquo;findByUserDep_uuid()\u0026rdquo;\n特殊的参数： 还可以直接在方法的参数上加入分页或排序的参数，比如：\nPage\u0026lt;UserModel\u0026gt; findByName(String name, Pageable pageable); List\u0026lt;UserModel\u0026gt; findByName(String name, Sort sort);  @Query注解 这种查询可以声明在 Repository 方法中，摆脱像命名查询那样的约束，将查询直接在相应的接口方法中声明，结构更为清晰，这是 Spring data 的特有实现。\n//查询 id 值最大的那个 Person //使用 @Query 注解可以自定义 JPQL 语句以实现更灵活的查询 @Query(\u0026quot;SELECT p FROM Person p WHERE p.id = (SELECT max(p2.id) FROM Person p2)\u0026quot;) Person getMaxIdPerson();  Person person = personRepsotory.getMaxIdPerson(); System.out.println(person);  传参方式一\n//为 @Query 注解传递参数的方式1: 使用占位符. @Query(\u0026quot;SELECT p FROM Person p WHERE p.lastName = ?1 AND p.email = ?2\u0026quot;) List\u0026lt;Person\u0026gt; testQueryAnnotationParams1(String lastName, String email);  传参方式二\n//为 @Query 注解传递参数的方式2: 命名参数的方式. @Query(\u0026quot;SELECT p FROM Person p WHERE p.lastName = :lastName AND p.email = :email\u0026quot;) List\u0026lt;Person\u0026gt; testQueryAnnotationParams2(@Param(\u0026quot;email\u0026quot;) String email, @Param(\u0026quot;lastName\u0026quot;) String lastName);  List\u0026lt;Person\u0026gt; persons = personRepsotory.testQueryAnnotationParams2(\u0026quot;aa@atguigu.com\u0026quot;, \u0026quot;AA\u0026quot;); System.out.println(persons); List\u0026lt;Person\u0026gt; persons = personRepsotory.testQueryAnnotationParams1(\u0026quot;AA\u0026quot;, \u0026quot;aa@atguigu.com\u0026quot;); System.out.println(persons);  允许占位符添加%%\n//like @Query(\u0026quot;SELECT p FROM Person p WHERE p.lastName LIKE ?1 OR p.email LIKE ?2\u0026quot;) List\u0026lt;Person\u0026gt; testQueryAnnotationLikeParam(String lastName, String email); //SpringData 允许在占位符上添加 %%. @Query(\u0026quot;SELECT p FROM Person p WHERE p.lastName LIKE %?1% OR p.email LIKE %?2%\u0026quot;) List\u0026lt;Person\u0026gt; testQueryAnnotationLikeParam(String lastName, String email); //SpringData 也可以写成命名参数 @Query(\u0026quot;SELECT p FROM Person p WHERE p.lastName LIKE %:lastName% OR p.email LIKE %:email%\u0026quot;) List\u0026lt;Person\u0026gt; testQueryAnnotationLikeParam2(@Param(\u0026quot;email\u0026quot;) String email, @Param(\u0026quot;lastName\u0026quot;) String lastName);  List\u0026lt;Person\u0026gt; persons = personRepsotory.testQueryAnnotationLikeParam(\u0026quot;%A%\u0026quot;, \u0026quot;%bb%\u0026quot;); System.out.println(persons.size()); List\u0026lt;Person\u0026gt; persons = personRepsotory.testQueryAnnotationLikeParam(\u0026quot;A\u0026quot;, \u0026quot;bb\u0026quot;); System.out.println(persons.size()); List\u0026lt;Person\u0026gt; persons = personRepsotory.testQueryAnnotationLikeParam2(\u0026quot;bb\u0026quot;, \u0026quot;A\u0026quot;); System.out.println(persons.size());  查询总数\n//设置 nativeQuery=true 即可以使用原生的 SQL 查询 @Query(value=\u0026quot;SELECT count(id) FROM jpa_persons\u0026quot;, nativeQuery=true) long getTotalCount();  long count = personRepsotory.getTotalCount(); System.out.println(count);  @Modifying 注解和事务 更新\n//可以通过自定义的 JPQL 完成 UPDATE 和 DELETE 操作. 注意: JPQL 不支持使用 INSERT //在 @Query 注解中编写 JPQL 语句, 但必须使用 @Modifying 进行修饰. 以通知 SpringData, 这是一个 UPDATE 或 DELETE 操作 //UPDATE 或 DELETE 操作需要使用事务, 此时需要定义 Service 层. 在 Service 层的方法上添加事务操作. //默认情况下, SpringData 的每个方法上有事务, 但都是一个只读事务. 他们不能完成修改操作! @Modifying @Query(\u0026quot;UPDATE Person p SET p.email = :email WHERE id = :id\u0026quot;) void updatePersonEmail(@Param(\u0026quot;id\u0026quot;) Integer id, @Param(\u0026quot;email\u0026quot;) String email);  @Transactional public void updatePersonEmail(String email, Integer id){ personRepsotory.updatePersonEmail(id, email); } personService.updatePersonEmail(\u0026quot;mmmm@atguigu.com\u0026quot;, 1);  注意：\n 方法的返回值应该是 int，表示更新语句所影响的行数 在调用的地方必须加事务，没有事务不能正常执行  Spring Data 提供了默认的事务处理方式，即所有的查询均声明为只读事务。\n对于自定义的方法，如需改变 Spring Data 提供的事务默认方式，可以在方法上注解 @Transactional 声明\n进行多个 Repository 操作时，也应该使它们在同一个事务中处理，按照分层架构的思想，这部分属于业务逻辑层，因此，需要在 Service 层实现对多个 Repository 的调用，并在相应的方法上声明事务。\nCrudRepository 接口 CrudRepository 接口提供了最基本的对实体类的添删改查操作\nT save(T entity);//保存单个实体 Iterable\u0026lt;T\u0026gt; save(Iterable\u0026lt;? extends T\u0026gt; entities);//保存集合 T findOne(ID id);//根据id查找实体 boolean exists(ID id);//根据id判断实体是否存在 Iterable\u0026lt;T\u0026gt; findAll();//查询所有实体,不用或慎用! long count();//查询实体数量 void delete(ID id);//根据Id删除实体 void delete(T entity);//删除一个实体 void delete(Iterable\u0026lt;? extends T\u0026gt; entities);//删除一个实体的集合 void deleteAll();//删除所有实体,不用或慎用!  public interface PersonRepsotory extends CrudRepository\u0026lt;Persion,Integer\u0026gt;{} @Transactional public void savePersons(List\u0026lt;Person\u0026gt; persons){ personRepsotory.save(persons); } @Test public void testCrudReposiory(){ List\u0026lt;Person\u0026gt; persons = new ArrayList\u0026lt;\u0026gt;(); for(int i = 'a'; i \u0026lt;= 'z'; i++){ Person person = new Person(); person.setAddressId(i + 1); person.setBirth(new Date()); person.setEmail((char)i + \u0026quot;\u0026quot; + (char)i + \u0026quot;@atguigu.com\u0026quot;); person.setLastName((char)i + \u0026quot;\u0026quot; + (char)i); persons.add(person); } personService.savePersons(persons); }  PagingAndSortingRepository接口 该接口提供了分页与排序功能\nIterable\u0026lt;T\u0026gt; findAll(Sort sort); //排序 Page\u0026lt;T\u0026gt; findAll(Pageable pageable); //分页查询（含排序功能）  分页与排序 public interface PersonRepsotory extends PagingAndSortingRepository\u0026lt;Person, Integer\u0026gt;{} @Test public void testPagingAndSortingRespository(){ //pageNo 从 0 开始. int pageNo = 6 - 1; int pageSize = 5; //Pageable 接口通常使用的其 PageRequest 实现类. 其中封装了需要分页的信息 //排序相关的. Sort 封装了排序的信息 //Order 是具体针对于某一个属性进行升序还是降序. Order order1 = new Order(Direction.DESC, \u0026quot;id\u0026quot;); Order order2 = new Order(Direction.ASC, \u0026quot;email\u0026quot;); Sort sort = new Sort(order1, order2); PageRequest pageable = new PageRequest(pageNo, pageSize, sort); Page\u0026lt;Person\u0026gt; page = personRepsotory.findAll(pageable); System.out.println(\u0026quot;总记录数: \u0026quot; + page.getTotalElements()); System.out.println(\u0026quot;当前第几页: \u0026quot; + (page.getNumber() + 1)); System.out.println(\u0026quot;总页数: \u0026quot; + page.getTotalPages()); System.out.println(\u0026quot;当前页面的 List: \u0026quot; + page.getContent()); System.out.println(\u0026quot;当前页面的记录数: \u0026quot; + page.getNumberOfElements()); }  JpaRepository接口 该接口提供了JPA的相关功能\nList\u0026lt;T\u0026gt; findAll(); //查找所有实体 List\u0026lt;T\u0026gt; findAll(Sort sort); //排序、查找所有实体 List\u0026lt;T\u0026gt; save(Iterable\u0026lt;? extends T\u0026gt; entities);//保存集合 void flush();//执行缓存与数据库同步 T saveAndFlush(T entity);//强制执行持久化 void deleteInBatch(Iterable\u0026lt;T\u0026gt; entities);//删除一个实体集合  @Test public void testJpaRepository(){ Person person = new Person(); person.setBirth(new Date()); person.setEmail(\u0026quot;xy@atguigu.com\u0026quot;); person.setLastName(\u0026quot;xyz\u0026quot;); person.setId(28); Person person2 = personRepsotory.saveAndFlush(person); System.out.println(person == person2); }  JpaSpecificationExecutor接口 不属于Repository体系，实现一组 JPA Criteria 查询相关的方法\n/** * 目标: 实现带查询条件的分页. id \u0026gt; 5 的条件 * * 调用 JpaSpecificationExecutor 的 Page\u0026lt;T\u0026gt; findAll(Specification\u0026lt;T\u0026gt; spec, Pageable pageable); * Specification: 封装了 JPA Criteria 查询的查询条件 * Pageable: 封装了请求分页的信息: 例如 pageNo, pageSize, Sort */ @Test public void testJpaSpecificationExecutor(){ int pageNo = 3 - 1; int pageSize = 5; PageRequest pageable = new PageRequest(pageNo, pageSize); //通常使用 Specification 的匿名内部类 Specification\u0026lt;Person\u0026gt; specification = new Specification\u0026lt;Person\u0026gt;() { /** * @param *root: 代表查询的实体类. * @param query: 可以从中可到 Root 对象, 即告知 JPA Criteria 查询要查询哪一个实体类. 还可以 * 来添加查询条件, 还可以结合 EntityManager 对象得到最终查询的 TypedQuery 对象. * @param *cb: CriteriaBuilder 对象. 用于创建 Criteria 相关对象的工厂. 当然可以从中获取到 Predicate 对象 * @return: *Predicate 类型, 代表一个查询条件. */ @Override public Predicate toPredicate(Root\u0026lt;Person\u0026gt; root, CriteriaQuery\u0026lt;?\u0026gt; query, CriteriaBuilder cb) { Path path = root.get(\u0026quot;id\u0026quot;); Predicate predicate = cb.gt(path, 5); return predicate; } }; Page\u0026lt;Person\u0026gt; page = personRepsotory.findAll(specification, pageable); System.out.println(\u0026quot;总记录数: \u0026quot; + page.getTotalElements()); System.out.println(\u0026quot;当前第几页: \u0026quot; + (page.getNumber() + 1)); System.out.println(\u0026quot;总页数: \u0026quot; + page.getTotalPages()); System.out.println(\u0026quot;当前页面的 List: \u0026quot; + page.getContent()); System.out.println(\u0026quot;当前页面的记录数: \u0026quot; + page.getNumberOfElements()); }  Specification：封装 JPA Criteria 查询条件。通常使用匿名内部类的方式来创建该接口的对象\n自定义 Repository 方法 为某一个 Repository 上添加自定义方法\n为所有的 Repository 都添加自实现的方法\n为某一个 Repository 上添加自定义方法 步骤：\n 定义一个接口: 声明要添加的, 并自实现的方法 提供该接口的实现类: 类名需在要声明的 Repository 后添加 Impl, 并实现方法 声明 Repository 接口, 并继承 1) 声明的接口 使用.  注意: 默认情况下, Spring Data 会在 base-package 中查找 \u0026ldquo;接口名Impl\u0026rdquo; 作为实现类. 也可以通过　repository-impl-postfix　声明后缀.\npublic interface PersonDao { void test(); } public interface PersonRepsotory extends PersonDao{} public class PersonRepsotoryImpl implements PersonDao { @PersistenceContext private EntityManager entityManager; @Override public void test() { Person person = entityManager.find(Person.class, 11); System.out.println(\u0026quot;--\u0026gt;\u0026quot; + person); } } public void testCustomRepositoryMethod(){ personRepsotory.test(); }  为所有的 Repository 都添加自实现的方法 步骤：\n 声明一个接口, 在该接口中声明需要自定义的方法, 且该接口需要继承 Spring Data 的 Repository.\n 提供 1) 所声明的接口的实现类. 且继承 SimpleJpaRepository, 并提供方法的实现\n 定义 JpaRepositoryFactoryBean 的实现类, 使其生成 1) 定义的接口实现类的对象\n 修改 节点的 factory-class 属性指向 3) 的全类名\n  注意: 全局的扩展实现类不要用 Imp 作为后缀名, 或为全局扩展接口添加 @NoRepositoryBean 注解告知 Spring Data: Spring Data 不把其作为 Repository\n","id":16,"section":"posts","summary":"[源码]() JPA 简介 JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行","tags":["Spring家族"],"title":"SpringData JPA自学笔记","uri":"https://mumulx.github.io/2020/02/springdata/","year":"2020"},{"content":" win10远程桌面连接阿里云centos7.3 使用secureCRT连接到自己的服务器\n安装x windows yum groupinstall -y \u0026quot;X Window System\u0026quot;  查看已安装软件\nyum grouplist  安装桌面\nyum groupinstall \u0026quot;GNOME Desktop\u0026quot; \u0026quot;Graphical Administration Tools\u0026quot;  设置系统以图像化界面启动 ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target  安装xrdp yum install -y xrdp  安装vnc server yum install tigervnc tigervnc-server  启动vncserver，设置开机自启 systemctl start xrdp systemctl enable xrdp systemctl status xrdp.service ss -antup|grep xrdp  重启服务器 reboot  window远程桌面连接 win+r mstsc  输入服务公网ip\n注意的是服务器要配置安全组规则，开放端口3389\n在阿里云实例列表左侧菜单找到网络与安全，打开安全组，右侧选择配置规则\n右上角快速创建规则\n自定义端口\n3389/3389  授权对象\n0.0.0.0/0  可以将一些常见的端口配置进去，在快速创建规则时可以将常用端口打上勾\n另外今后想要访问服务器的某个端口时，先要在服务器开启端口，再在阿里云安全组规则，开放端口\n服务器开启端口 centos7.x用firewall打开80端口\n 关闭与开启防火墙\n启动：systemctl start firewalld 关闭： systemctl stop firewalld  查看防火墙是否开启的状态，以及开放端口的情况\nsystemctl status firewalld.service firewall-cmd --list-all  通过以下命令开放http 80 端口\nfirewall-cmd --add-port=80/tcp --permanent  命令末尾的\u0026ndash;permanent表示用久有效，不加这句的话重启后刚才开放的端口就又失效了\n 然后重启防火墙：\nsudo firewall-cmd --reload  再次查看端口的开放情况：\n firewall-cmd --list-all  ports：里出现了 80 端口\n  然后再阿里云上添加安全组\n在window上配置别名 打开C: \\Windows \\System32\\drivers\\etc \\hosts\n追加:\n公网ip 别名 x.x.x.x myCentos7  今后可以使用别名(myCentos7)代替公网ip\n可以在服务器上安装jdk，部署mysql，部署一些小型项目\nsecureCRT远程连接服务器 默认使用的ssh端口是22，如果修改了端口需要更换端口连接服务器\nEclipse发布项目到github eclipse配置git信息 window-\u0026gt;preferences-\u0026gt;Team-\u0026gt;Git-\u0026gt;Configuration-\u0026gt;UserSettings\u0026ndash;》点击AddEntry…\n添加key(user.name)和value(自己的github名称)\n点击AddEntry…\n添加key(user.email)和value(自己注册github的邮箱)\n也可以直接点击open在文件中设置\n配置ssh General\u0026ndash;》Network connections\u0026ndash;》ssh2\n选择本地的.ssh文件夹\n创建本地git仓库 右键项目\u0026ndash;》Team\u0026ndash;》share Project\n点击 Use or create repository xxxxx\n点击create Repository\n向本地仓库提交项目，填写 Commit信息 右击项目-\u0026gt;Team-\u0026gt;Commit…\n在unstaged Changes中选中要提交的东西，右击add to index （或直接右击项目\u0026ndash;》team\u0026ndash;》add to index） commit\ngithub创建仓库\n将本地仓库项目内容推送到远程仓库（github） 右击项目-\u0026gt;Team-\u0026gt;remote-\u0026gt;push\nURL填写git仓库ssh地址(或http)\n输入用户名密码\n选择master分支\u0026ndash;》add Spec\nnext\u0026ndash;》finish\ncommit and push或commit的区别\ncommit按钮：不能单独的Push某一个文件，只能Push整个项目\ncommit and push可以单独Push某一个文件\n部署tomcat发布项目 参考博客\ncd /app mkdir -p tools cd tools/ wget http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.31/bin/apache-tomcat-9.0.31.tar.gz tar -zxvf apache-tomcat-9.0.31.tar.gz mv apache-tomcat-9.0.31 tomcat9.0.31/ vim /etc/profile  追加\n CATALINA_HOME=/app/tools/tomcat9.0.31 CATALINA_BASE=/app/tools/tomcat9.0.31 PATH=$PATH:$CATALINA_BASE/bin export PATH CATALINA_BASE  cd /app/tools/tomcat9.0.31/conf vi server.xml  修改编码、端口\n\u0026lt;Connector port=\u0026quot;80\u0026quot; protocol=\u0026quot;HTTP/1.1\u0026quot; connectionTimeout=\u0026quot;20000\u0026quot; redirectPort=\u0026quot;8443\u0026quot; URIEncoding=\u0026quot;UTF-8\u0026quot; /\u0026gt;  cd ../bin/ vi catalina.sh  在 # OS specific support. 前面加入如下代码：\nJAVA_HOME=/usr/java/jdk1.8.0_231-amd64 JRE_HOME=$JAVA_HOME/jre  启动\n./startup.sh  将 tomcat9 加入到系统服务列表中：\ncd /etc/init.d vi tomcat9  添加内容\n #tomcat config start - 2019-01-15 #!/bin/bash # description: Tomcat Start Stop Restart # processname: tomcat9 # chkconfig: 2345 20 80 JAVA_HOME=//usr/java/jdk1.8.0_231-amd64/ export JAVA_HOME PATH=$JAVA_HOME/bin:$PATH export PATH CATALINA_HOME=/app/tools/tomcat9.0.31/ case $1 in start) sh $CATALINA_HOME/bin/startup.sh ;; stop) sh $CATALINA_HOME/bin/shutdown.sh ;; restart) sh $CATALINA_HOME/bin/shutdown.sh sh $CATALINA_HOME/bin/startup.sh ;; esac exit 0 #chmod 755 tomcat #chkconfig --add tomcat #chkconfig --level 2345 tomcat on #chkconfig --list tomcat # tomcat config end - 2019-01-15  chmod +x tomcat9 chkconfig --add tomcat9 chkconfig --list  关闭 tomcat9 服务：\nservice tomcat9 stop  启动 tomcat9 服务：\nservice tomcat9 start  重启 tomcat9 服务：\n service tomcat9 restart  部署项目 将项目打成war包\n将war包复制到webapps下\n打开tomcat配置文件，添加虚拟路径\n\u0026lt;Context path=\u0026quot;/LostSomething\u0026quot; docBase=\u0026quot;LostSomething.war\u0026quot; debug=\u0026quot;0\u0026quot; privileged=\u0026quot;true\u0026quot; reloadable=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;Context docBase=\u0026quot;/app/tools/upload\u0026quot; path=\u0026quot;/LostSomething/upload\u0026quot; reloadable=\u0026quot;true\u0026quot;/\u0026gt;  启动tomcat\nservice tomcat9 start  安装RabbitMQ3.6.1 参考博客\ncd /app mkdir -p rabbitmq cd rabbitmq/ yum -y install gcc glibc-devel make ncurses-devel openssl-devel xmlto perl wget wget http://www.erlang.org/download/otp_src_18.3.tar.gz tar -xzvf otp_src_18.3.tar.gz cd otp_src_18.3/ ./configure --prefix=/usr/local/erlang make \u0026amp;\u0026amp; make install vi /etc/profile  #set erlang environment ERL_HOME=/usr/local/erlang PATH=$ERL_HOME/bin:$PATH export ERL_HOME PATH  source /etc/profile erl //测试 cd /app/rabbitmq wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.1/rabbitmq-server-generic-unix-3.6.1.tar.xz xz -d rabbitmq-server-generic-unix-3.6.1.tar.xz tar -xvf rabbitmq-server-generic-unix-3.6.1.tar vi /etc/profile  #set rabbitmq environment export PATH=$PATH:/app/rabbitmq/rabbitmq/sbin  source /etc/profile rabbitmq-server -detached //启动rabbitmq，-detached代表后台守护进程方式启动。 rabbitmqctl status mkdir /etc/rabbitmq rabbitmq-plugins enable rabbitmq_management firewall-cmd --permanent --add-port=15672/tcp firewall-cmd --permanent --add-port=5672/tcp systemctl restart firewalld.service  rabbitmqctl add_user superrd superrd //添加用户，后面两个参数分别是用户名和密码，我这都用superrd了。 rabbitmqctl set_permissions -p / superrd \u0026quot;.*\u0026quot; \u0026quot;.*\u0026quot; \u0026quot;.*\u0026quot; //添加权限 rabbitmqctl set_user_tags superrd administrator //修改用户角色  启动服务：rabbitmq-server -detached【 /usr/local/rabbitmq/sbin/rabbitmq-server -detached 】 查看状态：rabbitmqctl status【 /usr/local/rabbitmq/sbin/rabbitmqctl status 】 关闭服务：rabbitmqctl stop【 /usr/local/rabbitmq/sbin/rabbitmqctl stop 】 列出角色：rabbitmqctl list_users  安装docker uname -r 查看内核版本 要大于3.10 yum install -y yum-utils device-mapper-persistent-data lvm2 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 显示 repo saved to /etc/yum.repos.d/docker-ce.repo yum install -y docker-ce systemctl start docker vim /etc/docker/daemon.json  { \u0026quot;registry-mirrors\u0026quot;: [\u0026quot;https://br10hqrl.mirror.aliyuncs.com\u0026quot;] }  systemctl daemon-reload \u0026amp;\u0026amp; systemctl restart docker  解决zip文件解压中文乱码 安装p7zip\nyum install -y p7zip*  解压文件\n7za x file.zip  安装convmv\nyum -y install convmv  进入中文乱码目录\nconvmv -r -f utf8 -t iso88591 * --notest --nosmart \u0026amp;\u0026amp; convmv -r -f gbk -t utf8 * --notest --nosmart  ","id":17,"section":"posts","summary":"win10远程桌面连接阿里云centos7.3 使用secureCRT连接到自己的服务器 安装x windows yum groupinstall -y \u0026quot;X Window System\u0026quot; 查看已安装软件 yum grouplist 安装桌面 yum groupinstall \u0026quot;GNOME Desktop\u0026quot;","tags":["Linux"],"title":"我的阿里云服务器Centos7","uri":"https://mumulx.github.io/2020/02/%E6%88%91%E7%9A%84%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8centos7/","year":"2020"},{"content":" 搭建ssm环境  jar 表和类 配置数据库db.properties,log4j.properties 加载spring配置文件applicationContext.xml 加载springmvc配置文件applicationContext-controller.xml spring加载数据库文件 配置mybatis的sqlSessionFactory 配置psringmvc视图解析器  数据库设计 用户: 学号,登录密码,所在学院,姓名,性别,学生照片,出生日期,联系电话,家庭地址 学院: 学院id,学院名称 寻物启事: 寻物id,标题,丢失物品,物品照片,丢失时间,丢失地点,物品描述,报酬,联系电话,学生,发布时间 失物招领: 招领id,标题,物品名称,捡得时间,拾得地点,描述说明,联系人,联系电话,发布时间 认领: 认领id,招领信息,认领人,认领时间,描述说明,发布时间 表扬: 表扬id,招领信息,标题,表扬内容,表扬时间 站内通知: 通知id,标题,内容,发布时间  springmvc处理静态文件 添加配置\n\u0026lt;!-- SPringMVC基础配置、标配 --\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt; \u0026lt;!-- 处理静态资源 --\u0026gt; \u0026lt;mvc:default-servlet-handler\u0026gt;\u0026lt;/mvc:default-servlet-handler\u0026gt;  上传文件 \u0026lt;bean id=\u0026quot;multipartResolver\u0026quot; class=\u0026quot;org.springframework.web.multipart.commons.CommonsMultipartResolver\u0026quot;\u0026gt; \u0026lt;!-- 设置编码 --\u0026gt; \u0026lt;property name=\u0026quot;defaultEncoding\u0026quot; value=\u0026quot;UTF-8\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 设置上传文件的最大尺寸为2MB --\u0026gt; \u0026lt;property name=\u0026quot;maxUploadSize\u0026quot;\u0026gt; \u0026lt;value\u0026gt;2097152\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  bootstracp组件失灵  js文件引用顺序\n 先jquery 再引用bootstracp文件  jquery引用重复并且版本不对\n  tomcat配置虚拟路径实现访问本地文件 当客户端需要上传文件到服务器的时候，服务器需要将文件存放到本地中，如果保存在本项目的某个文件夹中时如上传的目录 upload ：（http://localhost:8888/LostSomething/upload/）\n//String photoBookRealPathDir = request.getSession().getServletContext().getRealPath(photoBookPathDir);  这是发现会丢失上传的文件\n 如果修改代码，则在tomcat重新启动时 会被删除\n原因：当修改代码的时候,tomcat会重新编译一份class 并且重新部署（重新创建各种目录）\n 如果不修改代码，则不会删除\n原因： 没有修改代码，class仍然是之前的class\n  因此，为了防止 上传目录丢失\n 配置虚拟路径\n 更换上传目录 到非tomcat目录\n  将文件上传到String photoBookRealPathDir = \u0026quot;C:\\\\workplace\\\\STS\\\\MyProject\\\\upload\u0026quot;; 本地计算机的某个文件夹中。\n当用户需要访问这个图片的时候，如果直接填写文件的本地路径如：\nString filePath = \u0026quot;C:\\\\workplace\\\\STS\\\\MyProject\\\\\u0026quot;; request.setAttribute(\u0026quot;filePath\u0026quot;, filePath);  \u0026lt;% String filePath=(String)request.getAttribute(\u0026quot;filePath\u0026quot;); %\u0026gt; \u0026lt;img class=\u0026quot;img-responsive\u0026quot; src=\u0026quot;\u0026lt;%=filePath%\u0026gt;\u0026lt;%=userInfo.getUserPhoto()%\u0026gt;\u0026quot; /\u0026gt;  会发现文件的请求为Request URL: file:///C:/workplace/STS/MyProject/upload/NoImage.jpg 这根本就不是一个请求，当然是访问不到文件的\n因此我们需要借助虚拟路径来解决，当用户访问upload请求时实际上访问的时本地的文件中\n在tomcat配置文件的host标签中添加子标签\n\u0026lt;Context docBase=\u0026quot;C:\\workplace\\STS\\MyProject\\upload\u0026quot; path=\u0026quot;/upload\u0026quot;/\u0026gt;  \u0026lt;% String basePath = request.getScheme()+\u0026quot;://\u0026quot;+request.getServerName()+\u0026quot;:\u0026quot;+request.getServerPort()+path+\u0026quot;/\u0026quot;; %\u0026gt; \u0026lt;img class=\u0026quot;img-responsive\u0026quot; src=\u0026quot;\u0026lt;%=basePath%\u0026gt;\u0026lt;%=userInfo.getUserPhoto()%\u0026gt;\u0026quot; /\u0026gt;  此时的请求为Request URL: http://localhost:8888/LostSomething/upload/NoImage.jpg,但是实际上请求的是 C:\\workplace\\STS\\MyProject\\upload\\NoImage.jpg\n这样就可以防止上传文件的丢失\n但是在Eclipse中运行的话需要配置项目的根目录（或者双击servers在moudles中配置）\n\u0026lt;Context docBase=\u0026quot;C:\\workplace\\STS\\MyProject\\upload\u0026quot; path=\u0026quot;/LostSomething/upload\u0026quot; reloadable=\u0026quot;true\u0026quot;/\u0026gt;  定义长传文件的本地保存位置\nprivate static final String UPLADMIMGSRC = \u0026quot;C:\\\\workplace\\\\STS\\\\MyProject\u0026quot;;  处理文件\n/* * * 处理图片文件上传，返回保存的文件名路径 * fileKeyName: 图片上传表单key * @throws IOException * @throws IllegalStateException */ public String handlePhotoUpload(HttpServletRequest request,String fileKeyName) throws IllegalStateException, IOException { // 设置默认的文件名 String fileName = \u0026quot;upload/NoImage.jpg\u0026quot;; MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request; /**构建图片保存的目录**/ String photoBookPathDir = \u0026quot;/upload\u0026quot;; /**得到图片保存目录的真实路径**/ //String photoBookRealPathDir = request.getSession().getServletContext().getRealPath(photoBookPathDir); // 保存在本地文件夹，因为tomcat在项目修改代码后会清理文件夹 HelpDev helpdev = new HelpDev(); String photoBookRealPathDir = helpdev.getUPLADMIMGSRC()+photoBookPathDir; /**根据真实路径创建目录**/ File photoBookSaveFile = new File(photoBookRealPathDir); if(!photoBookSaveFile.exists()) photoBookSaveFile.mkdirs(); /**页面控件的文件流**/ MultipartFile multipartFile_photoBook = multipartRequest.getFile(fileKeyName); if(!multipartFile_photoBook.isEmpty()) { /**获取文件的后缀**/ String suffix = multipartFile_photoBook.getOriginalFilename().substring (multipartFile_photoBook.getOriginalFilename().lastIndexOf(\u0026quot;.\u0026quot;)); String smallSuffix = suffix.toLowerCase(); if(!smallSuffix.equals(\u0026quot;.jpg\u0026quot;) \u0026amp;\u0026amp; !smallSuffix.equals(\u0026quot;.gif\u0026quot;) \u0026amp;\u0026amp; !smallSuffix.equals(\u0026quot;.png\u0026quot;) ) throw new UserException(\u0026quot;图片格式不正确！\u0026quot;); /**使用UUID生成文件名称**/ String photoBookFileName = UUID.randomUUID().toString()+ suffix;//构建文件名称 //String logImageName = multipartFile.getOriginalFilename(); /**拼成完整的文件保存路径加文件**/ String photoBookFilePath = photoBookRealPathDir + File.separator + photoBookFileName; File photoBookFile = new File(photoBookFilePath); multipartFile_photoBook.transferTo(photoBookFile); fileName = \u0026quot;upload/\u0026quot; + photoBookFileName; } return fileName; }  \u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt; \u0026lt;label for=\u0026quot;userInfo_userPhoto_header\u0026quot; class=\u0026quot;col-md-3 text-right\u0026quot;\u0026gt;学生照片:\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026quot;col-md-8\u0026quot;\u0026gt; \u0026lt;img class=\u0026quot;img-responsive\u0026quot; id=\u0026quot;userInfo_userPhotoImg\u0026quot; border=\u0026quot;0px\u0026quot; /\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; id=\u0026quot;userInfo_userPhoto_header\u0026quot; name=\u0026quot;userInfo.userPhoto\u0026quot; /\u0026gt; \u0026lt;input id=\u0026quot;userPhotoFile_header\u0026quot; name=\u0026quot;userPhotoFile\u0026quot; type=\u0026quot;file\u0026quot; size=\u0026quot;50\u0026quot; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   img:显示选择的图片\n hidden可以保存已经上传的图片的一些信息，帮助我们更新信息的时候判断图片是否更新，如果用户更新了图片，我们需要将旧的文件删除，再保存新的文件。我们如何知道用户是否更新了文件，可以将hidden中保存的信息和file组件中的信息进行对比\n file：文件上传组件\n/* ajax方式更新用户信息 */ @RequestMapping(value = \u0026quot;/{user_name}/update\u0026quot;, method = RequestMethod.POST) public void update(@Validated UserInfo userInfo, BindingResult br, Model model, HttpServletRequest request, HttpServletResponse response) throws Exception { String message = \u0026quot;\u0026quot;; boolean success = false; if (br.hasErrors()) { message = \u0026quot;输入的信息有错误！\u0026quot;; writeJsonResponse(response, success, message); return; } String userPhotoFileName = this.handlePhotoUpload(request, \u0026quot;userPhotoFile\u0026quot;); // 重新选择了头像就赋值 if (!userPhotoFileName.equals(\u0026quot;upload/NoImage.jpg\u0026quot;)) { // 删除用户头像文件 String imgSrc = userInfo.getUserPhoto(); userInfoService.getHelpDev().deleteImgPhoto(imgSrc); // 重新赋值用户头像文件 userInfo.setUserPhoto(userPhotoFileName); } else { // 没有选择头像，就不修改 userInfo.setUserPhoto(null); } try { userInfoService.updateUserInfo(userInfo); message = \u0026quot;用户更新成功!\u0026quot;; success = true; writeJsonResponse(response, success, message); } catch (Exception e) { e.printStackTrace(); message = \u0026quot;用户更新失败!\u0026quot;; writeJsonResponse(response, success, message); } }  //删除本地图片 public void deleteImgPhoto(String imgSrc) { if(!imgSrc.equals(\u0026quot;upload/NoImage.jpg\u0026quot;)) { File file = new File(UPLADMIMGSRC+\u0026quot;\\\\\u0026quot;+imgSrc); if(file.isFile()\u0026amp;\u0026amp; file.exists()){ file.delete(); } } }  /*更新用户记录*/ public void updateUserInfo(UserInfo userInfo) throws Exception { String pwd = userInfo.getPassword(); //用户对密码进行了修改，进行加密 if(pwd!=null \u0026amp;\u0026amp; !pwd.equals(\u0026quot;\u0026quot;)) { pwd=helpDev.md5Encode(pwd.getBytes()); }else { //没进行密码修改给密码赋默认值，方便mybatis进行更新 pwd=null; } userInfo.setPassword(pwd); userInfoMapper.updateUserInfo(userInfo); }  \u0026lt;!-- 更新用户记录 --\u0026gt; \u0026lt;update id=\u0026quot;updateUserInfo\u0026quot; parameterType=\u0026quot;userInfo\u0026quot;\u0026gt; update t_userInfo set \u0026lt;if test=\u0026quot;password!=null and password!=''\u0026quot;\u0026gt; password=#{password}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;userPhoto!=null and userPhoto!=''\u0026quot;\u0026gt; userPhoto=#{userPhoto}, \u0026lt;/if\u0026gt; areaObj=#{areaObj.areaId},name=#{name},sex=#{sex},birthday=#{birthday},telephone=#{telephone},address=#{address} where user_name = #{user_name} \u0026lt;/update\u0026gt;   mybatis使用if标签进行判断\n封装返回ajax请求的响应的方法 /* 向客户端输出操作成功或失败信息 */ public void writeJsonResponse(HttpServletResponse response, boolean success, String message) throws IOException, JSONException { response.setContentType(\u0026quot;text/json;charset=UTF-8\u0026quot;); PrintWriter out = response.getWriter(); // 将要被返回到客户端的对象 JSONObject json = new JSONObject(); json.accumulate(\u0026quot;success\u0026quot;, success); json.accumulate(\u0026quot;message\u0026quot;, message); out.println(json.toString()); out.flush(); out.close(); }  可以将常用的方法，属性封装成一个类，我们在需要使用他们呢的时候就可以继承它或，把它的一个对象作为自己的成员。\npublic class UserInfoController extends HelpDevController {}  private HelpDev helpDev;  快速返回上一个url \u0026lt;button onclick=\u0026quot;history.back();\u0026quot;\u0026gt;返回\u0026lt;/button\u0026gt;  back() 方法可加载历史列表中的前一个 URL（如果存在）。\n调用该方法的效果等价于点击后退按钮或调用 history.go(-1)。\nhistory 是js的内置对象\n页面刷新 window.location.reload();  更新用户信息问题 由于对用户的密码进行了MD5进行加密，因此我们实际上是不知道用户的密码的，因此在做用户修改个人信息的时候，显示要显示用户的信息，密码的话，我们不能直接显示给用户，因此密码的input框的值是空的，这时用户提交更新的请求就有两种情况了，一种是用户进行了密码修改，一种是用户对密码没有进行操作，此时密码为空，那么我们在写sql语句的时候就需要判断一下密码是否为空（别忘了对修改的密码进行加密），可以使用if标签来实现if判断\n\u0026lt;if test=\u0026quot;password!=null and password!=''\u0026quot;\u0026gt; password=#{password}, \u0026lt;/if\u0026gt;  用户上传的照片也是同理，在更新时也要判断一下，用户是否对照片进行了更改，\n总结，在更新时注意判断值是否改变以及是否为空的问题\n删除用户信息 也要对用户的图片进行删除，以及在更新静态资源（用户的头像，图片文件）进行更新时考虑是否将旧的文件进行删除，之后再更新\nspringmvc捕获上传文件太大的异常并返回客户端 \u0026lt;bean id=\u0026quot;multipartResolver\u0026quot; class=\u0026quot;org.springframework.web.multipart.commons.CommonsMultipartResolver\u0026quot;\u0026gt; \u0026lt;!-- 设置上传文件的最大尺寸为2MB --\u0026gt; \u0026lt;property name=\u0026quot;maxUploadSize\u0026quot;\u0026gt; \u0026lt;value\u0026gt;2097152\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- SpringMVC在超出上传文件限制时，会抛出org.springframework.web.multipart.MaxUploadSizeExceededException --\u0026gt; \u0026lt;!-- 该异常是SpringMVC在检查上传的文件信息时抛出来的，而且此时还没有进入到Controller方法中 --\u0026gt; \u0026lt;bean id=\u0026quot;exceptionResolver\u0026quot; class=\u0026quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;exceptionMappings\u0026quot;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;!-- 遇到MaxUploadSizeExceededException异常时，自动跳转到upload_error页面 --\u0026gt; \u0026lt;prop key=\u0026quot;org.springframework.web.multipart.MaxUploadSizeExceededException\u0026quot;\u0026gt;upload_error\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026quot;com.chengxusheji.utils.UserException\u0026quot;\u0026gt;user_error\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  这两个一个是设置上传文件的格式，一个是捕获异常，SimpleMappingExceptionResolver是spring内部帮我们实现好的一个类，它可以帮助我们捕获异常，但是遗憾的是，它对ajax请求就不是很友好，它不支持ajax请求，这是我们使用ajax上传文件的时候，当文件太大是，会触发MaxUploadSizeExceededException这个异常，这时就需要我们实现捕获异常\n一般我们想实现某种功能无非是先实现功能再配置，这时我们需要继承SimpleMappingExceptionResolver并重写doResolveException方法\npublic class MaxUploadSizeExceptionResolver extends SimpleMappingExceptionResolver { private static Logger log = Logger.getLogger(MaxUploadSizeExceptionResolver.class); public static final String UTF_8 = \u0026quot;utf-8\u0026quot;; public static final String ACCEPT = \u0026quot;accept\u0026quot;; public static final String APPLICATION_JSON = \u0026quot;application/json\u0026quot;; public static final String X_REQUESTED_WITH = \u0026quot;X-Requested-With\u0026quot;; public static final String XML_HTTP_REQUEST = \u0026quot;XMLHttpRequest\u0026quot;; public static final String APPLICATION_JSON_CHARSET_UTF_8 = \u0026quot;application/json; charset=utf-8\u0026quot;; /** * 重写Spring统一异常处理方法 */ @Override protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { ModelAndView mv = new ModelAndView(\u0026quot;error\u0026quot;); //文件太大异常 if(MaxUploadSizeExceededException.class.isInstance(ex)) { response.setContentType(\u0026quot;text/json;charset=UTF-8\u0026quot;); try { PrintWriter out = response.getWriter(); //将要被返回到客户端的对象 JSONObject json=new JSONObject(); boolean success=false; String message=\u0026quot;图片太大！\u0026quot;; json.accumulate(\u0026quot;success\u0026quot;, success); json.accumulate(\u0026quot;message\u0026quot;, message); out.println(json.toString()); out.flush(); out.close(); return null; } catch (Exception e) { // TODO: handle exception return null; } }else { mv.addObject(\u0026quot;exception\u0026quot;,ex.toString()); } return mv; } }  但是这样之后会捕捉所有的异常，因此要对异常进行判断，什么异常做什么处理。（个人感觉怪怪的）\n该方法的核心是要像ajax返回json数据，告知ajax文件过大的信息，让它提醒用户，更换文件，可以发现它的功能和controller的功能类似，因此可以向写controller那样编写\n配置\n将异常类纳入ioc\n\u0026lt;bean id=\u0026quot;exceptionResolver\u0026quot; class=\u0026quot;org.ycit.util.exception.MaxUploadSizeExceptionResolver\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;exceptionMappings\u0026quot;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026quot;org.springframework.web.multipart.MaxUploadSizeExceededException\u0026quot;\u0026gt;upload_error\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  @Autowired 与@Resource的区别 @Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。\n@Autowired通过byName自动注入\n@Autowired @Qualifier(\u0026quot;xx\u0026quot;)  @Resource通过属性name指定通过byName注入\n@Resource(name = \u0026quot;userInfoService\u0026quot;)  @Validated数据校验和@Valid数据校验 参考博客\n@Valid  在属性前加注解\npublic class Student { @Past//当前时间以前 private Date birthday ; }  在校验的Controller中 ，给校验的对象前增加 @Valid\npublic String testDateTimeFormat(@Valid Student student, BindingResult result ,Map\u0026lt;String,Object\u0026gt; map) {   @Validated  在属性前加注解\npublic class UserInfo { @NotEmpty(message=\u0026quot;学号不能为空\u0026quot;) private String user_name; }  在校验的Controller中 ，给校验的对象前增加 @Valid\nublic void add(@Validated LookingFor lookingFor, BindingResult br, Model model, HttpServletRequest request,HttpServletResponse response){}   分页查询问题 分页 我们要将数据库中的东西显示在页面上，当数据有很多时，一页时不可能全部显示出来的因此需要对结果进行分页，此时需要的请求参数有，第几页\n响应的参数有\n 当前页的所有数据的集合 总共的页数 数据的总数 当前页  当我们需要增加搜索查询时，需要客户端提交的东西包括，搜索的信息，以及第几页，这和我们显示所有结果是类似的，只不过显示所有结果的查询条件为空。因此搜索查询可以和分页写在一起，分页是查询条件为空的搜索查询\n/* 前台按照查询条件分页查询用户信息 */ @RequestMapping(value = { \u0026quot;/frontlist\u0026quot; }, method = { RequestMethod.GET, RequestMethod.POST }) public String frontlist(String user_name, @ModelAttribute(\u0026quot;areaObj\u0026quot;) Area areaObj, String name, String birthday, String telephone, Integer currentPage, Model model, HttpServletRequest request) throws Exception { if (currentPage == null || currentPage == 0) currentPage = 1; if (user_name == null) user_name = \u0026quot;\u0026quot;; if (name == null) name = \u0026quot;\u0026quot;; if (birthday == null) birthday = \u0026quot;\u0026quot;; if (telephone == null) telephone = \u0026quot;\u0026quot;; // 查询当前页数据 List\u0026lt;UserInfo\u0026gt; userInfoList = userInfoService.queryUserInfo(user_name, areaObj, name, birthday, telephone,currentPage); /* 计算总的页数和总的记录数 */ userInfoService.queryTotalPageAndRecordNumber(user_name, areaObj, name, birthday, telephone); /* 获取到总的页码数目 */ int totalPage = userInfoService.getHelpDev().getTotalPage(); /* 当前查询条件下总记录数 */ int recordNumber = userInfoService.getHelpDev().getRecordNumber(); request.setAttribute(\u0026quot;userInfoList\u0026quot;, userInfoList); request.setAttribute(\u0026quot;totalPage\u0026quot;, totalPage); request.setAttribute(\u0026quot;recordNumber\u0026quot;, recordNumber); request.setAttribute(\u0026quot;currentPage\u0026quot;, currentPage); request.setAttribute(\u0026quot;user_name\u0026quot;, user_name); request.setAttribute(\u0026quot;areaObj\u0026quot;, areaObj); request.setAttribute(\u0026quot;name\u0026quot;, name); request.setAttribute(\u0026quot;birthday\u0026quot;, birthday); request.setAttribute(\u0026quot;telephone\u0026quot;, telephone); List\u0026lt;Area\u0026gt; areaList = areaService.queryAllArea(); request.setAttribute(\u0026quot;areaList\u0026quot;, areaList); return \u0026quot;UserInfo/userInfo_frontquery_result\u0026quot;; }  要对查询的条件进行初始化操作，当查询条件为空时，仅仅为普通的分页。\n/*按照查询条件分页查询用户记录*/ public ArrayList\u0026lt;UserInfo\u0026gt; queryUserInfo(String user_name,Area areaObj,String name,String birthday,String telephone,int currentPage) throws Exception { String where = \u0026quot;where 1=1\u0026quot;; if(!user_name.equals(\u0026quot;\u0026quot;)) where = where + \u0026quot; and t_userInfo.user_name like '%\u0026quot; + user_name + \u0026quot;%'\u0026quot;; if(null != areaObj \u0026amp;\u0026amp; areaObj.getAreaId()!= null \u0026amp;\u0026amp; areaObj.getAreaId()!= 0) where += \u0026quot; and t_userInfo.areaObj=\u0026quot; + areaObj.getAreaId(); if(!name.equals(\u0026quot;\u0026quot;)) where = where + \u0026quot; and t_userInfo.name like '%\u0026quot; + name + \u0026quot;%'\u0026quot;; if(!birthday.equals(\u0026quot;\u0026quot;)) where = where + \u0026quot; and t_userInfo.birthday like '%\u0026quot; + birthday + \u0026quot;%'\u0026quot;; if(!telephone.equals(\u0026quot;\u0026quot;)) where = where + \u0026quot; and t_userInfo.telephone like '%\u0026quot; + telephone + \u0026quot;%'\u0026quot;; int startIndex = (currentPage-1) * this.helpDev.getRows(); return userInfoMapper.queryUserInfo(where, startIndex, this.helpDev.getRows()); } /*当前查询条件下计算总的页数和记录数*/ public void queryTotalPageAndRecordNumber(String user_name,Area areaObj,String name,String birthday,String telephone) throws Exception { String where = \u0026quot;where 1=1\u0026quot;; if(!user_name.equals(\u0026quot;\u0026quot;)) where = where + \u0026quot; and t_userInfo.user_name like '%\u0026quot; + user_name + \u0026quot;%'\u0026quot;; if(null != areaObj \u0026amp;\u0026amp; areaObj.getAreaId()!= null \u0026amp;\u0026amp; areaObj.getAreaId()!= 0) where += \u0026quot; and t_userInfo.areaObj=\u0026quot; + areaObj.getAreaId(); if(!name.equals(\u0026quot;\u0026quot;)) where = where + \u0026quot; and t_userInfo.name like '%\u0026quot; + name + \u0026quot;%'\u0026quot;; if(!birthday.equals(\u0026quot;\u0026quot;)) where = where + \u0026quot; and t_userInfo.birthday like '%\u0026quot; + birthday + \u0026quot;%'\u0026quot;; if(!telephone.equals(\u0026quot;\u0026quot;)) where = where + \u0026quot; and t_userInfo.telephone like '%\u0026quot; + telephone + \u0026quot;%'\u0026quot;; this.helpDev.computeTotalPag(userInfoMapper.queryUserInfoCount(where)); }  //计算总的页数 public void computeTotalPag(int rm) { this.recordNumber=rm; int mod = this.recordNumber % this.rows; this.totalPage = this.recordNumber / this.rows; if(mod != 0) this.totalPage++; }  \u0026lt;!-- 按照查询条件的用户记录数 --\u0026gt; \u0026lt;select id=\u0026quot;queryUserInfoCount\u0026quot; resultType=\u0026quot;int\u0026quot;\u0026gt; select count(*) from t_userInfo,t_area ${where} and t_userInfo.areaObj = t_area.areaId \u0026lt;/select\u0026gt; \u0026lt;!-- 按照查询条件分页查询用户记录 --\u0026gt; \u0026lt;select id=\u0026quot;queryUserInfo\u0026quot; resultMap=\u0026quot;userInfoMap\u0026quot; \u0026gt; select t_userInfo.* from t_userInfo,t_area ${where} and t_userInfo.areaObj = t_area.areaId limit #{startIndex},#{pageSize} \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026quot;userInfoMap\u0026quot; type=\u0026quot;userInfo\u0026quot;\u0026gt; \u0026lt;id property=\u0026quot;user_name\u0026quot; column=\u0026quot;user_name\u0026quot; /\u0026gt; \u0026lt;association property=\u0026quot;areaObj\u0026quot; column=\u0026quot;areaObj\u0026quot; select=\u0026quot;com.mumulx.mapper.AreaMapper.getArea\u0026quot; /\u0026gt; \u0026lt;/resultMap\u0026gt;  在查询数据库的当页数据时，我们又需要知道，当前页面显示几条数据\n@ModelAttribute和@RequestParam 参考博客\n连接远程mysql显示表不存在 更改数据的配置文件，让大小写不敏感\nvi /etc/my.cnf  在[mysqld]下添加\nlower_case_table_names=1  重启mysql\nservice mysql restart  @SessionAttributes @Controller @SessionAttributes(\u0026quot;username\u0026quot;) public class SystemController { @RequestMapping(value=\u0026quot;/login\u0026quot;,method=RequestMethod.POST) public void login(Model model){ } }   处理方法login在model中存放了属性名为username的数据， 处理结束后,model里的数据会被放入到request中,页面通过request域可以获取到。 而这里使用了@SessionAttributes(\u0026quot;username\u0026quot;)将model中属性名为username的数据复制一份进了session域中.  ","id":18,"section":"posts","summary":"搭建ssm环境 jar 表和类 配置数据库db.properties,log4j.properties 加载spring配置文件applicationC","tags":["其他问题"],"title":"校园失物招领项目实战","uri":"https://mumulx.github.io/2020/02/%E6%A0%A1%E5%9B%AD%E5%A4%B1%E7%89%A9%E6%8B%9B%E9%A2%86%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/","year":"2020"},{"content":" 源码\nSpringboot整合缓存 JSR-107、Spring缓存抽象、整合Redis\nJSR107 Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry\n和 Expiry。\n CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可  以在运行期访问多个CachingProvider。\n CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache  存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。\n Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个  CacheManager所拥有。\n Entry**是一个存储在Cache中的key-value对。\n Expiry 每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期\n  的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。\nSpring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；\n并支持使用JCache（JSR-107）注解简化我们开发；\n Cache接口为缓存的组件规范定义，包含缓存的各种操作集合；\n Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache , ConcurrentMapCache等；\n 每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。\n 使用Spring缓存抽象时我们需要关注以下两点；\n 确定方法需要被缓存以及他们的缓存策略\n 从缓存中读取之前缓存存储的数据\n   几个重要概念\u0026amp;缓存注解    Cache 缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache**等     CacheManager 缓存管理器，管理各种缓存（Cache）组件   @Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存   @CacheEvict 清空缓存   @CachePut 保证方法被调用，又希望结果被缓存。   @EnableCaching 开启基于注解的缓存   keyGenerator 缓存数据时key生成策略   serialize 缓存数据时value序列化策略    搭建环境 数据库 SET FOREIGN_KEY_CHECKS=0; -- ---------------------------- -- Table structure for department -- ---------------------------- DROP TABLE IF EXISTS `department`; CREATE TABLE `department` ( `id` int(11) NOT NULL AUTO_INCREMENT, `departmentName` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- ---------------------------- -- Table structure for employee -- ---------------------------- DROP TABLE IF EXISTS `employee`; CREATE TABLE `employee` ( `id` int(11) NOT NULL AUTO_INCREMENT, `lastName` varchar(255) DEFAULT NULL, `email` varchar(255) DEFAULT NULL, `gender` int(2) DEFAULT NULL, `d_id` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;  创建实体类\npublic class Department { private Integer id; private String departmentName; public Department() { super(); // TODO Auto-generated constructor stub } public Department(Integer id, String departmentName) { super(); this.id = id; this.departmentName = departmentName; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getDepartmentName() { return departmentName; } public void setDepartmentName(String departmentName) { this.departmentName = departmentName; } @Override public String toString() { return \u0026quot;Department [id=\u0026quot; + id + \u0026quot;, departmentName=\u0026quot; + departmentName + \u0026quot;]\u0026quot;; } } public class Employee { private Integer id; private String lastName; private String email; private Integer gender; //性别 1男 0女 private Integer dId; public Employee() { super(); } public Employee(Integer id, String lastName, String email, Integer gender, Integer dId) { super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; this.dId = dId; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Integer getGender() { return gender; } public void setGender(Integer gender) { this.gender = gender; } public Integer getdId() { return dId; } public void setdId(Integer dId) { this.dId = dId; } @Override public String toString() { return \u0026quot;Employee [id=\u0026quot; + id + \u0026quot;, lastName=\u0026quot; + lastName + \u0026quot;, email=\u0026quot; + email + \u0026quot;, gender=\u0026quot; + gender + \u0026quot;, dId=\u0026quot; + dId + \u0026quot;]\u0026quot;; } }  整合mybatis操作数据库\n1）、配置数据源信息\n配置文件application.properties\nspring.datasource.url=jdbc:mysql://localhost:3306/spring_cache spring.datasource.username=root spring.datasource.password=123456 #spring.datasource.driver-class-name=com.mysql.jdbc.Driver # \\u5F00\\u542F\\u9A7C\\u5CF0\\u547D\\u540D\\u5339\\u914D\\u89C4\\u5219 mybatis.configuration.map-underscore-to-camel-case=true logging.level.com.atguigu.cache.mapper=debug debug=true spring.redis.host=118.24.44.169  2）、使用注解版的mybatis\nmapper文件\n@Mapper public interface EmployeeMapper { @Select(\u0026quot;SELECT * FROM employee WHERE id = #{id}\u0026quot;) public Employee getEmpById(Integer id); @Update(\u0026quot;UPDATE employee SET lastName=#{lastName},email=#{email},gender=#{gender},d_id=#{dId} WHERE id=#{id}\u0026quot;) public void updateEmp(Employee employee); @Delete(\u0026quot;DELETE FROM employee WHERE id=#{id}\u0026quot;) public void deleteEmpById(Integer id); @Insert(\u0026quot;INSERT INTO employee(lastName,email,gender,d_id) VALUES(#{lastName},#{email},#{gender},#{dId})\u0026quot;) public void insertEmployee(Employee employee); @Select(\u0026quot;SELECT * FROM employee WHERE lastName = #{lastName}\u0026quot;) Employee getEmpByLastName(String lastName); }  @Mapper public interface DepartmentMapper { @Select(\u0026quot;SELECT * FROM department WHERE id = #{id}\u0026quot;) Department getDeptById(Integer id); }  缓存 步骤\n 开启基于注解的缓存\n​\n​ @EnableCaching\n 标注缓存注解\n​\n​ @Cacheable\n​ @CacheEvict\n1）、开启缓存 /** * 一、搭建基本环境 * 1、导入数据库文件 创建出department和employee表 * 2、创建javaBean封装数据 * 3、整合MyBatis操作数据库 * 1.配置数据源信息 * 2.使用注解版的MyBatis； * 1）、@MapperScan指定需要扫描的mapper接口所在的包 * 二、快速体验缓存 * 步骤： * 1、开启基于注解的缓存 @EnableCaching * 2、标注缓存注解即可 * @Cacheable * @CacheEvict * @CachePut * 默认使用的是ConcurrentMapCacheManager==ConcurrentMapCache；将数据保存在 ConcurrentMap\u0026lt;Object, Object\u0026gt;中 * */ @MapperScan(\u0026quot;com.atguigu.cache.mapper\u0026quot;) @SpringBootApplication @EnableCaching public class Springboot01CacheApplication { public static void main(String[] args) { SpringApplication.run(Springboot01CacheApplication.class, args); } }  2）、使用缓存 @Cacheable(value = {\u0026quot;emp\u0026quot;}/*,keyGenerator = \u0026quot;myKeyGenerator\u0026quot;,condition = \u0026quot;#a0\u0026gt;1\u0026quot;,unless = \u0026quot;#a0==2\u0026quot;*/) public Employee getEmp(Integer id){ System.out.println(\u0026quot;查询\u0026quot;+id+\u0026quot;号员工\u0026quot;); Employee emp = employeeMapper.getEmpById(id); return emp; }   几个属性： * cacheNames/value：指定缓存组件的名字;将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存；  ​\n​\n​ * key：缓存数据使用的key；可以用它来指定。默认是使用方法参数的值 1-方法的返回值 ​\n​  编写SpEL； `#i d;参数id的值 #a0 #p0 #root.args[0]` ​ getEmp[2] ​\n​\n* keyGenerator：key的生成器；可以自己指定key的生成器的组件id  ​\n key/keyGenerator：二选一使用;  ​\n​ * cacheManager：指定缓存管理器；或者cacheResolver指定获取解析器 ​\n​ * condition：指定符合条件的情况下才缓存；\ncondition = \u0026ldquo;#id\u0026gt;0\u0026rdquo;\ncondition = \u0026ldquo;#a0\u0026gt;1\u0026rdquo;：第一个参数的值》1的时候才进行缓存\n* unless:否定缓存；当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判断  ​\n​\n​  ​ unless = \u0026quot;#result == null\u0026quot; ​ unless = \u0026quot;#a0==2\u0026quot;:如果第一个参数的值是2，结果不缓存； ​ ​\n​ sync：是否使用异步模式 ​\n@param id\n @return  将方法的运行结果进行缓存；以后再要相同的数据，直接从缓存中获取，不用调用方法；\nCacheManager管理多个Cache组件的，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一一个名字；\n原理：\n1）、自动配置类；CacheAutoConfiguration\n2）、缓存的配置类\norg.springframework.boot.autoconfigure.cache.GenericCacheConfiguration org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration org.springframework.boot.autoconfigure.cache.EhCacheCacheConfiguration org.springframework.boot.autoconfigure.cache.HazelcastCacheConfiguration org.springframework.boot.autoconfigure.cache.InfinispanCacheConfiguration org.springframework.boot.autoconfigure.cache.CouchbaseCacheConfiguration org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration org.springframework.boot.autoconfigure.cache.CaffeineCacheConfiguration org.springframework.boot.autoconfigure.cache.GuavaCacheConfiguration org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration【默认】 org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration  3)、 个配置类默认生效：SimpleCacheConfiguration；\n4)、给容器中注册了一个CacheManager：ConcurrentMapCacheManager\n5)、可以获取和创建ConcurrentMapCache类型的缓存组件；他的作用将数据保存在ConcurrentMap中；\n运行流程：\n@Cacheable：\n1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取；（CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建。\n2、去Cache中查找缓存的内容，使用一个key，默认就是方法的参数；\nkey是按照某种策略生成的；默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key；\nSimpleKeyGenerator生成key的默认策略；\n如果没有参数；key=new SimpleKey()；\n如果有一个参数：key=参数的值\n如果有多个参数：key=new SimpleKey(params)；\n3、没有查到缓存就调用目标方法；\n4、将目标方法返回的结果，放进缓存中\n@Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存，\n如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据；\n核心：\n1）、使用CacheManager【ConcurrentMapCacheManager】按照名字得到Cache【ConcurrentMapCache】组件\n2）、key使用keyGenerator生成的，默认是SimpleKeyGenerator\n开发中使用缓存中间件；redis、memcached、ehcache；\n整合redis作为缓存 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。\n1、安装redis：使用docker；\ndocker pull registry.docker-cn.com/library/redis docker images docker run -d -p 6379:6379 --name myredis registry.docker-cn.com/library/redis docker ps  2、引入redis的starter\n3、配置redis\n4、测试缓存\n原理：CacheManager===Cache 缓存组件来实际给缓存中存取数据\n1）、引入redis的starter，容器中保存的是 RedisCacheManager；\n2）、RedisCacheManager 帮我们创建 RedisCache 来作为缓存组件；RedisCache通过操作redis缓存数据的\n3）、默认保存数据 k-v 都是Object；利用序列化保存；如何保存为json\n1、引入了redis的starter，cacheManager变为 RedisCacheManager；\n2、默认创建的 RedisCacheManager 操作redis的时候使用的是 RedisTemplate3、RedisTemplate是 默认使用jdk的序列化机制\n4）、自定义CacheManager；\nSpringboot整合消息 大多应用中，可通过消息服务中间件来提升系统异步通信、扩展解耦能力\n消息服务中两个重要概念：\n * 消息代理（message broker） * 和目的地（destination）  当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地。\n消息队列主要有两种形式的目的地\n队列（queue）：点对点消息通信（point-to-point）\n主题（topic）：发布（publish）/订阅（subscribe）消息通信\n点对点式：\n消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列 消息只有唯一的发送者和接受者，但并不是说只能有一个接收者\n发布订阅式：\n发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息\nJMS（Java Message Service）JAVA消息服务：\n基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现\nAMQP（Advanced Message Queuing Protocol）\n高级消息队列协议，也是一个消息代理的规范，兼容JMS\nRabbitMQ是AMQP的实现\n    JMS AMQP     定义 Java api 网络线级协议   跨语言 否 是   跨平台 否 是   Model 提供两种消息模型：（1）、Peer-2-Peer（2）、Pub/sub 提供了五种消息模型：（1）、direct exchange（2）、fanout exchange（3）、topic change（4）、headers exchange（5）、system exchange本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分；   支持消息类型 多种消息类型：TextMessageMapMessageBytesMessageStreamMessageObjectMessageMessage （只有消息头和属性） byte[]当实际应用时，有复杂的消息，可以将消息序列化后发送。   综合评价 JMS 定义了JAVA API层面的标准；在java体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差； AMQP定义了wire-level层的协议标准；天然具有跨平台、跨语言特性。    Spring支持\nspring-jms提供了对JMS的支持\nspring-rabbit提供了对AMQP的支持\n需要ConnectionFactory的实现来连接消息代理\n提供JmsTemplate、RabbitTemplate来发送消息\n@JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息\n@EnableJms、@EnableRabbit开启支持\nSpring Boot自动配置\nJmsAutoConfiguration RabbitAutoConfiguration  RabbitMQ 简介 RabbitMQ简介：\nRabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。\n核心概念 Message\n消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。\nPublisher\n消息的生产者，也是一个向交换器发布消息的客户端应用程序。\nExchange\n交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。 Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别\nQueue\n消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。\nBinding\n绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。 Exchange 和Queue的绑定可以是多对多的关系。\nConnection\n网络连接，比如一个TCP连接。\nChannel\n信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。\nConsumer\n消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。\nVirtual Host\n虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。\nBroker\n表示消息队列服务器实体\nRabbitMQ运行机制 AMQP 中的消息路由\nAMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 Exchange 和 Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。\nDirect Exchange 消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。\nFanout Exchange 每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。\nTopic Exchange topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“*”。#匹配0个或多个单词，*匹配一个单词。\n整合RabbitMQ  引入 spring-boot-starter-amqp application.yml配置 测试RabbitMQ  AmqpAdmin：管理组件 RabbitTemplate：消息发送处理组件   安装RabbitMQ docker pull registry.docker.cn.com/library/rabbitmq:3-management docker images docker run -d -p 5672:5672 -p 15672:15672 --name mybabbitmq df22j34k23  登录\n22.22.22.22:15672 输入用户名密码 guest/guest  测试 1）、添加exchange\nname:exchange.direct\ntype:direct\nDurability:Durable\n添加其余两个除了name不同其余属性都是相同的\nexchange.fanout type:fanout exchange.topic  2）、添加消息队列(Queues)\nmumu、mumu.news、mumu.emps、mumulx.news\n3）、绑定\n进入exchange\n在Add binding from this exchange处添加\nexchange.fanout、exchange.direct交换机都和着四个消息队列进行绑定（To queue与Routing key相同）\nexchange.top绑定四个消息队列routingkey为mumu.#和#.news\n4）、交换机发送消息\n进入exchange.direct在publish message中\nRouting key:mumu\nPayload:mumu.exchange.direct.hellword\n然后我们切换回Queues发现只有mumu接收了\n创建工程 场景选择器选择rabbitmq、web\n配置\nspring.rabbitmq.host=xx spring.rabbitmq.username=superrd spring.rabbitmq.password=guest  测试\n发送 @Autowired RabbitTemplate rabbitTemplate; //发送消息 @Test void contextLoads() { /* * 1.单播(点对点) * */ //message需要自己定义，定义消息体内容 //rabbitTemplate.send(exchage,routerKey,message); //只需要传入要发送的对象，自动序列化发送给rabbitMQ //rabbitTemplate.convertAndSend(exchage,routerKey,message); Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026quot;msg\u0026quot;, \u0026quot;第一条消息\u0026quot;); map.put(\u0026quot;data\u0026quot;, Arrays.asList(\u0026quot;hello\u0026quot;, 123, true)); //对象被默认序列化之后发送出去content_type:\tapplication/x-java-serialized-object rabbitTemplate.convertAndSend(\u0026quot;exchange.direct\u0026quot;,\u0026quot;mumu.news\u0026quot;,map); }  接收\n//接收消息 @Test public void receive() { Object o = rabbitTemplate.receiveAndConvert(\u0026quot;mumu.news\u0026quot;); System.out.println(o.getClass()); System.out.println(o); }  定义发送类型为Json类型 先找到模板RabbitTemplate在找到private MessageConverter messageConverter = new SimpleMessageConverter();发现是一个简单类型转换器。我们要自定义转换器，新建配置类返回结果为MessageConverter类型。F4打开继承关系图AbstractMessageConverter(抽象类)\u0026ndash;\u0026gt;AbstractJackson2MessageConverter\u0026ndash;》Jackson2JsonMessageConverter\n我们只要返回Jackson2JsonMessageConverter类型的转化器即可\n@Configuration public class RabbitMQConfig { //定义类型为Json @Bean public MessageConverter messageConverter(){ return new Jackson2JsonMessageConverter(); } }  之后我们在发送消息发现content_type: application/json\n格式为Json\n广播发送消息 /* * 广播发送消息 * */ @Test public void postmsg() { Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026quot;msg\u0026quot;, \u0026quot;第一条消息\u0026quot;); //map.put(\u0026quot;data\u0026quot;, Arrays.asList(\u0026quot;hello\u0026quot;, 1213, true)); rabbitTemplate.convertAndSend(\u0026quot;exchange.fanout\u0026quot;,\u0026quot;\u0026quot;,map); }  监听 @EnableRabbit+@RabbitListener(queues = \u0026quot;mumu.news\u0026quot;)监听消息队列中的内容\n@EnableRabbit//开启基于注解的RabbitMQ模式 @SpringBootApplication public class SpringbootRabbitmqApplication {  @Service public class BookService { //当消息队列中有新内容进来时，就会触发该函数 @RabbitListener(queues = \u0026quot;mumu.news\u0026quot;) public void receive(Book book) { System.out.println(\u0026quot;=========收到消息\u0026quot;); } }  创建消息队列 AmqpAdmin：rabbitMQ的系统管理功能组件\nAmqpAdmin：创建和删除Queue、Exchange，Binding\n@Autowired AmqpAdmin amqpAdmin; @Test public void createExchange(){ /*amqpAdmin.declareExchange(new DirectExchange(\u0026quot;amqpadmin.exchange\u0026quot;)); System.out.println(\u0026quot;====创建成功\u0026quot;);*/ /* amqpAdmin.declareQueue(new Queue(\u0026quot;amqpadmin.queue\u0026quot;,true)); System.out.println(\u0026quot;队列创建成功\u0026quot;);*/ //创建绑定 /* amqpAdmin.declareBinding(new Binding(\u0026quot;amqpadmin.queue\u0026quot;,Binding.DestinationType.QUEUE,\u0026quot;amqpadmin.exchange\u0026quot;,\u0026quot;amqpxx\u0026quot;,null)); System.out.println(\u0026quot;绑定成功\u0026quot;);*/ }  SpringBoot与检索 我们的应用经常需要添加检索功能，开源的 ElasticSearch 是目前全文搜索引擎的首选。他可以快速的存储、搜索和分析海量数据。Spring Boot通过整合Spring Data ElasticSearch为我们提供了非常便捷的检索功能支持；\nElasticsearch是一个分布式搜索服务，提供Restful API，底层基于Lucene，采用多shard（分片）的方式保证数据安全，并且提供自动resharding的功能，github等大型的站点也是采用了ElasticSearch作为其搜索服务，\n安装 docker serach elasticsearch docker pull registry.docker-cb.com/library/elasticserach docker imaages docker run -e ES_JAVA_OPTS=\u0026quot;-Xms256m -Xmx256m\u0026quot; -d -p 9200:9200 -p 9300:9300 --name ES01 s7dfy98asd8f docker ps  测试 22.22.22.22:9200  以 员工文档 的形式存储为例：一个文档代表一个员工数据。存储数据到 ElasticSearch 的行为叫做 索引 ，但在索引一个文档之前，需要确定将文档存储在哪里。\n一个 ElasticSearch 集群可以 包含多个 索引 ，相应的每个索引可以包含多个 类型 。 这些不同的类型存储着多个 文档 ，每个文档又有 多个 属性 。\n类似关系：\n索引-数据库 类型-表 文档-表中的记录 属性-列  使用postman发送请求 发送数据 PUT请求 http://22.22.22.22:9200/megacorp/employee/1  Body \u0026ndash;\u0026gt;raw\u0026ndash;\u0026gt;JSON\n{ \u0026quot;aa\u0026quot;:\u0026quot;aa\u0026quot;, \u0026quot;aa\u0026quot;:\u0026quot;bb\u0026quot;, \u0026quot;cc\u0026quot;:\u0026quot;cc\u0026quot;, \u0026quot;dd\u0026quot;:[\u0026quot;d1\u0026quot;,\u0026quot;d2\u0026quot;] }  获取数据 GET请求 http://22.22.22.22:9200/megacorp/employee/1  删除数据 DELETE请求  将HTTP命令由PUT 改为GET可以用来检索文档，同样的，可以使用DELETE命令来删除文档，以及使用HEAD指令来检查文档是否存在。如果想更新已存在的文档，只需再次PUT\n查询所有信息 GET请求 http://22.22.22.22:9200/megacorp/employee/_search  搜索信息 GET请求 http://22.22.22.22:9200/megacorp/employee/_search?q=last_name:Smith  查询表达式 POST请求 http://22.22.22.22:9200/megacorp/employee/_search  Body中添加JSON类型数据\n{ \u0026quot;query\u0026quot;:{ \u0026quot;match\u0026quot;:{ \u0026quot;last_name\u0026quot;:\u0026quot;Smith\u0026quot; } } }  { \u0026quot;query\u0026quot;:{ \u0026quot;bool\u0026quot;:{ \u0026quot;must\u0026quot;:{ \u0026quot;match\u0026quot;:{ \u0026quot;last_name\u0026quot;:\u0026quot;Smith\u0026quot; }, \u0026quot;filter\u0026quot;:{ \u0026quot;range\u0026quot;:{ \u0026quot;age\u0026quot;:{\u0026quot;gt\u0026quot;:30} } } } } } }  全文检索\n只要含有这些单词就会搜索出来\n{ \u0026quot;query\u0026quot;:{ \u0026quot;match\u0026quot;:{ \u0026quot;about\u0026quot;:\u0026quot;rock climing\u0026quot; } } }  短语搜索\n全部匹配\n{ \u0026quot;query\u0026quot;:{ \u0026quot;match_phrase\u0026quot;:{ \u0026quot;about\u0026quot;:\u0026quot;rock climing\u0026quot; } } }  高亮搜索\n{ \u0026quot;query\u0026quot;:{ \u0026quot;match_phrase\u0026quot;:{ \u0026quot;about\u0026quot;:\u0026quot;rock climing\u0026quot; } },{ \u0026quot;highlight\u0026quot;:{ \u0026quot;fields\u0026quot;:{ \u0026quot;about\u0026quot;:{} } } } }  整合 引入spring-boot-starter-data-elasticsearch\n安装Spring Data 对应版本的ElasticSearch\napplication.yml配置\nSpring Boot自动配置的\n​ ElasticsearchRepository、ElasticsearchTemplate、Jest\n测试ElasticSearch\n添加模块\nweb、\nNO SQL ： Elasticsearch\nspringBoot默认使用SpringData eleasticSearch模块进行操作\nSpringBoot与任务 异步任务、定时任务、邮件任务\n异步任务 在Java应用中，绝大多数情况下都是通过同步的方式来实现交互处理的；但是在处理与第三方系统交互的时候，容易造成响应迟缓的情况，之前大部分都是使用多线程来完成此类任务，其实，在Spring 3.x之后，就已经内置了@Async来完美解决这个问题。\n两个注解：\n@EnableAysnc、@Aysnc\n开启异步注解 @EnableAsync//开启异步注解 @SpringBootApplication public class SpringbootTaskApplication {  //告诉Spring这是一个异步方法 @Async public void hello(){ try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026quot;处理数据中...\u0026quot;); }  定时任务 项目开发中经常需要执行一些定时任务，比如需要在每天凌晨时候，分析一次前一天的日志信息。Spring为我们提供了异步执行任务调度的方式，提供TaskExecutor 、TaskScheduler 接口。\n两个注解：@EnableScheduling、@Scheduled\ncron表达式：\n   字段 允许值 允许的特殊字符     秒 0-59 , - * /   分 0-59 , - * /   小时 0-23 , - * /   日期 1-31 , - * ? / L W C   月份 1-12 , - * /   星期 0-7或SUN-SAT 0,7是SUN , - * ? / L C #       特殊字符 代表含义     , 枚举   - 区间   * 任意   / 步长   ? 日/星期冲突匹配   L 最后   W 工作日   C 和calendar联系后计算过的值   # 星期，4#2，第2个星期四    开启 @EnableScheduling//开启基于注解的定时任务 @SpringBootApplication public class SpringbootTaskApplication {  /** * second(秒), minute（分）, hour（时）, day of month（日）, month（月）, day of week（周几）. * 0 * * * * MON-FRI * 【0 0/5 14,18 * * ?】 每天14点整，和18点整，每隔5分钟执行一次 * 【0 15 10 ? * 1-6】 每个月的周一至周六10:15分执行一次 * 【0 0 2 ? * 6L】每个月的最后一个周六凌晨2点执行一次 * 【0 0 2 LW * ?】每个月的最后一个工作日凌晨2点执行一次 * 【0 0 2-4 ? * 1#1】每个月的第一个周一凌晨2点到4点期间，每个整点都执行一次； */ // @Scheduled(cron = \u0026quot;0 * * * * MON-SAT\u0026quot;) //@Scheduled(cron = \u0026quot;0,1,2,3,4 * * * * MON-SAT\u0026quot;) // @Scheduled(cron = \u0026quot;0-4 * * * * MON-SAT\u0026quot;) @Scheduled(cron = \u0026quot;0/4 * * * * MON-SAT\u0026quot;) //每4秒执行一次 public void hello(){ System.out.println(\u0026quot;hello ... \u0026quot;); }  邮件任务 邮件发送需要引入spring-boot-starter-mail\nSpring Boot 自动配置MailSenderAutoConfiguration\n定义MailProperties内容，配置在application.yml中\n自动装配JavaMailSender\n测试邮件发送\n注意，配置的邮箱的用户名，密码时，并不是自己真正的邮箱的密码，而需要进入邮箱开通相关的服务，之后获取授权码\n@Autowired JavaMailSenderImpl mailSender; //简单邮件 @Test void contextLoads() { SimpleMailMessage message = new SimpleMailMessage(); //邮件设置 message.setSubject(\u0026quot;通知-今晚开会\u0026quot;); message.setText(\u0026quot;今晚7:30开会\u0026quot;); message.setTo(\u0026quot;17512080612@163.com\u0026quot;); message.setFrom(\u0026quot;534096094@qq.com\u0026quot;); mailSender.send(message); } @Test public void test02() throws Exception{ //1、创建一个复杂的消息邮件 MimeMessage mimeMessage = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); //邮件设置 helper.setSubject(\u0026quot;通知-今晚开会\u0026quot;); helper.setText(\u0026quot;\u0026lt;b style='color:red'\u0026gt;今天 7:30 开会\u0026lt;/b\u0026gt;\u0026quot;,true); helper.setTo(\u0026quot;17512080612@163.com\u0026quot;); helper.setFrom(\u0026quot;534096094@qq.com\u0026quot;); //上传文件 //helper.addAttachment(\u0026quot;1.jpg\u0026quot;,new File(\u0026quot;C:\\\\Users\\\\lfy\\\\Pictures\\\\Saved Pictures\\\\1.jpg\u0026quot;)); //helper.addAttachment(\u0026quot;2.jpg\u0026quot;,new File(\u0026quot;C:\\\\Users\\\\lfy\\\\Pictures\\\\Saved Pictures\\\\2.jpg\u0026quot;)); mailSender.send(mimeMessage); }  SpringBoot与安全 Spring Security是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型。他可以实现强大的web安全控制。对于安全控制，我们仅需引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理。几个类：\nWebSecurityConfigurerAdapter：自定义Security策略 AuthenticationManagerBuilder：自定义认证策略 @EnableWebSecurity：开启WebSecurity模式  应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两个主要区域是Spring Security 的两个目标。\n“认证”（Authentication），是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统）。\n“授权”（Authorization）指确定一个主体是否允许在你的应用程序执行一个动作的过程。为了抵达需要授权的店，主体的身份已经有认证过程建立。\n这个概念是通用的而不只在Spring Security中。\nSpringBoot与分布式 分步式、Dubbo/Zookeeper、Spring Boot/Cloud\n在分布式系统中，国内常用zookeeper+dubbo组合，而Spring Boot推荐使用全栈的Spring，Spring Boot+Spring Cloud。\n 单一应用架构\n​ 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。\n 垂直应用架构\n​ 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。\n 分布式服务架构\n​ 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。\n 流动计算架构\n​ 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。\n  Dubbo/Zookeeper ZooKeeper\nZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。\nDubbo\nDubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。\n安装zookeeper docker pull registry.docker-cn.com/lobrary/zookeeper docker images docker run --name zk01 -p 2181:2181 --restart always -d a9s8df79 docker ps  添加依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--引入zookeeper的客户端工具--\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.sgroschupf\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zkclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  配置\ndubbo.application.name=provider-ticket dubbo.registry.address=zookeeper://mycentos6:2182 dubbo.scan.base-packages=com.mumulx.ticket.service  @EnableDubbo//开启springboot对dubbo的支持 @SpringBootApplication public class SpringbootDockerServerApplication {  Spring Boot/Cloud Spring Cloud\nSpring Cloud是一个分布式的整体解决方案。Spring Cloud 为开发者提供了在分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，一次性token，全局琐，leader选举，分布式session，集群状态）中快速构建的工具，使用Spring Cloud的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。\nSpringCloud分布式开发五大常用组件\n 服务发现——Netflix Eureka 客服端负载均衡——Netflix Ribbon 断路器——Netflix Hystrix 服务网关——Netflix Zuul 分布式配置——Spring Cloud Config  Spring Cloud 入门\n1、创建provider 2、创建consumer 3、引入Spring Cloud 4、引入Eureka注册中心 5、引入Ribbon进行客户端负载均衡\n整合 三个部分：注册中心center，提供方server，使用发client\ncenter\n配置\nserver: port: 8761 eureka: instance: hostname: eureka-center # eureka实例的主机名 client: register-with-eureka: false #不把自己注册到eureka上 fetch-registry: false #不从eureka上来获取服务的注册信息 service-url: defaultZone: http://localhost:8761/eureka/  @EnableEurekaServer @SpringBootApplication public class SpringbootCloudCenterApplication {  访问\nlocalhost:8761  提供方server\n@Service public class TicketService { public String getTicket(){ System.out.println(\u0026quot;8002\u0026quot;); return \u0026quot;《厉害了，我的国》\u0026quot;; } } @RestController public class TicketController { @Autowired TicketService ticketService; @GetMapping(\u0026quot;/ticket\u0026quot;) public String getTicket(){ return ticketService.getTicket(); } }  配置\nserver: port: 8002 spring: application: name: provider-ticket eureka: instance: prefer-ip-address: true # 注册服务的时候使用服务的ip地址 client: service-url: defaultZone: http://localhost:8761/eureka/  访问\nlocalhost:8002/ticket  使用方client\n@RestController public class UserController { @Autowired RestTemplate restTemplate; @GetMapping(\u0026quot;/buy\u0026quot;) public String buyTicket(String name){ String s = restTemplate.getForObject(\u0026quot;http://PROVIDER-TICKET/ticket\u0026quot;, String.class); return name+\u0026quot;购买了\u0026quot;+s; } }  spring: application: name: consumer-user server: port: 8200 eureka: instance: prefer-ip-address: true # 注册服务的时候使用服务的ip地址 client: service-url: defaultZone: http://localhost:8761/eureka/  @EnableDiscoveryClient //开启发现服务功能 @SpringBootApplication public class SpringbootCloudClientApplication { public static void main(String[] args) { SpringApplication.run(SpringbootCloudClientApplication.class, args); } @LoadBalanced //使用负载均衡机制 @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } }  测试\nhttp://localhost:8200/buy?name=\u0026quot;zs\u0026quot;  springBoot与热部署 在开发中我们修改一个Java文件后想看到效果不得不重启应用，这导致大量时间花费，我们希望不重启应用的情况下，程序可以自动部署（热部署）。有以下四种情况，如何能实现热部署。\n1）、模板引擎\n在Spring Boot中开发情况下禁用模板引擎的cache页面模板改变ctrl+F9可以重新编译当前页面并生效\n2）、Spring Loaded\nSpring官方提供的热部署程序，实现修改类文件的热部署\n下载Spring Loaded（项目地址）\n添加运行时参数；\n-javaagent:C:/springloaded-1.2.5.RELEASE.jar –noverify  3）、JRebel\n收费的一个热部署软件安装插件使用即可\n4）、Spring Boot Devtools（推荐） 引入依赖\nIDEA使用ctrl+F9或做一些小调整\n​ Intellij IEDA和Eclipse不同，Eclipse设置了自动编译之后，修改类它会自动编译，而IDEA在非RUN或DEBUG情况下才会自动编译（前提是你已经设置了Auto-Compile）。\n设置自动编译（settings-compiler-make project automatically）\nctrl+shift+alt+/（maintenance）\n勾选compiler.automake.allow.when.app.running\nSpring Boot Devtools 添加依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;  Spring Boot与监控管理 通过引入spring-boot-starter-actuator，可以使用Spring Boot为我们提供的准生产环境下的应用监控和管理功能。我们可以通过HTTP，JMX，SSH协议来进行操作，自动得到审计、健康及指标信息等\n步骤：\n引入spring-boot-starter-actuator\n通过http方式访问监控端点\n可进行shutdown（POST 提交，此端点默认关闭）\n配置\nmanagement.endpoints.web.exposure.include=*  访问：这里要加上前缀/actuator\nhttp://localhost:8080/actuator/beans  监控端点\n   auditevents 获取当前应用暴露的审计事件信息     beans 获取应用中所有的 Spring Beans 的完整关系列表   caches 获取公开可以用的缓存   conditions 获取自动配置条件信息，记录哪些自动配置条件通过和没通过的原因   configprops 获取所有配置属性，包括默认配置，显示一个所有 @ConfigurationProperties 的整理列版本   env 获取所有环境变量   flyway 获取已应用的所有Flyway数据库迁移信息，需要一个或多个 Flyway Bean   liquibase 获取已应用的所有Liquibase数据库迁移。需要一个或多个 Liquibase Bean   health 获取应用程序健康指标（运行状况信息）   httptrace 获取HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应交换）。需要 HttpTraceRepository Bean   info 获取应用程序信息   integrationgraph 显示 Spring Integration 图。需要依赖 spring-integration-core   loggers 显示和修改应用程序中日志的配置   logfile 返回日志文件的内容（如果已设置logging.file.name或logging.file.path属性）   metrics 获取系统度量指标信息   mappings 显示所有@RequestMapping路径的整理列表   scheduledtasks 显示应用程序中的计划任务   sessions 允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序   shutdown 关闭应用，要求endpoints.shutdown.enabled设置为true，默认为 false   threaddump 获取系统线程转储信息   heapdump 返回hprof堆转储文件   jolokia 通过HTTP公开JMX bean（当Jolokia在类路径上时，不适用于WebFlux）。需要依赖 jolokia-core   prometheus 以Prometheus服务器可以抓取的格式公开指标。需要依赖 micrometer-registry-prometheus    远程关闭 # 远程关闭 management.endpoint.shutdown.enabled=true  发送请求（post请求）\nhttp://localhost:8080/actuator/shutdown  定制端点信息 定制端点一般通过endpoints+端点名+属性名来设置。\n修改端点id(springboot1. )\n??  开启远程应用关闭功能\nmanagement.endpoint.shutdown.enabled=true  关闭端点\nmanagement.endpoints.enabled-by-default=false  开启所需端点\nmanagement.endpoints.enabled-by-default=false management.endpoint.beans.enabled=true  定制端点访问根路径\nmanagement.endpoints.web.base-path=/manage  定义端点号\nmanagement.server.port=8881  /health\n可以查看其他应用的信息(如redis等)只需要加入对应的starter就行\n","id":19,"section":"posts","summary":"源码 Springboot整合缓存 JSR-107、Spring缓存抽象、整合Redis JSR107 Java Caching定义了5个核心接口，分别是Cachin","tags":["Spring家族"],"title":"Springboot整合","uri":"https://mumulx.github.io/2020/02/springboot-examples/","year":"2020"},{"content":" 简介 Quartz：定时任务\nQuartz ：定时异步任务\nQuartz官网\n概念 任务：做什么事情\u0026hellip;. StudentService\n触发器：定义时间\n调度器：将任务、触发器 一一对应】\n实现步骤：（独立使用） jar jar 在quartz-2.2.1-distribution的lib中\n编写 任务\npublic class MeetingService { public void calClassMeeting(){ System.out.println(\u0026quot;需要提醒的任务(召开会议....)\u0026quot;); // try { // Thread.sleep(5000); // } catch (InterruptedException e) { // e.printStackTrace(); // } // System.out.println(\u0026quot;end.....\u0026quot;); } }  Job\n public class PlanJob implements Job { MeetingService meetingService = new MeetingService(); //jobExecutionContext可以获取 设置的各种参数值 @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { TriggerKey triggerkey = jobExecutionContext.getTrigger().getKey(); JobKey jobKey = jobExecutionContext.getJobDetail().getKey(); System.out.println(\u0026quot;----\u0026quot;); System.out.println(triggerkey+\u0026quot;\\n\u0026quot;+jobKey); JobDataMap jobDataMap = jobExecutionContext.getJobDetail().getJobDataMap(); List\u0026lt;String\u0026gt; infos = (List\u0026lt;String\u0026gt;)jobDataMap.get(\u0026quot;infos\u0026quot;); System.out.println(infos); //存放 计划执行的任务... meetingService.calClassMeeting(); } }  3.测试方法：Job 、 触发器 、调度器\n public class TestQuartz { //XxxBuilder -\u0026gt;withIdentity（）--\u0026gt;Xxx public static void main(String[] args) throws SchedulerException, InterruptedException, ParseException { // PlanJob JobBuilder jobBuilder = JobBuilder.newJob(PlanJob.class);//PlanJob PlanJob PlanJob //产生实际使用的Job JobDetail jobDetail = jobBuilder.withIdentity(\u0026quot;meeting Job\u0026quot;, \u0026quot;group1\u0026quot;).build(); //向Job的execute()中传入一些参数。。。 // JobDatMap JobDataMap jobDataMap = jobDetail.getJobDataMap(); List\u0026lt;String\u0026gt; names = Arrays.asList(new String[]{\u0026quot;zs\u0026quot;,\u0026quot;ls\u0026quot;,\u0026quot;ww\u0026quot;}); jobDataMap.put(\u0026quot;infos\u0026quot;,names); // 触发器(Trigger)：时间规则 ，依赖2个对象(TriggerBuilder ,Scheduel) TriggerBuilder\u0026lt;Trigger\u0026gt; triggerBuilder = TriggerBuilder.newTrigger(); triggerBuilder = triggerBuilder.withIdentity(\u0026quot;meeting trigger\u0026quot;, \u0026quot;group1\u0026quot;); triggerBuilder.startNow();//当满足条件时 立刻执行 // 2019-03-13 09:46:30 -- // 2019-03-13 09:46:45 SimpleDateFormat sdf = new SimpleDateFormat(\u0026quot;yyyy-MM-dd HH:mm:ss\u0026quot;); Date start = sdf.parse(\u0026quot;2019-03-13 09:46:30\u0026quot;); Date end = sdf.parse(\u0026quot;2019-03-13 09:46:45\u0026quot;); // triggerBuilder.startAt(start); // triggerBuilder.endAt(end); //scheduelBuilder：定执行的周期（时机） // SimpleScheduleBuilder scheduelBuilder = SimpleScheduleBuilder.simpleSchedule(); // scheduelBuilder.withIntervalInSeconds(1) ;//每隔1秒执行一次 // scheduelBuilder.withRepeatCount(300) ;//重复执行3次 CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(\u0026quot;5,10,15,30,45 * * * * ? *\u0026quot;); //产生触发器 CronTrigger trigger = triggerBuilder.withSchedule(cronScheduleBuilder).build(); // 调度器（工厂产生调度器） SchedulerFactory secheduleFacotry = new StdSchedulerFactory(); //产生调度器 Scheduler scheduler = secheduleFacotry.getScheduler(); //通过调度器 将 任务 和 触发器一一对应 scheduler.scheduleJob(jobDetail,trigger) ; scheduler.start(); // scheduler.shutdown(true); } }  scheduler.shutdown()：立刻关闭 scheduler.shutdown(false)：shutdown()立刻关闭 scheduler.shutdown(true)：将当前任务执行完毕后 再关闭  异步任务\n触发器：CronScheduleBuilder\nCron表达式：\n6-7个个参数，以空格隔开\n秒 分 时 天(月) 月 天（周） (年)  源码git地址\nSpring整合Quartz jar spring基础包(spring-context-support.jar/spring-tx.jar)+quartz  编写 将Job信息封装到一个 实体类中 public class ScheduleJob { //id private String jobId ; private String jobName ; private String jobGroup ; private String jobStatus ;//0:禁用 1启用 2删除 private String cronExpression ; private String desc ; public String getJobId() { return jobId; } public void setJobId(String jobId) { this.jobId = jobId; } public String getJobName() { return jobName; } public void setJobName(String jobName) { this.jobName = jobName; } public String getJobGroup() { return jobGroup; } public void setJobGroup(String jobGroup) { this.jobGroup = jobGroup; } public String getJobStatus() { return jobStatus; } public void setJobStatus(String jobStatus) { this.jobStatus = jobStatus; } public String getCronExpression() { return cronExpression; } public void setCronExpression(String cronExpression) { this.cronExpression = cronExpression; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } }  spring配置文件 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026quot;\u0026gt; \u0026lt;bean id=\u0026quot;scheduleJobEntity\u0026quot; class=\u0026quot;com.yanqun.entity.ScheduleJob\u0026quot; \u0026gt; \u0026lt;property name=\u0026quot;jobId\u0026quot; value=\u0026quot;j001\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jobName\u0026quot; value=\u0026quot;任务1\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jobGroup\u0026quot; value=\u0026quot;任务组1\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jobStatus\u0026quot; value=\u0026quot;1\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;cronExpression\u0026quot; value=\u0026quot;5,10,30,50 * * * * ? *\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;desc\u0026quot; value=\u0026quot;描述...\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026quot;jobDetail\u0026quot; class=\u0026quot;org.springframework.scheduling.quartz.JobDetailFactoryBean\u0026quot; \u0026gt; \u0026lt;property name=\u0026quot;jobClass\u0026quot; value=\u0026quot;com.yanqun.job.PlanJob\u0026quot;\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jobDataAsMap\u0026quot;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026quot;scheduleJob\u0026quot;\u0026gt; \u0026lt;ref bean=\u0026quot;scheduleJobEntity\u0026quot;\u0026gt;\u0026lt;/ref\u0026gt; \u0026lt;/entry\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 触发器：定义时间规则 \u0026lt;bean id=\u0026quot;cronTrigger\u0026quot; class=\u0026quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;jobDetail\u0026quot; ref=\u0026quot;jobDetail\u0026quot; \u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;cronExpression\u0026quot; value=\u0026quot;#{scheduleJobEntity.cronExpression}\u0026quot;\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; --\u0026gt; \u0026lt;!--SimpleTrigger--\u0026gt; \u0026lt;bean id=\u0026quot;simpleTrigger\u0026quot; class=\u0026quot;org.springframework.scheduling.quartz.SimpleTriggerFactoryBean\u0026quot; \u0026gt; \u0026lt;property name=\u0026quot;repeatInterval\u0026quot; value=\u0026quot;2000\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;repeatCount\u0026quot; value=\u0026quot;10\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;startDelay\u0026quot; value=\u0026quot;3\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jobDetail\u0026quot; ref=\u0026quot;jobDetail\u0026quot; \u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026quot;schedulerFactoryBean\u0026quot; class=\u0026quot;org.springframework.scheduling.quartz.SchedulerFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;triggers\u0026quot;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;ref bean=\u0026quot;simpleTrigger\u0026quot; /\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;  要做的事情\npublic class PlanJob implements Job { private MeetingService meetingService = new MeetingService() ; @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { meetingService.remindMeeting(); ; JobDataMap jobDataMap = jobExecutionContext.getJobDetail().getJobDataMap(); ScheduleJob job = (ScheduleJob)jobDataMap.get(\u0026quot;scheduleJob\u0026quot;); System.out.println(job.getJobId()); System.out.println(job.getJobName()); } }  测试\npublic class TestQuartzSpring { public static void main(String[] args) throws SchedulerException { //singleton:容器初始化时 ApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;applicationContext.xml\u0026quot;); // StdScheduler scheduler = (StdScheduler)context.getBean(\u0026quot;schedulerFactoryBean\u0026quot;); // scheduler.start();SchedulerFactoryBean默认会在实例化时自动启动(singleton的bean会会在ioc容器初始化时 自动加载) } }  调度器 -\u0026gt;触发器（Job、执行时间）\n源码\n","id":20,"section":"posts","summary":"简介 Quartz：定时任务 Quartz ：定时异步任务 Quartz官网 概念 任务：做什么事情\u0026hellip;. StudentService 触发器：定义时间 调度器：将任务、触发器 一一","tags":["Spring家族"],"title":"Quartz框架","uri":"https://mumulx.github.io/2020/01/quartz%E6%A1%86%E6%9E%B6/","year":"2020"},{"content":" 源码\n软件发展史  All In One\n所有代码在一个类/模块中编写容易造成代码混乱\n MVC/三层架构\n将各个功能根据层次进行了划分，但是所有代码任然在同一台计算机中编写，并发能力有限\n RPC\n使用RPC，可以让一个项目部署在不同的计算机中但是此种模式的ip+是端口号比较分散，有一定的维护难度\n SOA：面向服务的架构\n客户端服务端注册中心（客户端、服务端、仲裁中心）\n  dubbo（阿里巴巴产品）\n 运行提供方提供的服务 发布服务 订阅服务 推送服务(notify)\n实施监听服务方是否发生改变\n 调用\n  监听器(Monitor)\n图形化界面，便于监听\n开发dubbo程序 准备环境 linux中安装注册中心zookeeper  linux中安装jdk\n下载jdk-8u171-linux-x64.rpm\n安装\nrpm -ivh jdk-8u171-linux-x64.rpm  会自动安装到usr目录中的java中，\n通过pwd命令，查看jdk安装路径：/usr/java/jdk1.8.0_171-amd64  配置环境变量：\nvi /etc/profile，在文件最后追加： export JAVA_HOME=/usr/java/jdk1.8.0_171-amd64 export CLASSPATH=$JAVA_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$PATH  刷新环境变量\nsource /etc/profile  安装zookeeper\n下载zookeeper，官网\n解压\ntar -zxvf apache-zookeeper-3.5.6-bin.tar.gz  重命名zookeeper的配置文件：\ncd apache-zookeeper-3.5.6-bin/conf/ mv zoo_sample.cfg zoo.cfg  在zoo.cfg中：可以发现\nzookeeper的端口号是 clientPort=2181 我们修改成 clientPort=2182\n  添加\n\tadmin.serverPort=8889  设置zookeeper存放数据的目录：\n dataDir=/app/apache-zookeeper-3.5.6-bin/data  启动zookeeper：\n cd /app/apache-zookeeper-3.5.6-bin/ bin/zkServer.sh start bin/zkServer.sh start 启动 bin/zkServer.sh stop 关闭 bin/zkServer.sh status 查看状态  ### 新建服务端\nsts新建maven工程\n添加WEB-INF/web.xml文件\n添加依赖pom.xml\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;org.dubbo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;students-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;!-- 统一版本号 --\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;spring.version\u0026gt;4.3.17.RELEASE\u0026lt;/spring.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-beans\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-aspects\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jms\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context-support\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- dubbo组件 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- zookeeper --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.zookeeper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zookeeper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- zookeeper客户端 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.sgroschupf\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zkclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.javassist\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javassist\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.21.0-GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.7.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;encoding\u0026gt;UTF8\u0026lt;/encoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- 给maven项目 内置一个tomcat，之后 可以直接运行 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat7-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;port\u0026gt;8881\u0026lt;/port\u0026gt; \u0026lt;path\u0026gt;/\u0026lt;/path\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt;  接口及实现类：（具体的服务）\npublic interface StudentServer { public String server(String name);//zs } @Service//阿里巴巴提供的@Service注解 public class StudentServerImpl implements StudentServer{ public String server(String name) { return \u0026quot;server:\u0026quot; +name; } }  配置工作：\n继承spring:web.xml\n\t\u0026lt;web-app xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns=\u0026quot;http://java.sun.com/xml/ns/javaee\u0026quot; xsi:schemaLocation=\u0026quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\u0026quot; id=\u0026quot;WebApp_ID\u0026quot; version=\u0026quot;2.5\u0026quot;\u0026gt; \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;org.springframework.web.context.ContextLoaderListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; \u0026lt;/web-app\u0026gt;  配置spring: applicationContext.xml\n\t\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot; xmlns:dubbo=\u0026quot;http://code.alibabatech.com/schema/dubbo\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\u0026quot;\u0026gt; \u0026lt;!-- \u0026lt;bean id=\u0026quot;\u0026quot; class=\u0026quot;org.students.server.impl.StudentServerImpl\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; --\u0026gt; \u0026lt;!-- 配置dubbo的应用名称 --\u0026gt; \u0026lt;dubbo:application name=\u0026quot;students-server\u0026quot; /\u0026gt; \u0026lt;!-- 配置注册中心地址 --\u0026gt; \u0026lt;dubbo:registry protocol=\u0026quot;zookeeper\u0026quot; address=\u0026quot;zookeeper://192.168.2.128:2181\u0026quot; /\u0026gt; \u0026lt;!-- 配置dubbo扫描包 ：将@Service所在包 放入 dubbo扫描中，供后续 dubbo在rpc时使用--\u0026gt; \u0026lt;dubbo:annotation package=\u0026quot;org.students.server.impl\u0026quot; /\u0026gt; \u0026lt;!-- 将@Service所在包 放入springIOC容器中，供后续 依赖注入时使用 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;org.student.service.impl\u0026quot;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;/beans\u0026gt;  消费方代码：  引入依赖(jar)\npom.xml (与服务方pom.xml一致，改端口号；并设置客户端自己的gav)\n 补齐web工程需要的 WEB-INF/web.xml\n\u0026lt;web-app xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns=\u0026quot;http://java.sun.com/xml/ns/javaee\u0026quot; xsi:schemaLocation=\u0026quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\u0026quot; id=\u0026quot;WebApp_ID\u0026quot; version=\u0026quot;2.5\u0026quot;\u0026gt; \u0026lt;!-- 解决post乱码 --\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;CharacterEncodingfilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;foreEncoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CharacterEncodingfilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;*.action\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt;  配置springmvc（通过springmvc 来访问 提供方）\n\t\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns:mvc=\u0026quot;http://www.springframework.org/schema/mvc\u0026quot; xmlns:dubbo=\u0026quot;http://code.alibabatech.com/schema/dubbo\u0026quot; xmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\u0026quot;\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;!-- 此配置的目的：将Controller中的内容 直接打印到 浏览器中 --\u0026gt; \u0026lt;mvc:message-converters register-defaults=\u0026quot;false\u0026quot;\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.http.converter.StringHttpMessageConverter\u0026quot;\u0026gt; \u0026lt;constructor-arg value=\u0026quot;UTF-8\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; \u0026lt;!-- 配置dubbo的应用名称 --\u0026gt; \u0026lt;dubbo:application name=\u0026quot;students-consumer\u0026quot;/\u0026gt; \u0026lt;!-- 配置注册中心地址 --\u0026gt; \u0026lt;dubbo:registry address=\u0026quot;zookeeper://192.168.2.128:2181\u0026quot; /\u0026gt; \u0026lt;!-- 配置dubbo扫描包 --\u0026gt; \u0026lt;dubbo:annotation package=\u0026quot;org.controller\u0026quot;/\u0026gt; \u0026lt;!-- 将控制器@Controller所在包 加入IOC容器 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;org.controller\u0026quot;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;/beans\u0026gt;   编写控制器代码：用于访问 服务方提供的服务代码\npackage org.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.students.server.StudentServer; import com.alibaba.dubbo.config.annotation.Reference; //@Controller //@ResponseBody @RestController @RequestMapping(\u0026quot;controller\u0026quot;) public class StudentController { @Reference private StudentServer stuServer ; @RequestMapping(\u0026quot;rpcSerer\u0026quot;) public String rpcSerer() { String result = stuServer.server(\u0026quot;zs\u0026quot;) ; return result ;//将结果显示在控制台 } }  运行\n因为maven引入了内置的tomcat7组件所以项目启动可以\n右键项目\u0026ndash;\u0026gt;run as \u0026ndash;\u0026gt;maven build \u0026hellip;\n在Goals中输入：\nromcat7:run  浏览器访问\nhttp://localhost:8882/controller/rpcServer.action  安装管理控制台 管理手册\n安装监听器（存在于dubbo-admin;而dubbo-admin又存在于incubator-dubbo-ops 之中）\n因此要使用监听器，必须下载incubator-dubbo-ops，但是最新版的incubator-dubbo-ops是在spring boot中使用。\n如果要使用 旧的web版，则需要回退版本。但是陈旧版中 ，当前时间该版本 不完整（没有提供完整的maven依赖），因此无法使用。\n只能在 历史提交记录中 寻找一个可用的版本（Commits on May 18, 2018 ）\n将下载好的dubbo-admin源代码 进行打包war，为了后续的运行。\n执行打包好的dubbo-admin的war包 ：在linux中的tomcat中运行 （将刚才的war放入 tomcat的webapps中即可0）\n​\n在maven中引入一个 mvn中央仓库中不存在的Jar：\n将jar自己安装到本地mvn仓库：\nmvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc7 -Dversion=10.2.0.5.0 -Dpackaging=jar -Dfile=d:\\ojdbc7.jar\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.oracle\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;ojdbc7\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;10.2.0.5.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  service依赖：dao、pojo、父工程\nservice启动、发布\nDubbo综合案例 zookeeper+dubbo+ssm+maven\n","id":21,"section":"posts","summary":"源码 软件发展史 All In One 所有代码在一个类/模块中编写容易造成代码混乱 MVC/三层架构 将各个功能根据层次进行了划分，但是所有代码任然在同一台计算机","tags":["杂七杂八"],"title":"Dubbo自学笔记","uri":"https://mumulx.github.io/2020/01/dubbo%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","year":"2020"},{"content":" 系统使用的Linux Centos6\nMySQL版本： 基础 5.x:\n5.0-5.1:早期产品的延续，升级维护\n5.4 - 5.x : MySQL整合了三方公司的新存储引擎 （推荐5.5） 本次使用的是 * MySQL-client-5.5.58-1.el6.x86_64.rpm * MySQL-server-5.5.58-1.el6.x86_64.rpm\n安装：rpm -ivh rpm软件名\nrpm -ivh MySQL-server-5.5.58-1.el6.x86_64.rpm  如果安装时 与某个软件 xxx冲突，则需要将冲突的软件卸载掉：\nyum -y remove xxx yum -y remove mysql-libs-5.1.73-8.el6*  安装时 有日志提示我们可以修改密码：\nPLEASE REMEMBER TO SET A PASSWORD FOR THE MySQL root USER ! To do so, start the server, then issue the following commands: /usr/bin/mysqladmin -u root password 'new-password' /usr/bin/mysqladmin -u root -h localhost.centos6 password 'new-password'  rpm -ivh MySQL-client-5.5.58-1.el6.x86_64.rpm  注意：\n如果提示“GPG keys\u0026hellip;”安装失败，解决方案：\nrpm -ivh rpm软件名 --force --nodoeps  验证：\nmysqladmin --version  启动mysql应用： service mysql start 关闭： service mysql stop 重启： service mysql restart  在计算机reboot后 登陆MySQL :\n mysql  退出mysql\nexit  可能会报错：\n \u0026quot;/var/lib/mysql/mysql.sock不存在\u0026quot;  \u0026ndash;原因：是Mysql服务没有启动\n解决 ：\n启动服务： 1. 每次使用前 手动启动服务\n /etc/init.d/mysql start   开机自启\nchkconfig mysql on 开启开机自启 chkconfig mysql off 关闭开机自启 ntsysv 检查开机是否自动启动：  ​\n  给mysql 的超级管理员root 增加密码：\n/usr/bin/mysqladmin -u root password root  登陆：\nmysql -u root -p 回车之后输入密码  数据库存放目录：\nps -ef|grep mysql 可以看到： 数据库目录： datadir=/var/lib/mysql pid文件目录： --pid-file=/var/lib/mysql/bigdata01.pid  MySQL核心目录：\n/var/lib/mysql :mysql 安装目录 /usr/share/mysql: 配置文件 /usr/bin：命令目录（mysqladmin、mysqldump等） /etc/init.d/mysql启停脚本  MySQL配置文件\nmy-huge.cnf 高端服务器 1-2G内存 my-large.cnf 中等规模 my-medium.cnf 一般 my-small.cnf 较小  但是，以上配置文件mysql默认不能识别，默认只能识别\n/etc/my.cnf  因此需要将上面四个文件之一复制到默认配置文件中\n采用 my-huge.cnf ：\ncp /usr/share/mysql/my-huge.cnf /etc/my.cnf  注意 mysql5.5默认配置文件\n/etc/my.cnf；  Mysql5.6 默认配置文件\n/etc/mysql-default.cnf  默认端口 3306\nmysql字符编码：\nsql :\nshow variables like '%char%';  可以发现部分编码是 latin,需要统一设置为utf-8\n设置编码：\nvi /etc/my.cnf [mysql] default-character-set=utf8 [client] default-character-set=utf8 [mysqld] character_set_server=utf8 character_set_client=utf8 collation_server=utf8_general_ci  重启Mysql:\nservice mysql restart  sql :\nshow variables like '%char%' ;  注意事项：修改编码 只对“之后”创建的数据库生效，因此 我们建议 在mysql安装完毕后，第一时间 统一编码。\nmysql:清屏\nctrl+L system clear  ​\n原理 MYSQL逻辑分层 ：连接层 服务层 引擎层 存储层\nInnoDB(默认) ：事务优先 （适合高并发操作；行锁）\nMyISAM ：性能优先 （表锁）\n查询数据库引擎： 支持哪些引擎？\nshow engines ;  查看当前使用的引擎\nshow variables like '%storage_engine%' ;  指定数据库对象的引擎：\ncreate table tb( id int(4) auto_increment , name varchar(5), dept varchar(5) , primary key(id)\t)ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ;  由Welcome to the MySQL monitor. Commands end with ; or \\g.可知sql语句的结尾符有两种;和\\g\nSQL优化 原因：性能低、执行时间太长、等待时间太长、SQL语句欠佳（连接查询）、索引失效、服务器参数设置不合理（缓冲、线程数）\n参考文章\nSQL ： 编写过程：\nselect dinstinct ..from ..join ..on ..where ..group by ...having ..order by ..limit ..  解析过程：\nfrom .. on.. join ..where ..group by ....having ...select dinstinct ..order by limit ...  SQL优化， 主要就是 在优化索引 索引： 相当于书的目录\n索引： index是帮助MYSQL高效获取数据的数据结构。索引是数据结构（树：B树(默认)、Hash树\u0026hellip;）\n索引的弊端：\n 索引本身很大， 可以存放在内存/硬盘（通常为 硬盘） 索引不是所有情况均适用： a.少量数据 b.频繁更新的字段 c.很少使用的字段 索引会降低增删改的效率，提高查询的效率（增删改 查）  优势：\n 提高查询效率（降低IO使用率）\n 降低CPU使用率 （\u0026hellip;order by age desc,因为 B树索引 本身就是一个 好排序的结构，因此在排序时 可以直接使用）\n  三层Btree可以存放上百万条的数据\nBtree：一般指B+树，数据全部存放在叶结点中\nB+树中查询任意的数据的次数：n次(B+树的高度)\n索引 分类： 主键索引： 不能重复。id 不能是null\n唯一索引 ：不能重复。id 可以是null\n单值索引 ： 单列， age ;一个表可以多个单值索引,name。\n复合索引 ：多个列构成的索引 （相当于 二级目录 ： z: zhao） (name,age) (a,b,c,d,\u0026hellip;,n)\n创建索引： 方式一：\ncreate 索引类型 索引名 on 表(字段) 单值： create index dept_index on tb(dept); 唯一： create unique index name_index on tb(name) ; 复合索引 create index dept_name_index on tb(dept,name);  方式二：\nalter table 表名 索引类型 索引名（字段） 单值： alter table tb add index dept_index(dept) ; 唯一： alter table tb add unique index name_index(name); 复合索引 alter table tb add index dept_name_index(dept,name);  注意：如果一个字段是primary key，则该字段默认就是 主键索引\n此时的语句是DDL，会自动提交，因此不需要commit;\nDML语句需要自己commit，增删改\n删除索引：\ndrop index 索引名 on 表名 ; drop index name_index on tb ;  查询索引：\nshow index from 表名 ; show index from 表名 \\G  注意：结尾符需要写成\\G,结果以行的顺序以列的形式显示出来\nSQL性能问题  分析SQL的执行计划 : explain ，可以模拟SQL优化器执行SQL语句，从而让开发人员 知道自己编写的SQL状况 MySQL查询优化器会干扰我们的优化  优化方法，官网\n查询执行计划：\nexplain +SQL语句 explain select * from tb ;   id : 编号\tselect_type ： 查询类型 table ： 表 type ： 类型 possible_keys ： 预测用到的索引 key ： 实际使用的索引 key_len ： 实际使用索引的长度 ref : 表之间的引用 rows ： 通过索引查询到的数据量 Extra: 额外的信息  准备数据： create table course ( cid int(3), cname varchar(20), tid int(3) ); create table teacher ( tid int(3), tname varchar(20), tcid int(3) ); create table teacherCard ( tcid int(3), tcdesc varchar(200) ); insert into course values(1,'java',1); insert into course values(2,'html',1); insert into course values(3,'sql',2); insert into course values(4,'web',3); insert into teacher values(1,'tz',1); insert into teacher values(2,'tw',2); insert into teacher values(3,'tl',3); insert into teacherCard values(1,'tzdesc') ; insert into teacherCard values(2,'twdesc') ; insert into teacherCard values(3,'tldesc') ;  查询课程编号为2 或 教师证编号为3 的老师信息\nSQL语句\nselect t.* from teacherCard tc,course c,teacher t where c.tid = t.tid and t.tcid = tc.tcid and (c.cid = 2 or tc.tcid=3);  explain +sql:  表字段 id:  id值相同，从上往下 顺序执行。\nt(3)-tc(3)-c(4)  t表中添加数据后在执行\ntc（3）--c（4）-（t6）  表的执行顺序 因数量的个数改变而改变的原因： 笛卡儿积\n a b c 2 3 4 = 2*3=6 * 4 =24 3 4 2 = 3*4=12* 2 =24  虽然结果最终的结果相同但是中间的过程是不同的，程序喜欢数据越小越好。(小表驱动大表)\n数据小的表 优先查询；\n id值不同：id值越大越优先查询 (本质：在嵌套子查询时，先查内层 再查外层)\n查询教授SQL课程的老师的描述（desc），纯多表查询\nexplain select tc.tcdesc from teacherCard tc,course c,teacher t where c.tid = t.tid and t.tcid = tc.tcid and c.cname = 'sql' ;  将以上 多表查询 转为子查询形式（纯子查询）：会先执行括号中的\nexplain select tc.tcdesc from teacherCard tc where tc.tcid = (select t.tcid from teacher t where t.tid = (select c.tid from course c where c.cname = 'sql') );   子查询+多表：\nexplain select t.tname ,tc.tcdesc from teacher t,teacherCard tc where t.tcid= tc.tcid and t.tid = (select c.tid from course c where cname = 'sql') ;  结论: id值有相同，又有不同： id值越大越优先；id值相同，从上往下 顺序执行（c-tc-t）\nselect_type: select_type:查询类型\n PRIMARY:包含子查询SQL中的 主查询 （最外层） SUBQUERY：包含子查询SQL中的 子查询 （非最外层） simple:简单查询（不包含子查询、union）select * from teacher derived:衍生查询(使用到了临时表)(在table列中derived 字段的后面有一个数字指向了id为该数据的临时表)  衍生查询的两种情况\n 在from子查询中只有一张表\nexplain select cr.cname from ( select * from course where tid in (1,2) ) cr ;  在from子查询中， 如果有table1 union table2 ，则table1 就是derived,table2就是union\nexplain select cr.cname from ( select * from course where tid = 1 union select * from course where tid = 2 ) cr ;   union 看上面的例子。\nunion result :告知开发人员，那些表之间存union查询（在table列表示x表和y表之间有union）\nsystem \u0026gt; const \u0026gt; eq_ref \u0026gt; ref \u0026gt; fulltext \u0026gt; ref_or_null \u0026gt; index_merge \u0026gt; unique_subquery \u0026gt; index_subquery \u0026gt; range \u0026gt; index \u0026gt; ALL  type type:索引类型、类型\nsystem\u0026gt;const\u0026gt;eq_ref\u0026gt;ref\u0026gt;range\u0026gt;index\u0026gt;all ，要对type进行优化的前提：有索引  越往左边性能越高。其中：system,const只是理想情况；实际能达到 ref\u0026gt;range\nsystem system（忽略，不切实际。。）: 只有一条数据的系统表 ；或 衍生表只有一条数据的主查询\ncreate table test01 ( tid int(3), tname varchar(20) ); insert into test01 values(1,'a') ; commit;  增加索引（主键索引）\nalter table test01 add constraint tid_pk primary key(tid) ; explain select * from (select * from test01 )t where tid =1 ;  const const:仅仅能查到一条数据的SQL ,用于Primary key 或unique索引 （类型 与索引类型有关）\nexplain select tid from test01 where tid =1 ;  删除主键索引，创建一个一般索引,在查询\nalter table test01 drop primary key ; create index test01_index on test01(tid) ; explain select tid from test01 where tid =1 ;  则不行\neq_ref eq_ref:唯一性索引：对于每个索引键的查询，返回匹配唯一行数据（有且只有1个，不能多 、不能0）（每一行数据唯一，且表数据一对一不能多也不能少） select \u0026hellip; from ..where name = \u0026hellip; .常见于唯一索引 和主键索引(因为主键索引和唯一索引会保证唯一)。\n增加主键：给teacherCard表增加一个主键索引，给teacher表增加一个唯一索引\nalter table teacherCard add constraint pk_tcid primary key(tcid); alter table teacher add constraint uk_tcid unique index(tcid) ;  explain select t.tcid from teacher t,teacherCard tc where t.tcid = tc.tcid ;  以上SQL，用到的索引是 t.tcid,即teacher表中的tcid字段；如果teacher表的数据个数 和 连接查询的数据个数一致（都是3条数据），则有可能满足eq_ref级别；否则无法满足。\nref ref：非唯一性索引，对于每个索引键的查询，返回匹配的所有行（0，多）\n准备数据：\ninsert into teacher values(4,'tz',4) ; insert into teacher values(5,'tz',4) ; insert into teacherCard values(4,'tz222');  测试：先给name增加索引\nalter table teacher add index index_name (tname) ; explain select * from teacher where tname = 'tz';  查询到的索引列的结果有两个tz所以是ref\nrange range：检索指定范围的行 ,where后面是一个范围查询(between ,\u0026gt; \u0026lt; \u0026gt;=, 特殊:in有时候会失效 ，从而转为 无索引all)\nalter table teacher add index tid_index (tid) ; explain select t.* from teacher t where t.tid in (1,2) ; explain select t.* from teacher t where t.tid \u0026lt;3 ;  index index：查询全部索引中数据\nexplain select tid from teacher ;  \u0026ndash;tid 是索引，只需要扫描索引表，不需要查询所有表中的所有数据\nall all：查询全部表中的数据\nexplain select cid from course ;  \u0026ndash;cid不是索引，需要全表扫描，即需要查询所有表中的所有数据\n小结 system/const: 结果只有一条数据\neq_ref:结果多条；但是每条数据是唯一的 ；\nref：结果多条；但是每条数据是是0或多条 ；\npossible_keys possible_keys ：可能用到的索引，是一种预测，不准。\nalter table course add index cname_index (cname); explain select t.tname ,tc.tcdesc from teacher t,teacherCard tc where t.tcid= tc.tcid and t.tid = (select c.tid from course c where cname = 'sql') ;  如果 possible_key/key是NULL，则说明没用索引\nexplain select tc.tcdesc from teacherCard tc,course c,teacher t where c.tid = t.tid and t.tcid = tc.tcid and c.cname = 'sql' ;  这个预测就不准\nkey key ：实际使用到的索引\nkey_len key_len ：索引的长度 ;\n作用：用于判断复合索引是否被完全使用\ncreate table test_kl ( name char(20) not null default '' ); alter table test_kl add index index_name(name) ; explain select * from test_kl where name ='' ; --长度为60  \u0026ndash; key_len :60\n在utf8：1个字符站3个字节\nalter table test_kl add column name1 char(20) ; --name1可以为null alter table test_kl add index index_name1(name1) ; explain select * from test_kl where name1 ='' ; -- 长度为61  \u0026ndash;如果索引字段可以为Null,则会使用1个字节用于标识。\ndrop index index_name on test_kl ;--删除两个索引 drop index index_name1 on test_kl ;  增加一个复合索引\nalter table test_kl add index name_name1_index (name,name1) ; --会先查name，查到就不用name1，没查到会用name1 explain select * from test_kl where name1 = '' ; --复合索引会先查name在查name1  \u0026ndash;121；用到了name1，但是name1和name符合起来了，因此两者都被使用。20*3+20*3+1=121\nexplain select * from test_kl where name = '' ;  \u0026ndash;60；只用到了name，20*3=60\nvarchar(20)\nalter table test_kl add column name2 varchar(20) ;  \u0026ndash;可以为Null\nalter table test_kl add index name2_index (name2) ; explain select * from test_kl where name2 = '' ;  \u0026ndash;63\n20*3=60 + 1(null) +2(用2个字节 标识可变长度) =63\n utf8:1个字符3个字节 gbk:1个字符2个字节 latin:1个字符1个字节  ref ref : 注意与type中的ref值区分。\n作用： 指明当前表所参照的字段。\nselect ....where a.c = b.x ;(其中b.x可以是常量:const a表中c字段引用了b表中的x字段) alter table course add index tid_index (tid) ;--研究的前提是使用到的字段都加上了索引 explain select * from course c,teacher t where c.tid = t.tid and t.tname ='tw' ;  其中t.tname ='tw'中的tw是一个常量因此是const\nc.tid = t.tidc表的tid用到了t表的tid\nrows rows: 被索引优化查询的 数据个数 (实际通过索引而查询到的 数据个数)\nexplain select * from course c,teacher t where c.tid = t.tid and t.tname = 'tz' ;  Extra： using filesort ： 性能消耗大；需要“额外”的一次排序（查询） 。常见于 order by 语句中。\n排序之前要先查询\ncreate table test02 ( a1 char(3), a2 char(3), a3 char(3), index idx_a1(a1), index idx_a2(a2), index idx_a3(a3) ); explain select * from test02 where a1 ='' order by a1 ;--不是using filesort  explain select * from test02 where a1 ='' order by a2 ; --using filesort 根据a2排序但是a2没查，因此需要额外的一次查询  小结：对于单索引， 如果排序和查找是同一个字段，则不会出现using filesort；如果排序和查找不是同一个字段，则会出现using filesort；\n避免： where哪些字段，就order by那些字段\n复合索引：不能跨列（最佳左前缀）\ndrop index idx_a1 on test02; drop index idx_a2 on test02; drop index idx_a3 on test02; alter table test02 add index idx_a1_a2_a3 (a1,a2,a3) ; explain select *from test02 where a1='' order by a3 ; --using filesort 跨列了 跨过了a2  explain select *from test02 where a2='' order by a3 ; --using filesort 跨列了 跨过了a1  explain select *from test02 where a1='' order by a2 ;--没有--using filesort  explain select *from test02 where a2='' order by a1 ; --using filesort  小结：避免： where和order by 按照复合索引的顺序使用，不要跨列或无序使用。\nusing temporary: 性能损耗大 ，用到了临时表。一般出现在group by 语句中。\nexplain select a1 from test02 where a1 in ('1','2','3') group by a1 ;--没有--using temporary  explain select a1 from test02 where a1 in ('1','2','3') group by a2 ; --using temporary  避免：查询那些列，就根据那些列 group by .\nusing temporary:需要额外再多使用一张表. 一般出现在group by语句中；已经有表了，但不适用，必须再来一张表。\n解析过程：\nfrom .. on.. join ..where ..group by ....having ...select dinstinct ..order by limit ...  explain select * from test03 where a2=2 and a4=4 group by a2,a4 ;  ​ \u0026ndash;没有using temporary；先where a2\\a4在group by a2\\a4,在原先的基础上在分组，因此没有用到额外的一张表\nexplain select * from test03 where a2=2 and a4=4 group by a3 ;  \u0026ndash;using temporary；先where a2\\a4在group by a3，在原先的基础上按照a3进行分组，因此用到额外的一张表a3\nusing index : 性能提升; 索引覆盖（覆盖索引）。\n原因：不读取原文件，只从索引文件中获取数据 （不需要回表查询）\n不需要回表查询:用到的数据都是索引中的数据，不需要再在表中使用没加索引的数据\n只要使用到的列 全部都在索引中，就是索引覆盖using index\n例如：test02表中有一个复合索引(a1,a2,a3)\nexplain select a1,a2 from test02 where a1='' or a2= '' ; --using index 用到的a1和a2都在复合索引中  ​ 反例\ndrop index idx_a1_a2_a3 on test02; alter table test02 add index idx_a1_a2(a1,a2) ; explain select a1,a3 from test02 where a1='' or a3= '' ;--用到的a3不是索引因此没有--using index  如果用到了索引覆盖(using index时)，会对 possible_keys和key造成影响：\n 如果没有where，则索引只出现在key中；\n 如果有where，则索引 出现在key和possible_keys中。\n```sql  explain select a1,a2 from test02 where a1=\u0026rdquo; or a2= \u0026ldquo; ; explain select a1,a2 from test02 ;\n #### using where using where （需要回表查询） 假设age是索引列，但查询语句`select age,name from ...where age =...,`此语句中必须回原表查Name，因此会显示using where.  sql\n  explain select a1,a3 from test02 where a3 = \u0026ldquo; ;\u0026ndash;a3需要回原表查询\n #### impossible where impossible where ： where子句永远为false  sql explain select * from test02 where a1=\u0026lsquo;x\u0026rsquo; and a1=\u0026lsquo;y\u0026rsquo; ;\u0026ndash;impossible where\n ### 优化实例  sql create table test03( a1 int(4) not null, a2 int(4) not null, a3 int(4) not null, a4 int(4) not null ); alter table test03 add index idx_a1_a2_a3_a4(a1,a2,a3,a4);\n mssql explain select a1,a2,a3,a4 from test03 where a1=1 and a2=1 and a3=1 and a4=1;\u0026ndash;using index\n--推荐写法，因为索引的使用属性顺序（where）后面的顺序和复合索引的顺序一致  mssql explain select a1,a2,a3,a4 from test03 where a4=1 and a3=1 and a2=1 and a1=1;\u0026ndash;using index\n虽然编写的顺序和索引的顺序不一致，但是我们发现两者结果一致：是因为mysql的服务层的sql优化器对该语句进行了优化 以上2个sql，使用了全部的符合索引：通过key_len=16  mssql explain select a1,a2,a3,a4 from test03 where a1=1 and a2=1 and a4=1 order by a3;\na1,a2按顺序，显示using index，不需要回表查询 a4:无效索引，因为跨列使用(变为无效索引)会回表查询显示using where 可以通过key_len校验 ：8  sql explain select a1,a2,a3,a4 from test03 where a1=1 and a4=4 order by a3;\n 以上sql出现了--using filesort(文件内排序，“多了一次额外的查找、排序”) 不要跨列使用(where和order by拼起来不要跨列使用) a1--(a4无效)--a3:1-3结果跨列  sql explain select a1,a2,a3,a4 from test03 where a1=1 and a4=1 order by a2,a3;\n结果没有--using filesort，没有进行跨列使用 a1--a2--（a4失效）--a3:1-2-3 结果没有跨列 小结： 如果（a,b,c,d）复合索引和使用的顺序一致（且不跨列使用），则复合索引全部使用。如果部分一致，则使用部分索引 where和order by拼起来，不要跨列使用 ## 优化案例 单表优化、两表优化、三表优化 ### 单表优化  mssql create table book ( bid int(4) primary key, name varchar(20) not null, authorid int(4) not null, publicid int(4) not null, typeid int(4) not null ); insert into book values(1,\u0026lsquo;tjava\u0026rsquo;,1,1,2) ; insert into book values(2,\u0026lsquo;tc\u0026rsquo;,2,1,2) ; insert into book values(3,\u0026lsquo;wx\u0026rsquo;,3,2,1) ; insert into book values(4,\u0026lsquo;math\u0026rsquo;,4,2,3) ;\tcommit;\t 查询authorid=1且 typeid为2或3的 bid  mssql explain select bid from book where typeid in(2,3) and authorid=1 order by typeid desc ;\n 优化：加索引  mssql alter table book add index idx_bta (bid,typeid,authorid);\n 索引一旦进行 升级优化，需要将之前废弃的索引删掉，防止干扰。  sql drop index idx_bta on book;\n 根据SQL实际解析的顺序，调整索引的顺序：  from .. on.. join ..where ..group by \u0026hellip;.having \u0026hellip;select dinstinct ..order by limit \u0026hellip;\n  sql alter table book add index idx_tab (typeid,authorid,bid);\n --虽然可以回表查询bid，但是将bid放到索引中 可以提升使用using index ; 再次优化（之前是index级别）：思路,因为范围查询in有时会失效(in失效后a也会失效)，因此交换索引的顺序，将typeid in(2,3) 放到最后（这样即使in失效了我们的a还有用）。  sql drop index idx_tab on book;\nalter table book add index idx_atb (authorid,typeid,bid);\nexplain select bid from book where authorid=1 and typeid in(2,3) order by typeid desc ;\n --小结： 1. 最佳左前缀，保持索引的定义和使用的顺序一致性 1. 索引需要逐步优化 1. 将含In的范围查询 放到where条件的最后，防止失效。 本例中同时出现了Using where（需要回原表）; Using index（不需要回原表）： 原因，`where authorid=1 and typeid in(2,3)`中authorid在索引(authorid,typeid,bid)中，因此不需要回原表（直接在索引表中能查到）； 而typeid虽然也在索引(authorid,typeid,bid)中，但是含in的范围查询已经使该typeid索引失效，因此相当于没有typeid这个索引，所以需要回原表（using where）； 例如以下没有了In，则不会出现using where  sql explain select bid from book where authorid=1 and typeid =3 order by typeid desc ;\n 还可以通过key_len证明in可以使索引失效。 * 有in时索引长度为4 * 没in时索引长度为8 ### 两表优化  sql create table teacher2 ( tid int(4) primary key, cid int(4) not null );\ninsert into teacher2 values(1,2); insert into teacher2 values(2,1); insert into teacher2 values(3,3);\ncreate table course2 ( cid int(4) , cname varchar(20) );\ninsert into course2 values(1,\u0026lsquo;java\u0026rsquo;); insert into course2 values(2,\u0026lsquo;python\u0026rsquo;); insert into course2 values(3,\u0026lsquo;kotlin\u0026rsquo;); commit;\n 左连接：  sql explain select *from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname=\u0026lsquo;java\u0026rsquo;;\n 索引往哪张表加？ 小表驱动大表 (where 小表.x = 大表.y) 索引建立经常使用的字段上 （本题 t.cid=c.cid可知，t.cid字段使用频繁，因此给该字段加索引）,一般情况对于左外连接(以左表为基础：左表的数据要全部匹配)，给左表加索引；右外连接（以右表为基准），给右表加索引  小表:10 大表:300 select ...where 小表.x10=大表.x300 ; for(int i=0;i\u0026lt;小表.length 10;i++) { for(int j=0;j\u0026lt;大表.length 300;j++) { ... } } select ...where 大表.x300=小表.x10 ; for(int i=0;i\u0026lt;大表.length300;i++) { for(int j=0;j\u0026lt;小表.length10;j++) { ... } }   以上2个FOR循环，最终都会循环3000次；但是 对于双层循环来说：一般建议 将数据小的循环 放外层；数据大的循环放内层。小表驱动大表 当编写 ..on t.cid=c.cid 时，将数据量小的表 放左边（假设此时t表数据量小） 优化  \tsql alter table teacher2 add index index_teacher2_cid(cid) ;\n\talter table course2 add index index_course2_cname(cname);\u0026ndash;where后面的字段一定要加索引\n sql explain select *from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname=\u0026lsquo;java\u0026rsquo;;\n Using join buffer:extra中的一个选项，作用：Mysql引擎使用了 连接缓存。写的sql太差了mysql看不下去了，动了你的sql，给加了一个连接缓存。 --- 左连接（left join）即为两张表进行连接时,是以处于left join语句左侧的表为基准去匹配left join语句右边的表，如果左表中的一条数据在右表中能找到与之对应的一条数据，那么就会出现在以虚表形式存在的结果表中，如果没有找到，那么会以null来代替右表中的数据去匹配左表。这样会有一个鲜明的对比，左表中的每一条数据中的对象在右表中的某个属性的存在性是一目了然的。同时在使用on 进行连接时，on的作用仅仅是进行两张表的上诉连接，发挥匹配的功能，它选出来的是满足这种匹配的所有结果，而并不一定是用户所需要的，这时候就要使用where进行条件判断，从而筛选出真正需要的信息。 ---- 右连接（right join）本质上是相当于将上述的左连接的这个过程反过来，以连接语句right join右侧的表为基准去匹配左边的表，剩下的道理是一样的，不再赘述。 ----- 内连接（inner join）就是在用两张表进行匹配的时候，如果表中任意一条数据在另一张表中都是找不到对应数据的话，那么在结果表中是不会有这一条数据的。也就是说必须是两张表中任意两条能够互相对应着的数据才能被存入到结果表中，有点类似于取交集的味道。这种适用于一旦某条数据为空便没有意义的场景，这时给它设成null也就毫无意义了。表中的数据也因此显得简练很多。 ---- 外链接（outer join）与内连接是相反的，就是说，如果某张表中的数据在另一张中找不到对应的条目并不影响它依然出现在查询的结果中，这对于两张表都是满足的，两边都有出现null的可能，这就有一点数学里的并集的意思。 ----- 自连接(self join)可能看起来有点晦涩难懂，但是实际上换个角度你就会豁然开朗，你可以把它这个过程想象成两张一样的表进行左连接或右连接，这样就会简单多了，其中一张表通过设别名的方式成为了虚表，但是共享原标中的信息。应用场景是这样的，就是表的一个字段和另一个字段是相同性质的东西，譬如员工与上司，他们本质也都是员工，在员工表中，员工的直接上司编号会以另一个字段的形式出现，但是他的上司的编号也是会出现在员工编号这个字段里。那么在这种情况下，假如需要去查询某一位员工的上司的信息，在已知该员工编号的条件下，可以根据他的编号去获得上司的编号，进而通过上司的编号去获得上司的信息。 ### 三张表优化A B C * 小表驱动大表 * 索引建立在经常查询的字段上 ## 避免索引失效的一些原则 #### 复合索引 * 复合索引，不要跨列或无序使用（最佳左前缀） * 复合索引，尽量使用全索引匹配 复合索引可以看为是书的目录(a,b,c)一级目录a二级目录b三级目录c #### 索引操作 不要在索引上进行任何操作（计算、函数、类型转换），否则索引失效  sql select ..where A.x = .. ; \u0026ndash;假设A.x是索引\n\u0026ndash;不要：select ..where A.x*3 = .. ;\nexplain select * from book where authorid = 1 and typeid = 2 ;\u0026ndash;用到了at2个索引\nexplain select * from book where authorid = 1 and typeid*2 = 2 ;\u0026ndash;用到了a1个索引\nexplain select * from book where authorid*2 = 1 and typeid*2 = 2 ;\u0026mdash;-用到了0个索引\nexplain select * from book where authorid*2 = 1 and typeid = 2 ;\u0026mdash;-用到了0个索引,\n 原因：对于复合索引，如果左边失效，右侧全部失效。(a,b,c)，例如如果 b失效，则b c同时失效。 如果是单独的索引就没有这种问题  sql drop index idx_atb on book ;\nalter table book add index idx_authroid (authorid) ;\nalter table book add index idx_typeid (typeid) ;\n 独立索引，不影响  sql explain select * from book where authorid*2 = 1 and typeid = 2 ;\u0026ndash;使用到了0个索引 explain select * from book where authorid*2 = 1 and typeid = 2 ;\u0026ndash;使用到了一个索引\n #### 复合索引关键判断 复合索引不能使用不等于（!= \u0026lt;\u0026gt;）或is null (is not null)，否则自身以及右侧索引全部失效。 复合索引中如果有\u0026gt;，则自身和右侧索引全部失效。  sql explain select * from book where authorid = 1 and typeid =2 ;\u0026ndash;预测使用两个索引，实际使用到了一个索引\n -- SQL优化，是一种概率层面的优化。至于是否实际使用了我们的优化，需要通过explain进行推测。  sql explain select * from book where authorid != 1 and typeid =2 ;\u0026ndash;authorid失效\nexplain select * from book where authorid != 1 and typeid !=2 ;\u0026ndash;两个索引都失效\n ​ 体验概率情况(\u0026lt; \u0026gt; =)： 原因是服务层中有SQL优化器，可能会影响我们的优化。  sql show index from book; drop index idx_typeid on book;\ndrop index idx_authroid on book;\nalter table book add index idx_book_at (authorid,typeid);\nexplain select * from book where authorid = 1 and typeid =2 ;\u0026ndash;复合索引at全部使用\n explain select * from book where authorid \u0026gt; 1 and typeid =2 ; --复合索引中如果有\u0026gt;，则自身和右侧索引全部失效。(大部分的情况下是这种)  sql explain select * from book where authorid = 1 and typeid \u0026gt;2 ;\n --复合索引at全部使用 明显的概率问题：下面几个很明显  sql explain select * from book where authorid \u0026lt; 1 and typeid =2 ;\n--复合索引at只用到了1个索引  sql explain select * from book where authorid \u0026lt; 4 and typeid =2 ;\u0026ndash; 只是将1改为了4\n--复合索引全部失效 * 我们学习的索引优化 ，是一个大部分情况适用的结论，但由于SQL优化器等原因 该结论不是100%正确。 * 一般而言， 范围查询（\u0026gt; \u0026lt; in），之后的索引失效。 **补救尽量使用索引覆盖（using index）** 不会出错，永远成立  sql （a,b,c）\nselect a,b,c from xx..where a= .. and b =.. ;\n #### Like问题 **like尽量以“常量”开头，不要以'%'开头，否则索引失效**  sql select * from xx where name like \u0026lsquo;%x%\u0026rsquo; ;\n--name即使是一个索引，也会失效  sql explain select * from teacher where tname like \u0026lsquo;%x%\u0026rsquo;;\n--tname索引失效（开发过程中不要使用*）  sql explain select * from teacher where tname like \u0026lsquo;x%\u0026rsquo;;\n --使用name索引，索引为没失效  sql explain select tname from teacher where tname like \u0026lsquo;%x%\u0026rsquo;;\n --如果必须使用like '%x%'进行模糊查询，可以使用索引覆盖 挽救一部分。 #### 类型转换 **尽量不要使用类型转换（显示、隐式），否则索引失效**  sql explain select * from teacher where tname = \u0026lsquo;abc\u0026rsquo; ;\u0026ndash;使用了索引没问题 explain select * from teacher where tname = 123 ;\u0026ndash;程序底层将 123 -\u0026gt; \u0026lsquo;123\u0026rsquo;，即进行了类型转换，因此索引失效\n #### or 尽量不要使用or，否则索引失效  sql explain select * from teacher where tname =\u0026ldquo;;\u0026ndash;索引正常 explain select * from teacher where tname =\u0026rdquo; or tcid \u0026gt;1 ; \u0026ndash;将or左侧的tname 失效。\n ## 一些其他的优化方法 ### exist和in  sql select ..from table where exist (子查询) ; select ..from table where 字段 in (子查询) ;\n 如果主查询的数据集大，则使用In ,效率高。 如果子查询的数据集大，则使用exist,效率高。 --- exist语法： 将主查询的结果，放到子查询结果中进行条件校验（看子查询是否有数据，如果有数据则校验成功） ，如果符合校验，则保留数据；  sql select tname from teacher where exists (select * from teacher) ;\n--等价于`select tname from teacher`  sql select tname from teacher where exists (select * from teacher where tid =9999) ;\n子查询没数据,校验失败 --- in:  sql select ..from table where tid in (1,3,5) ;\n ### order by 优化 using filesort 有两种算法：双路排序、单路排序 （根据IO（访问硬盘文件）的次数） MySQL4.1之前 默认使用 双路排序； 双路：扫描2次磁盘 1. 从磁盘读取排序字段 ,对排序字段进行排序（在buffer(缓冲区)中进行的排序） 2. 扫描其他字段 --IO较消耗性能 MySQL4.1之后 默认使用 单路排序 ： 只读取一次（全部字段），在buffer中进行排序。 但此种单路排序 会有一定的隐患 （不一定真的是“单路|1次IO”，有可能多次IO）。 原因：如果数据量特别大，则无法 将所有字段的数据 一次性读取完毕，因此 会进行“分片读取、多次读取”。 注意：单路排序 比双路排序 会占用更多的buffer。 单路排序在使用时，如果数据大，可以考虑调大buffer的容量大小： sql命令  sql set max_length_for_sort_data = 1024; \u0026ndash;单位byte\n 如果max_length_for_sort_data值太低，则mysql会自动从 单路-\u0026gt;双路 （太低：需要排序的列的总大小超过了max_length_for_sort_data定义的字节数） 提高order by查询的策略： 1. 选择使用单路、双路 ；调整buffer的容量大小； 2. 避免select * ... 用什么查什么 1. 复合索引 不要跨列使用 ，避免using filesort 1. 保证全部的排序字段 排序的一致性（都是升序 或 降序） ## SQL排查 - 慢查询日志: MySQL提供的一种日志记录，用于记录MySQL种响应时间超过阀值的SQL语句 （long_query_time，默认10秒） 慢查询日志默认是关闭的； 建议：开发调优是 打开，而 最终部署时关闭。 检查是否开启了 慢查询日志 ：  sql show variables like \u0026lsquo;%slow_query_log%\u0026rsquo; ;\n 临时开启：mysql退出重启服务后关闭  sql set global slow_query_log = 1 ; \u0026ndash;在内存中开启\nexit\nservice mysql restart\n 永久开启： /etc/my.cnf 中追加配置： vi /etc/my.cnf [mysqld] slow_query_log=1 slow_query_log_file=/var/lib/mysql/localhost-slow.log 慢查询阀值：  sql show variables like \u0026lsquo;%long_query_time%\u0026rsquo; ;\n 临时设置阀值：  sql set global long_query_time = 5 ; \u0026ndash;设置完毕后，重新登陆后起效 （不需要重启服务）\n 永久设置阀值： /etc/my.cnf 中追加配置： vi /etc/my.cnf [mysqld] long_query_time=3 实例 select sleep(4); select sleep(5); select sleep(3); select sleep(3); --查询超过阀值的SQL：  sql show global status like \u0026lsquo;%slow_queries%\u0026rsquo; ;\n 1. 慢查询的sql被记录在了日志中，因此可以通过日志 查看具体的慢SQL。  shell cat /var/lib/mysql/localhost-slow.log\n 1. 通过mysqldumpslow工具查看慢SQL,可以通过一些过滤条件 快速查找出需要定位的慢SQL mysqldumpslow --help s：排序方式 r:逆序 l:锁定时间 g:正则匹配模式 **linux命令** 获取返回记录最多的3个SQL mysqldumpslow -s r -t 3 /var/lib/mysql/localhost-slow.log 获取访问次数最多的3个SQL mysqldumpslow -s c -t 3 /var/lib/mysql/localhost-slow.log 按照时间排序，前10条包含left join查询语句的SQL mysqldumpslow -s t -t 10 -g \u0026quot;left join\u0026quot; /var/lib/mysql/localhost-slow.log 语法： mysqldumpslow 各种参数 慢查询日志的文件 ## 分析海量数据 **模拟海量数据 存储过程（无return）/存储函数（有return）**  sql create database testdata ; use testdata\ncreate table dept ( dno int(5) primary key default 0, dname varchar(20) not null default \u0026ldquo;, loc varchar(30) default \u0026ldquo; )engine=innodb default charset=utf8;\ncreate table emp ( eid int(5) primary key, ename varchar(20) not null default \u0026ldquo;, job varchar(20) not null default \u0026ldquo;, deptno int(5) not null default 0 )engine=innodb default charset=utf8;\n #### 通过存储函数 插入海量数据： 1. 创建存储函数： ```sql randstring(6) -\u0026gt;aXiayx 用于模拟员工名称 delimiter $ create function randstring(n int) returns varchar(255) begin declare all_str varchar(100) default 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ; declare return_str varchar(255) default '' ; declare i int default 0 ; while i\u0026lt;n do set return_str = concat( return_str, substring(all_str, FLOOR(1+rand()*52) ,1) ); set i=i+1 ; end while ; return return_str; end $ ``` --如果报错：You have an error in your SQL syntax，说明SQL语句语法有错，需要修改SQL语句； 如果报错`This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)` 是因为 存储过程/存储函数在创建时 与之前的 开启慢查询日志冲突了 解决冲突： 临时解决( 开启log_bin_trust_function_creators )  sql show variables like \u0026lsquo;%log_bin_trust_function_creators%\u0026lsquo;;\n\tset global log_bin_trust_function_creators = 1;\n 永久解决：  s /etc/my.cnf [mysqld] log_bin_trust_function_creators = 1\n **创建产生随机整数存储函数（0-99）**  sql create function ran_num() returns int(5) begin declare i int default 0; set i =floor( rand()*100 ) ; return i ; end $\n **通过存储过程插入海量数据：** emp表中，从eid_start开始插入data_times条数据  sql create procedure insert_emp( in eid_start int(10),in data_times int(10)) begin declare i int default 0; set autocommit = 0 ; repeat insert into emp values(eid_start + i, randstring(5) ,\u0026lsquo;other\u0026rsquo; ,ran_num()) ; set i=i+1 ; until i=data_times end repeat ; commit ; end $\n **--通过存储过程插入海量数据：dept表中**  sql create procedure insert_dept(in dno_start int(10) ,in data_times int(10)) begin declare i int default 0; set autocommit = 0 ; repeat\n insert into dept values(dno_start+i ,randstring(6),randstring(8)) ; set i=i+1 ; until i=data_times end repeat ;  commit ; end$\n **--插入数据**  sql delimiter ; call insert_emp(1000,800000) ; call insert_dept(10,30) ;\n #### 分析海量数据: ##### profiles  shell show profiles ; \u0026ndash;默认关闭\nshow variables like \u0026lsquo;%profiling%\u0026rsquo;;\nset profiling = on ;\nshow profiles ：会记录所有profiling打开之后的 全部SQL查询语句所花费的时间。缺点：不够精确，只能看到 总共消费的时间，不能看到各个硬件消费的时间（cpu io ）\n ##### 精确分析:sql诊断  sql show profile all for query 上一步查询的的Query_Id\nshow profile cpu,block io for query 上一步查询的的Query_Id\n ##### 全局查询日志 ： 记录开启之后的 全部SQL语句。 （这次全局的记录操作 仅仅在调优、开发过程中打开即可，在最终的部署实施时 一定关闭）  sql show variables like \u0026lsquo;%general_log%\u0026lsquo;;\n * --执行的所有SQL记录在表中 ```sql set global general_log = 1 ;--开启全局日志 set global log_output='table' ; --设置 将全部的SQL 记录在表中 ``` * --执行的所有SQL记录在文件中 ```sql set global log_output='file' ; set global general_log = on ; set global general_log_file='/tmp/general.log' ; ``` 开启后，会记录所有SQL ： 会被记录mysql.general_log表中。  sql select * from mysql.general_log ;\n ## 锁机制 锁机制 ：解决因资源共享 而造成的并发问题。 示例：买最后一件衣服X A: X 买 ： X加锁 -\u0026gt;试衣服...下单..付款..打包 -\u0026gt;X解锁 B: X 买：发现X已被加锁，等待X解锁， X已售空 分类： 1. 操作类型： 1. 读锁（共享锁）： 对同一个数据（衣服），多个读操作可以同时进行，互不干扰。 2. 写锁（互斥锁）： 如果当前写操作没有完毕（买衣服的一系列操作），则无法进行其他的读操作、写操作 1. 操作范围： 1. 表锁 ：一次性对一张表整体加锁。如MyISAM存储引擎使用表锁，开销小、加锁快；无死锁；但锁的范围大，容易发生锁冲突、并发度低。 1. 行锁 ：一次性对一条数据加锁。如InnoDB存储引擎使用行锁，开销大，加锁慢；容易出现死锁；锁的范围较小，不易发生锁冲突，并发度高（很小概率 发生高并发问题：脏读、幻读、不可重复度、丢失更新等问题）。 1. 页锁 示例： ### 表锁 ： --自增操作 MYSQL/SQLSERVER 支持；oracle需要借助于序列来实现自增  sql create table tablelock ( id int primary key auto_increment , name varchar(20) )engine myisam; insert into tablelock(name) values(\u0026lsquo;a1\u0026rsquo;); insert into tablelock(name) values(\u0026lsquo;a2\u0026rsquo;); insert into tablelock(name) values(\u0026lsquo;a3\u0026rsquo;); insert into tablelock(name) values(\u0026lsquo;a4\u0026rsquo;); insert into tablelock(name) values(\u0026lsquo;a5\u0026rsquo;); commit;\n 增加锁：  sql locak table 表1 read/write ,表2 read/write ,\u0026hellip;\n 查看加锁的表：  sql show open tables ;\n 会话：session :每一个访问数据的dos命令行、数据库客户端工具 都是一个会话 ### 加读锁： 1. 会话0： ```sql lock table tablelock read ; select * from tablelock; --读（查），可以 delete from tablelock where id =1 ; --写（增删改），不可以 ``` 其他表 ```sql select * from emp ; --读，不可以 delete from emp where eid = 1; --写，不可以 ``` 结论1： * --如果某一个会话 对A表加了read锁，则 该会话 可以对A表进行读操作、不能进行写操作：且该会话不能对其他表进行读、写操作。 * --即如果给A表加了读锁，则当前会话只能对A表进行读操作。 2. 会话1（其他会话）： ```sql select * from tablelock; --读（查），可以 delete from tablelock where id =1 ; --写，会“等待”会话0将锁释放 ``` 2. 会话2（其他会话）：操作其他表 ```sql select * from emp ; --读（查），可以 ``` delete from emp where eid = 1; --写，可以 ``` --总结： 会话0给A表加了锁；其他会话的操作： 1. 可以对其他表（A表以外的表）进行读、写操作 1. 对A表：读-可以； 写-需要等待释放锁。 释放锁:  sql unlock tables ;\n ### 加写锁： 1. 会话0： ```sql lock table tablelock write ; ``` 当前会话（会话0） 可以对加了写锁的表 进行任何操作（增删改查）；但是不能 操作（增删改查）其他表 1. 其他会话： 对会话0中加写锁的表 可以进行增删改查的前提是：等待会话0释放写锁 ### MySQL表级锁的锁模式 MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁， 在执行更新操作（DML）前，会自动给涉及的表加写锁。 所以对MyISAM表进行操作，会有以下情况： * 对MyISAM表的读操作（加读锁），不会阻塞其他进程（会话）对同一表的读请求， 但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。 * 对MyISAM表的写操作（加写锁），会阻塞其他进程（会话）对同一表的读和写操作， 只有当写锁释放后，才会执行其它进程的读写操作。 ### 分析表锁定： 查看哪些表加了锁：  sql show open tables ; 1代表被加了锁\n 分析表锁定的严重程度：  sql show status like \u0026lsquo;table%\u0026rsquo; ;\nTable_locks_immediate :即可能获取到的锁数\nTable_locks_waited：需要等待的表锁数(如果该值越大，说明存在越大的锁竞争)\n 一般建议： Table_locks_immediate/Table_locks_waited \u0026gt; 5000， 建议采用InnoDB引擎，否则MyISAM引擎 ### 行锁（InnoDB）  sql create table linelock( id int(5) primary key auto_increment, name varchar(20) )engine=innodb ; insert into linelock(name) values(\u0026lsquo;1\u0026rsquo;) ; insert into linelock(name) values(\u0026lsquo;2\u0026rsquo;) ; insert into linelock(name) values(\u0026lsquo;3\u0026rsquo;) ; insert into linelock(name) values(\u0026lsquo;4\u0026rsquo;) ; insert into linelock(name) values(\u0026lsquo;5\u0026rsquo;) ;\n --mysql默认自动commit; oracle默认不会自动commit ; 为了研究行锁，暂时将自动commit关闭;  sql set autocommit =0 ;\n 以后需要通过commit 会话0： 写操作  sql insert into linelock values(6,\u0026lsquo;a6\u0026rsquo;) ;\n 会话1： 写操作 同样的数据  sql update linelock set name=\u0026lsquo;ax\u0026rsquo; where id = 6;\n 对行锁情况： 1. 如果会话x对某条数据a进行 DML操作（研究时：关闭了自动commit的情况下），则其他会话必须等待会话x结束事务(commit/rollback)后 才能对数据a进行操作。 2. 表锁 是通过unlock tables，也可以通过事务解锁 ; 行锁 是通过事务解锁。 行锁，操作不同数据： 会话0： 写操作  sql insert into linelock values(8,\u0026lsquo;a8\u0026rsquo;) ;\n 会话1： 写操作， 不同的数据  sql update linelock set name=\u0026lsquo;ax\u0026rsquo; where id = 5;\n 行锁，一次锁一行数据；因此 如果操作的是不同数据，则不干扰。 行锁的注意事项： 1. 如果没有索引，则行锁会转为表锁 ```sql show index from linelock ; alter table linelock add index idx_linelock_name(name); ``` 会话0： 写操作 ```sql update linelock set name = 'ai' where name = '3' ; ``` 会话1： 写操作， 不同的数据 ```sql update linelock set name = 'aiX' where name = '4' ; ``` 两者互不干扰 会话0： 写操作 ```sql update linelock set name = 'ai' where name = 3 ; ``` 会话1： 写操作， 不同的数据 ```sql update linelock set name = 'aiX' where name = 4 ; ``` --可以发现，数据被阻塞了（加锁） -- 原因：如果索引类 发生了类型转换，则索引失效。 因此 此次操作，会从行锁 转为表锁。 1. 行锁的一种特殊情况：间隙锁：值在范围内，但却不存在 --此时linelock表中 没有id=7的数据 ```sql update linelock set name ='x' where id \u0026gt;1 and id\u0026lt;9 ; ``` --即在此where范围中，没有id=7的数据，则id=7的数据成为间隙。 ```sql insert into linelock values(7,\u0026quot;zs\u0026quot;); ``` --结果被锁住了 间隙：Mysql会自动给 间隙 加锁 -\u0026gt;间隙锁。即 本题 会自动给id=7的数据加 间隙锁（行锁）。 行锁：如果有where，则实际加锁的范围 就是where后面的范围（不是实际的值）（2-8之间都加上锁） 如果仅仅是查询数据，能否加锁？ 可以 `for update ` 研究学习时，将自动提交关闭：(三种方式)  sql set autocommit =0 ;\nstart transaction ;\nbegin ;\n sql select * from linelock where id =2 for update ;\n通过`for update`对`query`语句进行加锁。 **行锁**： InnoDB默认采用行锁； 缺点： 比表锁性能损耗大。 优点：并发能力强，效率高。 因此建议，高并发用InnoDB，否则用MyISAM。 行锁分析：  sql show status like \u0026lsquo;%innodb_row_lock%\u0026rsquo; ;\nInnodb_row_lock_current_waits :当前正在等待锁的数量\nInnodb_row_lock_time：等待总时长。从系统启到现在 一共等待的时间 Innodb_row_lock_time_avg ：平均等待时长。从系统启到现在平均等待的时间 Innodb_row_lock_time_max ：最大等待时长。从系统启到现在最大一次等待的时间 Innodb_row_lock_waits ：\t等待次数。从系统启到现在一共等待的次数\n ### 主从复制 （集群在数据库的一种实现） 集群的优点 1. 负载均衡 2. 失败迁移 windows:mysql 主 linux:mysql从 安装windows版mysql: 如果之前计算机中安装过Mysql，要重新再安装 则需要：先卸载 再安装 #### 先卸载： 1. 通过电脑自带卸载工具卸载Mysql (电脑管家也可以) 2. 删除一个mysql缓存文件夹C:\\ProgramData\\MySQL 3. 删除注册表regedit中所有mysql相关配置 4. --重启计算机 #### 安装MYSQL： [下载官网](https://dev.mysql.com/downloads/mysql/5.5.html#downloads) 安装时，如果出现未响应： 则重新打开 xxx\\bin\\MySQLInstanceConfig.exe 图形化客户端： SQLyog, Navicat 如果要远程连接数据库，则需要授权远程访问。 在linux中授权远程访问 :(A-\u0026gt;B,则再B计算机的Mysql中执行以下命令) GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION; FLUSH PRIVILEGES; 如果仍然报错：可能是防火墙没关闭 ： 在B关闭防火墙  shell service iptables stop\n 实现主从同步（主从复制）： 主从同步的核心：通过二进制日志 1. master将改变的数 记录在本地的 二进制日志中（binary log） ；该过程 称之为：二进制日志事件 2. slave将master的binary log拷贝到自己的 relay log（中继日志文件）中 3. 中继日志事件，将数据读取到自己的数据库之中 MYSQL主从复制 是异步的，串行化的， 有延迟 MYSQL主从复制是异步的，串行化的，有延迟的 master:slave = 1:n 配置： windows(mysql: my.ini) linux(mysql: my.cnf) 配置前，为了无误，先将权限(远程访问)、防火墙等处理： 关闭windows/linux防火墙： 1. windows：右键“网络” 2. linux: ```shell service iptables stop ``` Mysql允许远程连接(windowos/linux)： GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION; FLUSH PRIVILEGES; window mysql8.0 版本修改允许访问远程权限 use mysql; select host, user, authentication_string, plugin from user; update user set host='%' where user='root'; grant all privileges on *.* to root@'%'; flush privileges; #### 主机（以下代码和操作 全部在主机windows中操作）：my.ini [mysqld] #id server-id=1 #二进制日志文件（注意是/ 不是\\） log-bin=\u0026quot;C:/Program Files/MySQL/MySQL Server 8.0/data/mysql-bin\u0026quot; #错误记录文件 log-error=\u0026quot;C:/Program Files/MySQL/MySQL Server 8.0/data/mysql-error\u0026quot; #主从同步时 忽略的数据库 binlog-ignore-db=mysql #(可选)指定主从同步时，同步哪些数据库 binlog-do-db=test windows中的数据库 授权哪台计算机中的数据库 是自己的从数据库： GRANT REPLICATION slave,reload,super ON *.* TO 'root'@'192.168.2.%' IDENTIFIED BY 'root'; flush privileges ; 查看主数据库的状态（每次在左主从同步前，需要观察 主机状态的最新值）  sql show master status;（mysql-bin.000001、 107）\n（mysql-bin.000001、 107）：二进制文件名和位置 #### 从机（以下代码和操作 全部在从机linux中操作）： my.cnf [mysqld] server-id=2 log-bin=mysql-bin replicate-do-db=test linux中的数据 授权哪台计算机中的数控 是自己的主计算机 CHANGE MASTER TO MASTER_HOST = '192.168.2.2', MASTER_USER = 'root', MASTER_PASSWORD = 'root', MASTER_PORT = 3306, master_log_file='mysql-bin.000001', master_log_pos=107; 如果报错：This operation cannot be performed with a running slave; run STOP SLAVE first 解决：  shell STOP SLAVE ;\n 再次执行上条授权语句 #### 开启主从同步： 从机linux:  shell start slave ;\n 检验  sql show slave status \\G\n 主要观察： Slave_IO_Running和 Slave_SQL_Running，确保二者都是yes；如果不都是yes，则看下方的 Last_IO_Error。 本次 通过 Last_IO_Error发现错误的原因是 主从使用了相同的server-id， 检查:在主从中分别查看serverid:  sql show variables like \u0026lsquo;server_id\u0026rsquo; ;\n 可以发现，在Linux中的my.cnf中设置了server-id=2，但实际执行时 确实server-id=1，原因：可能是 linux版Mysql的一个bug，也可能是 windows和Linux版本不一致造成的兼容性问题。 解决改bug：  sql set global server_id =2 ;\n重复执行上面  shell stop slave ;\nset global server_id =2 ;\nstart slave ;\nshow slave status \\G ``` 确保两个是yes\n演示： 主windows =\u0026gt;从\nwindows:\n将表，插入数据  linux\n观察从数据库中该表的数据  ","id":22,"section":"posts","summary":"系统使用的Linux Centos6 MySQL版本： 基础 5.x: 5.0-5.1:早期产品的延续，升级维护 5.4 - 5.x : MySQL整合了三方公司的新存储引擎 （推荐5.5","tags":["数据库"],"title":"SQL优化Mysql版","uri":"https://mumulx.github.io/2020/01/sql%E4%BC%98%E5%8C%96mysql%E7%89%88/","year":"2020"},{"content":" MybatisPlus mubatis plus 官网\nMyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生\nORM（Object Relational Mapping）框架采用元数据来描述对象与关系映射的细节，元数据一般采用XML格式，并且存放在专门的对象一映射文件中。\n只要提供了持久化类与表的映射关系，ORM框架在运行时就能参照映射文件的信息，把对象持久化到数据库中。当前ORM框架主要有五种：Hibernate(Nhibernate)，iBATIS，mybatis，EclipseLink，JFinal。\nORM是通过使用描述对象和数据库之间映射的元数据,在我们想到描述的时候自然就想到了xml和特性(Attribute).目前的ORM框架中,Hibernate就是典型的使用xml文件作为描述实体对象的映射框架,而大名鼎鼎的Linq则是使用特性(Attribute)来描述的。\n开发MyBatis Plus:  jar\n 数据表\u0026ndash;类\nstudent Student  MyBatis配置 文件 mybatis.xml (没有具体的配置信息，因为会放入Spring中配置)\n 日志 log4j.xml\n 数据库的连接信息\n Spring配置文件\n  spring boot:自动管理版本\nspring:版本手工 mybatis - plus\n切换到 MyBatis-PLus\n\u0026lt;bean id=\u0026quot;sqlSessionFactoryBean\u0026quot; class=\u0026quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean\u0026quot; \u0026gt;  mybatis 配置文件模板 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026quot;-//mybatis.org//DTD Config 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026quot;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;environment id=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot; /\u0026gt; \u0026lt;!-- 配置数据库连接信息 --\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;oracle.jdbc.OracleDriver\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:XE\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;system\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;sa\u0026quot; /\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!-- 在配置文件（conf.xml）中注册SQL映射文件（studentMapper.xml）--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026quot;org/lanqiao/entity/studentMapper.xml\u0026quot; /\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;  CRUD操作 JDBC: Dao接口 Dao实现类\nMyBatis: Mapper接口- SQL映射文件\nMyBatis-PLus : Mapper接口\nMyBatis-PLus：只写接口不需要写sql语句\n一个接口 extends BaseMapper，之后无需编写 SQL映射文件，该接口的对象全部操作哦Student对象\n 类名\u0026mdash;-表名\n@TableName(\u0026quot;tb_student\u0026quot;)  对象的属性\u0026mdash;表的字段 一一对应关系：\n@TableId、@TableField @TableId(value = \u0026quot;stuno\u0026quot;,type = IdType.AUTO)//指定自增  主键的自增依赖于数据库已经设置好了主键自增\n属性的驼峰命名法会变成下划线命名\n属性：stuName\u0026ndash;\u0026gt;字段：stu_name\n如果不想转换可以在配置文件中设置\n\u0026lt;!--配置属性和字段驼峰命名和下划线命名不互相转换 默认值是true--\u0026gt; \u0026lt;setting name=\u0026quot;mapUnderscoreToCamelCase\u0026quot; value=\u0026quot;false\u0026quot;/\u0026gt;  一般默认表中字段为下划线，类中属性为驼峰\nmybatisplus不需要在像mybatis那样执行后需要commit\n雪花算法\n  MyBatis-plus:\n 更换成MybatisSqlSessionFactoryBean\n 继承一个父接口 extends BaseMapper，之后就可以使用该接口中 已经存在的CRUD方法 操作 。 通过注解 将 表（字段） - 类（属性）  MP： where语句：Warpper实现 ， QueryWarpper(查询) UpdateWrapper（DML）\nMP源码 回顾：\nMappedStatement对象 就是 \u0026lt;select\u0026gt;等标签\nMyBatis/MP都是通过 MappedStatement对象来指向增删改\n预加载：MP启动时，会指定加载所有常见的 CRUD语句 （来自于MP提供的BaseMapper接口），并将这些语句封装到了MappedStatement对象中。\nAR: activeRecoder ,形式 ：通过实体类Student直接进行增删改查操作（不需要借助于Mapper对象） 继承Model类即可\npublic class Student extends Model\u0026lt;Student\u0026gt;  public static void testAR(){ // 必须在IOC容器中进行AR new ClassPathXmlApplicationContext(\u0026quot;applicationContext.xml\u0026quot;); Student student = new Student(\u0026quot;哈哈\u0026quot;, 22); student.insert(); }  注意：使用时 必须先加载IOC容器，目的 是为了让AR知道 要操作的是数据库在哪里\nMP将主键设置为了Serializable，类型。目的 ：可以接受常见的类型：8个基本类型+String -\u0026gt;Serializable\n逆向工程(代码生成器) MyBatis:\nstudent表-\u0026gt;Student类、Mapper接口、mapper.xml\nMyBatis Plus:\nstudent表-\u0026gt;Student类、Mapper接口、mapper.xml、Service、Controller\n区别：\n MyBatis: 模版配置文件 MyBatis Plus:类  具体使用参见官网\nlombok：可以给类的属性生成set get 构造方法等 1. 依赖 2. 配置\n分页 分页：复习\n\u0026lt;select\u0026gt;等标签 -\u0026gt; MappedStatement对象\nboundSql ：将我们写的SQL和参数值进行了拼接后的对象，即最终能被真正执行的SQL\n拦截器：编写拦截器、注入拦截器，放入 \u0026lt;plugins\u0026gt;即可。 作用：对SQL进行“修改”\n分页： MyBatis Plus\n\u0026lt;!-- 拦截器 分页--\u0026gt; \u0026lt;property name=\u0026quot;plugins\u0026quot;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;!-- 分页插件--\u0026gt; \u0026lt;bean class=\u0026quot;com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor\u0026quot;\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt;  public static void testPage() { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;applicationContext.xml\u0026quot;); StudentMapper studentMapper = context.getBean(\u0026quot;studentMapper\u0026quot;, StudentMapper.class); Page\u0026lt;Student\u0026gt; page = new Page\u0026lt;\u0026gt;(2, 2); //select * from student ; 第二个参数来存放where条件 IPage\u0026lt;Student\u0026gt; pages = studentMapper.selectPage(page, null); System.out.println(\u0026quot;当前页得数据++++\u0026quot;+ page.getRecords()); System.out.println(\u0026quot;当前页页码++++\u0026quot;+ page.getCurrent()); System.out.println(\u0026quot;总数据量++++\u0026quot;+ page.getTotal()); System.out.println(\u0026quot;每一页得数据量++++\u0026quot;+ page.getSize()); }  分析分页源码\n\tselect *from xxx -\u0026gt;PaginationInterceptor select *from xxx LIMIT 2,2\n攻击 SQL 阻断解析器 作用！阻止恶意的全表更新删除\n跟分页类一样\n性能分析插件 性能分析拦截器，用于输出每条 SQL 语句及其执行时间\n乐观锁插件 悲观锁：synchorinzed，lock；总以为会冲突，当第一个人访问得时候，把数据加上锁，其他人访问不到该数据，知道第一个人结束访问。并发操作变成串行操作（效率太低严重影响性能） 乐观锁：cvs算法；总以为不冲突；在修改的一瞬间去检验一下\nsql注入器 sql语句的实现方式  mybatis:\tstudentMapper.xml\t  \tselect * from xxx \n\t​\t mybatis:\t@Select(\u0026quot;select....\u0026quot;)  MP:\textends BaseMapper\u0026lt;Student\u0026gt;  MP:\t自己写SQL。Sql 注入器，仿照方式“3” 自己编写一个 带SQL的方法 deleteAllStudents();\n 自定义方法 -\u0026gt;写sql语句 + 标签名 MyDelete extends AbstractMethod 自定义Sql 注入器 ： 包含原来17个 + 自己的MyDelete 配置 告知MP,以后使用自定义注入器   逻辑删除 逻辑删除（假删除）：\n@TableLogic private Integer deleted;  在表中增加相应字段\n逻辑删除：为了数据安全\n全局配置： 以 表名加前缀位置\n\u0026lt;property name=\u0026quot;dbConfig\u0026quot; \u0026gt; \u0026lt;bean class=\u0026quot;com.baomidou.mybatisplus.core.config.GlobalConfig$DbConfig\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;logicDeleteValue\u0026quot; value=\u0026quot;1\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;logicNotDeleteValue\u0026quot; value=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;tablePrefix\u0026quot; value=\u0026quot;tb_\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt;  @TableName(value=\u0026quot;student\u0026quot;,keepGlobalPrefix=true)  自动填充插件 Sequence主键 实现oracle数据库的自增\nmvn仓库添加oracle jar  将ojdbc7.jar复制到mvn的本地仓库\n cmd执行\nmvn install:install-file -DgroupId=ojdbc -DartifactId=ojdbc7 -Dversion=7.0.0.1 -Dpackaging=jar -Dfile=ojdbc7.jar   MybatisX 快速开发插件 MybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。\n本插件时针对于mubatis开发的\nMyBatis Plus的源码 github地址\nMapper mapper 码云地址\n与MP时同级的关系都是对mybatis的插件\nmapper github地址\nmybatis/mp:\n\u0026lt;bean id=\u0026quot;configurer\u0026quot; class=\u0026quot;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026quot; \u0026gt; \u0026lt;property name=\u0026quot;basePackage\u0026quot; value=\u0026quot;com.yq.mapper\u0026quot; \u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  Mapper：\n【tk】\\.mybatis.spring.mapper.MapperScannerConfigure  回顾：\nmapper配置：和mybatis基本一致：唯一不同的 org-\u0026gt;tk\nMP:\npublic interface StudentMapper extends baomidou.....BaseMapper\u0026lt;Student\u0026gt; {  Mapper:\npublic interface StudentMapper extends Mapper\u0026lt;Student\u0026gt; {  mapper的核心：\nMapper父接口中 有很多细化的父接口（每个细化的父接口负责一件事情： x）\n主键：包装类Integer/ Long ，不要使用基本类型\n只支持单表操作\n标识@id\nSELECT stu_no,stu_name,stu_age FROM tb_student WHERE stu_no = ?  没有标识@id :默认 将全部字段作为联合主键\nSELECT stu_no,stu_name,stu_age FROM tb_student WHERE stu_no = ? AND stu_name = ? AND stu_age = ?  MP 可以将主键值 会写到 对象中；\nmapper默认不会， 如果要： 配置\n@Id() @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer stuNo ;//stuNo -\u0026gt; stu_no  插入数据时，如果不给主键赋值，是否回写？\nzs 23 -\u0026gt; 18,zs ,23   mysql 或其他自带 “自增功能”的数据库：\n@Id() @GeneratedValue(strategy = GenerationType.IDENTITY)  oracle不带自增：\n@Id()\n @KeySql(sql = \u0026quot;select SEQ_stu.nextval from dual\u0026quot;, order = ORDER.BEFORE)   通过序列实现自增\nselectOne(stu) stu:查询条件，类似于MP 中的wrapper\n selective\nINSERT INTO tb_student ( stu_no,stu_name ) VALUES( ?,? )  没有selectvie\nINSERT INTO tb_student ( stu_no,stu_name,stu_age ) VALUES( ?,?,? )  selective：对于没有操作的值，不进行任何处理\n没有selective：对于没有操作的值， 赋值为NULL 。可以发现，selective在insert操作 基本没有区别.\n但对于修改，一般建议 加上selective,不用修改的字段会保留原来的值，而不会赋值为null\n  mapper 代码生成器 mapper 自由组合功能 新增方法 mapper 的源码 mapper逆向工程\nmapper\n","id":23,"section":"posts","summary":"MybatisPlus mubatis plus 官网 MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生 ORM（Object","tags":["Spring家族"],"title":"MybatisPlus和Mapper框架","uri":"https://mumulx.github.io/2020/01/mybatisplus%E5%92%8Cmapper%E6%A1%86%E6%9E%B6/","year":"2020"},{"content":" Java反射 RTTI（RunTime Type Information，运行时类型信息）\n反射机制是在[运行状态]中:\n 对于任意一个类，都能够知道这个类的所有属性和方法;\n 对于任意一个对象，都能够调用它的任意一一个方法和属性;\n  反射提供的功能:  在运行时判断任意一个对象所属的类;\n 在运行时构造任意一个类的对象;\n 在运行时判断任意一个类所具有的成员变量和方法;\n 在运行时调用任意\u0026ndash;个对象的方法;\n 生成动态代理。\n  获取反射对象（反射入口）  Class.forName(全类名) xx.class 对象.getClass\n//通过反射获取类 //1. Class.forname() try { Class\u0026lt;?\u0026gt; forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); System.out.println(forName); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } //2. 类名.class Class\u0026lt;?\u0026gt; forName2 =Person.class; System.out.println(forName2); //3. 对象.getClass Person per = new Person(); Class\u0026lt;?\u0026gt; forName3=per.getClass(); System.out.println(forName3);   获取方法 public static void test2() { Class\u0026lt;?\u0026gt; forName = null ; //class try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } //获取所有的公共的方法 /* * 本类以及父类、接口中的所有的方法 * * 符合访问修饰符的规律 * */ Method[] methods = forName.getMethods(); for(Method method:methods) { System.out.println(method); } }  获取所有的方法 // 获取当前类所有方法 //1.只能是当前类 //2.忽略访问修饰符限制 public static void test7() { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Method[] declaredMethods = forName.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) { System.out.println(declaredMethod); } }  获取接口 //获取所有接口 public static void test3() { Class\u0026lt;?\u0026gt; forName = null ; //class try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } // 获取当前类的所有接口 Class\u0026lt;?\u0026gt;[] interfaces = forName.getInterfaces(); for(Class\u0026lt;?\u0026gt; inter:interfaces) { System.out.println(inter); } }  获取父类 //获取所有父类 public static void test4() { Class\u0026lt;?\u0026gt; forName = null ; //class try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } // 获取所有父类 单继承 Class\u0026lt;?\u0026gt; superclass = forName.getSuperclass(); System.out.println(superclass); }  获取所有的构造方法 //获取所有构造方法 public static void test5() { Class\u0026lt;?\u0026gt; forName = null ; //class try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } // 获取所有父类 单继承 Constructor\u0026lt;?\u0026gt;[] constructors = forName.getConstructors(); for(Constructor\u0026lt;?\u0026gt; constructor:constructors) System.out.println(constructor); }\t 获取所有的公共属性 // 获取所有公共属性 public static void test6() { Class\u0026lt;?\u0026gt; forName = null; // class try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } // 获取所有父类 单继承 Field[] fields = forName.getFields(); for (Field field : fields) { System.out.println(field); } }  获取所有属性 // 获取当前类所有属性 //1.只能是当前类 //2.忽略访问修饰符限制 public static void test8() { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Field[] declaredFields = forName.getDeclaredFields(); for (Field declaredField : declaredFields) { System.out.println(declaredField); } }\t 获取当前反射所代表类（接口）的对象 // 获取当前反射所代表类（接口）的对象 public static void test9() throws InstantiationException, IllegalAccessException { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Object instance = forName.newInstance(); Person person = (Person)instance; System.out.println(person); }  获取对象的实例，并操作对象 // 获取对象的实例，并操作对象 public static void test1() throws InstantiationException, IllegalAccessException { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Person person = (Person) forName.newInstance(); person.setId(22); person.setName(\u0026quot;zs\u0026quot;); System.out.println(person.getId() + \u0026quot;---\u0026quot; + person.getName()); }  操作属性 // 操作属性 public static void test2() throws InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Person person = (Person) forName.newInstance(); Field idField = forName.getDeclaredField(\u0026quot;id\u0026quot;); //访问的是private修饰的id，但是 peivate是私有 // 因此要修改属性的访问权限，使用反射时，如果是因为访问修饰符限制造成异常，可以通过setAccessible(true)方法解决 // 同理方法也具有setAccessible(true)的方法 idField.setAccessible(true); idField.set(person, 1);//相当于 person.setId(1); System.out.println(person.getId()); }  操作方法 // 操作方法 public static void test3() throws InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Person person = (Person) forName.newInstance(); Method myPrivateMethod= forName.getDeclaredMethod(\u0026quot;privateMethod\u0026quot;, null); // 同理方法也具有setAccessible(true)的方法 myPrivateMethod.setAccessible(true); myPrivateMethod.invoke(person, null); }  操作方法 带参 // 操作方法 带参 public static void test4() throws InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Person person = (Person) forName.newInstance(); Method myPrivateMethod1= forName.getDeclaredMethod(\u0026quot;privateMethod1\u0026quot;, String.class); // 同理方法也具有setAccessible(true)的方法 myPrivateMethod1.setAccessible(true); myPrivateMethod1.invoke(person, \u0026quot;hello\u0026quot;); }  操作构造方法 // 操作构造方法 public static void test5() throws InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } // 在反射中，根据类型获取方法时；基本类型(int\\char) 和包装类（Integer，Character）时不同的类型 Constructor\u0026lt;?\u0026gt; constructor = forName.getConstructor(int.class); System.out.println(constructor); }  获取私有的构造方法 // 操作构造方法 public static void test6() throws InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Constructor\u0026lt;?\u0026gt; constructor = forName.getDeclaredConstructor(String.class); System.out.println(constructor); }  构造方法new对象 // 操作构造方法 new对象 public static void test7() throws InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException { Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(\u0026quot;com.lx.myclass.Person\u0026quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } Constructor\u0026lt;?\u0026gt; constructor = forName.getConstructor(int.class); System.out.println(constructor); Person per = (Person) constructor.newInstance(10); System.out.println(per); }  注意传参\n动态加载类名和方法 class.txt\nclassName=com.lx.myclass.Person methodName = staticMethod  //动态加载类名和方法 public static void test8() throws FileNotFoundException, IOException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException { Properties properties = new Properties(); properties.load(new FileReader(\u0026quot;class.txt\u0026quot;)); String classname = properties.getProperty(\u0026quot;className\u0026quot;); String methodName = properties.getProperty(\u0026quot;methodName\u0026quot;); Class\u0026lt;?\u0026gt; forName = null; try { forName = Class.forName(classname); } catch (ClassNotFoundException e) { e.printStackTrace(); } Method method = forName.getMethod(methodName); method.invoke(forName.newInstance()); }  反射可以越过 泛型检查 //反射可以越过 泛型检查 public static void test9() throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException { //此时只能添加Integer类型 ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); list.add(1); list.add(2); //list.add(\u0026quot;zs\u0026quot;); Class\u0026lt;?\u0026gt; listclass= list.getClass(); Method method = listclass.getMethod(\u0026quot;add\u0026quot;, Object.class); method.invoke(list, \u0026quot;zs\u0026quot;); System.out.println(list); }  不推荐这样做\n就像不推荐反射操作private修饰的东西\n虽然可以通反射访问 private等修饰符不允许访问的属性/方法，也可以忽略掉泛型的约束；但是实际的开发，不建议这样使用，因此可能造成程序的混乱。\n万能set import java.lang.reflect.Field; public class MyProperty { //per.setXxx(value) public static void setProperty(Object obj,String propertyName,Object value) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { Class\u0026lt;?\u0026gt; class1 = obj.getClass(); Field field = class1.getDeclaredField(propertyName); field.setAccessible(true); field.set(obj, value); } }  public static void test10() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException{ Person person = new Person(); MyProperty.setProperty(person, \u0026quot;name\u0026quot;, \u0026quot;zs\u0026quot;); MyProperty.setProperty(person, \u0026quot;age\u0026quot;, 23); Student student = new Student(); MyProperty.setProperty(student, \u0026quot;score\u0026quot;, 98); System.out.println(person); System.out.println(student); }  源码 github地址\njava加密解密 使用异或进行加密解密 异或: * 同为0，异为1; * 一个数，两次异或之后，是原数本身\n一个数据异或一次：加密\n一个数据异或两次：解密\n是可逆的\npackage utils; public class SecurityUtil { //通过异或进行加密和解密 传入string(\u0026quot;abc\u0026quot;)---\u0026gt;String(\u0026quot;xyz\u0026quot;) public static String xor(String in) {//\u0026quot;abc\u0026quot;---\u0026gt;{'a','b','c'}字符串变成字符数组 //char 和int之间时可以直接转换的 //String 和int之间时无法进行运算的 char[] chs = in.toCharArray(); for(int i = 0; i \u0026lt; chs.length;i++) { //^ 异或符号 chs[i] = (char)(chs[i]^3000); } return new String(chs); } public static void main(String[] args) { String str = \u0026quot;hello\u0026quot;; str = xor(str);// 第一次异或 加密 System.out.println(str); str = xor(str);// 第二次异或 解密 System.out.println(str); } }  MD5 字符串 \u0026mdash;\u0026gt; 十六进制串\n是不可逆的\n引入jar包 commons-codec-1.10.jar\n代码 import org.apache.commons.codec.digest.DigestUtils; public class MD5 { public static String md5Encode(byte[] input) { return DigestUtils.md5Hex(input);//byte[]---\u0026gt;String } public static void main(String[] args) { // TODO Auto-generated method stub String str = \u0026quot;hello\u0026quot;; str = md5Encode(str.getBytes()); System.out.println(str); } }  SHA256加密 引入jar包 commons-codec-1.10.jar\n代码 import org.apache.commons.codec.digest.DigestUtils; public class MD5 { //SHA256 public static String SHA256Encode(byte[] input) { return DigestUtils.sha256Hex(input);//byte[]---\u0026gt;String }\tpublic static void main(String[] args) { String str = \u0026quot;hello\u0026quot;; str = SHA256Encode(str.getBytes()); System.out.println(str); } }  MD5和SHA256的异同  同：\n都是不可逆\n 异\nMD5：速度较快\nSHA256：安全性较高\n  Base64 import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Base { //base64 加密 public static String base64Encode(byte[] input) { String result = null; //反射 try { Class clazz = Class.forName(\u0026quot;com.sun.org.apache.xerces.internal.impl.dv.util.Base64\u0026quot;); Method method = clazz.getMethod(\u0026quot;encode\u0026quot;, byte[].class); result = (String)method.invoke(null, input); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } return result; } //base64解密 public static byte[] base64Decode(String input) { byte[] result = null ; try { Class clazz = Class.forName(\u0026quot;com.sun.org.apache.xerces.internal.impl.dv.util.Base64\u0026quot;); Method method = clazz.getMethod(\u0026quot;decode\u0026quot;, String.class); result = (byte[])method.invoke(null, input); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (NoSuchMethodException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (SecurityException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IllegalAccessException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IllegalArgumentException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (InvocationTargetException e) { // TODO Auto-generated catch block e.printStackTrace(); } return result; } public static void main(String[] args) { String str = \u0026quot;hello\u0026quot;; //加密 str = base64Encode(str.getBytes()); System.out.println(\u0026quot;加密\u0026quot;+str); //解密 byte[] rs = base64Decode(str); System.out.println(\u0026quot;解密\u0026quot;+new String(rs)); } }  可逆\n使用的是jdk自带的一个加密解密\n运用到了反射技术\n源码 git地址\nRPC RPC:Remote Procedure Call （远程过程调用）\n \u0026ldquo;HelloService\u0026rdquo;，而服务端需要通过该字符串解析出该字符串代表的接口的一切信息\u0026ndash;》通过反射技术 客户端\u0026ndash;》服务端：socket 服务端需要根据客户端的不同请求，返回不同的接口类型，客户端就要接收到不同的接口类型\u0026mdash;》通过动态代理  客户端 Client.java package com.lx.client; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.OutputStream; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.net.InetSocketAddress; import java.net.Socket; public class Client { // 获取代表服务端接口的动态代理对象 // serviceInterface:请求的接口名 // addr:带请求服务端的ip：端口 @SuppressWarnings(\u0026quot;unchecked\u0026quot;) public static \u0026lt;T\u0026gt; T getRemoteProxyObj(Class serviceInterface, InetSocketAddress addr) { // 动态代理对象 /* * newProxyInstance(a,b,c) a:类加载器：需要代理哪一个类 b:需要代理的对象具有哪些功能(方法) --- 接口（方法在接口中存放 ） */ return (T) Proxy.newProxyInstance(serviceInterface.getClassLoader(), new Class\u0026lt;?\u0026gt;[] {serviceInterface }, new InvocationHandler() { /** * proxy 代理的对象 * * method 对象的哪一个方法 * * args 参数列表 * */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { ObjectInputStream input = null; ObjectOutputStream output = null; Socket socket = new Socket(); try { // 客户端向服务端发送请求：请求某一个具体的接口 // socketAddress:Ip：端口 socket.connect(addr); output = new ObjectOutputStream(socket.getOutputStream());// 发送 通过序列化流(对象流) // 发送：接口名，方法名，方法的参数的类型,方法的参数， output.writeUTF(serviceInterface.getName()); output.writeUTF(method.getName()); output.writeObject(method.getParameterTypes()); output.writeObject(args); // 等待服务端处理 // 接收服务端处理后的返回值 input = new ObjectInputStream(socket.getInputStream()); Object result = input.readObject(); return result; } catch (Exception e) { // TODO: handle exception e.printStackTrace(); return null; } finally { try { if (output != null) { output.close(); } if (input != null) { input.close(); } } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); return null; } } } }); } }  服务端 MyCenter.java package com.lx.center; import java.io.IOException; import java.lang.reflect.InvocationTargetException; //服务中心 public interface MyCenter { public void start(); public void stop(); //注册服务 public void register(Class name,Class serviceImpl); }  MyCenterServer.java package com.lx.center; import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.net.InetSocketAddress; import java.net.ServerSocket; import java.net.Socket; import java.util.HashMap; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import javax.sound.sampled.Port; public class MyCenterServer implements MyCenter { // map:服务端的所有可供客户端访问的接口，都注册到map中 // key:接口的名字 value:真正的接口的实现 private static HashMap\u0026lt;String, Class\u0026gt; serviceRegister = new HashMap\u0026lt;String, Class\u0026gt;(); // 端口 private static int Port;// =9999 // 连接池：连接池中存在多个和连接对象，每一个连接对象都可以处理一个客户请求 // jdk1.5提供 private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); private static boolean isRunning = false; public MyCenterServer(int port) { this.Port = port; } // 开启服务 @Override public void start() { ServerSocket serverSocket = null; try { serverSocket = new ServerSocket(); serverSocket.bind(new InetSocketAddress(Port)); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } isRunning = true; while (true) { // 具体的服务内容；接收客户端请求，处理请求，并返回结果 // TODO Auto-generated method stub // 如果想要让多个客户端请求并发执行 多线程 System.out.println(\u0026quot;start server ... \u0026quot;); // 客户端每次请求一次连接（发送一次请求），则服务端 从连接池中获取一个线程对象去处理 Socket socket = null; try { socket = serverSocket.accept();// 等待客户端连接 } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } executor.execute(new ServiceTask(socket));// .参数是一个多线程对象 } } @Override public void stop() { // TODO Auto-generated method stub isRunning = false; executor.shutdown(); } @Override public void register(Class service, Class serviceImpl) { serviceRegister.put(service.getName(), serviceImpl); } private static class ServiceTask implements Runnable { private Socket socket; public ServiceTask(Socket socket) { this.socket = socket; } public ServiceTask() { } @Override public void run() {// 线程所做的事情 ObjectOutputStream output = null; ObjectInputStream input = null; // 具体的服务内容；接收客户端请求，处理请求，并返回结果 try { // 接收到客户端连接及请求，处理该请求 input = new ObjectInputStream(socket.getInputStream()); // 因为ObjectInputStream对发送数据的顺序严格要求，因此需要参照发送的顺序逐个接收 String serviceName = input.readUTF(); String methodName = input.readUTF(); Class[] parameterTypes = (Class[]) input.readObject();// 参数类型 Object[] arguments = (Object[]) input.readObject();// 方法的参数名 // 根据客户端的请求，找到map中与之对应的具体的接口 Class SerciceClass = serviceRegister.get(serviceName); Method method = SerciceClass.getMethod(methodName, parameterTypes); // 执行该方法 Object result = method.invoke(SerciceClass.newInstance(), arguments); // 向客户端 将执行完毕的返回值 传给客户端 output = new ObjectOutputStream(socket.getOutputStream()); output.writeObject(result); } catch (Exception e) { // TODO: handle exception e.printStackTrace(); } finally { try { if (output != null) { output.close(); } if (input != null) { input.close(); } } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } }  Service HelloService.java package com.lx.service; public interface HelloService { public String sayHi(String name); }  HelloServiceImpl.java package com.lx.service; public class HelloServiceImpl implements HelloService{ @Override public String sayHi(String name) { // TODO Auto-generated method stub System.out.println(\u0026quot;hi\u0026quot;+name); return \u0026quot;hi\u0026quot;+name; } }  Test ClientTest.java package com.lx.test; import java.net.InetSocketAddress; import com.lx.client.Client; import com.lx.service.HelloService; import com.lx.service.HelloServiceImpl; public class ClientTest { public static void main(String[] args) throws ClassNotFoundException { HelloService helloService = Client.getRemoteProxyObj(Class.forName(\u0026quot;com.lx.service.HelloService\u0026quot;), new InetSocketAddress(\u0026quot;127.0.0.1\u0026quot;, 9999)); System.out.println(helloService.sayHi(\u0026quot;zs\u0026quot;)); } }  ServerTest package com.lx.test; import com.lx.center.MyCenter; import com.lx.center.MyCenterServer; import com.lx.service.HelloService; import com.lx.service.HelloServiceImpl; public class ServeTest { public static void main(String[] args) { // 开启一个线程 new Thread(new Runnable() { @Override public void run() { // 服务中心 MyCenter serverCenter = new MyCenterServer(9999); // 将helloService接口及其实现类注册到服务中心 serverCenter.register(HelloService.class, HelloServiceImpl.class); serverCenter.start(); } }).start(); } }  源码地址 github地址\n发送邮件 简单邮件 导包\njavax.mail.jar  import java.util.Date; import java.util.Properties; import javax.mail.Session; import javax.mail.Transport; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeMessage; public class JavaMailDemo { // 发件人的 邮箱 和 密码（替换为自己的邮箱和密码） // PS: 某些邮箱服务器为了增加邮箱本身密码的安全性，给 SMTP 客户端设置了独立密码（有的邮箱称为“授权码”）, // 对于开启了独立密码的邮箱, 这里的邮箱密码必需使用这个独立密码（授权码）。 public static String sendEmailAccount = \u0026quot;收件人qq邮箱\u0026quot;; public static String sendEmailPwd = \u0026quot;请更换为自己的独立密码（授权码）\u0026quot;; public static String receiveMailAccount = \u0026quot;发件人qq邮箱\u0026quot;; //发件人邮箱服务器地址 public static String emailProtocolType = \u0026quot;smtp\u0026quot;; public static String sendEmailSMTPHost = \u0026quot;smtp.qq.com\u0026quot;; public static String smtpPort = \u0026quot;465\u0026quot;; public static String sslSocketFactory = \u0026quot;javax.net.ssl.SSLSocketFactory\u0026quot;; // 发件人邮箱的 SMTP 服务器地址, 必须准确, 不同邮件服务器地址不同, 一般格式为: smtp.xxx.com // 网易163邮箱的 SMTP 服务器地址为: smtp.163.com // 收件人邮箱（替换为自己知道的有效邮箱） public static void main(String[] args) throws Exception { // 1. 创建参数配置, 用于连接邮件服务器的参数配置 Properties props = new Properties(); // 参数配置 props.setProperty(\u0026quot;mail.transport.protocol\u0026quot;, emailProtocolType); // 使用的协议（JavaMail规范要求） props.setProperty(\u0026quot;mail.smtp.host\u0026quot;, sendEmailSMTPHost); // 发件人的邮箱的 SMTP 服务器地址 props.setProperty(\u0026quot;mail.smtp.auth\u0026quot;, \u0026quot;true\u0026quot;); // 需要请求认证 // PS: 某些邮箱服务器要求 SMTP 连接需要使用 SSL 安全认证 (为了提高安全性, 邮箱支持SSL连接, 也可以自己开启), // 如果无法连接邮件服务器, 仔细查看控制台打印的 log, 如果有有类似 “连接失败, 要求 SSL 安全连接” 等错误, // 打开下面 /* ... */ 之间的注释代码, 开启 SSL 安全连接。 /* // SMTP 服务器的端口 (非 SSL 连接的端口一般默认为 25, 可以不添加, 如果开启了 SSL 连接, // 需要改为对应邮箱的 SMTP 服务器的端口, 具体可查看对应邮箱服务的帮助, // QQ邮箱的SMTP(SLL)端口为465或587, 其他邮箱自行去查看) */ //ssl安全认证 props.setProperty(\u0026quot;mail.smtp.port\u0026quot;, smtpPort); //设置socketfactory\tprops.setProperty(\u0026quot;mail.smtp.socketFactory.class\u0026quot;, sslSocketFactory); //只处理SSL的连接, 对于非SSL的连接不做处理 props.setProperty(\u0026quot;mail.smtp.socketFactory.fallback\u0026quot;, \u0026quot;false\u0026quot;); props.setProperty(\u0026quot;mail.smtp.socketFactory.port\u0026quot;, smtpPort); // 2. 根据配置创建会话对象, 用于和邮件服务器交互 Session session = Session.getInstance(props); session.setDebug(true); // 设置为debug模式, 可以查看详细的发送 log // 3. 创建一封邮件 MimeMessage message = createMimeMessage(session, sendEmailAccount, receiveMailAccount); // 4. 根据 Session 获取邮件传输对象 Transport transport = session.getTransport(); // 5. 使用 邮箱账号 和 密码 连接邮件服务器, 这里认证的邮箱必须与 message 中的发件人邮箱一致, 否则报错 // PS_01: 成败的判断关键在此一句, 如果连接服务器失败, 都会在控制台输出相应失败原因的 log, // 仔细查看失败原因, 有些邮箱服务器会返回错误码或查看错误类型的链接, 根据给出的错误 // 类型到对应邮件服务器的帮助网站上查看具体失败原因。 // // PS_02: 连接失败的原因通常为以下几点, 仔细检查代码: // (1) 邮箱没有开启 SMTP 服务; // (2) 邮箱密码错误, 例如某些邮箱开启了独立密码; // (3) 邮箱服务器要求必须要使用 SSL 安全连接; // (4) 请求过于频繁或其他原因, 被邮件服务器拒绝服务; // (5) 如果以上几点都确定无误, 到邮件服务器网站查找帮助。 // // PS_03: 仔细看log, 认真看log, 看懂log, 错误原因都在log已说明。 transport.connect(sendEmailAccount, sendEmailPwd); // 6. 发送邮件, 发到所有的收件地址, message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人 transport.sendMessage(message, message.getAllRecipients()); // 7. 关闭连接 transport.close(); } /** * 创建一封只包含文本的简单邮件 * @param session 和服务器交互的会话 * @param sendMail 发件人邮箱 * @param receiveMail 收件人邮箱 * @return * @throws Exception */ public static MimeMessage createMimeMessage(Session session, String sendMail, String receiveMail) throws Exception { // 1. 创建一封邮件 MimeMessage message = new MimeMessage(session); // 2. From: 发件人（昵称有广告嫌疑，避免被邮件服务器误认为是滥发广告以至返回失败，请修改昵称） message.setFrom(new InternetAddress(sendMail, \u0026quot;setFrom\u0026quot;, \u0026quot;UTF-8\u0026quot;)); // 3. To: 收件人（可以增加多个收件人、抄送、密送） // CC:抄送人，BCC:密送 message.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress(receiveMail, \u0026quot;XX用户\u0026quot;, \u0026quot;UTF-8\u0026quot;)); message.setRecipient(MimeMessage.RecipientType.CC, new InternetAddress(\u0026quot;xxxxxxx@qq.com\u0026quot;, \u0026quot;XX用户\u0026quot;, \u0026quot;UTF-8\u0026quot;)); // 4. Subject: 邮件主题（标题有广告嫌疑，避免被邮件服务器误认为是滥发广告以至返回失败，请修改标题） message.setSubject(\u0026quot;setSubject\u0026quot;, \u0026quot;UTF-8\u0026quot;); // 5. Content: 邮件正文（可以使用html标签）（内容有广告嫌疑，避免被邮件服务器误认为是滥发广告以至返回失败，请修改发送内容） message.setContent(\u0026quot;正文...\u0026quot;, \u0026quot;text/html;charset=utf-8\u0026quot;); // 6. 设置发件时间 message.setSentDate(new Date()); // 7. 保存设置 message.saveChanges(); return message; } }  复杂邮件 import java.util.Date; import java.util.Properties; import javax.activation.DataHandler; import javax.activation.FileDataSource; import javax.mail.Message.RecipientType; import javax.mail.Session; import javax.mail.Transport; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeBodyPart; import javax.mail.internet.MimeMessage; import javax.mail.internet.MimeMultipart; import javax.mail.internet.MimeUtility; public class JavaMailWithAttachments { // 发件人的 邮箱 和 密码（替换为自己的邮箱和密码） public static String sendEmailAccount = \u0026quot;收件人qq邮箱\u0026quot;; public static String sendEmailPwd = \u0026quot;请更换为自己的独立密码（授权码）\u0026quot;; // 发件人邮箱的 SMTP 服务器地址, 必须准确, 不同邮件服务器地址不同, 一般格式为: smtp.xxx.com // 网易163邮箱的 SMTP 服务器地址为: smtp.163.com public static String myEmailSMTPHost = \u0026quot;smtp.qq.com\u0026quot;; // 收件人邮箱（替换为自己知道的有效邮箱） public static String receiveMailAccount = \u0026quot;发件人qq邮箱\u0026quot;; public static void main(String[] args) throws Exception { // 1. 创建参数配置, 用于连接邮件服务器的参数配置 Properties props = new Properties(); // 参数配置 props.setProperty(\u0026quot;mail.transport.protocol\u0026quot;, \u0026quot;smtp\u0026quot;); // 使用的协议（JavaMail规范要求） props.setProperty(\u0026quot;mail.smtp.host\u0026quot;, myEmailSMTPHost); // 发件人的邮箱的 SMTP 服务器地址 props.setProperty(\u0026quot;mail.smtp.auth\u0026quot;, \u0026quot;true\u0026quot;); // 需要请求认证 final String smtpPort = \u0026quot;465\u0026quot;; props.setProperty(\u0026quot;mail.smtp.port\u0026quot;, smtpPort); props.setProperty(\u0026quot;mail.smtp.socketFactory.class\u0026quot;, \u0026quot;javax.net.ssl.SSLSocketFactory\u0026quot;); props.setProperty(\u0026quot;mail.smtp.socketFactory.fallback\u0026quot;, \u0026quot;false\u0026quot;); props.setProperty(\u0026quot;mail.smtp.socketFactory.port\u0026quot;, smtpPort); // 开启 SSL 连接, 以及更详细的发送步骤请看上一篇: 基于 JavaMail 的 Java 邮件发送：简单邮件发送 // 2. 根据配置创建会话对象, 用于和邮件服务器交互 //Session对象的构造方法为private因此需要借助getInstance方法 Session session = Session.getInstance(props); session.setDebug(true); // 设置为debug模式, 可以查看详细的发送 log // 3. 创建一封邮件 MimeMessage message = createMimeMessage(session, sendEmailAccount, receiveMailAccount); // 也可以保持到本地查看 // message.writeTo(file_out_put_stream); // 4. 根据 Session 获取邮件传输对象 Transport transport = session.getTransport(); // 5. 使用 邮箱账号 和 密码 连接邮件服务器 // 这里认证的邮箱必须与 message 中的发件人邮箱一致，否则报错 transport.connect(sendEmailAccount, sendEmailPwd); // 6. 发送邮件, 发到所有的收件地址, message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人 transport.sendMessage(message, message.getAllRecipients()); // 7. 关闭连接 transport.close(); } /** * 创建一封复杂邮件（文本+图片+附件） */ public static MimeMessage createMimeMessage(Session session, String sendMail, String receiveMail) throws Exception { // 1. 创建邮件对象 MimeMessage message = new MimeMessage(session); // 2. From: 发件人 message.setFrom(new InternetAddress(sendMail, \u0026quot;我昵称\u0026quot;, \u0026quot;UTF-8\u0026quot;)); // 3. To: 收件人（可以增加多个收件人、抄送、密送） message.addRecipient(RecipientType.TO, new InternetAddress(receiveMail, \u0026quot;我的收件人昵称\u0026quot;, \u0026quot;UTF-8\u0026quot;)); // 4. Subject: 邮件主题 message.setSubject(\u0026quot;T图片+附件）\u0026quot;, \u0026quot;UTF-8\u0026quot;); // 5. 创建图片“节点” MimeBodyPart imagePart = new MimeBodyPart(); DataHandler imageDataHandler = new DataHandler(new FileDataSource(\u0026quot;src//abc.png\u0026quot;)); // 读取本地文件 imagePart.setDataHandler(imageDataHandler); // 将图片数据添加到“节点” imagePart.setContentID(\u0026quot;image_fairy_tail\u0026quot;); // 为“节点”设置一个唯一编号（在文本“节点”将引用该ID） // 6. 创建文本“节点” MimeBodyPart textPart = new MimeBodyPart(); // 这里添加图片的方式是将整个图片包含到邮件内容中, 实际上也可以以 http 链接的形式添加网络图片 textPart.setContent(\u0026quot;这是一张图片\u0026lt;br/\u0026gt;\u0026lt;img src='cid:image_fairy_tail'/\u0026gt;\u0026quot;, \u0026quot;text/html;charset=UTF-8\u0026quot;); // 7. （文本+图片）设置 文本 和 图片 “节点”的关系（将 文本 和 图片 “节点”合成一个混合“节点”） MimeMultipart mm_text_image = new MimeMultipart(); mm_text_image.addBodyPart(textPart); mm_text_image.addBodyPart(imagePart); mm_text_image.setSubType(\u0026quot;related\u0026quot;); // 关联关系 // 8. 将 文本+图片 的混合“节点”封装成一个普通“节点” MimeBodyPart text_image = new MimeBodyPart(); text_image.setContent(mm_text_image); // 9. 创建附件“节点” MimeBodyPart attachment = new MimeBodyPart(); DataHandler attDataHandler = new DataHandler (new FileDataSource(\u0026quot;src//上课前检查插头.txt\u0026quot;)); // 读取本地文件 attachment.setDataHandler(attDataHandler); // 将附件数据添加到“节点” attachment.setFileName(MimeUtility.encodeText(attDataHandler.getName())); // 设置附件的文件名（需要编码） // 10. 设置（文本+图片）和 附件 的关系（合成一个大的混合“节点” / Multipart ） MimeMultipart mm = new MimeMultipart(); mm.addBodyPart(text_image); mm.addBodyPart(attachment); // 如果有多个附件，可以创建多个多次添加 mm.setSubType(\u0026quot;mixed\u0026quot;); // 混合关系 // 11. 设置整个邮件的关系（将最终的混合“节点”作为邮件的内容添加到邮件对象） message.setContent(mm); // 12. 设置发件时间 message.setSentDate(new Date()); // 13. 保存上面的所有设置 message.saveChanges(); return message; } }  中文分词 另一个分词开源项目\n使用\n中科院分词包ictclas4j:\n 将Data目录拷贝到项目根目录 将ictclas4 j提供的bin目录，覆盖eclipse中的bin目录 将ictclas4 j提供的src源码复制到项目中 导入需要的commons-lang.jar、log4j.jar  参考博客\npublic static void main(String[] args) { Segment st = new Segment(1); String line = \u0026quot;一块勤奋地漂亮的一块钱,/打造经济的航空母舰。ABCD.#$% Hello World!\\n又一段文本123辆 ！3.0\u0026quot;; SegResult sr = st.split(line); System.out.println(sr.getFinalResult()); }  二维码 QRCode 日本的\njar包\nQrcode.jar  工具类\nimport java.awt.Color; import java.awt.Graphics2D; import java.awt.Image; import java.awt.image.BufferedImage; import java.io.File; import javax.imageio.ImageIO; import com.swetake.util.Qrcode; import jp.sourceforge.qrcode.QRCodeDecoder; public class QRCodeUtil { //加密： 文字信息 -\u0026gt;二维码.png /* * imgPath：src/二维码.png * content: 文字信息 * imgType：png */ public void encoderQRCode(String content,String imgPath,String imgType,int size) throws Exception{ //BufferedImage ：内存中的一张图片 BufferedImage bufImg = qRcodeCommon(content,imgType,size); File file = new File(imgPath);// \u0026quot;src/二维码.png\u0026quot; --\u0026gt; 二维码.png //生成图片 ImageIO.write(bufImg, imgType, file) ; } //产生一个二维码的BufferedImage /* *content:二维码中隐藏的信息 *imgType:图片格式 *size :二维码边长 */ public BufferedImage qRcodeCommon(String content ,String imgType,int size) throws Exception{ BufferedImage bufImg = null ; //Qrcode对象：字符串-\u0026gt;boolean[][] Qrcode qrCodeHandler = new Qrcode(); //设置二维码的排错率：7% L\u0026lt;M\u0026lt;Q\u0026lt;H30% ：排错率越高,可存储的信息越少；但是对二维码清晰对要求越小 qrCodeHandler.setQrcodeErrorCorrect('M'); //可存放的信息类型：N：数字、 A：数字+A-Z B：所有 qrCodeHandler.setQrcodeEncodeMode('B'); //尺寸：取值范围：1-40 qrCodeHandler.setQrcodeVersion(size); byte[] contentBytes = content.getBytes(\u0026quot;UTF-8\u0026quot;) ;//\u0026quot;Hello world\u0026quot; -\u0026gt; byte[]\u0026quot;Hello world\u0026quot; // --\u0026gt;boolean[][] boolean[][] codeOut = qrCodeHandler.calQrcode(contentBytes) ; int imgSize = 67 + 12*(size -1) ; //BufferedImage：内存中的图片 bufImg = new BufferedImage(imgSize,imgSize,BufferedImage.TYPE_INT_RGB );//red green blue //创建一个画板 Graphics2D gs = bufImg.createGraphics() ; gs.setBackground(Color.WHITE);//将画板的背景色设置为白色 gs.clearRect( 0,0, imgSize,imgSize); //初始化 gs.setColor(Color.BLACK);//设置 画板上 图像的颜色（二维码的颜色） int pixoff = 2 ; for(int j=0;j\u0026lt;codeOut.length;j++) { for(int i=0;i\u0026lt;codeOut.length;i++) { if(codeOut[j][i]) { gs.fillRect(j*3+pixoff , i*3+pixoff, 3, 3); } } } //增加LOGO //将硬盘中的src/logo.png 加载为一个Image对象 Image logo = ImageIO.read(new File(\u0026quot;src/logo.png\u0026quot;) ) ; int maxHeight = bufImg.getHeight() ; int maxWdith = bufImg.getWidth() ; //在已生成的二维码上 画logo gs.drawImage(logo,imgSize/5*2,imgSize/5*2, maxWdith/5,maxHeight/5 ,null) ; gs.dispose(); //释放空间 bufImg.flush(); //清理 return bufImg ; } //解密： 二维码(图片路径) -\u0026gt; 文字信息 public String decoderQRCode(String imgPath) throws Exception{ //BufferedImage内存中的图片 ：硬盘中的imgPath图片 -\u0026gt;内存BufferedImage BufferedImage bufImg = ImageIO.read( new File(imgPath) ) ; //解密 QRCodeDecoder decoder = new QRCodeDecoder() ; TwoDimensionCodeImage tdcImage = new TwoDimensionCodeImage(bufImg); byte[] bs = decoder.decode(tdcImage) ;\t//bufImg //byte[] --\u0026gt;String String content = new String(bs,\u0026quot;UTF-8\u0026quot;); return content; } }  import java.awt.image.BufferedImage; import jp.sourceforge.qrcode.data.QRCodeImage; public class TwoDimensionCodeImage implements QRCodeImage { BufferedImage bufImg; //将图片加载到内存中 public TwoDimensionCodeImage(BufferedImage bufImg) { this.bufImg = bufImg; } @Override public int getHeight() { return bufImg.getHeight(); } @Override public int getPixel(int x, int y) { return bufImg.getRGB(x, y); } @Override public int getWidth() { return bufImg.getWidth(); } }  测试\npublic class Test { public static void main(String[] args) throws Exception{ //生成二维码 /* * 生成图片的路径 src/二维码.png * 文字信息、网址信息 ： \u0026quot;helloworld\u0026quot; */ String imgPath = \u0026quot;src/二维码123.png\u0026quot;; String content = \u0026quot;http://www.baidu.com\u0026quot;; //扫描二维码后，网页跳转 //生成二维码 /* * 加密： 文字信息 -\u0026gt;二维码 * 解密： 二维码 -\u0026gt; 文字信息 */ QRCodeUtil qrUtil = new QRCodeUtil(); //加密： 文字信息 -\u0026gt;二维码 qrUtil.encoderQRCode(content, imgPath, \u0026quot;png\u0026quot;, 17); //\tTwoDimensionCode handler = new TwoDimensionCode(); //\thandler.encoderQRCode(content, imgPath, \u0026quot;png\u0026quot;, 7); //\t//解密： 二维码 -\u0026gt; 文字信息 String imgContent = qrUtil.decoderQRCode(imgPath) ; System.out.println(imgContent); } }  ZXing google的\njar\njavase-3.1.0.jar core-3.1.0.jar  工具类\nimport java.awt.BasicStroke; import java.awt.Color; import java.awt.Graphics2D; import java.awt.geom.RoundRectangle2D; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import javax.imageio.ImageIO; public class LogoUtil { //传入logo、二维码 -\u0026gt;带logo的二维码 public static BufferedImage logoMatrix( BufferedImage matrixImage,String logo ) throws IOException { //在二维码上画logo:产生一个 二维码画板 Graphics2D g2 = matrixImage.createGraphics() ; //画logo： String-\u0026gt;BufferedImage(内存) BufferedImage logoImg = ImageIO.read(new File(logo)) ; int height = matrixImage.getHeight() ; int width = matrixImage.getWidth(); //纯logo图片 g2.drawImage(logoImg , width*2/5,height* 2/5, width*1/5,height* 1/5 , null) ; //产生一个 画 白色圆角正方形的 画笔 BasicStroke stroke = new BasicStroke(5,BasicStroke.CAP_ROUND ,BasicStroke.JOIN_ROUND) ; //将画板-画笔 关联 g2.setStroke(stroke); //创建一个正方形 RoundRectangle2D.Float round = new RoundRectangle2D.Float(width*2/5,height* 2/5, width*1/5,height* 1/5 , BasicStroke.CAP_ROUND ,BasicStroke.JOIN_ROUND); g2.setColor(Color.WHITE); g2.draw(round); //灰色边框 BasicStroke stroke2 = new BasicStroke(1,BasicStroke.CAP_ROUND ,BasicStroke.JOIN_ROUND) ; g2.setStroke(stroke2); //创建一个正方形 RoundRectangle2D.Float round2 = new RoundRectangle2D.Float(width*2/5+2,height* 2/5+2, width*1/5-4,height* 1/5 -4, BasicStroke.CAP_ROUND ,BasicStroke.JOIN_ROUND); //\tColor color = new Color(128,128,128) ; g2.setColor(Color.GRAY); g2.draw(round2); g2.dispose(); matrixImage.flush();\treturn matrixImage; } }  import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; import javax.imageio.ImageIO; import com.google.zxing.BarcodeFormat; import com.google.zxing.Binarizer; import com.google.zxing.BinaryBitmap; import com.google.zxing.EncodeHintType; import com.google.zxing.LuminanceSource; import com.google.zxing.MultiFormatReader; import com.google.zxing.MultiFormatWriter; import com.google.zxing.Result; import com.google.zxing.WriterException; import com.google.zxing.client.j2se.BufferedImageLuminanceSource; import com.google.zxing.common.BitMatrix; import com.google.zxing.common.HybridBinarizer; import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel; import jp.sourceforge.qrcode.util.Color; public class ZXingUtil { //加密：文字-\u0026gt;二维码（图片） public static void encodeImg(String imgPath,String format,String content,int width, int height,String logo) throws WriterException, IOException {//format:gif Hashtable\u0026lt;EncodeHintType,Object \u0026gt; hints = new Hashtable\u0026lt;EncodeHintType,Object\u0026gt;() ; //排错率 L\u0026lt;M\u0026lt;Q\u0026lt;H hints.put( EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H) ; //编码 hints.put( EncodeHintType.CHARACTER_SET, \u0026quot;utf-8\u0026quot;) ; //外边距：margin hints.put( EncodeHintType.MARGIN, 1) ; /* * content : 需要加密的 文字 * BarcodeFormat.QR_CODE:要解析的类型（二维码） * hints：加密涉及的一些参数：编码、排错率 */ BitMatrix bitMatrix = new MultiFormatWriter().encode(content,BarcodeFormat.QR_CODE , width, height,hints) ; //内存中的一张图片：此时需要的图片 是二维码-\u0026gt; 需要一个boolean[][] -\u0026gt;BitMatrix //BufferedImage img = MatrixToImageWriter.toBufferedImage(bitMatrix) ; BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); for(int x=0;x\u0026lt;width;x++) { for(int y=0;y\u0026lt;height;y++) { img.setRGB(x, y, (bitMatrix.get(x,y)? Color.BLACK:Color.WHITE) ); } } //画logo img = LogoUtil.logoMatrix(img, logo) ; //String -\u0026gt;File File file = new File(imgPath); //生成图片 ImageIO.write(img, format,file) ;//format:图片格式 } //\tZXing //解密：二维码-\u0026gt;文字 public static void decodeImg(File file) throws Exception { if(!file.exists()) return ; //file-\u0026gt;内存中的一张图片 BufferedImage imge = ImageIO.read(file) ; MultiFormatReader formatReader = new MultiFormatReader() ; LuminanceSource source = new BufferedImageLuminanceSource(imge); Binarizer binarizer = new HybridBinarizer(source); BinaryBitmap binaryBitmap = new BinaryBitmap(binarizer); //图片 -\u0026gt;result Map map = new HashMap(); map.put(EncodeHintType.CHARACTER_SET, \u0026quot;utf-8\u0026quot;) ; Result result = formatReader.decode(binaryBitmap ,map ) ; System.out.println(\u0026quot;解析结果：\u0026quot;+ result.toString()); } public static void main(String[] args) { int i=6,j=8,k=10,m=7; if(i \u0026lt; j | m \u0026gt; ++k) k++; System.out.println(k); } }  使用\nimport java.io.File; import java.io.IOException; import com.google.zxing.WriterException; public class Test { public static void main(String[] args) throws Exception { String imgPath = \u0026quot;src/xx.png\u0026quot; ; String content = \u0026quot;hello你好\u0026quot; ; String logo = \u0026quot;src/logo.png\u0026quot; ; //加密：文字-\u0026gt;二维码 ZXingUtil.encodeImg(imgPath,\u0026quot;gif\u0026quot;,content,430,430,logo); //解密：二维码-\u0026gt;文字 ZXingUtil.decodeImg(new File(imgPath)); } }  Socket 基于TCP的Socket传输\n输入输出流发送的都是内存中的东西\n服务端 import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.ServerSocket; import java.net.Socket; public class MyServer { public static void main(String[] args) throws IOException { // 绑定了服务端的端口：ip：为本机的IP // 暴漏了一个服务，该 服务的地址：localhost:9999 ServerSocket serverSocket = new ServerSocket(9999); while (true) { Socket accept = serverSocket.accept(); System.out.println(\u0026quot;客户端连接成功\u0026quot;); // 服务端向客户端发送消息Output OutputStream out = accept.getOutputStream(); String info = \u0026quot;hello\u0026quot;; /* * out.write(info.getBytes()); */ // 发送文件 // 准备要发送的文件 File file = new File(\u0026quot;D:\\\\_model2.prt\u0026quot;); // 将文件放入内存中 InputStream fileIn = new FileInputStream(file); byte[] FileBytes = new byte[1000]; int len = -1; // 发送（因为文件较大，不能一次发送完毕，因此需要通过循环来分次发送） while ((len = fileIn.read(FileBytes)) != -1) { out.write(FileBytes); } System.out.println(\u0026quot;文件发送成功\u0026quot;); // 服务端接收客户端的信息 /* * InputStream in = accept.getInputStream(); byte[] bs = new byte[100]; * in.read(bs); System.out.println(\u0026quot;服务端接收到的消息为：\u0026quot;+new String(bs)); */ // in.close(); out.close(); accept.close(); serverSocket.close(); fileIn.close(); } } }  客户端 import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.Socket; import java.net.UnknownHostException; import com.sun.org.apache.bcel.internal.generic.NEW; public class MyClient { public static void main(String[] args) throws UnknownHostException, IOException { //客户端连接server发布的服务 Socket socket = new Socket(\u0026quot;127.0.0.1\u0026quot;,9999); //客户端接收消息 InputStream in = socket.getInputStream(); //接收普通文字 //byte[] bs = new byte[100]; //in.read(bs); //System.out.println(\u0026quot;客户端接收到的消息为：\u0026quot;+new String(bs)); //接收文件 OutputStream fileOut = new FileOutputStream(\u0026quot;D:\\\\aa.prt\u0026quot;); byte[] bs = new byte[1000]; int len =-1; while((len=in.read(bs))!=-1) { fileOut.write(bs,0,len); } System.out.println(\u0026quot;文件接收成功\u0026quot;); //客户端向服务端返回信息 /* * OutputStream out = socket.getOutputStream(); String info = \u0026quot;hello Server\u0026quot;; * out.write(info.getBytes()); */ in.close(); //out.close(); socket.close(); fileOut.close(); } }  优化服务端，多线程\nimport java.io.File; import java.io.FileInputStream; import java.io.InputStream; import java.io.OutputStream; import java.net.Socket; //处理下载的线程 public class MyDownload implements Runnable{ private Socket socket; public MyDownload() { } public MyDownload(Socket socket) { this.socket = socket; } @Override public void run() { System.out.println(\u0026quot;客户端连接成功\u0026quot;); try { // 服务端向客户端发送消息Output OutputStream out = socket.getOutputStream(); // 发送文件 // 准备要发送的文件 File file = new File(\u0026quot;D:\\\\_model2.prt\u0026quot;); // 将文件放入内存中 InputStream fileIn = new FileInputStream(file); byte[] FileBytes = new byte[1000]; int len = -1; // 发送（因为文件较大，不能一次发送完毕，因此需要通过循环来分次发送） while ((len = fileIn.read(FileBytes)) != -1) { out.write(FileBytes); } System.out.println(\u0026quot;文件发送成功\u0026quot;); out.close(); socket.close(); fileIn.close(); } catch (Exception e) { // TODO: handle exception System.out.println(e.getMessage()); } } }  import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; public class MyService01 { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(9999); while(true) { Socket socket = serverSocket.accept(); //下载的线程 //MyDownload mydownload =new MyDownload(socket); //Runnable--\u0026gt;Thread new Thread(new MyDownload(socket)).start(); } } }  文件的拆分和合并 将一个文件7.5M据分成若干个子文件8个文件(7个1M+1个0. 5)\n将拆分后的8个文件合并成源文件7.5M\n对象\u0026ndash;\u0026gt;硬盘：序列化\n硬盘\u0026ndash;》对象：反序列化\n拆分的时候：如何将文件名，分割的数量保留，为后续的合并做准备\n再生成一个配置文件conf.properties保存上述信息\n拆分文件 简单拆分 import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.Properties; public class SplitFile { public static void main(String[] args) throws IOException { // TODO Auto-generated method stub // 源文件(待拆分的文件) File resFile = new File(\u0026quot;d:\\\\data.zip\u0026quot;); // 拆分后的目录 File splitDir = new File(\u0026quot;d:\\\\splitDir\u0026quot;); splitFile(resFile,splitDir); } // 拆分文件 public static void splitFile(File resFile, File splitDir) throws IOException { if (!splitDir.exists()) { splitDir.mkdir(); } // 思路：拆分：1个输入流，n个输出流(a,b,c) // 合并：n个输入流，1和输出流(注意顺序a,b,c) // 拆分：1个输入流 InputStream in = new FileInputStream(resFile); OutputStream out = null; byte[] buf = new byte[1024 * 1024]; int len = -1; int count = 1; while ((len = in.read(buf)) != -1) { out = new FileOutputStream(new File(splitDir, count++ + \u0026quot;.part\u0026quot;)); out.write(buf, 0, len); // out.flush();//专门的清理缓冲区 out.close();// 关闭流、关闭之前会清理缓冲区 } // 拆分的时候：如何将文件名，分割的数量保留，为后续的合并做准备 // 再生成一个配置文件conf.properties保存上述信息 /* * //方式一 out = new FileOutputStream(new File(splitDir,\u0026quot;conf.properties\u0026quot;)); * //查询当前操作系统的换行符 String property = System.getProperty(\u0026quot;line.separator\u0026quot;); * out.write((\u0026quot;filename=\u0026quot;+resFile.getName()).getBytes()); * out.write(property.getBytes()); * * out.write((\u0026quot;partcount=\u0026quot;+(count-1)).getBytes()); out.close(); */ // 方式二Properties，将内存中的多个属性以key=value的形式写到硬盘中 out = new FileOutputStream(new File(splitDir, \u0026quot;conf.properties\u0026quot;)); Properties prop = new Properties(); prop.setProperty(\u0026quot;filename\u0026quot;, resFile.getName()); prop.setProperty(\u0026quot;partcount\u0026quot;, (count - 1) + \u0026quot;\u0026quot;); // 写入磁盘（保存：持久化） prop.store(out, \u0026quot;file configuration...\u0026quot;); out.close(); in.close(); } }  限制使用次数的拆分文件 合并文件 简单合并 import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import java.io.SequenceInputStream; import java.util.ArrayList; import java.util.Collections; import java.util.Enumeration; import java.util.List; import java.util.Properties; public class MergeFile { public static void main(String[] args) throws IOException { //文件合并方法一 //\t//读取多个拆分后的文件（inouts:所有输入流的集合） //\tList\u0026lt;FileInputStream\u0026gt; inputs = new ArrayList\u0026lt;\u0026gt;(); //\tfor(int i =1;i\u0026lt;=8;i++) { //\tinputs.add(new FileInputStream(\u0026quot;D:\\\\splitDir\\\\\u0026quot;+i+\u0026quot;.part\u0026quot;)); //\t//\t} //\t//指定合并后的文件输出流 //\tOutputStream out = new FileOutputStream(\u0026quot;d:\\\\asd.zip\u0026quot;); //\t//将多个输入流一次读入内存，最后再一次性输出到asd.zip中 //\tbyte[] buf = new byte[1024*1024]; //\tfor(FileInputStream in:inputs) { //\tint len = in.read(buf); //\tout.write(buf,0,len); //\t} //\tout.close(); //\tfor(FileInputStream in:inputs) { //\tin.close(); //\t} //\t//文件合并方法二 File splitDir = new File(\u0026quot;D:\\\\splitDir\u0026quot;); mergeFile(splitDir); } public static void mergeFile(File splitDir) throws IOException { List\u0026lt;FileInputStream\u0026gt; inputs = new ArrayList\u0026lt;\u0026gt;(); for(int i =1;i\u0026lt;=8;i++) { inputs.add(new FileInputStream(\u0026quot;D:\\\\splitDir\\\\\u0026quot;+i+\u0026quot;.part\u0026quot;)); } Enumeration\u0026lt;FileInputStream\u0026gt; en = Collections.enumeration(inputs); //多个流--》1个流 SequenceInputStream sin = new SequenceInputStream(en); //指定合并后的文件输出流 OutputStream out = new FileOutputStream(\u0026quot;d:\\\\asd.zip\u0026quot;); //将多个输入流一次读入内存，最后再一次性输出到asd.zip中 byte[] buf = new byte[1024*1024]; int len = -1; while((len=sin.read(buf))!=-1) { out.write(buf,0,len); } out.close(); sin.close(); } public static Properties getProperties() throws FileNotFoundException, IOException { //找到配置文件的位置 String configFileName = \u0026quot;D:\\\\splitDir\\\\conf.properties\u0026quot;; Properties properties= new Properties(); properties.load(new FileInputStream(configFileName)); return properties; } }  多线程合并文件 import java.io.BufferedReader; import java.io.File; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; public class ConfigReader { public static void main(String[] args) throws IOException { File configFile = new File(\u0026quot;d:\\\\splitDir\\\\9.config\u0026quot;); readConfig(configFile); } public static void readConfig(File configFile) throws IOException { BufferedReader bufferedReader = new BufferedReader(new FileReader(configFile)); String line = null; while((line=bufferedReader.readLine())!=null) { String[] arr = line.split(\u0026quot;=\u0026quot;); if(line.startsWith(\u0026quot;filename\u0026quot;)) { }else if(line.startsWith(\u0026quot;partcount\u0026quot;)) { }else { System.out.println(\u0026quot;暂未处理\u0026quot;); } } bufferedReader.close(); } }  import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import java.io.SequenceInputStream; import java.util.ArrayList; import java.util.Collections; import java.util.Enumeration; import java.util.List; import java.util.Properties; public class MergeFile { public static void main(String[] args) throws IOException { //文件合并方法一 //\t//读取多个拆分后的文件（inouts:所有输入流的集合） //\tList\u0026lt;FileInputStream\u0026gt; inputs = new ArrayList\u0026lt;\u0026gt;(); //\tfor(int i =1;i\u0026lt;=8;i++) { //\tinputs.add(new FileInputStream(\u0026quot;D:\\\\splitDir\\\\\u0026quot;+i+\u0026quot;.part\u0026quot;)); //\t} //\t//指定合并后的文件输出流 //\tOutputStream out = new FileOutputStream(\u0026quot;d:\\\\asd.zip\u0026quot;); //\t//将多个输入流一次读入内存，最后再一次性输出到asd.zip中 //\tbyte[] buf = new byte[1024*1024]; //\tfor(FileInputStream in:inputs) { //\tint len = in.read(buf); //\tout.write(buf,0,len); //\t} //\tout.close(); //\tfor(FileInputStream in:inputs) { //\tin.close(); //\t} //文件合并方法二 File splitDir = new File(\u0026quot;D:\\\\splitDir\u0026quot;); mergeFile1(splitDir); } public static Properties getProperties() throws FileNotFoundException, IOException { //找到配置文件的位置 String configFileName = \u0026quot;D:\\\\splitDir\\\\conf.properties\u0026quot;; Properties properties= new Properties(); properties.load(new FileInputStream(configFileName)); return properties; } public static void mergeFile1(File splitDir) throws FileNotFoundException, IOException { //合并之前先读取配置文件的信息 Properties prop = getProperties(); String fileName = prop.getProperty(\u0026quot;filename\u0026quot;); int partCount = Integer.parseInt(prop.getProperty(\u0026quot;partcount\u0026quot;)); List\u0026lt;FileInputStream\u0026gt; inputs = new ArrayList\u0026lt;\u0026gt;(); for(int i =1;i\u0026lt;=partCount;i++) { inputs.add(new FileInputStream(\u0026quot;D:\\\\splitDir\\\\\u0026quot;+i+\u0026quot;.part\u0026quot;)); } Enumeration\u0026lt;FileInputStream\u0026gt; en = Collections.enumeration(inputs); //多个流--》1个流 SequenceInputStream sin = new SequenceInputStream(en); //指定合并后的文件输出流 OutputStream out = new FileOutputStream(\u0026quot;d:\\\\aa\\\\\u0026quot;+fileName); //将多个输入流一次读入内存，最后再一次性输出到asd.zip中 byte[] buf = new byte[1024*1024]; int len = -1; while((len=sin.read(buf))!=-1) { out.write(buf,0,len); } out.close(); sin.close(); } }  序列化反序列化 import java.io.Serializable; public class Person implements Serializable{ /** * 指定该类的SUID */ private static final long serialVersionUID = 12L; private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } }  import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Test { public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException { //序列化 objectOut(); //反序列化 objectIn(); } public static void objectOut() throws FileNotFoundException, IOException { Person per = new Person(\u0026quot;zs\u0026quot;,24); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026quot;d:\\\\per.obj\u0026quot;)); oos.writeObject(per); oos.close(); } public static void objectIn() throws FileNotFoundException, IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026quot;d:\\\\per.obj\u0026quot;)); Object readObject = ois.readObject(); Person per = (Person)readObject; System.out.println(per.getName()+\u0026quot;====\u0026quot;+per.getAge()); } }  说明 序列化和反序列化都依赖对象所在的类：类不能改变\n再序列化和反序列化时JVM给Person对象计算一个SUID，计算时类是计算的一个因子，当类改变时SUID也随之改变，反序列化时，二者的SUID不一致，因此报错，可以指定该类的SUID\nprivate static final long serialVersionUID = 12L;  序列化运行时使用一个称为serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的seri alVersi onUID与对应的发送者的类的版本号不同，则反序列化将会导致InvalidClassException.可序列化类可以通过声明为\u0026rdquo;serialVersionUID\u0026rdquo; 的字段(该字段必须是静态(static)、 最终(final) 的long 型字段)显式声明其自己的seria1VersionUID:\nANT-ACESS-MODIFIER static final long serialVersionUID = 42L:  如果可序列化类未显式声明serialVersionUID, 则序列化运行时将基于该类的各个方面年算该类的默认serlalVersi1onU1D值，如ava(TD对象序列化规范”中所述。不过。强列建论所有可序列化类都显式声明serialVersinIITD 值，原因是计算默认的seria1Versi onUID对类的详细信息具有较高的敏感性，根据编译器实现的不同可能千差万别，这样在反序列化过程中可能会导致意外的InvalidClassException. 因此，为保证serlalVerstonUID值跨不同Java编译器实现的致性，序列化类必须声明一个 明确的serlalVerstonUID值。还强烈建议使用private修饰符显示声明seria1VersionUID (如果可能)，原因是这种声明仅应用于直接声明类\u0026ndash; serialVersi onUID字段作为继承成员没有用处。数组类不能声明一个明确的serialVersionUID, 因此它们总是具有默认的计算值，但是数组类没有匹配serialVersionUID 值的要求。\n因此建议写死\n序列化和反序列化的顺序要严格一致\n 序列化时a,b,c 反序列化时a,b,c  多个对象时，可以将对象挨个序列化，也可以将所有的对象放到一个List集合中\n序列化基本类型变量就使用write方法，对象类型就使用writeObject方法\n原因是\n//ObjectOutputStream继承了OutputStream public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants {  XML解析 dogs.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;dogs\u0026gt; \u0026lt;dog id =\u0026quot;1\u0026quot;\u0026gt; \u0026lt;name\u0026gt;YAYA\u0026lt;/name\u0026gt; \u0026lt;score\u0026gt;100\u0026lt;/score\u0026gt; \u0026lt;level\u0026gt;10\u0026lt;/level\u0026gt; \u0026lt;/dog\u0026gt; \u0026lt;dog id =\u0026quot;2\u0026quot;\u0026gt; \u0026lt;name\u0026gt;HAHA\u0026lt;/name\u0026gt; \u0026lt;score\u0026gt;10\u0026lt;/score\u0026gt; \u0026lt;level\u0026gt;1\u0026lt;/level\u0026gt; \u0026lt;/dog\u0026gt; \u0026lt;dog id =\u0026quot;3\u0026quot;\u0026gt; \u0026lt;name\u0026gt;LALA\u0026lt;/name\u0026gt; \u0026lt;score\u0026gt;200\u0026lt;/score\u0026gt; \u0026lt;level\u0026gt;20\u0026lt;/level\u0026gt; \u0026lt;/dog\u0026gt; \u0026lt;/dogs\u0026gt;  public class Dog { private int id; private String name; private double score; private int level; public Dog(int id, String name, double score, int level) { this.id = id; this.name = name; this.score = score; this.level = level; } public Dog() { } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getScore() { return score; } public void setScore(double score) { this.score = score; } public int getLevel() { return level; } public void setLevel(int level) { this.level = level; } @Override public String toString() { return \u0026quot;Dog [id=\u0026quot; + id + \u0026quot;, name=\u0026quot; + name + \u0026quot;, score=\u0026quot; + score + \u0026quot;, level=\u0026quot; + level + \u0026quot;]\u0026quot;; } }  import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.util.ArrayList; import java.util.List; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.xml.sax.SAXException; public class XMLParsrUtil { // 输入一个xml文件的路径(//dogs.xml)，输出一个List\u0026lt;Dog\u0026gt; public static List\u0026lt;Dog\u0026gt; parseXmlToList(String fileName) throws ParserConfigurationException, FileNotFoundException, SAXException, IOException { List\u0026lt;Dog\u0026gt; dogs = new ArrayList\u0026lt;\u0026gt;(); // DOM方式解析：入口 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();// 产生一个DOM工厂实例 // 产品 DocumentBuilder builder = factory.newDocumentBuilder(); // 准备输出流，为parse()做准备 // 解析为一个可以使用java来处理的document对象 Document document = builder.parse(new FileInputStream(fileName)); Element element = document.getDocumentElement();// 获取所有文档的节点 // nodeList存储了3个\u0026lt;dog\u0026gt; NodeList nodeList = element.getElementsByTagName(\u0026quot;dog\u0026quot;);// 获取dog节点 // 遍历nodeList，3个\u0026lt;dog\u0026gt; for (int i = 0; i \u0026lt; nodeList.getLength(); i++) { Dog dog = new Dog(); // Node node = nodeList.item(i);//list.get(i) // 获取dog的id属性 // node.getAttributes()[0]//node中只有getAttributes获取所有的属性而我们只有一个属性id // 可以使用他的子接口 // 获取节点属性 Element dogElement = (Element) nodeList.item(i);// list.get(i) int id = Integer.parseInt(dogElement.getAttribute(\u0026quot;id\u0026quot;)); dog.setId(id); // 获取dog的子节点\u0026lt;name\u0026gt;\u0026lt;score\u0026gt; NodeList childNodes = dogElement.getChildNodes(); // 遍历每一个子节点 for (int j = 0; j \u0026lt; childNodes.getLength(); j++) { // 每一个子节点\u0026lt;name\u0026gt;\u0026lt;level\u0026gt;\u0026lt;score\u0026gt;包括文字、空格 Node dogChild = childNodes.item(j); // 排除空格，只拿\u0026lt;xxx\u0026gt;形式的子节点,即Node.ELEMENT_NODE形式的 if (dogChild.getNodeType() == Node.ELEMENT_NODE) { // 判断节点名 if (dogChild.getNodeName().equals(\u0026quot;name\u0026quot;)) {// \u0026lt;name\u0026gt; String name = dogChild.getFirstChild().getNodeValue(); dog.setName(name); } else if (dogChild.getNodeName().equals(\u0026quot;score\u0026quot;)) { double score = Double.parseDouble(dogChild.getFirstChild().getNodeValue()); dog.setScore(score); } else if (dogChild.getNodeName().equals(\u0026quot;level\u0026quot;)) { int level = Integer.parseInt(dogChild.getFirstChild().getNodeValue()); dog.setLevel(level); } } } dogs.add(dog); } return dogs; } }  import java.io.FileNotFoundException; import java.io.IOException; import java.util.List; import javax.xml.parsers.ParserConfigurationException; import org.xml.sax.SAXException; //XML解析 public class Sample { public static void main(String[] args) throws FileNotFoundException, ParserConfigurationException, SAXException, IOException { List\u0026lt;Dog\u0026gt; dogs = XMLParsrUtil.parseXmlToList(\u0026quot;src/com/mumulx/dogs.xml\u0026quot;); System.out.println(dogs); } }  Json jspn官网\ngit下载java\n引入json\n方法一：打成jar包\n新建java项目\u0026ndash;\u0026gt;新建包org.json将下载的zip包中的文件复制到org.json中\n右键项目导出，java:jar文件，将源码一起打包\n方式二：直接使用\nmap变Json //1.Map集合、JavaBean、字符串--》JSon对象 //a.Map集合JSon对象 public static void mapAndJaon() { Map\u0026lt;String,String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026quot;s01\u0026quot;, \u0026quot;zs1\u0026quot;); map.put(\u0026quot;s02\u0026quot;, \u0026quot;zs2\u0026quot;); map.put(\u0026quot;s03\u0026quot;, \u0026quot;zs3\u0026quot;); map.put(\u0026quot;s04\u0026quot;, \u0026quot;zs4\u0026quot;); //map--\u0026gt;json JSONObject json = new JSONObject(map); System.out.println(json); }  JavaBean变JSon public class Person { private int age; private String name; private Address address; public Person() { } public Person(int age, String name, Address address) { this.age = age; this.name = name; this.address = address; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } }  public class Address { private String homeAddress; private String schoolAddress; public Address() { } public Address(String homeAddress, String schoolAddress) { this.homeAddress = homeAddress; this.schoolAddress = schoolAddress; } public String getHomeAddress() { return homeAddress; } public void setHomeAddress(String homeAddress) { this.homeAddress = homeAddress; } public String getSchoolAddress() { return schoolAddress; } public void setSchoolAddress(String schoolAddress) { this.schoolAddress = schoolAddress; } }  //JavaBean(普通java对象)--\u0026gt;JSon public static void javaBeanAndJSon() { Address address = new Address(\u0026quot;js\u0026quot;,\u0026quot;xz\u0026quot;); Person per = new Person(18,\u0026quot;zs\u0026quot;,address); //JavaBean--\u0026gt;JSon JSONObject json = new JSONObject(per); System.out.println(json); }  String变JSon //String--\u0026gt;JSon public static void stringAndJSon() { //字符串的形式必须是json的形式 String str = \u0026quot;{\\\u0026quot;name\\\u0026quot;:\\\u0026quot;zs\\\u0026quot;,\\\u0026quot;age\\\u0026quot;:23}\u0026quot;; JSONObject json = new JSONObject(str); System.out.println(json); }  JSon文件变JSon per.json\n{ \u0026quot;name\u0026quot;:\u0026quot;zs\u0026quot;, \u0026quot;age\u0026quot;:23, \u0026quot;address\u0026quot;:{\u0026quot;hAddress\u0026quot;:\u0026quot;js\u0026quot;,\u0026quot;sAddress\u0026quot;:\u0026quot;xz\u0026quot;} }  方式一 //文件--\u0026gt;JSon //方式一 //per.json--\u0026gt;JSON //思路：将文件变成字符串，再将字符串变成JSon public void fileAndJSon01() throws IOException {//static方法只能调用static函数 //将文件变成String //相对路径文件流 InputStream in = super.getClass().getClassLoader().getResourceAsStream(\u0026quot;com/mumulx/per.json\u0026quot;); byte[] bs = new byte[1024]; int len = -1; StringBuffer sb = new StringBuffer(); while((len=in.read(bs))!=-1) { //byte[]--\u0026gt;String String str = new String(bs,0,len); sb.append(str); } String rs = sb.toString(); JSONObject json = new JSONObject(rs); System.out.println(json); }  方式二 需要引入commons-io.jar\n//方式二 public void fileAndJSon02() throws IOException {//static方法只能调用static函数 //文件--\u0026gt;字符串 需要引入commons-io.jar String rs = FileUtils.readFileToString(new File(\u0026quot;src/com/mumulx/per.json\u0026quot;)); JSONObject json = new JSONObject(rs); System.out.println(json); }  生成JSon文件 //生成JSon文件 public static void createJSonFile() throws JSONException, IOException { //准备JSon数据 Map\u0026lt;String,Person\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Person per1 = new Person(11,\u0026quot;zs1\u0026quot;,new Address(\u0026quot;js1\u0026quot;,\u0026quot;yc1\u0026quot;)); Person per2 = new Person(12,\u0026quot;zs2\u0026quot;,new Address(\u0026quot;js2\u0026quot;,\u0026quot;yc2\u0026quot;)); Person per3 = new Person(13,\u0026quot;zs3\u0026quot;,new Address(\u0026quot;js3\u0026quot;,\u0026quot;yc3\u0026quot;)); map.put(\u0026quot;per1\u0026quot;, per1); map.put(\u0026quot;per2\u0026quot;, per2); map.put(\u0026quot;per3\u0026quot;, per3); //map--\u0026gt;JSon JSONObject json = new JSONObject(map); //生成json文件 Writer writer = new FileWriter(\u0026quot;d:\\\\aa.obj\u0026quot;); json.write(writer); writer.close(); }  JSonArray //JSonArray //[{\u0026quot;name\u0026quot;:\u0026quot;zs\u0026quot;,\u0026quot;age\u0026quot;:23},{\u0026quot;classname\u0026quot;:\u0026quot;aa\u0026quot;,\u0026quot;classno\u0026quot;:1},{\u0026quot;schoolname\u0026quot;:\u0026quot;bb\u0026quot;,\u0026quot;schooladdr\u0026quot;:\u0026quot;sdfsdf\u0026quot;}] public static void jsonArray() { String jsonArrayStr = \u0026quot;[{\\\u0026quot;name\\\u0026quot;:\\\u0026quot;zs\\\u0026quot;,\\\u0026quot;age\\\u0026quot;:23},{\\\u0026quot;classname\\\u0026quot;:\\\u0026quot;aa\\\u0026quot;,\\\u0026quot;classno\\\u0026quot;:1},{\\\u0026quot;schoolname\\\u0026quot;:\\\u0026quot;bb\\\u0026quot;,\\\u0026quot;schooladdr\\\u0026quot;:\\\u0026quot;sdfsdf\\\u0026quot;}]\u0026quot;; //String格式的json数组--\u0026gt;json数组 JSONArray jArray = new JSONArray(jsonArrayStr); System.out.println(jArray); }  Map转换为JSon数组 添加jar包\ncommons-beantils-1.8.0.jar commons-collections-3.2.1jar commons-lang-2.5.jar commons-logging-1.1.1jar ezmorph-1.0.6.jar json-lib-2.4-jdk15.jar  //对于json的类型转换通常需要引入另外一个json库 public static void mapAndJSONArray() { Map\u0026lt;String,String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026quot;s01\u0026quot;, \u0026quot;zs1\u0026quot;); map.put(\u0026quot;s02\u0026quot;, \u0026quot;zs2\u0026quot;); map.put(\u0026quot;s03\u0026quot;, \u0026quot;zs3\u0026quot;); map.put(\u0026quot;s04\u0026quot;, \u0026quot;zs4\u0026quot;); //冲突: JSONArray既存在于json.jar又 存在于json-lib库 net.sf.json.JSONArray jArray = new net.sf.json.JSONArray(); //map-\u0026gt;json jArray=jArray.fromObject(map); System.out.println(jArray); }  新增的jar包功能更加强大，常用\n//String--\u0026gt;JSon public static void stringAndJSon01() { //字符串的形式必须是json的形式 String str = \u0026quot;{\\\u0026quot;name\\\u0026quot;:\\\u0026quot;zs\\\u0026quot;,\\\u0026quot;age\\\u0026quot;:23}\u0026quot;; //JSONObject json = new JSONObject(str); net.sf.json.JSONObject json = new net.sf.json.JSONObject(); json=json.fromObject(str); System.out.println(json); }  //JavaBean(普通java对象)--\u0026gt;JSon public static void javaBeanAndJSon01() { Address address = new Address(\u0026quot;js\u0026quot;,\u0026quot;xz\u0026quot;); Person per = new Person(18,\u0026quot;zs\u0026quot;,address); //JavaBean--\u0026gt;JSon net.sf.json.JSONObject json = new net.sf.json.JSONObject(); json = json.fromObject(per); System.out.println(json); }  JSONArray\u0026ndash;\u0026gt;map //JSonArray--\u0026gt;map public static void jsonArrayToMap() { //JSONArray--》每获得一个json--\u0026gt;key:value--\u0026gt;map //准备数据 String jsonArrayStr = \u0026quot;[{\\\u0026quot;name\\\u0026quot;:\\\u0026quot;zs\\\u0026quot;,\\\u0026quot;age\\\u0026quot;:23},{\\\u0026quot;classname\\\u0026quot;:\\\u0026quot;aa\\\u0026quot;,\\\u0026quot;classno\\\u0026quot;:1},{\\\u0026quot;schoolname\\\u0026quot;:\\\u0026quot;bb\\\u0026quot;,\\\u0026quot;schooladdr\\\u0026quot;:\\\u0026quot;sdfsdf\\\u0026quot;}]\u0026quot;; //string--\u0026gt;jsonArray net.sf.json.JSONArray jArray = new net.sf.json.JSONArray(); jArray=jArray.fromObject(jsonArrayStr); //JSONArray--》获取每一个JSOn Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for(int i = 0;i\u0026lt;jArray.size();i++) { Object object = jArray.get(i); net.sf.json.JSONObject json = (net.sf.json.JSONObject)object; //获取每一个json的key/value--\u0026gt;map Set\u0026lt;String\u0026gt; keys = json.keySet();//每个json的所有key for(String key:keys) { Object value=json.getString(key); map.put(key, value); } } System.out.println(map); }  ","id":24,"section":"posts","summary":"Java反射 RTTI（RunTime Type Information，运行时类型信息） 反射机制是在[运行状态]中: 对于任意一个类，都能够知道这个类的","tags":["Java"],"title":"Java常见应用","uri":"https://mumulx.github.io/2020/01/java%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8/","year":"2020"},{"content":" 虚拟机启动访问 启动mongodb cd /usr/local/mongodb/bin/ ./mongod --port 27017 --dbpath=/data/mongodb  登录数据库 cd /usr/local/mongodb/bin/ netstat -lanp | grep \u0026quot;27017\u0026quot; ./mongo use admin db.auth(\u0026quot;root\u0026quot;,\u0026quot;135451\u0026quot;)  启动redis cd /data/redis/bin/ redis-server  启动EasyMock cd /app/easymock/easy-mock/ npm run dev  本机访问 http://centos6:7300/  linux软件安装 使用到的软件有nodejs、mongodb、redis、easy-mock、git\nnodejs安装 cd /opt wget https://nodejs.org/dist/v8.11.1/node-v8.11.1-linux-x64.tar.xz xz -d node-v8.11.1-linux-x64.tar.xz tar -xvf node-v8.11.1-linux-x64.tar cd node-v8.11.1-linux-x64/bin pwd ln -s /opt/node-v8.11.1-linux-x64/bin/node /usr/sbin/node ln -s /opt/node-v8.11.1-linux-x64/bin/node /usr/bin/node ln -s /opt/node-v8.11.1-linux-x64/bin/npm /usr/sbin/npm ln -s /opt/node-v8.11.1-linux-x64/bin/npm /usr/bin/npm  测试 node -v npm -v  安装cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org ln -s /opt/node-v8.11.1-linux-x64/bin/cnpm /usr/sbin/cnpm ln -s /opt/node-v8.11.1-linux-x64/bin/cnpm /usr/bin/cnpm  软连接 创建软链接 ln -s [源文件或目录] [目标文件或目录]  例如：\n当前路径创建test 引向/var/www/test 文件夹\nln –s /var/www/test test  创建/var/test 引向/var/www/test 文件夹\nln –s /var/www/test /var/test  删除软链接 和删除普通的文件是一样的，删除都是使用rm来进行操作\nrm –rf 软链接名称（请注意不要在后面加”/”，rm –rf 后面加不加”/” 的区别，可自行去百度下啊）  例如：\n删除test\nrm –rf test  修改软链接 ln –snf [新的源文件或目录] [目标文件或目录]  这将会修改原有的链接地址为新的地址\n例如：\n创建一个软链接\nln –s /var/www/test /var/test  修改指向的新路径\nln –snf /var/www/test1 /var/test  错误解决 python: /lib64/libc.so.6: versionGLIBC_2.14\u0026rsquo; not found (required by /usr/lib64/libpython2.7.so.1.0)，`\nhttp://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz http://ftp.gnu.org/gnu/glibc/glibc-ports-2.14.tar.gz tar -xvf glibc-2.14.tar.gz tar -xvf glibc-ports-2.14.tar.gz mv glibc-ports-2.14 glibc-2.14/ports mkdir glibc-2.14/build cd glibc-2.14/build ../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin make make install  strings /lib64/lib.so.6 |grep GLBC_  查看是否有2.14版本\nMongodb安装 cd /opt wget http://downloads.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.2.10.tgz tar -zxvf mongodb-linux-x86_64-rhel70-3.2.10.tgz.gz mv mongodb-linux-x86_64-rhel70-3.2.10 /usr/local/mongodb mkdir -p /data/mongodb cd /usr/local/mongodb/bin ./mongod --port 27017 --dbpath=/data/mongodb 启动服务  终端在运行，如果想操作的话，换另一个终端\nnetstat -lanp | grep \u0026quot;27017\u0026quot; 检查是否启动 ./mongo 进入数据库 use admin 登录 db.createUser({user:\u0026quot;root\u0026quot;,pwd:\u0026quot;yourpasswd\u0026quot;,roles:[\u0026quot;root\u0026quot;]}); db.auth(\u0026quot;root\u0026quot;,\u0026quot;yourpasswd\u0026quot;)  redis安装 参考博客\ncd /opt wget http://download.redis.io/releases/redis-2.8.0.tar.gz tar zxf redis-2.8.0.tar.gz mv redis-2.8.0 /data/redis yum install gcc cpp binutils glibc glibc-kernheaders glibc-common glibc-devel tcl cd /data/redis cd tests/unit/ vi memefficiency.tcl 找到16384,把后面的0.90改成0.80 cd .. cd .. make \u0026amp;\u0026amp; make test 等待较长时间后 cd src make install cd .. mkdir etc mkdir bin mv redis.conf /data/redis/etc/ cd src mv mkreleasehdr.sh redis-benchmark redis-check-aof redis-cli redis-server /data/redis/bin/ cd .. cd bin redis-server  cd etc/ vim redis.conf daemonize 将no修改为yes # requirepass foobared 取消注释设置登录密码 再次启动redis服务，并指定启动服务配置文件 redis-server /data/redis/etc/redis.conf 登录 redis-cli -h 127.0.0.1 -p 6379 -a 密码  问题解决 Creating Server TCP listening socket *:6379: bind: Address already in use\nps -ef | grep -i redis  结果\nroot 3086 1 0 Apr24 ? 00:00:07 ./bin/redis-server *:6379 root 3531 3467 0 01:00 pts/0 00:00:00 grep -i redis  杀死指定进程\nkill -9 3086  重新启动服务即可\n安装git  cd /app yum install gcc perl-ExtUtils-MakeMaker 在https://github.com/git/git/releases下载安装包，上传到linux tar -zxvf v2.25.0.tar.gz cd git-2.25.0 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker yum -y remove git make prefix=/usr/local/git all make prefix=/usr/local/git install vi /etc/profile source /etc/profile git --version  安装EasyMock cd /app/easymock git clone https://github.com/easy-mock/easy-mock.git cd easy-mock/ cnpm install npm run build npm run start  ","id":25,"section":"posts","summary":"虚拟机启动访问 启动mongodb cd /usr/local/mongodb/bin/ ./mongod --port 27017 --dbpath=/data/mongodb 登录数据库 cd /usr/local/mongodb/bin/ netstat -lanp | grep \u0026quot;27017\u0026quot; ./mongo use admin db.auth(\u0026quot;root\u0026quot;,\u0026quot;135451\u0026quot;) 启动redis cd /data/redis/bin/ redis-server 启动EasyMock cd /app/easymock/easy-mock/ npm run dev 本机访问 http://centos6:7300/ li","tags":["杂七杂八"],"title":"虚拟机搭建easymock","uri":"https://mumulx.github.io/2020/01/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BAeasymock/","year":"2020"},{"content":" 入门训练 圆的面积 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;iostream\u0026gt; int main (){ int r; scanf(\u0026quot;%d\u0026quot;,\u0026amp;r); double pi = 3.14159265358979323,s; s=pi * r *r; printf(\u0026quot;%.7f\u0026quot;,s); return 0; }  小数点的控制\n%d\t按十进制整型数据的实际长度输出。 %ld\t输出长整型数据。 %lld\t输出长长整型数据。 %md\tm 为指定的输出字段的宽度。如果数据的位数小于 m，则左端补以空格，若大于 m，则按实际位数输出。 %u\t输出无符号整型（unsigned）。输出无符号整型时也可以用 %d，这时是将无符号转换成有符号数，然后输出。但编程的时候最好不要这么写，因为这样要进行一次转换，使 CPU 多做一次无用功。 %c\t用来输出一个字符。 %f\t用来输出实数，包括单精度和双精度，以小数形式输出。不指定字段宽度，由系统自动指定，整数部分全部输出，小数部分输出 6 位，超过 6 位的四舍五入。 %.mf\t输出实数时小数点后保留 m 位，注意 m 前面有个点。 %o\t以八进制整数形式输出，这个就用得很少了，了解一下就行了。 %s\t用来输出字符串。用 %s 输出字符串同前面直接输出字符串是一样的。但是此时要先定义字符数组或字符指针存储或指向字符串，这个稍后再讲。 %x（或 %X 或 %#x 或 %#X）\t以十六进制形式输出整数，这个很重要。  入门训练 序列求和 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;iostream\u0026gt; using namespace std; int main (){ long long int n; scanf(\u0026quot;%d\u0026quot;,\u0026amp;n); long long int count=0; count = n*(n+1)/2; printf(\u0026quot;%lld\u0026quot;,count); return 0; }  注意：long long int的输出格式是%lld\n 短整型short：所占内存大小：2byte=16bit；\n所能表示范围：-32768~32767；(即-2^15~2^15-1)\n 整型int：所占内存大小：4byte=32bit；\n所能表示范围：-2147483648~2147483647；(即-2^31~2^31-1)\nunsigned: 所占内存大小：4byte=32bit；\n所能表示范围：0~4294967295；(即0~2^32-1)\n 长整型long：所占内存大小：4byte=32bit；\n所能表示范围：-2147483648~2147483647；(即-2^31~2^31-1)\nunsigned long: 所占内存大小：4byte=32bit；\n所能表示范围：0~4294967295；(即0~2^32-1)\n  注：上面所说的全部是有符号型的，short，int，long都默认为有符号型，其中long和int都占4个字节的空间大小，他们有什么区别呢？\nC语言规定：无论什么平台都要保证long型占用字节数不小于int型, int型不小于short型。\n 字符型char：所占内存大小：1byte=8bit；\n所能表示范围：不确定！！！！；\nunsigned char：所占内存大小：1byte=8bit；\n所能表示范围：0~255；(0~2^8-1)\nsingned char: 所占内存大小：1byte=8bit；\n所能表示范围：-128~127；(-2^7~2^7-1)\n  char的默认类型不确定有可能是unsigned，也有可能是signed，主要更具编译器而定，可以自己测试一下编译器的默认char的符号类型。\n 布尔类型bool：所占内存大小：1byte=8bit；\n所能表示的范围：只能取两个值false或者true；所以最小值就是：0， 最大值：1.\n 单精度float： 所占内存大小：4byte=32bit；\n所能表示的范围：(1.17549e-038)~(3.40282e+038);\n  注意：浮点数在内存中都是按科学计数法来存储的，浮点数的精度是由尾数的位数决定 的，大家记住即可不 必深究；\n 双精度double：所占内存大小：8byte=32bit；\n所能表示的范围：(2.22507e-308)~(1.79769e+308);\n  注：如何区分和使用这两个浮点类型呢，首先float和double的精度不同，float保留到小数点后面7位，而double保留到小数点后面16位，float能保证6位有效数字，而double能保证15位有效数字，如果在不追求精度的的情况下当然用 float比较好，节省内存，如果需要很高的精度的情况下，最好还是用double，平时我们定义浮点型变量一般都用double，毕竟精度高，一般精度的损失是不能忽略的。\n 字符串string：由于string在c++中属于类类型，不是基本数据类型，类不能计算其在内存中所占大小，非要用sizeof(string)来算的话，一般算出来的结果是 sizeof(string)=4byte， 如果string字符串内容很多，很明显就不是其真实大小，string类里面有计算其字节大小的函数如：size(),length()。  ","id":26,"section":"posts","summary":"入门训练 圆的面积 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;iostream\u0026gt; int main (){ int r; scanf(\u0026quot;%d\u0026quot;,\u0026amp;r); double pi = 3.14159265358979323,s; s=pi * r *r; printf(\u0026quot;%.7f\u0026quot;,s); return 0; } 小数点的控制 %d 按十进制整型数据的实际长度输出。 %ld 输出长整型数据。 %lld 输出长长整型数据。","tags":["杂七杂八"],"title":"蓝桥杯算法笔记","uri":"https://mumulx.github.io/2020/01/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","year":"2020"},{"content":" 学java的时候还是使用的Eclipse，并且使用了很长一段时间。然后学JSP的时候使用的是Eclipse IDE。接着就到了学习Spring家族的时候用的是STS。慢慢就听说了IDEA这个工具，听说要比Eclipse好用一些，第一次使用IDEA的时候是跟着老师学习在IDEA中使用Gradle整合gretty进行Web开发的时候。突然感觉IDEA好像确实名不虚传，这里就记录一下自己的IDEA的简单配置，这些配置有些是Eclipse中有的，有一些是Eclipse中没有的。工欲善其事，必先利其器，好的开发工具能提高自己的开发效率。\n修改配置文件 找到IDEA的安装目录/bin/idea64.exe.vmoptions文件修改\n-Xms500m -Xmx1500m -XX:ReservedCodeCacheSize=500m   -Xms500m \u0026ndash; Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值\n -Xmx1500m \u0026ndash; Java Heap最大值，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定\n -XX:ReservedCodeCacheSize=500m \u0026ndash; 预留保存代码的内存空间大小\n  注意：电脑配置在16G 64位系统时修改，可以提高IDEA的启动速度，代码自动保存的频率，提高开发效率。内存太小，不修改也可以。\n设置文件会放到github上，大家自行导入就行了github地址\n快捷键 直接导入快捷键设置，文件也在上面的github仓库中，采用的是类似Eclipse的快捷键的设置。\n执行(run)\talt+r 提示补全(Class Name Completion) alt+/ 单行注释 ctrl+/ 多行注释 ctrl+shift+/ 向下复制一行(Duplicate Lines) ctrl+alt+downe 删除行或选中行(delete line) ctrl+d 向下移动行(move statement down) alt+down 向上移动行(move statement up) alt+up 向下开始新的一行(start new line) shift+enter 向上开始新的一行 ctrl+shift+entere 如何查看源码(class) ctrl+选中指定的结构或ctrl+shift+t 万能解错/生成返回值变量 alt+enter 退回到前一个编辑的页面(back) alt+left 进入到下一个编辑的页面 alt +right 查看继承关系(type hierarchy) F4 格式化代码(reformat code) ctrl+shift+F 提示方法参数类型(Parameter Info) ctrl+alt+/ 复制代码 ctrl+C 撤销 ctrl+Z 反撤销 ctrl+y 剪切 ctrl+X 粘贴 ctrl+V 保存 ctrl+S 全选 ctrl+a 选中数行，整体往后移动 tab 选中数行，整体往前移动 shift + tab 查看类的结构:类似Feclipse 的outline ctrl+o 重构:修改交量名与方法名(rename) alt+shift+r 大写转小写/小写转大写(toggle case) ctrl+shift+y 生成构造器/get/set/tostring alt+shift+s 查看文档说明(quick documentation) F2 收起所有的方法(collapse all) alt+shift+C 打开所有方法(expand all) alt+shift+x 打开代码所在硬盘文件夹 ctrl+shift+x 生成try- catch等(surround with) alt+shift+z 局部变量抽取为成员变量 alt+shift+f 查找/替换(当前) ctrl+f 查找(全局) ctrl+h 查找文件 double shift 查看类的继承结构图(Show UML Diagram) ctrl+shift+u 查看方法的多层重写结构(method hierarchy) ctrl+alt+h 添加到收藏(add to favorites) ctrl+alt+f 抽取方法(Extract Method) alt+shift+m 打开最近修改的文件(Recently Files) ctrl+E 关闭当前打开的代码栏(close) ctrl+W 关闭打开的所有代码栏(close all) ctrl+shift+W 快速搜索类中的错误(next highlighted error) ctrl+shift+q 选择要粘贴的内容(Show in Explorer) ctrl+shift+V 查找方法在哪里被调用(Call Hierarchy) ctrl+shift+h 查看 树形 的类层次结构图 F4 结尾符 ctrl+alt+enter 快速添加返回值 ctrl+alt+v 代码格式化 ctrl+alt+l  模板 IDEA中代码模板所处的位置: settings Editor Live Templates/Postfix completion\npsvm public statis void mian(String[] args){ }  sout System.out.println(\u0026quot;\u0026quot;);  soutp System.out.println(\u0026quot;args = [\u0026quot; + args + \u0026quot;]\u0026quot;);  输出形参\nsoutm System.out.println(\u0026quot;test.main\u0026quot;);  输出方法名\nsoutv System.out.println(\u0026quot;a = \u0026quot; + a);  输出变量：就近原则\nxxx.sout a.sout System.out.println(a);  输出变量a\nfori for (int i = 0; i \u0026lt; ; i++) { }  iter for (String arg : args) { }  itar for (int i = 0; i \u0026lt; args.length; i++) { String arg = args[i]; }  list.for for (Object o : list) { }  遍历list\nlist.fori for (int i = 0; i \u0026lt; list.size(); i++) { }  list.forr for (int i = list.size() - 1; i \u0026gt;= 0; i--){ }  ifn if (list == null) { }  inn if (list != null) { }  xxx.nn if (list != null) { }  xxx.null if (list == null) { }  prsf private static final  psf public static final  psfi public static final int  psfs public static final String  ","id":27,"section":"posts","summary":"学java的时候还是使用的Eclipse，并且使用了很长一段时间。然后学JSP的时候使用的是Eclipse IDE。接着就到了学习Spring","tags":["开发软件"],"title":"IntelliJIDEA基础配置","uri":"https://mumulx.github.io/2020/01/intellijidea%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/","year":"2020"},{"content":" 下面来介绍几个我自己用到的vscode的插件\n主题  Atom One Dark Theme  文件图标主题  vscode-icons  代码格式化  Beautify  中文汉化  Chinese (Simplified) Language Pack for Visual Studio Code  与谷歌浏览器的链接  Debugger for Chrome  js语言  ESLint\n JavaScript (ES6) code snippets\n  HTML CSS  HTML CSS Support\n HTML Snippets\n  标签的提示修改  Auto Rename Tag\n  JQuery  jQuery Code Snippets  Vue  Vetur\n Vue 2 Snippets\n  写博客使用的markdown  markdownlint  打开浏览器  open in browser  显示路径文件  Path Intellisense  建议将自动保存选项给勾上，不然\u0026hellip;..血一样的教训。文件\u0026ndash;\u0026gt;自动保存前面打上钩\n以前前端做网页使用JQuery的时候还是比较喜欢HBuilder这个软件的。\n当使用Vue的话，感觉还是vscode更好用一些。\n以前没接触到vscode，学C++的时候还是用的visual studio2010，听到vscode的第一印象是visual studio，就像听到JavaScript和Java的感觉一样。并不很想用，用了之后发现 ,真香!!!!!!!\nvscode是世界上最好的编辑器！！！！！不接受反驳。\n","id":28,"section":"posts","summary":"下面来介绍几个我自己用到的vscode的插件 主题 Atom One Dark Theme 文件图标主题 vscode-icons 代码格式化 Beautify 中文汉化 Chinese (Simplified) Language Pack for Visual Studio Code 与谷歌浏览器的链接 Debugger for Chrome js语言 ESLint","tags":["开发软件"],"title":"VisualStudioCode常用插件","uri":"https://mumulx.github.io/2020/01/visualstudiocode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/","year":"2020"},{"content":" 简介 Web前端技术栈包括\n elementUI Nuxt Vue.js webpack ESLint Node.js axios mock.js ES6 Swagger  核心：Node.js和Vue.js\nwebpack webpack:打包, 可用将js等静态资源进行压缩，从而提高性能 可以打包js\\css\\图片等资源\n使用 下载安装 cnpm install webpack -g cnpm install webpack-cli -g  测试：\nwebpack -v  配置 新建并配置配置文件webpack.config.js\nvar path = require( 'path') ; module. exports = { entry: './src/main.js' ,//入口文件 output: {//输出文件 //_ di rname/.dist/bundle.is path: path. resolve(_ dirname, '.dist'), filename : 'bundle.js } }  运行 cmd到指定目录\nwebpack  webpack不能实现自动更新，修改代码后需要自己重新手动打包\n** 注意**：webpack本身只能打包js文件如果想打包css和图片文件的时候需要安装插件\n安装插件 npm install style-loader css-loader --save-dev  使用插件打包css  配置文件webpack.config.js\nvar path = require( 'path') ; module. exports = { entry: './src/main.js' ,//入口文件 output: {//输出文件 //_ di rname/.dist/bundle.is path: path. resolve(_ dirname, '.dist'), filename : 'bundle.js }, moudle:{ rules:[ { test:/\\.css$/, use:['style-loader','css-loader'] } ] } }  css文件要在主函数(main.js)中引用\nrequire('xxx.css')  使用\n执行cmd\n webpack  小结\n今后要使用css和js只要直接在html中引用bundle.js\n  实现修改css/js后，不打包，直接使得html生效 安装 npm i webpack-dev-server --save-dev  如果直接执行： webpack-dev-server ，会报错误：缺失该命令。\n原因：能够在cmd中执行直接的命令，必须是全局命令。\n全局安装\nnpm i webpack-dev-server -g  启动 cmd执行\nwebpack-dev-server  启动： webpack-dev-server ：自动将打包后的boundle.js -\u0026gt;加载到内存中（boundle.js）\nwebpack-dev-server启动模式，会将boundle.js加载到内存中。使用时，直接在当前目录中引用\u0026lt;script src=\u0026quot;bundle.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 这样好处：\n 热更新，css/js -\u0026gt;html 在内存中，因此速度快  也可以将该命令 配置在package.json中配置scrpit脚本\n{ \u0026quot;scripts\u0026quot;: { \u0026quot;dev\u0026quot; : \u0026quot;webpadk -dev-server \u0026quot; }, \u0026quot;devDependencies\u0026quot;: { \u0026quot;css- loader\u0026quot;: \u0026quot;^3.0. 0\u0026quot;, \u0026quot;style-loader\u0026quot;: \u0026quot;^0.23. 1 \u0026quot;, \u0026quot;webpack\u0026quot;: \u0026quot;^4.35.2\u0026quot;, \u0026quot;webpack-cli \u0026quot;:1 1^3.3.5” \u0026quot;webpack -dev-server\u0026quot;: \u0026quot;^3. 7.2\u0026quot; } }  直接运行\nnpm run dev  即可\n可以改修改启动时的默认文件目录：  修改成目录而不是文件\n 默认的文件名是index.html\n\u0026quot;scripts\u0026quot;:{ \u0026quot;dev\u0026quot; : \u0026quot;webpack-dev-server --contentBase src\u0026quot; },  d:/a/b/c/index.html\nd:/a/b/c/\n  修改端口以及自动启动 \u0026quot;scripts\u0026quot;:{ \u0026quot;dev\u0026quot; : \u0026quot;webpack-dev-server --port 8888 --open\u0026quot; }  注意：\nconsole.log(str);//cmd打印 - 调试窗口 document.write(str);//html  ES6 ESMAScript6.0 是一种规范JavaScript只是它的一个实现\n它有1、2、3、5、6这几个版本，4被废弃了\n ESMAScript6.0 是一套规范（2015年产生）：\n javascript是ESMAScript的具体实现\n NodeJs是javascript的脚本库\n  注意：\nNodeJs支持大部分的ESMAScript6.0 标准， 个别不支持 的需要回退5.0.\n版本回退，NodeJS会通过转换器自动搞定。\n转换器 配置转换器 新建文件并编辑(.babelrc)\n{ \u0026quot;presets\u0026quot;:['es2015'] }  安装转换器 cnpm install babel-preset-es2015 --save-dev  \u0026ndash;save-dev：以dev的方式安装\n安装命令行工具 cnpm install babel-cli -g  使用：  正常\nnode xxx.js  个别：\n如果遇到Nodejs不支持的ES6，则切换使用：\nbabel-node xxx.js   变量自动提升等级 test(); function(){ if(3\u0026lt;2\u0026gt;){ var a = 123; }else{ console.log(a); } }  运行结果：undefined\n没有报错\n原因：当使用a变量的时候发现当前找不到a但是上一级中有a，因此自动将a的等级提升变成\ntest(); function(){ var a； if(3\u0026lt;2\u0026gt;){ a= 123; }else{ console.log(a); } }  这种感觉\n如果不想自动提升则使用关键字let\ntest(); function(){ if(3\u0026lt;2\u0026gt;){ let a = 123; }else{ console.log(a); } }  运行结果：报错\n小结：\n var定义的变量，如果不存在，会自动提升（ 会将之前的局部变量，提升成全局变量 ） let:ES6 定义变量，和java等语言一样 严格控制变量的作用域（ES6新规范）\n const：常量（ES6新规范）\n  占位符/模板字符串 console.log('张三的年龄是：'+age);  可与写成\nconsole.log(`张三的年龄是：${age}`);  注意:占位符的符号是 ` 而不是 \u0026lsquo;\n换行符\n以前想要换行\nconsole.log('张三的年龄是：\\ 100');  现在：\nconsole.log(`张三的年龄是： 100`);  不需要使用\\连接\n函数默认参数 function test(a){ console.log(a); } test()  输出结果：\nundefined  现在\nfunction test(a=99){ console.log(a); } test()  输出结果\n99  箭头函数  不需要function关键字\n 省略return\n 继承this  之前\nfunction test(a,b){ console.log(a+b); }  现在\n(a,b)=\u0026gt; console.log(a+b);  以前\nfunction test(a,b){ return a+b; }  现在\n(a,b)=\u0026gt; (a+b);  对象初始化 以前\nfunction persion(pname,page){ return { name:pname; age:page; } }  现在\nfunction persion(pname,page){ return { pname; page; } }  可以省略属性名\n解构：方便的给对象、数组赋值 以前\nvar person={ name:'zs', age:23 } var pname =persion.name; var page = persion.age; console.log(`$(pname),$(page)`);  现在\nvar person={ name:'zs', age:23 } var {name,age}=persion; console.log(`$(name),$(age)`);  变量名与属性名要相等\n数组赋值\nconst fruit = ['apple','orange'] ; let [one,two] = fruit;  值的顺序与数组的顺序一致\n传播Spread Operator const fruit = ['apple','orange'] ; const fruit1=[...fruit,'pear']  此时fruit1中的前两个值就是fruit中的值\nvar person={ name:'zs', age:23 }; var person2={ ...persion, height:180 };  person2对象前两个属性是person中的属性\n导入导出 exports require()\nexports.fn=function(){ console.log('xx'); } require('./hello.js')  export import\nvar fn=function(){ console.log('xx'); } export{fn}; import{fn} from './hello.js'  使用export import时需要使用bable-node指令执行js文件\n分号结尾 分号 ：风格问题 可以加也可以不加（建议要么加要么不加）\n两个特殊情况 必须加：\n 下一条语句是()或[]开头，则上一条必须加;\n//以()开头 (function(){})() //以[]开头 [\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;].forEach(function(){ })   当都不加时，上一句的分号可以加在下一句的开头，即\n//以()开头 ;(function(){})() //以[]开头 ;[\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;].forEach(function(){ })  数据类型 基本类型  string number boolean undefined ：只定义，没赋值; var a ; null  引用类型  Object：任何对象 Function:函数 Array：数组\n数组和函数 都属于Object\n  判断类型  == / ===\n== 宽松的判断（自带类型转换）\n1==\u0026quot;1\u0026quot; 此时为true  ===严格的判断 （建议使用）\n1===\u0026quot;1\u0026quot; 此时为false  typeof：判断是否是某个类型 ，结果以“字符串形式”体现\nvar num; console.log(num,typeof num === 'undefined');  输出结果：\nundefined true  instanceof ：判断是否某个具体类型\n  prototype 原型 可以向对象 增加属性 或者方法\n每个函数都自带一个prorotype属性 ，默认情况下 指向一个空对象{} (称为原型对象，prototype对象) 原型对象（prototype对象） 都有一个constructor（构造方法）属性，它指向函数本身\nfunction myfun(){ } console . log(myfun. prototype ) console . log( myfun . prototype . constructor )  结果：\nmyfun{} 对象 [Function: myfun] 方法  使用 function Myfun(){ } Myfun.prototype.say=function(){ console.log(\u0026quot;this is a methods\u0026quot;) } var myfun= new Myfun(); myfun.say();  注意：\n 如果一个函数只有定义，即只有右边Myfun(){}，可以直接使用函数名.prototype;\n 如果一个函数有var myfun = function Myfun(){},则只能通过myfun.prototype\n  Restful编程风格  参数格式\nget方式传值\nlocalhost:8080/myproject?name=zs  Restful方式传值\nlocalhost:8080/myproject/zs ，将zs传递给后端  请求方式\npost： 增（查） delete: 删 put： 改 get： 查   get请求方式的地址栏中：\nlocalhost:8080/myproject?name=zs\u0026amp;age=23\u0026amp;hei=xxx\u0026amp;xxx...............  地址栏长度有限制 260-300 如果请求参数太长，超过了地址栏 范围，则只能换用其他请求方式（post）\nswagger Swagger是一款RESTFUL接口的文档在线自动生成+功能测试功能软件。Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化RESTfu风格的web服务。目标是使客户端和文件系统作为服务器一同样的速度来更新文件的方法，参数和模型紧密集成到服务器。这个解释简单点来讲就是说，swagger是一款可以根据restful风格生成的接口开发文档，并且支持做测试的一款中间软件。\n下载安装 swagger官网\n下载swagger Editor\n安装：package.json目录执行：\nnpm install  如果出现以下问题：\nError: Can't find Python executable \u0026quot;python\u0026quot;, you can set the PYTHON env variable  解决：\n * 管理员身份启动cmd * npm install --global --production windows-build-tools  再次执行：\n npm install  或使用在线版\n启动 双击index.html文件\n使用 swagger: '2.0' swagger版本号 info: version: \u0026quot;1.0.0\u0026quot; 文档的版本当 title: School-API 文档名称 host: xxx.xx.xx 项目地址 basePath: /xx 项目名 paths: 项目具体路径 /xx: 第一个访问地址 post: post请求 summary: 新增学校 注释 parameters: 传参 - 第一个参数，一个-代表一个参数 name: body 参数名 in: body 对象 description: 学校实体类 参数描述 required: true 参数是可选还是必须的 schema: 定义对象类型 $ref: '#/definitions/School' 类型是definitions中的School类型，definitions定义在后面 responses: 响应 200: 状态码 description: 成功响应 描述 schema: 响应数据 $ref: '#/definitions/ApiResponse' 数据类型 get: get请求 summary: 返回学校列表 描述 responses: 响应 200: 状态码 description: 成功响应 描述 schema: 数据 $ref: '#/definitions/ApiSchoolListResponse' definitions: 对象类型 School: 名称 type: object 类型 properties: 属性 id: 属性名 type: string 属性类型 description: ID 描述 name: 属性名 type: string 属性类型 description: 学校名称 描述 ApiResponse: 对象名 type: object 对象类型 properties: 属性 flag: 标识是否成功 type: boolean 类型 description: 是否成功 描述 code: 状态码 type: integer format: int32 description: 返回码 message: 返回信息 type: string description: 返回信息 ApiSchoolResponse: type: object properties: flag: type: boolean description: 是否成功 code: type: integer format: int32 description: 返回码 message: type: string description: 返回信息 data: $ref: '#/definitions/School' SchoolList: type: array items: $ref: '#/definitions/School' ApiSchoolListResponse: type: object properties: flag: type: boolean description: 是否成功 code: type: integer format: int32 description: 返回码 message: type: string description: 返回信息 data: $ref: '#/definitions/SchoolList'  in 的类型\nlocalhost: 8080/yq/school?a=b\u0026amp;c=d -query localhost: 8080/yq/school/b/d -path localhost: 8080/yq/school -body 对象类型  等等其他类型\n实例\nswagger: '2.0' info: version: \u0026quot;1.0.0\u0026quot; title: School-API host: xx.xx.xx basePath: /xx paths: /school: post: summary: 新增学校 parameters: - name: body in: body description: 学校实体类 required: true schema: $ref: '#/definitions/School' responses: 200: description: 成功响应 schema: $ref: '#/definitions/ApiResponse' get: summary: 返回学校列表 responses: 200: description: 成功响应 schema: $ref: '#/definitions/ApiSchoolListResponse' /school/{schoolId}: put: summary: 修改学校 parameters: - name: schoolId in: path description: 学校ID required: true type: string - name: body in: body description: 学校实体类 required: true schema: $ref: '#/definitions/School' responses: 200: description: 成功响应 schema: $ref: '#/definitions/ApiResponse' delete: summary: 删除学校 parameters: - name: schoolId in: path description: 学校ID required: true type: string responses: 200: description: 成功响应 schema: $ref: '#/definitions/ApiResponse' get: summary: 根据ID查询学校 parameters: - name: schoolId in: path description: 学校ID required: true type: string responses: 200: description: 成功响应 schema: $ref: '#/definitions/ApiSchoolResponse' /school/search: post: summary: 根据条件查询学校列表 parameters: - name: body in: body description: 学校实体类 required: true schema: $ref: '#/definitions/School' responses: 200: description: 成功响应 schema: $ref: '#/definitions/ApiSchoolListResponse' /school/search/{page}/{size}: post: summary: 根据条件查询学校列表 parameters: - name: page in: path description: 页码 required: true type: integer format: int32 - name: size in: path description: 页大小 required: true type: integer format: int32 - name: body in: body description: 学校实体类 required: true schema: $ref: '#/definitions/School' responses: 200: description: 成功响应 schema: $ref: '#/definitions/ApiSchoolPageResponse' definitions: School: type: object properties: id: type: string description: ID name: type: string description: 学校名称 isPopular: type: string description: 是否热门 ApiResponse: type: object properties: flag: type: boolean description: 是否成功 code: type: integer format: int32 description: 返回码 message: type: string description: 返回信息 ApiSchoolResponse: type: object properties: flag: type: boolean description: 是否成功 code: type: integer format: int32 description: 返回码 message: type: string description: 返回信息 data: $ref: '#/definitions/School' SchoolList: type: array items: $ref: '#/definitions/School' ApiSchoolListResponse: type: object properties: flag: type: boolean description: 是否成功 code: type: integer format: int32 description: 返回码 message: type: string description: 返回信息 data: $ref: '#/definitions/SchoolList' ApiSchoolPageResponse: type: object properties: flag: type: boolean description: 是否成功 code: type: integer format: int32 description: 返回码 message: type: string description: 返回信息 data: properties: total: type: integer format: int32 rows: $ref: '#/definitions/SchoolList'  只给显示界面 下载swagger-ui swagger-ui依赖nginx\n下载nginx 使用 swagger-ui-master.zip,解压，将其中的dist目录中的全部文件，拷贝到nginx中的html目录中\n运行 进入nginx目录cmd\nstart nginx.exe  访问\nlocalhost：80  整合 导出文件 swagger Editor中选择Generate Client中选择swagger-yaml\n导入swagger ui  将yaml文件拷贝到nginx的html目录中即可\n 搜索文件xxx.yaml\n  注意：文件后缀yaml和yml建议改成yml\nmock.js mockjs 可以以无侵入的方式拦截 ajax 请求，通过模拟服务器端响应来返回数据\n安装 cnpm install mockjs  快速体验\n新建test.js文件\nlet mymock = require('mockjs'); letpers = mymock.mock({ 'persons|10' :[{ 'id':1, 'name':'zs', 'age':23 }] }); console.log(JSON.stringify(pers,null,20));  运行\nnode test  语法  DTD:数据模板定义规范 DPD：数据占位符定义规范  DTD '属性名|规则': 属性值  实例\n'persons|10' :[{ 'id':1, 'name':'zs', 'age':23 }]  规则：\n 属性值是字符串类型\n 字符串重复count次\n属性名|count: 字符串 'name|10':'zs'  字符串重复min-max中任意次\n属性名|min-max: 字符串  \u0026lsquo;name|2-5\u0026rsquo;:\u0026lsquo;zs\u0026rsquo;\n  \u0026ndash;min-max代表次数\n 属性值是数字类型\n 递增任意数字\n属性名|+1: 数字 'id|+1':1  数字范围\n属性名|min-max: 数字 --min-max代表范围 'id|10-20':0 代表数字类型没有任何意义(可变成任意数字)  数字显示小数\n属性名|min-max.x: 数字 --min-max代表范围 'id|10-20.2':0 10-20中任意数字两个小数位  数字显示任意小数\n属性名|min-max.a-b: 数字 'id|10-20.2-4':0 10-20中任意数字2-4任意的小数   属性值是布尔类型\n 相等出现概率\n'sex|1':true 代表true出现的次数 和false 的概率是 1:1  自定义出现概率\n'sex|2-4':true 代表true出现的概率 是 2/2+4   属性值是对象object类型\n对象类型是通过json格式写的\n 对象出现的个数\n'属性|count':{k:v,k:v,k:v....} 'address|2':{'homeaddress':'西安','schooladdress':'北京','workaddress':'泸州'} 显示其中的任意两个  出现min-max中任意个\n'属性|min-max':{...} 'address|1-3':{'homeaddress':'西安','schooladdress':'北京','workaddress':'泸州'} 显示其中的任意1-3个   属性值是数组类型\n 出现指定次\n '属性|count':[{}] 'persons|3' :[{ ...} }]  出现min-max次\n'属性|min-max':[{}] 'persons|1-6' :[{ ...} }]    DPD 产生随机数据\n类型要加上@符号加上''\n 'name':'@cname', 'xing':'@cfirst', 'exing':'@Last',  注意： 属性名重复的话，后一个的值会覆盖前一个的值，出现的位置是在第一个的位置\n实例 let mymock = require('mockjs'); let pers = mymock.mock({ 'persons|1-6' :[{ 'id|+10':1, 'name':'@cname', 'xing':'@cfirst', 'exing':'@Last', 'desc' : '@string', 'stuno':'@integer', 'birthday':'@date', 'pic':'@image', 'age|18-60':0 , 'brief': '@title', 'content': '@cword(100)', 'height|160-180.2':0 , 'weight|50-100.2-4':0, 'sex|2-3':true , 'address|1-3':{'homeaddress':'西安','schooladdress':'北京','workaddress':'泸州'}, 'url':'@url' , 'ip':\u0026quot;@ip\u0026quot; , 'email':'@email', 'area':'@region', 'address2':'@county(true)' }] /* 'persons|1-6' :[{ 'id|+10':1, 'name|2-5':'zs', 'age|18-60':0 , 'height|160-180.2':0 , 'weight|50-100.2-4':0, 'sex|2-3':true , 'address|1-3':{'homeaddress':'西安','schooladdress':'北京','workaddress':'泸州'} }] */ }); console.log( JSON.stringify(pers ,null, 2) );  Easy mock Easy mock官网\neasy mock:在线Mock.js\n 内置了mock.js并且 暴露了url地址\n 同步swagger  模拟数据： 1. mock.js 模拟数据： 当请求url时，返回mock.js模拟的数据\n swagger模拟数据：根据yml中的请求url设置url,返回 response中定义的数据（类型是swagger定义的，而数据是easymock模拟出来的）-》模拟数据，并且有查询此数据的url【 url -\u0026gt;模拟数据】  使用  进入官网 创建项目 编写接口  使用swagger编写的yaml同步到easymock  获得yaml文件\n 进入easymock项目\n 设置\n Swagger Docs API\n 上传yaml文件\n 保存\n 进入easymock项目点击同步Swagger\n  element ui elementui:前端脚手架,vue组件组\n官网\n很多三方组件 是基础是基于elementui进行了扩展。 举例：\n vue-admin-template  github地址\ngithub上有详细的用法\n根据github提示:\n克隆项目（下载） git clone https://github.com/PanJiaChen/vue-admin-template.git  进入项目目录 cd vue-admin-template  安装依赖 npm install  建议不要直接使用 cnpm 安装以来，会有各种诡异的 bug。可以通过如下操作解决 npm 下载速度慢的问题 npm install --registry=https://registry.npm.taobao.org  启动服务 npm run dev  注意:\n遇见错误Error: Cannot find module 'node-sass'解决办法\ncnpm install node-sass --save  目录结构  build 构建源码 mock 模拟数据 public 首页\n favicon.ico网站图标  src 源码\n api 前后端遵循的api接口\n assets 资源 components 组件 icons 图标 router 路由 utils 工具 views 视图  .env.development 数据来源\n 修改数据来源，来源于easymock\nbase api VUE_APP_BASE_API = \u0026lsquo;https://www.easy-mock.com/mock/5d088992010742640520057f/myeasymock'  修改后需要重启\n  修改语言 进入src/main.js文件，修改成\nimport locale from 'element-ui/lib/locale/lang/zh-CN'  将本地数据 复制到 easymock中一份  修改数据源：.env.development ：VUE_APP_BASE_API\n request\u0026ndash;response\n 先查看本地有什么数据(chrome-F12,network)\n请求\nRequest URL(POST): http://localhost:9528/dev-api/user/login  响应\n{\u0026quot;code\u0026quot;:20000,\u0026quot;data\u0026quot;:{\u0026quot;token\u0026quot;:\u0026quot;admin-token\u0026quot;}}  请求\nRequest URL(GET): http://localhost:9528/dev-api/user/info （注意不要加?token=admin-token，定义接口时不需要传值，在请求时才传值）  响应\n{\u0026quot;code\u0026quot;:20000,\u0026quot;data\u0026quot;:{\u0026quot;roles\u0026quot;:[\u0026quot;admin\u0026quot;],\u0026quot;introduction\u0026quot;:\u0026quot;I am a super administrator\u0026quot;,\u0026quot;avatar\u0026quot;:\u0026quot;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif\u0026quot;,\u0026quot;name\u0026quot;:\u0026quot;lx\u0026quot;}}  复制到easy mock\n  在easy中定义请求和响应\n  源码  router:路由器\n views:视图\n api：调用接口\n  前端开发 请求xxx -\u0026gt;router(\u0026quot;xxx\u0026quot;)-\u0026gt;views(\u0026lt;template\u0026gt;html搭建,\u0026lt;script\u0026gt;js)-\u0026gt;调用（api）-\u0026gt;url(参数)-\u0026gt;Easy Mock[swagger(yml，类型+变量名，String id)+mock.js(DPD @string)] )\n后台开发： 请求xxx-\u0026gt;@RequestMapping(\u0026quot;xxx\u0026quot;)-\u0026gt;service -\u0026gt;dao -\u0026gt;db 动态从数据库中查\n请求xxx-\u0026gt;@RequestMapping(\u0026quot;xxx\u0026quot;)-\u0026gt;service :return \u0026quot;abc\u0026quot; 硬编码\n实例 简单的查询 .vue/.js模块化编程：\nimport .. export  请求xxx -\u0026gt;router(\u0026quot;xxx\u0026quot;)-\u0026gt;views(\u0026lt;template\u0026gt;html搭建,\u0026lt;script\u0026gt;js)-\u0026gt;调用（api）-\u0026gt;url(参数)-\u0026gt;Easy Mock[swagger(yml，类型+变量名，String id)+mock.js(DPD @string)] )\nviews  新建文件夹、文件myactivity/activity.vue\n 编写代码\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-table :data=\u0026quot;activitiesData\u0026quot; stripe style=\u0026quot;width: 100%\u0026quot;\u0026gt; \u0026lt;el-table-column prop=\u0026quot;id\u0026quot; label=\u0026quot;编号\u0026quot; width=\u0026quot;130\u0026quot;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026quot;name\u0026quot; label=\u0026quot;活动名\u0026quot; width=\u0026quot;130\u0026quot;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026quot;starttime\u0026quot; label=\u0026quot;开始时间\u0026quot;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026quot;state\u0026quot; label=\u0026quot;状态\u0026quot;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import activityApi from '@/api/activity' export default{ //获取easy mock中的模拟数据 ;变量 data(){ return { //查询easymock时 传入的参数（活动对象） activityData : {}, //封装活动信息：id, } } , /* created():初始化方法 -\u0026gt; 加载数据 initActivities(); data()：为了给 \u0026lt;templete\u0026gt;里的table填充值 */ //初始化方法 created(){ this.initActivities(); }, methods:{ initActivities(){ activityApi.getActivitis().then(response=\u0026gt;{ //将easy mock中查询的活动数据 赋值给activitiesData this.activitiesData = response.data ; } ); } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt;   api 新建文件activity.js\nimport request from '@/utils/request' //activity export default { //请求easy mock，获取活动列表数据 getActivitis(){ return request({ url: '/yq/activity', method: 'get' }) } }  easymock 编写请求和响应\n{ \u0026quot;code\u0026quot;:20000, \u0026quot;flag\u0026quot;:true 'message\u0026quot; \u0026quot;@string\u0026quot;， \u0026quot;data|10\u0026quot;:[{ \u0026quot;id|+1\u0026quot;: 1， “name\u0026quot;: \u0026quot;@cword\u0026quot; ”summary\u0026quot; : \u0026quot;@cword(6,10)\u0026quot; , \u0026quot;detail\u0026quot;: \u0026quot;@cword(16,20)\u0026quot;， ”sponsor\u0026quot;:' ”@string\u0026quot; , ”image\u0026quot;: \u0026quot;@string\u0026quot; ， 'starttime\u0026quot;: \u0026quot;@date\u0026quot;， ”endtime\u0026quot;:\u0026quot; @date\u0026quot; , \u0026quot;address\u0026quot;: \u0026quot;@string\u0026quot;, enrolltime\u0026quot;: \u0026quot;@string\u0026quot; ， \u0026quot;state\u0026quot;:\u0026quot; @string ， 'school\u0026quot;: \u0026quot;@string\u0026quot; }] }  code的值必须是20000\n编写router路由 { path: '/example', component: Layout, redirect: '/example/table', name: 'Example', meta: { title: '示例', icon: 'example' }, children: [ { path: 'table', name: 'Table', component: () =\u0026gt; import('@/views/myactivity/activity'), meta: { title: '活动', icon: 'table' } }, { path: 'tree', name: 'Tree', component: () =\u0026gt; import('@/views/tree/index'), meta: { title: 'Tree', icon: 'tree' } } ] }  实例\u0026ndash;分页 easymock 'code\u0026quot;: 20000 , \u0026quot;flag\u0026quot;: true, \u0026quot;message\u0026quot;:\u0026quot;带分页的查询\u0026quot;, data\u0026quot;: { \u0026quot;total\u0026quot;: 109, \u0026quot;rows|10\u0026quot;: [{ id|+1\u0026quot;: 1, ”name”: \u0026quot;@cnpme\u0026quot;， summary\u0026quot;: \u0026quot;@string\u0026quot; ， detail\u0026quot;: @string\u0026quot;, \u0026quot;sponsor\u0026quot;: \u0026quot;@string\u0026quot; , ' image\u0026quot;:\u0026quot; @string\u0026quot; , starttime\u0026quot;:' \u0026quot;@string\u0026quot; , ”endtime\u0026quot;:” @string\u0026quot; , ”address\u0026quot;: \u0026quot;@string ”enrolltime\u0026quot;: \u0026quot;@string\u0026quot; , \u0026quot;state\u0026quot;: \u0026quot;@string\u0026quot; , ”school\u0026quot;: \u0026quot;@string }] }  数据的形式：\n response.data.total :总数据量 response.data.rows:每页的数据量  api  initActivitiesByPage(currentPage,pageSize,activityQueryData){ //currentPage:当前第几页 pageSize：每页的数据量 return request({ url: `/yq/activity/queryActivitiesByPage/${currentPage}/${pageSize}`, method: 'post', data: activityQueryData //时间、名称 }) },  Vue  //带分页：查看当前页的数据 initActivitiesByPage(){ activityApi.initActivitiesByPage(this.currentpage,this.pagesize,this.activityData ).then(response=\u0026gt;{ this.total = response.data.total ;//109 this.activitiesData = response.data.rows ; }) }   \u0026lt;div class=\u0026quot;block\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;demonstration\u0026quot;\u0026gt;分页\u0026lt;/span\u0026gt; \u0026lt;el-pagination @current-change =\u0026quot;initActivitiesByPage\u0026quot; @size-change= \u0026quot;initActivitiesByPage\u0026quot; :page-sizes=\u0026quot;[10,20,30]\u0026quot; :page-size=\u0026quot;pagesize\u0026quot; :current-page=\u0026quot;currentpage\u0026quot; layout=\u0026quot;prev, pager, next\u0026quot; :total=\u0026quot;total\u0026quot;\u0026gt; \u0026lt;/el-pagination\u0026gt; \u0026lt;/div\u0026gt;  具体的代码放到百度网盘中了，自行下载；\n网盘地址\n提取码：abnl\nNuxt入门 nuxt官网\nnuxt：服务器渲染技术\najax -\u0026gt;服务端-\u0026gt;ajax\n服务端-\u0026gt;客户端\n服务端渲染优势：SEO ,提高网站的搜索排名 ， 爬虫 ：特点，不认识js（ajax就是js）\n下载运行 下载nuxt的模板代码starter-template github地址\n安装依赖 npm install  修改package.json中的占位符{{name}} \u0026quot;name\u0026quot;: \u0026quot;studynuxt\u0026quot;,  运行 npm run dev  访问 localhost:3000  源码  assets 静态资源 components 组件 static 静态图标 pages 页面 layouts 页面布局  layouts 页面布局三个部分\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;header\u0026gt;头部\u0026lt;/header\u0026gt; \u0026lt;nuxt/\u0026gt; \u0026lt;footer\u0026gt;尾部\u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;  pages 页面\n映射时，默认的文件名：index.vue\n映射目录“/”：代表的 pages目录\n\u0026lt;router-link to=\u0026quot;/userinfo\u0026quot;\u0026gt;  有两种可能： 1. pages/userinfo/index.vue 2. pages/userinfo.vue\n通过axios进行渲染\naxios 下载 cnpm install axios --save  share \u0026ndash;分享 share.js\nsocial-share.min.js\nshare.min.css\ngithub地址\n 引入。\nhttps://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css  编写DIV\n\u0026lt;div class=\u0026quot;social-share\u0026quot; \u0026gt;\u0026lt;/div\u0026gt;  完整性\nhttps://blog.csdn.net/liwenfei123/article/details/78952337 data-title data-description data-sites ：['qzone', 'qq', 'weibo','wechat', 'douban'] data-url data-xxx   代码 百度云\n提取码：a3xs\n","id":29,"section":"posts","summary":"简介 Web前端技术栈包括 elementUI Nuxt Vue.js webpack ESLint Node.js axios mock.js ES6 Swagger 核心：Node.js和Vue.js webpack webpack:打包, 可用将js等静态资源进行压缩，从而提高","tags":["前端框架"],"title":"Web前端技术栈","uri":"https://mumulx.github.io/2020/01/web%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/","year":"2020"},{"content":" vue介绍 vue是一个渐进式的JavaScript框架。渐进式：可插拔式、可扩展。\n我们刚开始只需要使用最核心的核心库，后期可以自己去增加新库。\nvue官网\nvue引入 vue提供了非常详细的官方文档，我们完全可以通过官方文档来学习vue.vue官方文档\nxx.vue文件组成结构： \u0026lt;template\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt;  在chrome中安装vue开发工具 解压文件下载,或者参考网上的解决方案进行安装\n该插件可以在chrome浏览器中充当vue的调试工具\nmvvm简介 html使用vue \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; var vm = new Vue({ el:'', data:{ }, methods:{ }, computed:{ }, directives:{ }, watch:{ }, components:{ }, filters:{ } }) \u0026lt;/script\u0026gt;   var vm = new Vue({});\n创建一个vue的实例\n当我们导入包之后在浏览器的内存中，就多了一个Vue的构造函数\n注意：我们new出来的这个vm对象就是我们mvvm中的vm调度者\n el\n表示，当前我们 new的这个vue实例，要控制页面上的哪一个区域\n data\ndata属性中，存放的时el中索要用到的数据，形式是采用key:value的形式\n这里的data 就是mvvm中的m，专门用来保存页面数据的\n通过 vue提供的指令，很方便的就能把数据渲染到页面上，程序员不需要手动操作dom元素了【前端的vue之类的框架，不提倡我们区手动操作dom元素了】\ndata中定义的变量是全局变量，所有vue对象都可以使用\ncomputed中的返回值也作为data中的一部分\n methods\n定义方法\n computed\n 进行计算，初始时自动加载，和变量是共享的（在data中定义的变量，就不能再在computed中定义）它中方法的返回值，也作为data变量存在：方法名就是变量名，返回值就是它的值。\n 当data数据发生改变时也会执行。\n computed中定义的data变量（类似方法的形式）只会被计算一次，之后会加入缓存中，之后在取值时，直接从缓存中获取。\ncomputed:{ ageAndName(){ return this.name+this.age; }  }\n  directives\n定义局部指令\n watch\n进行监听，将html中的数据放到data中(mvvm中 v\u0026ndash;\u0026gt;m),当数据发生变化时，触发监听\nwatch:{ name:function(value){ this.name1= value; } }  components\n定义组件\n filters\n定义过滤器\n 生命周期的函数\n  语法 插值表达式 {{}} 显示内容，只会替换自己的这个占位符，不会吧整个元素的内容清空\n\u0026lt;h1\u0026gt;{{name}}2222222\u0026lt;/h1\u0026gt; name:\u0026quot;helloword\u0026quot;  输出\nhelloword2222222  v-clock: 能够解决插值表达式闪烁的问题\n出现的原因：跟生命周期有关\nvue会先加载html文件，然后加载js文件，最后进行替换(vue数据)\n解决方案：先将元素隐藏，当加载完毕之后在进行显示\n 定义\n\u0026lt;style\u0026gt; [v-clock] { display: none; } \u0026lt;/style\u0026gt;  使用\n\u0026lt;p v-cloak\u0026gt;{{msg}}\u0026lt;/p\u0026gt;   使用v-clock能够解决插值表达式闪烁的问题，当网络较慢的时候{{msg}}会显示在页面中\nv-text: 显示内容，但是会覆盖元素中的原本内容\n\u0026lt;h1 v-text=\u0026quot;name\u0026quot;\u0026gt;222222\u0026lt;/h1\u0026gt; name:\u0026quot;helloword\u0026quot;  输出\nhelloword  v-html: 带渲染的显示，节点操作\n\u0026lt;h1 v-html=\u0026quot;site\u0026quot;\u0026gt;\u0026lt;/h1\u0026gt; site:\u0026quot;\u0026lt;a href='https://www.baidu.com'\u0026gt;百度\u0026lt;/a\u0026gt;\u0026quot;,  v-bind: 或 : 给html标签的属性绑定值\n他的缩写是 :\n\u0026lt;a v-bind:href=\u0026quot;link\u0026quot;\u0026gt;百度\u0026lt;/a\u0026gt; \u0026lt;a :href=\u0026quot;link\u0026quot;\u0026gt;百度\u0026lt;/a\u0026gt;  v-on: 或 @ 事件的绑定\n\u0026lt;button v-on:click=\u0026quot;sayHello\u0026quot;\u0026gt;sayHello\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026quot;sayHello\u0026quot;\u0026gt;sayHello\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026quot;sayHelloName('ssss')\u0026quot;\u0026gt;sayHelloName\u0026lt;/button\u0026gt;  无参函数中的()可写可不写\n有参函数需要传参的时候需要加上()\nv-model 可以实现 表单元素和model中的数据实现双向绑定\n用户名：\u0026lt;input type=\u0026quot;text\u0026quot; v-model=\u0026quot;name\u0026quot;/\u0026gt;  注意：\n 将data中的数据传到html中 插值表达式 {{}}，v-text:，v-html:，等方式\n 将html中的数据传到data中：\n 通过监听watch\n 通过vue对象\nvm.$watch('name', function(value){ this.age= value; })    vue引入css 通过class  定义css\n\u0026lt;style\u0026gt; .mystyle1{ background-color: blue ; width: 100px; height: 100px; } \u0026lt;/style\u0026gt;  css绑定到data\ncss1 : 'mystyle1'  html元素使用css\n\u0026lt;h3 :class=\u0026quot;mystyle1\u0026quot;\u0026gt;1111111\u0026lt;/h3\u0026gt;   注意\n vue的css样式引入可以与传统的css样式引入共存\n\u0026lt;h3 class=\u0026quot;mystyle3\u0026quot; :class=\u0026quot;css1\u0026quot;\u0026gt;info:{{info}}\u0026lt;/h3\u0026gt;  :class的值 是一个对象{k1:v1,k2:v2...}如果对象中的变量值true，则生效；否则不生效\n\u0026lt;h3 :class=\u0026quot;{mystyle1:istrue, mystyle3:isfalse}\u0026quot; \u0026gt;111111\u0026lt;/h3\u0026gt;  istrue和isfalse在data中定义，根据他们的值来判断样式是否生效，当istrue=true;isfalse=false;时，mystyle1生效，mystyle3不生效\n值可以同时为true或false\n 绑定数组 []\n\u0026lt;h3 :class=\u0026quot;['mystyle1', 'mystyle3']\u0026quot;\u0026gt;11111\u0026lt;/h3\u0026gt;  同时生效\n vue取值有一个特点：取的值是变量，变量名是在data中定义的。\n  通过style 语法：\n:style={样式名:样式值(\u0026lt;从data中获取\u0026gt;),x:x,...}\n\u0026lt;h3 :style=\u0026quot;{backgroundColor:x,color:y}\u0026quot;\u0026gt;info000000:{{info}}\u0026lt;/h3\u0026gt; x:'lightgray' , y:'purple',  注意：\n属性的名字不能使用xxx-yyyy(中间使用-符号)，而需要使用 xxxYyyy(驼峰命名)\n条件渲染 v-if和v-else \u0026lt;h3 v-if=\u0026quot;istrue\u0026quot;\u0026gt;1111\u0026lt;/h3\u0026gt; \u0026lt;h3 v-else\u0026gt;222\u0026lt;/h3\u0026gt;  isture在data中定义，当为真时显示111，为假时显示222\nv-show \u0026lt;h3 v-show=\u0026quot;isture\u0026quot;\u0026gt;111\u0026lt;/h3\u0026gt; \u0026lt;h3 v-show=\u0026quot;!isture\u0026quot;\u0026gt;222\u0026lt;/h3\u0026gt;  注意：v-if和v-show的区别\nv-show可以在源码中追踪到隐藏的元素,即隐藏的元素可以在源码中找到；\nv-if无法追踪，即隐藏的元素，在源码中找不到；\n循环遍历  \u0026lt;!-- 遍历一个具体对象 (一个对象有很多属性：name age )--\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026quot;(value,name) in students[2]\u0026quot; :key=\u0026quot;name\u0026quot; \u0026gt; {{value}} --{{name}} \u0026lt;/li\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;  value：对象属性的值\nname：对象的属性名\nstudents[2]:对象数组中的一个元素(即一个对象)\n遍历对象 遍历对象数组 \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026quot;(s,index) in students\u0026quot; :key=\u0026quot;index\u0026quot; \u0026gt; {{index}} - {{s.name}} - {{s.age}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; students: [ {name:'zs', age:23}, {name:'ls', age:24}, {name:'ww', age:25}, {name:'zl', age:26}, {name:'sq', age:27} ] //对象数组  s:数组的每一个元素\nindex:下标\nstudents:数组\n:key:唯一值\n注意：想要获取data中的数据，需要通过this.来获取\n删除数组元素:splice //删除完毕后，数组元素 会自动重新排序 this.students.splice(index,1);  从下标index起删除1个\n更新数组元素:splice this.students.splice(index,1,stu);  将下标为index的数组元素更新为stu对象\n筛选 组成：查询的条件，新数组\n 定义查询条件(即定义data中数据)\nqueryname: \u0026ldquo; //筛选条件\n 具体实现方法(在computed中定义，函数名就是变量，即新数组)\n//筛选后的新数组 queryStuentsResult(){ // 新数组的值 var queryStudents ;//s //筛选条件 // var queryname = data中定义的queryname ; // var student2 = data中定义的数组students ; var {queryname,students} = this ;//this 就是data //根据查询条件，筛选出新数组 queryStudents = students.filter( stu=\u0026gt;stu.name .indexOf(queryname ) \u0026gt; -1 ) return queryStudents ; }   排序  定义升降序变量(0:升序,1:降序)\n ordered: 0  对queryStudents对象数组中的元素，根据age属性进行排序\n//排序 queryStudents.sort( function(s1,s2) { if(ordered ==0){//升序 return s1.age - s2.age }{//降序 return s2.age -s1.age } })  升序：第一个 - 第二个\n降序：第二个 - 第一个\n别忘了return\n  传播行为与事件 传参当前对象 \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;按钮1\u0026quot; @click=\u0026quot;myclick\u0026quot; /\u0026gt; \u0026lt;!--错误行为--\u0026gt; \u0026lt;!-- \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;按钮\u0026quot; @click=\u0026quot;myclick()\u0026quot; /\u0026gt; --\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;按钮2\u0026quot; @click=\u0026quot;myclick2($event)\u0026quot; /\u0026gt;  传当前对象时，要么不写，要么添加($event)，不能只写()这样会报错\n获取对象 myclick(event){ alert( event.target.value ) }, myclick2(event){ alert(event.target.value ) },  event.target：当前对象\n注意：在vue中结尾符;可写可不写(要么都写，要么都不写)\n事件的传播行为(propogation) \u0026lt;div :class=\u0026quot;css1\u0026quot; @click='myclick3()'\u0026gt; outer \u0026lt;div :class=\u0026quot;css2\u0026quot; @click='myclick4()'\u0026gt; inner \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; myclick4(){ alert('inner' ) }, myclick5(){ alert('link...' ) },  结果：\n点击:inner时，会触发outer的点击事件\n阻止行为：\n\u0026lt;div :class=\u0026quot;css1\u0026quot; @click='myclick3()'\u0026gt; outer \u0026lt;div :class=\u0026quot;css2\u0026quot; @click.stop='myclick4()'\u0026gt; inner \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;  阻止默认行为 \u0026lt;a href=\u0026quot;https://www.baidu.com\u0026quot; @click.prevent='myclick5()'\u0026gt;百度\u0026lt;/a\u0026gt; myclick5(){ alert('link...' ) },  注意:.xxx可以嵌套着使用\n键盘点击事件 keydown 按键 按下事件\n\u0026lt;input @keydown='myclick6'\u0026gt; myclick6(event){ //event.target :当前dom对象 //event.keyCode：按键的值 a : 65 alert( event.keyCode +'--'+ event.target.value ) },  keyup 按键弹上去事件\n指定按键触发事件 \u0026lt;input @keyup.13='myclick6' \u0026gt;  指定的按键按下抬起时才触发的事件\n每一个键盘的按键都对应着一个键码值\n表单输入绑定 \u0026lt;form action=\u0026quot;\u0026quot; @submit.prevent=\u0026quot;mysubmit\u0026quot;\u0026gt; 用户名：\u0026lt;input type=\u0026quot;text\u0026quot; v-model=\u0026quot;user.username\u0026quot; \u0026gt;\u0026lt;br\u0026gt; 密码：\u0026lt;input type=\u0026quot;password\u0026quot; v-model=\u0026quot;user.password\u0026quot; \u0026gt;\u0026lt;br\u0026gt; 性别： \u0026lt;input type=\u0026quot;radio\u0026quot; value=\u0026quot;male\u0026quot; v-model=\u0026quot;user.password\u0026quot;\u0026gt;男\u0026lt;br\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; value=\u0026quot;female\u0026quot; v-model=\u0026quot;user.password\u0026quot;\u0026gt;女\u0026lt;br\u0026gt; 兴趣： \u0026lt;input type=\u0026quot;checkbox\u0026quot; value=\u0026quot;football\u0026quot; v-model=\u0026quot;user.hobbies\u0026quot;\u0026gt;足球， \u0026lt;input type=\u0026quot;checkbox\u0026quot; value=\u0026quot;basketball\u0026quot; v-model=\u0026quot;user.hobbies\u0026quot;\u0026gt;篮球， \u0026lt;input type=\u0026quot;checkbox\u0026quot; value=\u0026quot;pingpang\u0026quot; v-model=\u0026quot;user.hobbies\u0026quot;\u0026gt;乒乓球， 城市： \u0026lt;select name=\u0026quot;\u0026quot; id=\u0026quot;\u0026quot; v-model=\u0026quot;user.city\u0026quot;\u0026gt; \u0026lt;option :value=\u0026quot;c.id\u0026quot; v-for=\u0026quot;c in optionalCities\u0026quot;\u0026gt; {{c.name}} \u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;注册\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  data:{ user:{ username: '' , passowrd: '' , sex: 'male', hobbies: [] , city: '' //选中 }, //可选 optionalCities: [\u0026quot;js\u0026quot;,\u0026quot;bj\u0026quot;,\u0026quot;sh\u0026quot;] },  这里只列出了部分的用法详细的用法参考官网手册(http://doc.vue-js.com/v2/guide/forms.html)\n意义：如果给后台传递一个form表单的数据，不用再 一个一个的获取每个input等元素的值；而可以一次性传递一个对象\n生命周期 作用 生命周期的作用：某个动作 都有一个流程，当执行到该流程的某一个阶段时，会自动触发一些函数\n注意:生命周期函数与methods和el等标签同级\n详细的说明参见官方文档(https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA)\n动画效果 显示：Enter\n隐藏：Leave\n三个阶段： 初始阶段： v-enter/v-leave  过渡阶段： v-enter-active / v-leave-active  结束阶段： v-enter-to/v-leave-to  v- 是这些类名的前缀。使用 \u0026lt;name=\u0026quot;my-transition\u0026quot;\u0026gt; 可以重置前缀，比如 v-enter 替换为 my-transition-enter。\n过滤器 {{ message | filterA | filterB }}\n{{msg | 过滤器1 | 过滤器2 }}\nmoment.js 时间格式化，去官网下载js文件\n引入\n注册过滤器  //过滤：注册-\u0026gt;使用 (西方日期 -\u0026gt;格式) //es6:函数默认参数值 Vue.filter('dateFilter' , function(value, dateFormat='YYYY-MM-DD HH:mm:ss' ){ return moment(value).format(dateFormat) ; })  使用过滤器 {{ now | dateFilter('YYYY-MM-DD')}}  自定义指令 v-text-upper\nv-text-lower\n定义指令的名字是v-是不需要我们写的，只需要写右边的部分即可\n全局指令 与var vm = new Vue({})同级（与全局变量定义类似）\n 注册全局指令\nVue.directive('text-upper',function(el,binding){ el.innerHTML= binding.value.toUpperCase(); })  使用\n\u0026lt;p v-text-upper=\u0026quot;myVariable\u0026quot;\u0026gt;\u0026lt;/p\u0026gt; myVariable : \u0026quot;Hello World\u0026quot;,   局部指令 在var vm = new Vue({})中定义 （与局部变量定义类似）\n 注册局部指令\n//注册局部指令 directives:{ 'text-lower' :{ bind(el,binding){ el.innerHTML= binding.value.toLowerCase(); } } }  使用\n\u0026lt;p v-text-upper=\u0026quot;myVariable\u0026quot;\u0026gt;\u0026lt;/p\u0026gt; myVariable : \u0026quot;Hello World\u0026quot;,   自定义插件 详细参见官方文档\n开发插件 例\n(function(){ const MyPlugin = {} ; MyPlugin.install = function (Vue, options) { // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () { alert('全局方法或属性'); } // 2. 添加全局资源 Vue.directive('my-directive', {//v-text-upper bind (el, binding, vnode, oldVnode) { // 逻辑... } }) // 3. 注入组件选项 .每次实例vue对象中调用一次 Vue.mixin({ created: function () { // 逻辑... alert('mixin'); } }) // 4. 添加实例方法（局部） Vue.prototype.$myMethod = function (methodOptions) { // 逻辑... alert('局部') ; } } //将插件 暴露给外部使用 window.MyPlugin = MyPlugin ; })()  使用插件  引入(js文件)\n 使用插件\nVue.use(MyPlugin); //全局：static //类名.静态方法() Vue.myGlobalMethod(); //对象.方法() vm.$myMethod();   vue脚手架开发 vue脚手架指的是vue-cli，它是一个专门为单页面应用快速搭建繁杂的脚手架，它可以轻松的创建新的应用程序而且可用于自动生成vue和webpack的项目模板。\n安装 npm install -g vue-cli  下载模板 vue init webpack my_vue_cli  需要配置一些基本信息，不配置的话就一路回车\n注意： 根据提示 安装附加组件，安装时输入项目名时不能包含大写字母。安装时，不要随意点鼠标，点击鼠标右键可以恢复。\n根据提示\ncd my_vue_cli npm run dev  打包运行项目  生成dist目录\nnpm run build  安装服务组件(静态服务)\nnpm install -g serve\n 运行 serve dist\n 动态服务(tomcat)\n 配置webpack.prod.conf.js\noutput: { ... publicPath: '/myvue/' --\u0026gt;配置访问时的项目名  打包成dist\n 将dist拷贝到tomcat/webapps中，并且再将dist修改成myvue\n 启动tomcat,运行\n   vuecli源码解读 npm run dev 触发了哪些文件  dev -\u0026gt;package.json -\u0026gt;build/webpack.dev.conf.js -\u0026gt;./webpack.base.conf -\u0026gt;./src/main.js引用时的名字叫app\n 根据web基础知识可知： http://localhost:8080 实际是访问http://localhost:8080/index.html\n index.html:\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; -\u0026gt;会被src/App.vue中的\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;内容注入：\n  src/App.vue中内容\n\u0026lt;router-view/\u0026gt; ：路由，映射关系 localhost:8080/b\u0026ndash;\u0026gt; xxx本项目的映射： localhost:8080/ \u0026ndash;\u0026gt;HelloWorld.vue\n配置路由：\u0026lt;router-view/\u0026gt;: router/index.js 文件\n  小结 npm run dev -\u0026gt; main.js localhost:8080 / :index -\u0026gt; router -\u0026gt; HelloWorld.vue中的内容  app.vue中直接引入helloworld.vue  引入helloworld.vue\n\u0026lt;script\u0026gt; import HelloWorld from './components/HelloWorld'  将引入的文件打成一个组件\nexport default{ xxxxxx, components:{ HelloWorld } }  使用组件\n以标签的形式使用\n\u0026lt;HelloWorld\u0026gt;\u0026lt;/HelloWorld\u0026gt;   ESlint 代码规范检查工具，官网\n可以检测\n 空格个数 空行 变量名 代码是否未被使用 \u0026hellip;  如果不规范，则警告 或报错\n检测规则  \u0026ldquo;off\u0026rdquo; 或 0 - 关闭规则 \u0026ldquo;warn\u0026rdquo; 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出) \u0026ldquo;error\u0026rdquo; 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)  设置某些检查规则：.eslintrc.js文件\n全局设置是否启用ESlint：.eslintignore文件\n注意：\n初学：关闭\n真实的开发项目：打开，帮助规范代码的编写\nvue文件 组成 \u0026lt;template\u0026gt; \u0026lt;script\u0026gt; \u0026lt;style\u0026gt;  export default { name: '名字' , data(){ return msg: 'xxx' }， omputed:{}, methods:{}, components:{//组件} }  vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 vuex中文官网\n根据官网的流程图来理解Vuex\n状态自管理应用包含以下几个部分:\n state, 驱动应用的数据源; view,以声明方式将state映射到视图; actions, 响应在view.上的用户输入导致的状态变化。  他们时单向不可逆的，我们已简单的数字自增来举例，在state中定义一个变量count，显示在view组件上，通过actions来操作state，state变化后，view中也随之改变。\n但实际中vuex还有一个部分 mutations，根据官网的第二张图，我们发现action通过commit调用了Mutations，Mutations通过Mutate调用State，State通过Render来调用view，view通过dispatch来调用Action。此时就有点像mvc模式，actions和Mutations的关系就像service和dao的关系一样，Mutations会执行一些原子性的操作，而actions会做一些带逻辑性的操作；如删除操作，Actions会先判断存不存在，当存在的时候在进行删除，而Mutations则只进行删除操作。\n开发一个简单的状态管理 安装vuex依赖 npm install --save vux  新建./src/store.js文件 import Vue from 'vue' import Vuex from 'vuex' //使用vuex Vue.use(Vuex) //定义共享变量 const state = { count :0 } //直接操作共享变量的对象 const mutations={ mulincreases(state){ state.count++; } } //操作mutations的对象 const actions={ actioncrease({commit}){ commit('mulincreases'); } } //将store.js中的对象暴漏给外界 ，用于其他组件的共享 export default new Vuex.Store({ state, mutations, actions })  封装对象 我们发现要想将对象暴漏给外界，当需要暴漏的对象太多的时候，就会很麻烦，因此我们可以将要暴漏的对象给封装起来。\n在前面我们可知，程序在启动时会自动触发src/main.js文件。因此，思路：可以将store.js中暴露的多个对象，封装到main.js中。\n例：\n //引入准备封装的文件 import store from \u0026quot;./store\u0026quot; new Vue({ //xxxx store//注入store对象 })  此时我们需要引用需要暴漏的对象时只需要使用store.xxx即可使用。\n新建组件使用变量 组件其实就是一个.vue的文件\n我们在app.vue中使用变量\nsrc/main.js -》store -\u0026gt;App.vue\n程序的启动顺序，先main.js(store) -\u0026gt;App.vue 因此，在使用App.vue时，已经加载过了store,因此在App.vue中可以直接使用store,使用方式：$store\n{{$store.state.count}}  通过这种方式使得变量count显示在页面上\n {{$store.state.count}} \u0026lt;button @click=\u0026quot;countinc\u0026quot;\u0026gt;+\u0026lt;/button\u0026gt;   \u0026lt;script\u0026gt; export default{ methods:{ countinc(){ //注意$store是一个全局对象需要使用this来拿 return this.$store.dispatch('actioncrease') } } } \u0026lt;/script\u0026gt;  通过this来获取$store对象\n执行 npm run dev  异步实现自增 acioncrease 只需要添加并使用此方法\n //异步自增 asyncincrease({commit}){ setTimeout(()=\u0026gt;{ commit('mulincreases') },2000) }  两种取值方式  {{$xxx}}方式\n{{$store.state.count}}   数据来自store.js\u0026ndash;\u0026gt;getters\u0026ndash;\u0026gt;isAudlt(){\u0026hellip;}\n 方法取值\n \u0026lt;button @click=\u0026quot;countinc\u0026quot;\u0026gt;+\u0026lt;/button\u0026gt;   数据来自：store.js\u0026ndash;\u0026gt;actions\u0026ndash;\u0026gt;actincrease({commit}){}\n优化取值 直接使用isAudlt(){\u0026hellip;}和actincrease({commit}){}进行取值\nvuex中自带了两个对象\nimport {mapGetters,mapActions} from 'vuex'   mapGetters 可以获取getters中的方法 mapActions 可以获取Actions中的方法  如\ncomputed:mapGetters({ isAudlt : 'isAudlt'//将store.js中getters中的isAudlt()映射成isAudlt对象（前面的是属性，后面的是getters中的方法） })   methods:mapActions(['actioncrease','asyncincrease']),  使用\n{{isAudlt}} \u0026lt;button @click=\u0026quot;actioncrease\u0026quot;\u0026gt;同步+\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026quot;asyncincrease\u0026quot;\u0026gt;异步+\u0026lt;/button\u0026gt;  思路:\n以前需要通过$store获取store. js中的getter方法和actions方法现在可以直接通过mapGetters, mapActi ons获取store. js中的getter方法和actions方法\nvue-resource的使用 官网 相当于ajax、axios\n get(url, [config])\n post(url, [body], [config])\n  请求的方式config的作用，当表单发送请求时，需要加上{emulateJSON:true}，默认不加也行，但是为了防止某些特殊的情况建议还是加上。在前端，表单提交时一般加上:application/x-www.form-urlencoded，两者作用相似\nbody参数时传递的参数值；一般是采用对象的方式进行传参\nthis.$http.get(\u0026quot;请求地址\u0026quot;,{},{emulateJSON:true}).then(reponse=\u0026gt;{ consolg.log(resoonse); })   jsonp(url, [config])  支持跨域\n如果前台和后台的地址、端口、协议不一致(只要任何一个不一致)就称为跨域请求。为了安全，浏览器一般都禁止跨域请求\n解决：使用js技术替代了传统的http请求\n使用node.js搭建服务器\nconst http = require('http') const urlModule = require('url') //localhost:8080/myrequest?cb=myshow //localhost:8080/myrequest2 //创建服务 let server = http.createServer(); //servlet: doGet(request,resposne) server.on('request', function(req,res){ console.log('abcc') const { pathname ,query } = urlModule.parse( req.url ,true) if( pathname == '/myrequest'){ var data = { id : 1, name :\u0026quot;zs\u0026quot;, age :23 } //响应到哪里？ //localhost:8080/myrequest?cb=myshow //myshow(data) //data-\u0026gt;json //响应到：myshow方法，并响应的数据：data var result = `${query.cb}( ${JSON.stringify(data)} )` res.end(result) } }) server.listen(8888,function(){ console.log('sever running...') })  客户端\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;111\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026quot;./js/vue.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;./js/vue-resource.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; function myshow(data){ console.log(data) } \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;http://localhost:8888/myrequest?cb=myshow\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  客户端仅仅是引入了一个文件并没有发送请求\nPromise的使用 将嵌套方式变成链式写法\n读取多个文件的嵌套写法\nconst fs = require('fs') const path = require('path') //读取文件的内容 function myReadFile(fpath,frsuccess,frerror){ //读取文件时，如果由异常：err //数据正常保存data fs.readFile(fpath,\u0026quot;utf-8\u0026quot;,(err,data)=\u0026gt;{ if(err) return frerror(err) frsuccess(data) }) } //调用 js/file1.txt //先读取file1.txt，之后读取file2。txt //读取file1.txt--\u0026gt;成功之后读取--\u0026gt;file2.txt myReadFile(path.join(__dirname,'./file1.txt'),(data)=\u0026gt;{ console.log(data) myReadFile(path.join(__dirname,'./file2.txt'),(data)=\u0026gt;{ console.log(data) },(err)={}) },(err)=\u0026gt;{console.log(err.message)})  读取文件的链式写法\nconst fs = require('fs') const path = require('path') function myReadFile(fpath){ return new Promise((resolve,reject)=\u0026gt;{ fs.readFile(fpath,'utf-8',(err,data)=\u0026gt;{ if(err) return reject(err) resolve(data) }) }) } //调用 // ./代表根目录 myReadFile('./js/file1.txt').then((data)=\u0026gt;{ console.log(data) return myReadFile('./js/file2.txt') },(error)=\u0026gt;{ console.log(error) }).then((data)=\u0026gt;{ console.log(data) }).catch((e)=\u0026gt;{ console.log(e) })  .catch 可以统一处理错误\npromise的核心：return+then跳出递归\nvue组件 vue的三大组成部分\n\u0026lt;template\u0026gt; html(组件) \u0026lt;script\u0026gt; 存放js \u0026lt;style\u0026gt; 存放css  官网使用手册\n定义一个简单的组件 \u0026lt;html\u0026gt;\t\u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026quot;./js/vue.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;div id=\u0026quot;myvue\u0026quot;\u0026gt; \u0026lt;mycom\u0026gt;\u0026lt;/mycom\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component('mycom',{template:\u0026quot;\u0026lt;h1\u0026gt;这是我的组件\u0026lt;/h1\u0026gt;\u0026quot;}) new Vue({ el:'#myvue' }); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  注意：\n组件名不要使用驼峰命名法，如果使用，则使用该组件的时候使用-符号隔开\n组件定义方式\n 官网方式\n Vue.component('mycom',{template:\u0026quot;\u0026lt;h1\u0026gt;这是我的组件\u0026lt;/h1\u0026gt;\u0026quot;})  完整写法\n Vue.component('mycom',Vue.extend({template:\u0026quot;\u0026lt;h1\u0026gt;这是我的组件\u0026lt;/h1\u0026gt;\u0026quot;})  官网方式的id引用的方式\n\u0026lt;template id=\u0026quot;mytemp1\u0026quot;\u0026gt; \u0026lt;h1\u0026gt;这是我的组件\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; Vue.component('mycom',{template:\u0026quot;#mytemp1\u0026quot;})  完整方式的id引用方式\n\u0026lt;template id=\u0026quot;mytemp1\u0026quot;\u0026gt; \u0026lt;h1\u0026gt;这是我的组件\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; Vue.component('mycom',Vue.extend({template:\u0026quot;#mytemp1\u0026quot;})   注意：定义组件时template:\u0026quot;\u0026quot;的值和 \u0026lt;template\u0026gt;\u0026lt;/template\u0026gt;标签中的内容必须是标签，否则会出错\n这种方式定义的组件是全局组件，在所有的Vue对象中都可以使用。\n私有组件/局部组件:只能在选定的Vue对象中使用\nnew Vue({ el:'#myvue2', components:{ 'mycom1':{template:\u0026quot;\u0026lt;h1\u0026gt;这是我的组件\u0026lt;/h1\u0026gt;\u0026quot;} } });  其它的创建方式如上\n除了定义组件内容之外还可以在组件中定义数据，定义数据的方式如下：\ndata:function)(){ return { count:0 } }  注意：定义的数据必须是function，因为function中定义的变量是局部变量，为了防止多个组件之间共享数据，从而使得定义的组件的数据是独立的。\n特殊特性 is vue中自带一个标签\u0026lt;component\u0026gt;\u0026lt;/component\u0026gt;是一个组件标签，占位符\n\u0026lt;component :is=\u0026quot;'comp'\u0026quot;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;!-- 或 --\u0026gt; \u0026lt;component :is=\u0026quot;c\u0026quot;\u0026gt;\u0026lt;/component\u0026gt; data:{ c:'comp' }  一般vue:xx=xxx值一般是变量，而我们定义的组件名是一个常量，要想将一个常量值变成一个变量值，只需要添加''即可。而变量值是在data中定义的，如果不加''只需要在data中定义变量，其值为组件名即可。\n实现动态组件 只需要将:is绑定的值改变，就能实现动态组件。而:is中的值在data中定义，一次只需要改变data中变量的值即可。\n\u0026lt;span @click=\u0026quot;c='coma'\u0026quot;\u0026gt;切换A\u0026lt;/span\u0026gt; \u0026lt;span @click=\u0026quot;b()\u0026quot;\u0026gt;切换A\u0026lt;/span\u0026gt; methods:{ b(){ this.c=\u0026quot;comb\u0026quot; } }  注意：行内写法不需要加this,而函数写法需要加this\n什么时候加this  在Vue对象中除了data之外的所有区域使用data中的数据时，都需要使用this\n 在页面中使用{{}}取data中值是可加this也可不加this\n  一般结论：大多数的情况下，只要获取data中的变量的时候都需要使用this，除了个别特殊的情况，如：行内式写法、\n组件的过渡效果和参数传递的问题  将过度组件放入\u0026lt;transition\u0026gt;\u0026lt;/transition\u0026gt;标签中\n 编写样式在\u0026lt;style\u0026gt;\u0026lt;/style\u0026gt;标签中编写css样式\n\u0026lt;style\u0026gt; .v-enter, .v-leave-to{ opacity: 0 ; transform: translateX(100px) ; } .v-enter-active, .v-leave-active{ transition: all 1s ease ; } \u0026lt;/style\u0026gt;  \u0026lt;transition\u0026gt;的 mode=\u0026quot;out-in\u0026quot;属性可以设置出现的顺序，这样的话能避免重合。\n  传参 \u0026lt;coma :msg=\u0026quot;aname\u0026quot;\u0026gt;\u0026lt;/coma\u0026gt; Vue.component('coma', { template:\u0026quot; \u0026lt;p\u0026gt;这是我的组件A {{msg}}\u0026lt;/p\u0026gt;\u0026quot;, props: ['msg'] } ) data:{ aname :\u0026quot;你好，世界\u0026quot; }  :msg，msg是自己定义的属性名，他的值是一个变量aname,在data中定义。组件在使用msg属性的值的时候不能直接使用，需要借助props中转，然后进行使用。\n注意：组件中参数引用的位置一定要在标签中，否组Vue不认识它。\n组件的简化写法  公有组件\nvar comc = { template: '\u0026lt;p\u0026gt;这是组件C\u0026lt;/p\u0026gt;' } Vue.component('comc',comc) \u0026lt;comc\u0026gt;\u0026lt;/comc\u0026gt;  共有组件与Vue对象同级，在Vue对象的外面写\n 私有组件\nvar mycomc = { template: '\u0026lt;p\u0026gt;这是组件C\u0026lt;/p\u0026gt;' } components:{ 'mycomc': mycomc } \u0026lt;mycomc\u0026gt;\u0026lt;/mycomc\u0026gt;   注意:当组件名和变量名是同一个时可简化，只写组件名或变量民即可。\n例上面可以简化为：\ncomponents:{ mycomc }  小结：简化的核心就是使用var变量保存组件，然后通过引用变量实现自定义组件。\n调用组件内部的方法 普通的方法调用 \u0026lt;button @click=\u0026quot;aa()\u0026quot;\u0026gt;点击事件\u0026lt;/button\u0026gt; methods:{ aa(){ alert(\u0026quot;hahahah\u0026quot;) } }  调用的方法时vue中的methods中定义的方法\n定义的组件的方法的调用 组件常用的定义方式\n 定义组件内容\n\u0026lt;template id=\u0026quot;mytempid\u0026quot;\u0026gt; \u0026lt;button @click=\u0026quot;myclick\u0026quot;\u0026gt;方法调用\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt;  完善组件结构\nvar com = { template : '#mytempid' , data(){//局部变量 ,xx(){return {k:v}} return { comdata:{ num:1 } } }, methods:{ myclick(){ this.$emit('mycomclick',this.comdata.num) //myshow(a) } } }  注册到Vue中\n 公有组件\nVue.component('com',com)  私有组件\ncomponents:{ //com:com com } }   使用\n通过标签使用\n\u0026lt;com @mycomclick='myshow'\u0026gt;\u0026lt;/com\u0026gt;   组件中的单击事件调用的不是Vue中的Methods中定义的方法，而是组件中methods中定义的方法。\n调用组件内部按钮中的方法：单击\u0026ndash;\u0026gt;组件中的method\u0026ndash;\u0026gt;vue中的method\n小结：组件的单击事件\u0026lt;button @click=\u0026quot;myclick\u0026quot;\u0026gt;调用组件中的methods中定义的单击函数myclick;组件中定义的函数通过this.$emit触发组件自定义的事件 \u0026lt;com @mycomclick\u0026gt;, 组件的自定义事件调用Vue中定义的事件函数 myshow，从而实现事件的点击。\n核心思路：\n 普通的Html对象：直接调用Vue中的Methods中定义的函数\n 如果是组件，则调用组件中methods定义的方法，接着通过组件中的methods调用Vue中的methods\n 细节：组件中传递方法时： 发：自定义事件 收：$emit\n  当函数需要传参时this.$emit('mycomclick','hello') hello就是第一个参数，传多个参数时，通过,隔开\nthis所在位置\n当在组件中使用this时，代表当前组件，当需要使用data中的数据时需要通过this.comdata.xxx来获取变量\n当在Vue中使用this代表当前Vue对象，想要使用data中的数据时，需要使用this.xxx来获取变量。\nrefs 相当于jquery中的选择器\n在jquery中：\n定义 id=\u0026quot;myid\u0026quot; 使用 $(\u0026quot;#myid\u0026quot;)  在vue中：\n定义 ref=\u0026quot;myref\u0026quot; 使用 this.$refs.myref  \u0026lt;html\u0026gt;\t\u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026quot;./js/vue.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;div id=\u0026quot;myvue\u0026quot;\u0026gt; \u0026lt;!--普通元素--\u0026gt; \u0026lt;div ref=\u0026quot;mydiv\u0026quot;\u0026gt; 这是div元素... \u0026lt;/div\u0026gt; \u0026lt;!-- 组件--\u0026gt; \u0026lt;com ref=\u0026quot;mycom\u0026quot;\u0026gt;\u0026lt;/com\u0026gt; \u0026lt;button @click='myVueShow'\u0026gt;调用vue中的方法\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026quot;mytempid\u0026quot;\u0026gt; \u0026lt;div\u0026gt;普通组件...\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;\t\u0026lt;script\u0026gt; var com = { template : '#mytempid' , data(){ return { mymsg:'组件内部的数据' } }, methods:{ myComponentShow(){ alert('这是组件中的方法...') } } } const vm = new Vue({ el : \u0026quot;#myvue\u0026quot;, data:{ }, methods:{ myVueShow(){ //alert('myvueshow...'); //alert(this.$refs.mydiv.innerText) //获取组件中定义的mymsg数据 //alert(this.$refs.mycom.mymsg) //调用组件中定义的方法 this.$refs.mycom.myComponentShow() } }, components:{ //com:com com } } ); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  refs的作用：获取某个元素、组件，调用组件中的属性、方法、数据等信息\nrender函数 把组件模板(template)渲染成html（替换之前的内容）\n\u0026lt;html\u0026gt;\t\u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026quot;./js/vue.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;div id=\u0026quot;myvue\u0026quot;\u0026gt; \u0026lt;div\u0026gt; 这是div元素... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026quot;mytempid\u0026quot;\u0026gt; \u0026lt;span\u0026gt;普通组件...\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt;\t\u0026lt;script\u0026gt; var com = { template : '#mytempid' } const vm = new Vue({ el : \u0026quot;#myvue\u0026quot;, data:{ }, methods:{ }, render:function(createElements){ return createElements(com) //该方法的参数，就可以将组件渲染成html } } ); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt;  ","id":30,"section":"posts","summary":"vue介绍 vue是一个渐进式的JavaScript框架。渐进式：可插拔式、可扩展。 我们刚开始只需要使用最核心的核心库，后期可以自己去增加新库","tags":["前端框架"],"title":"Vue自学笔记","uri":"https://mumulx.github.io/2019/12/vue%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" git源码\n简介 SpringBoot官网\nSpringBoot是由Pivotal团队在2013年开始研发、2014年4月发布第一个版本的全新开源的轻量级框架。它基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。\n微服务 微服务：一个项目 可以由多个 小型服务构成（微服务）\n可更新可替代性比较强\nspring boot可以快速开发 微服务模块\n 简化j2ee开发 整个spring技术栈的整合（整合springmvc spring）\n 整个j2ee技术的整合（整合mybatis redis）  配置java环境变量  JAVA_HOME： jdk根目录 path:%JAVA_HOME%\\bin classpath:.%JAVA_HOME%\\lib%JAVA_HOME%\\lib\\tools.jar  配置maven环境变量  MAVEN_HOME： maven根目录 path: maven根目录\\bin 配置Maven本地仓库： mvn根目录/conf/setting.xml : \u0026lt;localRepository\u0026gt;C:/workplace/jar/mavenrep\u0026lt;/localRepository\u0026gt; 在STS中配置mvn：\nwindow-\u0026gt;preference-\u0026gt;搜maven ,installations/user settings   简单springboot项目  去官网生成springbootxiangmu官网\n STS 导入项目(Existing maven项目)\n 右键运行HelloWorldApplication.java \u0026ndash;run java application\n出现springboot和对应的版本号说明springboot配置好了\n  目录结构  java：java代码 resources/static:静态资源（js css 图片 音频 视频） resources/templates：模板文件（模版引擎freemarker ,thymeleaf；默认不支持jsp） resources/application.properties： 配置文件\nspringboot开发WEB程序  以前：webContext\u0026ndash;web.xml\u0026ndash;war\u0026ndash;tomcat\nspring boot内置了tomcat，并且不需要打成war再执行。\n@Controller public class HelloWorldController { //页面直接打印这些文字 @ResponseBody @RequestMapping(\u0026quot;helloWorld\u0026quot;) public String helloWorld() { return \u0026quot;hello world;hello spring boot\u0026quot;; } }  直接运行HelloWorldApplication.java \u0026ndash;run java\n访问\nhttp://localhost:8080/helloWorld  可以发现此时没有运行tomcat就能运行\n可以在appication.properties对端口号等服务端信息进行配置\nserver.port=8888  spring boot将各个应用/三方框架 设置成了一个个“场景”stater，以后要用哪个，只需要引入那个场景即可。 选完之后，spring boot就会将 该场景所需要的所有依赖 自动注入。\n官方starter介绍\n例如 选择 web,spring boot就会将web相关的依赖（tomcat json） 全部引入本项目\n版本仲裁中心\npom.xml中\n\u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt;  连续进入，就会发现里面配置了各个jar包的版本\n主配置类 HellowordApplication.java中含有注解\n@SpringBootApplication  spring boot的主配置类\n该注解包含了许多注解例：\n @SpringBootConfiguration\n包含@Configuration，表示\u0026rdquo;配置类\u0026rdquo;(用来代替配置文件):\n 该类是一个配置类 加了@Configuration注解的类，会自动纳入Spring 容器 （@Component）\n@Configuration public class A//表示A是一个 用于 配置的类 { }   @EnableAutoConfiguration\n使spring boot可以自动配置 ：（以前做spring，mybatis等项目时需要写很多配置文件，但是这里我们发现我们并没有写配置文件）约定优于配置（之前已经约定好了，所以没有进行配置）\n @AutoConfigurationPackage\n可以找到@SpringBootApplication所在类的包 ，\n作用：就会将该包及所有的子包 全部纳入spring容器\nspring boot自动配置自动将@SpringBootApplication所在类的包及其子包纳入spring容器中\n @Import(AutoConfigurationImportSelector.class\nAutoConfigurationImportSelector类中的selectImports方法在spring boot在启动时，会根据META-INF/spring.factories找到相应的三方依赖，并将这些依赖引入本项目\n   总结：\n编写项目时，一般会 对自己写的代码以及三方依赖 进行配置。但是spring boot可以自动进行配置：\n 自己写的代码\nspring boot通过@SpringBootConfiguration自动帮我们配置；\n 三方依赖\n通过spring-boot-autoconfigure-2.0.3.RELEASE.jar中的META-INF/spring.factories进行声明，然后通过@EnableAutoConfiguration开启使用即可\nspring-boot-autoconfigure-2.0.3.RELEASE.jar包中 包含了 J2EE整合体系中 需要的依赖。\n  如何自动装配 研究\norg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,  通过观察该源码 发现：\n@Configuration  标识此类是一个配置类 、将此类纳入springioc容器\n@EnableConfigurationProperties(HttpEncodingProperties.class)  通过HttpEncodingProperties将编码设置为了UTF_8 (即自动装配为UTF_8）\n如何修改改编码\n通过改HttpEncodingProperties的 predfix+属性名 进行修改 （配置文件中，yml/properties）\nspring.http.encoding.charset=ISO-8859-1  即：该注解给了默认编码utf8，并且提供了prefix+属性名 的方式 供我们修改编码。\n当满足以下条件（@Conditional）时才会被加载\n@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)  当它是一个servlet时成立\n@ConditionalOnClass(CharacterEncodingFilter.class)  当它有CharacterEncodingFilter这个类的时候成立\n@ConditionalOnProperty(prefix = \u0026quot;spring.http.encoding\u0026quot;, value = \u0026quot;enabled\u0026quot;, matchIfMissing = true)  当属性满足要求时，此条件成立 ：要求 ：如果没有配置spring.http.encoding.enabled=xxx, 则成立。\n总结：\n 每一个XxAutoConfiguration都有很多条件@ConditionalOnXxx，当这些条件都满足时，则此配置自动装配生效（utf-8）。\n但是我们可以手工修改改 自动装配：XxxProperties文件中的\nprefix.属性名=value   全局配置文件中的key， 来源于某个Properties文件中的 prefix+属性名\nSpringboot通过XxAutoConfiguration实现自动装配 ，修改默认值 XxxProperties（ prefix+属性名）\n  如何知道 spring boot开启了哪些自动装配、禁止了哪些自动装配：application.properties中添加\ndebug=true   Positive matches列表 表示 spring boot自动开启的装配 Negative matches列表 表示spring boot在此时 并没有启用的自动装配。  配置文件 作用：spring boot 自动配置(约定，8080 ).可以使用配置文件 对默认的配置 进行修改\n默认全局配置文件：\n application.properties\nk=v\n或行内写法(k： v，)\n application.yml\n yaml ain\u0026rsquo;t myarkup language ，不是一个标记文档   yaml：不是一个标记文档\nserver: port: 8882 path: /a/b/c  xml：是一个标记文档\n\u0026lt;server\u0026gt; \u0026lt;port\u0026gt;8882\u0026lt;/port\u0026gt; \u0026lt;path\u0026gt;/a/b/c\u0026lt;/path\u0026gt; \u0026lt;/server\u0026gt;  赋值 通过yaml给对象注入值： 注意： 1. k:空格v\n2. 通过垂直对齐 指定层次关系\n3. 默认可以不写引号； \u0026ldquo;\u0026ldquo;会将其中的转义符进行转义，其他不会\n行内写法\n[Set/List/数组] {map,对象类型的属性}  并且 []可省，{}不能省\n写法一：普通写法\nstudent: name: zs age: 23 sex: true birthday: 2019/02/02 location: province: 陕西1 city: 西安1 zone: 莲湖区1 hobbies: - 足球 - 篮球 skills: - 吃喝 - 玩乐 pet: nickname: wc strain: hsq  写法二：行内写法\nstudent: uname: x name: ${student.user.name2:无名} #age: 23 sex: true birthday: 2019/02/12 location: {province: 陕西,city: 西安, zone: 莲湖区} hobbies: [足球2,篮球22] skills: [编程3,金融33] pet: {nick-name: wc555,strain: hsq} email: 157468995@qq.com  public class Pet { private String nickname; private String strain; }  @Component @ConfigurationProperties(prefix = \u0026quot;student\u0026quot;) public class Student { private String name; private int age; private boolean sex; private Date birthday; private Map\u0026lt;String ,Object\u0026gt; location; private List\u0026lt;String\u0026gt; skills; private String[] hobbies; private Pet pet; }  @ConfigurationProperties(prefix=\u0026quot;student\u0026quot;)下面出现黄色警告时，单击add xxx，会在pom.xml中增加依赖（元数据的提示依赖）\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;  通过application.properties对属性进行赋值 student.name=ls student.age=23  yml与properties两种方式的赋值可以互补使用\n通过@Value赋值 在Student.java中使用@Value注解进行赋值\n@Value(\u0026quot;33\u0026quot;) private int age ;  此时不再需要使用@ConfigurationProperties(prefix=\u0026ldquo;student\u0026rdquo;)注解，该注解是在.yml和.properties文件中赋值时使用\n小结 @ConfigurationProperties(yml/properties[优先级高]) @Value(\u0026quot;xx\u0026quot;) 二者可以互补  ​\n   选项 @ConfigurationProperties) @Value     注值 批量注入 单个   松散语法 支持 不支持   SpEL 不支持 支持   JSR303数据校验 支持 不支持   注入复杂类型 支持 不支持    松散语法:驼峰命名法与xx-xx命名方式转换stuName--stu-name\nSpEL:LspringEL:\n@Value(\u0026quot;${student.uname}\u0026quot;) private String userName;  在文件中赋值，通过el语法取值\nJSR303数据校验\n@Component //将此Javabean @ConfigurationProperties(prefix=\u0026quot;student\u0026quot;) @Validated//开启jsr303数据校验的注解 public class Student { @Email private String email ; }  简单类型：(8个基本类型/String/Date)\n@PropertySource 默认会加载application.properties/application.yml文件中的数据；如果数据不在这两个文件时，需要借助它指定。\n例如\n@Component //将此Javabean @ConfigurationProperties(prefix=\u0026quot;student\u0026quot;) @PropertySource(value={\u0026quot;classpath:conf.yml\u0026quot;}) public class Student { @Value(\u0026quot;safasd\u0026quot;) }  通过注解@PropertySource(value={\u0026quot;classpath:conf.yml\u0026quot;})加载conf.properties文件中的数据；\n通过注解@PropertySource(value={\u0026quot;classpath:conf.yml\u0026quot;})加载conf.properties文件中的数据；\n但是，@PropertySource只能加载properties，不能加载yml\n@ImportResource spring boot自动装配/自动配置.\nspring等配置文件 默认会被spring boot自动给配置好。\n如果要自己编写spring等配置文件, spring boot能否识别？\n默认不识别。  如果需要识别，则需要在spring boot主配置类上 通过@ImportResource指定配置文件的路径\n@ImportResource(locations={\u0026quot;classpath:spring.xml\u0026quot;}) @SpringBootApplication public class HelloWorldApplication {}  但是不推荐手写spring配置文件。\n配置：xml配置文件，通过注解配置(推荐)。\nspring boot推荐时候用注解方式进行配置：写类，@Configuration @Bean，\n示例：\n//配置类（等价于spring.xml） @Configuration public class AppConfig { @Bean\tpublic StudentService stuService(){//\u0026lt;bean id=\u0026quot;xxxxxxxxxxxxx\u0026quot;\u0026gt; 方法名 StudentService stuService = new StudentService(); //\tStudentDao stuDao = new StudentDao() ; //\tstuService.setStudentDao(stuDao); return stuService;//返回值 \u0026lt;bean class=\u0026quot;xxxxxxxxxxxxx\u0026quot;\u0026gt; } }  spring boot全局配置文件中的 占位符表达式 $ {random.uuid}:uuid $ {random.value}:随机字符串 $ {random.int} :随机整型数 $ {random.long}:随机长整型数 $ {random.int(10)}:10以内的整型数 $ {random.int[1024,65536]}:指定随机数范围  引用变量值\n.properties文件中\nstudent.user.name=zs  .yml中引用\n${student.user.name} ${student.user.name:ls}可以指定默认值  两个文件中的值可以互相引用\napplication.properties中没有提示的话 在pom.xml中添加\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;  多环境的切换（profile） properties文件 默认spring boot会读取application.properties\n多个：\napplication-环境名.properties application-dev.properties application-test.properties  如果要选择某一个具体的环境： application.properties中指定：（环境名:dev,test）\nspring.profiles.active=环境名  如果将application.properties注释掉，spring boot仍然会读取其他appilcation-环境名.properties中的配置。并且properties的优先级高于yml\nyml 环境与环境之间通过\u0026mdash;隔开\n# 主环境 server: port: 8883 #指定环境 #spring: # profiles: # active: dev --- #环境一 server: port: 8884 spring: profiles: dev --- #环境二 server: port: 8885 spring: profiles: test  动态切换环境  通过运行参数指定环境\n STS(Eclipse) ：\n右键\u0026ndash;Run Configuration - Argument(Java Application中指定项目) - program Argument\n--spring.profiles.active=环境名   命令行方式：\n项目打jar包： 项目右键--\u0026gt;run as --\u0026gt;maven build...--\u0026gt; Goals:输入 package --\u0026gt;run--\u0026gt;在src同级目录target下会出现jar包 cmd到文件目录，执行 java -jar 项目名.jar --spring.profiles.active=环境名  通过jvm参数指定环境\nSTS(Eclipse) ：Run Configuration - Argument - VM arguments\n-Dspring.profiles.active=环境名   配置文件的位置 项目内部的配置文件： properties和yml中的配置，相互补充；如果冲突，则properties优先级高。\nspring boot默认能够读取的application.properties/application.yml，这2个文件 可以存在于以下4个地方：\n file:项目根目录/config\n file:项目根目录\n classpath:项目根目录/config\n classpath:项目根目录\n  注意:\n 如果某项配置冲突，则优先级从上往下 如果不冲突，则互补结合使用  配置项目名： properties文件中\nserver.servlet.context-path=/boot  项目外部的配置文件： (补救) 在项目Run configuration ,argumenets:\n--spring.config.location=D:/application.properties  如果 同一个配置 同时存在于 内部配置文件 和外部配置文件，则外部\u0026gt;内部\n命令行方式\n打包文件\nclean package  先清理后打包\ncmd到jar路径，通过命令行 调用外部配置文件\njava -jar xxx.jar --spring.config.location=D:/application.properties  项目运行参数 (补救)（配置与配置直接可以加空格隔开）\n在项目Run configuration ,argumenets:\n--server.port=8883  通过命令行修改配置参数\ncmd到jar包\njava -jar 项目.jar --server.port=8883  多个地方配置时，如果冲突，优先级：\n命令参数（调用外部的配置文件 \u0026gt; 运行参数 ）\u0026gt;内部文件 (properties\u0026gt;yaml)  官网对多配置时的顺序说明：\n日志 日志框架： UCL 、JUL 、jboss-logging、logback、log4j、log4j2、slf4j\u0026hellip;\nspring boot默认选用slf4j，logback，spring boot默认帮我们配置好了日志，我们直接使用即可。\n使用 Logger logger = LoggerFactory.getLogger(HelloWorldApplicationTests.class );//获取日志对象 @Test public void testLog(){//日志级别 logger.trace(\u0026quot;trace********\u0026quot;); logger.debug(\u0026quot;debug********\u0026quot;); logger.info(\u0026quot;info*******\u0026quot;); logger.warn(\u0026quot;warn******\u0026quot;); logger.error(\u0026quot;error****\u0026quot;); }  日志级别：（LogLevel类中） TRACE\u0026lt; DEBUG\u0026lt; INFO\u0026lt;WARN\u0026lt; ERROR\u0026lt; FATAL\u0026lt;OFF  springboot默认的日志级别是info（即只打印 info及之后级别的信息）；\n也可以自定义级别：全局配置文件中\nlogging.level.主配置类所在包=级别 logging.level.org.yq.HelloWorld=warn  日志存储 可以通过配置 将日志信息 存储到文件中\nlogging.file=springboot.log  存储到了项目的根目录中的springboot.log\n也可以指定 具体的日志路径：\nlogging.file=D:/springboot.log  也可以存储到一个 文件夹中 ，\nlogging.path=D:/log/  并且默认的文件名是spring.log\n指定日志显示格式：  日志显示在console中\nlogging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n  %d: 日期时间 %thread： 线程名 %-5level： 显示日志级别,-5表示从左显示5个字符宽度 %logger{50} : 设置日志长度 %msg： 日志消息 %n ： 回车  日志显示在文件中\nlogging.pattern.file=%d{yyyy-MM-dd} ** [%thread] ** %-5level ** %logger{50}** %msg%n   默认的日志格式，是在spring-boot.jar包中 相应包的xml文件中进行配置。 /org/springframework/boot/logging/\n日志的具体使用规范：官方说明\nspringboot开发Web项目 (静态资源 html css js )\n新建项目（sts） new \u0026ndash; spring starer Project \u0026ndash;设置（选择 需要的场景，web）\n静态资源存放路径 spring boot是一个jar，因此 静态资源就不是再存放到 webapps中，存放在哪里？\n静态资源的存放路径 通过WebMvcAutoConfiguration类-addResourceHandlers()指定为:/webjars/\nspring boot将静态资源存入到jar包中，引入:以后需要引入静态资源时只需要像maven那样去官网找到文件然后添加依赖即可\n\u0026lt;!--以前引入js等静态资源，是将这些资源下载并且手工放入到webapp目录中；而springboot将这些静态资源 直接以jar文件（maven）的形式引入项目--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.webjars\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jquery-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.12.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  webjars官网\n使用\n访问：从Jar目录结构的webjars开始写：http://localhost:8080/webjars/jquery/3.3.1-1/jquery.js\n将自定义静态资源放入项目 如何自己写 静态资源，如何放到如spring boot中？\n 将自己写的 静态资源-\u0026gt;jar,同上（不推荐）；\n 自定扫描方式（推荐）：\n  spring boot约定： spring boot将一些目录结构设置成静态资源存放目录，我们的静态资源直接放入这些目录即可，目录在哪里？\nResourceProperties类中的CLASSPATH_RESOURCE_LOCATIONS中设置：\n{ \u0026quot;classpath:/META-INF/resources/\u0026quot;, \u0026quot;classpath:/resources/\u0026quot;, \u0026quot;classpath:/static/\u0026quot;, \u0026quot;classpath:/public/\u0026quot; }  注意：在以上目录存放资源文件后，访问时 不需要加前缀，直接访问即可：http://localhost:8080/world.html\n设置欢迎页 WebMvcAutoConfiguration类中的welcomePageHandlerMapping() \u0026ndash;\u0026gt;getIndexHtml() \u0026ndash;\u0026gt; location + \u0026quot;index.html\u0026quot; ,即任意一个静态资源目录中的 index.html就是欢迎页\n网站中,网页标签的Logo是固定名字 ： favicon.ico\n自定义 favicon.ico 阅读 源码得知:只需要将 favicon.ico文件放入任意静态资源目录中即可。\n总结：\n 通过源码发现静态资源的目录 用静态资源：只需要将静态资源放入 以上目录即可 其他特定的文件（欢迎页、ico），只需要 根据约定（index.html favicon.ico） 放入该目录即可  自定义静态资源目录 如何自定义静态资源目录（Properties文件中的 prefix+属性） ：\nspring.resources.static-locations=classpath:/res/, classpath:/img/  以上就将静态资源目录设置为了classpath:/res/, classpath:/img/\n注意:自定义静态资源目录后 以前默认的目录会失效\n动态资源： JSP(spring boot默认不支持)\n推荐：模板引擎 thymeleaf\n网页= 模板+数据\n引入thymeleaf 到官网查询 thymeleaf的依赖官网\n使用thymeleaf thymeleaf官网\n代码在哪里写？\n查找自动装配jar包spring-boot-autoconfigure.jar，去里面查找响应的依赖找到XxProperties注解类，查看默认值\n今后查看默认值只需要查看\nXXXAutoCongifutation 、 XxProperties  通过ThymeleafProperties源码得知：\n使用thymeleaf只需要将 文件放入目录：\u0026quot;classpath:/templates/\u0026quot;; 文件的后缀： .html;\n使用 引入命名空间\n\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;  引入标签 \u0026lt;p th:text=\u0026quot;${welcome}\u0026quot;\u0026gt;Welcome to our grocery store!\u0026lt;/p\u0026gt;  控制器传值 @RequestMapping(\u0026quot;/welcome\u0026quot;) public String welcome(Map\u0026lt;String,Object\u0026gt; map) { map.put(\u0026quot;welcome\u0026quot;, \u0026quot;welcome--hahahhaha\u0026quot;); return \u0026quot;welcome\u0026quot;; }  以上，先从${welcome}中取值，如果有 则直接显示；如果没有，则在显示welcome to thymeleaf....\n注意：在以前传统的web项目中：静态资源修改后 是不需要重启的；但是在spring boot项目中，修改后 需要重启。\nth就是替换原有html的值：th:html属性名=值 ;\n\u0026lt;p id=\u0026quot;pid\u0026quot; class=\u0026quot;pclass\u0026quot; th:id=\u0026quot;${welcome}\u0026quot; th:class=\u0026quot;${welcome}\u0026quot; th:text=\u0026quot;${welcome}\u0026quot;\u0026gt;welcome to thymeleaf....\u0026lt;/p\u0026gt;  th:xx (参见第10章 Attrubite Pre....) th:text 获取文本值(不转义) 显示\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt; th:utext 获取文本值 显示 将hello 渲染为h1后的效果  符号\nth:text=\u0026quot;${welcome}\u0026quot;  除了$以外 其他符号？ 查看第四章 Standard Express\u0026hellip;.\n\u0026lt;div th:each=\u0026quot;prod : ${prods}\u0026quot;\u0026gt; \u0026lt;h4 th:text=\u0026quot;${prod.name}\u0026quot;\u0026gt;11\u0026lt;/h4\u0026gt; \u0026lt;h4 th:text=\u0026quot;${prod.price}\u0026quot;\u0026gt;11\u0026lt;/h4\u0026gt; \u0026lt;h4 th:text=\u0026quot;${prod.inStock}\u0026quot;\u0026gt;11\u0026lt;/h4\u0026gt; \u0026lt;/div\u0026gt;  @RequestMapping(\u0026quot;/welcome1\u0026quot;) public String welcome1(Map\u0026lt;String,Object\u0026gt; map) { List\u0026lt;Product\u0026gt; prods = new ArrayList\u0026lt;\u0026gt;(); prods.add(new Product(\u0026quot;a\u0026quot;,1000,100)); prods.add(new Product(\u0026quot;b\u0026quot;,1001,101)); prods.add(new Product(\u0026quot;c\u0026quot;,1002,102)); prods.add(new Product(\u0026quot;d\u0026quot;,1003,103)); map.put(\u0026quot;prods\u0026quot;, prods); return \u0026quot;welcome\u0026quot;; }  Spring boot整合JSP开发 之前spring boot默认 自带一个内置的tomcat，不需要打war包，直接通过Jar即可运行。但是，如果要整合jsp开发，就需要 单独配置一个 外置的tomcat ，需要打war包。\nSpring boot整合JSP开发步骤：  新建spring boot项目，war\n  注意：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-tomcat\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  provided：意思是 将项目打包时，不需要将内置的tomcat一起打包。\n 建立基本的web项目所需要的目录结构\nwebapps/WEB-INF(需要) webapps/WEB-INF/web.xml (不需要) webapps/index.jsp  创建tomcat实例、部署项目\n访问：\n域名：端口/项目名/文件名\nhttp://localhost:8080/SbJSP/index.jsp   分析：\n如果是一个war包的spring boot项目，在启动服务器tomcat时， 会自动调用ServletInitializer类中 的configure方法，configure方法会调用spring boot的主配置类 从而启动spring boot;\n即在启动tomcat服务器时 会\n 启动tomcat 启动spring boot  ","id":31,"section":"posts","summary":"git源码 简介 SpringBoot官网 SpringBoot是由Pivotal团队在2013年开始研发、2014年4月发布第一个版本的全新开源","tags":["Spring家族"],"title":"Springboot自学笔记","uri":"https://mumulx.github.io/2019/12/springboot%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" Express 简介 什么是Express express是一个基于node.js的极简、灵活的web开发框架。可以实现非常强大的web服务器功能。\nExpress的特点  可以设置中间件响应或过滤http请求。 可以使用路由实现动态网页，响应不同的http请求。 内置支持ejs模板(默认是jade模板)实现模板渲染生成html。  express-generator生成器 express-generator是express官方团队为开发者准备的一个快速生成工具，可以非常快速的生成一个基本的express开发框架。\nexpress的安装使用 安装express-generator生成器 cnpm install express -gd cnpm i -g express-generator //安装 完成后可以使用express命令，需要安装淘宝镜像 npm i -g express-generator//直接安装，较慢 ln -s /opt/node-v8.11.1-linux-x64/bin/express /usr/sbin/express ln -s /opt/node-v8.11.1-linux-x64/bin/express /usr/bin/express express --version  forever守护nodejs进程 （一直在线访问） 客户端可以正常启动应用，但是如果断开客户端连接，应用也就随之停止了。也就是说这样的启动方式没有给应用一个守护线程\nForever可以解决这个问题！Forever可以守护Node.js应用，客户端断开的情况下，应用也能正常工作\n 安装forever\ncd app cnpm install forever -g ln -s /opt/node-v8.11.1-linux-x64/bin/forever /usr/sbin/forever ln -s /opt/node-v8.11.1-linux-x64/bin/forever /usr/bin/forever  forever启动进程\ncd bin forever start www   注意:可能需要以管理员身份运行cmd\n创建项目 express xxx 项目名称//自动创建项目目录  安装依赖 cnpm install cnpm i//简写 npm install npm i//简写  开启项目 node app npm start//自动查找当前目录下的package.json文件 node ./bin/www  node app\n需要手动添加监听端口，打开app.js添加以下内容：\napp.listen(3000,function(){ console.log(\u0026quot;服务器已运行\u0026quot;); });  监听端口为:80\nnpm start：默认监听端口为:3000\n测试项目 打开浏览器输入localhost或127.0.0.1\n目录说明  bin 可执行文件目录 node_moudles 依赖包的目录 public 静态文件根目录  所有的静态文件都应该放在这个目录的下面(静态html,css,js,图片，字体，视频资源等)  routes 路由模块目录，动态文件的目录  优先找静态文件，如果没有静态存在则找动态路由，如果动态路由也没有就404  views 视图目录  用于存储所有的ejs模板   文件说明  app.js 项目的主文件  对整个项目的所有的字眼进行统筹的安排   var indexRouter = require('./routes/index');//引入处理根目录请求的路由 var usersRouter = require('./routes/users');//引进处理users目录请求的路由 app.use('/', indexRouter);//分配根目录下的请求给index去处理 app.use('/users', usersRouter);//分配users目录下的请求给users模块去处理 app.set('views', path.join(__dirname, 'views'));//设置模板的默认目录 app.set('view engine', 'ejs');//设置模板引擎为ejs模板 app.use(express.static(path.join(__dirname, 'public')));//设置静态文件目录   package.json 项目描述文件  生命项目的名称、版本、依赖包等信息   路由 什么是路由 路由是指接收用户请求，处理用户数据，返回结果给用户的一套程序。可以理解为：生成动态网页的程序。\n后端路由的核心: URL\nexpress对象自带有一个Router类，可以实例化出路由对象，可以在该对象上挂载非常多的路由节点。\n路由的写法 挂载路由线路的写法：\nrouter.请求方式('请求地址',function(req,res){ res.send('数据'); });  创建一个独立的路由模块 需求:创建一个vip路由模块，接收vip目录下的所有请求，响应数据。\n实现步骤：\n 创建一个vip路由模块\n 编写路由模块的代码(在Router文件夹下新建vip.js)\na. 引入express模块\nb. 实例化路由对象\nc. 编写路由线路挂载到路由对象上\nd. 暴露路由对象\n  代码：\nvar express = require('express');//引入express模块 var router = express.Router();//利用Router类创建一个路由的实例 //编写list.html用于展示所有的vip用户 router.get('/list.html', function(req, res, next){ res.send('\u0026lt;h1\u0026gt;张三，李四，王五\u0026lt;/h1\u0026gt;'); }); router.get('/info.html', function(req, res, next){ res.send('\u0026lt;h1\u0026gt;张三:23，李四:23，王五:24\u0026lt;/h1\u0026gt;'); }); module.exports = router;  注意:写请求路径news.html时不需要添加父路径/vip\n 将编写好的路由模块引入到主模块中，由主模块分配对应的请求到该模块中去处理(主模块为app.js)  代码\nvar appRouter = require('./routes/vip');//引入vip模块 app.use('/vip',appRouter);//分配vip目录下的请求给vip路由模块去处理  路由的区分 大路由(总路由) : app.js负责接收所有请求，对请求进行分配\n小路由(分路由) : /routes下面的所有路由模块，只负责处理自己能管理的目录下的所有请求\n响应对象 什么是响应对象 响应对象（res）是指服务器向容户端响应数据的对象，包含了所有要响应的内容\n响应对象的方法 res.send() //返回任意类型的数据 例：\nrouter.get('/',function(req,res){ //res.send('hello world'); //可以返回字符串数据 //var data={\u0026quot;name\u0026quot;:\u0026quot;李白\u0026quot;, \u0026quot;age\u0026quot;:999}; //res.send(data); // 也可以返回一个JSON数据 //res.send(1);//返回数字，即状态码 //res.send('1');//返回数字1 //返回状态码+数据链式调用 // res.status(404).send(\u0026quot;页面不见啦。。。。\u0026quot;); });  注意：\n 如果返回一个数字，就会被当成状态码，容易报错。 send方法能且仅能出现一次，重复无效且会报错，不写的话会挂起  res.json(); 返回JSON数据，自动设置相应头\n和send方法传递JSON数据的区别不大\n例\nrouter.get('/',function(req,res){ //var data={\u0026quot;name\u0026quot;:\u0026quot;李白\u0026quot;, \u0026quot;age\u0026quot;:999}; //res.json(data); // 返回json自动设置响应头 });  自己新建模板文件list.ejs 代码\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;用户列表\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;%for(var i in users){%\u0026gt; \u0026lt;li\u0026gt;姓名：\u0026lt;%=users[i].name%\u0026gt;====年龄:\u0026lt;%=users[i].age%\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;%}%\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  res.render(\u0026ldquo;模板名称\u0026rdquo;,{数据}); 读取模板文件，拼接数据（必须是json数据），自动将结果发送给浏览器\n模板名称直接写，路径在app.js文件中已经配置过了(即views目录下的文件)\n例\nrouter.get('/',function(req,res){ var data = [ {\u0026quot;name\u0026quot;:\u0026quot;aa\u0026quot;,\u0026quot;age\u0026quot;:\u0026quot;11\u0026quot;}, {\u0026quot;name\u0026quot;:\u0026quot;bb\u0026quot;,\u0026quot;age\u0026quot;:\u0026quot;22\u0026quot;}, {\u0026quot;name\u0026quot;:\u0026quot;cc\u0026quot;,\u0026quot;age\u0026quot;:\u0026quot;33\u0026quot;}, {\u0026quot;name\u0026quot;:\u0026quot;dd\u0026quot;,\u0026quot;age\u0026quot;:\u0026quot;44\u0026quot;} ]; //模板渲染 res.render('list.ejs',{users:data}); });  res.download 下载 res.download('./xxx.doc');//下载当前目录下面的xxx.doc文件。 res.download('./xxx doc, 'yyy.doc');//下载当前目录下面的xxx.doc文件，并且重命名为yyy.doc.  res.redirect(\u0026lsquo;目标\u0026rsquo;) 服务器端的跳转\nres.redirect('www.baidu.com');  完整api 1. res.app:同req.app一样 2. res.append():追加指定HTTP头 3. res.set()在res.append()后将重置之前设置的头 4. res.cookie (name,value[,option]) :设置Cookie opition:domain/expires/httpOnly/maxAge/path/secure/signed 5. res.clearCookie():清除Cookie 6. res.download():传送指定路径的文件 7. res.get():返回指定的HTTP头 8. res.json():传送JSON响应 9. res.jsonp():传送JSONP响应 10. res.location():只设置响应的Location HTTP头,不设置状态码或者closeresponse 11. res.redirect():设置响应的Location HTTP头，并且设置状态码302 12. res.send():传送HTTP响应 13. res.sendFile(path[,options][,fn]) :传送指定路的的文件-会自动根据文件extension 设定Content-Type 14.res.set():设置HTTP头，传入object可以一次设置多个头 15. res.status():设置HTTP的状态码 16. res.type():设置Content-type的MIME类型  请求对象 什么是请求对象 客户端向服务器发送数据的对象，包含请求头和请求主体\n接收GRT方式传的值 req.query.参数名  例\nrouter.get('/content.html',function(req,res){ var id=req.query.id; res.send('获取到的ID是:'+id); });  接收POST方式传的值 req.body.参数名\n例：\nrouter.post('/login.html',function(req,res){ var username=req.body.username; var pwd=req.bady.pwd; res .send('你传的用户名是:'+username+',你传的密码是:'+pwd); });  匹配URL网址上的数据 在接请求地方去匹配，再通过语法进行接收，\n语法：\nreq.params.参数名\n请求：\nlocalhost:/news/abc  例：\nrouter.get('/news/:id',function(req,res){ //自动匹配news/后的值作为id的值 var id=req.params.id; res. send('\u0026lt;h1\u0026gt;接收到的参数是: '+id+'\u0026lt;/h1\u0026gt;'); });  完整api 1. req.app:当callback为外部文件时，用req.app访问express的实例 2. req.baseUrl:获取路由当前安装的URL路径 3. req.body/req.cookies:获得「请求主体」/Cookies 4. reg.fresh/req.sale:判断请求是否还「新鲜」 5. req.hostname/req.ip:获取主机名和IP地址 6. req.originalUrl:获取原始请求URL 7. req.params:获取路由的parameters 8. req.path:获取请求路径 9. req.protocol:获取协议类型 10. req-query:获取URL的查询参数串 11. req.route:获取当前匹配的路由 12. req subdomains:获取子域名 13. req.accpets():检查请求的Accept头的请求类型 14. req.acceptsCharsets/req.acceptsEncodings/req.acceptsLanguages 15. req.get():获取指定的HTTP请求头 16. req.is():判断请求头Content-Type的MIME类型  中间件 Express是一个自身功能极简，完全是由路由和中间件构成一个的web开发框架:从本质上来说，一个Express应用就是在调用各种中间件。\n什么是中间件 中间件就是一个函数，位于客户端与路由之间，可以访问请求对象和响应对象，也可以调起下一个中间件。\n自定义中间件 app.use(function(req,res,next){ res.send('我是中间件'); //next(); });  尾函数next 如果在中间件不调用next函数，整个请求响应流程就中止不会再往后面执行。\n调用尾函数相当于调用下一个中间件，执行完以后自己的函数继续执行。\n例：编写一个记录用户访问的中间件\napp.use(function(req,res,next){ var fs=require('fs'); var ip=req.ip; var time=new Date().toLocaleString(); var data=fs.readFileSync('./2019-12-09.1og'); data+='访问时间:'+time+'IP: '+ip+'\\n'; fs.writeFileSync('./2019-12-09.1og',data); next();| });  ","id":32,"section":"posts","summary":"Express 简介 什么是Express express是一个基于node.js的极简、灵活的web开发框架。可以实现非常强大的web服务器功能。 Expre","tags":["node"],"title":"Express框架","uri":"https://mumulx.github.io/2019/12/express%E6%A1%86%E6%9E%B6/","year":"2019"},{"content":" 常见的操作  发布项目（share project）：项目组长将本机的项目第一次发布到中央仓库中\n 下载项目（check out）：（检出项目：check out），组员将中央仓库的项目第一次下载到本机\n 更新（update）：将服务器中的最新的代码，同步到本机 (服务器\u0026ndash;\u0026gt;本机)\n 提交（commit）：将本地修改的内容，同步到服务器中（本地\u0026ndash;\u0026gt;服务器）\n  注意：更新和提交一定要及时，即：\n提交：在编写完某一个小功能，每天下班前提交 更新：编写功能前，每天上班前更新 编写之前先更新，写完之后立刻提交  svn的安装配置 下载 下载地址\nwindow下载地址\n配置 环境变量配置：一般是自动配置，可以进入环境变量(Path)检验一下，如果没有配置的话，则将root/bin目录配置到环境变量。\n验证是否安装成功 win+r\ncmd\nsvn --version\n出现一下代码则安装成功\nsvn，版本 1.8.17 (r1770682) 编译于 Nov 30 2016，13:25:58 在 x86-microsoft-windows Copyright (C) 2016 The Apache Software Foundation. This software consists of contributions made by many people; see the NOTICE file for more information. Subversion is open source software, see http://subversion.apache.org/ 可使用以下的版本库访问模块: * ra_svn : 使用 svn 网络协议访问版本库的模块。 - 使用 Cyrus SASL 认证 - 处理“svn”方案 * ra_local : 访问本地磁盘的版本库模块。 - 处理“file”方案 * ra_serf : Module for accessing a repository via WebDAV protocol using serf. - using serf 1.3.9 - 处理“http”方案 - 处理“https”方案  配置中央仓库 中央仓库：保存项目的各个版本\n使用本地文件夹模拟中央仓库：\n svnadmin create 文件夹目录  例：\nsvnadmin createC:\\\\workplace\\\\svn\\\\svnck  注意：文件夹要为空\n启动svn服务 命令行方式(不推荐) svnserve -d -r 仓库目录  例\nsvnserve -d -r C:\\workplace\\svn\\svnck  注意：此时命令行窗口不能关闭，关闭之后服务就会终止\n注册系统方式(推荐) 在cmd中运行\n注意：cmd要以管理员身份运行\nsc create 服务名 binpath=\u0026quot;安装目录\\bin\\svnserve.exe --service -r 仓库位置\u0026quot; start=auto depend=Tcpip  例：\nsc create mysvn binpath=\u0026quot;C:\\RJ\\svn\\bin\\svnserve.exe --service -r C:\\workplace\\svn\\svnck\u0026quot; start=auto depend=Tcpip  出现以下代码则成功\n[SC] CreateService 成功  启动服务的两种方式 方式一(命令行)： 启动：sc start 服务名\n关闭：sc stop 服务名\n删除 sc delete 服务名\n方式二(服务列表)： 服务列表所在位置：开始-\u0026gt;windows管理工具-\u0026gt;服务\n访问项目 匿名访问 开启匿名访问 打开项目仓库的conf目录下的svnserve.conf文件找到\n# anon-access = read # anon-access = write # anon-access = none  三者者三选一，\n# anon-access = read 表示开启匿名访问后指允许读；\n# anon-access = write 表示开启匿名访问可读可写；\n# anon-access = none 表示什么也不能操作（一般选择）；\n注意：去掉#的时候把空格也要去掉，顶格写，否则可能会出错！\n授权访问 开启授权访问 打开项目仓库的conf目录下的svnserve.conf文件找到\n# auth-access = write # password-db = passwd # authz-db = authz  # password-db = passwd 表示授权人的用户名密码存放在passwd文件（授权文件）中。\n# authz-db = authz 表示授权访问的权限标识符，权限文件存放在authz中。\n注意：去掉#的时候把空格也要去掉，顶格写，否则可能会出错！\n编写用户文件 打开passwd文件（授权文件）在svnserve.conf文件的同级目录，在[users]下面添加用户名密码。采用键值对的形式用户名=密码。\n例如：\naa=123 bb=abc  编写授权文件 在[groups]下面创建分组\n例\ndev=aa,bb  对分组进行权限编写，例\n[/] @dev=rw *=  表示dev组的人员对项目根目录下的文件具有读和写的操作，其他人员没有权限。\n在Eclipse中使用SVN 默认eclipse是不支持svn的\n配置 离线方式 将eclipse_svn_site-1.10.5插件放入eclipse的安装目录的dropins子目录下，需要解压。\n在线方式 打开eclipse\u0026ndash;\u0026gt;help\u0026ndash;\u0026gt;Eclipse Marketplace 搜索：subversion/subeclipse，下载安装即可（可能比较慢）。\n检查 启动eclipse在项目中右键Team\u0026mdash;\u0026gt;Share Project会出现SVN选项。\n使用 发布项目 项目中右键Team\u0026mdash;\u0026gt;Share Project-\u0026gt;SVN\u0026ndash;\u0026gt;创建新的资源库位置\u0026ndash;\u0026gt;ur:svn://127.0.0.1\u0026ndash;\u0026gt;finish\u0026ndash;\u0026gt;右键项目\u0026ndash;\u0026gt;提交;\n需要输入用户名和密码，\n打开项目会发现代码后面有黄色的状态码\n黄色圆柱：本地无未提交代码 */灰色箭头：本地有未提交的代码 红色！：有冲突 蓝色箭头：服务端有最新代码，本地还没有更新  下载项目 file\u0026ndash;\u0026gt;import\u0026ndash;\u0026gt;从svn检出项目\u0026ndash;\u0026gt;next-\u0026gt;ur:svn://127.0.0.1\u0026ndash;\u0026gt;next\u0026ndash;\u0026gt;finsh\n提交代码 单个提交\n代码右键\u0026ndash;\u0026gt;team\u0026ndash;\u0026gt;提交\n多文件提交\n项目右键\u0026ndash;\u0026gt;Team\u0026ndash;\u0026gt;与资源库同步\u0026ndash;\u0026gt;ctrl选中多个文件\u0026ndash;\u0026gt;右键提交\n更新代码 单个文件\n代码右键\u0026ndash;\u0026gt;team\u0026ndash;\u0026gt;更新\n多个文件\n项目右键\u0026ndash;\u0026gt;Team\u0026ndash;\u0026gt;与资源库同步\u0026ndash;\u0026gt;ctrl选中多个文件\u0026ndash;\u0026gt;右键更新\n或\n右键项目\u0026ndash;\u0026gt;Team\u0026ndash;\u0026gt;更新\n注意：当提交项目或下载项目时，点击了保存密码，一但密码出错，很难更改密码，或更换用户；\n更改svn用户密码 进入C:\\Users\\当前用户\\AppData\\Roaming\\Subversion\\auth 删除文件夹中的所有文件即可重新填写用户，密码。\n解决冲突 一般更新或提交时会发现冲突\n右键项目\u0026ndash;\u0026gt;Team\u0026ndash;\u0026gt;与资源库同步\u0026ndash;\u0026gt;红色箭头表示冲突文件\n右键编辑冲突\u0026ndash;\u0026gt;修改\u0026ndash;\u0026gt;右键文件\u0026ndash;\u0026gt;team\u0026ndash;\u0026gt;标记为解决；重新提交。\n查看和恢复历史版本 右键\u0026ndash;\u0026gt;Team\u0026ndash;\u0026gt;显示资源历史记录\n查看版本：双击\n恢复所选版本:右键\u0026ndash;\u0026gt;获取内容\n注意：如果报错，则需要设置svnserve.conf 文件中的anon-access=none\nsvn发布到外网 第一种 当网段不在同一个网段上时，可以借助nat123将局域网ip映射到外网ip；通过访问外网ip来访问中央仓库。\n第二种 租赁服务器，将项目发布到服务器中\n第三种 使用svn托管的网站，\n","id":33,"section":"posts","summary":"常见的操作 发布项目（share project）：项目组长将本机的项目第一次发布到中央仓库中 下载项目（check out）：（检出项目：chec","tags":["版本控制"],"title":"Svn学习笔记","uri":"https://mumulx.github.io/2019/12/svn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" node.js简介 简单来说node.js就是js的一个运行环境，可以运行js代码，用于服务器端编程。\n下载安装 下载node.js\n安装：一路next\n环境变量会自动配置，不放心的话可以自己查看一下。\n验证：\n运行cmd：\nnode -v  node使用 进入项目目录运行cmd\nnode 文件名(.js)  .js可写可不写，因为node能且仅能运行js文件\n或 运行cmd\nnode  编写js代码\n模块组成 node.js提倡我们进行模块化编程\n所有用户编写的代码都放在模块中，模块就是文件(函数)\n用户编写的代码在nodejs运行时都会自动放在一个函数中，所以一个文件就是一个模块\n用户编写的代码都自动封装在一个函数中\nfunction(exports,require,module,_filename,_dirname){}  函数有五个参数:\nexports 暴露对象，可以将模块中的数据暴露给引入的地方 require 引入模块的函数， 用于在一个模块中引入另外一个模块，并且将子模块暴露的数据赋值给变量 module 模块对象， 包含了当前模块的所有信息 __filename 当前模块的文件 名 __dirname 当前模块所在的路径(目录路径〉  nodejs的模块是指所有用户编室的代码都放在函数中，所有定义的函数或变量都是局部的，相互之间不受影响。如果模块之间需要共享数据，则需要使用module.exports是暴漏对象。\nrequire : 作用:在当前模块中加载另外一个模块\n模块分类:\n 自定义模块\n我们自己编写的文件就是一个自定义模块\n注意：\n 子模块没有暴漏数据，返回空对象\n 自定义模块必须加./(指向当前模块)因为在node.js中查找模块默认在node_modules目录中去查找\n  第三方模块\n第三方程序员或公司开发的模块，先安装再使用\n安装可以使用npm包管理工具\nnpm install \u0026lt;包的名字\u0026gt;  引入 require(\u0026ldquo;模块名\u0026rdquo;)\n 系统模块\nnode.js开发团队已经开发好的功能模块，直接引入即可使用，不需要安装也不需要自己写\n例如：\nfs http url path \u0026hellip;.\n引入 require(\u0026ldquo;模块名\u0026rdquo;)\n  require函数的注意事项:\n1) 当引入的模块有语法错误时，会报错。 2) 当引入的模块路径有错时，也会报错。 3) 当一个模块被多次引入时，只执行一次,会将暴露对象直接写入缓存，以后就直接从缓存读取  exports导出对象: 作用:将模块中需要共享给其它模块的数据暴露(导出)到引用处\n语法:\nexports.属性名=值; exports .方法名=函数;  注意:\n1) exports 是module.exports对象的引用 2) exports 是module.exports的引用，不能改指向，只能添加属性和方法S 3) module.exports才是真正的暴漏对象，指向哪里就暴漏哪里  module模块对象: module.exports真正的暴露对象, exports对象只是对它的引用。\nmodule.exports.属性=值; module.exports.方法=函数; module.exports=对象或函数; module.id模块ID， 模块名称 module. parent模块的父级 module. filename模块的文 件名和路径 module.children子模块列表 module. paths模块查找路径，如果当前目录下找不到node_ modules就去上一级目录查找，直到根目录如果配置了NODE_ PATH环境变量， 则会再去环境变量指向的路径查找  控制合命令: console.1og() 普通输出语句 console.dir() 输出对象 console.errar() 警告输出 console.time(标识) 计时开始 console.timeEnd(标识) 计时结束 console.assert(表达式，输出文字) 当表达式为假时，输出文字  node. js的作用域: 由于node.js在执行里会将用户编写的所有代码都封装在函数中，所有用户定义的变量或函数都是局部的。\n要将数据共享给其它模块使用:\n1.暴露对象 module.exports 2.全局对象 global.工性或方法=值; 注意:使用时global关键字可以省略不写  npm 什么是NPM npm(Node Package Manager)是基 于nodejs的包管理工具\n一般node.js自带npm不需要自己在单独配置\n测试：打开cmd\nnpm -v  下载的文件存放的目录一般是node_modules\n什么是包 包===项目 模块===文件\n创建package.json npm init npm init -y //自动以全部为yes的形式生成package.json文件  package.json简介 package.json是node. js项目的包描述文件，以JSON格 式的形式描述项目\npackage.json的常用属性 name 项目名称 version 版本号 description 项目描述 main 主模块（入口文件） dependencies 依赖列表 devDependencies 开发时依赖 scripts 脚本命令， 可以使用npm命令进行执行 license 开源协议 contibutors 包的其他贡献者姓名。  npm的常用命令 安装命令\nnpm install \u0026lt;包的名称\u0026gt; //安装指定的包（package.json文件中指定的依赖dependencies） npm i //自动下载package.json中的依赖 npm i \u0026lt;包的名称\u0026gt; , //效果同上，缩写形式 npm i \u0026lt;包的名称\u0026gt;@版本号 //安装指定版本的包 npm i \u0026lt;包的名称\u0026gt; -g //全局安装 安装位置: C: \\Users \\Administrator\\AppData\\Roaming \\npm\\node_ modules 我的位置已修改C:\\Program Files\\nodejs\\node_global npm i \u0026lt;包的名称\u0026gt; --save //将安装包写入package .json依赖列表 npm i \u0026lt;包的名称\u0026gt; --save-dev //将安装包写入package .json开发时依赖列表 //其它命令 npm search \u0026lt;包的名称\u0026gt; , /搜索包 npm view \u0026lt;包的名称\u0026gt; //查看 包的信息 npm uninstall \u0026lt;包的名称\u0026gt; //卸载包 npm update \u0026lt;包的名称\u0026gt; 更新包  不使用-g只下载在当前目录，只有当前目录可用，使用-g是全局下载，下载到整个电脑，所有目录均可使用，以后在使用就不需要下载\n下载的版本号问题：\nexpress\u0026quot;: \u0026quot;^4.17. 1\u0026quot;\n 4.17.1:指定版本\n ~4.17.1:版本号\u0026gt;=4.17.1，^表示\u0026gt;=4.17.1，但是\u0026lt;4.18.x;即本次下载4.17.99\n4.17.1 4.17. 2 4.17.99 4.18.22  ^4. 17.1: 版本号\u0026gt;= 4.17.1，^表示\u0026gt;=4.17.1，但是\u0026lt;5.x.x,即本次下载4.19.23\n 4.17.1 4.17.2 4.17. 99 4.18.22 4.19.23 5.1.1  lastest:在所有范围内找最大的，即本次下载5.1.1\n 5.1.1 4.17. 1 4.17.2 4.17. 99 4.18.22 4.19.23   cnpm npm 就是一个文件下载工具，默认情况下去 npmjs.com/github. com下载资源\ncnpm 由于在国内下载npmjs. com的数据非常慢，所以淘宝制作了一个npmjs.com的镜像(可以下载，不能上传)，直接访问国内的网站下载较快用法和npm一毛一样。\n安装：\nnpm install -g cnpm --registry=https://registry.npm.taobao.org  之后下载的话就使用cnpm用法跟npm一样\n回调函数 什么是回调函数? 回调函数又称为回调，将a函数作为参数传入b函数中，b函数在执行过程中根据时机或条件决定是否调用a函数，a函数就是回调函数。\n异步的三种实现方式:\n1. 回调函数 回调函数不一定是异步，但是异步定有回调函数 2. 事件 3. promise  回调函数 //异步-定有回调函数\nsetTimeout(function(){ console.1og('....' ); }, 1000);  //回调函数不一定是异步\nconsole. log( '1111'); var arr=[1,2,3,4]; arr.forEach(function(v,i){ console.1og(v); }); console.1og('2222');  事件 事件源.on('事件名称',回调函数)  promise承诺对象:  什么是promise\npromise是ES6中新增的承诺对象，用于对异步的操作进行消息的传递。\n promise的状态\n Pending 等待中 Resolved 成功 Rejected 失败 Pending =\u0026gt; Resolved Pending =\u0026gt; Rejected  promise有什么用?\npromise可以用于传递异步消息\n  缓存区: 什么是缓存区 在内存中开辟-个临时区域用于存 储需要运算的字节码\n创建缓存区 创建指定长度的缓存区 var buf = new Buffer(5);  按指定的数组（编码）创建缓存区 var buf=new Buffer([97,98,99,65,66]);  按指定字符创建缓存区 var buf=new Buffer( '字符串' ) ;  写入缓存区 buf.write('字符串' );  读取缓存区 buf.toString();  缓存区复制 buf.copy(buf2);  文件系统操作 读取文件 由于node.js是服务器端程序，必须要有读写文件操作，在客户端没有这样的功能。\n文字读写有两种方式:\n直接读取 将硬盘上的所有内容全部读入内存以后才触发回调函数\n两种写法:\n异步:\nfs.readFile('./file1.txt',function(err.data){ console.log(data.toString()); });  同步:\nvar data = fs.readFileSync('./file.txt');  注意：一般同步的方法都是在异步的方法后面添加Sync\n流式读取 下面会专门讲。\n写文件: 同步版本  fs.writeFileSync('文件名','数据');  异步版本 fs.writeFile('文件名',数据,function(err){ //写完文件以后执行的代码 });  例\n//文件读取 //如果要读写文件，必须使用文件系统模块(fs) var fs=require('fs'); //直接读取文件---异步 fs.readFile('./file1.txt',function(err.data){ console.log(data.toString()); }); //同步 var data = fs.readFileSync('./file.txt'); console.log(data); console.log(data.toString()); //异步写文件 var hello=\u0026quot;\u0026lt;h1\u0026gt;Hel1o Node.js\u0026lt;/h1\u0026gt;\u0026quot;; fs.writeFile( 'index.html', hello,function(err){ if(err){ throw err; }else{ console.1og('文件写入成功'); } });  读取文件信息 fs.stat(' ./file1.txt',function(err,state){ console.log(state); });  属性解析\nsize 文件大小(字节) mtime 文件修改时间 birthtime 文件创建时间  方法解析\nisFile() 判断当前查看的对就是不是一个文件 isDirectory() 判断是不是一个目录  删除文件 fs.unlink('./jquery.js',function(err){ if(err){ throw err; }else{ console.log( '删除成功') ; });  例\n需求:编写代码实现删除一个非空目录\n使用代码删除某个文件夹，该文件夹不为空。\n使用递归函数实现，逐层查询并清空文件再删除空文件夹\n 定义一个函数，用于实现递归调用。\n 删除空文件夹(删不掉，目录非空)\n 读取文件夹的内容(文件及文件夹列表)\n 遍历数组一个一个获取文件信息\n 判断是否为文件，如果是文件则删除\n 判断是否为目录，如果是目录就调用自己(递归的入口)\n  代码\nfunction deldir(p){ //读取文件央的内容 var list=fs.readdirSync(p); //遍历数组 for(var i in list){ //list[i]是当前目录中每个文件及文件夹的名称 var path=p+'/'+list[i]; //拼接 一个从(05.js)当前目录能查找到的路径 var info=fs.statSync(path); if(info.isFile()){ fs.unlinkSync(path); //如果是文件则删除文件 }else{ arguments.callee(path);//如果不是文件就是目录，则调用自己再删除该目录 } } fs.rmdirSync(p); //删除空文件夹 } deldir('./aa');  文件流 什么是流 所有互联网传输的数据都是以流的方式，流是一组有起点有终点的数据传输方式\n流的操作 流式读取文件 一节一节的读取数据，一节64kb ==\u0026gt; 65536字节\n以流的方式写文件 一节一节的写文件\n例\n读入流\n//创建一个可以读取的流 var stream=fs.createReadStream('./file1.txt'); //绑定data事件，当读取到内容就执行 stream.on( 'data',function(a){ console.log('------------------'); console.log(a.length); }); //读取流的事件: end完成事件 stream.on('end',function(){ console.log('数据读完了'); }); //读取流出错事件: error错误事件 stream.on('error'，function(err){ console.log(\u0026quot;读取出错\u0026quot;); //抛出错误 //throw err; });  写入流\nvar fs=require('fs'); //创建一个可以写入的流 var stream=fs.createWriteStream('./file2.txt' ); //写入数据 stream.write('张三失踪了'); stream.write('李四也失踪了'); stream.write('王小五也疯了'); stream.end(); //以流的方式写入数据 必须显示的声明结束 //on是绑定时事件 //写入流的事件: finish 完成事件 stream.on('finish',function(){ console.log('写完了'); }); //写入流的事件: error 错误事件 stream.on('error',function(err){ console.log( '出错啦'); });  需求:实现大文件的复制\nvar fs=require('fs'); var s1=fs.createReadStream('./file3.txt'); var s2=fs.createWriteStream('./file6.txt'); //以流的方式 //以流的方式实现大文件复制，读取一节存一节 s1.on('data',function(a){ s2.write(a); }); s1.on('end',function(){ s2.end(); console.log(\u0026quot;文件复制已完成!\u0026quot;) ; }); //以管道的形式 s1.pipe(s2);  链式流:\n将多个管道连接起来，实现链式处理。\n需求:使用链式流实现大文件压缩!\n代码\nvar fs=require('fs'); var zlib=require('zlib'); var s1=fs.createReadStream('./file3.txt'); var s2=fs . createWriteStream('./file3.txt.zip'); s1.pipe(zlib.createGzip()).pipe(s2);|  path模块 什么是path模块? path模块是node.js中提供的一个系统模块，用于格式化或拼接一个完整的路径\npath模块的常用方法  path.join() //将多 个字符串拼接成一-个完整的路径 path.dirname() / /返回路径中的文件夹部分 path.basename() / /返回路径中的文件部分(文件名和扩展名) path.extname( ) / /返回路径中的扩展名部分 path.parse()/ / 解析路径:近回一个对象包含路径中的各个部分  URL模块: 什么是URL? url全球统一资源定位符， 对网站资源的一种简洁表达形式，也称为网址。\nURL 的构成 构成：\n协议://用户名:密码@主机名.名.城:端口号/目录名/文件名.扩展名?参数名=参数值\u0026amp;参数名2=参数值2#hash\nhttp协议的URL常见结构:\n协议://主机名.名.域/目录名/文件名.扩展名?参数名=参数值\u0026amp;参数名2=参数值2#hash\nhttps默认的端口号是443\nhttp默认的端口号是80\nnode. js的URL模块 在node.js中提供了两套对于url进行处理的API功能。\n 老的node.js url模块\n 新的url模块 (WHATWG URL标准模块》\n  什么是网络 网络是一个共享、传输信息的虚拟平台。\n什么是网络协议 每天有大量的数据在网络上传输，都需要遵循相应的规则，规则就是网络协议。\n什么是http协议 http (hypertext transfer protocol) 即超文本传输协议，传输超文本内容(文字、图片、视频、音频、动漫\u0026hellip;\nhttp协议规定了数据在服务器与浏览器之间传输数据的格式和过程。\nhttp协议规定 的细节 http协议是一种请求应答形式的协议，一次请求， 一次应答(响应)。\n细节: 1. 定义了浏览器以什么格式向服务器发请求， 2. 定义了服务器以什么格式解析浏览器发送过来的数据， 1. 定义了服务器以什么格式响应数据给浏览器， 1. 定义了浏览器以什么格式解析服务器响应的数据\n软件开发模式  单机软件\n打开电脑就能用，不需要网络，如: HBuilder、Word.西图\u0026hellip;.\n  2) C/S软件\n客户端Client /服务器端 Server 需要下载安装以后，才能连接网络使用，如:迅雷、QQ、微信....  3) B/S软件\n浏览器BrowEr /服务器端 Server 打开网址直接使用，不需要安装，如:百度、淘宝、JD....  注意：所有浏览器发起的请求都是get方式，post请求只能通过表单提交发起\nhttp模块:  get方法  get方法用于模仿客户端从服务器获取数据\nhttp.get('url',function(res){ //res是返回对象，接收到服务器响应的所有内容 });  网络爬虫程序 什么是爬虫? 网络爬虫又被称为网页蜘蛛或网络机器人，是一种按照一定的规则， 自动地抓取万维网信息的程序。\n案例：写一个爬虫程序从nipic. com批量下载图片 url: http://www. nipic. com/ photo/jianzhu/ shinei/index. html\n开发思路:\n1)打开网页查看内容，找图片地址 找规律=\u0026gt;查看网页源代码 小图: http://img90.nipic. com/file/20180110/5792316151721347529 1.jpg 大图: http://pic152.nipic. com/fne/20180110/5792316_ _151721347529_ _2.jpg 2)编写代码实现打开网页，获取所有的html内容 3)通过正则表达式提取出有哪些图片地址 4)遍历图片地址数组，一个一个请求 5)将获取到的图片数据保存在硬盘上  代码：\nvar http=require('http'); http.get('http://www.nipic.com/photo/jianzhu/shinei/index.html',function(res){ var data=''; //定义一个变量用于存放一段一段的HTML数据 //以流的方式读取数据 res.on('data',function(a){ data+=a. toString(); }; //绑定end事件 res.on('end',function(){ //data 就是当前网页的HTML内容 //编写正则表达式提取所有的图片地址 var reg=/\u0026lt;img src=\u0026quot;(.+?)\u0026quot; alt=\u0026quot;.*?\u0026quot;\\/\u0026gt;/img; //exec正则表达式方法，获取匹配到的结果，只能获取一个，指针自动向下移动 var arr =[]; var result=\u0026quot;\u0026quot;; while(result= reg.exec(data)){ arr.push(result[1]); } for(var i in arr){ (function(i){ setTimeout(function(){ getImg(arr[i]); },3000*i); })(i); } }); }); //定义一个函数用于获取图片内容 function getImg(ur1){ //console.log('修改前: ' ,ur1); ur1=ur1.replace(/img\\d\\d/,'pic152').replace('1.jpg','2.jpg'); //console.log('修改后:',url); http.get(ur1, function(res){ var fn=new Date().getTime(); //创建一个可写流 var stream=fs.createwriteStream('./files/'+fn+'.jpg'); res.pipe(stream); });\t}  小结 回调函数 什么是回调函数? 回调函数也称为回调(callback)，其实就是一个普通函数。将该函数作为另外一个函数的参数传入，由另外一个函数根据条件或时机决定调用\n回调函数的实现机制  定义一个普通函数(作为回调函数)\n 将该函数作为一个参数传入另外一个函数(调用者)中\n 调用者函数在具体的时机或条件达到时，调用该函数(回过头再调用的函数)\n  回调函数的作用 如果我们需要在某一个任务完成后，执行一段代码，可以使用回调函数\n异步与同步[重点] 什么是异步与同步? 同步:前一个任务完成以后，后一个任务才能继续执行(会造成阻塞)\n异步:将比较复杂的任务制作成异步模式(回调函数)，后一句代码不需要等待前一.句完成也可以继续执行(不会造成阻塞)\n异步的实现  回调函数 异步一定有回调函数，回调函数不一定是异步(一些同步的情况也会用到回调函数) 事件 触发事件以后执行一个回调函数，就是异步 事件源.on(事件类型,回调函数) ; promise promise (承诺)对象，实现异步的消息传递。  buffer缓存区 什么是缓存区? 缓存区就是在内存中开辟存储空间，用于存储字节码数据。\n缓存区操作 1.创建新的缓存区\nvar buf=new Buffer(10); var buf=new Buffer([97,98]); var buf=new Buffer('张三 ');  1.读取缓存区\nbuf.toString(); //将字节码转换成字符串  1.写缓存区\nbuf.write(\u0026quot;字符串\u0026quot;);  1.复制缓存区\nbuf1. copy(buf2);  文件基本操作(直接操作) 读取文件内容 //异步出错时自己定义抛出异常系统不会报错 fs. readFile('文件路径'，function(err, data){ //err是错误对象，如果有错则有值，没有错则为nu1l //data是数据(字符串) }); //同步:只要在异步的方法名后面加Sync就是同步版本 //出错时系统会自动报错 var data=fs.readFileSync( '文件路径);  读取文件信息 fs.stat('文件路径'，function(err, info){ //info就是文件的信息 .size文件的大小 .ctime文件的创建时间 .mtime文件的修改时间 .atime文件的访问时间 .birthtime文件的创建时间 //方法 .isFile()判断是不是 一个文件 .isDirectory()判断是不是一一个目录  写文件内容(新增、修改) fs .writeFile('文件路径'，数据内容，function(err){ //如果文件存在则修改 //如果文件不存在则新增 });  删除文件 fs.unlink('文件路径',function(err){ });  新增目录 fs.mkdir('目录路径',function(err,list){ //list是读取到的当前文件夹的所有文件及其子文件夹列表 });  读取目录中的文件列表 fs. readdir('目录路径', function(){ });  删除空文件夹 fs . rmdir('目录路径', function(err){ //只能删除空文件夹，不能删除非空文件夹 });  其它操作 改支件名或目录名...  流式读写 什么是流 流是一组有序的、有起点和终点的字节数据的传输方式(流式)。流的内容称为字节流。\n读取流 var stream=fs.createReadStream('文件路径'); //绑定data事件接收数据 stream. on('data',function(data){ console.1og(data); }); //绑定error错误事件 异步的方式 stream.on('error'function(err){ throw err; }); //绑定end结束事件 stream.on('end',function(){ console.log( '数据读取完毕'); });  写入流 var stream=fs.createWriteStream('文件路径'); //写入数据 stream.write('数据1'); stream.write('数据2'); stream.write('数据3'); stream.end(); //流式写入完毕时一 定要-个明确的结束标识 //绑定finish数据写入完成事件 stream. on('finish'，function(){ }); //绑定error出错事件 stream. on('error'，function(err){ });  管道pipe 什么是管道 管道(pipe)是一种输入流与输出流之间传输数据的机制\n管道的写法 输出流.pipe(输入流);  管道的作用 管道可以实现对大文件的操作(文件大小超过内存)\n链式流 将多个管道连接起来，进行链式操作。\n输出流.pipe(中转流). pipe(中转流).pipe(....). pipe(输出渝) ;  远程服务器(使用的是阿里云) 使用window的远程桌面命令:mstsc: 连接远程服务器，操作服务器。\n注意在网页的后面添加robots.txt就可以看到网站（例如：淘宝）的蜘蛛协议，它可以说明此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。\nnode.js服务器创建步骤  引入通信模块 创建服务器 监听request事件 监听端口 访问服务器:\n 打开浏览器 输入网址\n 127.0.0.1 本机地址\n localhost 本地主机，本地域名\n 172.16.3.224 局域网工IP(使用cmd命令行获取ipconfig)\n    例：\nvar http=require('http'); //创建服务器 var server=http.createServer(); //监听request请求事件， 当前请求事件发生时就返回数据 server.on('request',function(req,res){ //都是以流的方式来传送请求 //req: 请求对象，包含了所有客户端请求的数据，请求头、请求主体 //res:响应对象，包含了所有服务器端发送给客户端的数据，响应头、响应主体 res .write('\u0026lt;h1\u0026gt;He11o Node.js\u0026lt;/h1\u0026gt;'); res .write('\u0026lt;p\u0026gt;He1lo 1111\u0026lt;/p\u0026gt;'); res. end(); }); //监听服务器的80端口（默认的就是80，所以访问时不需要加端口号） //可以监听其他端口，但是访问时需要加端口号 server.listen(80, function(){ console.log( '服务器已运行...'); });  //组合写法 require('http').createServer(function(req,res){ res .write('\u0026lt;h1\u0026gt;He1lo world\u0026lt;/h1\u0026gt;'); res.end() ; }).listen(80,function(){ console.log( '服务器已运行...'); });  注意：可能需要的cmd命令\n//查看自己的电脑开了哪些端口 //netstat -a //查看端口被谁占用 //netstat -ab  服务器url 网页响应内容:\n可以根据用户请求的url不同，判断响应不同的数据，实现访问不同的URL得到不同的结果。 核心: req.ur1获取到用户请求的网址\n例\nvar http=require('http'); var server=http.createServer(); server.on('request',function(req,res){ if(req.url==='/'){ res.write(\u0026quot;\u0026lt;h1\u0026gt;HomePage\u0026lt;/h1\u0026gt;\u0026quot;) } if(req.url==='/article.html'){ res.write(\u0026quot;\u0026lt;h1\u0026gt;article.html\u0026lt;/h1\u0026gt;\u0026quot;) } if(req.url==='/about.html'){ res.write(\u0026quot;\u0026lt;h1\u0026gt;about.html\u0026lt;/h1\u0026gt;\u0026quot;) } res.end(); }); server.listen(80, function(){ console.log( '服务器已运行...'); });  http状态码 什么是状态码 http协议规定的服务器响应数据时的状态编码，就是状态码\n常用的状态码 1xx :表示普通消息，没有特殊含义 2xx :表示服务器响应成功 200 成功 3xx :表示重定向 301 永久重定向 302 临时重定向 304 使用缓存(服务器没有更新过) 4xx :无法访问 403 权限不足， 无法访问 404 资源找不到 5xx :服务器有错 500 服务器端代码有错 502 网关错误 503 服务器已崩溃  状态码的使用 res .writeHead(状态码,响应头对象);  例\nvar http=require('http'); var server=http.createServer(); server.on('request',function(req,res){ res.writeHead(200,{\u0026quot;Content-type\u0026quot;:\u0026quot;text/html;charset=utf-8\u0026quot;}); res.write(\u0026quot;\u0026lt;h1\u0026gt;中文乱码解决\u0026lt;/h1\u0026gt;\u0026quot;) res.end(); }); server.listen(80, function(){ console.log( '服务器已运行...'); });  响应头 Content-Type 响应的文件类型 text/html 注意:未指定响应文件类型时，默认就是html,编码默认是系统编码 Content-Length 响应内容的长度 Access -Control-Allow-Origin 设置响应头可以跨域  例\nvar http=require('http'); var server=http.createServer(); server.on('request',function(req,res){ res.writeHead(200,{ \u0026quot;Content-type\u0026quot;:\u0026quot;text/html;charset=utf-8\u0026quot;, \u0026quot;Content-Length\u0026quot;:24 //\u0026quot;Access-Control-Allow-Origin\u0026quot;:\u0026quot;*\u0026quot;//实现跨域 }); res.write(\u0026quot;\u0026lt;h1\u0026gt;中文乱码解决\u0026lt;/h1\u0026gt;\u0026quot;) res.end(); }); server.listen(80, function(){ console.log( '服务器已运行...'); });  MIME类型: 什么是MIME类型 MIME类型可以认为是文件类型的表述\n常用的MIME类型 .txt text/plain .html text/html . CSS text/css .js text/javascript .png image/png .jpg image/jpeg .gif image/gif .json text/json application/json .mp3 dio/mpeg .mp4 video/mpeg .pdf application/pdf .xml text/xm1 .zip application/x-gzip  例\n\u0026quot;Content-Type:\u0026quot;text/html; charset=utf-8\u0026quot;, / /生成一个html网页 \u0026quot;Content-Type\u0026quot;:\u0026quot;text/plain; charset=utf-8\u0026quot;, //生成一个普通文本 \u0026quot;Content-Type\u0026quot;:\u0026quot;inage/png\u0026quot;, //生成一个普通文本 \u0026quot;Content- Type\u0026quot;:\u0026quot;application/x-gzip\u0026quot;, //生成一个压缩包， 浏览器自动下载  静态网页资源服务器实例 node.js静态网页服务器实例\n客户端向服务器传递数据:  GET方式\n 在URL后面添加?写键值对形式就是GET方式传数据 只要可以写url的地方就可以在后面加?传参数 在node.js可以接收到客户端传过来的参数值。  POST方式\n post方式提交数据只能使用表单提交的方式   实例\n接收Get方式传值\n方式一\nvar http=require('http'); var server=http.createServer(); server.on('request',function(req,res){ //Get方式 //通过解析req.url后面参数字符串的解析分析出传递的参数的值 var query = req.url.split(\u0026quot;?\u0026quot;); var value = query[1].split(\u0026quot;=\u0026quot;); res.writeHead(200,{\u0026quot;content-type\u0026quot;:\u0026quot;text/html;charset=utf-8\u0026quot;}); res.write(\u0026quot;\u0026lt;h1\u0026gt;你传递的参数的值是\u0026quot;+value[1]+\u0026quot;\u0026lt;/h1\u0026gt;\u0026quot;) res.end(); }); server.listen(80, function(){ console.log( '服务器已运行...'); });  方式二\nvar http = require(\u0026quot;http\u0026quot;); var http = require(\u0026quot;url\u0026quot;); var serve = http.createServe(function(req,res){ //传参lohost://9999?a=b\u0026amp;c=d var params = url.parse(req.url,true).query; //类型转换为字符串 res.write(params.a+\u0026quot; \u0026quot;); res.write(params.c+\u0026quot; \u0026quot;); res.write(\u0026quot;\u0026lt;p\u0026gt;hello World\u0026lt;/p\u0026gt;\u0026quot;); res.end(\u0026quot;end...\u0026quot;); }); serve.listen(9999,function(){ console.log(\u0026quot;serve is runing...\u0026quot;); });  接收Post方式传值\nvar http=require('http'); var server=http.createServer(); server.on('request',function(req,res){ //判断请求 if(req. ur1==='/action.html'){ //从req请求主体中获取到POST方式提交的数据 var query='';//存储结果 //post请求会触发data事件 req.on('data',function(a){ query+=a.toString(); }); //请求结束会触发end事件 req.on('end'，function(){ res.writeHead(200, {\u0026quot;Content - Type\u0026quot;: \u0026quot;text/html; charset=utf-8\u0026quot;}); res.write('\u0026lt;h1\u0026gt;我们已经收到了请求\u0026lt;/h1\u0026gt;'); res.write(' \u0026lt;h1\u0026gt;接收到的数据是:'+query+*\u0026lt;/h1\u0026gt;' ); res.end( ); }); return; } server.listen(80, function(){ console.log( '服务器已运行...'); });  模板 使用动态网页模板:\n什么是模板\n将一些固定的结构或表现直接以静态文件形式存储，将需要表现成动态数据的地方使用模板语法进行编写，再使用模板引擎读取该静态文件，将动态的数据进行替换进去。最终实现产生出一个动态的网页\n小结 path模块 path模块主要用于对路径进行处理(解析、拼接、格式化等)\npath.join(字符串,字符串2); //将字符串拼 接成一个完整的路径 path.parse(路径); //将路径解析成为各个不同的部分，返回一个对象  url模块 什么是URL url是全球统一资源定位符，也称为网址\nURL的格式  完整的格式\n协议://用户名:密码@主机名.名.域:端口号/路径/文件名.扩展名?参数名=参数值\u0026amp;参数名2=参数值2#hash地址\n 常见的格式\n协议://主机名.名.域:端口号/路径/文件名。扩展名?参数名=参数值#hash地址\n  url模块 在node.js中提供了url模块，用于解析ur1中的各个部分，有两套API功能:\n//传统的node. js的ur1解析 var obj=url.parse(网址); //按WHATWG标准进行解析 var obj=new url . URL (网址);  http协议 什么是http协议 http协议就是超文本传输协议，主要用于规定客户端与服务器端进行数据传输的过程及格式。\nhttp协议以请求、应答形式进行数据交互，必须一次请求对应一次应答(响应)。\nhttp协议的细节 规定了客户端如何向服务器发送数据\n规定了服务器如何向客户端发送数据\n发送过程 客户端向服务器端发送数据称为请求，包含请求头和请求主体;\n服务器端向客户端发送数据称为响应，包含响应头和响应主体;\nhttp模块 什么是http模块 http模块是node. js中的系统模块，用于进行网络通信(服务器、客户端)\n.get()方法 用于获取其它服务器的数据(可以跨域)\n语法:\nhttp. get(url, function(响应对象){ 响应对象.on('data',function(){ }); });  http协议及工作原理 在浏览器中输入网址，回车时，将网址发送到指定的DNS服务器去查询对应的IP地址。\n浏览器获取到IP地址以后，向该IP的服务器发起请求，服务器收到请求，并且读取请求的网页文件，发送给客户端浏览器,浏览器可以直接解析执行html代码将内容渲染出来显示给用户\n如果服务器硬盘中没有该文件，就执行动态程序生成一个(使用node.js引擎读写数据库)生成html网页在发送给浏览器。\n编写网络蜘蛛抓职itsource . cn首页的所有图片 var http=require('http'); var fs=require('fs'); //获取itsource. cn首页的html内容 http. get( 'http://www.itsource.cn/',function(res){ varstr=''; res. on('data',function(a){ str+=a; }); res.on('end',function(){ //fs.writeFileSync('./itsource.html',str); var reg = /url\\((\\/upload.*?)\\)/; var arr,result=[]; while(arr=reg.exec(str)){ result.push(arr[1]); } }); });  ","id":34,"section":"posts","summary":"node.js简介 简单来说node.js就是js的一个运行环境，可以运行js代码，用于服务器端编程。 下载安装 下载node.js 安装：一路ne","tags":["node"],"title":"Node.js学习笔记","uri":"https://mumulx.github.io/2019/12/node/","year":"2019"},{"content":" 关于解决Eclipse导入SpringBoot项目jar包从Maven中下载太慢的问题 只需要在maven安装目录./config/settings.xml中插入下列代码,配置阿里镜像就可以了！\n\u0026lt;mirrors\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;nexus-aliyun\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;Nexus aliyun\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://maven.aliyun.com/nexus/content/groups/public\u0026lt;/url\u0026gt;; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; shshsh  ","id":35,"section":"posts","summary":"关于解决Eclipse导入SpringBoot项目jar包从Maven中下载太慢的问题 只需要在maven安装目录./config/setti","tags":["其他问题"],"title":"Eclipse导入springBoot项目jar包下载太慢的问题","uri":"https://mumulx.github.io/2019/11/eclipse%E5%AF%BC%E5%85%A5springboot/","year":"2019"},{"content":" Git简介 git lab指令\n启动\ngitlab-ctl start  关闭\ngitlab-ctl stop  关闭防火墙\nsystemctl stop firewalld  开启防火墙\nsystemctl start firewalld  Git指令 git init 项目初始化 git status 查看当前状态 git log 查看日志 git log -2 查看最近两次的提交 git log --pretty=oneline 一行 git log --pretty=format:\u0026quot;%h - %an ,%ar : %s\u0026quot; 指定格式 shal值前面的一部分- 作者 ，什么时候提交：提交注释 git add . git commit -m \u0026quot;xx\u0026quot; git push git add remote origin xxx git push origin master git config 查看帮助指令  \u0026emsp;Git是一个分布式版本控制系统。版本控制系统又分为：集群式版本控制系统(常见的有cvs、svn)、分布式版本控制系统(常见的有Git)。Git的官网是 Git，Git起源于Linus系统，因为BitMover公司不再向Linux社区提供BitKeeper软件免费的软件授权，因此有一些Linux大神创建了Git分布式版本控制系统，并且上传了Linux系统的源码。Git是以全量的方式管理版本即每一个版本都包含全部的文件，可以时刻保持数据的完整性。\ngit优势：\n 本地版本控制\n 重写提交说明\n 可以“后悔”\n 分支系统  svn:增量\ngit:全量(每一个版本都包含全部的文件,时刻保持数据的完整性)\nGit内部具有三种状态：  已修改(modified)：表示数据文件已经被修改，但未被保存到Git数据库中。 已暂存(staged)：表示数据文件已经被修改，并会在下次提交时提交到Git数据库中。 已提交(committed)：表示数据文件已经顺利提交到Git数据库中。  三个区 \u0026emsp;Git在管理项目时，文件流转的三个工作区域是：工作区域-\u0026gt;暂存区域-\u0026gt;对象区域。因此，基本的Git工作流程如下：在本地的工作目录对文件进行写操作；然后对修改后的文件进行add（处于 modified 状态），保存到暂存区域(处于 stage 状态)；最后提交更新(处于 commited 状态)，将保存在暂存区域中的文件版本永久转存到Git的本地仓库中。关于Git的安装和环境的配置，这里就不多说了，本篇主要是记录，自学过程中的知识点。\n 工作区 暂存区 对象区  工作区\u0026ndash;\u0026gt;暂存区\ngit add . 将当前目录的所有文件都进行提交 gir add xxx 指提交指定的文件  暂存区-\u0026gt;工作区\ngit rm --cached xxx git teset head xxx  暂存区\u0026ndash;\u0026gt;对象区\ngit commit -m \u0026quot;xxx\u0026quot; xxx为本次提交的注解  对象区\u0026ndash;\u0026gt;服务器\ngit push  对象区\u0026ndash;\u0026gt;工作区\n文件的内容被修改  撤销修改\n如果某个文件已提交，并且对其进行了修改。可以放弃修改（还原到已提交的状态）\ngit checkout -- xxx 放弃工作区中的修改  合并add 和commit：\ngit commit -am '注释' 第一次不能使用，以后可以使用  删除文件  git 删除\ngit rm xxx\n干了两件事情，将本地文件删除，操作命令\u0026ndash;》暂存区\n删除之后文件被放到暂存区,要想彻底删除好需要再提交一次\ngit commit -m \u0026quot;彻底删除\u0026quot;   后悔删除\n 暂存区恢复到工作区\ngit reset HEAD hello.txt  删除动作还原\ngit checkout -- hello.txt    操作系统删除\nrm xxx  删除本地文件\n操作状态在工作区\n  重命名文件 重命名文件涉及了两个文件，将原文件删除，创建新文件\ngit指令\ngit mv aa.txt bb.txt  在暂存区中\n操作系统指令\nmv aa.txt bb.txt  在工作区中\n注意：操作之后调用git status查看状态的提示\n注释重写 注释重写（重写提交说明）\ngit commit --amend -m '修正'  将上一次的提交注释进行重写\nGit的安装 \u0026emsp;网上关于Git的安装有很多的教程，这里就不详细记录了，基本就是一路下一步就可以了。\nGit的使用 Git官网新建仓库 加号\u0026ndash;\u0026gt;new repository\u0026ndash;\u0026gt;填写仓库名，描述\u0026ndash;\u0026gt;create\nGit项目初始化 git init  \u0026emsp;在本地新建一个文件夹，鼠标右键选择 Git Bash Here 输入指令git init 这样的话就将该文件夹纳入到了Git的管理。在本地文件夹会出现一个隐藏的目录.git目录,它是一个版本控制的目录。\n设置邮箱、用户名 \u0026emsp;当我们每次使用git push来将文件推到远程仓库的的时候，会发现每次都需要输入用户名和密码，为了解决它，可以给项目配置用户名，邮箱，这样每次push的时候就不需要再次输入用户名和密码，配置的方式分为三种，分别是：\n git config --global（基本不用）给整个计算机一次性设置  git config \u0026ndash;global user.name \u0026ldquo;mumulx\u0026rdquo;\ngit config \u0026ndash;global user.email \u0026ldquo;2606964863@qq.com\u0026rdquo;\n git config --system（推荐）给当前用户一次性设置\ncd ~ 切换到当前用户得系统文件夹 cat .gitconfig 查看给当前用户设置的用户名和密码 git config --system user.name 'mumulx' git config --system user.email '1819778796@qq.com'  git config --local给当前项目一次性设置\ncd .git/ cat config 查看项目得配置文件 git config --local user.name 'mumulx' git config --local user.email '1819778796@qq.com' git config --local --unset user.name git config --local --unset user.email 删除配置  删除配置\ngit config --local --unset user.name git config --local --unset user.email 删除配置   他们的优先级是3\u0026gt;2\u0026gt;1，也就是说会采用就近的原则进行设置，而且当修改了配置文件时只对修改之后的提交有效。修改之前的提交仍然使用的是之前的配置(用户名、邮箱)\n本地配置的邮箱与用户名并没有实际的意义，可以与远程仓库的用户名邮箱不一样，知识标识一下代码时谁写的。\ncommit的随机数 查看提交日志会发现commit后面又一串字符\ncommit eb125a18e9b9d7ffeb2e30236ce5fbe6d6d110ce  eb125a18e9b9d7ffeb2e30236ce5fbe6d6d110ce：sha1计算的结果\nsha1 、md5 加密算法 、随机数 ，用于区分 是哪一次的提交（并且不重复，理论上会重复，但是几率太小因此认为不会重复）\n忽略文件  创建忽略文件：.gitignore\ntouch .gitignore\n 编辑忽略文件\n  通配符 ：\n* 任意字符 *.properties !b.properties 除了 dir/：忽略dir目录中的所有文件 dir/*.txt dir/*/*.txt :能够忽略 dir/abc/a.txt，dir/xyz/a.txt ,不能 dir/xyz/123/a.txt dir/**/*.txt :任意级别目录 空目录：默认就是忽略的  分支 查看分支 git branch git branch -a git branch -av 创建分支 git branch 分支名 切换分支 git checkout 分支名 删除分支 git branch -d 分支名 (不能删除当前分支) 其他不能删除的情况： 包含 “未合并”的内容，删除分支之前 建议先合并 强行删除 git branch -D 分支名 创建新分支 并切换 ：git checkout -b 分支名 git checkout -b new_branch 合并分支 git merge 分支名 git merge new_branch 分支最近一次提交的shal值 git branch -v  细节：\n 如果在分支A中进行了写操作，但此操作局限在工作区中进行（没add commit）。在master中能够看到该操作。 如果分支A中进行了写操作 进行了commit（对象区），则master中无法观察到此文件\n 如果在分支A中进行了写操作，但此操作局限在工作区中进行（没add commit）。删除分支A 是可以成功的。\n  分支：一个commit链，一条工作记录线\n分支名(master) :指向当前的提交(commit)\nHEAD:指向当前分支（HEAD-\u0026gt;分支名）\n如果一个分支靠前(dev)，另一个落后(master)。则如果不冲突， master可以通过 merge 直接追赶上dev，称为 fast forward。\nfast forward本质就是 分支指针的移动.注意：跳过的中间commit，仍然会保存。\nfast forward：\n 两个分支 fast forward 归于一点commit 没有分支信息（丢失分支信息）  git在merge 时，默认使用fast fast forward ；也可以禁止 :\ngit merge --no-ff   两个分支 fast forward ，不会归于一点commit （主动合并的分支 会前进一步） 分支信息完整（不丢失分支信息）  合并：merge more采用ff.\n合并：如果冲突 ，需要解决冲突。\n解决冲突：\ngit add xxxx git commit -m \u0026quot;xx\u0026quot;  git add xxxx(告知git,冲突已解决)\n注意：master在merge时 如果遇到冲突 并解决，则解决冲突 会进行2次提交： 1次是最终提交，1次是将对方dev的提交信息commit也拿来了\n如果一方落后，另一方前进。则落后放可以直接通过merge合并到前进方，不会冲突。\n当两个分支处在同一个位置时，尝试合并分支会冲突。\n查看日志方法\ngit log --graph git log --graph --pretty=oneline --abbrev-commit  合并add 和commit：\ngit commit -am '注释'  版本穿梭： 在多个commit之间 进行穿梭。 回退、前进\n回退到上二次commit： git reset --hard HEAD^^ 回退到上n次commit： git reset --hard HEAD~n 跳转到任意一次commit: git reset --hard sha1值的前几位 通过sha1值 直接回退 ，需要结合git reflog使用。 git reflog：查看记录，记录所有操作。可以帮助我们 实现“后悔”操作。需要借助于 良好的 注释习惯  checkout的放弃与游离操作 checkout：放弃修改。放弃的是 工作区中的修改。 相对于暂存区或对象区\nreset: 将之前增加到暂存区中的内容 回退到工作区\ncheckout：\ngit checkout shal值  版本穿梭（游离状态）\n 修改后、必须提交 创建分支的好时机\ngit branch mybranch 2735603 创建分支 git chekcout master;切换分支   分支重命名：\ngit branch -m master master2  stash:保存现场  建议（规范） ：在功能未没有开发完毕前，不要commit\n 规定（必须） ： 在没有commit之前，不能chekcout切换分支 （不在同一个commit阶段）\n  如果还没有将某一个功能开发完毕 就要切换分支：建议 1. 保存现场（临时保存，stash）\n2. 切换\n保存现场：\ngit stash 名字随机产生 git stash save \u0026quot;mystash\u0026quot; 自定义名字  查看现场：\ngit stash list  还原现场(默认还原最近一次)：\ngit stash pop (将原来保存的删除， 用于还原内容) git stash apply (还原内容，不删除原保存的内容) git stash apply stash@{1} 指定某一次现场  保存的现场以栈的顺序存储，先进后出\n手工删除现场：\ngit stash drop stash@{0}  （了解即可） 如果不同的分支 在同一个commit阶段在，在commit之前，可以chekcout切换分支；操作的文件的记录是一致的\n当保存现场后忘记还原现场，而对文件进行了修改并am了可能会造成冲突，解决冲突的方法与上面一致\nTag标签 ：适用于整个项目，和具体的分支没关系 创建标签（在commit之后）\ngit tag v1.0 git tag -a xxx -m \u0026quot;xxxx\u0026quot;  查看标签\ngit tag git tag -l 'v1.0' 指定查询 git tag -l 'v*' 模糊查询  删除标签\ngit tag -d 标签名  blame：责任 git blame a.txt 查看a.txt的所有提交commit sha1值，以及每一行的作者  差异性diff linux 命令\ndiff a.txt b.txt 粗略信息，只显示哪些不一样的 diff -u a.txt b.txt 详细信息  @@ -4,4 +4,6 @@ 4:从第4行开始，6 比较6行\n-：原文件\n+：对比的文件\n无符号表示一样\ndiff：比较的是文件本身，源文件-那几行再+那几行就是b文件了\ngit 比较差异\n 暂存区 和工作区的差异\ngit diff  git diff ：比较的区中的文件\ngit diff :暂存区 和工作区的差异\n 工作区 和 某个对象区的差异\ngit diff commit的sha1值： 对象区和 工作区的差异 git diff head：最新 对象区和 工作区的差异  对象区和 暂存区的差异\ngit diff --cached commit的sha1值 : 对象区和 暂存区的差异 git diff --cached HEAD : 最新对象区和 暂存区的差异   push push:本地-\u0026gt;github pull:github-\u0026gt;本地 ， pull = fetch + merge rm -rf * ：当前目录中的文件、子文件目录全部删除（不会删除隐藏文件、不过回收站） .....rm ..... -rf / ......：不要执行，删除整个计算机中的全部文件  github的仓库中，默认的说明文档README.md\n推送：\ngit remote add origin https://github.com:mumulx/xiaochengxu.git  标识，将origin标识为 https://github.com:mumulx/xiaochengxu.git,使用关键字origin代表后面的一串\n(ssh)git remote add origin git@github.com:mumulx/xiaochengxu.git  标识，将origin标识为 git@github.com:mumulx/xiaochengxu.git\n(master) git push -u origin master  推送到master分支中 后续修改推送时 只需要\ngit push  ssh配置： 本地 私钥 ，远程github存放公钥\nssh-keygen 生成：私钥(本机) 公钥（github）  一路回车，生成的文件在当前用户的文件夹/.ssh文件夹中\nid_rsa 私钥 id_rsa_pub 公钥  可以将公钥 存放在github中的两个地方：\n 项目的setting中，只要当前项目可以和 本机 免秘钥登录 账号的settings中， 账户的所有项目 都可以和本机免秘钥  将公钥中的内容粘贴到github中\n注意：远程增加ssh的公钥时\n1. 删除回车符\n2. 可写权限\ngit remote show origin  显示远程仓库的信息\n分支\ndev:开发分支，频繁改变 test：基本开发完毕后，交给测试实施人员的分支 master：生产阶段，，很少变化 bugfix：临时修复bug分支  dev -\u0026gt; test (merge dev) -\u0026gt; master (merge test ) -\u0026gt; \u0026hellip;.\ngit remote show 查看当前的服务器列表 git remote show origin 查看具体的服务器信息  git会在本地维护 origin/master分支，通过该分支 感知远程github的内容\norigin/master一般建议 不要修改，是一个只读分支\n远程到本地\ngit clone git@github.com:mumulx/xiaochengxu.git 会将项目名也下载下载，项目名就是文件夹名 git clone git@github.com:mumulx/ mytest1 指定文件夹名  clone项目时将版本库也下载下来了，操作和原先的一摸一样\npull/push:推送，改变指针\nFast-forward ：更新， 如果发现 更新的内容 比自己先一步（commit 的sh1值 在自己之前），则 会自动合并\n冲突： 根据提示发现有\nfetch first git pull  着两个字段，而\npull = fetch + merge  有冲突：\n 解决冲突\npull =fetch + merge merge： vi 解决冲突 -\u0026gt; git add . -\u0026gt;commit   总结：\npull -\u0026gt; vi -\u0026gt; add -\u0026gt; commit -\u0026gt;push  pull =fetch + merge git pull git fetch 将远程文件拉到本地 git merge 合并和origin/master分支合并  冲突的原因时merge\n图形化工具 git gui ： gitk 、gui 、github desktop\ngitk 命令行输入\ngitk  gui 右键选择\ngit gui here  命令行\ngit gui  日志 本地日志 git log 查看本地日志  查看github分支的日志： git log origin/master git log remotes/origin/master git log refs/remotes/origin/master  分支：就是一个指針，commit的sha1值\n分支：  git branch -av 查看本地分支和本地的远程分支  分支分为： * 本地分支 * 远程分支 * 追踪分支（本地的远程分支）\n本地分支-\u0026gt;远程： 方法一：(本地在dev分支中)\ngit push -u origin dev  方法二：（在本地的test分支中）\ngit push --set-upstream origin test  远程-\u0026gt;本地  pull :远程-\u0026gt;追踪\ngit pull 将远程分支拉到本地的追踪分支  追踪-\u0026gt;本地\n方法一：\ngit checkout -b dev origin/dev 创建一个dev分支，并切换到dev分支，dev分支和origin/dev关联起来  方法二：\ngit checkout -b test --track origin/test git checkout --track origin/aaa   删除分支 删除本地分支\ngit branch -d 分支名  推送分支语法\ngit push origin src:dest  将本地的src分支推送到远端的dest分支\ngit push origin dev:dev2 git push origin HEAD:dev2  head：当前分支\n删除远端分支\ngit push origin :test git push origin --delete dev  git pull origin ccc2:ccc3  相当于 git pull + : git checkout -b dev origin/分支名\n本地没有a分支，但本地却感知远端的a分支。需要将a分支删除掉\n检测那些分支时不需要的：\ngit remote prune origin --dry-run  清理无效的 追踪分支（本地中感知的远程分支）\ngit remote prune origin  将远端分支 拉去到本地某个新分支 ： git fetch origin master:refs/remotes/orogin/helloworld  将远端的master分支拉到本地的helloworld追踪分支\n给命令起别名： git config --global alias.ch checkout  使用ch 将相当于使用了checkout指令\n标签 查看本机标签 git tag  创建本机标签 git tag v1.0 简单标签，只存储当前的commit的sha1值 git tag -a v2.0 -m \u0026quot;我的v.2.0版本\u0026quot; （创建一个新对象，会产生一个新的commit/sha1）存储信息，其中包含了当前的commit的sha1值  推送标签 git push origin v1.0 v2.0 推送指定的标签 git push origin --tags 推送本地所有标签 git push origin v1.0 完整 git push origin refs/tags/v1.0:refs/tags/v1.0  获取远程标签 git pull  如果远端新增标签，则pull 可以将新增的标签拉去到本地；如果远程是删除标签，则pull无法感知\ngit fetch orgin tag v4.0  删除远程标签 git push origin :refs/tags/v1.0  注意：如果将远程标签删除，其他用户无法直接感知，需要用户自己手工删除\ngit gc :压缩 git gc  objects、refs目录中记录了很多commit的sha1值，如果执行gc 则会将这么多sha1值 存放到一个 压缩文件中packed-refs\nrefs ：标签、head、remote\nobjects：对象 ,git 每一次version的全量内容\ngit裸库 创建裸库\ngit init --bare  没有工作区的 工作仓库 ，存在于服务端.不能add\nsubmodule ：子模块 应用场景 ：在一个仓库中 引用另一个仓库的代码。\n在github上如果新建项目，并且ssh连接 则必须配置ssh，如果给项目单独配置ssh则，一个密钥只能对应一个项目\n第一次：指定仓库地址、分支\ngit remote add origin xxx git push -u origin master  本地A仓库引用B仓库\ngit submodule add B仓库ssh地址  推到远程仓库\ngit add . git commit -m \u0026quot;xx\u0026quot; git push  A中有B库，但B push之后 A无法直接感知 ，需要主动操作：pull\n 进入A/B中pull\ncd B/ git pull  将B库更新到远程\ncd .. git add . git commit -m \u0026quot;xx\u0026quot; git push  直接在A中 迭代pull（将A中的所有submodule全部pull）：\ngit submodule foreach git pull  更新远程的submodule\ngit add . git commit -m \u0026quot;x\u0026quot; git push  注意：本地仓库直接使用git pull不会更新模块中的内容\n  如果clone的项目包含submodule,则clone方法 git clone sshxxxx --recursive  删除submodule  工作区\nrm -rf B rm -rf .gitmoudles  暂存区\ngit rm --cached B  对象区\n将删除后的\ngit add . git commit -m \u0026quot;\u0026quot;  远程\ngit push\n  建议：submodule 单向操作\nsubstree：双向、简单\nsubstree 加入子模块 git subtree  查看指令帮助\n 给子模块起别名\ngit remote add subtree-origin 子模块ssh地址  本地仓库引入子模块\ngit subtree add -P 本地项目名 模块地址 模块分支 git subtree add -P subtree subtree-origin master  等价\ngit subtree add --prefix subtree subtree-origin master  另一种方式\ngit subtree add -P subtree2 subtree-origin master --squash  \u0026ndash;squash：合并commit,为了防止 子工程干扰父工程\nsquash：减少commit的次数,会将提交封装起来\n加了squash之后：\n 会产生新的提交(很容易冲突)\n 往前走两步commit  \u0026ndash;结论： 在做subtree\n如果加squash，以后每次都加 （git subtree开头的命令，要么都加 要么都不加）\n如果不加，都不要加\n-如果是同一个祖先，则可能不会冲突\n-如果不是同一个祖先，很可能冲突\n在subtree submodule容易冲突（有2个跟解决） -\u0026gt; vi add commit push\n  推送远程 git push  本地更新子模块 git 子模块文件夹名 pull -P subtree 子模块ssh地址 分支名 git suntree pull subtree subtree-origin master  本地更新远程模块 git push  核心流程：\n子-\u0026gt;父中子 有反应\n 修改子工程 push\n 将github中的子工程更新到 父中子模块（本地）\ngit subtree pull -P subtree subtree-origin master  父中子模块 的更新情况 推送到 对应的github上（父-子）\n  修改 父工程中子模块-\u0026gt;子模块 如何将 本地修改的内容（父-子） 推送到 远程中真实的子模块中：\ncd 子模块 进行修改 git add . git commit -m \u0026quot;xx\u0026quot; git push 更新父工程远程的子模块文件 cd .. 进入父工程 git 本地模块文件夹名 push -P subtree subtree-origin master 更新对应子模块远程仓库 git subtree push -P subtree subtree-origin master  冲突 冲突：修改同一文件的同一行、不是同一祖先、不规范\ncherry-pick 如果写了一半(已经提交)，发现写错分支，需要将已提交的commit转移 分支\n每次只能转移（复制）一个commit ，内容会被复制，但是sha1会变\n在想要转移到的分支中\ngit cherry-pick shal值  在转移的分支中删除提交\ngit checkout shal值 git branch -D dev 删除分支 git checkout -b dev 创建分支  思路： cherry-pick 复制到应该编写的分支上；\n把写错分支删除（checkout 旧节点，删除分支）；\n新建分支\ncherry-pick 在复制的时候，不要跨commit节点复制\nrebase:变基（衍合） 改变分支的根基\ngit rebase 转移的分支名  rebase会改变提交历史\nrebase之后的提交线路 是一条直线\nshal值会改变\n编写代码的地方\n如果B转到A ；\n cherry-pick:在A中操作\n rebase:在B中操作\n  rebase也会冲突：\n 解决冲突\nvi ... add . 告知程序已解决 git rebase --continue 继续trbase  忽略冲突（放弃rebase所在分支的修改，直接使用其他分支）\ngit rebase --skip  终止,还原成rebase之前的场景\ngit rebase --abort   建议：\n reabase分支 只在本机操作，不要推送github\n 不要在master上直接rebase\n  rebase到的分支的头节点不会前进，因此可以merge两个分支\u0026ndash;fast-forward\nIDEA使用gradle整合gretty进行web开发 git - gradle\njar :maven\ngradle -\u0026gt;Maven\n下载、解压缩\ngradle官网\n下载地址\ngradle -\u0026gt;maven\ngradle实际是在maven仓库中获取 jar，因此引用jar包时去maven中搜索\nbuild.gradle\u0026mdash;pom.xml\n配置 配置jdk cmd开发 GRADLE_HOME：gradle安装目录 GRADLE_USER_HOME 本地仓库（本地存放JAR的目录） PATH：%GRADLE_HOME%\\bin  idea开发 (本地仓库)额外 idea:settings-gradle ：Service directory path  idea新建gradle项目 File--\u0026gt;new-\u0026gt;Gradle 勾选web-\u0026gt;设置坐标--\u0026gt;勾选Use auto-import自动导入  下载的jar包在resp/caches/modules-2/files-2.1中\nbuild.gradle配置 apply plugin : 'java' apply plugin : 'war' apply plugin : 'idea' apply plugin : 'maven' apply plugin : 'org.akhikhl.gretty' buildscript { repositories { mavenCentral() } dependencies { classpath 'org.akhikhl.gretty:gretty:2.0.0' } } repositories { mavenCentral() } //私服 //dependencies{ //repositories { // maven{ // url:xxx // } //} //} if (!project.plugins.findPlugin(org.akhikhl.gretty.GrettyPlugin)) project.apply(plugin: org.akhikhl.gretty.GrettyPlugin) gretty { httpPort=8080 contextPath = '/MyGradlePro' host=\u0026quot;localhost\u0026quot; httpEnabled = true servletContainer = \u0026quot;tomcat8\u0026quot; scanInterval = 1 fastReload = true loggingLevel = \u0026quot;DEBUG\u0026quot; consoleLogEnabled = true debugPort = 8887 debugSuspend = true } //sourceSets { // main{ // java{ // srcDir 'src/main/nn' // } // resources{ // srcDir 'src/main/yy' // } // // } //} //plugins { // id 'java' // id 'war' //} group 'com.mumu.gradle' version '1.0-SNAPSHOT' sourceCompatibility = 1.8 targetCompatibility = 1.8 repositories { mavenCentral() } dependencies { testCompile group: 'junit', name: 'junit', version: '4.12' compile group: 'org.mybatis', name: 'mybatis', version: '3.4.6' } tasks.withType(JavaCompile){ options.encoding = \u0026quot;UTF-8\u0026quot; } [compileJava,javadoc,compileTestJava]*.options*.encoding = \u0026quot;UTF-8\u0026quot;  IDEA右侧有Gradle的工具箱\nweb服务器 gradle或maven中 可以通过编码配置 产生web服务器环境\ngradle:gretty\ngretty -》tomcat\ngretty教程\napply plugin: 'war' apply plugin : 'org.akhikhl.gretty' buildscript { repositories { mavenCentral() } dependencies { classpath 'org.akhikhl.gretty:gretty:2.0.0' } } repositories { mavenCentral() } if (!project.plugins.findPlugin(org.akhikhl.gretty.GrettyPlugin)) project.apply(plugin: org.akhikhl.gretty.GrettyPlugin) gretty { httpPort=8080 contextPath = '/MyGradlePro' host=\u0026quot;localhost\u0026quot; httpEnabled = true servletContainer = \u0026quot;tomcat8\u0026quot; scanInterval = 1 fastReload = true loggingLevel = \u0026quot;DEBUG\u0026quot; consoleLogEnabled = true debugPort = 8887 debugSuspend = true }  编码\n//编码 tasks.withType(JavaCompile){ options.encoding = \u0026quot;UTF-8\u0026quot; } [compileJava,javadoc,compileTestJava]*.options*.encoding = \u0026quot;UTF-8\u0026quot;  执行 加前缀gradle xxx appRun 运行 appRunDebug 调试 --结束： 按任意键 appStart appStartDebug --结束：appStop  idea右侧gradle子目录gretty有诸多命令\n运行：\ngradle appRun 、gradle appStart -》直接访问  调试： 1. 配置\n debugPort = 8888 （5005） debugSuspend = true   启动\ngradle appRunDebug/gradle appStartDebug  监听服务\n配置run-- Configuration - Remote name随便取 host：localhost port：8887  启动调试，idea的debug按钮\n 访问\n访问8080\n  新建servlet 右键\u0026ndash; new\u0026ndash;Create new Servlet\n自动生成的文件\n@WebServlet(name = \u0026quot;MyServlet\u0026quot;) 改成 @WebServlet(urlPatterns = \u0026quot;/MyServlet\u0026quot;)  web.xml注意\nmetadata-complete=\u0026quot;false\u0026quot;\u0026gt;，应为false  源码\npackage org.mumu.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(urlPatterns = \u0026quot;/MyServlet\u0026quot;) public class MyServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\u0026quot;do post\u0026quot;); int a =10; int b=9; a=a+b; System.out.println(a); System.out.println(b); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } }  在idea中使用git托管项目（版本控制） 将idea中默认的cmd更换 bash.exe 重启\nfile--\u0026gt;setting--\u0026gt;Terminal--\u0026gt;设置Shell path路径为git安装目录/bin/bash.exe  创建忽略文件\n.gitignore\nbuild out .gradle .idea  初始化\ngit init git add . git commit -m \u0026quot;xxxx\u0026quot; git remote add origin xxxx git push origin master  项目地址\n本地更新idea git pull  clone项目到本地 file \u0026ndash;\u0026gt; new\u0026ndash;\u0026gt;Project from Version Control \u0026ndash;\u0026gt;Git\n复制远程的地址\n构建项目 （gradle项目）\ngradle build  菜单栏VCS中也有Git的操作指令，快捷键\n右键文件也有Git的快捷键\n右键项目也有\n解决冲突图形化界面\n右键\u0026ndash;\u0026gt;git\u0026ndash;\u0026gt;resolve Conficts\u0026hellip;.\nGitLab 下载 gitlab-ce-12.7.2-ce.0.el7.x86_64.rpm\n下载地址\ngitlab ee（收费）\ngitlab ce\n安装说明\nyum install -y curl policycoreutils-python openssh-server systemctl enable sshd systemctl start sshd systemctl start firewalld firewall-cmd --permanent --add-service=http firewall-cmd --permanent --add-service=https systemctl reload firewalld  yum install postfix systemctl enable postfix systemctl start postfix EXTERNAL_URL=\u0026quot;https://192.168.2.150\u0026quot;  将下载的文件传到linux中\nrpm -ivh gitlab-ce-12.7.2-ce.0.el7.x86_64.rpm gitlab-ctl reconfigure  等待时间较长，会一致出现action run，不用理它，耐心等待\n启动\ngitlab-ctl start  关闭\ngitlab-ctl stop  访问 可以先关闭防火墙\nsystemctl stop firewalld  访问\n centos7init 192.168.2.150  用户名\nroot  设置密码\nrootroot  登录\n创建组，创建项目\n之前EXTERNAL_URL=\u0026quot;https://192.168.2.150\u0026quot;忘记设置\n补救\neclipse 推送git 首选项 team\u0026ndash;\u0026gt;git\u0026mdash;configuration 配置邮箱和目录 General\u0026mdash;-NetWorkConnection\u0026ndash;\u0026gt;ssh2\n第一次发布 右键Team---\u0026gt;share 设置本地存储仓库 右键--\u0026gt;Team-\u0026gt;add to index 加入暂存区 右键--\u0026gt;Team--\u0026gt;commit 提交到本地分支 右键 --\u0026gt;team--\u0026gt;remote--\u0026gt;push 选择项目 填写账号邮箱 密码 --\u0026gt;next--\u0026gt;master--\u0026gt;add Sp 将项目推送到远程分支  提交\n右键--\u0026gt;Team-\u0026gt;add to index 加入暂存区 右键--\u0026gt;Team--\u0026gt;commit 提交到本地分支 右键--\u0026gt;Team--\u0026gt;push 提交到远程仓库  commit时\ncommit and push或commit的区别\n commit按钮：不能单独的Push某一个文件，只能Push整个项目\n commit and push可以单独Push某一个文件\n  第一次下载： import---\u0026gt;git fro--\u0026gt;clone url  更新 指定文件\u0026ndash;\u0026gt;右键\u0026ndash;\u0026gt;Team\u0026ndash;》repository\u0026ndash;\u0026gt;pull\ngit冲突的解决:\n发现冲突\n 1.进入同步视图右键\u0026mdash;-team - \u0026ndash;synchronized\u0026hellip;I 红色:冲突\n 2。\n添加到本地暂存区 add to index 提交到本地分支 commit 更新服务端的分支内容到本地分支 pull   修改冲突:直接修改或者merge tool(修改代码) (\u0026mdash;\u0026gt;已经变为了普通本地文件) \u0026ndash;将服务端文件进行更新\nadd to index commit push  git多个人团队协作开发\ngithub中 该项目-settings\u0026ndash;collaborators 增加合作者:\n发送邀请链接\n合作伙伴:打开该链接、 接受邀请、clone项目、修改、add \\commit\\push\n","id":36,"section":"posts","summary":"Git简介 git lab指令 启动 gitlab-ctl start 关闭 gitlab-ctl stop 关闭防火墙 systemctl stop firewalld 开启防火墙 systemctl start firewalld Git指令 git init 项目初始化 git status 查看当前状态 git log 查看日志 git log -2 查看最近两次","tags":["版本控制"],"title":"Git自学笔记","uri":"https://mumulx.github.io/2019/11/git%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" 简介 Query是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等。\n下载 JQuery官网\nmin.js：压缩版 发布版\n.js:常规版 开发板\n开始使用 $(document).ready(function(){}): 初始化函数， 当网页中的dom元素(不包含图片、视频、资源)全部加载完毕后立刻执行\nonload:javascript,初始化函数，当网页中的dom元素(关联图片、视频、资源)全部加载完毕后立刻执行\njquery初始化函数简化:\n$ (function() {...}) ;  $ 等价于jQuery\ndom模型: 将html xml 等文档结构的标签语言看成dom模型\ndom节点有三种类型:\n 元素节点\u0026lt;html\u0026gt; \u0026lt;ul\u0026gt;... \u0026lt;p\u0026gt;\n 属性节点: title Src alt\n 文本节点:文本节点\n  Dom对象: 以上三种节点类型的具体对象就是Dom对象。\n使用层面: 凡是JavaSCript 能够直接操作的对象，就是Dom对象。\n例如，var title = document. getElementById(' myTitile\u0026quot;) ;通过js获取到的title对象就是一个dom 对象(就是\u0026lt;p\u0026gt;对象)\njQuery对象: 凡是jQuery能够直接操作的对象，就是jQuery对象。\n例如: var $title = $(\u0026quot; #myTitile\u0026quot;) ;通过jquery获取到的$title就是一个jquery对象。\n同样一个元素，既可以成为个dom对象 (javascript对象) ，也可以成为一个jquery对象\n注意: dom对象只适用于js的各种语法(函数、属性)，jquery对 象只用于jquery的各种语法(函数、属性)。dom对象和jquery对象的各自独立。\n例如\n title是dom对象，因此可以使用js属性或方法title. innerHTML\n $title是jquery对象，因此可以使用jquery属性或方法$title.html ()\n  建议:\n js对象 直接写title jQuery对象加上$title  dom对象和jQuery对象的转换\n title.innerHTML: title-\u0026gt;$title $title.html(): $title-\u0026gt;title  dom-jQuery:jquery工厂，$(dom对象).jQuery方法\njQuery-Dom:  基础：jquery对象默认是一个数组或集合；dom对象默认是一个单独对象 数组：jQuery对象[0]； jQuery对象(含有$) 集合：jQuery对象.get(0);  jQuery选择器：jQuery根基 分类：  基本选择器：\n标签选择器： $(\u0026quot;标签名\u0026quot;) 类选择器： $(\u0026quot;.class值\u0026quot;) id选择器: $(\u0026quot;#id值\u0026quot;) 全局选择器： $(\u0026quot;*\u0026quot;) 并集选择器:\u0026quot;,\u0026quot; $(\u0026quot;#id值,.class值\u0026quot;) 交集选择器（同时存在）：直接写$(\u0026quot;p.class值\u0026quot;) 无需\u0026quot;,\u0026quot; 既是p标签的值又是clss的值 错误$(\u0026quot;.class值p\u0026quot;) 交集选择器在交接处只能是.或#  层次选择器: 只取后面的那个\n相邻选择器 + $(\u0026quot;#b+li\u0026quot;) id为b的相邻的标签为li的元素 $(\u0026quot;选择器1+选择器2\u0026quot;) 同辈选择器 ~ $(\u0026quot;选择器1~选择器2\u0026quot;) 后代选择器： 空格 $(\u0026quot;选择器1 选择器2\u0026quot;) 子代选择器： \u0026gt; $(\u0026quot;选择器1\u0026gt;选择器2\u0026quot;)  属性选择器 [\u0026hellip;.]\n$(\u0026quot;[属性名]\u0026quot;) $(\u0026quot;[name]\u0026quot;) 选中全部元素中含有name属性的元素 $(\u0026quot;[属性名=属性值]\u0026quot;) $(\u0026quot;[class=xxx\u0026quot;) 等价 $(\u0026quot;[class='xxx']\u0026quot;) $(\u0026quot;[属性名^=a]\u0026quot;) 属性名以a开头的元素 $(\u0026quot;[属性名$=a]\u0026quot;) 属性名含有a的元素 判断属性值的操作 $(\u0026quot;[属性名*=a]\u0026quot;) 属性名以a开头的元素 $(\u0026quot;[属性名!=a]\u0026quot;) 属性名不等于a开头的元素 有属性名但属性值不等于属性值 没有属性名  过滤选择器 \u0026ldquo;:\u0026rdquo; 和其他的一些方法类似\n first() last() 有些不行 :odd 基本过滤选择器 从0开始 0是偶数 :first 最开头的那一个 :last-child 最后哪一个 :even 偶数 :odd 奇数 :eq(index) 第index个 jQuery对象是一个数组0 1 2 3 :gt(index) \u0026gt;index的全部元 index就相当于下标 :lt(index) \u0026lt;index的全部元素 :not(index) 除了index以外的全部 :header: 选中所有的标题元素 h1 h2 h3 :focus: 中当前焦点的元素  例\n$(\u0026quot;ul\u0026gt;li:first\u0026quot;).length $(\u0026quot;ul\u0026gt;li\u0026quot;).first().length 对象.过滤器(); 对象:first  有些是可以通用的\n注意\n $(\u0026quot;ul\u0026gt;li:odd\u0026quot;)[0].html() 是错误的  原因：\n$(\u0026quot;ul\u0026gt;li:odd\u0026quot;)[0]是dom对象 不能使用jQuery方法  解决办法\n$($(\u0026quot;ul\u0026gt;li:odd\u0026quot;)[0]).html() 将dom对象转换为jQuery对象  可见性选择器\n:visible:选中所有可见的元素 :hidden:选中所有隐藏的元素   通过css()来设置样式\n$(\u0026quot;input:focus\u0026quot;).css $(\u0026quot;:header\u0026quot;).css(\u0026quot;key\u0026quot;,\u0026quot;value\u0026quot;); background red;  事件  js:on~ onclick() 写在script内 ready()外\n jQuery:没有on click() 写在ready()内\n  语法：\n$(选择器).事件类型(function (){ });  windows事件: ready();  鼠标事件： click（）:点击事件 mouseover():鼠标悬浮 mouseout():鼠标离开  jQuery执行完毕后返回对象本身\n因此\n$(\u0026quot;div\u0026quot;).mouseover(function(){ alert(\u0026quot;111\u0026quot;); }); $(\u0026quot;div\u0026quot;).mouseout(function(){ alert(\u0026quot;2222\u0026quot;); });  等价于 链式写法\n$(\u0026quot;div\u0026quot;).mouseover(function(){ alert(\u0026quot;111\u0026quot;); }).mouseout(function(){ alert(\u0026quot;2222\u0026quot;); });  键盘事件 event.keyCode拿到键码值\nkeydown(): 从上往下压过程 keypress(): 压到底了 keyup(): 从下往上  注意：前端的一些事件、方法会在某些情况下失效。考虑兼容性。\n表单事件  focus(方法):获取焦点 blur(方法):失去焦点  注意：\n 当颜色两两相同时六位十六进制的颜色可以写成3位\n 可以使用this代表当前对象 但是this是dom对象因此 需要转换为jQuery对象$(this)\n  绑定事件和移除事件 $(...).bind(事件类型,[数据],函数); 数据可选参数 $(...).bind(\u0026quot;click\u0026quot;,function(){ });  批量绑定  $(...).bind({\u0026quot;事件名\u0026quot;：函数，\u0026quot;事件名\u0026quot;：函数})  移除事件： $(...).unbind(事件类型,[数据],函数);数据可选参数 $(...).unbind(\u0026quot;click\u0026quot;);  复合事件： hover(f1,f2); 切换使用 mouseover mouseout toggle(f1,f2,f3,.....fn): 具有版本问题（只支持1.9之前的） 轮回执行多个click()事件 toggle()其他含义（隐藏和显示）  显示效果（隐藏与显示） hide([速度],[回调函数])：隐藏 hide()：立刻隐藏 hide(3000)三秒隐藏 show()：显示 toggle()：两者切换  注意\n 回调函数（callBack） 当函数执行完毕后 在执行回调函数\n 速度：毫秒 或者关键字\u0026rdquo;fast\u0026rdquo; \u0026ldquo;slow\u0026rdquo; \u0026ldquo;normal\u0026rdquo;\n  淡入淡出：改变透明度来隐藏 fadeIn():淡入 显示 fadeOut():淡出 隐藏  控制高度 slideDown():变大 下拉 slideUp()：变小 上拉  总结显示问题 显示：show(),fadeIn(),slideDown() 隐藏：hide(),fadeOut(),slideUp()  操作Dom： 样式操作 设置css jQuery对象.css(\u0026quot;属性名\u0026quot;,\u0026quot;属性值\u0026quot;)操作一个、 jQuery对象.css({\u0026quot;属性名\u0026quot;:\u0026quot;属性值\u0026quot;,\u0026quot;属性名\u0026quot;:\u0026quot;属性值\u0026quot;,\u0026quot;属性名\u0026quot;:\u0026quot;属性值\u0026quot;})操作多个  追加或移除样式class addClass(\u0026quot;x\u0026quot;) 一个 addClass(\u0026quot;x x x\u0026quot;) 多个以空格隔开 一组双引号 removeClass(\u0026quot;x\u0026quot;); 移除一个 removeClass(\u0026quot;x x\u0026quot;); 移除多个 removeClass()： 移除全部样式 toggleClass(); 切换追加与移除  内容操作  对象.方法 html(): 获取值，获取的是元素的内容 包括元素内部的各种标签 html(zxzz) 赋值 text(): 获取值，只获取文本值 text(xxxx) 赋值 val(): 获取value值 val(xxxx): 设置value值  节点与属性的操作 节点操作 查询节点： jquery选择器  创建节点：$() $(选择器)： 获取节点 $(DOM对象): 转换 $(html字符串) 创建节点$(\u0026quot;\u0026lt;li\u0026gt;xxxx\u0026lt;/li\u0026gt;\u0026quot;)  内部插入 先创建 var $aaaa = $(\u0026quot;\u0026lt;h1\u0026gt;hello\u0026lt;/h1\u0026gt;\u0026quot;); $(A).append(B) 将B追加到A中 后面 如: $(\u0026quot;\u0026quot;).append($aaaa); $(A).appendTo(B) 把A追加到B中 如: $aaaa.appendTo(\u0026quot;\u0026quot;); $(A). prepend (B) 将B前置插入到A中 前面 如: $(\u0026quot;\u0026quot;). prepend ($node); $(A). prependTo(B) 将A前置插入到B中 如: $ node.prependTo (\u0026quot;ul!\u0026quot;);  外部插入 $(A).after(B) 将B插入到A之后 如: $(\u0026quot;u\u0026quot;).after(Snode); S(A).insertAfter(B) 将A插入到B之后 如: $ node.insertAfer(\u0026quot;l\u0026quot;); $(A).before(B) 将B插入至A之前 如: $(\u0026quot;u\u0026quot;).before(Snode); S(A).insertBefore(B) 将 A插入到B之前 如: $ node.insertBefore(\u0026quot;ul\u0026quot;);  替换节点 $x.replaceWith(b) 用b替换a $b.replaceAll(x) 用b体寒a  删除节点 remove(): 彻底删除 deatch()： 只将节点删除 但关联的事件 数据不会删除（不推荐删除） empty()： 只删除内容  克隆节点 clone(true|false); 连事件 是否克隆  属性操作 attr(\u0026quot;属性名\u0026quot;)： 获取属性值 attr(\u0026quot;属性名\u0026quot;,\u0026quot;属性值\u0026quot;)： 设置属性值 attr({\u0026quot;属性名\u0026quot;：\u0026quot;属性值\u0026quot;,\u0026quot;属性名\u0026quot;：\u0026quot;属性值\u0026quot;,}) 设置多个值 removeAttr(\u0026quot;属性名\u0026quot;); 删除 val(): 获取value值 val(xxxx): 设置value值  获取集合与遍历 $(\u0026quot;\u0026quot;) 本身就是一个集合  节点集合 $(...).childern(\u0026quot;标签\u0026quot;) 标签为空 则选择所有节点  后代集合 不推荐 $(...).find(\u0026quot;标签\u0026quot;);  这种也可以\n后代选择器：空格 $(\u0026quot;选择器1 选择器2\u0026quot;) 子代选择器：\u0026gt; $(\u0026quot;选择器1\u0026gt;选择器2\u0026quot;)  同辈集合 ()里面可以加标签 next() : 后一个 + prev(): 前一个 无 siblings()： 同辈 都有 不包含自己  前辈集合 ()里面可以加标签 parent(): 父代 parents(): 祖先节点  过滤集合 很多方法的()就是一个过滤选择器 filter(\u0026quot;选择器\u0026quot;)  遍历集合 $(....).each(function(){ }); $(....).each(function(index,element){ });   index:当前第几个元素\n element：当前的元素是谁 相当与this但是this和element都是dom对象 需要转换为jQuery对象$(this) $(element)\n  CSS-dom操作： （）取 值 (xxxx)设置值xxxx是数字 不要加px\nheight() 高 width() 宽 offset() 偏移量（左上角） 结果是一个对象 .left .top  例\noffset(function(index,oldOffset){//通过方法来赋值 //定义对象 var newOffset = new Object(); //赋值 newOffset.left = oldOffset.left+100; newOffset.top=oldOffset.top+100; //返回结果 return newOffsetp; })   index；第几个 oldOffset；当前元素\n offsetParent()：获取已定位的最近的父元素 结果是节点而不是位置\n  定位： 元素的position的属性(默认为static)被设置为relative(相对) absolute（绝对）或dixed\nscrollLet() 滚动条 scrollTop ()  表单校验 可以减轻对服务端的访问次数\n 获取要校验的元素值(选择器)\n 通过 字符串处理方法、或者 正则表达式等手段进行验证\n 触发校验的方法或事件\nblur():失去焦点时触发 submit():当点击表单的提交按键时  js方法\nonblur=\u0026quot;xxxx()\u0026quot; onsubmit=\u0026quot;xxxx()\u0026quot;   正则表达式：用于定义规则 /.../ 一个 规则的开始和结束 ^ 匹配字 符串的开始 $ 匹配字符串的结束 [] 定义一个匹配的字符范围，如[0-9a-z]表示 该字符取值的范围是数字或小写字母 \\s 任何空白字符 \\S 任何非空白字符 \\d 匹配一个数字字符，等价于[0-9] \\D 除了数字之外的任何字符，等价于[^0-9] ^ 非 除了 \\w 匹配一个数字、下划线或字母字符，等价于[A-Za-z0-9_ ] 或直接写 范围- \\W 任何非单字字符，等价于[^a-ZA-Z0-9_ ] . 除了换行符之外的任意字符 {n} 匹配前一项n次 {n,} 匹配前项n次或n次以上 {n,m} 匹配前一项至少n次，至多m次 * 匹配前一项0 次或多次，等价于{0,} + 匹配前一项1次或多次，等价于{1,} ? 匹配前一项0次或1次，也就是说前一项是可选的，等价于{0,1}  实例\n$(\u0026quot;#utel\u0026quot;) .blur ( function() { var $tel = $(this) . val () ; var reg= /^1\\d{10}$/ ; if(! (reg. test ($tel))) { if($tel=\u0026quot;\u0026quot;||$tel. length==0) { $(\u0026quot;#telTip\u0026quot;) .css (\u0026quot;display\u0026quot;,\u0026quot;none \u0026quot;); }else{ $(\u0026quot;#telTip\u0026quot;) .css (\u0026quot;display\u0026quot;,\u0026quot;inline\u0026quot;) ;//inline不换行 block回车换行 } }else{ $(\u0026quot;#telTip\u0026quot;) .css (\u0026quot;display\u0026quot;,\u0026quot;none \u0026quot;); } }) ; $ (\u0026quot;#uemail\u0026quot;) .blur(function() { var $email = $ (this) . val () ; var reg = /^\\w+@[0-9a-zA-Z]{2,4}\\.[a-zA-Z]{2,3}([a-zA-Z] {2,3})?$/; if( ! reg. test ($email) ) if($email=\u0026quot;\u0026quot;||$email. length==0) { $ (\u0026quot; #emailTip\u0026quot;) .css (\u0026quot;emailTip\u0026quot; , \u0026quot;none\u0026quot;); }else{ $(\u0026quot;#telTip\u0026quot;) .css (\u0026quot;display\u0026quot;, \u0026quot;inline\u0026quot;) ; } }else{ $ (\u0026quot; #emailTip\u0026quot;) .css (\u0026quot;emailTip\u0026quot; , \u0026quot;none\u0026quot;); } }) ;  表单选择器（过滤选择器） :input 匹配所有input、textarea select和button元素 $(\u0026quot; #myfom :input\u0026quot;)选 取所有的input、select、 button元素 :text 匹配所有单行文本框 $(\u0026quot;#myfom :text\u0026quot; )选取所有的\u0026lt;input type=\u0026quot; text\u0026quot;/\u0026gt;元素 :password 匹配所有密码框 $(\u0026quot; #myform :password\u0026quot; )选取所有\u0026lt;inputtype=\u0026quot;password\u0026quot; /\u0026gt;元素 :radio 匹配所有单项按钮 $(\u0026quot; #myfom :radio\u0026quot;)选 取所有\u0026lt;input type=\u0026quot;radio\u0026quot;/\u0026gt;元素 :checkbox 匹配所有复选框 $(\u0026quot; #myform:checkbox”)选取\u0026lt;input type=\u0026quot;checkbox”/\u0026gt;元素 :submit 匹配所有提交按钮 $(\u0026quot; tmyfom :submit ”)选取\u0026lt;input type=\u0026quot;submit”/\u0026gt;元素 :image 匹配所有图像 S$(\u0026quot;#myform :image\u0026quot; )选取\u0026lt;input type=\u0026quot; image\u0026quot; /\u0026gt; 元素 :reset 匹配所有重置按钮 $(\u0026quot; #myform:reset”)选取\u0026lt;input type=\u0026quot; reset”/\u0026gt;元素 :button 匹配所有按钮 $(\u0026quot; #myfom :button\u0026quot; )选取button元素 :file 匹配所有文件域 $(\u0026quot; #myform :file\u0026quot; )选取\u0026lt;input type=\u0026quot; file”1\u0026gt;元素 :hidden 匹配所有不可见元素 $(\u0026quot; tmyform :hidden\u0026quot; )选取\u0026lt;input type=\u0026quot;hidden”/\u0026gt;、style=\u0026quot;display: none\u0026quot;等元素  函数 对象.stop(true,true).事件;立即执行该事件.\n","id":37,"section":"posts","summary":"简介 Query是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScr","tags":["前端框架"],"title":"JQuery自学笔记","uri":"https://mumulx.github.io/2019/11/jquery%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" 源码\nJSP:动态网页 静态、动态：\n 不用 和 是否有“动感”混为一谈\n 是否随着时间、地点、用户操作的改变而改变  动态网页需要使用到服务端脚本语言（JSP）\n架构 CS：Client Server CS不足：\n 如果 软件升级， 那么全部软件都需要升级 维护麻烦：需要维护每一台 客户端软件 每一台客户端 都需要安装 客户端软件  BS ：Broswer Server 客户端可以通过 浏览器 直接访问服务端\n注意：bs和cs各有优势。\ntomcat解压后目录： bin:可执行文件（startup.bat shutdown.bat） conf:配置文件（server.xml） lib：tomcat依赖的jar文件 log:日志文件（记录出错等信息） temp:临时文件 webapps：可执行的项目（将我们开发的项目 放入该目录） work:存放由jsp翻译成的java,以及编辑成的class文件(jsp -\u0026gt;java -\u0026gt;class)  配置tomcat  配置jdk (必须配置JAVA_HOME)\njava_home classPath path  配置catalina_home\n双击bin/startup.bat启动tomacat，\n常见错误： 可能与其他服务的端口号冲突 tomcat端口号默认8080 （此端口号较为常见，容易冲突），建议修改此端口 （8888）\n  修改端口号： 修改tomcat根目录/conf/server.xml大概70行左右\n\u0026lt;Connector connectionTimeout=\u0026quot;20000\u0026quot; port=\u0026quot;8080\u0026quot; protocol=\u0026quot;HTTP/1.1\u0026quot; redirectPort=\u0026quot;8443\u0026quot;/\u0026gt;  访问tomcat http://localhost:8888/  默认访问项目是webapp/ROOT\n常见状态码：\n200：一切正常 300/301: 页面重定向 （跳转） 404:资源不存在 403：权限不足 （如果访问a目录，但是a目录设置 不可见） 500：服务器内部错误（代码有误） 其他编码：积累  jsp：在html中嵌套的java代码\n在项目/WEB-INF/web.xml中设置 默认的 初始页面\n \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;index.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt;  tomcat项目必须有的两个/WEB-INF/web.xml目录和文件\n虚拟路径 将web项目配置到 webapps以外的目录\n方式一 conf/server.xml中配置 host标签中新增：\n\u0026lt;Context docBase=\u0026quot;D:\\study\\JspProject\u0026quot; path=\u0026quot;/JspProject\u0026quot;/\u0026gt;  docBase：实际路径\npath：虚拟路径 （绝对路径、相对路径【相对于webapps】）\n重启\n访问path实际访问的是docBase\n方式二 apache-tomcat-8.5.30\\conf\\Catalina\\localhost 中新建 “项目名.xml”中新增一行：\n\u0026lt;Context docBase=\u0026quot;D:\\study\\JspProject\u0026quot; path=\u0026quot;/JspProject\u0026quot; /\u0026gt;  虚拟主机 通过www.test.com访问本机\n conf/server.xml\n\u0026lt;Engine name=\u0026quot;Catalina\u0026quot; defaultHost=\u0026quot;www.test.com\u0026quot;\u0026gt; \u0026lt;Host appBase=\u0026quot;D:\\study\\JspProject\u0026quot; name=\u0026quot;www.test.com\u0026quot;\u0026gt; \u0026lt;Context docBase=\u0026quot;D:\\study\\JspProject\u0026quot; path=\u0026quot;/\u0026quot;/\u0026gt; \u0026lt;/Host\u0026gt;  C:\\Windows\\System32\\drivers\\etc\\host\n增加\n127.0.0.1 www.test.com   流程：\nwww.test.com-\u0026gt; host找映射关系 -\u0026gt;server.xml找Engine的defaultHost -\u0026gt;通过\u0026rdquo;/\u0026ldquo;映射到D:\\study\\JspProject\n项目默认的端口号是：80\nJSP执行流程 jsp- java(Servlet文件) -class D:\\study\\apache-tomcat-8.5.30\\work\\Catalina\\localhost\\JspProject\\org\\apache\\jsp\nJsp 和Servlet 可以相互转换\n因为第一请求服务端 会有翻译 和编译的过程，因此比较慢； 后续访问 可以直接访问class,因此速度较快。但是 如果 服务端修改了代码，则再次访问时 会重新的翻译、编译。\n使用Eclipse开发Web项目(JSP项目) tomcat 配置tomcat windows-\u0026gt;preferences\u0026ndash;\u0026gt;server\u0026ndash;\u0026gt;run time 添加tomcat与jdk\n在Eclipse中创建的Web项目： File\u0026ndash;\u0026gt;new \u0026ndash;\u0026gt;Dynamic Web Project\n浏览器可以直接访问 WebContent中的文件，\n例如http://localhost:8888/MyJspProject/index1.jsp\n其中的index1.jsp就在WebContent目录中；\n但是WEB-INF中的文件 无法通过客户端（浏览器）直接访问，只能通过请求转发来访问\n注意：并不是 任何的内部跳转都能访问WEB-INF；原因是 跳转有2种方式：请求转发 、重定向\n配置tomcat运行时环境 jsp\u0026lt;-\u0026gt;Servlet两种方法 1. 将tomcat/lib中的servlet-api.jar加入项目的构建路径 1. 右键项目-\u0026gt;Build Path -\u0026gt; Add library -\u0026gt;Server Runtime\n部署tomcat 在servers面板 新建一个 tomcat实例 ， 再在该实例中 部署项目（右键-add）\n之后运行\n注意：一般建议 将eclipse中的tomcat与 本地tomcat的配置信息保持一致： 将eclipse中的tomcat设置为托管模式：【第一次】创建tomcat实例之后， 双击，选择Server Location的第二项\n统一字符集编码 编码分类：\n设置jsp文件的编码（jsp文件中的pageEncoding属性）： jsp -\u0026gt; java\n设置浏览器读取jsp文件的编码（jsp文件中content属性）\n一般将上述设置成 一致的编码，推荐使用UTF-8\n文本编码：三种方式\n 将整个eclipse中的文件 统一设置 （推荐）\n 设置 某一个项目\n 设置单独文件\n  JSP的页面元素 HTML java代码（脚本Scriptlet）、指令、注释\n脚本Scriptlet \u0026lt;% 局部变量、java语句 %\u0026gt;  \u0026lt;%! 全局变量、定义方法 %\u0026gt;  \u0026lt;%=输出表达式 %\u0026gt;  \u0026lt;%! public String bookName ;//全局变量java注释 public void init() /*java注释 */ { Date date = new Date(); bookName = \u0026quot;java书\u0026quot;+date ; } %\u0026gt; ====hello index1 你好...==== \u0026lt;% String name = \u0026quot;zhangsan\u0026quot; ; out.println(\u0026quot;\u0026lt;font color='red'\u0026gt;hello.\u0026lt;/font\u0026gt;..\u0026quot;+name +\u0026quot;\u0026lt;br/\u0026gt;\u0026quot;); init() ; %\u0026gt; \u0026lt;%=\u0026quot;he\u0026lt;br/\u0026gt;llo...\u0026quot;+bookName %\u0026gt; \u0026lt;!--html注释 --\u0026gt; \u0026lt;%-- jsp注释--%\u0026gt;  一般而言，修改web.xml、配置文件、java 需要重启tomcat服务\n但是如果修改 Jsp\\html\\css\\js ，不需要重启\n注意，out.println()不能回车； 要想回车：“\u0026lt;br/\u0026gt;”，即out.print() \u0026lt;%= %\u0026gt; 可以直接解析html代码\n指令 page指令\n\u0026lt;%@ page ....%\u0026gt;  page指定的属性：\nlanguage:jsp页面使用的脚本语言 import:导入类（java） pageEncoding:jsp文件自身编码 jsp -\u0026gt;java contentType:浏览器解析jsp的编码  \u0026lt;%@ page language=\u0026quot;java\u0026quot; contentType=\u0026quot;text/html; charset=UTF-8\u0026quot; pageEncoding=\u0026quot;UTF-8\u0026quot; import=\u0026quot;java.util.Date\u0026quot; %\u0026gt;  注释 html注释 \u0026lt;!-- --\u0026gt; ,可以被客户 通过浏览器查看源码 所观察到,其他两个则不行 java注释 // /*...*/ jsp注释 \u0026lt;%-- --%\u0026gt;  JSP九大内置对象 （自带的，不需要new 也能使用的对象）\nout：输出对象，向客户端输出内容 pageContext: request：请求对象；存储“客户端向服务端发送的请求信息” reponse session application config 配置对象（服务器配置信息） page 当前JSP页面对象（相当于java中的this） exception 异常对象  request对象 request：请求对象；存储“客户端向服务端发送的请求信息”\nrequest对象的常见方法：\nString getParameter(String name) :根据请求的字段名key （input标签的name属性值） ，返回字段值value （input标签的value属性值） String[] getParameterValues(String name): 根据请求的字段名key ，返回多个字段值value （checkbox） void setCharacterEncoding(\u0026quot;编码格式utf-8\u0026quot;) ：设置post方式的请求编码 （tomcat7以前默认iso-8859-1，tomcat8以后改为了utf-8） getRequestDispatcher(\u0026quot;b.jsp\u0026quot;).forward(request,response) ; ：请求转发 的方式跳转页面 A - \u0026gt; B ServletContext getServerContext():获取项目的ServletContext对象  实例 注册\nregister.jsp ，show.jsp  register.jsp\n\u0026lt;form action=\u0026quot;show.jsp\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 用户名：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;uname\u0026quot; /\u0026gt;\u0026lt;br/\u0026gt; 密码：\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;upwd\u0026quot;/\u0026gt;\u0026lt;br/\u0026gt; 年龄：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;uage\u0026quot;/\u0026gt;\u0026lt;br/\u0026gt; 爱好\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;uhobbies\u0026quot; value=\u0026quot;足球\u0026quot;/\u0026gt;足球、 \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;uhobbies\u0026quot; value=\u0026quot;篮球\u0026quot;/\u0026gt;篮球、 \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;uhobbies\u0026quot; value=\u0026quot;乒乓球\u0026quot;/\u0026gt;乒乓球\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;注册\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  show.jsp\n\u0026lt;% //设置编码 request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;) ; String name = request.getParameter(\u0026quot;uname\u0026quot;) ; //name = new String( name.getBytes(\u0026quot;gbk\u0026quot;) , \u0026quot;utf-8\u0026quot;); get方式修改编码 int age = Integer.parseInt( request.getParameter(\u0026quot;uage\u0026quot;) ) ; String pwd = request.getParameter(\u0026quot;upwd\u0026quot;) ; String[] hobbies = request.getParameterValues(\u0026quot;uhobbies\u0026quot;) ; %\u0026gt; 注册成功，信息如下：\u0026lt;br/\u0026gt; 姓名：\u0026lt;%=name %\u0026gt;\u0026lt;br/\u0026gt; 年龄：\u0026lt;%=age %\u0026gt;\u0026lt;br/\u0026gt; 密码：\u0026lt;%=pwd %\u0026gt;\u0026lt;br/\u0026gt; 爱好：\u0026lt;br/\u0026gt; \u0026lt;% if(hobbies !=null){ for(String hobby :hobbies) { out.print(hobby +\u0026quot;\u0026amp;nbsp;\u0026quot;); } } %\u0026gt;  通过地址栏传参\nhttp://localhost:8888/MyJspProject/show.jsp?uname=aa\u0026amp;upwd=123\u0026amp;uage=22\u0026amp;uhobbies=%E7%AF%AE%E7%90%83 连接/文件？参数名1=参数值1 \u0026amp; 参数名2=参数值2 \u0026amp; 参数名1=参数值1  get提交方式: method=\u0026ldquo;get\u0026rdquo; 和 地址栏 、超链接(\u0026lt;a href=\u0026quot;xx\u0026quot;\u0026gt;)请求方式 默认都属于get提交方式\nget与post请求方式的区别  get方式 在地址栏显示 请求信息 (但是地址栏能够容纳的 信息有限，4-5KB；如果请求数据存在大文件，图片等 会出现地址栏无法容纳全部的数据而出错) ；post不会显示\n 文件上传操作，必须是post 推荐使用post\n  统一请求的编码 request get方式请求 如果出现乱码，解决：\n 统一每一个变量的 编码 （不推荐）\nnew String( 旧编码，新编码); name = new String(name.getBytes(\u0026quot;iso-8859-1\u0026quot;),\u0026quot;utf-8\u0026quot;);  修改server.xml ，一次性的 更改tomcat默认get提交方式的编码 （utf-8）(建议)\n使用tomcat时， 首先在server.xml中 统一get方式的编码..在修改端口号的标签中添加属性\nURIEncoding=\u0026quot;UTF-8\u0026quot;   tomcat7 (iso-8859-1)\ntomcat8（utf-8）\npost方式设置编码\nrequest.setCharacterEncoding(\u0026quot;utf-8\u0026quot;) ;  response 响应对象\n提供的方法：\nvoid addCookie( Cookie cookie ); 服务端向客户端增加cookie对象 void sendRedirect(String location ) throws IOException; :页面跳转的一种方式（重定向） void setContetType(String type):设置服务端响应的编码（设置服务端的contentType类型）  实例：登陆\nlogin.jsp -\u0026gt; check.jsp -\u0026gt;success.jsp login.jsp\n\u0026lt;form action=\u0026quot;check.jsp\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 用户名:\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;uname\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; 密码:\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;upwd\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;登陆\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/form\u0026gt;  check.jsp\n\u0026lt;% request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;) ; String name = request.getParameter(\u0026quot;uname\u0026quot;); String pwd = request.getParameter(\u0026quot;upwd\u0026quot;); if(name.equals(\u0026quot;zs\u0026quot;) \u0026amp;\u0026amp; pwd.equals(\u0026quot;abc\u0026quot;)){//假设 zs abc response.sendRedirect(\u0026quot;success.jsp\u0026quot;) ;//页面跳转：重定向， 导致数据丢失 //页面跳转：请求转发, 可以获取到数据，并且 地址栏 没有改变（仍然保留 转发时的页面check.jsp） //request.getRequestDispatcher(\u0026quot;success.jsp\u0026quot;).forward( request,response); }else{ //登陆失败 out.print(\u0026quot;用户名或密码有误！\u0026quot;) ; } %\u0026gt;  success.jsp\n登录成功！\u0026lt;br/\u0026gt; 欢迎您： \u0026lt;% String name = request.getParameter(\u0026quot;uname\u0026quot;) ; out.print(name) ; %\u0026gt;  请求转发和重定向的区别\n    请求转发 重定向     地址栏是否改变 不变(check.jsp) 改变(success.jsp)   是否保留第一次请求时的数据\u0026ndash;4种范围对象 保留 不保留   请求的次数 1 2   跳转发生的位置 服务端 客户端发出的第二次跳转    session(服务端) Cookie Cookie（客户端，不是内置对象）:Cookie是由 服务端生成的 ，再发送给客户端保存。\n相当于 本地缓存的作用： 客户端(hello.mp4,zs/abc)-\u0026gt;服务端(hello.mp4；zs/abc)\n作用：提高访问服务端的效率，但是安全性较差。\nCookie：\tname=value javax.servlet.http.Cookie  public Cookie(String name,String value) String getName()：获取name String getValue():获取value void setMaxAge(int expiry);最大有效期 （秒）  服务端准备Cookie：\nresponse.addCookie(Cookie cookie)  页面跳转（转发，重定向）\n客户端获取cookie:\nrequest.getCookies();   服务端增加cookie :response对象；客户端获取对象：request对象 不能直接获取某一个单独对象，只能一次性将 全部的cookie拿到\n\u0026lt;% //服务端 Cookie cookie1 = new Cookie(\u0026quot;name\u0026quot;,\u0026quot;zs\u0026quot;); Cookie cookie2 = new Cookie(\u0026quot;pwd\u0026quot;,\u0026quot;abc\u0026quot;); response.addCookie( cookie1 ); response.addCookie( cookie2 ); //页面跳转到客户端（转发、重定向） response.sendRedirect(\u0026quot;result.jsp\u0026quot;) ; %\u0026gt;  \u0026lt;% //客户端 Cookie[] cookies = request.getCookies(); for(Cookie cookie:cookies){ out.print(cookie.getName()+\u0026quot;--\u0026quot;+cookie.getValue() +\u0026quot;\u0026lt;br/\u0026gt;\u0026quot;); } %\u0026gt;   通过F12可以发现 除了自己设置的Cookie对象外，还有一个name为 JSESSIONID的cookie\n建议 cookie只保存 英文数字，否则需要进行编码、解码\ncookie保存位置\nC:\\Users\\26069\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\q4od5ob1.default-release-1573292012539\\cookies.sqlite  使用Cookie实现 记住用户名 功能 login.jsp--\u0026gt;check.jsp--\u0026gt;A.jap  login.jsp\n\u0026lt;%! String uname ; %\u0026gt; \u0026lt;% boolean flag = false ; Cookie[] cookies = request.getCookies() ; for(Cookie cookie :cookies){ if(cookie.getName().equals(\u0026quot;uname\u0026quot;)){ uname = cookie.getValue() ; flag = true ; } } if(!flag){//if(flag ==true) out.print(\u0026quot;cookie已失效！\u0026quot;); }else{ out.print(\u0026quot;cookie:\u0026quot;+uname); } %\u0026gt; \u0026lt;form action=\u0026quot;check.jsp\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 用户名:\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;uname\u0026quot; value=\u0026quot;\u0026lt;%=(uname==null?\u0026quot;\u0026quot;:uname)%\u0026gt;\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; 密码:\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;upwd\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;登陆\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/form\u0026gt;  check.jsp\n\u0026lt;% request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;) ; String name = request.getParameter(\u0026quot;uname\u0026quot;); String pwd = request.getParameter(\u0026quot;upwd\u0026quot;); //将用户名 加入到Cookie种 Cookie cookie = new Cookie(\u0026quot;uname\u0026quot;,name); cookie.setMaxAge(10) ; response.addCookie(cookie) ; response.sendRedirect(\u0026quot;A.jsp\u0026quot;) ; %\u0026gt;  session :会话 一次访问：\n 浏览网站：开始-关闭 购物： 浏览、付款、退出 电子邮件：浏览、写邮件、退出  开始-结束\nsession机制：\n客户端第一次请求服务端时，（jsessionid-sessionid匹配）服务端会产生一个session对象（用于保存该客户的信息）并且每个session对象 都会有一个唯一的 sessionId( 用于区分其他session);\n服务端由会 产生一个cookie，并且 该cookie的name=JSESSIONID ,value=服务端sessionId的值；\n然后 服务端会在 响应客户端的同时 将该cookie发送给客户端，至此 客户端就有了 一个cookie(JSESSIONID)；\n因此，客户端的cookie就可以和服务端的session一一对应（JSESSIONID - sessionID）\n客户端第二/n次请求服务端时:服务端会先用客户端cookie种的JSESSIONID 去服务端的session中匹配sessionid,如果匹配成功（cookie jsessionid和sesion sessionid），说明此用户 不是第一次访问,无需登录；\n例子：\n客户端： 顾客（客户端） 服务端: 存包处 - 商场(服务端)\n顾客第一次存包：商场 判断此人是 之前已经存过包（通过你手里是否有钥匙）。 如果是新顾客（没钥匙） ，分配一个钥匙 给该顾客； 钥匙 会和 柜子 一一对应；\n第二/n次 存包：商场 判断此人是 之前已经存过包（通过你手里是否有钥匙） 如果是老顾客（有钥匙），则不需要分配；该顾客手里的钥匙 会 和柜子 自动一一对应。\nsession:\n session存储在服务端 session是在 同一个用户（客户）请求时 共享 实现机制：第一次客户请求时 产生一个sessionid 并复制给 cookie的jsessionid 然后发给客户端。最终 通过session的sessionid-cookie的jsessionid  session方法 String getId() :获取sessionId boolean isNew() :判断是否是 新用户（第一次访问） void invalidate():使session失效 （退出登录、注销） void setAttribute() Object getAttribute(); void setMaxInactiveInterval(秒) ：设置最大有效 非活动时间 int getMaxInactiveInterval():获取最大有效 非活动时间  实例：\n登录 login.jsp\n\u0026lt;form action=\u0026quot;check.jsp\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 用户名:\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;uname\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; 密码:\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;upwd\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;登陆\u0026quot;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/form\u0026gt;  check.jsp\n\u0026lt;% request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;) ; String name = request.getParameter(\u0026quot;uname\u0026quot;); String pwd = request.getParameter(\u0026quot;upwd\u0026quot;); if(name.equals(\u0026quot;zs\u0026quot;) \u0026amp;\u0026amp; pwd.equals(\u0026quot;abc\u0026quot;)){//假设 zs abc //只有登录成功，session中才会存在uname /upwd session.setAttribute(\u0026quot;uname\u0026quot;, name)\t; session.setAttribute(\u0026quot;upwd\u0026quot;, pwd)\t; System.out.println(\u0026quot;sessionId\u0026quot;+session.getId()); //Cookie cookie = new Cookie(\u0026quot;uname\u0026quot; ,namxe); //response.addCookie(cookie) ; //服务端在第一次响应客户端时，会发送一个 JSESSIONID的cookie //session.setMaxInactiveInterval(10) ; request.getRequestDispatcher(\u0026quot;welcome.jsp\u0026quot;).forward(request, response) ; }else{ //登录失败 response.sendRedirect(\u0026quot;login.jsp\u0026quot;) ; } %\u0026gt;  invalidate.jsp\n\u0026lt;% session.invalidate() ;//session失效 response.sendRedirect(\u0026quot;login.jsp\u0026quot;) ; //session.removeAttribute(\u0026quot;uname\u0026quot;) ; %\u0026gt;  welcome.jsp\n欢迎您： \u0026lt;% String name = (String)session.getAttribute(\u0026quot;uname\u0026quot;) ; //如果 用户没有登录，而是直接 通过地址栏 访问welcome.jsp,则必然获取到的name是null if(name!=null){ out.print(name); System.out.println(); %\u0026gt; \u0026lt;a href=\u0026quot;invalidate.jsp\u0026quot;\u0026gt;注销\u0026lt;/a\u0026gt; \u0026lt;% }else{//如果没有登录，应该跳转登录页面 response.sendRedirect(\u0026quot;login.jsp\u0026quot;); } %\u0026gt;  A.jsp\n\u0026lt;% out.print(session.getAttribute(\u0026quot;uname\u0026quot;)); Cookie[] cookies = request.getCookies(); for(Cookie cookie:cookies){ if(cookie.getName().equals(\u0026quot;JSESSIONID\u0026quot;)){ System.out.print(\u0026quot;JSESSIONID\u0026quot;+cookie.getValue()); } } %\u0026gt;  客户端在第一次请求服务端时，如果服务端发现 此请求没有 JSESSIONID,则会创建一个 name=JSESIONID的cookie 并返回给客户端\n即使服务端并没有new Cookie对象\nCookie：\n 不是内对对象，要使用必须new 但是，服务端会 自动生成一个(服务端自动new一个cookie) name=JSESIONID的cookie 并返回给客户端  cookie和session的区别：\n    session cookie     保存的位置 服务端 客户端   安全性 较安全 较不安全   保存的内容 Object String    appliation 全局对象 方法\nString getContextPath() 虚拟路径 String getRealPath(String name): 绝对路径（虚拟路径 相对的绝对路径）  \u0026lt;%=\u0026quot;当前项目的虚拟路径：\u0026quot; +application.getContextPath() +\u0026quot;\u0026lt;br/\u0026gt;\u0026quot;\t%\u0026gt; \u0026lt;%=\u0026quot;虚拟路径对应的绝对路径：\u0026quot; +application.getRealPath(\u0026quot;/MyJspProject\u0026quot;) +\u0026quot;\u0026lt;br/\u0026gt;\u0026quot;\t%\u0026gt;  四种范围对象（小-\u0026gt;大）    pageContext JSP页面容器 当前页面有效     request 请求对象 同一次请求有效   session 会话对象 同一次会话有效   appliation 全局对象 全局有效（整个项目有效）    pageContext有些书上也叫（page对象，但不是九大内置对象的page）；\n以上4个对象共有的方法：\nObject getAttribute(String name):根据属性名，或者属性值 void setAttribute(String name,Object obj) :设置属性值（新增，修改） setAttribute(\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;) 如果a对象之前不存在，则新建一个a对象 ； 如果a之前已经存在，则将a的值改为b void removeAttribute(String name)：根据属性名，删除对象  pageContext 当前页面有效 (页面跳转后无效)\n\u0026lt;%\tpageContext.setAttribute(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;) ; request.getRequestDispatcher(\u0026quot;pc1.jsp\u0026quot;).forward(request, response) ; %\u0026gt; \u0026lt;%=pageContext.getAttribute(\u0026quot;hello\u0026quot;) %\u0026gt;  request 同一次请求有效；其他请求无效 （请求转发后有效；重定向后无效）\n\u0026lt;% request.setAttribute(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;) ; request.getRequestDispatcher(\u0026quot;rq1.jsp\u0026quot;).forward(request, response) ; //response.sendRedirect(\u0026quot;rq1.jsp\u0026quot; ) ; %\u0026gt;  \u0026lt;%=request.getAttribute(\u0026quot;hello\u0026quot;) %\u0026gt;  session 同一次会话有效 （无论怎么跳转，都有效；关闭/切换浏览器后无效 ； 从 登陆-\u0026gt;退出 之间 全部有效）\n\u0026lt;% session.setAttribute(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;) ; //request.getRequestDispatcher(\u0026quot;rq1.jsp\u0026quot;).forward(request, response) ; response.sendRedirect(\u0026quot;ss1.jsp\u0026quot; ) ; %\u0026gt;  application 全局变量；整个项目运行期间 都有效 (切换浏览器 仍然有效)；关闭服务、其他项目 无效\n-\u0026gt;多个项目共享、重启后仍然有效 ：JNDI\n\u0026lt;%\tapplication.setAttribute(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;) ; //request.getRequestDispatcher(\u0026quot;rq1.jsp\u0026quot;).forward(request, response) ; response.sendRedirect(\u0026quot;ap1.jsp\u0026quot; ) ; %\u0026gt;  小结  以上的4个范围对象，通过 setAttribute()复制，通过getAttribute()取值；\n 以上范围对象，尽量使用最小的范围。因为对象的范围越大，造成的性能损耗越大。\n  JDBC Java DataBase Connectivity 可以为多种关系型数据库DBMS 提供统一的访问方式，用Java来操作数据库\nJDBC API 主要功能\n三件事，具体是通过以下类/接口实现：\nDriverManager ： 管理jdbc驱动 Connection： 连接（通过DriverManager产生） Statement（PreparedStatement） ：增删改查 （通过Connection产生 ） CallableStatement ： 调用数据库中的 存储过程/存储函数 （通过Connection产生 ） Result ：返回的结果集 （上面的Statement等产生 ）  Connection 产生操作数据库的对象：\nConnection产生Statement对象：createStatement() Connection产生PreparedStatement对象：prepareStatement() Connection产生CallableStatement对象：prepareCall();  Statement 操作数据库：\n增删改：executeUpdate() 查询：executeQuery();  ResultSet 保存结果集 select * from xxx\nnext():光标下移，判断是否有下一条数据；true/false previous(): true/false getXxx(字段名|位置):获取具体的字段值  PreparedStatement 操作数据库：\npublic interface PreparedStatement extends Statement  因此\n增删改：executeUpdate() 查询：executeQuery();  \u0026ndash;此外\n赋值操作 setXxx();  PreparedStatement与Statement在使用时的区别：\n Statement:\nsql executeUpdate(sql)  PreparedStatement:\nsql(可能存在占位符?)  在创建PreparedStatement 对象时，将sql预编译\nprepareStatement(sql) executeUpdate() setXxx()替换占位符？   推荐使用PreparedStatement：原因如下：\n 编码更加简便（避免了字符串的拼接）\nString name = \u0026quot;zs\u0026quot; ; int age = 23 ;   stmt:\nString sql =\u0026quot; insert into student(stuno,stuname) values('\u0026quot;+name+\u0026quot;', \u0026quot;+age+\u0026quot; ) \u0026quot; ; stmt.executeUpdate(sql);  pstmt:\nString sql =\u0026quot; insert into student(stuno,stuname) values(?,?) \u0026quot; ; pstmt = connection.prepareStatement(sql);//预编译SQL pstmt.setString(1,name); pstmt.setInt(2,age);   提高性能(因为 有预编译操作，预编译只需要执行一次) 需要重复增加100条数\n stmt:\n String sql =\u0026quot; insert into student(stuno,stuname) values('\u0026quot;+name+\u0026quot;', \u0026quot;+age+\u0026quot; ) \u0026quot; ; for(100) stmt.executeUpdate(sql);  pstmt:\nString sql =\u0026quot; insert into student(stuno,stuname) values(?,?) \u0026quot; ; pstmt = connection.prepareStatement(sql);//预编译SQL pstmt.setString(1,name); pstmt.setInt(2,age); for( 100){ pstmt.executeUpdate(); }   安全（可以有效防止sql注入）\nsql注入：将客户输入的内容和开发人员的SQL语句 混为一体\n stmt:存在被sql注入的风险\n(例如输入 用户名：任意值 \u0026lsquo; or 1=1 \u0026ndash; 密码：任意值)\n分析：\nselect count(*) from login where uname='任意值 ' or 1=1 --' and upwd ='任意值' ; 简化 select count(*) from login where uname='任意值 ' or 1=1 ; 简化 select count(*) from login ;  登陆时输入 xxx \u0026lsquo; or 1=1 \u0026ndash;\n pstmt:有效防止sql注入\nselect count(*) from login where uname='\u0026quot;+name+\u0026quot;' and upwd ='\u0026quot;+pwd+\u0026quot;'   推荐使用pstmt\n  jdbc访问数据库的具体步骤：  导入驱动，加载具体的驱动类 与数据库建立连接 发送sql，执行 处理结果集 （查询）  数据库驱动 Oracle\n驱动jar ojdbc-x.jar 具体驱动类 oracle.jdbc.OracleDriver 连接字符串 jdbc:oracle:thin:@localhost:1521:ORCL  MySQL\n驱动jar mysql-connector-java-x.jar 具体驱动类 com.mysql.jdbc.Driver 连接字符串 jdbc:mysql://localhost:3306/数据库实例名  SqlServer\n驱动jar sqljdbc-x.jar 具体驱动类 com.microsoft.sqlserver.jdbc.SQLServerDriver 连接字符串 jdbc:microsoft:sqlserver:localhost:1433;databasename=数据库实例名  使用jdbc操作数据库时，如果对数据库进行了更换，只需要替换：驱动、具体驱动类、连接字符串、用户名、密码\npublic class JDBCDemo { private static final String URL = \u0026quot;jdbc:oracle:thin:@localhost:1521:ORCL\u0026quot;; private static final String USERNAME = \u0026quot;scott\u0026quot;; private static final String PWD = \u0026quot;tiger\u0026quot;; public static void update() {// 增删改 Connection connection = null; Statement stmt = null; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); // c.发送sql，执行(增删改、查) stmt = connection.createStatement(); //String sql = \u0026quot;insert into student values(1,'zs',23,'s1')\u0026quot;; //String sql = \u0026quot;update student set STUNAME='ls' where stuno=1\u0026quot;; String sql = \u0026quot;delete from student where stuno=1\u0026quot;; // 执行SQL int count = stmt.executeUpdate(sql); // 返回值表示 增删改 几条数据 // d.处理结果 if (count \u0026gt; 0) { System.out.println(\u0026quot;操作成功！\u0026quot;); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(stmt!=null) stmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } } public static void query() { Connection connection = null; Statement stmt = null; ResultSet rs = null ; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); // c.发送sql，执行(增删改、【查】) stmt = connection.createStatement(); //String sql = \u0026quot;select stuno,stuname from student\u0026quot;; Scanner input= new Scanner(System.in); System.out.println(\u0026quot;请输入用户名：\u0026quot;); String name = input.nextLine() ; System.out.println(\u0026quot;请输入密码：\u0026quot;); String pwd = input.nextLine() ; String sql = \u0026quot;select count(*) from login where uname='\u0026quot;+name+\u0026quot;' and upwd ='\u0026quot;+pwd+\u0026quot;' \u0026quot; ; //String sql = \u0026quot;select * from student where stuname like '%\u0026quot;+name+\u0026quot;%'\u0026quot;; // 执行SQL(增删改executeUpdate()，查询executeQuery()) rs = stmt.executeQuery(sql); // 返回值表示 增删改 几条数据 // d.处理结果 //\twhile(rs.next()) { //\tint sno = rs.getInt( \u0026quot;stuno\u0026quot;) ; //\tString sname = rs.getString(\u0026quot;stuname\u0026quot;) ; ////\tint sno = rs.getInt(1) ; //下标：从1开始计数 ////\tString sname = rs.getString(2) ; //\tSystem.out.println(sno+\u0026quot;--\u0026quot;+sname); //\t} int count = -1; if(rs.next()) { count = rs.getInt(1) ; } if(count\u0026gt;0) { System.out.println(\u0026quot;登陆成功！\u0026quot;); }else { System.out.println(\u0026quot;登陆失败！\u0026quot;); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(rs!=null) rs.close(); if(stmt!=null) stmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } } }  public class JDBCPreparedStatementDemo { private static final String URL = \u0026quot;jdbc:oracle:thin:@localhost:1521:ORCL\u0026quot;; private static final String USERNAME = \u0026quot;scott\u0026quot;; private static final String PWD = \u0026quot;tiger\u0026quot;; public static void update() {// 增删改 Connection connection = null; PreparedStatement pstmt = null; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); //PreparedStatement String sql = \u0026quot;insert into student values(?,?,?,?)\u0026quot;; pstmt = connection.prepareStatement(sql);//预编译 pstmt.setInt(1, 36); pstmt.setString(2, \u0026quot;zhangsan\u0026quot;); pstmt.setInt(3, 56); pstmt.setString(4, \u0026quot;s3\u0026quot;); int count =pstmt.executeUpdate() ; // d.处理结果 if (count \u0026gt; 0) { System.out.println(\u0026quot;操作成功！\u0026quot;); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(pstmt!=null) pstmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } } public static void query() { Connection connection = null; PreparedStatement pstmt = null; ResultSet rs = null ; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); // c.发送sql，执行(增删改、【查】) Scanner input= new Scanner(System.in); System.out.println(\u0026quot;请输入用户名：\u0026quot;); String name = input.nextLine() ; System.out.println(\u0026quot;请输入密码：\u0026quot;); String pwd = input.nextLine() ; //String sql = \u0026quot;select * from student where stuname like '%\u0026quot;+name+\u0026quot;%'\u0026quot;; //String sql = \u0026quot;select * from student where stuname like ?\u0026quot;; String sql =\u0026quot;select count(*) from login where uname= ? and upwd =?\u0026quot;; pstmt = connection.prepareStatement(sql) ; pstmt.setString(1, name); pstmt.setString(2, pwd); //String sql = \u0026quot;select stuno,stuname from student\u0026quot;; // 执行SQL(增删改executeUpdate()，查询executeQuery()) rs = pstmt.executeQuery(); // 返回值表示 增删改 几条数据 // d.处理结果 int count = -1; if(rs.next()) { count = rs.getInt(1) ; } if(count\u0026gt;0) { System.out.println(\u0026quot;登陆成功！\u0026quot;); }else { System.out.println(\u0026quot;登陆失败！\u0026quot;); } } catch (ClassNotFoundException e) { System.out.println(\u0026quot;111\u0026quot;); e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(rs!=null) rs.close(); if(pstmt!=null) pstmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); }catch(Exception e) { e.printStackTrace(); } } } }  jdbc总结 （模板、八股文）：\ntry{ a.导入驱动包、加载具体驱动类Class.forName(\u0026quot;具体驱动类\u0026quot;); b.与数据库建立连接connection = DriverManager.getConnection(...); c.通过connection，获取操作数据库的对象（Statement\\preparedStatement\\callablestatement） stmt = connection.createStatement(); d.(查询)处理结果集rs = pstmt.executeQuery() while(rs.next()){ rs.getXxx(..) ;} }catch(ClassNotFoundException e ) { ...} catch(SQLException e) {... } catch(Exception e) {... } finally { //打开顺序，与关闭顺序相反 if(rs!=null)rs.close() if(stmt!=null) stmt.close(); if(connection!=null)connection.close(); }  \u0026ndash;jdbc中，除了Class.forName() 抛出ClassNotFoundException，其余方法全部抛SQLException\nCallableStatement 调用 存储过程、存储函数\nconnection.prepareCall(参数：存储过程或存储函数名)  参数格式：\n存储过程（无返回值return，用out参数替代）：\n{ call 存储过程名(参数列表) }  存储函数（有返回值return）：\n{ ? = call 存储函数名(参数列表) }  创建存储过程\ncreate or replace procedure addTwoNum ( num1 in number,num2 in number,result out number ) as begin result := num1+num2 ; end ; /  强调： 如果通过sqlplus 访问数据库，只需要开启：\nOracleServiceSID  通过其他程序访问数据（sqldevelop、navicate、JDBC），需要开启：\nOracleServiceSID、XxxListener  public static void invokeProcedure() { Connection connection = null; CallableStatement cstmt = null; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); // c.发送sql，执行(增删改、查) num1+num2 -\u0026gt;num3 cstmt = connection.prepareCall( \u0026quot;{ call addTwoNum(?,?,?) }\u0026quot; ) ; cstmt.setInt(1, 30); cstmt.setInt(2, 40); //设置输出参数的类型 cstmt.registerOutParameter(3, Types.INTEGER); cstmt.execute() ;//num1+num2 ,execute()之前处理 输入参数以及输出参数类型，之后接受输出参数值 int result = cstmt.getInt(3) ;//获取计算结果 System.out.println(result); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(cstmt!=null) cstmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } }  JDBC调用存储过程的步骤：\n 产生 调用存储过程的对象（CallableStatement） cstmt = connection.prepareCall( \u0026quot;...\u0026quot; ) ; 通过setXxx()处理 输出参数值 cstmt.setInt(1, 30); 通过 registerOutParameter(\u0026hellip;)处理输出参数类型 cstmt.execute()执行 接受 输出值（返回值）getXxx()  调存储函数： 创建存储函数\ncreate or replace function addTwoNumfunction ( num1 in number,num2 in number) -- 1 + 2 return number as result number ;\tbegin result := num1+num2 ; return result ; end ; /  调用存储函数\npublic static void invokeFunction() { Connection connection = null; CallableStatement cstmt = null; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); // c.发送sql，执行(增删改、查) num1+num2 -\u0026gt;num3 cstmt = connection.prepareCall( \u0026quot;{? = call addTwoNumfunction\t(?,?) }\u0026quot; ) ; cstmt.setInt(2, 30); cstmt.setInt(3,40); cstmt.registerOutParameter(1, Types.INTEGER); cstmt.execute() ;//num1+num2 ,execute()之前处理 输入参数以及输出参数类型，之后接受输出参数值 //设置输出参数的类型 int result = cstmt.getInt(1) ;//获取计算结果 System.out.println(result); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(cstmt!=null) cstmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } }  JDBC调用存储函数：与调存储过程的区别：\n在调用时，注意参数位置\n处理CLOB/BLOB类型 CLOB：大文本数据\nBLOB：二进制文件\n处理稍大型数据：\n 方法一\n存储路径 E:\\JDK_API_zh_CN.CHM\n通过JDBC存储文件路径，然后 根据IO操作处理\n例如：JDBC将 E:\\JDK_API_zh_CN.CHM 文件 以字符串形式“E:\\JDK_API_zh_CN.CHM”存储到数据库中\n获取：\n 获取该路径“E:\\JDK_API_zh_CN.CHM”\n IO\n  方法二\n直接将数据存放到数据库中\n  clob:大文本数据 字符流 Reader Writer\n创建表\ncreate table mynovel(id number primary key,novel clob);  通过jdbc存储大文本数据（小说）CLOB\n//通过jdbc存储大文本数据（小说）CLOB //设置CLOB类型：setCharacterStream public static void clobDemo() { Connection connection = null; PreparedStatement pstmt = null; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); String sql = \u0026quot;insert into mynovel values(?,?)\u0026quot;; // c.发送sql，执行(增删改、查) pstmt = connection.prepareStatement(sql); pstmt.setInt(1, 1); File file = new File(\u0026quot;E:\\\\all.txt\u0026quot;); InputStream in = new FileInputStream( file) ; Reader reader = new InputStreamReader( in ,\u0026quot;UTF-8\u0026quot;) ;//转换流 可以设置编码 pstmt.setCharacterStream(2, reader, (int)file.length()); int count =pstmt.executeUpdate() ; // d.处理结果 if (count \u0026gt; 0) { System.out.println(\u0026quot;操作成功！\u0026quot;); } reader.close(); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(pstmt!=null) pstmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } }  步骤\n 先通过pstmt 的?代替小说内容 （占位符）\n 再通过pstmt.setCharacterStream(2, reader, (int)file.length()); 将上一步的？替换为 小说流， 注意第三个参数需要是 Int类型\n  读取小说\n//读取小说 public static void clobReaderDemo() { Connection connection = null; PreparedStatement pstmt = null; ResultSet rs = null ; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); String sql = \u0026quot;select NOVEL from mynovel where id = ? \u0026quot;; // c.发送sql，执行(查) pstmt = connection.prepareStatement(sql); pstmt.setInt(1, 1); rs = pstmt.executeQuery() ; //setXxxx getXxxx setInt getInt if(rs.next()) { Reader reader = rs.getCharacterStream(\u0026quot;NOVEL\u0026quot;) ; Writer writer = new FileWriter(\u0026quot;src/小说.txt\u0026quot;); char[] chs = new char[100] ; int len = -1; while( (len = reader.read(chs)) !=-1 ) { writer.write( chs,0,len ); } writer.close(); reader.close(); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(pstmt!=null) pstmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } }  读取步骤\n 通过Reader reader = rs.getCharacterStream(\u0026ldquo;NOVEL\u0026rdquo;) ; 将cloc类型的数据 保存到Reader对象中 将Reader通过Writer输出即可。  blob: 二进制 字节流 InputStream OutputStream\n与CLOB步骤基本一致，区别：\nsetBinaryStream(...) getBinaryStream(...)  创建表\ncreate table mymusic(id number primary key,music blob);  通过jdbc存储二进制类型 （mp3）\n//通过jdbc存储二进制类型 （mp3） //设置BLOB类型： public static void blobDemo() { Connection connection = null; PreparedStatement pstmt = null; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); String sql = \u0026quot;insert into mymusic values(?,?)\u0026quot;; // c.发送sql，执行(增删改、查) pstmt = connection.prepareStatement(sql); pstmt.setInt(1, 1); File file = new File(\u0026quot;d:\\\\luna.mp3\u0026quot;); InputStream in = new FileInputStream(file ); pstmt.setBinaryStream(2,in ,(int)file.length() ); int count =pstmt.executeUpdate() ; // d.处理结果 if (count \u0026gt; 0) { System.out.println(\u0026quot;操作成功！\u0026quot;); } in.close(); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(pstmt!=null) pstmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } }  读取二进制文件\n//读取二进制文件 public static void blobReaderDemo() { Connection connection = null; PreparedStatement pstmt = null; ResultSet rs = null ; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); String sql = \u0026quot;select music from mymusic where id = ? \u0026quot;; // c.发送sql，执行(查) pstmt = connection.prepareStatement(sql); pstmt.setInt(1, 1); rs = pstmt.executeQuery() ; if(rs.next()) { InputStream in = rs.getBinaryStream(\u0026quot;music\u0026quot;) ; OutputStream out = new FileOutputStream(\u0026quot;src/music.mp3\u0026quot;) ; byte[] chs = new byte[100] ; int len = -1; while( (len = in.read(chs)) !=-1 ) { out.write( chs,0,len ); } out.close(); in.close(); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(pstmt!=null) pstmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } }  JSP访问数据库 JSP就是在html中嵌套的java代码，因此 java代码可以写在jsp中（\u0026lt;% \u0026hellip; %\u0026gt;）\n导包操作： java项目 ：\n Jar复制到工程中 右键该Jar :build path -\u0026gt;add to build Path  Web项目：\n jar复制到WEB-INF/lib  核心：就是将 java中的JDBC代码，复制到 JSP中的\u0026lt;% \u0026hellip; %\u0026gt;\nindex.jsp\n\u0026lt;form action=\u0026quot;check.jsp\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 用户名：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;uname\u0026quot; /\u0026gt;\u0026lt;br/\u0026gt; 密码：\u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;upwd\u0026quot; /\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;登录\u0026quot; /\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/form\u0026gt;  check.jsp\n\u0026lt;%@ page import=\u0026quot;java.sql.*\u0026quot; %\u0026gt; \u0026lt;% String URL = \u0026quot;jdbc:oracle:thin:@localhost:1521:ORCL\u0026quot;; String USERNAME = \u0026quot;scott\u0026quot;; String PWD = \u0026quot;tiger\u0026quot;; Connection connection = null; Statement stmt = null; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); // c.发送sql，执行(增删改、查) stmt = connection.createStatement(); String name =request.getParameter(\u0026quot;uname\u0026quot;); String pwd = request.getParameter(\u0026quot;upwd\u0026quot;); String sql = \u0026quot;select count(*) from login where uname='\u0026quot;+name+\u0026quot;' and upwd ='\u0026quot;+pwd+\u0026quot;' \u0026quot; ; // 执行SQL(增删改executeUpdate()，查询executeQuery()) rs = stmt.executeQuery(sql); // 返回值表示 增删改 几条数据 // d.处理结果 int count = -1; if(rs.next()) { count = rs.getInt(1) ; } if(count\u0026gt;0) { System.out.println(\u0026quot;登陆成功！\u0026quot;); }else { System.out.println(\u0026quot;登陆失败！\u0026quot;); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } finally { try { if(rs!=null) rs.close(); if(stmt!=null) stmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } %\u0026gt;  注意：如果jsp出现错误：The import Xxx cannot be resolved\n尝试解决步骤：\n (可能是Jdk、tomcat版本问题) 右键项目-\u0026gt;build path，将其中 报错的 libary或Lib 删除后 重新导入\n 清空各种缓存：右键项目-\u0026gt;Clean tomcat\u0026hellip; clean （Project -clean或者 进tomcat目录 删除里面work的子目录）\n 删除之前的tomcat，重新解压缩、配置tomcat，重启计算机\n 如果类之前没有包，则将该类加入包中\n  JavaBean 刚才我们将 jsp中 登录操作的代码 转移到了LoginDao.java；其中LoginDao类 就称之为JavaBean。 JavaBean的作用： 1. 减轻的jsp复杂度\n1. 提高代码复用（以后任何地方的 登录操作，都可以通过调用LoginDao实现）\nloginDao.java\npublic class LoginDao { //1:登录成功 0：登录失败（用户名或密码有误） -1：系统异常 public int login(Login login) { String URL = \u0026quot;jdbc:oracle:thin:@localhost:1521:ORCL\u0026quot;; String USERNAME = \u0026quot;scott\u0026quot;; String PWD = \u0026quot;tiger\u0026quot;; Connection connection = null; Statement stmt = null; ResultSet rs = null ; try { // a.导入驱动，加载具体的驱动类 Class.forName(\u0026quot;oracle.jdbc.OracleDriver\u0026quot;);// 加载具体的驱动类 // b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PWD); // c.发送sql，执行(【查】) stmt = connection.createStatement(); String sql = \u0026quot;select count(*) from login where uname='\u0026quot;+login.getName()+\u0026quot;' and upwd ='\u0026quot;+login.getPwd()+\u0026quot;' \u0026quot; ; rs = stmt.executeQuery(sql); // 返回值表示 增删改 几条数据 // d.处理结果 int count = -1; if(rs.next()) { count = rs.getInt(1) ; } return count ; } catch (ClassNotFoundException e) { e.printStackTrace(); return -1 ; } catch (SQLException e) { e.printStackTrace(); return -1 ; } catch(Exception e) { e.printStackTrace(); return -1 ; } finally { try { if(rs!=null) rs.close(); if(stmt!=null) stmt.close();// 对象.方法 if(connection!=null)connection.close(); }catch(SQLException e) { e.printStackTrace(); } } }  check.jsp\n\u0026lt;%@ page import=\u0026quot;org.lanqiao.dao.LoginDao\u0026quot; %\u0026gt; \u0026lt;% String name = request.getParameter(\u0026quot;uname\u0026quot;) ; String pwd = request.getParameter(\u0026quot;upwd\u0026quot;) ; Login login = new Login(name,pwd) ; LoginDao dao = new LoginDao(); int result = dao.login(login) ; if(result \u0026gt;0){ out.print(\u0026quot;登录成功！\u0026quot;); }else if(result==0){ out.print(\u0026quot;用户名或密码有误！！\u0026quot;); }else{ out.print(\u0026quot;系统异常！！\u0026quot;); } %\u0026gt;  Login.java\npublic class Login { private int id ; private String name; private String pwd ; public Login() { } public Login(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public Login( String name, String pwd) { this.name = name; this.pwd = pwd; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } }  JavaBean（就是一个Java类）的定义：满足一下2点 ，就可以称为JavaBean\n public 修饰的类 ,public 无参构造 所有属性(如果有) 都是private，并且提供set/get (如果boolean 则get 可以替换成is)  使用层面，Java分为2大类：\n 封装业务逻辑的JavaBean (LoginDao.java封装了登录逻辑)逻辑\n可以将jsp中的JDBC代码，封装到Login.java类中 （Login.java）\n 封装数据的JavaBean （实体类，Student.java Person.java ）数据\n对应于数据库中的一张表\nLogin login = new Login(uname,upwd) ;//即用Login对象 封装了2个数据（用户名 和密码）\n  封装数据的JavaBean 对应于数据库中的一张表 (Login(name,pwd))\n封装业务逻辑的JavaBean 用于操作 一个封装数据的JavaBean\n可以发现，JavaBean可以简化 代码(jsp-\u0026gt;jsp+java)、提供代码复用(LoginDao.java)\nMVC设计模式  M：Model，模型 ：一个功能。用JavaBean实现。\n V:View，视图： 用于展示、以及与用户交互。使用html js css jsp jquery等前端技术实现\n C:Controller，控制器 ：接受请求，将请求跳转到模型进行处理；模型处理完毕后，再将处理的结果\n返回给 请求处 。 可以用jsp实现， 但是一般建议使用 Servlet实现控制器。\n  Jsp-\u0026gt;Java(Servlet)-\u0026gt;JSP\nServlet Java类必须符合一定的 规范：\n 必须继承 javax.servlet.http.HttpServlet 重写其中的 doGet()或doPost()方法\ndoGet()： 接受 并处 所有get提交方式的请求 doPost()：接受 并处 所有post提交方式的请求   public class WelcomeServlet extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026quot;doGet...\u0026quot;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //System.out.println(\u0026quot;doPost...\u0026quot;); this.doGet(req, resp); } }  \u0026lt;a href=\u0026quot;/Servlet25Project/WelcomeServlet\u0026quot;\u0026gt;WelcomeServlet\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;form action=\u0026quot;/WelcomeServlet\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; \u0026gt; \u0026lt;/form\u0026gt;   Servlet要想使用，必须配置\n Serlvet2.5：web.xml Servle3.0： @WebServlet  Serlvet2.5 web.xml:\n\u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;WelcomeServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.lanqiao.servlet.WelcomeServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;WelcomeServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/WelcomeServlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;  项目的根目录：WebContent 、src\n\u0026lt;a href=\u0026quot;WelcomeServlet\u0026quot;\u0026gt;所在的jsp是在 WebContent目录中，因此 发出的请求WelcomeServlet 是去请求项目的根目录(/)。\nServlet流程： 请求 -\u0026gt;\u0026lt;url-pattern\u0026gt; -\u0026gt; 根据\u0026lt;servlet-mapping\u0026gt;中的\u0026lt;servlet-name\u0026gt;去匹配 \u0026lt;servlet\u0026gt; 中的\u0026lt;servlet-name\u0026gt;，然后寻找到\u0026lt;servlet-class\u0026gt;，求中将请求交由该\u0026lt;servlet-class\u0026gt;执行。\n创建servlet\n 纯手工方法创建第一个Servlet\n步骤：\n 编写一个类，继承HttpServlet\n 重写doGet()、doPost()方法\n 编写web.xml 中的servlet映射关系\n  借助于Eclipse快速生成Servlet\n直接新建Servlet即可！（继承、重写、web.xml 可以借助Eclipse自动生成）\n  Servlet3.0，与Servlet2.5的区别：\nServlet3.0不需要在web.xml中配置，但 需要在 Servlet类的定义处之上编写 注解@WebServlet(\u0026ldquo;url-pattern的值\u0026rdquo;)\n匹配流程： 请求地址 与@WebServlet中的值 进行匹配，如果匹配成功 ，则说明 请求的就是该注解所对应的类\n项目根目录 项目根目录：WebContent、src（所有的构建路径）\n例如：\nWebContent中有一个文件index.jsp src中有一个Servlet.java  如果: index.jsp中请求 \u0026lt;a href=\u0026quot;abc\u0026quot;\u0026gt;...\u0026lt;/a\u0026gt; ，则 寻找范围：既会在src根目录中找 也会在WebContent根目录中找\n如果：index.jsp中请求\u0026lt;a href=\u0026quot;a/abc\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;，寻找范围：先在src或WebContent中找a目录，然后再在a目录中找abc\n web.xml中的 /:代表项目根路径\nhttp://localhost:8888/Servlet25Project/  jsp中的/: 服务器根路径\nhttp://localhost:8888/   构建路径、WebContent:根目录\nServlet生命周期：5个阶段  加载 :Servlet容器自动处理 初始化： init() ，该方法会在 Servlet被加载并实例化的以后 执行 服务 ：service() -\u0026gt;doGet() doPost 销毁 ：destroy()， Servlet被系统回收时执行 卸载 :Servlet容器自动处理  init():  默认第一次访问 Servlet时会被执行 （只执行这一次）\n 可以修改为 Tomcat启动时自动执行\n Servlet2.5： web.xml\n\u0026lt;servlet\u0026gt; ... \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt;  其中的“1”代表第一个。\n Servlet3.0\n@WebServlet( value=\u0026quot;/WelcomeServlet\u0026quot; ,loadOnStartup=1 )    service() -\u0026gt;doGet() doPost ：调用几次，则执行几次\ndestroy()：关闭tomcat服务时，执行一次。\nServlet API 由两个软件包组成： 对应于HTTP协议的软件包、对应于除了HTTP协议以外的其他软件包\n即Servlet API可以适用于 任何 通信协议。\n我们学习的Servlet,是位于javax.servlet.http包中的类和接口，是基础HTTP协议。\nServlet继承关系 ServletConfig:接口\nServletContext getServletContext():获取Servlet上下文对象 application String getInitParameter(String name):在当前Servlet范围内，获取名为name的参数值（初始化参数）  ServletContext中的常见方法(application)：\ngetContextPath():相对路径 getRealPath()：绝对路径 setAttribute() 、getAttribute() ---\u0026gt; String getInitParameter(String name);在当前Web容器范围内(范围更大，包含了servlet)，获取名为name的参数值（初始化参数）  servlet2.5方式设置参数值\n在整个web容器中设置初始化参数\n \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;globalParam\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;global value..\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt;  在servlet中设置初始化参数\n\u0026lt;servlet\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;servletparamname\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;servletparamvalue...\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/servlet\u0026gt;  获取值\npublic void init() throws ServletException { System.out.println(\u0026quot;init...\u0026quot;); //获取当前Servlet的初始化参数 String value = super.getInitParameter(\u0026quot;servletparamname\u0026quot;) ; System.out.println(\u0026quot;当前Servlet的参数servletparamname的值是：\u0026quot;+value); //获取当前Web容器的初始化参数 ServletContext servletContext = super.getServletContext() ; String globalValue = servletContext.getInitParameter(\u0026quot;globalParam\u0026quot;) ; System.out.println(\u0026quot;当前Web容器的 参数globalValue的值是：\u0026quot;+globalValue); }  Servlet3.0方式 给当前Servlet设置初始值：\n@WebServlet( .... , initParams= {@WebInitParam(name=\u0026quot;serveltparaname30\u0026quot;,value=\u0026quot;servletparavalue30\u0026quot;)})  注意，此注解只 隶属于某一个具体的Servlet ，因此无法为 整个web容器设置初始化参数 （如果要通过3.0方式设置 web容器的初始化参数，仍然需要在web.xml中设置）\n全局的servlet值在web.xml中设置\nHttpServletRequest中的方法：(同request)，例如\nsetAttrite()、getCookies()、getMethod() HttpServletResponse中的方法：同response  Servlet使用层面：\nEclipse中在src创建一个Servlet，然后重写doGet() doPost()就可以 （doGet() doPost()只需要编写一个）。\nMVC案例 三层架构 与MVC设计模式的目标一致：都是为了解耦合、提高代码的复用；\n三层组成：\n表示层（USL,User Show Layer; 视图层）\n 表示层前台代码（jsp，html js css用于和用户交互，界面的显示 代码位子WebContent）\n 表示层后台代码（servlet用于控制跳转、调用业务逻辑层 在src中的xxx.servlet包中）  业务逻辑层(BLL,Business Logic Layer; service )(逻辑。可拆（也是功能 可以拆分）\n调用数据访问层的方法 一般在src中的xxx.service包中)组装数据访问层 带逻辑性的操作（增删改查 删：查+删）接受表示层的请求调用\n数据访问层(DAL,Data Acess Layer; Dao层\n一般位于src中的xxx.dao包)（原子性 不可拆，各种功能方法）直接访问数据库原子性的操作（增删改查）\nMVC和三层的关系 mvc\nV对应三层里面表示层的前台代码\nC对应三层里面表示层后台diamante\nM对应业务逻辑层和数据访问层\nM里面的封装数据的JavaBean对应业务逻辑层和数据访问层\n封装数据的JavaBean对应实体类（不在三层架构当中，但是三层架构借助实体类封装数据传递数据）\njsp的对象在servlet怎么使用\n out: PrintWriter out = response.getWriter();\n session:request.getSession();\n applicayion: request.getServletContext();\n  设置编码  设置请求编码\n页面向数据库传东西 数据库出现乱码\nrequest.setCharacterEncoding(\u0026quot;utf-8\u0026quot;);   出现乱码要设置相应的编码\n 设置响应编码\n数据库向页面传东西 页面出现乱码\nresponse.setContentType(\u0026quot;text/html; charset=UTF-8\u0026quot; ); response.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); PrintWriter out = response.getWriter();   三层\n三层间的关系：上层将请求传递给下层，下层处理后返回给上层\n上层依赖下层\n依赖：代码的理解，就是持有成员变量\n流程解析  表示层前台 add.jsp (form action=\u0026ldquo;\u0026hellip;Servlet\u0026rdquo; 用户输入数据)\n 表示层后台addStuServlet(获取数据 封装数据 调用Service中的方法)\n 业务逻辑层 StudentService\naddStudent(student) （调用数据访问层的方法）  数据访问层 StudentDao\nisExist(student)（访问数据库） addStudent(student)（访问数据库）  数据库\n  每一个方法都有返回值 调用方法结束后要根据返回值进行相应的操作\njsp\u0026mdash;》servlet\u0026mdash;》service\u0026ndash;》Dao\u0026ndash;》数据库\nservlet:一个servlet对应一个功能\n因此增删改查四个功能写四个servlet\n三层优化  加入接口\n建议面向接口开发：先接口-再实现类\n\u0026ndash;service、dao加入接口\n\u0026ndash;接口与实现类的命名规范\n接口：interface，起名 ：I实体类Service\nIStudentService IStudentDao  实现类：implements起名 ：实体类ServiceImpl\nStudentServiceImpl StudentDaoImpl  接口所在的包：\nxxx.service xx.dao  实现类所在的包：\nxxx.service.impl xx.dao.impl  以后使用接口/实现类时，推荐写法：\n接口 x = new 实现类(); IStudentDao studentDao = new StudentDaoImpl();  DBUtil 通用的数据库帮助类，可以简化Dao层的代码量\n帮助类 一般建议写在 xxx.util包\n  方法重构： 将多个方法 的共同代码 提炼出来，单独写在一个方法中，然后引入该方法即可\nWeb调试： 与java代码的调试 区别：启动方式不同\nindex.jsp -\u0026gt;index_jsp.java -\u0026gt;index_jsp.class  jsp-\u0026gt;java-\u0026gt;class\njsp翻译成的Java 以及编译后的class文件 存在于tomcat中的work目录中\n分页 5变量（属性）\n 数据总数 （select count(*) from xxx ，查数据库） 页面大小（页面容量，每页显示的数据条数） （用户自定义） 总页数 （自动计算）\n800:10= 80页 总页数= 数据总数 /页面大小 802:10= 800/10 +1 ； 总页数= 数据总数 /页面大小 + 1;  \u0026ndash;\u0026gt;通式\n总页数= 数据总数 % 页面大小==0 ?数据总数 /页面大小:数据总数 /页面大小 + 1;  注意：自动计算的时机：当 数据总数 和 页面大小都被赋值以后，自动计算总页数。\n 当前页码 （用户自定义）\n 实体类对象集合（当前页的数据集合）：依赖于数据库 (查数据库)\n假设： 每页显示10条（页面大小=10）\nselect * from student where id\u0026gt;=起始 and id\u0026lt;=终止;  页数 起止 起止等价写法 1 1-10 (页数-1)*10+1-页数*10 2 11-20 3 21-30\n  某一页的数据 起止：\n(页数-1)*10+1-页数*10  select * from student where sno\u0026gt;=(页数-1)*10+1 and sno\u0026lt;=页数*10;  此种分页SQL 严格依赖sno的数据，一旦sno出现了间隙（裂缝），则无法满足每页10条\n-\u0026gt;将此SQL 转换： 1. 有rownum\n2. 不能有rownum\u0026gt;xx\n转换的核心：将rownum从伪列 转换为 一个 临时表的 普通列。\nselect *from ( select rownum r,t.*from (select s.* from student s order by sno asc) t ) where r\u0026gt;=(页数-1)*10+1 and r\u0026lt;=页数*10;  优化：\nselect *from ( select rownum r,t.*from (select s.* from student s order by sno asc) t where rownum\u0026lt;=页数*页面大小 ) where r\u0026gt;=(页数-1)*页面大小+1 ;  dao和DBUtil的区别：\n dao 是处理特定 类的 数据库操作类： DBUtil是通用 数据库操作类  分页\n要实现分页，必须知道 某一页的 数据 从哪里开始 到哪里结束\n页面大小：每页显示的数据量\n假设每页显示10条数据\nmysql分页 mysql:从0开始计数 0 0 9 1 10 19 2 20 29 n n*10 (n+1)*10-1  结论：\n分页：\n第n页的数据：\n第(n-1)*10+1条 -- 第n*10条  MYSQL实现分页的sql：\nlimit 开始,多少条\n第0页 select * from student limit 0,10 ; 第1页 select * from student limit 10,10 ; 第2页 select * from student limit 20,10 ; 第n页 select * from student limit n*10,10  mysql的分页语句：\nselect * from student limit 页数*页面大小,页面大小  oracle分页： sqlserver/oracle:从1开始计数 第n页 开始 结束 1 1 10 2 11 20 3 21 30 n (n-1)*10+1 n*10  select *from student where sno \u0026gt;=(n-1)*10+1 and sno \u0026lt;=n*10 ;  \u0026ndash;此种写法的前提：必须是Id连续 ，否则 无法满足每页显示10条数据\nselect rownum,t.*from student t where rownum \u0026gt;=(n-1)*10+1 and rownum \u0026lt;=n*10 order by sno;   如果根据sno排序则rownum会混乱（解决方案：分开使用-\u0026gt;先只排序，再只查询rownum） rownum不能查询\u0026gt;的数据\nselect s.* from student s order by sno asc; select rownum, t.* from (select s.* from student s order by sno asc) t where rownum \u0026gt;=(n-1)*10+1 and rownum \u0026lt;=n*10 ; ;   //ORACLE\\sqlserver都是从1开始计数：\n(n-1)*10+1 --- n*10  oracle的分页查询语句：\nselect *from ( select rownum r, t.* from (select s.* from student s order by sno asc) t 10000 ) where r\u0026gt;=(n-1)*10+1 and \u0026lt;=n*10 ;  优化：\nselect *from ( select rownum r, t.* from (select s.* from student s order by sno asc) t where rownum\u0026lt;=n*10 ) where r\u0026gt;=(n-1)*10+1 ;  select *from ( select rownum r, t.* from (select s.* from student s order by sno asc) t where rownum\u0026lt;=页数*页面大小 ) where r\u0026gt;=(页数-1)*页面大小+1 ;\t SQLServer分页 3种分页sql\nrow_number() over(字段) ;  sqlserver2003:top \u0026ndash;此种分页SQL存在弊端（如果id值不连续，则不能保证每页数据量相等）\nselect top 页面大小 * from student where id not in ( select top (页数-1)*页面大小 id from student order by sno asc )  sqlserver2005之后支持：\nselect *from ( select row_number() over (sno order by sno asc) as r,* from student where r\u0026lt;=n*10 ) where r\u0026gt;=(n-1)*10+1 and ;  SQLServer此种分页sql与oralce分页sql的区别： 1. rownum ，row_number()\n2. oracle需要排序（为了排序，单独写了一个子查询），但是在sqlserver 中可以省略该排序的子查询 因为sqlserver中可以通过over直接排序\nsqlserver2012之后支持\noffset fetch next only  select * from student oreder by sno offset (页数-1)*页面大小+1 rows fetch next 页面大小 rows only ;  (n-1)*10+1 --- n*10  mysql从0开始计数，Oracle/sqlserver 从1开始计数\n上传文件 引入2个jar\napache: commons-fileupload.jar组件 commons-fileupload.jar依赖 commons-io.jar  代码：\n前台jsp：\n\u0026lt;form action=\u0026quot;UploadServet\u0026quot; method=\u0026quot;post\u0026quot; enctype=\u0026quot;multipart/form-data\u0026quot;\u0026gt; 学号：\u0026lt;input name=\u0026quot;sno\u0026quot; /\u0026gt;\u0026lt;br/\u0026gt; 姓名：\u0026lt;input name=\u0026quot;sname\u0026quot; /\u0026gt;\u0026lt;br/\u0026gt; 上传照片: \u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;spicture\u0026quot;/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;注册\u0026quot;/\u0026gt; \u0026lt;/form\u0026gt;  表单提交方式必须为post\n在表单中必须增加一个属性 entype=\u0026quot;multipart/form-data\u0026quot;\n后台servlet：\nprotected void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException { request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); response.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); response.setContentType(\u0026quot;text/html; charset=UTF-8\u0026quot;); // 上传 // request.getParameter(\u0026quot;sname\u0026quot;) try { boolean isMultipart = ServletFileUpload.isMultipartContent(request); if (isMultipart) {// 判断前台的form是否有 mutipart属性 //\tFileItemFactory factory = new DiskFileItemFactory(); DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); //设置上传文件时 用到的临时文件的大小DiskFileItemFactory factory.setSizeThreshold(10240);//设置临时的缓冲文件大小为10 factory.setRepository(new File(\u0026quot;D:\\\\study\\\\uploadtemp\u0026quot;));//设置临时文件的目录 //控制上传单个文件的大小 20KB ServletFileUpload upload.setSizeMax(20480);//字节B Thread.sleep(3000); // 通过parseRequest解析form中的所有请求字段，并保存到 items集合中（即前台传递的sno sname // spicture此时就保存在了items中） List\u0026lt;FileItem\u0026gt; items = upload.parseRequest(request); // 遍历items中的数据（item=sno sname spicture） Iterator\u0026lt;FileItem\u0026gt; iter = items.iterator(); while (iter.hasNext()) { FileItem item = iter.next(); String itemName = item.getFieldName(); int sno = -1; String sname = null; // 判断前台字段 是普通form表单字段(sno sname)，还是文件字段 // request.getParameter() -- iter.getString() if (item.isFormField()) { if (itemName.equals(\u0026quot;sno\u0026quot;)) {// 根据name属性 判断item是sno sname 还是spicture? sno = Integer.parseInt(item.getString(\u0026quot;UTF-8\u0026quot;)); } else if (itemName.equals(\u0026quot;sname\u0026quot;)) { sname = item.getString(\u0026quot;UTF-8\u0026quot;); } else { System.out.println(\u0026quot;其他字段xxx.....\u0026quot;); } } else {// spicture 123 // 文件 上传 // 文件名 getFieldName是获取 普通表单字段的Name值 // getName()是获取 文件名 String fileName = item.getName();//a.txt a.docx a.png String ext = fileName.substring( fileName.indexOf(\u0026quot;.\u0026quot;)+1 ) ; if(!(ext.equals(\u0026quot;png\u0026quot;) || ext.equals(\u0026quot;gif\u0026quot;) ||ext.equals(\u0026quot;jpg\u0026quot;))) { System.out.println(\u0026quot;图片类型有误！格式只能是 png gif jpg\u0026quot;); return ;//终止 } // 获取文件内容 并上传 // 定义文件路径：指定上传的位置(服务器路径) // 获取服务器路径D:\\\\study\\\\apache-tomcat-8.5.30\\\\wtpwebapps\\\\UpAndDown\\\\upload // String path =request.getSession().getServletContext().getRealPath(\u0026quot;upload\u0026quot;) ; String path = \u0026quot;D:\\\\study\\\\upload\u0026quot;; File file = new File(path, fileName); item.write(file);// 上传 System.out.println(fileName + \u0026quot;上传成功！\u0026quot;); return; } } } } catch (FileUploadBase.SizeLimitExceededException e) {//SizeLimitExceededException是FileUploadException的一个子类 System.out.println(\u0026quot;上传文件大小超过限制！最大20KB\u0026quot;); } catch (FileUploadException e) { e.printStackTrace(); } // 解析请求 catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } }  注意的问题：\n上传的目录 upload ：\n 如果修改代码，则在tomcat重新启动时 会被删除\n原因：当修改代码的时候,tomcat会重新编译一份class 并且重新部署（重新创建各种目录）\n 如果不修改代码，则不会删除\n原因： 没有修改代码，class仍然是之前的class\n  因此，为了防止 上传目录丢失\n 虚拟路径\n 直接更换上传目录 到非tomcat目录\n  限制上传：\n类型、大小\n注意 对文件的限制条件 写再parseRequest之前\n下载 不需要依赖任何jar\n 请求（地址a form），请求Servlet\n Servlet通过文件的地址 将文件转为输入流 读到Servlet中 通过输出流 将 刚才已经转为输入流的文件 输出给用户  请求\n\u0026lt;a href=\u0026quot;DownloadServlet?filename=MIME.png\u0026quot;\u0026gt;MIME\u0026lt;/a\u0026gt;  servlet\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); //获取需要下载的文件名 String fileName = request.getParameter(\u0026quot;filename\u0026quot;) ;//form 、a href、 ...Server?a=b //下载文件：需要设置 消息头 response.addHeader(\u0026quot;content-Type\u0026quot;,\u0026quot;application/octet-stream\u0026quot; );//MIME类型:二进制文件（任意文件） //对于不同浏览器，进行不同的处理 //获取客户端的user-agent信息 String agent = request.getHeader(\u0026quot;User-Agent\u0026quot;); if(agent.toLowerCase().indexOf(\u0026quot;firefox\u0026quot;) !=-1) { //ff下载 文件名乱码问题 response.addHeader(\u0026quot;content-Disposition\u0026quot;,\u0026quot;attachment;filename==?UTF-8?B?\u0026quot;+ new String( Base64.encodeBase64(fileName.getBytes(\u0026quot;UTF-8\u0026quot;)) ) +\u0026quot;?=\u0026quot; );//fileName包含了文件后缀：abc.txt }else { //edge下载 文件名乱码问题 response.addHeader(\u0026quot;content-Disposition\u0026quot;,\u0026quot;attachment;filename=\u0026quot;+ URLEncoder.encode(fileName,\u0026quot;UTF-8\u0026quot;) );//fileName包含了文件后缀：abc.txt } //Servlet通过文件的地址 将文件转为输入流 读到Servlet中 InputStream in = getServletContext().getResourceAsStream(\u0026quot;/res/\u0026quot;+fileName) ; //通过输出流 将 刚才已经转为输入流的文件 输出给用户 ServletOutputStream out = response.getOutputStream() ; byte[] bs = new byte[10]; int len=-1 ; while( (len=in.read(bs)) != -1) { out.write(bs,0,len); } out.close(); in.close(); }  注意：下载文件 需要设置2个 响应头：\nresponse.addHeader(\u0026quot;content-Type\u0026quot;,\u0026quot;application/octet-stream\u0026quot; );//MIME类型:二进制文件（任意文件） response.addHeader(\u0026quot;content-Disposition\u0026quot;,\u0026quot;attachement;filename=\u0026quot;+fileName );//fileName包含了文件后缀：abc.txt  下载时 ，文件名乱码问题：\nedge：\nURLEncoder.encode(fileName,\u0026quot;UTF-8\u0026quot;)  firefox：\n给文件名 加：\n前缀\n=?UTF-8?B?  中间\nString构造方法 Base64.encode  后缀\n?=  示例：\nresponse.addHeader(\u0026quot;content-Disposition\u0026quot;,\u0026quot;attachment;filename==?UTF-8?B?\u0026quot;+ new String( Base64.encodeBase64(fileName.getBytes(\u0026quot;UTF-8\u0026quot;)) ) +\u0026quot;?=\u0026quot; );//fileName包含了文件后缀：abc.txt  ","id":38,"section":"posts","summary":"源码 JSP:动态网页 静态、动态： 不用 和 是否有“动感”混为一谈 是否随着时间、地点、用户操作的改变而改变 动态网页需要使用到服务端脚本语言（JSP","tags":["J2EE"],"title":"JSP学习笔记","uri":"https://mumulx.github.io/2019/11/jsp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" 源码\nEL Expression Launguage:可以代替JSp页面中的Java代码\n传统的在jsp代码中显示java代码 需要使用\u0026lt;%%\u0026gt;\u0026lt;%=%\u0026gt; 需要处理null 类型转换 代码参杂 \u0026mdash;》EL\nEL示例\n${域对象.域对象中的属性.对象属性的属性......级联属性} ${requestScope.student.sno}、 ${requestScope.student.address.homeAddress} ${requestScope.student[\u0026quot;address\u0026quot;]['schoolAddress']}  EL操作符：\n 点操作符. 使用方便 [\u0026quot;\u0026quot;] 或者['']操作符 功能强大：可以使用特殊字符(. 、 -) 获取变量值int a =10 ; [a]可以获取变量值10 加\u0026rdquo;\u0026ldquo;是常量，不加\u0026rdquo;\u0026ldquo;是变量,可以访问数组\n点操作符：$(requestScope.my-name) 不可以 [\u0026quot;\u0026quot;]操作符：$(requestScope['my-name']) 可以 数组：$(requestScope。hobbies[0]) 数组：$(requestScope。hobbies[1])   获取 map属性 map\nMap\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026quot;ud\u0026quot;,\u0026quot;df\u0026quot;); map.put(\u0026quot;dfs\u0026quot;,\u0026quot;dsfsdf\u0026quot;); request.setAttribute(\u0026quot;map\u0026quot;,map); ${requestScope.map.ud} ${requestScope.map[\u0026quot;dfs\u0026quot;]  ${9\u0026gt;8}、${9 gt 8} ${3\u0026gt;2||3\u0026lt;2\u0026gt;}、${3\u0026gt;2 or 3\u0026lt;2\u0026gt;}  Empty运算符\n判断一个值是否null，\n不存在或null:true\n存在:false\n${empty requestScope[\u0026quot;my-name\u0026quot;]}  EL表达式的隐式对象 不需要new就能使用的对象，自带的\n 作用域访问对象（EL域对象）\npageScopeScope requestScope sessionScope applicationScope  如果没指定域对象则从小到大一次查找\n 参数访问对象\n获取表单数据\\超链接地址栏的值 jsp :\nrequest.getParameter()request.getParameterValues()  EL\n${param} ${paramValues}  如\n${param.uname} ${paramValues.hobbies[0]} ${paramValues.hobbies[1]}  JSP隐式对象\npageContext\n在 jsp中可以使用pageContext获取其他jsp的隐式对象： 因此如果在EL中使用JSP隐式对象，就可以通过pageContext间接获取 ${pageContext.方法名去掉get并且将首字母小写} ${pageContext.request} ${pageContext.session}\n可以使用此方法获取级联对象\n${pageContext.request.serverPort}   JSTl JSTl比EL更加强大比EL更加强大\n需要引入jar包：\njstl.jar standard.jar  复制到lib\n引入tablib\n在jsp中导包\n\u0026lt;%@taglib prefix=\u0026quot;c\u0026quot; uri=\u0026quot;http://java.sun.com/jsp/jstl/core\u0026quot; %\u0026gt;  其中prefix=\u0026ldquo;c\u0026rdquo;：前缀\n核心标签库：通用标签库、条件标签库 迭代标签库\n通用标签库 \u0026lt;c:set\u0026gt;赋值  某个作用域（4个范围对象）中给某个变量赋值\n\u0026lt;c:set var=\u0026quot;属性名\u0026quot; value=\u0026quot;属性值\u0026quot; scope=\u0026quot;作用域\u0026quot;/\u0026gt; \u0026lt;c:set var=\u0026quot;name\u0026quot; value=\u0026quot;aaa\u0026quot; scope=\u0026quot;request\u0026quot;/\u0026gt;  在某个作用域中给某个对象（和map）的属性进行赋值,不需要指定scope属性\n\u0026lt;c:set target=\u0026quot;对象\u0026quot; property=\u0026quot;对象的属性\u0026quot; value=\u0026quot;赋值\u0026quot; /\u0026gt; ${requestScope.student.sname} \u0026lt;c:set target=\u0026quot;${requestScope.student}\u0026quot; property=\u0026quot;sname\u0026quot; value=\u0026quot;fdsdf\u0026quot;/\u0026gt;  给map对象赋值\n\u0026lt;c:set target=\u0026quot;${requestScope.countries}\u0026quot; property=\u0026quot;cn\u0026quot; value=\u0026quot;中国\u0026quot; /\u0026gt;  \u0026lt;c:set/\u0026gt;可以给不存在的变量赋值,不能给不存在的对象赋值\n\u0026lt;c：set var=\u0026quot;x\u0026quot; values= \u0026quot;dfg\u0026quot; dcope=\u0026quot;request\u0026quot;/\u0026gt;   \u0026lt;c:out\u0026gt; ：显示 传统EL：${requestScope.student }\u0026lt;br/\u0026gt; c:out方式：\u0026lt;c:out value=\u0026quot;${requestScope.student }\u0026quot; /\u0026gt;\u0026lt;br/\u0026gt; c:out显示不存在的数据：\u0026lt;c:out value=\u0026quot;${requestScope.stu }\u0026quot; default=\u0026quot;zs-23\u0026quot;/\u0026gt;\u0026lt;br/\u0026gt; true:\u0026lt;c:out value='\u0026lt;a href=\u0026quot;https://www.baidu.com\u0026quot;\u0026gt;百度\u0026lt;/a\u0026gt;' default=\u0026quot;当value为空的，显示的默认值\u0026quot; escapeXml=\u0026quot;true\u0026quot; /\u0026gt; 原样输出 false： \u0026lt;c:out value='\u0026lt;a href=\u0026quot;https://www.baidu.com\u0026quot;\u0026gt;百度\u0026lt;/a\u0026gt;' escapeXml=\u0026quot;false\u0026quot; /\u0026gt; 解析标签  \u0026lt;c:remove \u0026gt;：删除属性 \u0026lt;c:remove var=\u0026quot;a\u0026quot; scope=\u0026quot;request\u0026quot;/\u0026gt;  选择： if(boolean)\n单重选择\n\u0026lt;c:if test=\u0026quot;${1\u0026gt;2}\u0026quot;\u0026gt;\u0026lt;/c:if\u0026gt; \u0026lt;c:if test=\u0026quot;${1\u0026gt;2}\u0026quot; var=\u0026quot;result\u0026quot; scope=\u0026quot;request\u0026quot; \u0026gt;\u0026lt;/c:if\u0026gt;  将运算结果赋值为result并且放入scope域中\n多重选择\nif else if... esle if... else /switch  \u0026lt;c:choose\u0026gt; \u0026lt;c:when test=\u0026quot;${}\u0026quot;\u0026gt; \u0026lt;/c:when\u0026gt; \u0026lt;c:when test=\u0026quot;${}\u0026quot;\u0026gt; \u0026lt;/c:when\u0026gt; \u0026lt;c:when test=\u0026quot;${}\u0026quot;\u0026gt; \u0026lt;/c:when\u0026gt; \u0026lt;c:otherwise\u0026gt; \u0026lt;/c:otherwise\u0026gt; \u0026lt;/c:choose\u0026gt;  判断语句使用el语法\n在使用 test=\u0026ldquo;\u0026rdquo; 一定要注意后面是否有空格 例如：\ntest=\u0026quot;${10\u0026gt;2 }\u0026quot; true test=\u0026quot;${10\u0026gt;2 } \u0026quot; 非true true+\u0026quot; \u0026quot;==String  任何类型遇到字符串变成字符串\n循环（迭代标签库）\nfor(int i=0;i\u0026lt;=5;i++)  \u0026lt;c:forEach begin=\u0026quot;0\u0026quot; end=\u0026quot;5\u0026quot; step=\u0026quot;1\u0026quot; varStatus=\u0026quot;status\u0026quot;\u0026gt; ${status.index } 第几次 test.... \u0026lt;/c:forEach\u0026gt;  for(String str:names)  \u0026lt;c:forEach var=\u0026quot;student\u0026quot; items=\u0026quot;${requestScope.students }\u0026quot; \u0026gt; ${student.sname }-${student.sno } \u0026lt;/c:forEach\u0026gt;  过滤器： 实现一个Filter接口\ninit()、destroy() 原理、执行时机 同Servlet\n//要想将 一个普通的class 编程一个 具有特定功能的类（过滤器、拦截....），要么继承 父类、要么实现一个接口、要么增加一个注解 public class MyFilter implements Filter {//过滤器 @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\u0026quot;filter..init..\u0026quot;); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\u0026quot;拦截请求......\u0026quot;); chain.doFilter(request, response);//放行 System.out.println(\u0026quot;拦截响应......\u0026quot;); } @Override public void destroy() { System.out.println(\u0026quot;filter..destroy..\u0026quot;); } }  配置过滤器，类似servlet\n \u0026lt;!-- 配置过滤器 --\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;MyServlet\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.student.filter.MyFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;MyFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/MyServlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;  通过doFilter()处理拦截，并且通过chain.doFilter(request, response);放行\nfilter映射\n只拦截 访问MyServlet的请求\n\u0026lt;url-pattern\u0026gt;/MyServlet\u0026lt;/url-pattern\u0026gt;  拦截一切请求（每一次访问 都会被拦截）\n\u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt;  通配符\ndispatcher请求方式：\nREQUEST：拦截HTTP请求 get post FORWARD：只拦截 通过 请求转发方式的请求 INCLUDE:只拦截拦截通过 request.getRequestDispatcher(\u0026quot;\u0026quot;).include() 、通过\u0026lt;jsp:include page=\u0026quot;...\u0026quot; /\u0026gt;此种方式发出的请求 ERROR：只拦截\u0026lt;error-page\u0026gt;发出的请求  过滤器中doFilter方法参数：ServletRequest\n在Servlet中的方法参数：HttpServletRequest\n\u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;MyServlet\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;dispatcher\u0026gt;REQUEST\u0026lt;/dispatcher\u0026gt; \u0026lt;dispatcher\u0026gt;FORWARD\u0026lt;/dispatcher\u0026gt; \u0026lt;/filter-mapping\u0026gt;  过滤器链\n可以配置多个过滤器，过滤器的先后顺序 是由 \u0026lt;filter-mapping\u0026gt;的位置 决定\n监听器 一个类实现了三个接口\n监听对象的创建销毁\n\u0026mdash;四个范围对象 PageContext request session application\n监听对象request response application 各自一个监听器\nrequest：ServletRequestListener response：HttpSessionListener application：ServletContextListener  每个监听器提供了两个方法 一个开始一个结束\nServletContext在Servlet启动时自动创建\n //监听器实现接听接口 public class ContextSessionRequestListner implements ServletRequestListener,HttpSessionListener,ServletContextListener{ //application（ServletContext） public void contextDestroyed(ServletContextEvent arg0) { System.out.println(\u0026quot;监听ServletConntext，创建Servlet对象........\u0026quot;+arg0); } public void contextInitialized(ServletContextEvent arg0) { System.out.println(\u0026quot;监听ServletConntext，销毁Servlet对象........\u0026quot;+arg0); } //session public void sessionCreated(HttpSessionEvent se) { System.out.println(\u0026quot;监听HttpSession，创建HttpSession对象........\u0026quot;+se); } public void sessionDestroyed(HttpSessionEvent se) { System.out.println(\u0026quot;监听HttpSession,销毁HttpSession对象........\u0026quot;+se); } //request public void requestDestroyed(ServletRequestEvent sre) { System.out.println(\u0026quot;监听ServletRequest,销毁ServletRequest对象........\u0026quot;+sre); } public void requestInitialized(ServletRequestEvent sre) { System.out.println(\u0026quot;初始化ServletRequest,创建ServletRequest对象........\u0026quot;+sre); } }  web.xml配置监听器\n\u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;org.ycit.listner.ContextSessionRequestListner\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt;  监听对象属性的变更 request：ServletRequestAttributeListener response：HttpSessionAttributeListener application：ServletServletContextAttributeListener  每个方法有三个方法(创建、删除、修改)\n public class AttributeListener implements ServletRequestAttributeListener,HttpSessionAttributeListener,ServletContextAttributeListener{ public void attributeAdded(ServletContextAttributeEvent arg0) { String attrName = arg0.getName(); Object attrValue = arg0.getServletContext().getAttribute(attrName); System.out.println(\u0026quot;ServletContex【增加】属性\u0026quot;+attrName+\u0026quot;属性值: \u0026quot;+attrValue); } @Override public void attributeRemoved(ServletContextAttributeEvent arg0) { System.out.println(\u0026quot;ServletContex【删除】属性\u0026quot;+arg0.getName()); } public void attributeReplaced(ServletContextAttributeEvent arg0) { String attrName = arg0.getName(); Object attrValue = arg0.getServletContext().getAttribute(attrName); System.out.println(\u0026quot;ServletContex【替换】属性\u0026quot;+attrName+\u0026quot;属性值: \u0026quot;+attrValue); } public void attributeAdded(HttpSessionBindingEvent arg0) { } public void attributeRemoved(HttpSessionBindingEvent arg0) { } public void attributeReplaced(HttpSessionBindingEvent arg0) { } public void attributeAdded(ServletRequestAttributeEvent srae) { } public void attributeRemoved(ServletRequestAttributeEvent srae) { } public void attributeReplaced(ServletRequestAttributeEvent srae) { } }  配置 web.xml\n\u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt;  session钝化 客户端访问服务器会分配session对象(在内存中) 当访问量很多的时候会使得内存放不下 我们可以将session放入硬盘中(钝化)\n从硬盘取到内存中叫活化\nsession对象的四种状态： 不需要配xml\n监听绑定和解绑HttpSessionBindingListener\n监听Session对象的钝化和活HttpSessionActivationListener\n session.setAttribute(\u0026ldquo;aa\u0026rdquo;,\u0026ldquo;dfg\u0026rdquo;)对象aa绑定到session中(增加)\n session.removeAttribute(\u0026ldquo;aa\u0026rdquo;) 将对象aa从session中解绑(删除)\n每次访问时会先后创建session对象，然后再删除之前绑定的session对象\n 钝化\n 活化\n方法WillPa 监听钝化之前\nDid 刚刚进行活化之后\n  如何钝化和活化\n钝化\n配置 tomcat安装目录/conf/context.xml\n添加； 最大空闲时间；5秒钟没访问就钝化\n\u0026lt;Manager className=\u0026quot;org.apache.catalina.session.PersistentManager\u0026quot; maxIdleSwap=\u0026quot;5\u0026quot;\u0026gt; \u0026lt;Store className=\u0026quot;apache.catalina.session.FileStore\u0026quot; directory=\u0026quot;aqa\u0026quot;/\u0026gt; \u0026lt;/Manager\u0026gt;  FileStore:拖过该类具体操作 directory:相对路径 相对于tomcat/work/Catalina/localhost/项目名/aqa  活化:自动活化\n两个本质：序列化反序列化 需要借助Serializable接口\n类名 implements HttpSessionActivationListener,Serializable  总结： 钝化活化实际的执行是通过tomcat中的context.xml中进行配置\nHttpSessionActivationListener只是负责session钝化和活化时予以监听\n需要实现Serializable接口\n活化：session中获取某一个对象时，如果该对象不存在时，则直接尝试从之前钝化的文件中去获取(活化)\nAjax 异步js 和 xml\n异步刷新： 如果网页中某一个地方需要修改，异步刷新可以使：只刷新该需要修改的地方，而页面中其他地方 保持不变。例如：百度搜索框、视频的点赞\n实现：\njs: XMLHttpRequest对象\nXMLHttpRequest对象的方法：\nopen(方法名(提交方式get|post),服务器地址,true) :与服务端建立连接true异步刷新，false全局刷新 send(): get: send(null) post: send(参数值) setRequestHeader(header,value): get:不需要设置此方法 post:需要设置： a.如果请求元素中包含了 文件上传: setRequestHeader(\u0026quot;Content-Type\u0026quot;,\u0026quot;multipart/form-data\u0026quot;); b.不包含了 文件上传 setRequestHeader(\u0026quot;Content-Type\u0026quot;,\u0026quot;application/x-www-form-urlencoded\u0026quot;)  XMLHttpRequest对象的属性：\nreadyState:请求状态 只有状态为4 代表请求完毕 status:响应状态 只有200 代表响应正常 onreadystatechange:回调函数 responseText：响应格式为String responseXML：相应格式为XML  js \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; function register() { var mobile = document.getElementById(\u0026quot;mobile\u0026quot;).value; //通过ajax异步方式 请求服务端 xmlHttpRequest = new XMLHttpRequest(); //设置xmlHttpRequest对象的回调函数 xmlHttpRequest.onreadystatechange = callBack ; xmlHttpRequest.open(\u0026quot;post\u0026quot;,\u0026quot;MobileServlet\u0026quot;,true); //设置post方式的 头信息 xmlHttpRequest.setRequestHeader(\u0026quot;Content-Type\u0026quot;,\u0026quot;application/x-www-form-urlencoded\u0026quot;); } function registerGet() { var mobile = document.getElementById(\u0026quot;mobile\u0026quot;).value; //通过ajax异步方式 请求服务端 xmlHttpRequest = new XMLHttpRequest(); //设置xmlHttpRequest对象的回调函数 xmlHttpRequest.onreadystatechange = callBack ; xmlHttpRequest.open(\u0026quot;get\u0026quot;,\u0026quot;MobileServlet?mobile=\u0026quot;+mobile,true); //设置post方式的 头信息 ,get不需要 //xmlHttpRequest.setRequestHeader(\u0026quot;Content-Type\u0026quot;,\u0026quot;application/x-www-form-urlencoded\u0026quot;); xmlHttpRequest.send(null);//k=v } //定义回调函数 (接收服务端的返回值) function callBack(){ if(xmlHttpRequest.readyState ==4 \u0026amp;\u0026amp; xmlHttpRequest.status ==200){ //接收服务端返回的数据 var data = xmlHttpRequest.responseText ;//服务端返回值为string格式 alert(data.length +\u0026quot;===\u0026quot;+data) if(data == \u0026quot;true\u0026quot;){ alert(\u0026quot;请号码已存在,请更换！\u0026quot;); }else{ alert(\u0026quot;注册成功！\u0026quot;); } } } \u0026lt;/script\u0026gt;  手机：\u0026lt;input id=\u0026quot;mobile\u0026quot;/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;注册\u0026quot; onclick=\u0026quot;registerGet()\u0026quot; /\u0026gt;  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); response.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); response.setContentType(\u0026quot;text/html; charset=UTF-8\u0026quot;); String mobile = request.getParameter(\u0026quot;mobile\u0026quot;) ; //假设此时 数据库中 只有一个号码：18888888888 //if(mobile.equals(\u0026quot;18888888888\u0026quot;)) { PrintWriter out = response.getWriter(); if(\u0026quot;18888888888\u0026quot;.equals(mobile)) { //return true ; //out.write(\u0026quot;true\u0026quot;);//servlet以输出流的方式 将信息 返回给客户端 //out.write(\u0026quot;此号码已存在！\u0026quot;); //如果客户端是getJSON(),则需要以json格式返回数据 out.write( \u0026quot;{\\\u0026quot;msg\\\u0026quot;:\\\u0026quot;true\\\u0026quot;}\u0026quot; );// {\u0026quot;\\\u0026quot;msg\\\u0026quot;:\\\u0026quot;true\\\u0026quot;\u0026quot;} }else { //return false ; //out.write(\u0026quot;false\u0026quot;); //out.write(\u0026quot;注册成功！\u0026quot;); out.write( \u0026quot;{\\\u0026quot;msg\\\u0026quot;:\\\u0026quot;false\\\u0026quot;}\u0026quot; );// \u0026quot;\\\u0026quot;msg\\\u0026quot;:\\\u0026quot;false\\\u0026quot;\u0026quot; } out.close(); }  jquery:推荐 $.ajax({ url:服务器地址, 请求方式:get|post, data:请求数据, success:function(result,testStatus) { }, error:function(xhr,errrorMessage,e){ } });  $.get( 服务器地址, 请求数据, function (result){ }, 预期返回值类型（string\\xml） );  $.post( 服务器地址, 请求数据, function (result){ }, \u0026quot;xml\u0026quot; 或 \u0026quot;json\u0026quot; 或 \u0026quot;text\u0026quot; );  $(xxx).load( 服务器地址, 请求数据 );  load:将服务端的返回值 直接加载到$(xxx)所选择的元素中 JSON\n$.getJSON( 服务器地址, JSON格式的请求数据, function (result){ } );  \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; function register() { var $mobile = $(\u0026quot;#mobile\u0026quot;).val(); /* $.ajax({ url:\u0026quot;MobileServlet\u0026quot;, 请求方式:\u0026quot;post\u0026quot;, data:\u0026quot;mobile=\u0026quot;+$mobile, success:function(result,testStatus) { if(result == \u0026quot;true\u0026quot;){ alert(\u0026quot;已存在！注册失败！\u0026quot;); }else{ alert(\u0026quot;注册成功！\u0026quot;); } }, error:function(xhr,errrorMessage,e){ alert(\u0026quot;系统异常！\u0026quot;); } }); $.post( \u0026quot;MobileServlet\u0026quot;, \u0026quot;mobile=\u0026quot;+$mobile, function (result){ if(result == \u0026quot;true\u0026quot;){ alert(\u0026quot;已存在！注册失败！\u0026quot;); }else{ alert(\u0026quot;注册成功！\u0026quot;); } }, \u0026quot;text\u0026quot; ); $.get( \u0026quot;MobileServlet\u0026quot;, \u0026quot;mobile=\u0026quot;+$mobile, function (result){ if(result == \u0026quot;true\u0026quot;){ alert(\u0026quot;已存在！注册失败！\u0026quot;); }else{ alert(\u0026quot;注册成功！\u0026quot;); } } ); $(\u0026quot;#tip\u0026quot;).load( \u0026quot;MobileServlet\u0026quot;, \u0026quot;mobile=\u0026quot;+$mobile ); var student = {\u0026quot;name\u0026quot;:\u0026quot;zs\u0026quot; , \u0026quot;age\u0026quot;:23} ; //alert(student.name +\u0026quot;--\u0026quot; +student.age) ; //var name = [\u0026quot;xx\u0026quot;,\u0026quot;xx\u0026quot;,\u0026quot;xx\u0026quot;] ; var students =[ {\u0026quot;name\u0026quot;:\u0026quot;zs\u0026quot; , \u0026quot;age\u0026quot;:23} , {\u0026quot;name\u0026quot;:\u0026quot;ls\u0026quot; , \u0026quot;age\u0026quot;:24} , {\u0026quot;name\u0026quot;:\u0026quot;ww\u0026quot; , \u0026quot;age\u0026quot;:25} ]; alert(students[1].name +\u0026quot;--\u0026quot; +students[1].age) ; */ $.getJSON( \u0026quot;MobileServlet\u0026quot;, //\t\u0026quot;mobile=\u0026quot;+$mobile, {\u0026quot;mobile\u0026quot;:$mobile}, function (result){//msg:true|false alert(123); if(result.msg == \u0026quot;true\u0026quot;){ alert(\u0026quot;已存在！注册失败！\u0026quot;); }else{ alert(\u0026quot;注册成功！\u0026quot;); } } ); } \u0026lt;/script\u0026gt;  手机：\u0026lt;input id=\u0026quot;mobile\u0026quot;/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;注册\u0026quot; onclick=\u0026quot;register()\u0026quot; /\u0026gt; \u0026lt;span id=\u0026quot;tip\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;  Ajax处理JSON数据 jar包\ncommons-beanutils-1.7.0.jar commons-lang-2.6.jar commons-collections-3.2.1.jar commons-logging-1.1.3.jar ezmorph-1.0.6.jar json-lib-2.4-jdk15.jar  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); response.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); response.setContentType(\u0026quot;text/html; charset=UTF-8\u0026quot;); PrintWriter out = response.getWriter(); //测试前端传来的数据 String name2 = request.getParameter(\u0026quot;name\u0026quot;) ; String age2 = request.getParameter(\u0026quot;age\u0026quot;) ; System.out.println(name2+\u0026quot;--\u0026quot;+age2); Student stu1 = new Student(); stu1.setAge(23); stu1.setName(\u0026quot;zs\u0026quot;); Student stu2 = new Student(); stu2.setAge(44); stu2.setName(\u0026quot;ls\u0026quot;); Student stu3 = new Student(); stu3.setAge(55); stu3.setName(\u0026quot;ww\u0026quot;); JSONObject json = new JSONObject() ; json.put(\u0026quot;stu1\u0026quot;,stu1 ) ; json.put(\u0026quot;stu2\u0026quot;,stu2 ) ; json.put(\u0026quot;stu3\u0026quot;,stu3 ) ; out.print( json);// 返回json对象 {\u0026quot;stu1\u0026quot;:stu1, \u0026quot;stu2\u0026quot;:stu2,\u0026quot;stu3\u0026quot;:stu3 } out.close(); }  /* json中只有一个对象的情况 function testJson() { $.getJSON( \u0026quot;JsonServlet\u0026quot;, {\u0026quot;name\u0026quot;:\u0026quot;zs\u0026quot;, \u0026quot;age\u0026quot;:24}, function (result){ //js需要通过eval()函数 将返回值 转为一个js能够识别的json对象 var jsonStudent = eval(result.stu1) ; alert(jsonStudent.name +\u0026quot;---\u0026quot;+ jsonStudent.age) ; } ); } */ /* json中有多对象的情况*/ function testJson() { $.getJSON( \u0026quot;JsonServlet\u0026quot;, {\u0026quot;name\u0026quot;:\u0026quot;zs\u0026quot;, \u0026quot;age\u0026quot;:24}, function (result){ // result： {\u0026quot;stu1\u0026quot;:stu1, \u0026quot;stu2\u0026quot;:stu2,\u0026quot;stu3\u0026quot;:stu3 } //js需要通过eval()函数 将返回值 转为一个js能够识别的json对象 var json = eval(result) ; $.each( json, function(i,element){ alert( this.name +\u0026quot;---\u0026quot;+ this.age ); } ); } ); }  IDEA开发Web 配置tomcat run\u0026ndash;》Edit Configurations\u0026ndash;\u0026gt;点击加号\u0026ndash;\u0026gt;Tomcat Server\n选择tomcat，jre\nDeployment部署项目，设置项目名\nidea中tomcat乱码：  file - settings - 搜File Encodings,全部改为utf-8 打开idea安装目录/bin，在idea64.exe.vmoptions和idea.exe.vmoptions最后追加\n-Dfile.encoding=UTF-8  配置tomcat的页面中：VM option设置：\n-Dfile.encoding=UTF-8   热部署问题(jsp+java) 在配置tomcat的页面\n Update:更新操作（经过测试，很多时候无效） Frame:idea失去焦点时触发  推荐选项：\n Update：任意 Frame:update classes and resources  idea：热部署\n 如果是run启动，仅JSP等静态资源有效 如果是debug启动，java和jsp等均有效  总结 热部署：\n Frame:update classes and resources 以debug模式启动  注意：编写servlet前 需要先加入tomcat环境\n打开Project Structure \u0026ndash;》Modules \u0026ndash;\u0026gt;右边加号\u0026ndash;\u0026gt;Library\u0026ndash;》tomcat\nServlet3.0注解方式的参数设置访问路径的为url-pattern,也是默认值，值中要含有项目根目录/;例\n@javax.servlet.annotation.WebServlet( \u0026quot;/MyServlet\u0026quot;)  注意注解参数的值中有没有url-pattern,和值正不正确\n自动导包\nSettings\u0026ndash;\u0026gt;Editor\u0026ndash;\u0026gt;General\u0026ndash;\u0026gt;Auto Import\nJNDI java命名与目录接口\npageContext \u0026lt; request\u0026lt; session\u0026lt; application(一个项目运行期间都有效)\njndi:将某一个资源（对象），以配置文件(tomcat/conf/context.xml)的形式写入；\n实现步骤：\ntomcat/conf/context.xml配置：\n\u0026lt;Context\u0026gt; \u0026lt;Environment name=\u0026quot;jndiName\u0026quot; value=\u0026quot;jndiValue\u0026quot; type=\u0026quot;java.lang.String\u0026quot; /\u0026gt;  jsp中用：\n\u0026lt;% Context ctx = new InitialContext() ; String testJndi = (String)ctx.lookup(\u0026quot;java:comp/env/jndiName\u0026quot;); out.print(testJndi); %\u0026gt;  DIEA JAR包  java项目\n复制粘贴jar包\u0026ndash;》右键Add as Library\n Web项目\n WEB-INF新建目录lib\n 将jar包复制到目录\n Project Structure\u0026ndash;\u0026gt;Artifacts\u0026ndash;\u0026gt;右边添加文件夹lib\n   Eclipse中的web项目引入jar:只需要 jar 放入web-context/lib/xx.jar,Eclipse就会将web-context/lib/中的所有jar存放到项目的全部生命周期中\nIDEA：会将web-context/lib/中的所有jar包，只存在于运行阶段生效\n开发（编写、编译）- 运行(commons-dbcp.jar )\n即idea中Web-Content/lib/的jar，只在运行时生效，在其他阶段不生效。\n解决方案： gradle/maven\n手工解决（了解）:原理-结论\n jar包本身只在 运行时有效(ojdbc.jar)\n Class.forName() DriverManager.getCOnnection() Presss Connection  处理办法：\n 只需要将jar复制在Web-Content/lib/ojdbc7.jar\n问题：有时候延迟较长\n Structure - Artifacts - output\n   2.commons-dbcp.jar （开发时、运行均有效）\nWeb-Content/lib/commons-dbcp.jar --只在运行时有效 手工解决： 将commons-dbcp.jar 在开发时也有效： 直接将jar复制到工程src中，右键-Add as Library...  常见错误：\n仅仅将jar引用在了Dependencies中，并且将jar的生命周期选择为了compile -错误\n错误原因：\nweb项目结构：web约定jar是存放在lib中\n总结论：\n java项目，和eclipse,在项目src中复制粘贴jar包右键 add as library web项目：\n jar本身就只在运行阶段有效ojdbc.jar\n只需要复制Web-Content/lib/中即可。\n jar在各个阶段均有效\n要复制Web-Content/lib/中即可\n再复制src中，右键-Add as library\u0026hellip;\n   或Project Structure中Modules添加jar包\n连接池 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。\n常见连接池：Tomcat-dbcp、dbcp、c3p0、druid\n可以用数据源(javax.sql.DataSource)管理连接池\nTomcat-dbcp  类似jndi,在context.xml中配置数据库\n\u0026lt;Context\u0026gt; \u0026lt;Resource name=\u0026quot;student\u0026quot; auth=\u0026quot;Container\u0026quot; type=\u0026quot;javax.sql.DataSource\u0026quot; maxActive=\u0026quot;400\u0026quot; maxIdle=\u0026quot;20\u0026quot; maxWait=\u0026quot;5000\u0026quot; username=\u0026quot;scott\u0026quot; password=\u0026quot;tiger\u0026quot; driverClassName=\u0026quot;oracle.jdbc.driver.OracleDriver\u0026quot; url=\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026quot; /\u0026gt;  在项目的web.xml中\n\u0026lt;resource-ref\u0026gt; \u0026lt;res-ref-name\u0026gt;student\u0026lt;/res-ref-name\u0026gt; \u0026lt;res-type\u0026gt;javax.sql.DataSource\u0026lt;/res-type\u0026gt; \u0026lt;res-auth\u0026gt;Container\u0026lt;/res-auth\u0026gt; \u0026lt;/resource-ref\u0026gt;  使用数据源\n更改 连接对象Connection的获取方式 ：\n 传统Jdbc方式\nconnection = DriverManager.getConnection(URL,USERNAME,PASSWORD);  数据源方式：\nContext ctx = new InitialContext() ;//context.xml DataSource ds = (DataSource)ctx.lookup(\u0026quot;java:comp/env/student\u0026quot;) ; connection = ds.getConnection();    tomcat-dbcp数据源总结：\n 配置数据源（context.xml）\n 指定数据源（web.xml） 用数据源 ：通过数据库获取Connection  dbcp连接池 Jar包\ncommons-dbcp-1.4.jar commons-pool.jar  连接池：\n怎么用？ * 不用连接池\n Class.forName(); Connection connection = DriverManager.getConnection();//连接指向数据库   用连接池的核心：将连接的指向改了，现在指向的是数据源 而不是数据库。\n....-\u0026gt; DataSource ds = .... Connection connection =ds.getConnection();//指向的是数据源的连接   数据库访问核心 -\u0026gt; pstmt/stmt -\u0026gt;connection\n 直接数据库 数据源 ds.getConnection()\nPreparedStatemnt pstmt = connection.preparedStatement();   dbcp获取ds:\n1. BasicDataSource 2. BasicDataSourceFactory  BasicDataSource方式 （硬编码）：DasicDataSource对象设置各种数据\n//获取dbcp方式的ds对象 public static DataSource getDataSourceWIthDBCP(){ BasicDataSource dbcp = new BasicDataSource(); dbcp.setDriverClassName(\u0026quot;oracle.jdbc.driver.OracleDriver\u0026quot;); dbcp.setUrl(\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026quot;); dbcp.setUsername(\u0026quot;scott\u0026quot;); dbcp.setPassword(\u0026quot;tiger\u0026quot;); dbcp.setInitialSize(20); dbcp.setMaxActive(10); return dbcp; }  getDataSourceWIthDBCP().getConnection()  BasicDataSourceFactory方式 配置方式（.properties文件, 编写方式key=value）\ndbcpconfig.properties\ndriverClassName=oracle.jdbc.driver.OracleDriver url=jdbc:oracle:thin:@127.0.0.1:1521:ORCL username=scott password=tiger initialSize=10  public static DataSource getDataSourceWIthDBCPByProperties() throws Exception{ DataSource dbcp = null ; Properties props = new Properties(); InputStream input = new DBCPDemo().getClass().getClassLoader().getResourceAsStream(\u0026quot;dbcpconfig.properties\u0026quot;); props.load(input); //只需要记住以下一句 dbcp = BasicDataSourceFactory.createDataSource(props) ; return dbcp; }  getDataSourceWIthDBCPByProperties().getConnection();  报错：NoClassDefFoundError异常 说明少jar\nDataSource 是所有sql数据源的上级类。BasicDataSource是dbcp类型的数据源,ComboPooledDataSource是c3p0类型的数据源；XxxDataSource\u0026hellip;\n###c3p0连接池\n两种方式\n 硬编码 配置文件  -\u0026gt;合二为一 ，通过ComboPooledDataSource的构造方法参数区分：\n 如果无参，硬编码； 有参，配置文件  jar包\nc3p0.jar c3p0-oracle-thin-extras.jar  无参，硬编码 public static DataSource getDataSourceWithC3P0(){ ComboPooledDataSource c3p0 = new ComboPooledDataSource(); try { c3p0.setDriverClass(\u0026quot;oracle.jdbc.driver.OracleDriver\u0026quot;); } catch (PropertyVetoException e) { e.printStackTrace(); } c3p0.setJdbcUrl(\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026quot;); c3p0.setUser(\u0026quot;scott\u0026quot;); c3p0.setPassword(\u0026quot;tiger\u0026quot;); return c3p0 ; }  有参，配置文件 c3p0-config.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;c3p0-config\u0026gt; \u0026lt;default-config\u0026gt; \u0026lt;!-- 如果要研究某个xml中可以设置哪些属性。找相关类的 属性 或者setXxx()--\u0026gt; \u0026lt;property name=\u0026quot;user\u0026quot;\u0026gt;scott\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot;\u0026gt;tiger\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;driverClass\u0026quot;\u0026gt;oracle.jdbc.driver.OracleDriver\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jdbcUrl\u0026quot;\u0026gt;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;checkoutTimeout\u0026quot;\u0026gt;30000\u0026lt;/property\u0026gt; \u0026lt;/default-config\u0026gt; \u0026lt;named-config name=\u0026quot;yanqun\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;user\u0026quot;\u0026gt;scott\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot;\u0026gt;tiger\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;driverClass\u0026quot;\u0026gt;oracle.jdbc.driver.OracleDriver\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;jdbcUrl\u0026quot;\u0026gt;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;checkoutTimeout\u0026quot;\u0026gt;20000\u0026lt;/property\u0026gt; \u0026lt;/named-config\u0026gt; \u0026lt;/c3p0-config\u0026gt;  public static DataSource getDataSourceWithC3P0ByXml(){ ComboPooledDataSource c3p0 = new ComboPooledDataSource(\u0026quot;yanqun\u0026quot;); return c3p0 ; }  oralce修改密码：\n管理员状态 sqlplus / as sysdba\nalter user scott identified by tiger ;  所有连接池的思路：\n 硬编码，某个连接池数据源的\n对象 ds = new XxxDataSource(); ds.setXxx(); return ds ;  配置文件\nds = new XxxDataSource();加载配置文件 ,return ds ;   数据源工具类 dbcp、c3p0, druid\npublic class DataSourceUtil { //获取dbcp方式的ds对象 public static DataSource getDataSourceWIthDBCP(){ BasicDataSource dbcp = new BasicDataSource(); dbcp.setDriverClassName(\u0026quot;oracle.jdbc.driver.OracleDriver\u0026quot;); dbcp.setUrl(\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026quot;); dbcp.setUsername(\u0026quot;scott\u0026quot;); dbcp.setPassword(\u0026quot;tiger\u0026quot;); dbcp.setInitialSize(20); dbcp.setMaxActive(10); return dbcp; } public static DataSource getDataSourceWIthDBCPByProperties() throws Exception{ DataSource dbcp = null ; Properties props = new Properties(); InputStream input = new DBCPDemo().getClass().getClassLoader().getResourceAsStream(\u0026quot;dbcpconfig.properties\u0026quot;); props.load( input ); //只需要记住以下一句 dbcp = BasicDataSourceFactory.createDataSource(props ) ; return dbcp; } public static DataSource getDataSourceWithC3P0(){ ComboPooledDataSource c3p0 = new ComboPooledDataSource(); try { c3p0.setDriverClass(\u0026quot;oracle.jdbc.driver.OracleDriver\u0026quot;); } catch (PropertyVetoException e) { e.printStackTrace(); } c3p0.setJdbcUrl(\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026quot;); c3p0.setUser(\u0026quot;scott\u0026quot;); c3p0.setPassword(\u0026quot;tiger\u0026quot;); return c3p0 ; } public static DataSource getDataSourceWithC3P0ByXml(){ ComboPooledDataSource c3p0 = new ComboPooledDataSource(\u0026quot;yanqun\u0026quot;); return c3p0 ; } }  Apache DBUtils jar\ncommons-dbutils-1.7.jar  其中包含以下几个重点类：\nDbUtils、QueryRunner、ResultSetHandler   DbUtils：辅助 QueryRunner：增删改查\nupdate() query()  oracle:dml,commit\nmysql:dml自动提交\n 如果是查询，则需要ResultSetHandler接口，有很多实现类,一个实现类对应于一种 不同的查询结果类型\n  实现类ArrayHandler ：返回结果集中的第一行数据，并用Object[]接收\n//select *from student ; -\u0026gt; List\u0026lt;Student\u0026gt; //查询单行数据 public static void testArrayHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 Object[] student = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new ArrayHandler(),1) ; System.out.println( student[0]+\u0026quot;,\u0026quot;+student[1]); }  实现类ArrayListHandler：返回结果集中的多行数据， List\u0026lt;Object[]\u0026gt;\n//查询单多数据 public static void testArrayListHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 List\u0026lt;Object[]\u0026gt; students = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new ArrayListHandler(),1) ; for(Object[] student:students){ System.out.println( student[0]+\u0026quot;,\u0026quot;+student[1]); } }  BeanHandler ：返回结果集中的第一行数据，用对象(Student)接收\n//查询单行数据(放入对象中) public static void testBeanHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 Student student = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new BeanHandler\u0026lt;Student\u0026gt;(Student.class),1) ; System.out.println( student.getId()+\u0026quot;,\u0026quot;+student.getName()); }  BeanListHandler：返回结果集中的多行数据， List\u0026lt;Student\u0026gt; students, stu stu2 stu3\n //查询多行数据(放入对象中) public static void testBeanListHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 List\u0026lt;Student\u0026gt; students = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new BeanListHandler\u0026lt;Student\u0026gt;(Student.class),1) ; for(Student student:students){ System.out.println( student.getId()+\u0026quot;,\u0026quot;+student.getName()); } }  BeanMapHandler\n1:stu1,2:stu2.3:stu3\n//查询多行数据(放入map中) public static void testBeanMapHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 -- java中对应oracle默认的数值类型 BigDecimal Map\u0026lt;BigDecimal,Student\u0026gt; students = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new BeanMapHandler\u0026lt;BigDecimal,Student\u0026gt;( Student.class,\u0026quot;id\u0026quot; ),1) ; // 2: ls, 3:ww Student stu = students.get(new BigDecimal(2)) ; System.out.println(stu.getId()+\u0026quot;,\u0026quot;+stu.getName()); }  反射会通过无参构造来创建对象\n\u0026ndash; Map\nMapHandler:：返回结果集中的第一行数据\n{id=1 ,name=zs}\n//查询单行数据 map public static void testMapHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 Map\u0026lt;String,Object\u0026gt; student = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new MapHandler(),1) ; System.out.println( student); }  MapListHandler：返回结果集中的多行数据\n{{id=2 ,name=ls}，{id=3 ,name=ww}}\n//查询多行数据 map public static void testMapListHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 List\u0026lt;Map\u0026lt;String,Object\u0026gt;\u0026gt; students = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new MapListHandler(),1) ; System.out.println( students); }  KeyedHanlder:\n{ls={id=2 ,name=ls}，ww={id=3 ,name=ww}}\n//查询多行数据 keyed public static void testKeyedHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 Map\u0026lt;String,Map\u0026lt;String,Object\u0026gt;\u0026gt; students = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new KeyedHandler\u0026lt;String\u0026gt;(\u0026quot;name\u0026quot;),1) ; System.out.println( students); }  ColumnListHander ：把结果集中的某一列 保存到List中\n//查询多行数据中的某一列 public static void testColumnListHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 List\u0026lt;String\u0026gt; names = runner.query(\u0026quot;select * from student where id \u0026gt; ? \u0026quot; ,new ColumnListHandler\u0026lt;String\u0026gt;(\u0026quot;name\u0026quot;),1) ; System.out.println( names); }  ScalarHandler ：单值结果\n//查询单值数据 public static void testScalarHandler() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());//自动提交事务 // BigDecimal result = runner.query(\u0026quot;select name from student where id = ? \u0026quot; ,new ScalarHandler\u0026lt;BigDecimal\u0026gt;(),2) ; String result = runner.query(\u0026quot;select name from student where id = ? \u0026quot; ,new ScalarHandler\u0026lt;String\u0026gt;(),2) ; System.out.println( result); }  问题：查询的实现类的参数问题\nquery(..., Object... params )  其中Object\u0026hellip; params代表可变参数： 既可以写单值，也可以写一个数组\nrunner.query(\u0026quot;... where id = ? and name like ? \u0026quot; ,new ArrayHandler(),new Object[]{1,\u0026quot;%s%\u0026quot;}) ; runner.query(\u0026quot;... where id = ?\u0026quot; ,new ArrayHandler(),1) ;  apache dbutils 增删改 自动提交事务 update(sql,参数);update(sql);\n手动提交事务 update(connection ,sql,参数);\npublic static void add() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0()) ; int count = runner.update( \u0026quot;insert into student(id,name) values(?,?)\u0026quot;,new Object[]{4,\u0026quot;zl\u0026quot;} ) ; System.out.println(count); } public static void delete() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0()) ; int count = runner.update( \u0026quot;delete from student where id = ?\u0026quot;,4 ) ; System.out.println(count); } public static void update() throws SQLException { QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0()) ; int count = runner.update( \u0026quot;update student set name = ? where id = ?\u0026quot;,new Object[]{\u0026quot;xx\u0026quot;,3} ) ; System.out.println(count); }  手动提交事务 基础知识：\n如果既要保证数据安全，又要保证性能，可以考虑ThreadLocal\nThreadLocal:可以为每个线程 复制一个副本。每个线程可以访问自己内部的副本。 别名 :线程本地变量\nset():给tl中存放一个 变量 get():从tl中获取变量（副本）， remove();删除副本  对于数据库来说，一个连接 对应于一个事务 ，一个事务可以包含多个DML操作\nService(多个原子操作) -\u0026gt; Dao(原子操作)  如果给每个 dao操作 都创建一个connection，则 多个dao操作对应于多个事务；\n但是 一般来讲，一个业务(service) 中的多个dao操作 应该包含在一个事务中。\n-\u0026gt;解决，ThreadLocal, 在第一个dao操作时 真正的创建一个connection对象，然后在其他几次dao操作时，借助于tl本身特性 自动将该connection复制多个（connection只创建了一个，因此该connection中的所有操作 必然对应于同一个事务； 并且tl将connection在使用层面复制了多个，因此可以同时完成多个dao操作）\n事务流程： 开启事务（将自动提交-\u0026gt;手工提交） -\u0026gt;进行各种DML -\u0026gt;正常，将刚才所有DML全部提交 （全部成功）\n-\u0026gt;失败（异常），将刚才所有DML全部回滚（全部失败）\n事务的操作 全部和连接Connection密切相关\npublic class JDBCUtil { private static ThreadLocal\u0026lt;Connection\u0026gt; threadLocal = new ThreadLocal\u0026lt;\u0026gt;() ; public static Connection getConnection() throws SQLException { Connection conn = threadLocal.get();//获取tl中的变量，如果不够，会自动创建副本 if(conn == null){ conn = DataSourceUtil.getDataSourceWithC3P0().getConnection(); threadLocal.set(conn); } return conn; } //开启事务 public static void beginTransaction() throws SQLException { //连接 Connection conn = getConnection() ; conn.setAutoCommit(false);//开启事务 } //正常。提交事务 public static void commitTransaction() throws SQLException { //连接 Connection conn = getConnection() ; //所有的 对象.方法() 全部排空 if(conn !=null) conn.commit(); } //失败。回滚事务 public static void rollbackTransaction() throws SQLException { //连接 Connection conn = getConnection() ; if(conn !=null) conn.rollback(); } public static void close() throws SQLException{ Connection conn = getConnection() ; if(conn !=null) conn.close(); threadLocal.remove(); conn = null ; } }  public class AccountDaoImpl implements AccountDao { @Override public Account queryAccountByCard(int cardId) throws SQLException { QueryRunner runner = new QueryRunner() ; Connection conn = JDBCUtil.getConnection() ; Account account = runner.query(conn, \u0026quot;select * from account where carid = ?\u0026quot;, new BeanHandler\u0026lt;Account\u0026gt;(Account.class), cardId);//如果是手动提交： QueryRunner()无参；query()update()必须传入connection return account; } //carid 余额 @Override public void updateAccount(Account account) throws SQLException{ QueryRunner runner = new QueryRunner() ; Connection conn = JDBCUtil.getConnection() ; runner.update(conn,\u0026quot;update account set balance = ? where carid = ?\u0026quot;,new Object[]{account.getBalance(),account.getCardId()} ); } }  public class AccountServiceImpl implements AccountService { @Override public void transfer(int fromCardId, int toCardId, int money) { AccountDaoImpl accountDao = new AccountDaoImpl(); //开启事务 try { JDBCUtil.beginTransaction(); //各种DML操作 //a. -1000 b.+1000 //根据cardid查询相应的账户 Account fromAccount = accountDao.queryAccountByCard(fromCardId) ;//付款方 Account toAccount = accountDao.queryAccountByCard(toCardId) ;//收款方 //转账 if(fromAccount.getBalance() \u0026gt; money){ //付款方 -1000 int fromBalance = fromAccount.getBalance() - money; fromAccount.setBalance( fromBalance ); fromAccount.setCardId(fromCardId ); accountDao.updateAccount(fromAccount); System.out.println(1/0); //收款方+1000 int toBalance = toAccount.getBalance() + money ; toAccount.setBalance(toBalance); toAccount.setCardId(toCardId); accountDao.updateAccount(toAccount); System.out.println(\u0026quot;转账成功!\u0026quot;); //正常提交事务 JDBCUtil.commitTransaction(); }else{ System.out.println(\u0026quot;余额不足！\u0026quot;); } } catch (Exception e) { try { JDBCUtil.rollbackTransaction(); System.out.println(\u0026quot;转账失败，回滚操作！\u0026quot;); } catch (SQLException e1) { e1.printStackTrace(); }catch (Exception e1) { e1.printStackTrace(); } e.printStackTrace(); }finally{ try { JDBCUtil.close(); } catch (SQLException e) { e.printStackTrace(); } } //结束事务（正常、失败） } }  public class Test { public static void main(String[] args) { AccountServiceImpl accountService = new AccountServiceImpl(); accountService.transfer(1234,1111,100); } }  元数据(MetaData) 描述数据的数据\n三类：\n 数据库元数据 参数元数据 结果集元数据  1.数据库元数据 DataBaseMetaData\nConnection -\u0026gt; DataBaseMetaData -\u0026gt; .  2.参数元数据 ParameterMetaData pstmt -\u0026gt; ParameterMetaData -\u0026gt; .\n3.结果集元数据 ResultSetMetaData ResultSet -\u0026gt; ResultSetMetaData\n public class MeteDataDemo { private final static String DRIVER=\u0026quot;oracle.jdbc.OracleDriver\u0026quot;; private final static String URL=\u0026quot;jdbc:oracle:thin:@localhost:1521:orcl\u0026quot;; private final static String USERNAME=\u0026quot;scott\u0026quot;; private final static String PASSWORD=\u0026quot;tiger\u0026quot;; public static void databaseMetaData(){ try { Class.forName(DRIVER); Connection connection = DriverManager.getConnection(URL,USERNAME,PASSWORD); //数据库元信息 DatabaseMetaData dbMetadata = connection.getMetaData() ; String dbName = dbMetadata.getDatabaseProductName() ; System.out.println(\u0026quot;数据库名\u0026quot;+dbName); String dbVersion = dbMetadata.getDatabaseProductVersion() ;//11.1.22 System.out.println(\u0026quot;数据库版本\u0026quot;+dbVersion); String driverName = dbMetadata.getDriverName(); System.out.println(driverName); String url = dbMetadata.getURL(); System.out.println(url); String userName = dbMetadata.getUserName(); System.out.println(userName); System.out.println(\u0026quot;-----------\u0026quot;); ResultSet rs = dbMetadata.getPrimaryKeys(null, userName, \u0026quot;STUDENT\u0026quot;); while(rs.next()){ Object tableName = rs.getObject(3); Object columnName = rs.getObject(4); Object pkName = rs.getObject(6); System.out.println(tableName+\u0026quot;--\u0026quot;+columnName+\u0026quot;--\u0026quot;+pkName); } }catch(Exception e){ e.printStackTrace(); } } public static void parameterMetaData(){ try { Class.forName(DRIVER); Connection connection = DriverManager.getConnection(URL,USERNAME,PASSWORD); PreparedStatement pstmt = connection.prepareStatement(\u0026quot;select * from student where id = ? and name = ?\u0026quot;); //通過pstmt獲取參數元数据 ParameterMetaData metaData = pstmt.getParameterMetaData(); int count = metaData.getParameterCount() ; System.out.println(\u0026quot;参数个数：\u0026quot;+count); for(int i=1;i\u0026lt;=count ; i++){ String typeName = metaData.getParameterTypeName(i) ; System.out.println(typeName); } }catch(Exception e){ e.printStackTrace(); } } public static void resultSetMetaData(){ try { Class.forName(DRIVER); Connection connection = DriverManager.getConnection(URL,USERNAME,PASSWORD); PreparedStatement pstmt = connection.prepareStatement(\u0026quot;select * from student \u0026quot;); ResultSet rs = pstmt.executeQuery(); ResultSetMetaData metaData = rs.getMetaData(); int count = metaData.getColumnCount(); System.out.println(\u0026quot;列的个数：\u0026quot;+count); System.out.println(\u0026quot;---\u0026quot;); for(int i=1;i\u0026lt;=count ;i++){ String columnName = metaData.getColumnName(i); String columnTypeName = metaData.getColumnTypeName(i); System.out.println( columnName+\u0026quot;\\t\u0026quot;+columnTypeName); } while(rs.next()){ for(int i=1;i\u0026lt;=count;i++){ System.out.print( rs.getObject(i)+\u0026quot;\\t\u0026quot;); } System.out.println(); } }catch(Exception e){ e.printStackTrace(); } } }  很多数据库对元数据的支持问题：\nOralce目前必须使用ojdbc7.jar作为驱动包；\nMySql必须在url中附加参数配置：\njdbc:mysql://localhost:3306/数据库名?generateSimpleParameterMetadata=true  自定义标签 步骤：\n 编写标签处理类 编写标签描述符\n 导入并使用  编写标签处理类  传统方式（JSP1.1）：实现\njavax.servlet.jsp.tagext.Tag接口 doStartTag()  简单方式（JSP2.0）：实现\njavax.servlet.jsp.tagext.SimpleTag接口 doTag()   如果jsp在编译阶段 发现了自定义标签\u0026lt;xx:yyy\u0026gt;，就会交给doStartTag()或doTag()\n编写标签描述符 tld 编写建议：可以仿照一个 其他标签语言（el jstl ） 的tld文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!-- 标签库的头文件--\u0026gt; \u0026lt;taglib xmlns=\u0026quot;http://java.sun.com/xml/ns/j2ee\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\u0026quot; version=\u0026quot;2.0\u0026quot;\u0026gt; \u0026lt;description\u0026gt;标签库描述\u0026lt;/description\u0026gt; \u0026lt;tlib-version\u0026gt;1.0\u0026lt;/tlib-version\u0026gt; \u0026lt;short-name\u0026gt;xxxxxx\u0026lt;/short-name\u0026gt; \u0026lt;uri\u0026gt;标签库的url\u0026lt;/uri\u0026gt; \u0026lt;!-- -自定义标签的相关信息 --\u0026gt; \u0026lt;tag\u0026gt; \u0026lt;description\u0026gt;标签描述\u0026lt;/description\u0026gt; \u0026lt;name\u0026gt;标签名\u0026lt;/name\u0026gt; \u0026lt;tag-class\u0026gt;标签的处理\u0026lt;/tag-class\u0026gt; \u0026lt;body-content\u0026gt;标签体的类型\u0026lt;/body-content\u0026gt; \u0026lt;/tag\u0026gt; \u0026lt;/taglib\u0026gt;  scriptlet：\n\u0026lt;% ... %\u0026gt; \u0026lt;%！ ... %\u0026gt; \u0026lt;%= ... %\u0026gt;  导入并使用 位置：myTag.tld导入 WEB-INF或子目录下WEB-INF/xxx/(特例排除，不能是WEB-INF/lib、WEB-INF/classes )\n使用：\n引入具体要使用的.tld文件\n\u0026lt;%@ taglib uri=\u0026quot;...\u0026quot; prefix=\u0026quot;d\u0026quot; %\u0026gt;   uri：每个tld文件的 唯一描述符 prefix：使用tld标签时 的前缀  具体的使用：\n 空标签（没有标签体的标签）\n\u0026lt;d:foreach\u0026gt;\u0026lt;/d:foreach\u0026gt; \u0026lt;d:foreach /\u0026gt;  带标签体\n\u0026lt;d:foreach\u0026gt; xxx \u0026lt;/d:foreach\u0026gt;  带属性\n\u0026lt;d:foreach 属性名=\u0026quot;属性值\u0026quot; \u0026gt; xxx \u0026lt;/d:foreach\u0026gt; \u0026lt;d:foreach collection=\u0026quot;${students}\u0026quot; \u0026gt; xxx \u0026lt;/d:foreach\u0026gt;  嵌套\n\u0026lt;d:foreach\u0026gt; \u0026lt;d:foreach\u0026gt; xxx \u0026lt;/d:foreach\u0026gt; \u0026lt;/d:foreach\u0026gt; \u0026lt;d:foreach\u0026gt;   实际开发步骤 编写标签处理类\n先确保项目有tomcat环境\nTag接口：\ndoStartTag()：标签处理类的核心方法 （标签体的执行逻辑）\n该方法有以下2个返回值：0/1\nint SKIP_BODY = 0; 标签体不会被执行 int EVAL_BODY_INCLUDE = 1; 标签体会被执行  doEndTag()：标签执行完毕之后 的方法.例如可以让 标签在执行完毕后，再执行一次\nint SKIP_PAGE = 5;后面的JSP页面内容不被执行 int EVAL_PAGE = 6;后面的JSP页面内容继续执行  Tag接口中的所有方法执行顺序：\njsp - servlet\n当JSP容器（Tomcat、jetty）在将.jsp翻译成.servlet(.java)的时候 ,如果遇到JSP中有标签，就会依次执行 setPageContext() setParent()doStartTag() doEndTagrealease(),用于解析标签的执行逻辑。\njavax.servlet.jsp.tagext.IterationTag接口：（是Tag的子接口）\n 如果有循环：IterationTag，\n 没有循环：Tag\n  IterationTag接口中存在以下方法：\ndoAfterBody()：当标签体执行完毕之后的操作 ，通过返回值决定 ：\n（EVAL_BODY_AGAIN = 2）要么重复执行 ； （SKIP_BODY=0）：要么不再执行  目标：遍历3次 (hello)\n\u0026lt;xxx\u0026gt;hello\u0026lt;xxx\u0026gt;  执行一次，并重复两次\npublic class MyIteration extends TagSupport { private int num ;//执行次数 3 public void setNum(int num){ this.num = num ; } //执行标签 @Override public int doStartTag() throws JspException { return EVAL_BODY_INCLUDE ;//先执行一次 } //执行完毕后 @Override public int doAfterBody() throws JspException { num-- ; return num\u0026gt;0 ? EVAL_BODY_AGAIN :SKIP_BODY; //重复执行 } }  编写标签描述符\nmyTag.tld\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!-- 标签库的头文件--\u0026gt; \u0026lt;taglib xmlns=\u0026quot;http://java.sun.com/xml/ns/j2ee\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\u0026quot; version=\u0026quot;2.0\u0026quot;\u0026gt; \u0026lt;description\u0026gt;这是我的迭代器标签库\u0026lt;/description\u0026gt; \u0026lt;tlib-version\u0026gt;1.0\u0026lt;/tlib-version\u0026gt; \u0026lt;short-name\u0026gt;mytaglib\u0026lt;/short-name\u0026gt; \u0026lt;uri\u0026gt;http://www.yanqun.com\u0026lt;/uri\u0026gt; \u0026lt;!-- -自定义标签的相关信息 --\u0026gt; \u0026lt;tag\u0026gt; \u0026lt;description\u0026gt;这是我的迭代器标签\u0026lt;/description\u0026gt; \u0026lt;name\u0026gt;mytag\u0026lt;/name\u0026gt; \u0026lt;tag-class\u0026gt;com.yanqun.tag.MyIteration\u0026lt;/tag-class\u0026gt; \u0026lt;body-content\u0026gt;JSP\u0026lt;/body-content\u0026gt; \u0026lt;attribute\u0026gt; \u0026lt;name\u0026gt;num\u0026lt;/name\u0026gt; \u0026lt;required\u0026gt;true\u0026lt;/required\u0026gt; \u0026lt;/attribute\u0026gt; \u0026lt;/tag\u0026gt; \u0026lt;/taglib\u0026gt;  导入并使用\n位置：myTag.tld导入 WEB-INF或子目录下WEB-INF/xxx/(特例排除，不能是WEB-INF/lib、WEB-INF/classes )\n\u0026lt;%@ taglib uri=\u0026quot;http://www.yanqun.com\u0026quot; prefix=\u0026quot;yq\u0026quot;%\u0026gt;   \u0026lt;body\u0026gt; \u0026lt;yq:mytag num=\u0026quot;3\u0026quot;\u0026gt; hello \u0026lt;/yq:mytag\u0026gt; \u0026lt;/body\u0026gt;  BoyTag接口：如果在标签体 被显示之前，进行一些其他的“额外”操作\nhello hello hello -\u0026gt; HELLO HELLO HELLO\n包含属性：\nint EVAL_BODY_BUFFERED = 2  是doStartTag()的第三个返回值 ，代表一个缓冲区（BodyContent）。\nBodyContent是abstract,具体使用时需要使用实现类 BodyContentImpl(再引入jasper.jar)\n缓冲区（BodyContent）的使用用途：hello -\u0026gt;HELLO\n如果返回值是EVAL_BODY_BUFFERED ，则服务器会自动 将标签体需要显示的内容 放入缓冲区中（BodyContent）\n。因此，如果要更改最终显示结果，只需要从 缓冲区 获取原来的数据 进行修改即可。\n如何修改、获取 缓冲区：详见BodyContent的方法,具体就是 通过getXxx()获取原来的数据(hello),自己修改（HELLO）,输出getEnclosingWriter();\npublic class ToUpperCase extends BodyTagSupport { //第一步，告诉程序 我要将原来的hello变成大写，即将 doStartTag()的返回值设置成 EVAL_BODY_BUFFER (此步骤，已经在父类默认实现) //第二步：获取，并修改 @Override public int doEndTag() throws JspException { try { String content = getBodyContent().getString();//hello content = content.toUpperCase();//修改 bodyContent.getEnclosingWriter().write(content); } catch (Exception e) { e.printStackTrace(); } return super.doEndTag();//默认6，代表标签执行完毕后 是否执行其他的JSP元素 } }  \u0026lt;tag\u0026gt; \u0026lt;name\u0026gt;myToUpperCase\u0026lt;/name\u0026gt; \u0026lt;tag-class\u0026gt;com.yanqun.tag.ToUpperCase\u0026lt;/tag-class\u0026gt; \u0026lt;body-content\u0026gt;JSP\u0026lt;/body-content\u0026gt; \u0026lt;/tag\u0026gt;  简单方式 SimpleTag\n最大的简化：\n将传统方式的doStartTag() doEndTag() doafterBody()等方法 简化成了一个通用的 doTag()方法。\ndoTag() ：传统方式 可以对标签的最终显示 进行修改, hello -\u0026gt;HELLO ,核心是有一个缓冲区。\n但是简单方式 没有“缓冲区”。 如何修改显示内容？ 流\njavax.servlet.jsp.tagext.JspFragment类 ：代表一块JSP元素（该块 不包含scriptlet,因此简单方式的tld文件中\u0026lt;body-content\u0026gt;不能是JSP ）\nJspFragment中有一个invoke(Writer var1) 方法，入参是 “流”，即如果要修改显示内容，只需要修改此 流\ninvoke(Writer var1) ：每调用一次invoke()方法，会执行一次 标签体。\nSimpleTagSupport的 getJspBody()可以获取JspFragment对象。\nSimpleTagSupport的 getJspContext()方法 可以获取 jsp一些内置对象：getJspContext()的返回值是JspContext对象 是JSP内置对象的入口对象PageContext 的父类。\n简单标签方式 ，获取JSP内置对象： getJspContext() -\u0026gt; JspContext -\u0026gt;转成子类PageContext -\u0026gt;PageContext就是所有JSP内置对象的入口，即可以获取一切JSP内置对象\npublic class MySimpleTagIterator extends SimpleTagSupport { private int num ;//3 public int getNum() { return num; } public void setNum(int num) { this.num = num; } /* \u0026lt;aa\u0026gt; xxx \u0026lt;/aa\u0026gt; */ @Override public void doTag() throws JspException, IOException { JspFragment jspFragment = getJspBody(); for(int i=0;i\u0026lt;num ;i++){ jspFragment.invoke(null); } } }  \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!-- 标签库的头文件--\u0026gt; \u0026lt;taglib xmlns=\u0026quot;http://java.sun.com/xml/ns/j2ee\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\u0026quot; version=\u0026quot;2.0\u0026quot;\u0026gt; \u0026lt;description\u0026gt;这是我的简单迭代器标签库\u0026lt;/description\u0026gt; \u0026lt;tlib-version\u0026gt;1.0\u0026lt;/tlib-version\u0026gt; \u0026lt;short-name\u0026gt;mysimpletaglib\u0026lt;/short-name\u0026gt; \u0026lt;uri\u0026gt;http://www.yanqunsimple.com\u0026lt;/uri\u0026gt; \u0026lt;!-- -自定义标签的相关信息 --\u0026gt; \u0026lt;tag\u0026gt; \u0026lt;description\u0026gt;这是我的简单迭代器标签\u0026lt;/description\u0026gt; \u0026lt;name\u0026gt;mysimpletag\u0026lt;/name\u0026gt; \u0026lt;tag-class\u0026gt;com.yanqun.tag.MySimpleTagIterator\u0026lt;/tag-class\u0026gt; \u0026lt;body-content\u0026gt;scriptless\u0026lt;/body-content\u0026gt; \u0026lt;attribute\u0026gt; \u0026lt;name\u0026gt;num\u0026lt;/name\u0026gt; \u0026lt;required\u0026gt;true\u0026lt;/required\u0026gt; \u0026lt;/attribute\u0026gt; \u0026lt;/tag\u0026gt; \u0026lt;/taglib\u0026gt;  \u0026lt;%@ taglib uri=\u0026quot;http://www.yanqunsimple.com\u0026quot; prefix=\u0026quot;yqs\u0026quot;%\u0026gt; \u0026lt;yqs:mysimpletag num=\u0026quot;5\u0026quot;\u0026gt; nihao \u0026lt;/yqs:mysimpletag\u0026gt;  条件选择：\n当某一个条件满足时，再执行某个标签体\n传统标签：如果条件不满足，让doStartTag()的返回值为0；\n简单标签(不允许写scriplet \u0026lt;% \u0026hellip;%\u0026gt;)： 如果条件不满足，不调用invoke()即可。\n实例使用简单标签实现登录功能 \u0026lt;tag\u0026gt; \u0026lt;name\u0026gt;login\u0026lt;/name\u0026gt; \u0026lt;tag-class\u0026gt;com.yanqun.tag.LoginTag\u0026lt;/tag-class\u0026gt; \u0026lt;body-content\u0026gt;scriptless\u0026lt;/body-content\u0026gt; \u0026lt;/tag\u0026gt;  input.jsp\n\u0026lt;form action=\u0026quot;LoginServlet\u0026quot;\u0026gt; 用户名 \u0026lt;input name=\u0026quot;uname\u0026quot;/\u0026gt;\u0026lt;br/\u0026gt; 密码 \u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;upwd\u0026quot;/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;登录\u0026quot;/\u0026gt; \u0026lt;/form\u0026gt;  input.jsp\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String name = request.getParameter(\u0026quot;uname\u0026quot;) ; String pwd = request.getParameter(\u0026quot;upwd\u0026quot;) ; //zs ,abc if(name.equals(\u0026quot;zs\u0026quot;) \u0026amp;\u0026amp; pwd.equals(\u0026quot;abc\u0026quot;)){ //登录成功，将当前用户名 保存到session request.getSession().setAttribute(\u0026quot;name\u0026quot;,name); //User user = new User(); request.getRequestDispatcher(\u0026quot;show.jsp\u0026quot;).forward(request,response); }else{ //跳转到失败页面 response.sendRedirect(\u0026quot;error.jsp\u0026quot;); } }  show.jsp\n\u0026lt;%@taglib uri=\u0026quot;http://www.yanqunsimple.com\u0026quot; prefix=\u0026quot;yqs\u0026quot;%\u0026gt; \u0026lt;yqs:login\u0026gt; ${sessionScope.name},已登录 ${name} \u0026lt;/yqs:login\u0026gt;  LoginTag.java\npublic class LoginTag extends SimpleTagSupport { @Override public void doTag() throws JspException, IOException { //判断 是否已经登录成功 PageContext pageContext = (PageContext)getJspContext() ; HttpSession session = pageContext.getSession(); String name = (String)session.getAttribute(\u0026quot;name\u0026quot;) ; if(name !=null){ //执行一次标签体 getJspBody().invoke(null) ; } //如果成功，执行标签体 //如果失败，不执行 } }  验证码 强制刷新：除了禁止缓存以外，还需要给服务端传递一个唯一的参数值（没有实际用处）。随机数、时间\nimg.jsp\n\u0026lt;%@ page import=\u0026quot;java.awt.*\u0026quot; %\u0026gt; \u0026lt;%@ page import=\u0026quot;java.util.Random\u0026quot; %\u0026gt; \u0026lt;%@ page import=\u0026quot;java.awt.image.BufferedImage\u0026quot; %\u0026gt; \u0026lt;%@ page import=\u0026quot;javax.imageio.ImageIO\u0026quot; %\u0026gt; \u0026lt;%@ page contentType=\u0026quot;image/jpeg;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;%! //随机产生颜色值 public Color getColor(){ Random ran = new Random() ;//Math.random() 0-1 int r = ran.nextInt(256) ; int g = ran.nextInt(256) ; int b = ran.nextInt(256) ; return new Color(r,g,b) ;//red green blue 0-255 } //产生验证码值 public String getNum() { // 0-8999 1000-9999 int ran = (int)( Math.random()*9000) +1000 ; return String.valueOf(ran) ; } %\u0026gt; \u0026lt;% //禁止缓存，防止验证码过期 response.setHeader(\u0026quot;Pragma\u0026quot;,\u0026quot;no-cache\u0026quot;); response.setHeader(\u0026quot;Cache-Control\u0026quot;,\u0026quot;no-cache\u0026quot;); response.setHeader(\u0026quot;Expires\u0026quot;,\u0026quot;0\u0026quot;); //绘制验证码 BufferedImage image = new BufferedImage(80,30,BufferedImage.TYPE_INT_RGB) ; //画笔 Graphics graphics = image.getGraphics(); graphics.fillRect(0,0,80,30); //绘制干扰线条 for(int i=0;i\u0026lt;60;i++) { Random ran = new Random() ; int xBegin = ran.nextInt(80) ;//55 int yBegin = ran.nextInt(30) ; int xEnd = ran.nextInt(xBegin +10 ) ; int yEnd = ran.nextInt(yBegin + 10) ; graphics.setColor( getColor()); //绘制线条 graphics.drawLine(xBegin,yBegin,xEnd,yEnd); } graphics.setFont(new Font(\u0026quot;seif\u0026quot;,Font.BOLD,20)); //绘制验证码 graphics.setColor(Color.BLACK); String checkCode = getNum() ; //2 1 3 4 StringBuffer sb = new StringBuffer() ; for(int i=0;i\u0026lt;checkCode.length();i++){ sb.append(checkCode.charAt(i)+\u0026quot; \u0026quot; ) ;//验证码的每一位数字 } graphics.drawString( sb.toString(), 15,20 );//绘制验证码 //将验证码真实值 保存在session中，供使用时比较真实性 session.setAttribute(\u0026quot;CKECKCODE\u0026quot; ,checkCode ); //真实的产生图片 ImageIO.write(image,\u0026quot;jpeg\u0026quot;, response.getOutputStream()) ; //关闭 out.clear(); out = pageContext.pushBody() ; //\u0026lt;input type=\u0026quot;image\u0026quot; src=\u0026quot;xxx\u0026quot; /\u0026gt; %\u0026gt;  CheckCodeServlet.java\n@WebServlet(\u0026quot;/CheckCodeServlet\u0026quot;) public class CheckCodeServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String resultTip = \u0026quot;imgs/wrong.jpg\u0026quot;; //获取用户输入验证码 String checkcodeClient = request.getParameter(\u0026quot;checkcode\u0026quot;); //真实的验证码值 String checkcodeServer = (String) request.getSession().getAttribute(\u0026quot;CKECKCODE\u0026quot;); if(checkcodeServer.equals(checkcodeClient)){ resultTip = \u0026quot;imgs/right.jpg\u0026quot;; } response.setContentType(\u0026quot;text/html;charset=UTF-8\u0026quot;); PrintWriter writer = response.getWriter();//输出流 writer.write(resultTip); writer.flush(); writer.close(); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } }  index.jsp\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;jquery-3.3.1.js\u0026quot; \u0026gt; \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; \u0026gt; function reloadCheckImg() { $(\u0026quot;img\u0026quot;).attr(\u0026quot;src\u0026quot;, \u0026quot;img.jsp?t=\u0026quot;+(new Date().getTime())); //\u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; } $(document).ready(function(){ $(\u0026quot;#checkcodeId\u0026quot;).blur(function(){ var $checkcode = $(\u0026quot;#checkcodeId\u0026quot;).val(); //校验 :文本框中输入的值 发送到服务端。 //服务端： 获取文本框输入的值 ，和真实验证码图片中的值对比 ，并返回验证结果 $.post( \u0026quot;CheckCodeServlet\u0026quot;,//服务端地址 \u0026quot;checkcode=\u0026quot;+$checkcode , function(result){//图片地址（imgs/right.jpg imgs/wrong.jpg） //result: imgs/right.jpg var resultHtml = $(\u0026quot;\u0026lt;img src='\u0026quot;+result+\u0026quot;' height='15' width='15px' /\u0026gt;\u0026quot;) ; $(\u0026quot;#tip\u0026quot;).html(resultHtml); } ); }); }); \u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;验证码\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 验证码： \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;checkcode\u0026quot; id=\u0026quot;checkcodeId\u0026quot; size=\u0026quot;4\u0026quot; /\u0026gt; \u0026lt;!-- 验证码--\u0026gt; \u0026lt;a href=\u0026quot;javascript:reloadCheckImg();\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;img.jsp\u0026quot;/\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;span id=\u0026quot;tip\u0026quot;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  集群： apache、 nginx  tomcat:理论上 单节点tomcat能够稳定的 处理请求并发量200-300；\n负载均衡\n失败迁移\n服务端集群：\n 水平集群 :将服务器安装在 各个不同的计算机上 （失败迁移）\n 垂直集群 ：将多个服务器，安装在同一个计算机上 （负载均衡）\n 水平+垂直\n  搭建集群： apache :特点是处理静态资源（html 图片 js） .这里的apache是一个服务工具，不是 之前理解的 基金组织。\ntomcat:特点 可以处理动态资源\napache+tomcat:动静分离\napache：请求的分流操作\n下载apache服务器工具下载地址\n配置：\nconf/http.conf（37行左右）\nDefine SRVROOT \u0026quot;D:\\dev\\cluster\\Apache24\u0026quot;  看一看将apache配置成windows服务，既可以在服务中启动停止服务：\n管理员身份打开cmd，通过命令注册apache服务\n\u0026quot;C:\\workplace\\jar\\cluster\\httpd-2.4.41-win64-VS16\\Apache24\\bin\\httpd.exe\u0026quot; -k install -n apache24  删除服务\nsc delete 服务名  如果在注册apache服务时，提示“丢失VCRUNTIME140.DLL”，则需要下载并安装vc_redist.x64.exe。下载地址\n注册成功后，启动，浏览器访问\nlocalhost  查看是否成功访问\n准备tomcat：复制两份，改端口\n 规划并修改端口： server.xml\n 22行 63行 108行 server端口号 http协议端口 ajp协议端口号 tomcat-a: 1005 1080 1009 tomcat-b: 2005 2080 2009  配置引擎Engine ： server.xml\n增加jvmRoute（128行）\n\u0026lt;Engine name=\u0026quot;Catalina\u0026quot; defaultHost=\u0026quot;localhost\u0026quot; jvmRoute=\u0026quot;tomcat-b\u0026quot;\u0026gt;  打开集群开关 server.xml（133行）\n打开以下注释\n\u0026lt;Cluster className=\u0026quot;org.apache.catalina.ha.tcp.SimpleTcpCluster\u0026quot;/\u0026gt;   tomcat集群配置搞定，apache启动\n-\u0026gt;结合apache+tomcat :mod_jk.so\n下载地址\n配置mod_jk.so：  存放位置，\\Apache24\\modules\\mod_jk.so\n 配置\\Apache24\\conf\\workers.properties\n 配置\\Apache24\\conf\\mod_jk.conf （用于加载mod_jk.so和workers.properties）\n 配置httpd.conf： 在apache启动时 自动加载mod_jk.conf：\n追加(最后)\ninclude conf/mod_jk.conf  mod_jk.so,workers.properties -\u0026gt;mod_jk.conf -\u0026gt; apache程序会自动加载httpd.conf\n 在项目web.xml中添加\n\u0026lt;distributable/\u0026gt;  表示开启项目同步\n  部署项目将项目分别部署到tomcat中\n依次启动apache、tomcata、tomcatb 访问\nhttp://localhost/ClusterProject/  workers.properties\nworker.list=controller,tomcata,tomcatb #tomcata worker.tomcata.port=1009 worker.tomcata.host=localhost worker.tomcata.type=ajp13 #负载均衡的权重 worker.tomcata.lbfactor=1 #tomcatb worker.tomcatb.port=2009 worker.tomcatb.host=localhost worker.tomcatb.type=ajp13 #负载均衡的权重 worker.tomcatb.lbfactor=2 #controller worker.controller.type=lb worker.controller.balanced_workers=tomcata,tomcatb worker.controller.sticky_session=false  分布式session策略：  sticky:固定将每一个用户的请求 分给特定的服务器，后期的请求不会分给其他服务器\n弊端：无法失败迁移\n session广播（自动同步session）： 自动同步session，\n弊端：如果服务器太多，可能造成广播风暴（将一个服务器的session,需要同步到其他所有的服务器中）\n 集中管理方式（推荐）：将各个服务器的session集群存储到一个 数据库中\n  mod_jk.conf\n#加载mod_jk.so LoadModule jk_module modules/mod_jk.so #加载workers.properties JkWorkersFile conf/workers.properties JkMount /* controller  路径以apache的根目录开始找\n其中JkMount /* controller，表示拦截一切请求。也可以只拦截jsp： /*.jsp\n集群 应用阶段、部署实施\nCATALINA_HOME会使 启动tomcat时 自动开启CATALINA_HOME指定的tomcat。而集群中 需要开启多个不同的tomcat，因此 在单机环境下，需要删除CATALINA_HOME。\n依次启动apache、tomcata、tomcatb\n原因：\napache之前已经成功运行，但是重启时 失败  分析思路：\n成功运行的时机：第一把apche下载完后 失败时机： apache+tomcat整合  得出结论： 整合\n测试：失败迁移 负载均衡 session共享\n细节：  apache:\nworker.list=controller,tomcata,tomcatb  流程：apache-\u0026gt;workers.properties中配置的 ip:端口 找到具体的tomcat服务（与tomcat中的jvmRoute=\u0026ldquo;tomcat-a\u0026rdquo;的没有关系）\n tomcat配置：（只需要保证 所有tomcat的jvmRoute不能重名即可 ，可以和apache中的命名不一致）\njvmRoute=\u0026quot;tomcat-a\u0026quot; jvmRoute=\u0026quot;tomcat-b\u0026quot;  tomcat服务的目录名：（任意）\ntomcata tomcatb   ","id":39,"section":"posts","summary":"源码 EL Expression Launguage:可以代替JSp页面中的Java代码 传统的在jsp代码中显示java代码 需要使用\u0026lt;%%\u0026gt;\u0026lt;%=%","tags":["J2EE"],"title":"JSP进阶学习笔记","uri":"https://mumulx.github.io/2019/11/jsp%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" vm安装centos6 新建虚拟机\n稍后安装操作系统\n处理器数量（虚拟的，只跟自己的真实机有关）1，1，1\n内存2048\n网络nat\n磁盘20G\n完成\n编辑虚拟机设置\n设置iso镜像位置\n开启虚拟机\n第一项回车\nskip 跳过检测\n语言简体中文\n键盘默认\n是忽略所有数据\n主机名 centosinit\n选择时区 亚洲/上海\n输入密码\n自定义系统布局\n磁盘布局: 创建 标准分区\n/boot:系统启动时需要的内存200M /:系统的可用磁盘大小10240M swap:交换内存，建议大小和内存一致2048M  鼠标从虚拟机中释放: ctrl+alt\n下一步\n格式化\n是将修改写入磁盘\nDesktopt 现在自定义\n基本系统取消java平台\n下一步\n重新引导\n不创建用户\n关于vmware中计算机名子: 虚拟机名: bigdata01 计算机名: bigdata01 网络中的名字: bigdata01 用户名:root  默认超级管理员: root/自己设置\n查看计算机名: hostname hostname  查看计算机名\n通过文本编辑器打开文件: vi路径/文件名\nvi /etc/sysconfig/network  查看文件: cat /etc/sysconfig/network\n编辑: a\n保存: esc，shift +z+z\n重启计算机:reboot\n关机:halt\nlinux安装vm tools 虚拟机\u0026ndash;\u0026gt;安装vmtool\u0026mdash;\u0026gt;复制压缩包xxx.tar.gz到桌面\u0026ndash;\u0026gt;解压缩\u0026ndash;\u0026gt;xxxx.pl\u0026mdash;\u0026gt;在命令行打开，一直回车\u0026ndash;\u0026gt;重启\ncentos网络配置 编辑\u0026ndash;》虚拟机网络设置\u0026ndash;》更改设置》NAT模式 vmnet8\n子网ip 192.168.2.0\n子网掩码255.255.255.0\nDHCP设置\n起始IP192.168.2.128 终止ip192.168.2.254\nNAT设置 网关192.168.2.1\n配置windows访问虚拟机 网络\u0026ndash;》右键属性\u0026ndash;》更改适配器设置\u0026ndash;网络连接- vmNet8- -TCP/IP V4 - IP192. 168. 2.2，网关192. 168.2. 1 ，子网掩码 255.255.255.0\ncentos网卡 vi /etc/sysconfig/network-scripts/ifcfg-eth0  DEVICE=eth0 HWADDR=00:0C:29:26:8F:4F TYPE=Ethernet UUID=d7986e04-0a7d-4f73-a69a-782be645067b --修改以下配置 ONBOOT=yes NM_CONTROLLED=yes BOOTPROTO=static IPADDR=192.168.2.128 GATEWAY=192.168.2.1 BROADCAST=192.168.2.255 DNS1=114.114.114.114 DNS2=8.8.8.8  vi如果使用shift+z+z无法保存，则使用\u0026rdquo;:wq!\u0026rdquo;\n通过网络名访问虚拟机(192. 168. 2.128 -\u0026gt;bi gdata01)  centos:\nvi /etc/hosts, 追加: 192.168.2.128 centos6  windows:\nC: \\Windows \\System32\\drivers\\etc\\hosts 追加: 192.168.2.128 bigdata01   配置网络服务 service NetworkManager stop /etc/init.d/network restart chkconfig NetworkManager off vi /etc/resolv.conf 追 加 nameserve 192. 168. 2.1 service network restart  防火墙 service iptables stop：关闭当前防火墙 chkconfig iptables off：禁止开机自启 service iptables status：查看当前防火墙状态  自动同步时间 yum -y install ntp utpdate：安装时间插件 ntpdate cn.pool.ntp.org：根据网站同步时间 hwclock --systohc：将系统时间写入硬盘时间  windows真实机通过SecureCRT操作centos  下载SecureCRT\n通过SecureCRT对centos进行文件的上传下载:\nyum -y install lrzsz  上传:切换到当前目录cd /tmp, 直接用鼠标拖拽，Zmodem. .\n  添加连接 单击快速连接(alt+q)\nhostname 填写ip地址\nusername 填写root\n下载安装jdk（rpm方式） exe:rpm rar:.tar.gz  下载rpm版jdk\n安装:切到 rpm版 jdk的文件夹中，\nrpm -ivh jdk名字  ll:查看当前文件夹文件 pwd:查看当前所在的目录 rpm安装完毕之后全部在usr文件夹中\n例如Java的安装位置：/usr/java/jdk1.8.0_231-amd64\nlinux：一切都是文件，一切都是命令\n配置环境变量: vi /etc/profile 中 的最后追加: export JAVA_ HOME=/usr/java/jdk1.8.0_ 181-amd64 export CLASSPATH=$JAVA_HOME$\\lib: $CLASSPATH export PATH=$JAVA_HOME$\\bin:$PATH  让环境变量立即生效\nsource /etc/profile  集群(3台) :完整克隆 bigdata01 -\u0026gt; bigdata02/bi gdata03  克隆完毕后:\n 将从计算机的内存适当降低\n 修改从计算中唯一性的配置(ip、uuid、hostname映射)\n在克隆后的bigdata02/bigdata03中\n修改计算机名:\nvi /etc/sysconfig/network  修改ip\nvi /etc/sysconfig/network-scripts/ifcfg-eth0 修改IP地址 删除uuid/hwaddr (在重启时，自动生成)  删除文件：\nrm -r /etc/udev/rule.d/70-persistent-net.rules 输入yes  映射\ncentos\nvi /etc/hosts 追加: 192.168. 2.128 bi gdata01 192. 168. 2. 129 bi gdata02 192.168. 2. 130 bi gdata03  windows:\nC: \\Windows \\System32\\drivers\\etc \\hosts 追加: 192.168. 2.128 bi gdata01 192. 168. 2. 129 bi gdata02 192.168. 2. 130 bi gdata03   SSH免密钥登录 生成密钥 ssh-keygen -t rsa  一直回车\n存储路径：\n/root/.ssh  id_rsa:私钥\nid_rsa.pub：公钥\n发送给其他计算机 发送私钥(本机)：\nssh-copy-id localhost yes 当前用户密码  发送公钥（其他计算机）\nssh-copy-id xxxx yes xxxx计算机的密码  测试免密钥登录\nssh localhost ssh xxxx  用户权限 用户组 创建用户组\ngroupadd bd  在用户组中添加用户\nuseradd -g bd lx passwd lx 回车 输入密码  给用户提升权限（在/etc/sudoers中设置lx的权限）\n/etc/sudoers文件本身是可读的，所以修改该文件前需要，将只读禁止\nchmod 777 /etc/sudoers 最高权限（可读可写）  编辑文件\n追加\nlx ALL(ALL) ALL  还原/etc/sudoers的权限为只读：\nchomd 440 /etc/sudoers  删除用户 userdel lx  切换用户 su lx 切换普通用户 su 切换到管理员用户  jps 查看进程\njps  删除进程\nkill -9 进程编号  Linux Centos7 安装 新建虚拟机\n稍后安装操作系统\n处理器数量（虚拟的，只跟自己的真实机有关）1，1，1\n内存2048\n网络nat\n磁盘20G\n完成\n编辑虚拟机设置\n设置iso镜像位置\n开启虚拟机\n第一项回车\n语言推荐选英语\n更改时区\nSOFTWARE SELECTION选择\nGNOME Desktop  INSTALLATION DESTINATION选择\nI will configure partitioning  Standard Partition 点击+\n/ 10240 /boot 300 swap 1024(与内存大小一致)  设置管理员密码\n重启\n同意协议\n设置hostname hostnamectl set-hostname centos7init  设置ip 编辑\u0026ndash;》虚拟网络编辑器，与centos6设置一样\ncd /etc/sysconfig/network-scripts/ ls  DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=f75a83a8-750a-40db-8ac1-562e6190d1e4 DEVICE=ens33 ONBOOT=yes IPADDR=192.168.2.150 GATEWAY=192.168.2.1 BROADCAST=192.168.2.255 DNS1=114.114.114.114 DNS2=8.8.8.8  域名映射 vi /etc/hosts 192.168.2.150 centos7init  windows:\nC: \\Windows \\System32\\dr ivers\\etc \\hosts 追加: 192.168.2.150 centos7init  配置网络服务 service NetworkManager stop /etc/init.d/network restart chkconfig NetworkManager off vi /etc/resolv.conf 追 加 nameserve 192. 168. 2.1 service network restart  防火墙 systemctl stop firewalld：关闭当前防火墙 systemctl disable firewalld：禁止开机自启  自动同步时间 yum -y install ntp utpdate：安装时间插件 ntpdate cn.pool.ntp.org：根据网站同步时间 hwclock --systohc：将系统时间写入硬盘时间  windows真实机通过SecureCRT操作centos  下载SecureCRT\n通过SecureCRT对centos进行文件的上传下载:\nyum -y install lrzsz  上传:切换到当前目录cd /tmp, 直接用鼠标拖拽，Zmodem. .\n  添加连接 单击快速连接(alt+q)\nhostname 填写ip地址\nusername 填写root\n下载安装jdk（rpm方式） exe:rpm rar:.tar.gz  下载rpm版jdk\n安装:切到 rpm版 jdk的文件夹中，\nrpm -ivh jdk名字  例如Java的安装位置：/usr/java/jdk1.8.0_231-amd64\nlinux：一切都是文件，一切都是命令\n配置环境变量: vi /etc/profile 中 的最后追加: export JAVA_ HOME=/usr/java/jdk1.8.0_231-amd64 export CLASSPATH=$JAVA_HOME$\\lib: $CLASSPATH export PATH=$JAVA_HOME$\\bin:$PATH  让环境变量立即生效\nsource /etc/profile  集群(3台) :完整克隆 克隆完毕后:\n 将从计算机的内存适当降低\n 修改从计算中唯一性的配置(ip、uuid、hostname映射)\n在克隆后的bigdata02/bigdata03中\n修改计算机名:\nhostnamectl set-hostname xxxx  修改ip\ncd /etc/sysconfig/network-scripts/ ls 删除uuid(在重启时，自动生成)  映射\ncentos\nvi /etc/hosts 追加: 192.168. 2.128 bi gdata01 192. 168. 2. 129 bi gdata02 192.168. 2. 130 bi gdata03  windows:\nC: \\Windows \\System32\\drivers\\etc \\hosts 追加: 192.168. 2.128 bi gdata01 192. 168. 2. 129 bi gdata02 192.168. 2. 130 bi gdata03   SSH免密钥登录 生成密钥 ssh-keygen -t rsa  一直回车\n存储路径：\n/root/.ssh  id_rsa:私钥\nid_rsa.pub：公钥\n发送给其他计算机 发送私钥(本机)：\nssh-copy-id localhost yes 当前用户密码  发送公钥（其他计算机）\nssh-copy-id xxxx yes xxxx计算机的密码  测试免密钥登录\nssh localhost ssh xxxx  ","id":40,"section":"posts","summary":"vm安装centos6 新建虚拟机 稍后安装操作系统 处理器数量（虚拟的，只跟自己的真实机有关）1，1，1 内存2048 网络nat 磁盘20G 完成 编辑","tags":["杂七杂八"],"title":"Linux Centos6安装","uri":"https://mumulx.github.io/2019/11/linux-centos6%E5%AE%89%E8%A3%85/","year":"2019"},{"content":" Mybatis 简介 官网\nmybatis:\nibatis:apache\n2010 ibatis-\u0026gt; google colde ,Mybatis\nMyBatis可以简化JDBC操作，实现数据的持久化 。\nORM:Object Relational Mapping\nORM可以解决数据库与程序间的异构性，比如在Java中我们使用String表示字符串，而Oracle中可使用varchar2，MySQL中可使用varchar，SQLServer可使用nvarchar。\n对象关系映射(英语:Object Relational Mapping，简称ORM，或O/RM，或O/R mapping)，用于实现面向对象编程语言里不同类型系统的数据之间的转换。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象与关系数据库相互映射。\n person对象 person表 之间一一映射起来\n ORM：概念 ，Mybatis是ORM的一个实现/Hibernate orm可以是的开发人员像操作对象一样操作数据库表。\n开发mybatis程序从步骤： 所有学习源码git地址\njar包 mybatis-3.4.6.jar  类\u0026ndash;表 public class Student { private int id; private String name; private int age ; public Student() { } public Student(int id, String name, int age) { this.id = id; this.name = name; this.age = age; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return this.id+\u0026quot;,\u0026quot;+this.name+\u0026quot;,\u0026quot;+this.age ; } }  配置mybatis conf.xml:配置数据库信息 和 需要加载的映射文件 表 - 类\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026quot;-//mybatis.org//DTD Config 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026quot;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;environment id=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot;/\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;!-- 配置数据库信息 --\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;oracle.jdbc.OracleDriver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;scott\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;tiger\u0026quot;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;!-- 加载映射文件 --\u0026gt; \u0026lt;mapper resource=\u0026quot;org/lanqiao/entity/personMapper.xml\u0026quot;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;  映射文件xxMapper.xml :增删改查标签\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot;\u0026gt; \u0026lt;mapper namespace=\u0026quot;org.lanqiao.entity.personMapper\u0026quot;\u0026gt; \u0026lt;select id=\u0026quot;queryPersonById\u0026quot; resultType=\u0026quot;org.lanqiao.entity.Person\u0026quot; parameterType=\u0026quot;int\u0026quot;\u0026gt; select * from person where id = #{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;  测试类：\npublic class TestMyBatis { public static void main(String[] args) throws IOException { //加载MyBatis配置文件（为了访问数据库） Reader reader = Resources.getResourceAsReader(\u0026quot;conf.xml\u0026quot;) ; SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader) ; //session - connection SqlSession session = sessionFactory.openSession() ; String statement = \u0026quot;org.lanqiao.entity.personMapper.queryPersonById\u0026quot; ; Student person = session.selectOne( statement,1 ) ; System.out.println(person); session.close(); } }   session.selectOne(\u0026ldquo;需要查询的SQL的namespace.id\u0026rdquo;,\u0026ldquo;SQL的参数值\u0026rdquo;);\n conf.xml配置文件 配置文件的提示功能是通过\nPUBLIC \u0026quot;-//mybatis.org//DTD Config 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026quot;  来配置的，因此需要联网，也可以将http://mybatis.org/dtd/mybatis-3-config.dtd下载下来，通过，windows-Preferences\u0026ndash;\u0026gt;XML\u0026ndash;\u0026gt;XML Catalog\u0026ndash;\u0026gt;Catalog Entry指定文件的内容；其中Location放文件地址，Key放-//mybatis.org//DTD Config 3.0//EN\n切换环境 \u0026lt;!-- 通过environments的default值 和 environment的 id 来指定 MyBatis运行时的数据库环境--\u0026gt; \u0026lt;environments default=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;!-- 开发环境（自己的计算机） --\u0026gt; \u0026lt;environment id=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;!-- 事务提交方式： JDBC:利用JDBC方式处理事务（手工commit rollback close） MANAGED：将事务交由 其他组件去托管（spring ,jobss）,默认 会关闭连接。 关闭默认值，默认不关闭 \u0026lt;transactionManager type=\u0026quot;MANAGED\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;closeConnection\u0026quot; value=\u0026quot;false\u0026quot;/\u0026gt; --\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot; /\u0026gt; \u0026lt;!-- 数据源类型： UNPOOLED:传统的JDBC模式（每次访问数据库，均需要 打开、关闭等数据库操作，但是 打开、关闭数据库是比较消耗性能的，不推荐使用） POOLED：使用数据库连接池 JNDI：从tomcat中获取一个内置的数据库连接池 （数据库连接池-数据源 ） --\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;!-- 配置数据库信息 --\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;oracle.jdbc.OracleDriver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;scott\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;tiger\u0026quot;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;!-- 真正的项目应该在 发布的那台计算机上运行 --\u0026gt; \u0026lt;environment id=\u0026quot;shishi\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot;/\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;!-- 配置数据库信息 --\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;oracle.jdbc.OracleDriver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;jdbc:oracle:thin:@192.168.1.183:1521:ORCL\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;scott\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;tiger\u0026quot;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;!-- --\u0026gt; \u0026lt;environment id=\u0026quot;test\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot;/\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;!-- 配置数据库信息 --\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;oracle.jdbc.OracleDriver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;jdbc:oracle:thin:@192.168.1.111:1521:ORCL\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;scott\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;tiger\u0026quot;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt;  还可以通过硬编码的方式指定环境，即使conf中default已经指定了默认环境。可以通过build的第二参数 指定数据库环境\nSqlSessionFactory sessionFacotry = new SqlSessionFactoryBuilder().build(reader, \u0026quot;development\u0026quot;);  xxxMapper.xml文件 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot;\u0026gt; \u0026lt;!-- namespace:该mapper.xml映射文件的 唯一标识 --\u0026gt; \u0026lt;mapper namespace=\u0026quot;org.lanqiao.mapper.StudentMapper\u0026quot;\u0026gt; \u0026lt;/mapper\u0026gt;  后续通过 namespace.id定位sql语句\nparameterType:输入参数的类型\nresultType：查询返回结果值的类型 ，返回类型\n复习第一个MyBatis程序： mybatis.jar ojdbc.jar   conf.xml (数据库配置信息、映射文件)\n 表-类：映射文件 mapper.xml\n 测试\n  基础方式的增删改查CRUD: mybatis约定：\n输入参数parameterType 和 输出参数resultType ，在形式上都只能有一个\n 如果输入/输出参数 ：\n 是简单类型（8个基本类型+String） 是可以使用任何占位符,#{xxxx}\n 如果是对象类型，则必须是对象的属性 #{属性名}\n  输出参数：\n 如果返回值类型是一个 对象（如Student），则无论返回一个、还是多个，在resultType都写成org.lx.entity.Student即 resultType=\u0026quot;org.lx.entity.Student\u0026quot;   注意事项：\n 如果使用的 事务方式为 jdbc,则需要 手工commit提交，即\nsession.commit();  所有的标签 \u0026lt;select\u0026gt; \u0026lt;update\u0026gt;等 ，都必须有sql语句，但是sql参数值可选(重载了函数，有一个参数，有两个参数)\nsql有参数：session.insert(statement, 参数值 ); sql没参数：session.insert(statement);   增加 \u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;org.lanqiao.entity.Student\u0026quot; \u0026gt; insert into student(stuno,stuname,stuage,graname) values(#{stuNo},#{stuName},#{stuAge},#{graName} ) \u0026lt;/insert\u0026gt;  String statement = \u0026quot;org.lanqiao.entity.studentMapper.\u0026quot;+\u0026quot;addStudent\u0026quot;; Student student = new Student(13, \u0026quot;ww3\u0026quot;, 23, \u0026quot;s3\u0026quot;); int count = session.insert(statement,student); session.commit();  删除 \u0026lt;delete id=\u0026quot;deleteStudentByStuno\u0026quot; parameterType=\u0026quot;int\u0026quot;\u0026gt; delete from student where stuno = #{stuno} \u0026lt;/delete\u0026gt;  String statement = \u0026quot;org.lanqiao.entity.studentMapper.\u0026quot;+\u0026quot;deleteStudentByStuno\u0026quot;; int count = session.delete(statement,3) session.commit();  修改 \u0026lt;update id=\u0026quot;updateStudentByStuno\u0026quot; parameterType=\u0026quot;org.lx.entity.Student\u0026quot; \u0026gt; update student set stuname=#{stuName} ,stuage=#{stuAge},graname=#{graName} where stuno=#{stuNo} \u0026lt;/update\u0026gt;  String statement = \u0026quot;org.lanqiao.entity.studentMapper.\u0026quot;+\u0026quot;updateStudentByStuno\u0026quot;; Student student = new Student(); // 修改哪个人，where stuno =2 student.setStuNo(2); // 修改成什么样子？ student.setStuName(\u0026quot;ls\u0026quot;); student.setStuAge(24); student.setGraName(\u0026quot;s1\u0026quot;); int count = session.update(statement,student) session.commit();  查询 查询一个\n\u0026lt;select id=\u0026quot;queryStudentByStuno\u0026quot; parameterType=\u0026quot;int\u0026quot; resultMap=\u0026quot;org.lx.entity.Student\u0026quot; \u0026gt; select * from student where stuno = #{stuno} \u0026lt;/select\u0026gt;  String statement = \u0026quot;org.lanqiao.entity.studentMapper.\u0026quot;+\u0026quot;queryStudentByStuno\u0026quot;; Student student = session.selectOne(statement,1)  查询多个\n\u0026lt;select id=\u0026quot;queryAllStudents\u0026quot; resultType=\u0026quot;org.lx.entity.Student\u0026quot; \u0026gt; select * from student \u0026lt;/select\u0026gt;  String statement = \u0026quot;org.lanqiao.entity.studentMapper.\u0026quot;+\u0026quot;queryAllStudents\u0026quot;; List\u0026lt;Student\u0026gt; students = session.selectList(statement)  mapper动态代理方式的crud （MyBatis接口开发）: 原则：约定优于配置\n硬编码方式\nabc.java\nConfiguration conf = new Configuration(); con.setName(\u0026quot;myProject\u0026quot;) ;  配置方式：\nabc.xml\n\u0026lt;name\u0026gt;myProject\u0026lt;/name\u0026gt;  配置方式优于硬编码方式\n约定方式优于硬编码方式\n约定：\n默认值就是myProject\n具体实现的步骤：\n 基础环境：\nmybatis.jar/ojdbc.jar、conf.xml、mapper.xml\n 不同之处\n约定的目标：省略掉statement,即根据约定直接可以定位出SQL语句\n   接口，接口中的方法必须遵循以下约定：\n 方法名和mapper.xml文件中标签的id值相同\n 方法的 输入参数和mapper.xml文件中标签的 parameterType类型一致 (如果mapper.xml的标签中没有 parameterType，则说明方法没有输入参数)\n 方法的返回值和mapper.xml文件中标签的 resultType类型一致 （无论查询结果是一个 还是多个（student、List\u0026lt;Student\u0026gt;），在mapper.xml标签中的resultType中只写 一个（Student）；如果没有resultType，则说明方法的返回值为void）\n  除了以上约定，要实现 接口中的方法 和 Mapper.xml中SQL标签一一对应，还需要以下1点：\n   namespace的值 ，就是 接口的全类名（ 接口 - mapper.xml 一一对应）\n 匹配的过程：（约定的过程）\n 根据 接口名 找到 mapper.xml文件（根据的是namespace=接口全类名） 根据 接口的方法名 找到 mapper.xml文件中的SQL标签 （方法名=SQL标签Id值）\n以上2点可以保证： 当我们调用接口中的方法时， 程序能自动定位到 某一个Mapper.xml文件中的sqL标签\n  习惯：SQL映射文件（mapper.xml） 和 接口放在同一个包中 （注意修改conf.xml中加载mapper.xml文件的路径）\n以上，可以通过接口的方法-\u0026gt;SQL语句\n接口中的方法-\u0026gt;SQL语句\n执行：\n通过session对象获取接口（session.getMapper(接口.class);），再调用该接口中的方法，程序会自动执行该方法对应的SQL。\n增加 \u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;org.lanqiao.entity.Student\u0026quot; \u0026gt; insert into student(stuno,stuname,stuage,graname) values(#{stuNo},#{stuName},#{stuAge},#{graName} ) \u0026lt;/insert\u0026gt;  void addStudent(Student student);  Student student = new Student(13, \u0026quot;ww3\u0026quot;, 23, \u0026quot;s3\u0026quot;); StudentMapper studentMapper = session.getMapper(StudentMapper.class); studentMapper.addStudent(student);  删除 \u0026lt;delete id=\u0026quot;deleteStudentByStuno\u0026quot; parameterType=\u0026quot;int\u0026quot;\u0026gt; delete from student where stuno = #{stuno} \u0026lt;/delete\u0026gt;  void deleteStudentByStuno(int stuno);  StudentMapper studentMapper = session.getMapper(StudentMapper.class); studentMapper.deleteStudentByStuno(13);  修改 \u0026lt;update id=\u0026quot;updateStudentByStuno\u0026quot; parameterType=\u0026quot;org.lx.entity.Student\u0026quot; \u0026gt; update student set stuname=#{stuName} ,stuage=#{stuAge},graname=#{graName} where stuno=#{stuNo} \u0026lt;/update\u0026gt;  void updateStudentByStuno(Student student);  // 修改的参数 Student student = new Student(); // 修改哪个人，where stuno =2 student.setStuNo(2); // 修改成什么样子？ student.setStuName(\u0026quot;ls\u0026quot;); student.setStuAge(24); student.setGraName(\u0026quot;s1\u0026quot;); // 执行 StudentMapper studentMapper = session.getMapper(StudentMapper.class); studentMapper.updateStudentByStuno(student);  查询 查询单个学生\n\u0026lt;select id=\u0026quot;queryStudentByStuno\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;org.lanqiao.entity.Student\u0026quot; \u0026gt; select * from student where stuno = #{stuno} \u0026lt;/select\u0026gt;  Student queryStudentByStuno(int stuno);  StudentMapper studentMapper = session.getMapper(StudentMapper.class); Student student = studentMapper.queryStudentByStuno  查询多个\n\u0026lt;select id=\u0026quot;queryAllStudents\u0026quot; resultType=\u0026quot;org.lanqiao.entity.Student\u0026quot; \u0026gt; select * from student \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryAllStudents();  StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u0026lt;Student\u0026gt; students = studentMapper.queryAllStudents();// 接口的方法-\u0026gt;SQL  优化、 可以将配置信息 单独放入 db.properties文件中，然后再动态引入 新建文件db.properties\ndriver=oracle.jdbc.OracleDriver url=jdbc:oracle:thin:@127.0.0.1:1521:ORCL username=scott password=tiger  配置\n\u0026lt;configuration\u0026gt; \u0026lt;properties resource=\u0026quot;db.properties\u0026quot;/\u0026gt;  使用\n\u0026lt;environment id=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot; /\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;!-- 配置数据库信息 --\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;${driver}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;${url}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;${username}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${password}\u0026quot; /\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt;  引入之后，使用${key}\nMyBatis全局参数 Mybatis全局参数.png\n了解即可\n在conf.xml中设置，在configuration里面\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026quot;cacheEnabled\u0026quot; value=\u0026quot;false\u0026quot; /\u0026gt; \u0026lt;setting name=\u0026quot;lazyLoadingEnabled\u0026quot; value=\u0026quot;false\u0026quot; /\u0026gt; \u0026lt;/settings\u0026gt;  别名 conf.xml  设置单个别名\n\u0026lt;!-- 设置单个/多个别名 --\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;!-- 单个别名 （别名 忽略大小写） --\u0026gt; \u0026lt;typeAlias type=\u0026quot;org.lanqiao.entity.Student\u0026quot; alias=\u0026quot;student\u0026quot;/\u0026gt; \u0026lt;/typeAliases\u0026gt;  使用,在xxMapper.xml中\n\u0026lt;select id=\u0026quot;queryAllStudents\u0026quot; resultType=\u0026quot;sTuDenT\u0026quot; \u0026gt; select * from student \u0026lt;/select\u0026gt;  别名，忽略大小写\n 批量设置别名\n\u0026lt;typeAliases\u0026gt; \u0026lt;!-- 批量定义别名 （别名 忽略大小写），以下会自动将该包中的所有类 批量定义别名： 别名就是类名（不带包名，忽略大小写） --\u0026gt; \u0026lt;package name=\u0026quot;org.lanqiao.entity\u0026quot;/\u0026gt; \u0026lt;/typeAliases\u0026gt;  别名，忽略大小写\n  除了自定义别名外，MyBatis还内置了一些常见类的别名。\n类型处理器（类型转换器） MyBatis自带一些常见的类型处理器 自定义MyBatis类型处理器 java -数据库(jdbc类型)  示例：\n实体类Student : boolean stuSex\ntrue:男 false：女  表student： number stuSex\n1:男 0：女  自定义类型转换器（boolean -number）步骤：\n 创建转换器：需要实现TypeHandler接口\n通过阅读源码发现，此接口有一个实现类 BaseTypeHandler ，因此 要实现转换器有2种选择：\n 实现接口TypeHandler接口 继承BaseTypeHandler\n//BaseTypeHandler\u0026lt;java类型\u0026gt; public class BooleanAndIntConverter extends BaseTypeHandler\u0026lt;Boolean\u0026gt;{ //java(boolean)-DB(number) /* * ps:PreparedStatement对象 * i:PreparedStatement对象操作参数的位置 * parameter:java值 * jdbcType：JDBC操作的数据库类型 */ @Override public void setNonNullParameter(PreparedStatement ps, int i, Boolean parameter, JdbcType jdbcType) throws SQLException { if(parameter) { //1 ps.setInt(i, 1); }else { // 0 ps.setInt(i, 0); } } //db(number)-\u0026gt;java(boolean) @Override public Boolean getNullableResult(ResultSet rs, String columnName) throws SQLException { int sexNum = rs.getInt(columnName) ;//rs.getInt(\u0026quot;stuno\u0026quot;) ; // if(sexNum == 1) // // return true; // else { // return false ; // } return sexNum == 1?true:false ; } @Override public Boolean getNullableResult(ResultSet rs, int columnIndex) throws SQLException { int sexNum = rs.getInt(columnIndex) ;//rs.getInt(1) return sexNum == 1?true:false ; } @Override public Boolean getNullableResult(CallableStatement cs, int columnIndex) throws SQLException { int sexNum = cs.getInt(columnIndex) ;//rs.getInt(1) return sexNum == 1?true:false ; } }   配置conf.xml\n\u0026lt;typeHandlers\u0026gt; \u0026lt;typeHandler handler=\u0026quot;org.lanqiao.converter.BooleanAndIntConverter\u0026quot; javaType=\u0026quot;Boolean\u0026quot; jdbcType=\u0026quot;INTEGER\u0026quot; /\u0026gt; \u0026lt;/typeHandlers\u0026gt;  使用\n查询\n\u0026lt;!-- 查询：使用了类型转换器 1如果 类中属性 和表中的字段 类型能够合理识别 （String-varchar2），则可以使用resultType;否则(boolean-number) 使用resultMap 2如果 类中属性名 和表中的字段名能够合理识别 （stuNo -stuno）则可以使用resultType;否则(id-stuno) 使用resultMap --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentByStunoWithConverter\u0026quot; parameterType=\u0026quot;int\u0026quot; resultMap=\u0026quot;studentResult\u0026quot; \u0026gt; select * from student where stuno = #{stuno} \u0026lt;/select\u0026gt;  \u0026lt;resultMap type=\u0026quot;student\u0026quot; id=\u0026quot;studentResult\u0026quot;\u0026gt; \u0026lt;!-- 分为主键id 和非主键 result--\u0026gt; \u0026lt;id property=\u0026quot;stuNo\u0026quot; column=\u0026quot;stuno\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuName\u0026quot; column=\u0026quot;stuname\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuAge\u0026quot; column=\u0026quot;stuage\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;graName\u0026quot; column=\u0026quot;graname\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuSex\u0026quot; column=\u0026quot;stusex\u0026quot; javaType=\u0026quot;boolean\u0026quot; jdbcType=\u0026quot;INTEGER\u0026quot;/\u0026gt; \u0026lt;/resultMap\u0026gt;  注意#{stuNo} 中存放的是 属性值，需要严格区分大小写。\nresultMap可以实现2个功能：\n 类型转换\n 属性-字段的映射关系\n\u0026lt;resultMap type=\u0026quot;student\u0026quot; id=\u0026quot;studentMapping\u0026quot;\u0026gt; \u0026lt;!-- 分为主键id 和非主键 result--\u0026gt; \u0026lt;id property=\u0026quot;id\u0026quot; column=\u0026quot;stuno\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuName\u0026quot; column=\u0026quot;stuname\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuAge\u0026quot; column=\u0026quot;stuage\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;graName\u0026quot; column=\u0026quot;graname\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuSex\u0026quot; column=\u0026quot;stusex\u0026quot; javaType=\u0026quot;boolean\u0026quot; jdbcType=\u0026quot;INTEGER\u0026quot;/\u0026gt; \u0026lt;/resultMap\u0026gt;  当表中的字段名和类中的属性名不同是，也可以通过resultMap进行转换\nStudent queryStudentByStunoWithConverter(int stuno);  StudentMapper studentMapper = session.getMapper(StudentMapper.class); Student student = studentMapper.queryStudentByStunoWithConverter(1);// 接口中的方法-\u0026gt;SQL语句   需要注意的问题： INTEGER\n查询：使用了类型转换器\n 如果 类中属性 和表中的字段 类型能够合理识别 （String-varchar2），则可以使用resultType;否则(boolean-number) 使用resultMap\n 如果 类中属性名 和表中的字段名能够合理识别 （stuNo -stuno）则可以使用resultType;否则(id-stuno) 使用resultMap\n  增加\n\u0026lt;!-- 带转换器的增加 --\u0026gt; \u0026lt;insert id=\u0026quot;addStudentWithConverter\u0026quot; parameterType=\u0026quot;student\u0026quot; \u0026gt; insert into student(stuno,stuname,stuage,graname,stusex) values(#{stuNo},#{stuName},#{stuAge},#{graName} ,#{stuSex ,javaType=boolean ,jdbcType=INTEGER } ) \u0026lt;/insert\u0026gt;  //增加 void addStudentWithConverter(Student student);  Student student = new Student(63, \u0026quot;ww53\u0026quot;, 23, \u0026quot;s3\u0026quot;); student.setStuSex(true);// 1 StudentMapper studentMapper = session.getMapper(StudentMapper.class); studentMapper.addStudentWithConverter(student); session.commit(); // 提交事务   输入参数：parameterType 类型为 简单类型（8个基本类型+String） #{}、${}的区别\n 存放的值不同\n#{任意值},一般建议不要乱写，即见名知意 ${value} ，其中的标识符只能是value  输出不同\n#{}自动给String类型加上'' （自动类型转换） ${} 原样输出，但是适合于 动态排序（动态字段） select stuno,stuname,stuage from student where stuname = #{value} select stuno,stuname,stuage from student where stuname = '${value}'  动态排序：\n\u0026lt;select id=\u0026quot;queryStudentOrderByColumn\u0026quot; parameterType=\u0026quot;string\u0026quot; resultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student order by ${value} asc \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentOrderByColumn(String column);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentOrderByColumn(\u0026quot;stuno\u0026quot;) ;//接口的方法-\u0026gt;SQL  SQL注入\n#{}可以防止SQL注入\n${}不防止\n 什么是SQL注入\n SQL注入是通过把SQL命令插入到web表单提交或通过页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL指令。注入攻击的本质是把用户输入的数据当做代码执行。\n举例如: 表单有两个用户需要填写的表单数据，用户名和密码，如果用户输入admin(用户名)，111(密码)，若数据库中存在此用户则登录成功。SQL大概是这样\n　SELECT * FROM XXX WHERE userName = admin and password = 111  但若是遭到了SQL注入，输入的数据变为 admin or 1 =1 # 密码随便输入，这时候就直接登录了，SQL大概是这样\n　SELECT * FROM XXX WHERE userName = admin or 1 = 1 # and password = 111  ,因为 # 在sql语句中是注释，将后面密码的验证去掉了，而前面的条件中1 = 1始终成立，所以不管密码正确与否，都能登录成功。\n mybatis中的#{} 为什么能防止sql注入，${}不能防止sql注入\n 答: #{}在mybatis中的底层是运用了PreparedStatement 预编译，传入的参数会以 ? 形式显示，因为sql的输入只有在sql编译的时候起作用，当sql预编译完后，传入的参数就仅仅是参数，不会参与sql语句的生成，而${}则没有使用预编译，传入的参数直接和sql进行拼接，由此会产生sql注入的漏洞。\n  ${}、#{}相同之处：  都可以 获取对象的值 （嵌套类型对象）   模糊查询 模糊查询，方式一：\n like #{stuName}\nstudent.setStuName(\u0026ldquo;%w%\u0026rdquo;);\n \u0026lt;select id=\u0026quot;queryStudentBystuageOrstuName\u0026quot; parameterType=\u0026quot;student\u0026quot;\tresultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student where stuage= #{stuAge} or stuname like #{stuName} \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentBystuageOrstuName(Student student);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; Student student = new Student(); student.setStuAge(24); student.setStuName(\u0026quot;%w%\u0026quot;); List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentBystuageOrstuName(student) ;//接口的方法-\u0026gt;SQL  ​ 模糊查询，方式二：\n like \u0026lsquo;%${stuName}%\u0026rsquo;\nstudent.setStuName(\u0026ldquo;w\u0026rdquo;);\n \u0026lt;select id=\u0026quot;queryStudentBystuageOrstuName\u0026quot; parameterType=\u0026quot;student\u0026quot;\tresultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student where stuage= #{stuAge} or stuname like '%${stuName}%' \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentBystuageOrstuName(Student student);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; Student student = new Student(); student.setStuAge(24); student.setStuName(\u0026quot;w\u0026quot;); List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentBystuageOrstuName(student) ;//接口的方法-\u0026gt;SQL  ​\n嵌套类型对象 Address.java\npublic class Address { private String homeAddress; private String schoolAddress; public String getHomeAddress() { return homeAddress; } public void setHomeAddress(String homeAddress) { this.homeAddress = homeAddress; } public String getSchoolAddress() { return schoolAddress; } public void setSchoolAddress(String schoolAddress) { this.schoolAddress = schoolAddress; } }  Student.java包含Address的对象\nprivate Address address;//家庭、学校 public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; }   方式一\n\u0026lt;select id=\u0026quot;queryStudentByaddress\u0026quot; parameterType=\u0026quot;address\u0026quot; resultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student where homeaddress = #{homeAddress} or schooladdress = '${schoolAddress}' \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentByaddress(Address address);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; Address address = new Address(); address.setHomeAddress(\u0026quot;xa\u0026quot;); address.setSchoolAddress(\u0026quot;x\u0026quot;); List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentByaddress(address) ;  方式二:级联属性\n\u0026lt;!-- 输入参数为 级联属性 --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentByaddress\u0026quot; parameterType=\u0026quot;student\u0026quot; resultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student where homeaddress = #{address.homeAddress} or schooladdress = '${address.schoolAddress}' \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentByaddress(Student address);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; Student student = new Student(); Address address = new Address(); address.setHomeAddress(\u0026quot;xa\u0026quot;); address.setSchoolAddress(\u0026quot;xxxxxx\u0026quot;); student.setAddress(address); List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentByaddress(student) ;  方式三：输入对象为HashMap：\n\u0026lt;select id=\u0026quot;queryStudentBystuageOrstuNameWithHashMap\u0026quot; parameterType=\u0026quot;HashMap\u0026quot; resultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student where stuage= #{stuAge} or stuname like '%${stuName}%' \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentBystuageOrstuNameWithHashMap(Map\u0026lt;String,Object\u0026gt; map);//String,Object  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; Map\u0026lt;String,Object\u0026gt; studentMap = new HashMap\u0026lt;\u0026gt;(); studentMap.put(\u0026quot;stuAge\u0026quot;, 24) ; studentMap.put(\u0026quot;stuName\u0026quot;, \u0026quot;zs\u0026quot;) ; List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentBystuageOrstuNameWithHashMap (studentMap) ;//接口的方法-\u0026gt;SQL  where stuage= #{stuAge}\n用map中key的值 匹配 占位符#{stuAge}，如果匹配成功 就用map的value替换占位符\n  mybatis调用存储过程 创建存储过程 查询某个年级的 学生总数\n输入：年级\n输出：该年级的学生总数\ncreate or replace procedure queryCountByGradeWithProcedure(gName in varchar, scount out number ) as begin select count(*) into scount from student where graname = gname ; end; /  根据学号删除学生\ncreate or replace procedure deleteStuBynoWithProcedure(sno in number) as begin delete from student where stuno = sno ; end; /  调用存储过程实现查询 \u0026lt;!-- 通过调用[存储过程] 实现查询 ,statementType=\u0026quot;CALLABLE\u0026quot; 存储过程的输入参数，在mybatis用Map来传递（HashMap） --\u0026gt; \u0026lt;select id=\u0026quot;queryCountByGradeWithProcedure\u0026quot; statementType=\u0026quot;CALLABLE\u0026quot; parameterType=\u0026quot;HashMap\u0026quot; \u0026gt; { CALL queryCountByGradeWithProcedure( #{gName,jdbcType=VARCHAR,mode=IN}, #{scount,jdbcType=INTEGER,mode=OUT} ) }\t\u0026lt;/select\u0026gt;  void queryCountByGradeWithProcedure(Map\u0026lt;String,Object\u0026gt; params );  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; //通过map给 存储过程指定输入参数 Map\u0026lt;String,Object\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026quot;gName\u0026quot;, \u0026quot;g1\u0026quot;) ;//指定存储过程的输入参数gName的值是g1 studentMapper.queryCountByGradeWithProcedure(params);//调用存储过程，并传入输入参数 //获取存储过程的输出参数 Object count = params.get(\u0026quot;scount\u0026quot;) ;  其中 通过statementType=\u0026ldquo;CALLABLE\u0026rdquo;设置SQL的执行方式是存储过程。 存储过程的输入参数gName需要通过HashMap来指定 在使用时，通过hashmap的put方法传入输入参数的值；通过hashmap的Get方法 获取输出参数的值。\n要注意Jar问题：ojdbc6.jar不能在 调存储过程时 打回车、tab，但是ojdbc7.jar可以。\n如果报错： No enum constant org.apache.ibatis.type.JdbcType.xx，则说明mybatis不支持xx类型，需要查表。\n调用存储过程实现删除 \u0026lt;!-- 通过存储过程实现删除 --\u0026gt; \u0026lt;delete id=\u0026quot;deleteStuBynoWithProcedure\u0026quot; statementType=\u0026quot;CALLABLE\u0026quot; parameterType=\u0026quot;HashMap\u0026quot;\u0026gt; { CALL deleteStuBynoWithProcedure( #{sno,jdbcType=INTEGER,mode=IN} ) }\t\u0026lt;/delete\u0026gt;  void deleteStuBynoWithProcedure(Map\u0026lt;String,Object\u0026gt; params);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026quot;sno\u0026quot;, 3) ; studentMapper.deleteStuBynoWithProcedure( map) ; session.commit(); session.close();  存储过程 无论输入参数是什么值，语法上都需要 用map来传递该值；\n只要 是 \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot;/\u0026gt;，则增删改都需要手工commit ;\n输出参数 输出参数resultType\n简单类型（8个基本+String） \u0026lt;select id=\u0026quot;queryStudentCount\u0026quot; resultType=\u0026quot;int\u0026quot; \u0026gt; select count(*) from student \u0026lt;/select\u0026gt;  int queryStudentCount();  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; int count = studentMapper.queryStudentCount();  输出参数为实体对象类型 \u0026lt;select id=\u0026quot;queryStuByStuno\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;student\u0026quot; \u0026gt; select * from student where stuno = ${value} \u0026lt;/select\u0026gt;  Student queryStuByStuno(int stuno);  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; Student student = studentMapper.queryStuByStuno(2) ;//接口中的方法-\u0026gt;SQL语句  输出参数为实体对象类型的集合 虽然输出类型为集合，但是resultType依然写 集合的元素类型（resyltType=\u0026ldquo;Student\u0026rdquo;）\n\u0026lt;select id=\u0026quot;queryAllStudents\u0026quot; resultType=\u0026quot;Student\u0026quot; \u0026gt; select * from student \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryAllStudents();  StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u0026lt;Student\u0026gt; students = studentMapper.queryAllStudents();// 接口的方法-\u0026gt;SQL  输出参数类型为HashMap \u0026lt;!-- 别名作为Map的key --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentOutByHashMap\u0026quot; resultType=\u0026quot;HashMap\u0026quot; \u0026gt; select stuno \u0026quot;no\u0026quot;,stuname \u0026quot;name\u0026quot; from student where stuno=1 \u0026lt;/select\u0026gt;  HashMap\u0026lt;String,Object\u0026gt; queryStudentOutByHashMap();  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; HashMap\u0026lt;String,Object\u0026gt; studentMap = studentMapper.queryStudentOutByHashMap();  HashMap本身是一个集合，可以存放多个元素，但是根据提示发现 返回值为HashMap时 ，查询的结果只能是1个学生（no,name）\n结论：一个HashMap 对应一个学生的多个元素（多个属性） 【一个map，一个学生】\n比较像二维数组，一个数组是一个HashMap对象\n{ {1,zs,23,xa}, 一个HashMap对象 {2,ls,24,bj}, {3,ww,25,tj} }  获取多个HashMap\n\u0026lt;select id=\u0026quot;queryAllStudentsOutByHashMap\u0026quot; resultType=\u0026quot;HashMap\u0026quot; \u0026gt; select stuno \u0026quot;no\u0026quot;,stuname \u0026quot;name\u0026quot; from student \u0026lt;/select\u0026gt;  List\u0026lt;HashMap\u0026lt;String,Object\u0026gt;\u0026gt; queryAllStudentsOutByHashMap();  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; List\u0026lt;HashMap\u0026lt;String,Object\u0026gt;\u0026gt; studentMap = studentMapper.queryAllStudentsOutByHashMap();  resultType\nresultMap:实体类的属性、数据表的字段： 类型、名字不同时（stuno,id）\n注意：当属性名 和字段名 不一致时，除了使用resultMap以外，还可以使用resultType+HashMap:\nresultMap \u0026lt;select id=\u0026quot;queryStudentById\u0026quot; parameterType=\u0026quot;int\u0026quot;\tresultMap=\u0026quot;queryStudentByIdMap\u0026quot; \u0026gt; select id,name from student where id = #{id} \u0026lt;/select\u0026gt; \u0026lt;resultMap type=\u0026quot;student\u0026quot; id=\u0026quot;queryStudentByIdMap\u0026quot;\u0026gt; \u0026lt;!-- 指定类中的属性 和 表中的字段 对应关系 --\u0026gt; \u0026lt;id property=\u0026quot;stuNo\u0026quot; column=\u0026quot;id\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuName\u0026quot; column=\u0026quot;name\u0026quot; /\u0026gt; \u0026lt;/resultMap\u0026gt;  Student queryStudentById(int stuno);  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; Student student = studentMapper.queryStudentById(2) ;//接口中的方法-\u0026gt;SQL语句  resultType+HashMap \u0026lt;select id=\u0026quot;queryStudentByIdWithHashMap\u0026quot; parameterType=\u0026quot;int\u0026quot;\tresultType=\u0026quot;student\u0026quot; \u0026gt; select id \u0026quot;stuNo\u0026quot;,name \u0026quot;stuName\u0026quot; from student where id = #{id} \u0026lt;/select\u0026gt;  Student queryStudentByIdWithHashMap(int stuno);  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; Student student = studentMapper.queryStudentByIdWithHashMap(2) ;//接口中的方法-\u0026gt;SQL语句  select 表的字段名 \u0026ldquo;类的属性名\u0026rdquo; from\u0026hellip; 来制定字段名 和属性名的对应关系\n注意: 如果如果10个字段，但发现 某一个字段结果始终为默认值（0，0.0，null），则可能是 表的字段 和 类的属性名字写错。\n动态SQL //查询全部 String statement = \u0026quot;select stuno,stuname from student\u0026quot;; //根据年龄查询学生 String statement = \u0026quot;select stuno,stuname from student where stuage = #{stuage}\u0026quot;;  //根据姓名和年龄查询学生 String statement = \u0026quot;select stuno,stuname from student where stuage = #{stuage} and stuage = #{stuage} \u0026quot;;  可以发现其中有重复的部分\n\u0026lt;select id=\u0026quot;queryStuByNOrAWishSQLTag\u0026quot; parameterType=\u0026quot;student\u0026quot;\tresultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student \u0026lt;where\u0026gt; \u0026lt;!-- \u0026lt;if test=\u0026quot;student有stuname属性 且不为null\u0026quot;\u0026gt; 属性严格区分大小写--\u0026gt; \u0026lt;if test=\u0026quot;stuName !=null and stuName!=''\u0026quot;\u0026gt; and stuname = #{stuName} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;stuAge !=null and stuAge!=0 \u0026quot;\u0026gt; and stuage = #{stuAge} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;  Student queryStuByNOrAWishSQLTag(Student student);  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; Student stu = new Student(); stu.setStuAge(24); //stu.setStuName(\u0026quot;ls\u0026quot;); Student student = studentMapper.queryStuByNOrAWishSQLTag(stu) ;//接口中的方法-\u0026gt;SQL语句  处理and的两种方式\n 方式一\n\u0026lt;select id=\u0026quot;queryStuByNOrAWishSQLTag\u0026quot; parameterType=\u0026quot;student\u0026quot; resultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student where 1=1 \u0026lt;if test=\u0026quot;stuName !=null and stuName!='' \u0026quot;\u0026gt; and stuname = #{stuName} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;stuAge !=null and stuAge!=0 \u0026quot;\u0026gt; and stuage = #{stuAge} \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt;  方式二 （推荐）\n\u0026lt;select id=\u0026quot;queryStuByNOrAWishSQLTag\u0026quot; parameterType=\u0026quot;student\u0026quot; resultType=\u0026quot;student\u0026quot; \u0026gt; select stuno,stuname,stuage from student \u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;stuName !=null and stuName!='' \u0026quot;\u0026gt; and stuname = #{stuName} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;stuAge !=null and stuAge!=0 \u0026quot;\u0026gt; and stuage = #{stuAge} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;  \u0026lt;where\u0026gt;会自动处理第一个（满足条件的第一个）\u0026lt;if\u0026gt;标签中的 and，但不会处理之后\u0026lt;if\u0026gt;中的and。\n  foreach 查询学号为1、2、53的学生信息\nsql语句\nselect stuno,stuname from student where stuno in(1,2,53)  \u0026lt;foreach\u0026gt;迭代的类型：数组、对象数组、集合、属性(Grade类： List\u0026lt;Integer\u0026gt; ids)\n属性 (Grade类： List\u0026lt;Integer\u0026gt; ids\npublic class Grade { //学号 private List\u0026lt;Integer\u0026gt; stuNos ; public List\u0026lt;Integer\u0026gt; getStuNos() { return stuNos; } public void setStuNos(List\u0026lt;Integer\u0026gt; stuNos) { this.stuNos = stuNos; } }  \u0026lt;!-- 将多个元素值 放入对象的属性中 --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentsWithNosInGrade\u0026quot; parameterType=\u0026quot;grade\u0026quot; resultType=\u0026quot;student\u0026quot;\u0026gt; select * from student \u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;stuNos!=null and stuNos.size\u0026gt;0\u0026quot;\u0026gt; \u0026lt;foreach collection=\u0026quot;stuNos\u0026quot; open=\u0026quot; and stuno in (\u0026quot; close=\u0026quot;)\u0026quot; item=\u0026quot;stuNo\u0026quot; separator=\u0026quot;,\u0026quot;\u0026gt; #{stuNo} \u0026lt;/foreach\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;  collection:集合 select * from student +open: select * from student and stuno in ( +item: select * from student and stuno in (1,2,53 +close: select * from student and stuno in (1,2,53) separator:分隔符  List\u0026lt;Student\u0026gt; queryStudentsWithNosInGrade(Grade grade);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; Grade grade = new Grade(); List\u0026lt;Integer\u0026gt; stuNos = new ArrayList\u0026lt;\u0026gt;(); stuNos.add(1) ; stuNos.add(2) ; // stuNos.add(53) ; grade.setStuNos(stuNos); List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentsWithNosInGrade(grade) ;  简单类型的数组: \u0026lt;!-- 将多个元素值 放入数组中 int[] stuNos = {1,2,53} --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentsWithArray\u0026quot; parameterType=\u0026quot;int[]\u0026quot; resultType=\u0026quot;student\u0026quot;\u0026gt; select * from student \u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;array!=null and array.length\u0026quot;\u0026gt; \u0026lt;foreach collection=\u0026quot;array\u0026quot; open=\u0026quot; and stuno in (\u0026quot; close=\u0026quot;)\u0026quot; item=\u0026quot;stuNo\u0026quot; separator=\u0026quot;,\u0026quot;\u0026gt; #{stuNo} \u0026lt;/foreach\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;  约定：无论编写代码时，传递的是什么参数名(stuNos)，在mapper.xml中 必须用array代替该数组\nList\u0026lt;Student\u0026gt; queryStudentsWithArray(int[] stuNos);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; int[] stuNos = {1,2,53}; List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentsWithArray(stuNos) ;  对象数组： \u0026lt;sql id=\u0026quot;objectArrayStunos\u0026quot;\u0026gt; \u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;array!=null and array.length\u0026gt;0\u0026quot;\u0026gt; \u0026lt;foreach collection=\u0026quot;array\u0026quot; open=\u0026quot; and stuno in (\u0026quot; close=\u0026quot;)\u0026quot; item=\u0026quot;student\u0026quot; separator=\u0026quot;,\u0026quot;\u0026gt; #{student.stuNo} \u0026lt;/foreach\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;!-- 将多个元素值 放入对象数组中Student[] students = {student0,student1,student2} 每个studentx包含一个学号属性 --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentsWithObjectArray\u0026quot; parameterType=\u0026quot;Object[]\u0026quot; resultType=\u0026quot;student\u0026quot;\u0026gt; select * from student \u0026lt;!--如果sql片段和 引用处不在同一个文件中，则需要 在refid 引用时 加上namespace: namespace.id \u0026lt;include refid=\u0026quot;org.lanqiao.mapper.abcMapper.objectArrayStunos\u0026quot;\u0026gt;\u0026lt;/include\u0026gt; --\u0026gt; \u0026lt;include refid=\u0026quot;objectArrayStunos\u0026quot;\u0026gt;\u0026lt;/include\u0026gt; \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentsWithObjectArray(Student[] students);  StudentMapper studentMapper = session.getMapper( StudentMapper.class) ; Student stu1 = new Student(); stu1.setStuNo(1); Student stu2 = new Student(); stu2.setStuNo(2); Student stu53 = new Student(); stu53.setStuNo(53); Student[] stus = new Student[] {stu1,stu2,stu53}; List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentsWithObjectArray(stus);  集合： 无论编写代码时，传递的是什么参数名(stuNos)，在mapper.xml中 必须用list代替该数组\n\u0026lt;!-- 将多个元素值 放入数组中 List\u0026lt;Integer\u0026gt; stuNos 值 {1,2,53} --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentsWithList\u0026quot; parameterType=\u0026quot;list\u0026quot; resultType=\u0026quot;student\u0026quot;\u0026gt; select * from student \u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;list!=null and list.size\u0026gt;0\u0026quot;\u0026gt; \u0026lt;foreach collection=\u0026quot;list\u0026quot; open=\u0026quot; and stuno in (\u0026quot; close=\u0026quot;)\u0026quot; item=\u0026quot;stuNo\u0026quot; separator=\u0026quot;,\u0026quot;\u0026gt; #{stuNo} \u0026lt;/foreach\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentsWithList(List\u0026lt;Integer\u0026gt; stuNos);  List\u0026lt;Integer\u0026gt; stuNos = new ArrayList\u0026lt;\u0026gt;(); stuNos.add(1) ; stuNos.add(2) ; stuNos.add(53) ; List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentsWithList(stuNos) ;  SQL片段： java：方法 数据库：存储过程、存储函数 Mybatis :SQL片段   提取相似代码 引用\n\u0026lt;sql id=\u0026quot;objectArrayStunos\u0026quot;\u0026gt; \u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;array!=null and array.length\u0026gt;0\u0026quot;\u0026gt; \u0026lt;foreach collection=\u0026quot;array\u0026quot; open=\u0026quot; and stuno in (\u0026quot; close=\u0026quot;)\u0026quot; item=\u0026quot;student\u0026quot; separator=\u0026quot;,\u0026quot;\u0026gt; #{student.stuNo} \u0026lt;/foreach\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/sql\u0026gt;  \u0026lt;select id=\u0026quot;queryStudentsWithObjectArray\u0026quot; parameterType=\u0026quot;Object[]\u0026quot; resultType=\u0026quot;student\u0026quot;\u0026gt; select * from student \u0026lt;!--如果sql片段和 引用处不在同一个文件中，则需要 在refid 引用时 加上namespace: namespace.id \u0026lt;include refid=\u0026quot;org.lanqiao.mapper.abcMapper.objectArrayStunos\u0026quot;\u0026gt;\u0026lt;/include\u0026gt; --\u0026gt; \u0026lt;include refid=\u0026quot;objectArrayStunos\u0026quot;\u0026gt;\u0026lt;/include\u0026gt; \u0026lt;/select\u0026gt;   关联查询 两张表\nstudent\nstuno stuname cardid  studentCard\ncardid cardinfo  一对一  业务扩展类\n核心：用resultType指定类的属性 包含 多表查询的所有字段\n resultMap\n  业务扩展类做法：\n新建业务扩展类，类中既包含了A的属性也包含了B的属性，继承一个属性多的类，重写一个属性较少的类的属性\npublic class StudentBusiness extends Student{//学生业务扩展类 private int cardId; private String cardInfo ; public int getCardId() { return cardId; } public void setCardId(int cardId) { this.cardId = cardId; } public String getCardInfo() { return cardInfo; } public void setCardInfo(String cardInfo) { this.cardInfo = cardInfo; } @Override public String toString() { return super.toString() + \u0026quot;,\u0026quot;+this.cardId+\u0026quot;,\u0026quot;+this.cardInfo; } }  \u0026lt;select id=\u0026quot;queryStudentByNoWithOO\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;StudentBusiness\u0026quot; \u0026gt; select s.*,c.* from student s inner join studentcard c on s.cardid=c.cardid where s.stuno = #{stuNo} \u0026lt;/select\u0026gt;  StudentBusiness queryStudentByNoWithOO(int stuno);  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; StudentBusiness studentBusiness = studentMapper.queryStudentByNoWithOO(2) ;//接口中的方法-\u0026gt;SQL语句  resultMap的做法\n表与表之间通过外键进行连接，那么，类与类之间通过属性进行连接\n通过 属性成员 将2个类建立起联系\n把其中一个类作为另一个的类的属性\n//学生类 包含：1学生信息 2学生证信息 public class Student { //1学生信息 private int stuNo ; private String stuName ; private int stuAge ; private String graName ; private boolean stuSex ; //2学生证信息 private StudentCard card ; /* x x x x*/ }  \u0026lt;resultMap type=\u0026quot;student\u0026quot; id=\u0026quot;student_card_map\u0026quot;\u0026gt; \u0026lt;!-- 学生的信息 --\u0026gt; \u0026lt;id property=\u0026quot;stuNo\u0026quot; column=\u0026quot;stuNo\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;stuName\u0026quot; column=\u0026quot;stuName\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuAge\u0026quot; column=\u0026quot;stuAge\u0026quot; /\u0026gt; \u0026lt;!-- 一对一时，对象成员使用 association映射;javaType指定该属性的类型--\u0026gt; \u0026lt;association property=\u0026quot;card\u0026quot; javaType=\u0026quot;StudentCard\u0026quot; \u0026gt; \u0026lt;id property=\u0026quot;cardId\u0026quot; column=\u0026quot;cardId\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;cardInfo\u0026quot; column=\u0026quot;cardInfo\u0026quot;/\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt;  \u0026lt;!-- 利用resultMap实现一对一 --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentByNoWithOO2\u0026quot; parameterType=\u0026quot;int\u0026quot; resultMap=\u0026quot;student_card_map\u0026quot; \u0026gt; select s.*,c.* from student s inner join studentcard c on s.cardid=c.cardid where s.stuno = #{stuNo} \u0026lt;/select\u0026gt;  Student queryStudentByNoWithOO2(int stuNo);  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; Student student = studentMapper.queryStudentByNoWithOO2(2) ;  一对多 （MyBatis:多对一，多对多的本质就是 一对多的变化）\n表：\nstudentClass\nclassId className  student\nstuno stuname classId  其中两个学生对应一个班级\n班级类中增加学生属性\npublic class StudentClass { private int classId; private String className; //增加学生属性 (通过该字段 让Student类和StudentClass类建立起关联) List\u0026lt;Student\u0026gt; students ; /*x x x*/ }  \u0026lt;!-- 类-表的对应关系 --\u0026gt; \u0026lt;resultMap type=\u0026quot;studentClass\u0026quot; id=\u0026quot;class_student_map\u0026quot;\u0026gt; \u0026lt;!-- 因为 type的主类是班级，因此先配置班级的信息--\u0026gt; \u0026lt;id property=\u0026quot;classId\u0026quot; column=\u0026quot;classId\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;className\u0026quot; column=\u0026quot;className\u0026quot;/\u0026gt; \u0026lt;!-- 配置成员属性学生，一对多;属性类型：javaType，属性的元素类型ofType --\u0026gt; \u0026lt;collection property=\u0026quot;students\u0026quot; ofType=\u0026quot;student\u0026quot;\u0026gt; \u0026lt;id property=\u0026quot;stuNo\u0026quot; column=\u0026quot;stuNo\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;stuName\u0026quot; column=\u0026quot;stuName\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;stuAge\u0026quot; column=\u0026quot;stuAge\u0026quot;/\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt;  可以级联匹配，student中在配置studentcard的信息\n查询g1班的班级信息，和g1班的所有学生信息\n\u0026lt;select id=\u0026quot;queryClassAndStudents\u0026quot; parameterType=\u0026quot;int\u0026quot; resultMap=\u0026quot;class_student_map\u0026quot;\u0026gt; select c.*,s.* from student s inner join studentclass c on c.classid = s.classid where c.classid = #{classId} \u0026lt;/select\u0026gt;  StudentClass queryClassAndStudents(int classId);  StudentClassMapper studentClassMapper = session.getMapper(StudentClassMapper.class) ; //班级 List\u0026lt;StudentClass\u0026gt; studentClasses = studentClassMapper.queryClassAndStudents() ; //班级信息 for(StudentClass stuClass :studentClasses) { System.out.println(stuClass.getClassId()+\u0026quot;,\u0026quot;+stuClass.getClassName()); System.out.println(\u0026quot;-----------\u0026quot;); for(Student student: stuClass.getStudents()) { System.out.println(student.getStuNo()+\u0026quot;,\u0026quot;+student.getStuName()); } }  日志 如果不指定，Mybatis就会根据以下顺序 寻找日志\nSLF4J →Apache Commons Logging →Log4j2 → Log4j →JDK logging  使用log4j\njar Log4j: log4j.jar (mybatis.zip中lib中包含此jar)  开启日志，conf.xml \u0026lt;settings\u0026gt; \u0026lt;!-- 开启日志，并指定使用的具体日志 --\u0026gt; \u0026lt;setting name=\u0026quot;logImpl\u0026quot; value=\u0026quot;LOG4J\u0026quot;/\u0026gt; \u0026lt;/settings\u0026gt;  编写配置日志输出文件 log4j.properties log4j.properties，内容\nlog4j.rootLogger=DEBUG, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n  DEBUG：级别\n日志级别：\nDEBUG\u0026lt;INFO\u0026lt;WARN\u0026lt;ERROR  如果设置为info，则只显示 info及以上级别的信息；\n建议：在开发时设置debug，在运行时设置为info或以上。\nstdout：在控制台输出\n可以通过日志信息，相信的阅读mybatis执行情况（ 观察mybatis实际执行sql语句 以及SQL中的参数 和返回结果）\n延迟加载（懒加载）： 一对一、一对多、多对一、多对多\n一对多：班级-学生 ，\n如果不采用延迟加载 （立即加载），查询时会将 一 和多 都查询，班级、班级中的所有学生。\n如果想要 暂时只查询1的一方， 而多的一方 先不查询 而是在需要的时候再去查询 \u0026ndash;\u0026gt;延迟加载\nmybatis中使用延迟加载，需要先配置：\n\u0026lt;settings\u0026gt; \u0026lt;!-- 开启延迟加载 --\u0026gt; \u0026lt;setting name=\u0026quot;lazyLoadingEnabled\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 关闭立即加载 --\u0026gt; \u0026lt;setting name=\u0026quot;aggressiveLazyLoading\u0026quot; value=\u0026quot;false\u0026quot;/\u0026gt; \u0026lt;/settings\u0026gt;  一对一：学生（student）、学生证（studentCard） studentCardMapper.xml\n\u0026lt;mapper namespace=\u0026quot;org.lanqiao.mapper.StudentCardMapper\u0026quot;\u0026gt; \u0026lt;!-- 查询学生证信息 --\u0026gt;\t\u0026lt;select id=\u0026quot;queryCardById\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;studentCard\u0026quot;\u0026gt; \u0026lt;!-- 查询学生对应的学生证 --\u0026gt; select * from studentCard where cardid = #{cardId} \u0026lt;/select\u0026gt; \u0026lt;!-- 根据cardid查询学生证的SQL： org.lanqiao.mapper.StudentCardMapper.queryCardById --\u0026gt; \u0026lt;/mapper\u0026gt;  加载mapper配置文件\n\u0026lt;mapper resource=\u0026quot;org/lanqiao/mapper/studentCardMapper.xml\u0026quot;/\u0026gt;  \u0026lt;resultMap type=\u0026quot;student\u0026quot; id=\u0026quot;student_card_lazyLoad_map\u0026quot;\u0026gt; \u0026lt;!-- 学生的信息 --\u0026gt; \u0026lt;id property=\u0026quot;stuNo\u0026quot; column=\u0026quot;stuNo\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;stuName\u0026quot; column=\u0026quot;stuName\u0026quot; /\u0026gt; \u0026lt;result property=\u0026quot;stuAge\u0026quot; column=\u0026quot;stuAge\u0026quot; /\u0026gt; \u0026lt;!-- 一对一时，对象成员使用 association映射;javaType指定该属性的类型 此次采用延迟加载：在查询学生时，并不立即加载 学生证信息 --\u0026gt; \u0026lt;!-- 学生证 ,通过select 在需要的时候再查学生证 --\u0026gt; \u0026lt;association property=\u0026quot;card\u0026quot; javaType=\u0026quot;StudentCard\u0026quot; select=\u0026quot;org.lanqiao.mapper.StudentCardMapper.queryCardById\u0026quot; column=\u0026quot;cardid\u0026quot; \u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt;  \u0026lt;!-- 利用resultMap实现一对一 ，延迟加载--\u0026gt; \u0026lt;select id=\u0026quot;queryStudentWithOO2LazyLoad\u0026quot; parameterType=\u0026quot;int\u0026quot; resultMap=\u0026quot;student_card_lazyLoad_map\u0026quot; \u0026gt; \u0026lt;!-- 先查学生 --\u0026gt; select * from student \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentWithOO2LazyLoad();  StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; //学生, List\u0026lt;Student\u0026gt; students = studentMapper.queryStudentWithOO2LazyLoad(); //此时，只获取了学生的信息 for(Student student:students) { System.out.println(student.getStuNo()+\u0026quot;,\u0026quot;+student.getStuName()); //获取学生证，下一步即将获取学生证的信息 StudentCard card = student.getCard() ; System.out.println(card.getCardId()+\u0026quot;,\u0026quot;+card.getCardInfo()); } session.close();  如果增加了mapper.xml ,要修改conf.xml配置文件（将新增的mapper.xml加载进去）\n通过debug可以发现， 如果程序只需要学生，则只向数据库发送了查询学生的SQL；当我们后续 需要用到学生证的时候，再第二次发送 查询学生证的SQL。\n一对多：和一对一的延迟加载配置方法相同 延迟加载的步骤：先查班级，按需查询学生\n开启延迟加载conf.xml配置settings\n配置mapper.xml\nStudentClassMapper.xml\n\u0026lt;!-- 一对多，带延迟加载 --\u0026gt; \u0026lt;select id=\u0026quot;queryClassAndStudents\u0026quot; resultMap=\u0026quot;class_student_lazyLoad_map\u0026quot;\u0026gt; \u0026lt;!-- 先查询班级 --\u0026gt; select c.* from studentclass c \u0026lt;/select\u0026gt;  \u0026lt;!-- 类-表的对应关系 --\u0026gt; \u0026lt;resultMap type=\u0026quot;studentClass\u0026quot; id=\u0026quot;class_student_lazyLoad_map\u0026quot;\u0026gt; \u0026lt;id property=\u0026quot;classId\u0026quot; column=\u0026quot;classId\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;className\u0026quot; column=\u0026quot;className\u0026quot;/\u0026gt; \u0026lt;!-- 再查班级对应的学生 --\u0026gt; \u0026lt;collection property=\u0026quot;students\u0026quot; ofType=\u0026quot;student\u0026quot; select=\u0026quot;org.lanqiao.mapper.StudentMapper.queryStudentsByClassId\u0026quot; column=\u0026quot;classid\u0026quot;\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt;  StudentMapper.xml\n\u0026lt;!-- 一对多,延迟加载需要的： 查询班级中的所有学生 --\u0026gt; \u0026lt;select id=\u0026quot;queryStudentsByClassId\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;student\u0026quot;\u0026gt; select * from student where classId = #{classId} \u0026lt;/select\u0026gt;  StudentClassMapper.java\n//查询全部班级 List\u0026lt;StudentClass\u0026gt; queryClassAndStudents();  StudentClassMapper studentClassMapper = session.getMapper(StudentClassMapper.class) ; //班级 List\u0026lt;StudentClass\u0026gt; studentClasses = studentClassMapper.queryClassAndStudents() ; //班级信息 for(StudentClass stuClass :studentClasses) { System.out.println(stuClass.getClassId()+\u0026quot;,\u0026quot;+stuClass.getClassName()); System.out.println(\u0026quot;-----------\u0026quot;); for(Student student: stuClass.getStudents()) { System.out.println(student.getStuNo()+\u0026quot;,\u0026quot;+student.getStuName()); } } session.close();  即查询 学生的sql是通过 select属性指定，并且通过column指定外键\n查询缓存 只涉及查询\n一级缓存 ：同一个SqlSession对象 MyBatis默认开启一级缓存，如果用同样的SqlSession对象查询相同的数据，则只会在第一次 查询时 向数据库发送SQL语句，并将查询的结果 放入到SQLSESSION中（作为缓存在）；后续再次查询该同样的对象时，则直接从缓存中查询该对象即可（即省略了数据库的访问）\n执行commit操作后会将缓存清空\n二级缓存 MyBatis默认情况没有开启二级缓存，需要手工打开。\n conf.xml\n\u0026lt;!-- 开启二级缓存 --\u0026gt; \u0026lt;setting name=\u0026quot;cacheEnabled\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;  在具体的mapper.xml中声明开启\n\u0026lt;!-- 声明次namespace开启二级缓存 --\u0026gt; \u0026lt;cache/\u0026gt;   根据异常提示：NotSerializableException可知，MyBatis的二级缓存 是将对象放入硬盘文件中(序列化)\n序列化：内存-\u0026gt;硬盘 反序列化：硬盘-\u0026gt;内存  准备缓存的对象，必须实现了序列化接口 （如果开启的缓存Namespace=\u0026ldquo;org.lanqiao.mapper.StudentMapper\u0026rdquo;），可知序列化对象为Student，因此需要将Student序列化 （序列化Student类，以及Student的级联属性、和父类）\npublic class Student implements Serializable{} public class StudentCard implements Serializable{}  二级缓存，实际存放的位置在硬盘中\n触发将对象写入二级缓存的时机：SqlSession对象的close()方法。将一级缓存的对象放入硬盘\n日志中会发现有Cache Hit Ratio[xxxx]:0.0和Cache Hit Ratio[xxxx]:0.5，它的意思是命中率的问题。\n第一次查询时，二级缓存中没有，因此是0.0；第二次之前已经close了，因此将查询结果放入二级缓存；第二次查询，总共查询了两次，查到了结果，因此命中率是0.5\n命中率：\n1:zs :0% 2: 50% 3: 2/3 0.666 4: 3/4 0.75  Mybatis自带二级缓存：【同一个namespace】生成的mapper对象 回顾：namespace的值 就是 接口的全类名（包名.类名）， 通过接口可以产生代理对象（studentMapper对象\u0026mdash;\u0026gt;namespace决定了studentMapper对象的产生\n结论：只要产生的xxxMapper对象 来自于同一个namespace，则 这些对象 共享二级缓存。\n如果是同一个SqlSession对象进行多次相同的查询，则直接进入一级缓存查询；如果不是同一个SqlSession对象进行多次相同的查询（但是来自于同一个namespace）则进入二级缓存查询\n注意：二级缓存 的范围是同一个namespace, 如果有多个xxMapper.xml的namespace值相同，则通过这些xxxMapper.xml产生的xxMapper对象 仍然共享二级缓存。\n禁用 ：select标签中添加属性\nuseCache=\u0026quot;false\u0026quot;  清理：\n 与清理一级缓存的方法相同commit();\ncommit(); （一般执行增删改时 会清理掉缓存；设计的原因 是为了防止脏数据）\n在二级缓存中，commit()不能是查询自身的commit。（session.commit;）\ncommit会清理一级和二级缓存；但是 清理二级缓存时，不能是查询自身的commit；\n 在select标签中 增加属性\nflushCache=\u0026quot;true\u0026quot;   MyBatis中调用SqlSession.commit()和SqlSession.close()对二级缓存的影响\n三方提供的二级缓存： ehcache、memcache\n要想整合三方提供的二级缓存 （或者自定义二级缓存），必须实现org.apache.ibatis.cache.Cache接口，该接口的默认实现类是PerpetualCache\n整合ehcache二级缓存：\n jar\nehcache-core.jar mybatis-Ehcache.jar slf4j-api.jar  编写ehcache配置文件 Ehcache.xml\n\u0026lt;ehcache xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:noNamespaceSchemaLocation=\u0026quot;../config/ehcache.xsd\u0026quot;\u0026gt; \u0026lt;diskStore path=\u0026quot;D:\\Ehcache\u0026quot;/\u0026gt; \u0026lt;defaultCache maxElementsInMemory=\u0026quot;1000\u0026quot; maxElementsOnDisk=\u0026quot;1000000\u0026quot; eternal=\u0026quot;false\u0026quot; overflowToDisk=\u0026quot;false\u0026quot; timeToIdleSeconds=\u0026quot;100\u0026quot; timeToLiveSeconds=\u0026quot;100\u0026quot; diskExpiryThreadIntervalSeconds=\u0026quot;120\u0026quot; memoryStoreEvictionPolicy=\u0026quot;LRU\u0026quot;\u0026gt; \u0026lt;/defaultCache\u0026gt; \u0026lt;/ehcache\u0026gt;  当二级缓存的对象 超过内存限制时（缓存对象的个数\u0026gt;maxElementsInMemory），存放入的硬盘文件\u0026lt;diskStore path=\u0026quot;D:\\Ehcache\u0026quot;/\u0026gt;\nmaxElementsInMemory:设置 在内存中缓存 对象的个数 maxElementsOnDisk：设置 在硬盘中缓存 对象的个数 eternal：设置缓存是否 永远不过期 overflowToDisk：当内存中缓存的对象个数 超过maxElementsInMemory的时候，是否转移到硬盘中 timeToIdleSeconds：当2次访问 超过该值的时候，将缓存对象失效 timeToLiveSeconds：一个缓存对象 最多存放的时间（生命周期） diskExpiryThreadIntervalSeconds：设置每隔多长时间，通过一个线程来清理硬盘中的缓存 memoryStoreEvictionPolicy：当超过缓存对象的最大值时，处理的策略；LRU，FIFO,LFU  开启EhCache二级缓存\n在xxxMapper.xml中开启\n\u0026lt;cache type=\u0026quot;org.mybatis.caches.ehcache.EhcacheCache\u0026quot;\u0026gt; \u0026lt;!-- 通过property覆盖Ehcache.xml中的值 --\u0026gt; \u0026lt;property name=\u0026quot;maxElementsInMemory\u0026quot; value=\u0026quot;2000\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;maxElementsOnDisk\u0026quot; value=\u0026quot;3000\u0026quot;/\u0026gt; \u0026lt;/cache\u0026gt;   逆向工程 表、类、接口、mapper.xml四者密切相关，因此 当知道一个的时候 其他三个应该可以自动生成。\n表-\u0026gt;其他三个 实现步骤：\n jar\nmybatis-generator-core.jar mybatis.jar ojdbc.jar  逆向工程的配置文件generator.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE generatorConfiguration PUBLIC \u0026quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026quot;\u0026gt; \u0026lt;generatorConfiguration\u0026gt; \u0026lt;context id=\u0026quot;DB2Tables\u0026quot; targetRuntime=\u0026quot;MyBatis3\u0026quot;\u0026gt; \u0026lt;commentGenerator\u0026gt; \u0026lt;!-- suppressAllComments属性值：是否不出现注释 true:自动生成实体类、SQL映射文件时没有注释 false:自动生成实体类、SQL映射文件，并附有注释 --\u0026gt; \u0026lt;property name=\u0026quot;suppressAllComments\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;/commentGenerator\u0026gt; \u0026lt;!-- 数据库连接信息 --\u0026gt; \u0026lt;jdbcConnection driverClass=\u0026quot;oracle.jdbc.OracleDriver\u0026quot; connectionURL=\u0026quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL\u0026quot; userId=\u0026quot;scott\u0026quot; password=\u0026quot;tiger\u0026quot;\u0026gt; \u0026lt;/jdbcConnection\u0026gt; \u0026lt;!-- forceBigDecimals属性值： true:把数据表中的DECIMAL和NUMERIC类型， 解析为JAVA代码中的java.math.BigDecimal类型 false(默认):把数据表中的DECIMAL和NUMERIC类型， 解析为解析为JAVA代码中的Integer类型 --\u0026gt; \u0026lt;javaTypeResolver\u0026gt; \u0026lt;property name=\u0026quot;forceBigDecimals\u0026quot; value=\u0026quot;false\u0026quot; /\u0026gt; \u0026lt;/javaTypeResolver\u0026gt; \u0026lt;!-- targetProject属性值:实体类的生成位置 targetPackage属性值：实体类所在包的路径 --\u0026gt; \u0026lt;javaModelGenerator targetPackage=\u0026quot;org.lanqiao.entity\u0026quot; targetProject=\u0026quot;.\\src\u0026quot;\u0026gt; \u0026lt;!-- trimStrings属性值： true：对数据库的查询结果进行trim（去空格）操作 false(默认)：不进行trim操作 --\u0026gt; \u0026lt;property name=\u0026quot;trimStrings\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;/javaModelGenerator\u0026gt; \u0026lt;!-- targetProject属性值:SQL映射文件的生成位置 targetPackage属性值：SQL映射文件所在包的路径 --\u0026gt; \u0026lt;sqlMapGenerator targetPackage=\u0026quot;org.lanqiao.mapper\u0026quot; targetProject=\u0026quot;.\\src\u0026quot;\u0026gt; \u0026lt;/sqlMapGenerator\u0026gt; \u0026lt;!-- 生成动态代理的接口 --\u0026gt; \u0026lt;javaClientGenerator type=\u0026quot;XMLMAPPER\u0026quot; targetPackage=\u0026quot;org.lanqiao.mapper\u0026quot; targetProject=\u0026quot;.\\src\u0026quot;\u0026gt; \u0026lt;/javaClientGenerator\u0026gt; \u0026lt;!-- 指定数据库表 --\u0026gt; \u0026lt;table tableName=\u0026quot;Student\u0026quot;\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;table tableName=\u0026quot;studentCard\u0026quot;\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;table tableName=\u0026quot;studentClass\u0026quot;\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/context\u0026gt; \u0026lt;/generatorConfiguration\u0026gt;  执行\npublic class Test { public static void main(String[] args) throws IOException, XMLParserException, InvalidConfigurationException, SQLException, InterruptedException { File file = new File(\u0026quot;src/generator.xml\u0026quot;) ;//配置文件 List\u0026lt;String\u0026gt; warnings = new ArrayList\u0026lt;\u0026gt;(); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(file); DefaultShellCallback callBack = new DefaultShellCallback(true); //逆向工程的核心类 MyBatisGenerator generator = new MyBatisGenerator(config, callBack,warnings ); generator.generate(null); } }   数据库环境切换 （驱动jar）  切换 environment （指定实际使用的数据库）\n\u0026lt;!--default指定環境 --\u0026gt; \u0026lt;environments default=\u0026quot;devOracle\u0026quot;\u0026gt; \u0026lt;!--oracle --\u0026gt; \u0026lt;environment id=\u0026quot;devOracle\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot; /\u0026gt; \u0026lt;!-- 配置数据库连接信息 --\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;${oracle.driver}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;${oracle.url}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;${oracle.username}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${oracle.password}\u0026quot; /\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;!--mysql --\u0026gt; \u0026lt;environment id=\u0026quot;devMysql\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot; /\u0026gt; \u0026lt;!-- 配置数据库连接信息 --\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;${mysql.driver}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;${mysql.url}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;${mysql.username}\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${mysql.password}\u0026quot; /\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt;  db.properties\n#oracle oracle.driver=oracle.jdbc.OracleDriver oracle.url=jdbc:oracle:thin:@127.0.0.1:1521:ORCL oracle.username=scott oracle.password=tiger #mysql mysql.driver=com.mysql.jdbc.Driver mysql.url=jdbc:mysql://localhost:3306/mydb?allowMultiQueries=true mysql.username=root mysql.password=root  配置 Provider别名\n\u0026lt;!-- 配置数据库支持类，value的值是别名--\u0026gt; \u0026lt;databaseIdProvider type=\u0026quot;DB_VENDOR\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;MySQL\u0026quot; value=\u0026quot;mysql\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;Oracle\u0026quot; value=\u0026quot;oracle\u0026quot; /\u0026gt; \u0026lt;/databaseIdProvider\u0026gt;  写不同数据库的SQL语句\n 在mappe.xml中配置databaseId=\u0026ldquo;Provider别名\u0026rdquo;、\n\u0026lt;!--mysql--\u0026gt; \u0026lt;select id=\u0026quot;queryStudentByNo\u0026quot; resultType=\u0026quot;com.yanqun.entity.Student\u0026quot; parameterType=\u0026quot;int\u0026quot; databaseId=\u0026quot;mysql\u0026quot;\u0026gt; select * from student where stuNo=#{stuNo} \u0026lt;/select\u0026gt;  \u0026lt;!-- oracle--\u0026gt; \u0026lt;select id=\u0026quot;queryStudentByNo\u0026quot; parameterType=\u0026quot;student\u0026quot; resultType=\u0026quot;student\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; select * from student where stuNo=#{stuNo} \u0026lt;/select\u0026gt;  id值相同，系统会根据环境的不同选择执行的语句\n  如果mapper.xml的 sql标签 仅有 一个 不带databaseId的标签，则改标签 会自动适应当前数据库。如果既有不带databaseId的标签，又有带databaseId的标签,则程序会优先使用带databaseId的标签\n注解方式 推荐使用xml\n将sql语句写在接口的方法上@Select(\u0026ldquo;\u0026rdquo;) ;xxMapper.java // @Select(\u0026quot;select * from student where stuNo = #{stuNo}\u0026quot;) Student queryStudentByNo (int stuNo);  将接口的全类名 写入，让mybatis知道sql语句此时是存储在接口中conf.xml \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026quot;com.yanqun.mapper.StudentMapper\u0026quot; /\u0026gt; \u0026lt;/mappers\u0026gt;  注解/xml都支持批量引入，\n\u0026lt;mappers\u0026gt; \u0026lt;!--以下可以将com.yanqun.mapper 包中的注解接口 和 xml全部一次性引入 --\u0026gt; \u0026lt;package name=\u0026quot;com.yanqun.mapper\u0026quot; /\u0026gt; \u0026lt;/mappers\u0026gt;  增删改的返回值问题 返回值可以是void、Integer、Long、Boolean 如何操作：只需要在接口中 修改返回值即可,映射文件不需要任何其他的操作\n事务自动提交 手动提交： sessionFactory.openSession(); session.commit();//提交  自动提交：每个dml语句 自动提交 sessionFactory.openSession(true);  自增问题 mysql支持自增 表\ncreate table student ( stuno int(4) primary key auto_increment, stuname varchar(10), stuage int(4), graname varchar(10) );  自增的同时将值回写\n\u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;com.lx.entity.Student\u0026quot; databaseId=\u0026quot;mysql\u0026quot; useGeneratedKeys=\u0026quot;true\u0026quot; keyProperty=\u0026quot;stuNo\u0026quot;\u0026gt; insert into student(stuName,stuAge,graName) values(#{stuName},#{stuAge},#{graName}) \u0026lt;/insert\u0026gt;  只需要配置两个属性即可：\nuseGeneratedKeys=\u0026quot;true\u0026quot; keyProperty=\u0026quot;stuNo\u0026quot;  获取自增值\nstudent.getStuNo();  oracle不支持自增 ：通过序列模拟实现 创建序列\ncreate sequence myseq increment by 1 start with 1;  序列自带的两个属性：\nnextval：序列中下一个值 currval: 当前值  插入值\ninsert into student values(myseq.nextval,'zs1',23,'a1'); insert into student values(myseq.nextval,'zs2',24,'a2'); insert into student values(myseq.nextval,'zs3',25,'a3'); insert into student values(myseq.nextval,'zs4',26,'a4'); insert into student values(myseq.nextval,'zs5',27,'a5');  方式一：before（推荐）\n通过 \u0026lt;insert\u0026gt;的子标签 \u0026lt;selectKey\u0026gt;实现： 在 \u0026lt;selectKey\u0026gt;中查询下一个序列（自增后的值），再将此值传入keyProperty=\u0026ldquo;stuNo\u0026rdquo;属性，最后在真正执行时 使用该属性值。\n\u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;com.yanqun.entity.Student\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; \u0026lt;!--order=\u0026quot;BEFORE\u0026quot;表示先执行selectKey标签，将myseq.nextval的值拿到，放入keyProperty=\u0026quot;stuNo\u0026quot;中--\u0026gt; \u0026lt;selectKey keyProperty=\u0026quot;stuNo\u0026quot; resultType=\u0026quot;Integer\u0026quot; order=\u0026quot;BEFORE\u0026quot;\u0026gt; select myseq.nextval from dual \u0026lt;/selectKey\u0026gt; insert into student(stuno,stuName,stuAge,graName) values(#{stuNo} , #{stuName},#{stuAge},#{graName}) \u0026lt;/insert\u0026gt;  方式二：after\n\u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;com.yanqun.entity.Student\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; \u0026lt;selectKey keyProperty=\u0026quot;stuNo\u0026quot; resultType=\u0026quot;Integer\u0026quot; order=\u0026quot;AFTER\u0026quot;\u0026gt; select myseq.currval from dual \u0026lt;/selectKey\u0026gt; insert into student(stuno,stuName,stuAge,graName) values(myseq.nextval , #{stuName},#{stuAge},#{graName}) \u0026lt;/insert\u0026gt;  先执行sql语句，将数据插入在执行selectKey标签，将值回写，插入时使用的myseq.nextval，因此回写时使用的是myseq.currval\n参数问题 目前 将多个参数封装到一个javabean对象（pojo）,然后使用该对象传递\n传入多个参数时，不用在mapper.xml中编写parameterType（输入参数不用写）\n异常提示：\nstuNo不能使用。可以使用的是：\n[arg3, arg2, arg1, arg0, param3, param4, param1, param2]  \u0026lt;insert id=\u0026quot;addStudent\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; insert into student(stuno,stuName,stuAge,graName) values(#{arg0} , #{arg1},#{arg2},#{arg3}) \u0026lt;/insert\u0026gt;  或\nvalues(#{param1},#{param2},#{param3},#{param4})  注意param1从1开始计数arg0从0开始计数\npublic abstract Integer addStudent(Integer stuNo, String stuName, Integer stuAge,String graName);  StudentMapper studentMapper = session.getMapper(StudentMapper.class);//接口 Student stu = new Student(555, \u0026quot;bbb\u0026quot;, 44, \u0026quot;xx\u0026quot;); studentMapper.addStudent( stu);  命名参数 可以在接口中通过@Param(\u0026ldquo;sNo\u0026rdquo;) 指定sql中参数的名字\n\u0026lt;insert id=\u0026quot;addStudent\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; insert into student(stuno,stuName,stuAge,graName) values(#{sNo} , #{sName},#{sAge},#{gName}) \u0026lt;/insert\u0026gt;  public abstract Integer addStudent(@Param(\u0026quot;sNo\u0026quot;) Integer stuNo, @Param(\u0026quot;sName\u0026quot;)String stuName, @Param(\u0026quot;sAge\u0026quot;)Integer stuAge, @Param(\u0026quot;gName\u0026quot;)String graName);  StudentMapper studentMapper = session.getMapper(StudentMapper.class);//接口 Student stu = new Student(555, \u0026quot;aaa\u0026quot;, 44, \u0026quot;xx\u0026quot;); studentMapper.addStudent( stu);  综合使用 \u0026lt;insert id=\u0026quot;addStudent\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; insert into student(stuno,stuName,stuAge,graName) values(#{sNo} , #{stu.stuName},#{stu.stuAge},#{stu.graName}) \u0026lt;/insert\u0026gt;  Integer addStudent(@Param(\u0026quot;sNo\u0026quot;)Integer stuNo, @Param(\u0026quot;stu\u0026quot;)Student student);  StudentMapper studentMapper = session.getMapper(StudentMapper.class);//接口 Student stu = new Student(null, \u0026quot;xx\u0026quot;, 44, \u0026quot;xx\u0026quot;); studentMapper.addStudent(444,stu);  增加null Student stu = new Student(555, null, 44, \u0026quot;xx\u0026quot;); studentMapper.addStudent( stu);  oracle: 如果插入的字段是Null, 提示错误： Other 而不是null\nmysql：如果插入的字段是Null, 可以正常执行（没有约束）\n原因：\n各个数据库 在mybatis中 对各种数据类型的 默认值不一致。\nmybatis中，jdbcTypeForNull（如果是null） ，则默认值OTHER。对于Other来说，MySQL能够处理（NULL）,但是Oracle不行。\n解决： oracle： null -\u0026gt;OTHER ,需要手工告诉oracle :other -\u0026gt;null\n方法一：修改具体的sql标签\n当某个数据类型oracle无法处理时，告诉它用默认值null；\n注意，此时设置的jdbcType=NULL，不会影响正常的赋值（“zs”）\n\u0026lt;insert id=\u0026quot;addStudent\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; insert into student(stuno,stuName) values(#{stuNo} , #{stuName,jdbcType=NULL}) \u0026lt;/insert\u0026gt;  jdbcType=NULL表示，当且仅当oracle遇到不能处理的值的时候，赋值为null\n方法二：配置 mybatis全局配置文件conf.xml\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026quot;jdbcTypeForNull\u0026quot; value=\u0026quot;NULL\u0026quot;/\u0026gt; \u0026lt;/settings\u0026gt;  null -\u0026gt;jdbcTypeForNull -\u0026gt; NULL\n返回值为HashMap的情况 \u0026lt;select id=\u0026quot;queryStudentOutByHashMap\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;HashMap\u0026quot;\u0026gt; select stuNo \u0026quot;no\u0026quot;,stuName \u0026quot;name\u0026quot;,stuAge \u0026quot;age\u0026quot; from student where stuNo = #{stuNo} \u0026lt;/select\u0026gt;  HashMap\u0026lt;String,Object\u0026gt; queryStudentOutByHashMap(int stuNo);  StudentMapper studentMapper = session.getMapper(StudentMapper.class); HashMap\u0026lt;String, Object\u0026gt; studentMap = studentMapper.queryStudentOutByHashMap(11); //System.out.println( studentMap.get(\u0026quot;no\u0026quot;) +\u0026quot;,\u0026quot; +studentMap.get(\u0026quot;name\u0026quot;) +\u0026quot;,\u0026quot; +studentMap.get(\u0026quot;age\u0026quot;) ); System.out.println(studentMap);  select stuNo \u0026quot;no\u0026quot; ...其中 stuNo是数据库的字段名。 “no”是stuNo的别名，用于 在map中 get值时使用(作为map的key)。 map.get(\u0026quot;no\u0026quot; );\n如果不加别名，则map的key就是字段名\n\u0026lt;select id=\u0026quot;queryStudentOutByHashMap\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;HashMap\u0026quot;\u0026gt; select stuNo,stuName,stuAge from student where stuNo = #{stuNo} \u0026lt;/select\u0026gt;  查询结果为HashMap的集合\n\u0026lt;select id=\u0026quot;queryStudentsByHashMap\u0026quot; resultType=\u0026quot;HashMap\u0026quot;\u0026gt; select stuNo ,stuName ,stuAge from student \u0026lt;/select\u0026gt;  @MapKey(\u0026quot;STUNO\u0026quot;) HashMap\u0026lt;String,Student\u0026gt; queryStudentsByHashMap();  程序根据select的返回值 知道map的value就是 Student ,根据 @MapKey(\u0026quot;stuNo\u0026quot;)知道 Map的key是stuNo\n@MapKey(\u0026quot;STUNO\u0026quot;) //oracle的元数据（字段名、表名 ）都是大写\nStudentMxapper studentMapper = session.getMapper(StudentMapper.class); HashMap\u0026lt;String, Student\u0026gt; studentMap= studentMapper.queryStudentsByHashMap(); System.out.println( studentMap.get(\u0026quot;no\u0026quot;) +\u0026quot;,\u0026quot; +studentMap.get(\u0026quot;name\u0026quot;) +\u0026quot;,\u0026quot; +studentMap.get(\u0026quot;age\u0026quot;) ); session.close();  map:\nkey:STUNO value:Student  ResultMap ： 字段 和 属性名 的对应关系 字段名 \u0026mdash; 属性名 不一致\nsno - stuNo  \u0026lt;!-- 如果字段名 属性名不一致，需要使用resultMap指定对应关系--\u0026gt; \u0026lt;select id=\u0026quot;queryStudentsWithResultMap\u0026quot; parameterType=\u0026quot;int\u0026quot; resultMap =\u0026quot;studentResultMap\u0026quot;\u0026gt; select sno, sname, sage, gname from student where sno = #{sno} \u0026lt;/select\u0026gt;  \u0026lt;resultMap type=\u0026quot;com.yanqun.entity.Student\u0026quot; id=\u0026quot;studentResultMap\u0026quot;\u0026gt; \u0026lt;!--主键 --\u0026gt; \u0026lt;id column=\u0026quot;sno\u0026quot; property=\u0026quot;stuNo\u0026quot;/\u0026gt; \u0026lt;!--普通字段 \u0026lt;result column=\u0026quot;sname\u0026quot; property=\u0026quot;stuName\u0026quot;/\u0026gt; --\u0026gt; \u0026lt;result column=\u0026quot;sage\u0026quot; property=\u0026quot;stuAge\u0026quot;/\u0026gt; \u0026lt;result column=\u0026quot;gname\u0026quot; property=\u0026quot;graName\u0026quot;/\u0026gt; \u0026lt;/resultMap\u0026gt;  鉴别器\n\u0026lt;!-- 如果字段名 属性名不一致，需要使用resultMap指定对应关系--\u0026gt; \u0026lt;select id=\u0026quot;queryStudentsWithResultMap\u0026quot; resultMap =\u0026quot;studentResultMap\u0026quot;\u0026gt; select sno, sname,nickname, sage, gname from student \u0026lt;/select\u0026gt;  \u0026lt;resultMap type=\u0026quot;com.yanqun.entity.Student\u0026quot; id=\u0026quot;studentResultMap\u0026quot;\u0026gt; \u0026lt;!--主键 --\u0026gt; \u0026lt;id column=\u0026quot;sno\u0026quot; property=\u0026quot;stuNo\u0026quot;/\u0026gt; \u0026lt;!--普通字段 \u0026lt;result column=\u0026quot;sname\u0026quot; property=\u0026quot;stuName\u0026quot;/\u0026gt; --\u0026gt; \u0026lt;result column=\u0026quot;sage\u0026quot; property=\u0026quot;stuAge\u0026quot;/\u0026gt; \u0026lt;result column=\u0026quot;gname\u0026quot; property=\u0026quot;graName\u0026quot;/\u0026gt; \u0026lt;!-- 鉴别器 : 对查询结果进行分支处理： 如果是a年级，则真名，如果b年级，显示昵称--\u0026gt; \u0026lt;discriminator javaType=\u0026quot;string\u0026quot; column=\u0026quot;gname\u0026quot;\u0026gt; \u0026lt;case value=\u0026quot;a\u0026quot; resultType=\u0026quot;com.yanqun.entity.Student\u0026quot; \u0026gt; \u0026lt;result column=\u0026quot;sname\u0026quot; property=\u0026quot;stuName\u0026quot;/\u0026gt; \u0026lt;/case\u0026gt; \u0026lt;case value=\u0026quot;b\u0026quot; resultType=\u0026quot;student\u0026quot;\u0026gt; \u0026lt;result column=\u0026quot;nickname\u0026quot; property=\u0026quot;stuName\u0026quot;/\u0026gt; \u0026lt;/case\u0026gt; \u0026lt;/discriminator\u0026gt; \u0026lt;/resultMap\u0026gt;  List\u0026lt;Student\u0026gt; queryStudentsWithResultMap();  StudentMapper studentMapper = session.getMapper(StudentMapper.class);//接口 List\u0026lt;Student\u0026gt; students= studentMapper.queryStudentsWithResultMap();  在resultMap中 还可以使用鉴别器：对相同sql中不同字段值进行判断，从而进行不同的处理。\n别名问题 conf.xml\n\u0026lt;typeAliases\u0026gt; \u0026lt;!-- 给com.yanqun.entity包（包和子包）中的所有类 起了别名： 不带包名的类名，不区分大小写--\u0026gt; \u0026lt;package name=\u0026quot;com.yanqun.entity\u0026quot; \u0026gt;\u0026lt;/package\u0026gt; \u0026lt;/typeAliases\u0026gt;  如果在批量设置别名时，出现了冲突。可以使用@Alias(\u0026ldquo;myStudent\u0026rdquo;)区分。\n@Alias(\u0026quot;myStudent\u0026quot;) public class Student {}  SQL标签 ONGL技术\n\u0026lt;select id=\u0026quot;queryStudentByNoWithONGL\u0026quot; parameterType=\u0026quot;student\u0026quot; resultType=\u0026quot;student\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; \u0026lt;!-- select * from student where 1=1 --\u0026gt; select * from student \u0026lt;trim prefix=\u0026quot;where\u0026quot; suffixOverrides=\u0026quot;and\u0026quot;\u0026gt; \u0026lt;bind name=\u0026quot;_queryName\u0026quot; value=\u0026quot;'%'+stuName+'%'\u0026quot;/\u0026gt; \u0026lt;if test=\u0026quot;stuName != null and stuName !='' \u0026quot;\u0026gt; stuName like #{stuName} and \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;graName != null and graName !='' \u0026quot;\u0026gt; graName like '%${graName}%' and \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;stuAge != null and stuAge !='' \u0026quot;\u0026gt; stuAge = #{stuAge} and \u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; \u0026lt;!-- \u0026lt;trim prefix=\u0026quot;where\u0026quot; prefixOverrides=\u0026quot;and\u0026quot;\u0026gt; \u0026lt;if test=\u0026quot;stuName != null and stuName !='' \u0026quot;\u0026gt; and stuName like '%${stuName}%' \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;graName != null and graName !='' \u0026quot;\u0026gt; and graName like '%${graName}%' \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;stuAge != null and stuAge !='' \u0026quot;\u0026gt; and stuAge = #{stuAge} \u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; --\u0026gt; \u0026lt;!-- \u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;stuName != null and stuName !='' \u0026quot;\u0026gt; and stuName like '%${stuName}%' \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;graName != null and graName !='' \u0026quot;\u0026gt; and graName like '%${graName}%' \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;stuAge != null and stuAge !='' \u0026quot;\u0026gt; and stuAge = #{stuAge} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; --\u0026gt; \u0026lt;/select\u0026gt;  \u0026lt;where\u0026gt;可以处理拼接sql中 【开头】第一个and\n\u0026lt;trim\u0026gt;可以处理拼接sql中 【开头或结尾】第一个and\n开头：\n\u0026lt;trim prefix=\u0026quot;where\u0026quot; prefixOverrides=\u0026quot;and\u0026quot;\u0026gt; 给拼接的SQL加prefix=\u0026quot;where\u0026quot; prefixOverrides=\u0026quot;and\u0026quot;，处理拼接SQL中【开头】第一个and suffixOverrides=\u0026quot;and\u0026quot;，处理拼接SQL中【结尾】最后一个and prefix： 拼接 prefixOverrides：删除  内置参数 _parameter: 代表mybatis的输入参数。 _databaseId: 代表当前数据库的 名字  _parameter\n\u0026lt;if test=\u0026quot;_parameter.stuName != null and _parameter.stuName !='' \u0026quot;\u0026gt; stuName like '%${_parameter.stuName}%' and \u0026lt;/if\u0026gt;  _databaseId\n\u0026lt;if test=\u0026quot;_databaseId == 'oracle'\u0026quot;\u0026gt; select * from student where stuNo = #{_parameter} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;_databaseId == 'mysql'\u0026quot;\u0026gt; select * from student where stuNo != #{_parameter} \u0026lt;/if\u0026gt;  模糊查询三种方法 ${} ：原样输出 #[]:加引号  方法一${} stuName like '%${stuName}%'  方法二：传值时，直接传 #{} stuName like #{stuName} student.setStuName(\u0026quot;%s%\u0026quot;);  方法三：bind参数 \u0026lt;bind name=\u0026quot;_queryName\u0026quot; value=\u0026quot;'%'+stuName+'%'\u0026quot;/\u0026gt; stuName like #{_queryName}  通过bind将传入的stuName进行了处理（增加了%\u0026hellip;%）\n逆向工程的使用 生成逆向工程的文件\n增加 mybatis配置文件 conf.xml\n查询所有学生\n//Example中的Criteria：查询条件 List\u0026lt;Student\u0026gt; students = mapper.selectByExample(null) ;  public class TestGeneratorDemo { public static void main(String[] args) throws IOException { String resource = \u0026quot;conf.xml\u0026quot;; Reader reader = Resources.getResourceAsReader(resource); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession session = sessionFactory.openSession(); StudentMapper mapper = session.getMapper(StudentMapper.class); //Example中的Criteria：查询条件 // List\u0026lt;Student\u0026gt; students = mapper.selectByExample(null) ; //规则：example 默认使用的是 第一个criteria StudentExample example = new StudentExample() ; StudentExample.Criteria criteria = example.createCriteria(); // criteria.andStunoBetween((short) 32, (short) 33);// stuno: 2-3 criteria.andStunameLike(\u0026quot;%l%\u0026quot;); //where (xx=xx and xx =x) or (xx =xxx and xx =xx) ; //where stuname like '%z%' or ( stuno \u0026lt;=31 and granameLike \u0026quot;%j%) ; //criteria:where stuname like '%z%' // or //criteria: stuno \u0026lt;=31 and granameLike \u0026quot;%j% ； StudentExample.Criteria criteria1 = example.createCriteria(); criteria1.andStunoLessThanOrEqualTo((short)31) ; //\u0026lt;= criteria1.andGranameLike(\u0026quot;%j%\u0026quot;) ; example.or(criteria1) ; //query by Criteria , QBC List\u0026lt;Student\u0026gt; students = mapper.selectByExample(example ) ; System.out.println(students ); session.close(); } }  对于like模糊查询，逆向工程需要在传值时 写入%x%\nMyBatis架构和源码解析 MyBatis中步骤\na.获取SqlSessionFactory对象 b.获取SqlSession对象 c.获取XxxMapper对象（代理接口中的方法、mapper.xml中的\u0026lt;select\u0026gt;等标签） d.执行\u0026lt;select\u0026gt;等标签中定义的SQL语句  获取SqlSessionFactory对象 parser解析器\n通过parseConfiguration()在configuration标签 设置了 properties、settings、 environments等属性标签\n将所有的配置信息 放在了Configuration对象中\n解析所有的XxxMapper.xml文件（分析其中的 增删改查标签）\n\u0026lt;select id=\u0026quot;\u0026quot; resultType=\u0026quot; 等属性 是通过 parseStatementNode()解析的\n会将XxxMapper.xml中的\u0026lt;select\u0026gt;等标签解析成 MappedStatement对象即 MappedStatement对象就是 \u0026lt;select\u0026gt;等标签\nMappedStatement -\u0026gt;存在于Configuration中\nenvironment -\u0026gt;存在于Configuration中\n所有的配置信息、增删改标签 全部存在于Configuration中\nConfiguration又存在于DefaultSqlSessionFactory对象中（SqlSessionFactory）\nSqlSessionFactory对象 -\u0026gt;DefaultSqlSessionFactory -\u0026gt;Configuration -\u0026gt;包含了一切配置信息\n获取SqlSession对象 configuration.newExecutor(tx, execType) -\u0026gt;SimpleExecutor(默认)  根据不同的类型execType，产生不同的Executor,并且会对执行器进行拦截操作：\nexecutor = (Executor) interceptorChain.pluginAll(executor);  通过装饰模式，将刚才产生的executor 包装成一个更加强大的 executor。\n作用：以后 如果我们要给MyBatis写自己的插件， 就可以通过拦截器实现。\n插件开发：\n1. 写插件\n2. 放入拦截器\n返回DefaultSqlSession(configuration,executor,事务)\nSqlSession -》openSession()-\u0026gt;openSessionFromDataSource()-\u0026gt;DefaultSqlSession对象  SqlSession -》 DefaultSqlSession对象 -》执行SQL\n获取XxxMapper对象、执行 执行增删改查-\u0026gt;MapperProxy/invoke()\u0026ndash;\u0026gt;InvocationHandler ：JDK动态代理接口\n用到了 动态代理模式：增删改查 -\u0026gt; 代理对象 （MapperProxy对象） -\u0026gt;代理对象 帮我们“代理执行” 增删改查 -\u0026gt;\nXxxMapper代理对象： MapperProxy对象  mapperMethod.execute(sqlSession,args) ：实际调用增删改查的方法 ，依靠了sqlSession中的configuration和 executor..\n处理增删改查方法的参数：method.convertArgsToSqlCommandParam(args);： 如果參數是0个，reutrun null ;如果参数是1，返回第一个 ； 如果有多个参数 放入map中\n查询方法：selectOne() -\u0026gt;selectList() : configuration.getMappedStatement() 即获取到用于增删改查的对象\nboundSql ：将我们写的SQL 和 参数值进行了拼接后的对象，即最终能被真正执行的SQL\n执行SQL 是通过Executor\n如果缓存中没有要查询的内容，则进入数据库 真实查询：queryFromDatabase()\nmybatis使用的jdbc对象是PreparedStatement\n底层执行增删改查：PreparedStatement的execute()\nMyBatis底层在执行CRUD时 可能会涉及到四个处理器：StatementHandler（处理对象PreparedStatement的控制器） 、 ParameterHandler（处理参数的控制器） 、 TypeHandler（类型转换的控制器） 、 ResultSetHandler（处理结果集的控制器）\nXxxMapper包含:\nSqlSession(configuration,executor,事务)、代理接口的对象(MapperInterface)、methodCache(存放查询缓存， 底层是CurrentHashMap)\n自定义插件  四个处理：StatementHandler ParameterHandler ResultSetHandler TypeHandler\n四大核心对象：StatementHandler ParameterHandler ResultSetHandler Executor\n 四大核心对象\n 都涉及到了 拦截器 用于增强 四大核心对象都包含了 该增强操作  自定义插件的编写逻辑： 根据MyBatis规则 编写一个 拦截器 ，在拦截器内部加入 自定义增强功能\n步骤：\n编写拦截器 public class MyInterceptor implements Interceptor { //拦截 @Override public Object intercept(Invocation invocation) throws Throwable { System.out.println(\u0026quot;拦截方法...intercept...\u0026quot;); Object proceed = invocation.proceed();//放行 return proceed; } @Override public Object plugin(Object target) {//将拦截器中定义的 增强功能 和原来的核心对象 合并起来，称为最终的 核心对象 Object wrap = Plugin.wrap(target, this); System.out.println(\u0026quot;plugin....\u0026quot;+wrap); return wrap; } @Override public void setProperties(Properties properties) { System.out.println(\u0026quot;setProperties....\u0026quot;); } }  编写签名注解 @Intercepts({ @Signature(type = StatementHandler.class , method =\u0026quot;query\u0026quot;,args = {Statement.class, ResultHandler.class}) public class MyInterceptor implements Interceptor {  配置 \u0026lt;plugins\u0026gt; \u0026lt;plugin interceptor=\u0026quot;com.yanqun.my.interceptors.MyInterceptor\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;name\u0026quot; value=\u0026quot;zs\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;age\u0026quot; value=\u0026quot;23\u0026quot;/\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt;  编写多个拦截器时，执行顺序 和 \u0026lt;plugins\u0026gt;配置顺序一致\n插件\nselect * from student -\u0026gt;拦截器 增加where条件  编写拦截器\n//query(Statement statement, ResultHandler resultHandler) @Intercepts({ @Signature(type = StatementHandler.class , method =\u0026quot;parameterize\u0026quot;,args = {Statement.class}) }) public class MyInterceptor implements Interceptor { //拦截 @Override public Object intercept(Invocation invocation) throws Throwable { System.out.println(\u0026quot;拦截方法...intercept...\u0026quot;); Object target = invocation.getTarget();//目标方法 ： select * from student where stuNo = #{stuNo} System.out.println(\u0026quot;目标对象\u0026quot; +target); MetaObject metaObject = SystemMetaObject.forObject(target); // metaObject.getValue(\u0026quot;参数..\u0026quot;) ; Object value = metaObject.getValue(\u0026quot;parameterHandler.parameterObject\u0026quot;); System.out.println(value+\u0026quot;---------\u0026quot;); metaObject.setValue(\u0026quot;parameterHandler.parameterObject\u0026quot;,2);//11-\u0026gt;1 Object value2 = metaObject.getValue(\u0026quot;parameterHandler.parameterObject\u0026quot;); System.out.println(value2+\u0026quot;---------\u0026quot;); Object proceed = invocation.proceed();//放行 System.out.println(proceed); return proceed; } @Override public Object plugin(Object target) {//将拦截器中定义的 增强功能 和原来的核心对象 合并起来，称为最终的 核心对象 Object wrap = Plugin.wrap(target, this); System.out.println(\u0026quot;plugin....\u0026quot;+wrap); return wrap; } @Override public void setProperties(Properties properties) { // System.out.println(\u0026quot;setProperties....\u0026quot;); System.out.println(\u0026quot;设置属性:\u0026quot;+properties); //设置属性... } }  目标对象target的包装后的产物 -\u0026gt; metaObject.getValue(\u0026ldquo;可以从target中获取\u0026rdquo;)\n通过打印语句 可知，target就是 RoutingStatementHandler \u0026ndash;\u0026gt; metaObject.getValue(\u0026ldquo;可以从RoutingStatementHandler中获取\u0026rdquo;)\n-\u0026gt;metaObject.getValue(\u0026ldquo;可以从RoutingStatementHandler中获取 :boundSql/parameterHandler\u0026rdquo;)\n-\u0026gt;-\u0026gt;metaObject.getValue(\u0026ldquo;parameterHandler\u0026rdquo;)\nmetaObject.getValue(\u0026quot;parameterHandler.parameterObject\u0026quot;) //XxxMapper.xml中的sql语句中的参数值 metaObject.getValue(\u0026quot;parameterHandler.boundSql\u0026quot;) //XxxMapper.xml中的sql语句  \u0026ndash;\u0026gt;只研究\nmetaObject.setValue(\u0026quot;parameterHandler.parameterObject\u0026quot;,2)//修改参数值 metaObject.setValue(\u0026quot;parameterHandler.boundSql.sql\u0026quot;,\u0026quot;select * from book...\u0026quot;) //修改sql语句 metaObject.setValue(\u0026quot;parameterHandler.boundSql.parameterObject\u0026quot;,2)  批量操作DML sessionFactory.openSession(ExecutorType.BATCH ); --推荐的写法  \u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;com.yanqun.entity.Student\u0026quot; databaseId=\u0026quot;mysql\u0026quot;\u0026gt; insert into student(stuNo,stuName,stuAge,graName) values(#{stuNo} , #{stuName},#{stuAge},#{graName}) \u0026lt;/insert\u0026gt;  public abstract Integer addStudent(Student student);  SqlSession session = sessionFactory.openSession( ); StudentMapper studentMapper = session.getMapper(StudentMapper.class);//接口 long start = System.currentTimeMillis(); for(int i=0;i\u0026lt;100000;i++) { Student stu = new Student((int)(Math.random()*9000) +1000, \u0026quot;abc\u0026quot;, 44, \u0026quot;xx\u0026quot;); studentMapper.addStudent(stu); } long end = System.currentTimeMillis(); System.out.println(end-start);  此时插入数据较慢\n想变快则使用BATCH sessionFactory.openSession(ExecutorType.BATCH ); \u0026ndash;推荐的写法\nSqlSession session = sessionFactory.openSession( ExecutorType.BATCH); StudentMapper studentMapper = session.getMapper(StudentMapper.class);//接口 long start = System.currentTimeMillis(); for(int i=0;i\u0026lt;100000;i++) { Student stu = new Student((int)(Math.random()*9000) +1000, \u0026quot;abc\u0026quot;, 44, \u0026quot;xx\u0026quot;); studentMapper.addStudent(stu); } long end = System.currentTimeMillis(); System.out.println(end-start);  使用BATCH: 预编译SQL一次 ，其余DML 只需要设置参数值即可\ninsert into student(stuNo,stuName,stuAge,graName) values(#{stuNo} , #{stuName},#{stuAge},#{graName})  不使用BATCH： 预编译N次 ，每次DML都需要 执行完整的SQL\n不推荐的方式： 拼接SQL\noracle:批量插入 a. create table 表 select ... from 旧表 b. insert into 表(...) select .. from 表 ; c. begin ..(DML).. end ; d. 数据泵、SQL Loader 、外部表  以 c. begin ..(DML).. end ;为例\nbegin insert into student(stuno,stuname) values(1,\u0026quot;zs\u0026quot;); insert into student(stuno,stuname) values(1,\u0026quot;ls\u0026quot;); end ;  \u0026lt;insert id=\u0026quot;addStudentOracle\u0026quot; databaseId=\u0026quot;oracle\u0026quot;\u0026gt; \u0026lt;foreach collection=\u0026quot;list\u0026quot; open=\u0026quot;begin\u0026quot; close=\u0026quot;end ;\u0026quot; item=\u0026quot;student\u0026quot;\u0026gt; insert into student(stuno,stuname) values(#{student.stuNo},#{student.stuName}) ; \u0026lt;/foreach\u0026gt; \u0026lt;/insert\u0026gt;  void addStudentOracle (List\u0026lt;Student\u0026gt; students) ;  StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); students.add( new Student(10,\u0026quot;zs\u0026quot;) ); students.add( new Student(20,\u0026quot;ls\u0026quot;) ); studentMapper.addStudentOracle(students);  \u0026ndash;核心：将SQL拼接成oracle能够执行的SQL；\ncollection的参数必须是 collection或List\nmysql:批量插入 insert into student(stuno,stuname) values(100,'zsx'),(200,'lsx'),(200,'lsx'),(200,'lsx')...... ;  \u0026lt;insert id=\u0026quot;addStudentMySql\u0026quot; databaseId=\u0026quot;mysql\u0026quot;\u0026gt; insert into student(stuno,stuname) values \u0026lt;foreach collection=\u0026quot;list\u0026quot; item=\u0026quot;student\u0026quot; separator=\u0026quot;,\u0026quot; close=\u0026quot;;\u0026quot; \u0026gt; (#{student.stuNo},#{student.stuName}) \u0026lt;/foreach\u0026gt; \u0026lt;/insert\u0026gt;  void addStudentMySql (List\u0026lt;Student\u0026gt; students) ;  StudentMapper studentMapper = session.getMapper(StudentMapper.class); List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); students.add( new Student(510,\u0026quot;311zs\u0026quot;) ); students.add( new Student(610,\u0026quot;311ls\u0026quot;) ); studentMapper.addStudentMySql(students);  这种批量插入方式不推荐：\n 没有用到mybatis对批量插入的支持\n 不适合数据库迁移\n 如果大量数据，则会将 拼接的SQL语句拉的很长，而部分数据库 对SQL语句的长度有限制。  推荐：调存储过程、存储函数\nmysql.url=jdbc:mysql://localhost:3306/mydb?allowMultiQueries=true  myssql默认不支持接收多个分号（多条语句），这个可以修改默认设置\n分页插件 PageHelper\nPageHelper的git地址\n jar 配置conf.xml中 PageHelper.startPage(2, 3);  配置conf.xml \u0026lt;plugin interceptor=\u0026quot;com.github.pagehelper.PageInterceptor\u0026quot;\u0026gt; \u0026lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 \u0026lt;property name=\u0026quot;reasonable\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;--\u0026gt; \u0026lt;/plugin\u0026gt;  \u0026lt;select id=\u0026quot;queryStudents\u0026quot; resultType=\u0026quot;com.yanqun.entity.Student\u0026quot; \u0026gt; select * from student order by stuno \u0026lt;/select\u0026gt;  List\u0026lt;Student\u0026gt; queryStudents () ;  public static void queryStudents() throws IOException { String resource = \u0026quot;conf.xml\u0026quot;; Reader reader = Resources.getResourceAsReader(resource); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession session = sessionFactory.openSession(); StudentMapper studentMapper = session.getMapper(StudentMapper.class); /* 方式一 加入分页功能 Page\u0026lt;Object\u0026gt; page = PageHelper.startPage(2, 3); */ //pageInfo方式 PageHelper.startPage(2, 3); /* lambda形式 Page\u0026lt;Student\u0026gt; page = PageHelper.startPage(2, 3).doSelectPage(()-\u0026gt; studentMapper.queryStudents()); List\u0026lt;Student\u0026gt; list = page.getResult(); */ // select * from student order by stuno -\u0026gt;拦截器 //select * from student order by stuno limit 6,3 List\u0026lt;Student\u0026gt; list = studentMapper.queryStudents() ; for(Student student :list){ System.out.println(student); } //PageInfo方式 PageInfo\u0026lt;Student\u0026gt; pageInfo = new PageInfo\u0026lt;\u0026gt;(list); System.out.println(\u0026quot;当前页：\u0026quot;+pageInfo.getPageNum()); System.out.println(\u0026quot;总数据量：\u0026quot;+pageInfo.getTotal()); System.out.println(\u0026quot;总页码：\u0026quot; +pageInfo.getPages()); System.out.println(\u0026quot;页面大小：\u0026quot; +pageInfo.getPageSize()); System.out.println(\u0026quot;最开头那一页：\u0026quot;+ pageInfo.getNavigateFirstPage()); System.out.println(\u0026quot;每一页的页号\u0026quot;); for( int pageNum : pageInfo.getNavigatepageNums()){ System.out.println(pageNum); } session.close(); }  ","id":41,"section":"posts","summary":"Mybatis 简介 官网 mybatis: ibatis:apache 2010 ibatis-\u0026gt; google colde ,Mybatis MyBatis可以简化JDBC操作，实现数据的持久化 。 ORM:Object Relational Mapping ORM可以解决数据库与程序间的异构性，比如在Java中我","tags":["Spring家族"],"title":"Mybatis自学笔记","uri":"https://mumulx.github.io/2019/11/mybatis%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" 源码\n一、Spring Boot 入门 1、Spring Boot 简介  简化Spring应用开发的一个框架；\n整个Spring技术栈的一个大整合；\nJ2EE开发的一站式解决方案；\n 2、微服务 2014，martin fowler\n微服务：架构风格（服务微化）\n一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；\n单体应用：ALL IN ONE\n微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；\n详细参照微服务文档\n3、环境准备 http://www.gulixueyuan.com/\n环境约束\n–jdk1.8：Spring Boot 推荐jdk1.7及以上；java version \u0026ldquo;1.8.0_112\u0026rdquo;\n–maven3.x：maven 3.3以上版本；Apache Maven 3.3.9\n–IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS\n–SpringBoot 1.5.9.RELEASE：1.5.9；\n统一环境；\n1、MAVEN设置； 给maven 的settings.xml配置文件的profiles标签添加\n\u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;jdk-1.8\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;jdk\u0026gt;1.8\u0026lt;/jdk\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.compilerVersion\u0026gt;1.8\u0026lt;/maven.compiler.compilerVersion\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt;  2、IDEA设置 整合maven进来；\n4、Spring Boot HelloWorld 一个功能：\n浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；\n1、创建一个maven工程；（jar） 2、导入spring boot相关的依赖 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.5.9.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  3、编写一个主程序；启动Spring Boot应用 /** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */ @SpringBootApplication public class HelloWorldMainApplication { public static void main(String[] args) { // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); } }  4、编写相关的Controller、Service @Controller public class HelloController { @ResponseBody @RequestMapping(\u0026quot;/hello\u0026quot;) public String hello(){ return \u0026quot;Hello World!\u0026quot;; } }  5、运行主程序测试 6、简化部署 \u0026lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;  将这个应用打成jar包，直接使用java -jar的命令进行执行；\n5、Hello World探究 1、POM文件 1、父项目 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.5.9.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; 他的父项目是 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.5.9.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../../spring-boot-dependencies\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; 他来真正管理Spring Boot应用里面的所有依赖版本；  Spring Boot的版本仲裁中心；\n以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）\n2、启动器 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  spring-boot-starter-==web==：\n​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；\nSpring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器\n2、主程序类，主入口类 /** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */ @SpringBootApplication public class HelloWorldMainApplication { public static void main(String[] args) { // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); } }  @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；\n@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication {  @SpringBootConfiguration:Spring Boot的配置类；\n​ 标注在某个类上，表示这是一个Spring Boot的配置类；\n​ @Configuration:配置类上来标注这个注解；\n​ 配置类 \u0026mdash;\u0026ndash; 配置文件；配置类也是容器中的一个组件；@Component\n@EnableAutoConfiguration：开启自动配置功能；\n​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效；\n@AutoConfigurationPackage @Import(EnableAutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration {  ​ @AutoConfigurationPackage：自动配置包\n​ @Import(AutoConfigurationPackages.Registrar.class)：\n​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；\n==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；==\n​ @Import(EnableAutoConfigurationImportSelector.class)；\n​ 给容器中导入组件？\n​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器；\n​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；\n​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；\n​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；\n==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们；\nJ2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；\n​\n==Spring注解版（谷粒学院）==\n6、使用Spring Initializer快速创建Spring Boot项目 1、IDEA：使用 Spring Initializer快速创建项目 IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；\n选择我们需要的模块；向导会联网创建Spring Boot项目；\n默认生成的Spring Boot项目；\n 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构  static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；   2、STS使用 Spring Starter Project快速创建项目 二、配置文件 1、配置文件 SpringBoot使用一个全局的配置文件，配置文件名是固定的；\n•application.properties\n•application.yml\n配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；\nYAML（YAML Ain\u0026rsquo;t Markup Language）\n​ YAML A Markup Language：是一个标记语言\n​ YAML isn\u0026rsquo;t Markup Language：不是一个标记语言；\n标记语言：\n​ 以前的配置文件；大多都使用的是 xxxx.xml文件；\n​ YAML：以数据为中心，比json、xml等更适合做配置文件；\n​ YAML：配置例子\nserver: port: 8081  ​ XML：\n\u0026lt;server\u0026gt; \u0026lt;port\u0026gt;8081\u0026lt;/port\u0026gt; \u0026lt;/server\u0026gt;  2、YAML语法： 1、基本语法 k:(空格)v：表示一对键值对（空格必须有）；\n以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的\nserver: port: 8081 path: /hello  属性和值也是大小写敏感；\n2、值的写法 字面量：普通的值（数字，字符串，布尔） ​ k: v：字面直接来写；\n​ 字符串默认不用加上单引号或者双引号；\n​ \u0026ldquo;\u0026ldquo;：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思\n​ name: \u0026ldquo;zhangsan \\n lisi\u0026rdquo;：输出；zhangsan 换行 lisi\n​ \u0026ldquo;：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据\n​ name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi\n对象、Map（属性和值）（键值对）： ​ k: v：在下一行来写对象的属性和值的关系；注意缩进\n​ 对象还是k: v的方式\nfriends: lastName: zhangsan age: 20  行内写法：\nfriends: {lastName: zhangsan,age: 18}  数组（List、Set）： 用- 值表示数组中的一个元素\npets: - cat - dog - pig  行内写法\npets: [cat,dog,pig]  3、配置文件值注入 配置文件\nperson: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: {k1: v1,k2: 12} lists: - lisi - zhaoliu dog: name: 小狗 age: 12  javaBean：\n/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \u0026quot;person\u0026quot;：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */ @Component @ConfigurationProperties(prefix = \u0026quot;person\u0026quot;) public class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map\u0026lt;String,Object\u0026gt; maps; private List\u0026lt;Object\u0026gt; lists; private Dog dog;  我们可以导入配置文件处理器，以后编写配置就有提示了\n\u0026lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt;  1、properties配置文件在idea中默认utf-8可能会乱码 调整\n2、@Value获取值和@ConfigurationProperties获取值比较     @ConfigurationProperties @Value     功能 批量注入配置文件中的属性 一个个指定   松散绑定（松散语法） 支持 不支持   SpEL 不支持 支持   JSR303数据校验 支持 不支持   复杂类型封装 支持 不支持    配置文件yml还是properties他们都能获取到值；\n如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；\n如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；\n3、配置文件注入值数据校验 @Component @ConfigurationProperties(prefix = \u0026quot;person\u0026quot;) @Validated public class Person { /** * \u0026lt;bean class=\u0026quot;Person\u0026quot;\u0026gt; * \u0026lt;property name=\u0026quot;lastName\u0026quot; value=\u0026quot;字面量/${key}从环境变量、配置文件中获取值/#{SpEL}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; * \u0026lt;bean/\u0026gt; */ //lastName必须是邮箱格式 @Email //@Value(\u0026quot;${person.last-name}\u0026quot;) private String lastName; //@Value(\u0026quot;#{11*2}\u0026quot;) private Integer age; //@Value(\u0026quot;true\u0026quot;) private Boolean boss; private Date birth; private Map\u0026lt;String,Object\u0026gt; maps; private List\u0026lt;Object\u0026gt; lists; private Dog dog;  4、@PropertySource\u0026amp;@ImportResource\u0026amp;@Bean @PropertySource：加载指定的配置文件；\n/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \u0026quot;person\u0026quot;：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = \u0026quot;person\u0026quot;)默认从全局配置文件中获取值； * */ @PropertySource(value = {\u0026quot;classpath:person.properties\u0026quot;}) @Component @ConfigurationProperties(prefix = \u0026quot;person\u0026quot;) //@Validated public class Person { /** * \u0026lt;bean class=\u0026quot;Person\u0026quot;\u0026gt; * \u0026lt;property name=\u0026quot;lastName\u0026quot; value=\u0026quot;字面量/${key}从环境变量、配置文件中获取值/#{SpEL}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; * \u0026lt;bean/\u0026gt; */ //lastName必须是邮箱格式 // @Email //@Value(\u0026quot;${person.last-name}\u0026quot;) private String lastName; //@Value(\u0026quot;#{11*2}\u0026quot;) private Integer age; //@Value(\u0026quot;true\u0026quot;) private Boolean boss;  @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效；\nSpring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；\n想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上\n@ImportResource(locations = {\u0026quot;classpath:beans.xml\u0026quot;}) 导入Spring的配置文件让其生效  不来编写Spring的配置文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026quot;\u0026gt; \u0026lt;bean id=\u0026quot;helloService\u0026quot; class=\u0026quot;com.atguigu.springboot.service.HelloService\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;  SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式\n1、配置类@Configuration\u0026mdash;\u0026mdash;\u0026gt;Spring配置文件\n2、使用@Bean给容器中添加组件\n/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用\u0026lt;bean\u0026gt;\u0026lt;bean/\u0026gt;标签添加组件 * */ @Configuration public class MyAppConfig { //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02(){ System.out.println(\u0026quot;配置类@Bean给容器中添加组件了...\u0026quot;); return new HelloService(); } }  ##4、配置文件占位符\n1、随机数 ${random.value}、${random.int}、${random.long} ${random.int(10)}、${random.int[1024,65536]}  2、占位符获取之前配置的值，如果没有可以是用:指定默认值 person.last-name=张三${random.uuid} person.age=${random.int} person.birth=2017/12/15 person.boss=false person.maps.k1=v1 person.maps.k2=14 person.lists=a,b,c person.dog.name=${person.hello:hello}_dog person.dog.age=15  5、Profile 1、多Profile文件 我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml\n默认使用application.properties的配置；\n2、yml支持多文档块方式 server: port: 8081 spring: profiles: active: prod --- server: port: 8083 spring: profiles: dev --- server: port: 8084 spring: profiles: prod #指定属于哪个环境  3、激活指定profile ​ 1、在配置文件中指定 spring.profiles.active=dev\n​ 2、命令行：\n​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar \u0026ndash;spring.profiles.active=dev；\n​ 可以直接在测试的时候，配置传入命令行参数\n​ 3、虚拟机参数；\n​ -Dspring.profiles.active=dev\n6、配置文件加载位置 springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件\n–file:./config/\n–file:./\n–classpath:/config/\n–classpath:/\n优先级由高到底，高优先级的配置会覆盖低优先级的配置；\nSpringBoot会从这四个位置全部加载主配置文件；互补配置；\n==我们还可以通过spring.config.location来改变默认的配置文件位置==\n项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；\njava -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar \u0026ndash;spring.config.location=G:/application.properties\n7、外部配置加载顺序 ==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置==\n1.命令行参数\n所有的配置都可以在命令行上进行指定\njava -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar \u0026ndash;server.port=8087 \u0026ndash;server.context-path=/abc\n多个配置用空格分开； \u0026ndash;配置项=值\n2.来自java:comp/env的JNDI属性\n3.Java系统属性（System.getProperties()）\n4.操作系统环境变量\n5.RandomValuePropertySource配置的random.*属性值\n==由jar包外向jar包内进行寻找；==\n==优先加载带profile==\n6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件\n7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件\n==再来加载不带profile==\n8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件\n9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件\n10.@Configuration注解类上的@PropertySource\n11.通过SpringApplication.setDefaultProperties指定的默认属性\n所有支持的配置加载来源；\n参考官方文档\n8、自动配置原理 配置文件到底能写什么？怎么写？自动配置原理；\n配置文件能配置的属性参照\n1、自动配置原理： 1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==\n2）、@EnableAutoConfiguration 作用：\n 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？\n 可以查看selectImports()方法的内容；\n List\u0026lt;String\u0026gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置\nSpringFactoriesLoader.loadFactoryNames() 扫描所有jar包类路径下 META-INF/spring.factories 把扫描到的这些文件的内容包装成properties对象 从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中   将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；\nAuto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\ org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\ org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\ org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\ org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\ org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\ org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\ org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\ org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\ org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\ org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\ org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\ org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\ org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\ org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\ org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\ org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\ org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\ org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\ org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\ org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\ org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\ org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\ org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\ org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\ org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\ org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\ org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\ org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\ org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\ org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\ org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\ org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\ org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\ org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\ org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\ org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\ org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\ org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\ org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\ org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\ org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\ org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\ org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\ org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\ org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\ org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\ org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\ org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\ org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\ org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\ org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\ org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\ org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\ org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\ org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration  每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；\n3）、每一个自动配置类进行自动配置功能；\n4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；\n@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件 @EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中 @ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效 @ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器； @ConditionalOnProperty(prefix = \u0026quot;spring.http.encoding\u0026quot;, value = \u0026quot;enabled\u0026quot;, matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的 //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的； public class HttpEncodingAutoConfiguration { //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) { this.properties = properties; } @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; }  根据当前不同的条件判断，决定这个配置类是否生效？\n一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；\n5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类\n@ConfigurationProperties(prefix = \u0026quot;spring.http.encoding\u0026quot;) //从配置文件中获取指定的值和bean的属性进行绑定 public class HttpEncodingProperties { public static final Charset DEFAULT_CHARSET = Charset.forName(\u0026quot;UTF-8\u0026quot;);  精髓：\n​ 1）、SpringBoot启动会加载大量的自动配置类\n​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；\n​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）\n​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；\nxxxxAutoConfigurartion：自动配置类；\n给容器中添加组件\nxxxxProperties:封装配置文件中相关属性；\n2、细节 1、@Conditional派生注解（Spring注解版原生的@Conditional作用） 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；\n   @Conditional扩展注解 作用（判断是否满足当前指定条件）     @ConditionalOnJava 系统的java版本是否符合要求   @ConditionalOnBean 容器中存在指定Bean；   @ConditionalOnMissingBean 容器中不存在指定Bean；   @ConditionalOnExpression 满足SpEL表达式指定   @ConditionalOnClass 系统中有指定的类   @ConditionalOnMissingClass 系统中没有指定的类   @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean   @ConditionalOnProperty 系统中指定的属性是否有指定的值   @ConditionalOnResource 类路径下是否存在指定资源文件   @ConditionalOnWebApplication 当前是web环境   @ConditionalOnNotWebApplication 当前不是web环境   @ConditionalOnJndi JNDI存在指定项    自动配置类必须在一定的条件下才能生效；\n我们怎么知道哪些自动配置类生效；\n==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效；\n========================= AUTO-CONFIGURATION REPORT ========================= Positive matches:（自动配置类启用的） ----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类） ----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition)  三、日志 1、日志框架 小张；开发一个大型系统；\n​ 1、System.out.println(\u0026ldquo;\u0026rdquo;)；将关键数据打印在控制台；去掉？写在一个文件？\n​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar；\n​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？\n​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；\n​ 5、JDBC\u0026mdash;数据库驱动；\n​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；\n​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；\n市面上的日志框架；\nJUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j\u0026hellip;.\n   日志门面 （日志的抽象层） 日志实现     JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback    左边选一个门面（抽象层）、右边来选一个实现；\n日志门面： SLF4J；\n日志实现：Logback；\nSpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘\n​ ==SpringBoot选用 SLF4j和logback；==\n2、SLF4j使用 1、如何在系统中使用SLF4j https://www.slf4j.org 以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；\n给系统里面导入slf4j的jar和 logback的实现jar\nimport org.slf4j.Logger; import org.slf4j.LoggerFactory; public class HelloWorld { public static void main(String[] args) { Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\u0026quot;Hello World\u0026quot;); } }  图示；\n每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件；\n2、遗留问题 a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx\n统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？\n如何让系统中所有的日志都统一到slf4j；\n==1、将系统中其他日志框架先排除出去；==\n==2、用中间包来替换原有的日志框架；==\n==3、我们导入slf4j其他的实现==\n3、SpringBoot日志关系 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  SpringBoot使用它来做日志功能；\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-logging\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  底层依赖关系\n总结：\n​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录\n​ 2）、SpringBoot也把其他的日志都替换成了slf4j；\n​ 3）、中间替换包？\n@SuppressWarnings(\u0026quot;rawtypes\u0026quot;) public abstract class LogFactory { static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = \u0026quot;http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j\u0026quot;; static LogFactory logFactory = new SLF4JLogFactory();  ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？\n​ Spring框架用的是commons-logging；\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt;  ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；==\n4、日志使用； 1、默认配置 SpringBoot默认帮我们配置好了日志；\n//记录器 Logger logger = LoggerFactory.getLogger(getClass()); @Test public void contextLoads() { //System.out.println(); //日志的级别； //由低到高 trace\u0026lt;debug\u0026lt;info\u0026lt;warn\u0026lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace(\u0026quot;这是trace日志...\u0026quot;); logger.debug(\u0026quot;这是debug日志...\u0026quot;); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info(\u0026quot;这是info日志...\u0026quot;); logger.warn(\u0026quot;这是warn日志...\u0026quot;); logger.error(\u0026quot;这是error日志...\u0026quot;); }   日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --\u0026gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n  SpringBoot修改日志的默认配置\nlogging.level.com.atguigu=trace #logging.path= # 不指定路径在当前项目下生成springboot.log日志 # 可以指定完整的路径； #logging.file=G:/springboot.log # 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件 logging.path=/spring/log # 在控制台输出的日志的格式 logging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n # 指定文件中日志输出的格式 logging.pattern.file=%d{yyyy-MM-dd} === [%thread] === %-5level === %logger{50} ==== %msg%n     logging.file logging.path Example Description     (none) (none)  只在控制台输出   指定文件名 (none) my.log 输出日志到my.log文件   (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中    2、指定配置 给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了\n   Logging System Customization     Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy   Log4j2 log4j2-spring.xml or log4j2.xml   JDK (Java Util Logging) logging.properties    logback.xml：直接就被日志框架识别了；\nlogback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能\n\u0026lt;springProfile name=\u0026quot;staging\u0026quot;\u0026gt; \u0026lt;!-- configuration to be enabled when the \u0026quot;staging\u0026quot; profile is active --\u0026gt; 可以指定某段配置只在某个环境下生效 \u0026lt;/springProfile\u0026gt;  如：\n\u0026lt;appender name=\u0026quot;stdout\u0026quot; class=\u0026quot;ch.qos.logback.core.ConsoleAppender\u0026quot;\u0026gt; \u0026lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --\u0026gt; \u0026lt;layout class=\u0026quot;ch.qos.logback.classic.PatternLayout\u0026quot;\u0026gt; \u0026lt;springProfile name=\u0026quot;dev\u0026quot;\u0026gt; \u0026lt;pattern\u0026gt;%d{yyyy-MM-dd HH:mm:ss.SSS} ----\u0026gt; [%thread] ---\u0026gt; %-5level %logger{50} - %msg%n\u0026lt;/pattern\u0026gt; \u0026lt;/springProfile\u0026gt; \u0026lt;springProfile name=\u0026quot;!dev\u0026quot;\u0026gt; \u0026lt;pattern\u0026gt;%d{yyyy-MM-dd HH:mm:ss.SSS} ==== [%thread] ==== %-5level %logger{50} - %msg%n\u0026lt;/pattern\u0026gt; \u0026lt;/springProfile\u0026gt; \u0026lt;/layout\u0026gt; \u0026lt;/appender\u0026gt;  如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误\nno applicable action for [springProfile]\n5、切换日志框架 可以按照slf4j的日志适配图，进行相关的切换；\nslf4j+log4j的方式；\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;log4j-over-slf4j\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-log4j12\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  切换为log4j2\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-logging\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-log4j2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  四、Web开发 1、简介 使用SpringBoot；\n1）、创建SpringBoot应用，选中我们需要的模块；\n2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来\n3）、自己编写业务代码；\n自动配置原理？\n这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx\nxxxxAutoConfiguration：帮我们给容器中自动配置组件； xxxxProperties:配置类来封装配置文件的内容；  2、SpringBoot对静态资源的映射规则； @ConfigurationProperties(prefix = \u0026quot;spring.resources\u0026quot;, ignoreUnknownFields = false) public class ResourceProperties implements ResourceLoaderAware { //可以设置和静态资源有关的参数，缓存时间等  WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { logger.debug(\u0026quot;Default resource handling disabled\u0026quot;); return; } Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern(\u0026quot;/webjars/**\u0026quot;)) { customizeResourceHandlerRegistration( registry.addResourceHandler(\u0026quot;/webjars/**\u0026quot;) .addResourceLocations( \u0026quot;classpath:/META-INF/resources/webjars/\u0026quot;) .setCachePeriod(cachePeriod)); } String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) { customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); } } //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) { return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); } //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = \u0026quot;spring.mvc.favicon.enabled\u0026quot;, matchIfMissing = true) public static class FaviconConfiguration { private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) { this.resourceProperties = resourceProperties; } @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() { SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap(\u0026quot;**/favicon.ico\u0026quot;, faviconRequestHandler())); return mapping; } @Bean public ResourceHttpRequestHandler faviconRequestHandler() { ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; } }  ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；==\n​ webjars：以jar包的方式引入静态资源；\nhttp://www.webjars.org/\nlocalhost:8080/webjars/jquery/3.3.1/jquery.js\n\u0026lt;!--引入jquery-webjar--\u0026gt;在访问的时候只需要写webjars下面资源的名称即可 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.webjars\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jquery\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  ==2）、\u0026rdquo;/**\u0026rdquo; 访问当前项目的任何资源，都去（静态资源的文件夹）找映射==\n\u0026quot;classpath:/META-INF/resources/\u0026quot;, \u0026quot;classpath:/resources/\u0026quot;, \u0026quot;classpath:/static/\u0026quot;, \u0026quot;classpath:/public/\u0026quot; \u0026quot;/\u0026quot;：当前项目的根路径  localhost:8080/abc === 去静态资源文件夹里面找abc\n==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被\u0026rdquo;/**\u0026ldquo;映射；==\n​ localhost:8080/ 找index页面\n==4）、所有的 **/favicon.ico 都是在静态资源文件下找；==\n3、模板引擎 JSP、Velocity、Freemarker、Thymeleaf\nSpringBoot推荐的Thymeleaf；\n语法更简单，功能更强大；\n1、引入thymeleaf； \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; 2.1.6 \u0026lt;/dependency\u0026gt; 切换thymeleaf版本 \u0026lt;properties\u0026gt; \u0026lt;thymeleaf.version\u0026gt;3.0.9.RELEASE\u0026lt;/thymeleaf.version\u0026gt; \u0026lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --\u0026gt; \u0026lt;!-- thymeleaf2 layout1--\u0026gt; \u0026lt;thymeleaf-layout-dialect.version\u0026gt;2.2.2\u0026lt;/thymeleaf-layout-dialect.version\u0026gt; \u0026lt;/properties\u0026gt;  2、Thymeleaf使用 @ConfigurationProperties(prefix = \u0026quot;spring.thymeleaf\u0026quot;) public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING = Charset.forName(\u0026quot;UTF-8\u0026quot;); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\u0026quot;text/html\u0026quot;); public static final String DEFAULT_PREFIX = \u0026quot;classpath:/templates/\u0026quot;; public static final String DEFAULT_SUFFIX = \u0026quot;.html\u0026quot;; //  只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；\n使用：\n1、导入thymeleaf的名称空间\n\u0026lt;html lang=\u0026quot;en\u0026quot; xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;  2、使用thymeleaf语法；\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot; xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;成功！\u0026lt;/h1\u0026gt; \u0026lt;!--th:text 将div里面的文本内容设置为 --\u0026gt; \u0026lt;div th:text=\u0026quot;${hello}\u0026quot;\u0026gt;这是显示欢迎信息\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  3、语法规则 1）、th:text；改变当前元素里面的文本内容；\n​ th：任意html属性；来替换原生属性的值\n2）、表达式？\nSimple expressions:（表达式语法） Variable Expressions: ${...}：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. ${session.foo} 3）、内置的一些工具对象： #execInfo : information about the template being processed. #messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样； 补充：配合 th:object=\u0026quot;${session.user}： \u0026lt;div th:object=\u0026quot;${session.user}\u0026quot;\u0026gt; \u0026lt;p\u0026gt;Name: \u0026lt;span th:text=\u0026quot;*{firstName}\u0026quot;\u0026gt;Sebastian\u0026lt;/span\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Surname: \u0026lt;span th:text=\u0026quot;*{lastName}\u0026quot;\u0026gt;Pepper\u0026lt;/span\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Nationality: \u0026lt;span th:text=\u0026quot;*{nationality}\u0026quot;\u0026gt;Saturn\u0026lt;/span\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; Message Expressions: #{...}：获取国际化内容 Link URL Expressions: @{...}：定义URL； @{/order/process(execId=${execId},execType='FAST')} Fragment Expressions: ~{...}：片段引用表达式 \u0026lt;div th:insert=\u0026quot;~{commons :: main}\u0026quot;\u0026gt;...\u0026lt;/div\u0026gt; Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,… Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is ${name}| Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): - Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , not Comparisons and equality:（比较运算） Comparators: \u0026gt; , \u0026lt; , \u0026gt;= , \u0026lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne ) Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) Special tokens: No-Operation: _  4、SpringMVC自动配置 https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications\n1. Spring MVC auto-configuration Spring Boot 自动配置好了SpringMVC\n以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）==\n Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.\n 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；==  Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars\n Static index.html support. 静态首页访问\n Custom Favicon support (see below). favicon.ico\n 自动注册了 of Converter, GenericConverter, Formatter beans.\n Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date；\n@Bean @ConditionalOnProperty(prefix = \u0026quot;spring.mvc\u0026quot;, name = \u0026quot;date-format\u0026quot;)//在文件中配置日期格式化的规则 public Formatter\u0026lt;Date\u0026gt; dateFormatter() { return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件 }    ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可==\n Support for HttpMessageConverters (see below).\n HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User\u0026mdash;Json；\n HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter；\n  ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）==\n Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则\n Automatic use of a ConfigurableWebBindingInitializer bean (see below).\n  ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）==\n 初始化WebDataBinder； 请求数据=====JavaBean；  org.springframework.boot.autoconfigure.web：web的所有自动场景；\nIf you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components.\nIf you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.\n2、扩展SpringMVC \u0026lt;mvc:view-controller path=\u0026quot;/hello\u0026quot; view-name=\u0026quot;success\u0026quot;/\u0026gt; \u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026quot;/hello\u0026quot;/\u0026gt; \u0026lt;bean\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt;  ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==;\n既保留了所有的自动配置，也能用我们扩展的配置；\n//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能 @Configuration public class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\u0026quot;/atguigu\u0026quot;).setViewName(\u0026quot;success\u0026quot;); } }  原理：\n​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类\n​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class)\n@Configuration public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List\u0026lt;WebMvcConfigurer\u0026gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) { // for (WebMvcConfigurer delegate : this.delegates) { // delegate.addViewControllers(registry); // } } } }  ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用；\n​ 4）、我们的配置类也会被调用；\n​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用；\n3、全面接管SpringMVC； SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了\n我们需要在配置类中添加@EnableWebMvc即可；\n//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能 @EnableWebMvc @Configuration public class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\u0026quot;/atguigu\u0026quot;).setViewName(\u0026quot;success\u0026quot;); } }  原理：\n为什么@EnableWebMvc自动配置就失效了；\n1）@EnableWebMvc的核心\n@Import(DelegatingWebMvcConfiguration.class) public @interface EnableWebMvc {  2）、\n@Configuration public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {  3）、\n@Configuration @ConditionalOnWebApplication @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class }) //容器中没有这个组件的时候，这个自动配置类才生效 @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10) @AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class }) public class WebMvcAutoConfiguration {  4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；\n5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；\n5、如何修改SpringBoot的默认配置 模式：\n​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；\n​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置\n​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置\n6、RestfulCRUD 1）、默认访问首页 //使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能 //@EnableWebMvc 不要接管SpringMVC @Configuration public class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\u0026quot;/atguigu\u0026quot;).setViewName(\u0026quot;success\u0026quot;); } //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){ WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\u0026quot;/\u0026quot;).setViewName(\u0026quot;login\u0026quot;); registry.addViewController(\u0026quot;/index.html\u0026quot;).setViewName(\u0026quot;login\u0026quot;); } }; return adapter; } }  2）、国际化 1）、编写国际化配置文件；\n2）、使用ResourceBundleMessageSource管理国际化资源文件\n3）、在页面使用fmt:message取出国际化内容\n步骤：\n1）、编写国际化配置文件，抽取页面需要显示的国际化消息\n2）、SpringBoot自动配置好了管理国际化资源文件的组件；\n@ConfigurationProperties(prefix = \u0026quot;spring.messages\u0026quot;) public class MessageSourceAutoConfiguration { /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * \u0026quot;org.mypackage\u0026quot;), it will be resolved from the classpath root. */ private String basename = \u0026quot;messages\u0026quot;; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() { ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) { //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); } if (this.encoding != null) { messageSource.setDefaultEncoding(this.encoding.name()); } messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; }  3）、去页面获取国际化的值；\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot; xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html; charset=UTF-8\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1, shrink-to-fit=no\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;author\u0026quot; content=\u0026quot;\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Signin Template for Bootstrap\u0026lt;/title\u0026gt; \u0026lt;!-- Bootstrap core CSS --\u0026gt; \u0026lt;link href=\u0026quot;asserts/css/bootstrap.min.css\u0026quot; th:href=\u0026quot;@{/webjars/bootstrap/4.0.0/css/bootstrap.css}\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt; \u0026lt;!-- Custom styles for this template --\u0026gt; \u0026lt;link href=\u0026quot;asserts/css/signin.css\u0026quot; th:href=\u0026quot;@{/asserts/css/signin.css}\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026quot;text-center\u0026quot;\u0026gt; \u0026lt;form class=\u0026quot;form-signin\u0026quot; action=\u0026quot;dashboard.html\u0026quot;\u0026gt; \u0026lt;img class=\u0026quot;mb-4\u0026quot; th:src=\u0026quot;@{/asserts/img/bootstrap-solid.svg}\u0026quot; src=\u0026quot;asserts/img/bootstrap-solid.svg\u0026quot; alt=\u0026quot;\u0026quot; width=\u0026quot;72\u0026quot; height=\u0026quot;72\u0026quot;\u0026gt; \u0026lt;h1 class=\u0026quot;h3 mb-3 font-weight-normal\u0026quot; th:text=\u0026quot;#{login.tip}\u0026quot;\u0026gt;Please sign in\u0026lt;/h1\u0026gt; \u0026lt;label class=\u0026quot;sr-only\u0026quot; th:text=\u0026quot;#{login.username}\u0026quot;\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;Username\u0026quot; th:placeholder=\u0026quot;#{login.username}\u0026quot; required=\u0026quot;\u0026quot; autofocus=\u0026quot;\u0026quot;\u0026gt; \u0026lt;label class=\u0026quot;sr-only\u0026quot; th:text=\u0026quot;#{login.password}\u0026quot;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026quot;password\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;Password\u0026quot; th:placeholder=\u0026quot;#{login.password}\u0026quot; required=\u0026quot;\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;checkbox mb-3\u0026quot;\u0026gt; \u0026lt;label\u0026gt; \u0026lt;input type=\u0026quot;checkbox\u0026quot; value=\u0026quot;remember-me\u0026quot;/\u0026gt; [[#{login.remember}]] \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button class=\u0026quot;btn btn-lg btn-primary btn-block\u0026quot; type=\u0026quot;submit\u0026quot; th:text=\u0026quot;#{login.btn}\u0026quot;\u0026gt;Sign in\u0026lt;/button\u0026gt; \u0026lt;p class=\u0026quot;mt-5 mb-3 text-muted\u0026quot;\u0026gt;© 2017-2018\u0026lt;/p\u0026gt; \u0026lt;a class=\u0026quot;btn btn-sm\u0026quot;\u0026gt;中文\u0026lt;/a\u0026gt; \u0026lt;a class=\u0026quot;btn btn-sm\u0026quot;\u0026gt;English\u0026lt;/a\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  效果：根据浏览器语言设置的信息切换了国际化；\n原理：\n​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）；\n@Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = \u0026quot;spring.mvc\u0026quot;, name = \u0026quot;locale\u0026quot;) public LocaleResolver localeResolver() { if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) { return new FixedLocaleResolver(this.mvcProperties.getLocale()); } AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; } 默认的就是根据请求头带来的区域信息获取Locale进行国际化  4）、点击链接切换国际化\n/** * 可以在连接上携带区域信息 */ public class MyLocaleResolver implements LocaleResolver { @Override public Locale resolveLocale(HttpServletRequest request) { String l = request.getParameter(\u0026quot;l\u0026quot;); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l)){ String[] split = l.split(\u0026quot;_\u0026quot;); locale = new Locale(split[0],split[1]); } return locale; } @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) { } } @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); } }  3）、登陆 开发期间模板引擎页面修改以后，要实时生效\n1）、禁用模板引擎的缓存\n# 禁用缓存 spring.thymeleaf.cache=false  2）、页面修改完成以后ctrl+f9：重新编译；\n登陆错误消息的显示\n\u0026lt;p style=\u0026quot;color: red\u0026quot; th:text=\u0026quot;${msg}\u0026quot; th:if=\u0026quot;${not #strings.isEmpty(msg)}\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;  4）、拦截器进行登陆检查 拦截器\n/** * 登陆检查， */ public class LoginHandlerInterceptor implements HandlerInterceptor { //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Object user = request.getSession().getAttribute(\u0026quot;loginUser\u0026quot;); if(user == null){ //未登陆，返回登陆页面 request.setAttribute(\u0026quot;msg\u0026quot;,\u0026quot;没有权限请先登陆\u0026quot;); request.getRequestDispatcher(\u0026quot;/index.html\u0026quot;).forward(request,response); return false; }else{ //已登陆，放行请求 return true; } } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } }  注册拦截器\n//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){ WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\u0026quot;/\u0026quot;).setViewName(\u0026quot;login\u0026quot;); registry.addViewController(\u0026quot;/index.html\u0026quot;).setViewName(\u0026quot;login\u0026quot;); registry.addViewController(\u0026quot;/main.html\u0026quot;).setViewName(\u0026quot;dashboard\u0026quot;); } //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\u0026quot;/**\u0026quot;) .excludePathPatterns(\u0026quot;/index.html\u0026quot;,\u0026quot;/\u0026quot;,\u0026quot;/user/login\u0026quot;); } }; return adapter; }  5）、CRUD-员工列表 实验要求：\n1）、RestfulCRUD：CRUD满足Rest风格；\nURI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作\n    普通CRUD（uri来区分操作） RestfulCRUD     查询 getEmp emp\u0026mdash;GET   添加 addEmp?xxx emp\u0026mdash;POST   修改 updateEmp?id=xxx\u0026amp;xxx=xx emp/{id}\u0026mdash;PUT   删除 deleteEmp?id=1 emp/{id}\u0026mdash;DELETE    2）、实验的请求架构;\n   实验功能 请求URI 请求方式     查询所有员工 emps GET   查询某个员工(来到修改页面) emp/1 GET   来到添加页面 emp GET   添加员工 emp POST   来到修改页面（查出员工进行信息回显） emp/1 GET   修改员工 emp PUT   删除员工 emp/1 DELETE    3）、员工列表：\nthymeleaf公共页面元素抽取 1、抽取公共片段 \u0026lt;div th:fragment=\u0026quot;copy\u0026quot;\u0026gt; \u0026amp;copy; 2011 The Good Thymes Virtual Grocery \u0026lt;/div\u0026gt; 2、引入公共片段 \u0026lt;div th:insert=\u0026quot;~{footer :: copy}\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; ~{templatename::selector}：模板名::选择器 ~{templatename::fragmentname}:模板名::片段名 3、默认效果： insert的公共片段在div标签中 如果使用th:insert等属性进行引入，可以不用写~{}： 行内写法可以加上：[[~{}]];[(~{})]；  三种引入公共片段的th属性：\nth:insert：将公共片段整个插入到声明引入的元素中\nth:replace：将声明引入的元素替换为公共片段\nth:include：将被引入的片段的内容包含进这个标签中\n\u0026lt;footer th:fragment=\u0026quot;copy\u0026quot;\u0026gt; \u0026amp;copy; 2011 The Good Thymes Virtual Grocery \u0026lt;/footer\u0026gt; 引入方式 \u0026lt;div th:insert=\u0026quot;footer :: copy\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div th:replace=\u0026quot;footer :: copy\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div th:include=\u0026quot;footer :: copy\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 效果 \u0026lt;div\u0026gt; \u0026lt;footer\u0026gt; \u0026amp;copy; 2011 The Good Thymes Virtual Grocery \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;footer\u0026gt; \u0026amp;copy; 2011 The Good Thymes Virtual Grocery \u0026lt;/footer\u0026gt; \u0026lt;div\u0026gt; \u0026amp;copy; 2011 The Good Thymes Virtual Grocery \u0026lt;/div\u0026gt;  引入片段的时候传入参数：\n\u0026lt;nav class=\u0026quot;col-md-2 d-none d-md-block bg-light sidebar\u0026quot; id=\u0026quot;sidebar\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;sidebar-sticky\u0026quot;\u0026gt; \u0026lt;ul class=\u0026quot;nav flex-column\u0026quot;\u0026gt; \u0026lt;li class=\u0026quot;nav-item\u0026quot;\u0026gt; \u0026lt;a class=\u0026quot;nav-link active\u0026quot; th:class=\u0026quot;${activeUri=='main.html'?'nav-link active':'nav-link'}\u0026quot; href=\u0026quot;#\u0026quot; th:href=\u0026quot;@{/main.html}\u0026quot;\u0026gt; \u0026lt;svg xmlns=\u0026quot;http://www.w3.org/2000/svg\u0026quot; width=\u0026quot;24\u0026quot; height=\u0026quot;24\u0026quot; viewBox=\u0026quot;0 0 24 24\u0026quot; fill=\u0026quot;none\u0026quot; stroke=\u0026quot;currentColor\u0026quot; stroke-width=\u0026quot;2\u0026quot; stroke-linecap=\u0026quot;round\u0026quot; stroke-linejoin=\u0026quot;round\u0026quot; class=\u0026quot;feather feather-home\u0026quot;\u0026gt; \u0026lt;path d=\u0026quot;M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;polyline points=\u0026quot;9 22 9 12 15 12 15 22\u0026quot;\u0026gt;\u0026lt;/polyline\u0026gt; \u0026lt;/svg\u0026gt; Dashboard \u0026lt;span class=\u0026quot;sr-only\u0026quot;\u0026gt;(current)\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;!--引入侧边栏;传入参数--\u0026gt; \u0026lt;div th:replace=\u0026quot;commons/bar::#sidebar(activeUri='emps')\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;  6）、CRUD-员工添加 添加页面\n\u0026lt;form\u0026gt; \u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt; \u0026lt;label\u0026gt;LastName\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;zhangsan\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt; \u0026lt;label\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026quot;email\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;zhangsan@atguigu.com\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt; \u0026lt;label\u0026gt;Gender\u0026lt;/label\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;div class=\u0026quot;form-check form-check-inline\u0026quot;\u0026gt; \u0026lt;input class=\u0026quot;form-check-input\u0026quot; type=\u0026quot;radio\u0026quot; name=\u0026quot;gender\u0026quot; value=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;label class=\u0026quot;form-check-label\u0026quot;\u0026gt;男\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;form-check form-check-inline\u0026quot;\u0026gt; \u0026lt;input class=\u0026quot;form-check-input\u0026quot; type=\u0026quot;radio\u0026quot; name=\u0026quot;gender\u0026quot; value=\u0026quot;0\u0026quot;\u0026gt; \u0026lt;label class=\u0026quot;form-check-label\u0026quot;\u0026gt;女\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt; \u0026lt;label\u0026gt;department\u0026lt;/label\u0026gt; \u0026lt;select class=\u0026quot;form-control\u0026quot;\u0026gt; \u0026lt;option\u0026gt;1\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;2\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;3\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;4\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;5\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt; \u0026lt;label\u0026gt;Birth\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;zhangsan\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026quot;submit\u0026quot; class=\u0026quot;btn btn-primary\u0026quot;\u0026gt;添加\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt;  提交的数据格式不对：生日：日期；\n2017-12-12；2017/12/12；2017.12.12；\n日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型;\n2017-12-12\u0026mdash;Date； 类型转换，格式化;\n默认日期是按照/的方式；\n7）、CRUD-员工修改 修改添加二合一表单\n\u0026lt;!--需要区分是员工修改还是添加；--\u0026gt; \u0026lt;form th:action=\u0026quot;@{/emp}\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;!--发送put请求修改员工数据--\u0026gt; \u0026lt;!-- 1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的） 2、页面创建一个post表单 3、创建一个input项，name=\u0026quot;_method\u0026quot;;值就是我们指定的请求方式 --\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;_method\u0026quot; value=\u0026quot;put\u0026quot; th:if=\u0026quot;${emp!=null}\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;id\u0026quot; th:if=\u0026quot;${emp!=null}\u0026quot; th:value=\u0026quot;${emp.id}\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt; \u0026lt;label\u0026gt;LastName\u0026lt;/label\u0026gt; \u0026lt;input name=\u0026quot;lastName\u0026quot; type=\u0026quot;text\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;zhangsan\u0026quot; th:value=\u0026quot;${emp!=null}?${emp.lastName}\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt; \u0026lt;label\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;input name=\u0026quot;email\u0026quot; type=\u0026quot;email\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;zhangsan@atguigu.com\u0026quot; th:value=\u0026quot;${emp!=null}?${emp.email}\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt; \u0026lt;label\u0026gt;Gender\u0026lt;/label\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;div class=\u0026quot;form-check form-check-inline\u0026quot;\u0026gt; \u0026lt;input class=\u0026quot;form-check-input\u0026quot; type=\u0026quot;radio\u0026quot; name=\u0026quot;gender\u0026quot; value=\u0026quot;1\u0026quot; th:checked=\u0026quot;${emp!=null}?${emp.gender==1}\u0026quot;\u0026gt; \u0026lt;label class=\u0026quot;form-check-label\u0026quot;\u0026gt;男\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;form-check form-check-inline\u0026quot;\u0026gt; \u0026lt;input class=\u0026quot;form-check-input\u0026quot; type=\u0026quot;radio\u0026quot; name=\u0026quot;gender\u0026quot; value=\u0026quot;0\u0026quot; th:checked=\u0026quot;${emp!=null}?${emp.gender==0}\u0026quot;\u0026gt; \u0026lt;label class=\u0026quot;form-check-label\u0026quot;\u0026gt;女\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt; \u0026lt;label\u0026gt;department\u0026lt;/label\u0026gt; \u0026lt;!--提交的是部门的id--\u0026gt; \u0026lt;select class=\u0026quot;form-control\u0026quot; name=\u0026quot;department.id\u0026quot;\u0026gt; \u0026lt;option th:selected=\u0026quot;${emp!=null}?${dept.id == emp.department.id}\u0026quot; th:value=\u0026quot;${dept.id}\u0026quot; th:each=\u0026quot;dept:${depts}\u0026quot; th:text=\u0026quot;${dept.departmentName}\u0026quot;\u0026gt;1\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt; \u0026lt;label\u0026gt;Birth\u0026lt;/label\u0026gt; \u0026lt;input name=\u0026quot;birth\u0026quot; type=\u0026quot;text\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;zhangsan\u0026quot; th:value=\u0026quot;${emp!=null}?${#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')}\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026quot;submit\u0026quot; class=\u0026quot;btn btn-primary\u0026quot; th:text=\u0026quot;${emp!=null}?'修改':'添加'\u0026quot;\u0026gt;添加\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt;  8）、CRUD-员工删除 \u0026lt;tr th:each=\u0026quot;emp:${emps}\u0026quot;\u0026gt; \u0026lt;td th:text=\u0026quot;${emp.id}\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;[[${emp.lastName}]]\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026quot;${emp.email}\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026quot;${emp.gender}==0?'女':'男'\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026quot;${emp.department.departmentName}\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026quot;${#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')}\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a class=\u0026quot;btn btn-sm btn-primary\u0026quot; th:href=\u0026quot;@{/emp/}+${emp.id}\u0026quot;\u0026gt;编辑\u0026lt;/a\u0026gt; \u0026lt;button th:attr=\u0026quot;del_uri=@{/emp/}+${emp.id}\u0026quot; class=\u0026quot;btn btn-sm btn-danger deleteBtn\u0026quot;\u0026gt;删除\u0026lt;/button\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;script\u0026gt; $(\u0026quot;.deleteBtn\u0026quot;).click(function(){ //删除当前员工的 $(\u0026quot;#deleteEmpForm\u0026quot;).attr(\u0026quot;action\u0026quot;,$(this).attr(\u0026quot;del_uri\u0026quot;)).submit(); return false; }); \u0026lt;/script\u0026gt;  7、错误处理机制 1）、SpringBoot默认的错误处理机制 默认效果：\n​ 1）、浏览器，返回一个默认的错误页面\n浏览器发送请求的请求头：\n​ 2）、如果是其他客户端，默认响应一个json数据\n​ 原理：\n​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置；\n给容器中添加了以下组件  ​ 1、DefaultErrorAttributes：\n帮我们在页面共享信息； @Override public Map\u0026lt;String, Object\u0026gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) { Map\u0026lt;String, Object\u0026gt; errorAttributes = new LinkedHashMap\u0026lt;String, Object\u0026gt;(); errorAttributes.put(\u0026quot;timestamp\u0026quot;, new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; }  ​ 2、BasicErrorController：处理默认/error请求\n@Controller @RequestMapping(\u0026quot;${server.error.path:${error.path:/error}}\u0026quot;) public class BasicErrorController extends AbstractErrorController { @RequestMapping(produces = \u0026quot;text/html\u0026quot;)//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { HttpStatus status = getStatus(request); Map\u0026lt;String, Object\u0026gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(\u0026quot;error\u0026quot;, model) : modelAndView); } @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; error(HttpServletRequest request) { Map\u0026lt;String, Object\u0026gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt;(body, status); }  ​ 3、ErrorPageCustomizer：\n@Value(\u0026quot;${error.path:/error}\u0026quot;) private String path = \u0026quot;/error\u0026quot;; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则）  ​ 4、DefaultErrorViewResolver：\n@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map\u0026lt;String, Object\u0026gt; model) { ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null \u0026amp;\u0026amp; SERIES_VIEWS.containsKey(status.series())) { modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); } return modelAndView; } private ModelAndView resolve(String viewName, Map\u0026lt;String, Object\u0026gt; model) { //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = \u0026quot;error/\u0026quot; + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) { //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); } //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); }  ​ 步骤：\n​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理；\n​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的；\nprotected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map\u0026lt;String, Object\u0026gt; model) { //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) { ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) { return modelAndView; } } return null; }  2）、如果定制错误响应： 1）、如何定制错误的页面； ​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面；\n​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）；\n​ 页面能获取的信息；\n​ timestamp：时间戳\n​ status：状态码\n​ error：错误提示\n​ exception：异常对象\n​ message：异常消息\n​ errors：JSR303数据校验的错误都在这里\n​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找；\n​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面；\n2）、如何定制错误的json数据； ​ 1）、自定义异常处理\u0026amp;返回定制json数据；\n@ControllerAdvice public class MyExceptionHandler { @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map\u0026lt;String,Object\u0026gt; handleException(Exception e){ Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026quot;code\u0026quot;,\u0026quot;user.notexist\u0026quot;); map.put(\u0026quot;message\u0026quot;,e.getMessage()); return map; } } //没有自适应效果...  ​ 2）、转发到/error进行自适应响应效果处理\n@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request){ Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute(\u0026quot;javax.servlet.error.status_code\u0026quot;); */ request.setAttribute(\u0026quot;javax.servlet.error.status_code\u0026quot;,500); map.put(\u0026quot;code\u0026quot;,\u0026quot;user.notexist\u0026quot;); map.put(\u0026quot;message\u0026quot;,e.getMessage()); //转发到/error return \u0026quot;forward:/error\u0026quot;; }  3）、将我们的定制数据携带出去； 出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）；\n​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中；\n​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到；\n​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的；\n自定义ErrorAttributes\n//给容器中加入我们自己定义的ErrorAttributes @Component public class MyErrorAttributes extends DefaultErrorAttributes { @Override public Map\u0026lt;String, Object\u0026gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) { Map\u0026lt;String, Object\u0026gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(\u0026quot;company\u0026quot;,\u0026quot;atguigu\u0026quot;); return map; } }  最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容，\n8、配置嵌入式Servlet容器 SpringBoot默认使用Tomcat作为嵌入式的Servlet容器；\n问题？\n1）、如何定制和修改Servlet容器的相关配置； 1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）；\nserver.port=8081 server.context-path=/crud server.tomcat.uri-encoding=UTF-8 //通用的Servlet容器设置 server.xxx //Tomcat的设置 server.tomcat.xxx  2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置\n@Bean //一定要将这个定制器加入到容器中 public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){ return new EmbeddedServletContainerCustomizer() { //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setPort(8083); } }; }  2）、注册Servlet三大组件【Servlet、Filter、Listener】 由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。\n注册三大组件用以下方式\nServletRegistrationBean\n//注册三大组件 @Bean public ServletRegistrationBean myServlet(){ ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),\u0026quot;/myServlet\u0026quot;); return registrationBean; }  FilterRegistrationBean\n@Bean public FilterRegistrationBean myFilter(){ FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(\u0026quot;/hello\u0026quot;,\u0026quot;/myServlet\u0026quot;)); return registrationBean; }  ServletListenerRegistrationBean\n@Bean public ServletListenerRegistrationBean myListener(){ ServletListenerRegistrationBean\u0026lt;MyListener\u0026gt; registrationBean = new ServletListenerRegistrationBean\u0026lt;\u0026gt;(new MyListener()); return registrationBean; }  SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet；\nDispatcherServletAutoConfiguration中：\n@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME) @ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME) public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) { ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) { registration.setMultipartConfig(this.multipartConfig); } return registration; }  2）、SpringBoot能不能支持其他的Servlet容器；\n3）、替换为其他嵌入式Servlet容器 默认支持：\nTomcat（默认使用）\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器； \u0026lt;/dependency\u0026gt;  Jetty\n\u0026lt;!-- 引入web模块 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-tomcat\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--引入其他的Servlet容器--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jetty\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/dependency\u0026gt;  Undertow\n\u0026lt;!-- 引入web模块 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-tomcat\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--引入其他的Servlet容器--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-undertow\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/dependency\u0026gt;  4）、嵌入式Servlet容器自动配置原理； EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) @Configuration @ConditionalOnWebApplication @Import(BeanPostProcessorsRegistrar.class) //导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件 //导入了EmbeddedServletContainerCustomizerBeanPostProcessor： //后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作 public class EmbeddedServletContainerAutoConfiguration { @Configuration @ConditionalOnClass({ Servlet.class, Tomcat.class })//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat { @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() { return new TomcatEmbeddedServletContainerFactory(); } } /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass({ Servlet.class, Server.class, Loader.class, WebAppContext.class }) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty { @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() { return new JettyEmbeddedServletContainerFactory(); } } /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class }) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow { @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() { return new UndertowEmbeddedServletContainerFactory(); } }  1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）\npublic interface EmbeddedServletContainerFactory { //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers); }  2）、EmbeddedServletContainer：（嵌入式的Servlet容器）\n3）、以TomcatEmbeddedServletContainerFactory为例\n@Override public EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) { //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(\u0026quot;tomcat\u0026quot;)); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) { tomcat.getService().addConnector(additionalConnector); } prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat); }  4）、我们对嵌入式容器的配置修改是怎么生效？\nServerProperties、EmbeddedServletContainerCustomizer  EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？\n怎么修改的原理？\n5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor\n//初始化之前 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) { // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); } return bean; } private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) { //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) { customizer.customize(bean); } } private Collection\u0026lt;EmbeddedServletContainerCustomizer\u0026gt; getCustomizers() { if (this.customizers == null) { // Look up does not include the parent context this.customizers = new ArrayList\u0026lt;EmbeddedServletContainerCustomizer\u0026gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); } return this.customizers; } ServerProperties也是定制器  步骤：\n1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】\n2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；\n只要是嵌入式的Servlet容器工厂，后置处理器就工作；\n3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法\n###5）、嵌入式Servlet容器启动原理；\n什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；\n获取嵌入式的Servlet容器工厂：\n1）、SpringBoot应用启动运行run方法\n2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext\n3）、refresh(context);刷新刚才创建好的ioc容器；\npublic void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\u0026quot;Exception encountered during context initialization - \u0026quot; + \u0026quot;cancelling refresh attempt: \u0026quot; + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } }  4）、 onRefresh(); web的ioc容器重写了onRefresh方法\n5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer();\n6）、获取嵌入式的Servlet容器工厂：\nEmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();\n​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；\n7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer());\n8）、嵌入式的Servlet容器创建对象并启动Servlet容器；\n先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来；\n==IOC容器启动创建嵌入式的Servlet容器==\n9、使用外置的Servlet容器 嵌入式Servlet容器：应用打成可执行的jar\n​ 优点：简单、便携；\n​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）；\n外置的Servlet容器：外面安装Tomcat\u0026mdash;应用war包的方式打包；\n步骤 1）、必须创建一个war项目；（利用idea创建好目录结构）\n2）、将嵌入式的Tomcat指定为provided；\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-tomcat\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法\npublic class ServletInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); } }  4）、启动服务器就可以使用；\n原理 jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；\nwar包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器；\nservlet3.0（Spring注解版）：\n8.2.4 Shared libraries / runtimes pluggability：\n规则：\n​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例：\n​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名\n​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；\n流程：\n1）、启动Tomcat\n2）、org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer：\nSpring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer\n3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set\u0026gt;；为这些WebApplicationInitializer类型的类创建实例；\n4）、每一个WebApplicationInitializer都调用自己的onStartup；\n5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法\n6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器\nprotected WebApplicationContext createRootApplicationContext( ServletContext servletContext) { //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) { this.logger.info(\u0026quot;Root context already created (using as parent).\u0026quot;); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); } builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() \u0026amp;\u0026amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) { application.getSources().add(getClass()); } Assert.state(!application.getSources().isEmpty(), \u0026quot;No SpringApplication sources have been defined. Either override the \u0026quot; + \u0026quot;configure method or add an @Configuration annotation\u0026quot;); // Ensure error pages are registered if (this.registerErrorPageFilter) { application.getSources().add(ErrorPageFilterConfiguration.class); } //启动Spring应用 return run(application); }  7）、Spring的应用就启动并且创建IOC容器\npublic ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); } }  ==启动Servlet容器，再启动SpringBoot应用==\n五、Docker 1、简介 Docker是一个开源的应用容器引擎；是一个轻量级容器技术；\nDocker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；\n运行中的这个镜像称为容器，容器启动是非常快速的。\n2、核心概念 docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；\ndocker客户端(Client)：连接docker主机进行操作；\ndocker仓库(Registry)：用来保存各种打包好的软件镜像；\ndocker镜像(Images)：软件打包好的镜像；放在docker仓库中；\ndocker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用\n使用Docker的步骤：\n1）、安装Docker\n2）、去Docker仓库找到这个软件对应的镜像；\n3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；\n4）、对容器的启动停止就是对软件的启动停止；\n3、安装Docker 1）、安装linux虚拟机 ​ 1）、VMWare、VirtualBox（安装）；\n​ 2）、导入虚拟机文件centos7-atguigu.ova；\n​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆\n​ 4）、使用客户端连接linux服务器进行命令操作；\n​ 5）、设置虚拟机网络；\n​ 桥接网络===选好网卡====接入网线；\n​ 6）、设置好网络以后使用命令重启虚拟机的网络\nservice network restart  ​ 7）、查看linux的ip地址\nip addr  ​ 8）、使用客户端连接linux；\n2）、在linux虚拟机上安装docker 步骤：\n1、检查内核版本，必须是3.10及以上 uname -r 2、安装docker yum install docker 3、输入y确认安装 4、启动docker [root@localhost ~]# systemctl start docker [root@localhost ~]# docker -v Docker version 1.12.6, build 3e8e77d/1.12.6 5、开机启动docker [root@localhost ~]# systemctl enable docker Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. 6、停止docker systemctl stop docker  4、Docker常用命令\u0026amp;操作 1）、镜像操作    操作 命令 说明     检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。   拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest   列表 docker images 查看所有本地镜像   删除 docker rmi image-id 删除指定的本地镜像    https://hub.docker.com/\n2）、容器操作 软件镜像（QQ安装程序）\u0026mdash;-运行镜像\u0026mdash;-产生一个容器（正在运行的软件，运行的QQ）；\n步骤：\n1、搜索镜像 [root@localhost ~]# docker search tomcat 2、拉取镜像 [root@localhost ~]# docker pull tomcat 3、根据镜像启动容器 docker run --name mytomcat -d tomcat:latest 4、docker ps 查看运行中的容器 5、 停止运行中的容器 docker stop 容器的id 6、查看所有的容器 docker ps -a 7、启动容器 docker start 容器id 8、删除一个容器 docker rm 容器id 9、启动一个做了端口映射的tomcat [root@localhost ~]# docker run -d -p 8888:8080 tomcat -d：后台运行 -p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口 10、为了演示简单关闭了linux的防火墙 service firewalld status ；查看防火墙状态 service firewalld stop：关闭防火墙 11、查看容器的日志 docker logs container-name/container-id 更多命令参看 https://docs.docker.com/engine/reference/commandline/docker/ 可以参考每一个镜像的文档  3）、安装MySQL示例 docker pull mysql  错误的启动\n[root@localhost ~]# docker run --name mysql01 -d mysql 42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846 mysql退出了 [root@localhost ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 42f09819908b mysql \u0026quot;docker-entrypoint.sh\u0026quot; 34 seconds ago Exited (1) 33 seconds ago mysql01 538bde63e500 tomcat \u0026quot;catalina.sh run\u0026quot; About an hour ago Exited (143) About an hour ago compassionate_ goldstine c4f1ac60b3fc tomcat \u0026quot;catalina.sh run\u0026quot; About an hour ago Exited (143) About an hour ago lonely_fermi 81ec743a5271 tomcat \u0026quot;catalina.sh run\u0026quot; About an hour ago Exited (143) About an hour ago sick_ramanujan //错误日志 [root@localhost ~]# docker logs 42f09819908b error: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个  正确的启动\n[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql b874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f [root@localhost ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b874c56bec49 mysql \u0026quot;docker-entrypoint.sh\u0026quot; 4 seconds ago Up 3 seconds 3306/tcp mysql01  做了端口映射\n[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql ad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434 [root@localhost ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ad10e4bc5c6a mysql \u0026quot;docker-entrypoint.sh\u0026quot; 4 seconds ago Up 2 seconds 0.0.0.0:3306-\u0026gt;3306/tcp mysql02  几个其他的高级操作\ndocker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面 改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql） docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 指定mysql的一些配置参数  六、SpringBoot与数据访问 1、JDBC \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver  效果：\n​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；\n​ 数据源的相关配置都在DataSourceProperties里面；\n自动配置原理：\norg.springframework.boot.autoconfigure.jdbc：\n1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；\n2、SpringBoot默认可以支持；\norg.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、  3、自定义数据源类型\n/** * Generic DataSource configuration. */ @ConditionalOnMissingBean(DataSource.class) @ConditionalOnProperty(name = \u0026quot;spring.datasource.type\u0026quot;) static class Generic { @Bean public DataSource dataSource(DataSourceProperties properties) { //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); } }  4、DataSourceInitializer：ApplicationListener；\n​ 作用：\n​ 1）、runSchemaScripts();运行建表语句；\n​ 2）、runDataScripts();运行插入数据的sql语句；\n默认只需要将文件命名为：\nschema-*.sql、data-*.sql 默认规则：schema.sql，schema-all.sql； 可以使用 schema: - classpath:department.sql 指定位置  5、操作数据库：自动配置了JdbcTemplate操作数据库\n2、整合Druid数据源 导入druid数据源 @Configuration public class DruidConfig { @ConfigurationProperties(prefix = \u0026quot;spring.datasource\u0026quot;) @Bean public DataSource druid(){ return new DruidDataSource(); } //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet(){ ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \u0026quot;/druid/*\u0026quot;); Map\u0026lt;String,String\u0026gt; initParams = new HashMap\u0026lt;\u0026gt;(); initParams.put(\u0026quot;loginUsername\u0026quot;,\u0026quot;admin\u0026quot;); initParams.put(\u0026quot;loginPassword\u0026quot;,\u0026quot;123456\u0026quot;); initParams.put(\u0026quot;allow\u0026quot;,\u0026quot;\u0026quot;);//默认就是允许所有访问 initParams.put(\u0026quot;deny\u0026quot;,\u0026quot;192.168.15.21\u0026quot;); bean.setInitParameters(initParams); return bean; } //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter(){ FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map\u0026lt;String,String\u0026gt; initParams = new HashMap\u0026lt;\u0026gt;(); initParams.put(\u0026quot;exclusions\u0026quot;,\u0026quot;*.js,*.css,/druid/*\u0026quot;); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(\u0026quot;/*\u0026quot;)); return bean; } }  3、整合MyBatis \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  步骤：\n​ 1）、配置数据源相关属性（见上一节Druid）\n​ 2）、给数据库建表\n​ 3）、创建JavaBean\n4）、注解版 //指定这是一个操作数据库的mapper @Mapper public interface DepartmentMapper { @Select(\u0026quot;select * from department where id=#{id}\u0026quot;) public Department getDeptById(Integer id); @Delete(\u0026quot;delete from department where id=#{id}\u0026quot;) public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = \u0026quot;id\u0026quot;) @Insert(\u0026quot;insert into department(departmentName) values(#{departmentName})\u0026quot;) public int insertDept(Department department); @Update(\u0026quot;update department set departmentName=#{departmentName} where id=#{id}\u0026quot;) public int updateDept(Department department); }  问题：\n自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer；\n@org.springframework.context.annotation.Configuration public class MyBatisConfig { @Bean public ConfigurationCustomizer configurationCustomizer(){ return new ConfigurationCustomizer(){ @Override public void customize(Configuration configuration) { configuration.setMapUnderscoreToCamelCase(true); } }; } }  使用MapperScan批量扫描所有的Mapper接口； @MapperScan(value = \u0026quot;com.atguigu.springboot.mapper\u0026quot;) @SpringBootApplication public class SpringBoot06DataMybatisApplication { public static void main(String[] args) { SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); } }  5）、配置文件版 mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置  更多使用参照\nhttp://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/\n4、整合SpringData JPA 1）、SpringData简介 2）、整合SpringData JPA JPA:ORM（Object Relational Mapping）；\n1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；\n//使用JPA注解配置映射关系 @Entity //告诉JPA这是一个实体类（和数据表映射的类） @Table(name = \u0026quot;tbl_user\u0026quot;) //@Table来指定和哪个数据表对应;如果省略默认表名就是user； public class User { @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = \u0026quot;last_name\u0026quot;,length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email;  2）、编写一个Dao接口来操作实体类对应的数据表（Repository）\n//继承JpaRepository来完成对数据库的操作 public interface UserRepository extends JpaRepository\u0026lt;User,Integer\u0026gt; { }  3）、基本的配置JpaProperties\nspring: jpa: hibernate: # 更新或者创建数据表结构 ddl-auto: update # 控制台显示SQL show-sql: true  @RestController public class UserController { @Autowired UserRepository userRepository; @GetMapping(\u0026quot;/user/{id}\u0026quot;) public User getUser(@PathVariable(\u0026quot;id\u0026quot;) Integer id){ User user = userRepository.findOne(id); return user; } @GetMapping(\u0026quot;/user\u0026quot;) public User insertUser(User user){ User save = userRepository.save(user); return save; } }  七、启动配置原理 几个重要的事件回调机制\n配置在META-INF/spring.factories\nApplicationContextInitializer\nSpringApplicationRunListener\n只需要放在ioc容器中\nApplicationRunner\nCommandLineRunner\n启动流程：\n1、创建SpringApplication对象 initialize(sources); private void initialize(Object[] sources) { //保存主配置类 if (sources != null \u0026amp;\u0026amp; sources.length \u0026gt; 0) { this.sources.addAll(Arrays.asList(sources)); } //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass(); }  2、运行run方法 public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try { //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); } }  3、事件监听机制 配置在META-INF/spring.factories\nApplicationContextInitializer\npublic class HelloApplicationContextInitializer implements ApplicationContextInitializer\u0026lt;ConfigurableApplicationContext\u0026gt; { @Override public void initialize(ConfigurableApplicationContext applicationContext) { System.out.println(\u0026quot;ApplicationContextInitializer...initialize...\u0026quot;+applicationContext); } }  SpringApplicationRunListener\npublic class HelloSpringApplicationRunListener implements SpringApplicationRunListener { //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args){ } @Override public void starting() { System.out.println(\u0026quot;SpringApplicationRunListener...starting...\u0026quot;); } @Override public void environmentPrepared(ConfigurableEnvironment environment) { Object o = environment.getSystemProperties().get(\u0026quot;os.name\u0026quot;); System.out.println(\u0026quot;SpringApplicationRunListener...environmentPrepared..\u0026quot;+o); } @Override public void contextPrepared(ConfigurableApplicationContext context) { System.out.println(\u0026quot;SpringApplicationRunListener...contextPrepared...\u0026quot;); } @Override public void contextLoaded(ConfigurableApplicationContext context) { System.out.println(\u0026quot;SpringApplicationRunListener...contextLoaded...\u0026quot;); } @Override public void finished(ConfigurableApplicationContext context, Throwable exception) { System.out.println(\u0026quot;SpringApplicationRunListener...finished...\u0026quot;); } }  配置（META-INF/spring.factories）\norg.springframework.context.ApplicationContextInitializer=\\ com.atguigu.springboot.listener.HelloApplicationContextInitializer org.springframework.boot.SpringApplicationRunListener=\\ com.atguigu.springboot.listener.HelloSpringApplicationRunListener  只需要放在ioc容器中\nApplicationRunner\n@Component public class HelloApplicationRunner implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { System.out.println(\u0026quot;ApplicationRunner...run....\u0026quot;); } }  CommandLineRunner\n@Component public class HelloCommandLineRunner implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(\u0026quot;CommandLineRunner...run...\u0026quot;+ Arrays.asList(args)); } }  八、自定义starter starter：\n​ 1、这个场景需要使用到的依赖是什么？\n​ 2、如何编写自动配置\n@Configuration //指定这个类是一个配置类 @ConditionalOnXXX //在指定条件成立的情况下自动配置类生效 @AutoConfigureAfter //指定自动配置类的顺序 @Bean //给容器中添加组件 @ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置 @EnableConfigurationProperties //让xxxProperties生效加入到容器中 自动配置类要能加载 将需要启动就加载的自动配置类，配置在META-INF/spring.factories org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\  ​ 3、模式：\n启动器只用来做依赖导入；\n专门来写一个自动配置模块；\n启动器依赖自动配置；别人只需要引入启动器（starter）\nmybatis-spring-boot-starter；自定义启动器名-spring-boot-starter\n步骤：\n1）、启动器模块\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.atguigu.starter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;atguigu-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!--启动器--\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--引入自动配置模块--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.atguigu.starter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;atguigu-spring-boot-starter-autoconfigurer\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt;  2）、自动配置模块\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.atguigu.starter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;atguigu-spring-boot-starter-autoconfigurer\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;atguigu-spring-boot-starter-autoconfigurer\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.5.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--引入spring-boot-starter；所有starter的基本配置--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt;  package com.atguigu.starter; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(prefix = \u0026quot;atguigu.hello\u0026quot;) public class HelloProperties { private String prefix; private String suffix; public String getPrefix() { return prefix; } public void setPrefix(String prefix) { this.prefix = prefix; } public String getSuffix() { return suffix; } public void setSuffix(String suffix) { this.suffix = suffix; } }  package com.atguigu.starter; public class HelloService { HelloProperties helloProperties; public HelloProperties getHelloProperties() { return helloProperties; } public void setHelloProperties(HelloProperties helloProperties) { this.helloProperties = helloProperties; } public String sayHellAtguigu(String name){ return helloProperties.getPrefix()+\u0026quot;-\u0026quot; +name + helloProperties.getSuffix(); } }  package com.atguigu.starter; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration @ConditionalOnWebApplication //web应用才生效 @EnableConfigurationProperties(HelloProperties.class) public class HelloServiceAutoConfiguration { @Autowired HelloProperties helloProperties; @Bean public HelloService helloService(){ HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; } }  更多SpringBoot整合示例 https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples\n","id":42,"section":"posts","summary":"源码 一、Spring Boot 入门 1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式","tags":["Spring家族"],"title":"Spring Boot自学笔记-02","uri":"https://mumulx.github.io/2019/11/spring-boot%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" git源码\nSpringMVC 简介 Servlet发展史\nStruts1.x\u0026ndash;\u0026gt;Struts2.x\u0026ndash;\u0026gt;SpringMVC\nspringmvc:\n第一个SpringMVC程序 jar spring-aop.jar spring-bean.jar spring-context.jar spring-core.jar spring-web.jar spring-webmvc.jar commons-logging.jar  报错NoClassDefFoundError：缺少jar\nServet - Springmvc jsp -\u0026gt;Servlet (Springmvc)-\u0026gt;Jsp  url\nspringmvc配置文件 springmvc.xml 选中常用的命名空间：beans aop context mvc\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns:aop=\u0026quot;http://www.springframework.org/schema/aop\u0026quot; xmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot; xmlns:mvc=\u0026quot;http://www.springframework.org/schema/mvc\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\u0026quot;\u0026gt; \u0026lt;!-- 扫描 有注解的包 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;org.lanqiao.handler\u0026quot;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;!--配置视图解析器(InternalResourceViewResolver) 配置的prefix和suffix会给所有返回的地址加上前缀/views/加上后缀.jsp。 例return \u0026quot;success\u0026quot; 实际的结果为/views/success.jsp --\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;prefix\u0026quot; value=\u0026quot;/views/\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;suffix\u0026quot; value=\u0026quot;.jsp\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;  普通的servlet流程：\n请求-url-pattern -交给对应的servlet去处理\n如果现在想用springmvc，而不是普通的servlet，如何告知程序？-如何让springmvc 介入程序：\n需要配置一个 Springmvc自带的servlet\n通过以下配置，拦截所有请求，交给SpringMVC处理：web.xml\n\u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springDispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springDispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;  其中：\n\u0026lt;url-pattern\u0026gt;.action\u0026lt;/url-pattern\u0026gt; / :一切请求 ，注意不是 /* /user :拦截以 /user开头的请求 /user/abc.do :只拦截该请求 .action :只拦截 .action结尾的请求  通过\n\u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt;  指定springmvc配置文件的路径，如果要省略，必须放到 默认路径：\n/WEB-INF/springDispatcherServlet-servlet.xml  严格的来说是\n\u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springDispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springDispatcherServlet\u0026lt;/servlet-name\u0026gt; /WEB-INF/servetname的值-servlet.xml  请求\n\u0026lt;a href=\u0026quot;welcome\u0026quot;\u0026gt;first springmvc - welcome\u0026lt;/a\u0026gt;  servlet\n@RequestMapping(value=\u0026quot;welcome\u0026quot;,method=RequestMethod.POST,params= {\u0026quot;name=zs\u0026quot;,\u0026quot;age!=23\u0026quot;,\u0026quot;!height\u0026quot;})//映射 public String welcome() { return \u0026quot;success\u0026quot; ;// views/success.jsp }  项目中同时兼容 springMVC和Servlet\n\u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springDispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;.action\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;  @RequestMapping 映射是 去匹配@RequestMapping注解，可以和方法名、类名不一致，\n//接口/类 注解 配置 @Controller @RequestMapping(value=\u0026quot;handler\u0026quot;) //映射 public class SpringMVCHandler { @RequestMapping(value=\u0026quot;welcome\u0026quot;)//映射 public String welcome() { return \u0026quot;success\u0026quot; ; } }  默认值的属性为value\n@RequestMapping(value=\u0026quot;welcome\u0026quot;) @RequestMapping(\u0026quot;welcome\u0026quot;)  二者相等\n此时请求的路径为\nhandler/welcome  先去找类前面的，再去找方法前面的，默认使用了 请求转发的 跳转方式，地址栏的地址没有改变\nmethod\n通过method指定 请求方式（get post delete put）\n@RequestMapping(value=\u0026quot;welcome\u0026quot;,method=RequestMethod.POST)//映射  params\n参数值\nparams= {\u0026quot;name\u0026quot;}  请求参数值中一定要有name属性\nparams= {\u0026quot;name=zs\u0026quot;}  请求参数值中一定要有name属性，并且参数值一定是zs params= {\u0026ldquo;name=zs\u0026rdquo;,\u0026ldquo;age!=23\u0026rdquo;})\n name:必须有name=\u0026ldquo;zs\u0026rdquo;参数\n age!=23 :\n 如果有name=\u0026ldquo;age\u0026rdquo;，则age值不能是23 要么没有age\nparams= {\u0026quot;name=zs\u0026quot;,\u0026quot;age!=23\u0026quot;,\u0026quot;!height\u0026quot;})  请求参数中不能有height\n   headers\n请求头\nheaders= {\u0026quot;Accept=text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\u0026quot;,\u0026quot;Accept-Encoding=gzip, deflate\u0026quot;}  多个参数使用,隔开\nant风格的请求路径 ? 单字符 * 任意个字符（0或多个） ** 任意目录  @RequestMapping(value=\u0026quot;welcome3/a?c/test\u0026quot;)  接受示例：\n a href=\u0026quot;welcome3/axc/test\u0026quot; a href=\u0026quot;welcome3/ayc/test\u0026quot;  @RequestMapping(value=\u0026quot;welcome3/*/test\u0026quot;)  接受示例：\na href=\u0026quot;welcome3/abc/test\u0026quot; a href=\u0026quot;welcome3/xxx/test\u0026quot;  @RequestMapping(value=\u0026quot;welcome3/**/test\u0026quot;)  接受示例：\na href=\u0026quot;welcome3/abc/xyz/abccc/test\u0026quot; a href=\u0026quot;welcome3/xxx/xxx/xxx/test\u0026quot;  @PathVariable 通过@PathVariable获取动态参数\n传参\n\u0026lt;a href=\u0026quot;hander/welcome5/zs\u0026quot;\u0026gt;  zs为传递的值\n@RequestMapping(value=\u0026quot;welcome5/{name}\u0026quot;) public String welcome5(@PathVariable(\u0026quot;name\u0026quot;) String name ) { System.out.println(name); return \u0026quot;success\u0026quot; ; }  name的值为zs\nREST风格 ：软件编程风格 conf.xml快速生成配置文件\nctrl+/ 选择#dispatcherservlet  然后修改拦截请求，和配置文件的位置\nSpringmvc:\nGET :查 POST :增 DELETE :删 PUT :改  delete与put 普通浏览器 只支持get post方式 ；其他请求方式 如 delelte | put请求是通过过滤器（HiddenHttpMethodFilter）新加入的支持。\n过滤器拦截delelte|put请求的条件\n 请求方式为post\n 标签有隐藏域，并且隐藏域的name为_method,value为delete或put\n\u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;_method\u0026quot; value=\u0026quot;delete|put\u0026quot;\u0026gt;   springmvc实现 ：put|post请求方式的步骤 增加过滤器,web.xml\n\u0026lt;!-- 增加HiddenHttpMethodFilte过滤器：目的是给普通浏览器 增加 put|delete请求方式 --\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;HiddenHttpMethodFilte\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.HiddenHttpMethodFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;HiddenHttpMethodFilte\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;  delete 表单\n\u0026lt;form action=\u0026quot;handler/testRest/1234\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;_method\u0026quot; value=\u0026quot;DELETE\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;删\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  控制器\n@RequestMapping(value=\u0026quot;testRest/{id}\u0026quot;,method=RequestMethod.DELETE) public String testDelete(@PathVariable(\u0026quot;id\u0026quot;) Integer id) { System.out.println(\u0026quot;delete：删 \u0026quot; +id); return \u0026quot;success\u0026quot; ; }  put 表单\n\u0026lt;form action=\u0026quot;handler/testRest/1234\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;_method\u0026quot; value=\u0026quot;PUT\u0026quot;/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;改\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  控制器\n@RequestMapping(value=\u0026quot;testRest/{id}\u0026quot;,method=RequestMethod.PUT) public String testPut(@PathVariable(\u0026quot;id\u0026quot;) Integer id) { System.out.println(\u0026quot;put：改 \u0026quot;+id); return \u0026quot;success\u0026quot; ; }  get 表单\n\u0026lt;form action=\u0026quot;handler/testRest/1234\u0026quot; method=\u0026quot;get\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;查\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  控制器\n@RequestMapping(value=\u0026quot;testRest/{id}\u0026quot;,method=RequestMethod.GET) public String testGet(@PathVariable(\u0026quot;id\u0026quot;) Integer id) { System.out.println(\u0026quot;get：查 \u0026quot; +id); return \u0026quot;success\u0026quot; ; }  post 表单\n\u0026lt;form action=\u0026quot;handler/testRest/1234\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;增\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  控制器\n@RequestMapping(value=\u0026quot;testRest/{id}\u0026quot;,method=RequestMethod.POST) public String testPost(@PathVariable(\u0026quot;id\u0026quot;) Integer id) { System.out.println(\u0026quot;post：增 \u0026quot; +id); return \u0026quot;success\u0026quot; ; }  通过method=RequestMethod.DELETE匹配具体的请求方式\n此外，可以发现 ，当映射名相同时即@RequestMapping(value=\u0026quot;testRest)相同，可以通过method处理不同的请求。\n处理delete|put的源码分析 过滤器中 处理put|delete请求的部分源码：\nprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)throws ServletException, IOException { HttpServletRequest requestToUse = request; if (\u0026quot;POST\u0026quot;.equals(request.getMethod()) \u0026amp;\u0026amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) { String paramValue = request.getParameter(this.methodParam); if (StringUtils.hasLength(paramValue)) { requestToUse = new HttpMethodRequestWrapper(request, paramValue); } } filterChain.doFilter(requestToUse, response); }  原始请求：request，改请求默认只支持get\\ post \\ header]\n但是如果 是\u0026rdquo;POST\u0026rdquo; 并且有隐藏域\n\u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;_method\u0026quot; value=\u0026quot;DELETE\u0026quot;/\u0026gt;  则，过滤器 将原始的请求 request加入新的请求方式DELETE，并将原始请求 转为 requestToUse 请求（request+Delete请求）\n最后将requestToUse 放入 请求链中， 后续再事情request时 实际就使用改造后的 requestToUse\n普通传值 表单\n\u0026lt;form action=\u0026quot;handler/testParam\u0026quot; method=\u0026quot;get\u0026quot;\u0026gt; name:\u0026lt;input name=\u0026quot;uname\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;查\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  控制器\n@RequestMapping(value=\u0026quot;testParam\u0026quot;) public String testParam(@RequestParam(\u0026quot;uname\u0026quot;) String name) { String name = request.getParameter(\u0026quot;uname\u0026quot;); System.out.println(name); return \u0026quot;success\u0026quot; ; }  前台传多个参数值，后台可以接收其中几个值，但是不可以接收多的值，即后台接收的的值，前台一定要发送；前台发送的值，后台可以不接收\n@RequestParam(\u0026quot;uname\u0026quot;) String name,@RequestParam(value=\u0026quot;uage\u0026quot;,required=false,defaultValue=\u0026quot;23\u0026quot;)  设置默认值，不传的时候为23\n@RequestParam(\u0026quot;uname\u0026quot;)  接受前台传递的值，等价于\nrequest.getParameter(\u0026quot;uname\u0026quot;);  required=false:该属性 不是必须的。 defaultValue=\u0026quot;23\u0026quot;：默认值23  获取请求头信息 @RequestHeader \u0026lt;a href=\u0026quot;handler/testRequestHeader\u0026quot;\u0026gt;testRequestHeader\u0026lt;/a\u0026gt;  public String testRequestHeader(@RequestHeader(\u0026quot;Accept-Language\u0026quot;) String al ) {}  通过@RequestHeader(\u0026quot;Accept-Language\u0026quot;) String al 获取请求头中的Accept-Language值，并将值保存再al变量中\n通过mvc获取cookie值（JSESSIONID） @CookieValue (前置知识： 服务端在接受客户端第一次请求时，会给该客户端分配一个session （该session包含一个sessionId）),并且服务端会在第一次响应客户端时 ，将该sessionId赋值给JSESSIONID 并传递给客户端的cookie中\n\u0026lt;a href=\u0026quot;handler/testCookieValue\u0026quot;\u0026gt;testCookieValue\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt;  @RequestMapping(value=\u0026quot;testRequestHeader\u0026quot;) public String testRequestHeader(@RequestHeader(\u0026quot;Accept-Language\u0026quot;) String al ) { System.out.println( al); return \u0026quot;success\u0026quot; ; }  小结：\nSpringMVC处理各种参数的流程/逻辑：\n请求： 前端发请求a-\u0026gt; @RequestMappting(\u0026ldquo;a\u0026rdquo;)\n处理请求中的参数xyz：\n@RequestMappting(\u0026quot;a\u0026quot;) public String aa(@Xxx注解(\u0026quot;xyz\u0026quot;) xyz) { }  使用对象（实体类Student）接受请求参数 public class Student { private int id; private String name; private Address address ; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } }  public class Address { private String homeAddress ; private String schoolAddress ; public String getHomeAddress() { return homeAddress; } public void setHomeAddress(String homeAddress) { this.homeAddress = homeAddress; } public String getSchoolAddress() { return schoolAddress; } public void setSchoolAddress(String schoolAddress) { this.schoolAddress = schoolAddress; } }  \u0026lt;form action=\u0026quot;handler/testObjectProperties\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; id:\u0026lt;input name=\u0026quot;id\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; name:\u0026lt;input name=\u0026quot;name\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; 家庭地址:\u0026lt;input name=\u0026quot;address.homeAddress\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; 学校地址:\u0026lt;input name=\u0026quot;address.schoolAddress\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;查\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  @RequestMapping(value=\u0026quot;testObjectProperties\u0026quot;) public String testObjectProperties(Student student) {//student属性 必须 和 form表单中的属性Name值一致（支持级联属性） /* 以前的方式 String name = request.getParameter(\u0026quot;name\u0026quot;); int age= Integer.parseInt(request.getParameter(\u0026quot;age\u0026quot;)s)\t; String haddrss = request.getParameter(\u0026quot;homeaddress\u0026quot;); String saddress = request.getParameter(\u0026quot;schooladdress\u0026quot;); Address address = new Address(); address.setHomeAddress(haddrss); address.setSchoolAddress(saddress); Student student = new Student(); student.setName(name); student.setAddress(address); */\tSystem.out.println(student.getId()+\u0026quot;,\u0026quot;+student.getName()+\u0026quot;,\u0026quot;+student.getAddress().getHomeAddress()+\u0026quot;,\u0026quot;+student.getAddress().getSchoolAddress()); return \u0026quot;success\u0026quot; ; }  @InitBinder注解 参考博客\n实现参数绑定\n\u0026lt;form action=\u0026quot;/testBean\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; name: \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;u.name\u0026quot;\u0026gt; \u0026lt;br\u0026gt; age: \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;u.age\u0026quot;\u0026gt; \u0026lt;br\u0026gt; name: \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;s.name\u0026quot;\u0026gt; \u0026lt;br\u0026gt; age: \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;s.age\u0026quot;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  @InitBinder(\u0026quot;user\u0026quot;) public void init1(WebDataBinder binder) { binder.setFieldDefaultPrefix(\u0026quot;u.\u0026quot;); } @InitBinder(\u0026quot;stu\u0026quot;) public void init2(WebDataBinder binder) { binder.setFieldDefaultPrefix(\u0026quot;s.\u0026quot;); } @RequestMapping(\u0026quot;/testBean\u0026quot;) public ModelAndView testBean(User user, @ModelAttribute(\u0026quot;stu\u0026quot;) Student stu) { System.out.println(stu); System.out.println(user); String viewName = \u0026quot;success\u0026quot;; ModelAndView modelAndView = new ModelAndView(viewName); modelAndView.addObject(\u0026quot;user\u0026quot;, user); modelAndView.addObject(\u0026quot;student\u0026quot;, stu); return modelAndView; } }  @InitBinder(\u0026ldquo;user\u0026rdquo;)括号内的参数为类的首字母小写(默认命名规则),也可以用@ModelAttribute(\u0026ldquo;stu\u0026rdquo;)做限定.\n在SpringMVC中使用原生态的Servlet API HttpServletRequest ,HttpServletResponse\n\u0026lt;a href=\u0026quot;handler/testServletAPI\u0026quot;\u0026gt;testServletAPI\u0026lt;/a\u0026gt;  @RequestMapping(value=\u0026quot;testServletAPI\u0026quot;) public String testServletAPI(HttpServletRequest request,HttpServletResponse response) { //\trequest.getParameter(\u0026quot;uname\u0026quot;) ; System.out.println(request); return \u0026quot;success\u0026quot; ; }  直接将 servlet-api中的类、接口等 写在springMVC所映射的方法参数中即可：\n处理模型数据 如果跳转时需要带数据：V、M,则可以使用以下方式：\nModelAndView、ModelMap 、Map、Model -数据放在了request作用域 @SessionAttributes、@ModelAttribute  ModelAndView \u0026lt;a href=\u0026quot;handler/testModelAndView\u0026quot;\u0026gt;testModelAndView\u0026lt;/a\u0026gt;  @RequestMapping(value=\u0026quot;testModelAndView\u0026quot;) public ModelAndView testModelAndView() { //ModelAndView:既有数据，又有视图 //ModelAndView:Model -M View-V ModelAndView mv = new ModelAndView(\u0026quot;success\u0026quot;);//view: views/success.jsp,仍然会加前缀和后缀 Student student = new Student() ; student.setId(2); student.setName(\u0026quot;zs\u0026quot;); mv.addObject(\u0026quot;student\u0026quot;, student);//相当于request.setAttribute(\u0026quot;student\u0026quot;, student); return mv; }  取值\n${requestScope.student.id } -${requestScope.student.name } \u0026lt;br/\u0026gt;  ModelMap \u0026lt;a href=\u0026quot;handler/testModelMap\u0026quot;\u0026gt;testModelMap\u0026lt;/a\u0026gt;  @RequestMapping(value=\u0026quot;testModelMap\u0026quot;) public String testModelMap(ModelMap mm) { Student student = new Student() ; student.setId(2); student.setName(\u0026quot;zs\u0026quot;); mm.put(\u0026quot;student2\u0026quot;, student);//request域 return \u0026quot;success\u0026quot;; //view }  ${requestScope.student2.id } -${requestScope.student2.name } \u0026lt;br/\u0026gt;  Map \u0026lt;a href=\u0026quot;handler/testMap\u0026quot;\u0026gt;testMap\u0026lt;/a\u0026gt;  @RequestMapping(value=\u0026quot;testMap\u0026quot;) public String testMap(Map\u0026lt;String,Object\u0026gt; m) { Student student = new Student() ; student.setId(2); student.setName(\u0026quot;zs\u0026quot;); m.put(\u0026quot;student3\u0026quot;, student);//request域 return \u0026quot;success\u0026quot;; }  ${requestScope.student3.id } -${requestScope.student3.name }  Model \u0026lt;a href=\u0026quot;handler/testModel\u0026quot;\u0026gt;testModel  @RequestMapping(value=\u0026quot;testModel\u0026quot;) public String testModel(Model model) { Student student = new Student() ; student.setId(2); student.setName(\u0026quot;zs\u0026quot;); model.addAttribute(\u0026quot;student4\u0026quot;,student);//request域 return \u0026quot;success\u0026quot;; }  ${requestScope.student4.id } -${requestScope.student4.name }  会将x对象 放入request域中\n如何将上述数据放入session中 加上注解\n@SessionAttributes(..)  在Handlee类前加注解\n@SessionAttributes(value=\u0026quot;student4\u0026quot;)  如果要在request中存放student4对象，则同时将该对象 放入session域中\n@SessionAttributes(types= {Student.class,Address.class})  如果要在request中存放Student类型的对象，则同时将该类型对象放入session域中\n@ModelAttribute  经常在 更新时使用 在不改变原有代码的基础之上，插入一个新方法。\n\u0026lt;form action=\u0026quot;handler/testModelAttribute\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 编号:\u0026lt;input name=\u0026quot;id\u0026quot; type=\u0026quot;hidden\u0026quot; value=\u0026quot;31\u0026quot; /\u0026gt; 姓名:\u0026lt;input name=\u0026quot;name\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;修改\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  @ModelAttribute//在任何一次请求前，都会先执行@ModelAttribute修饰的方法 //@ModelAttribute 在请求 该类的各个方法前 均被执行的设计是基于一个思想：一个控制器 只做一个功能 public void queryStudentById(Map\u0026lt;String,Object\u0026gt; map) { //StuentService stuService = new StudentServiceImpl(); //Student student = stuService.queryStudentById(31); //模拟调用三层查询数据库的操作 Student student = new Student(); student.setId(31); student.setName(\u0026quot;zs\u0026quot;); student.setAge(23); //map.put(\u0026quot;student\u0026quot;, student) ;//约定：map的key 就是方法参数 类型的首字母小写 map.put(\u0026quot;stu\u0026quot;, student) ;//约定：map的key 就是方法参数 类型的首字母小写 }  //修改:Zs-ls @RequestMapping(value=\u0026quot;testModelAttribute\u0026quot;) public String testModelAttribute(@ModelAttribute(\u0026quot;stu\u0026quot;)Student student) { student.setName(student.getName());//将名字修改为ls System.out.println(student.getId()+\u0026quot;,\u0026quot;+student.getName()+\u0026quot;,\u0026quot;+student.getAge()); return \u0026quot;success\u0026quot;; }   通过@ModelAttribute修饰的方法 ，会在每次请求前先执行； 并且该方法的参数map.put()可以将 对象 放入 即将查询的参数中；\n必须满足的约定： map.put(k,v) 其中的k 必须是即将查询的方法参数的首字母小写\n//map.put(\u0026quot;student\u0026quot;, student) ; public String testModelAttribute(Student student)  如果不一致，需要通过@ModelAttribute声明。\nmap.put(\u0026quot;stu\u0026quot;, student); public String testModelAttribute(@ModelAttribute(\u0026quot;stu\u0026quot;)Student student) {  一个Servlet 对应一个功能：\n增删改查 对应于 4个Servlet\n@ModelAttribute会在 该类的每个方法执行前 均被执行一次，因为使用时需要注意。\n视图、视图解析器 流程\nController返回值\u0026ndash;\u0026gt;ModeAndView\u0026ndash;\u0026gt;ViewResolver(视图解析器)\u0026ndash;\u0026gt;视图view（渲染）（Jsp/PDF/Excel）\n视图的顶级接口:\nView  视图解析器顶级接口：\nViewResolver  常见的视图和解析器：\nInternalResourceView、InternalResourceViewResolver  public class JstlView extends InternalResourceView：\nspringMVC解析jsp时 会默认使用InternalResourceView，如果发现Jsp中包含了jstl语言相关的内容，则自动转为JstlView。\nJstlView： 可以解析jstl\\实现国际化操作\n国际化： 针对不同地区、不同国家 ，进行不同的显示\n中国: 欢迎 美国： welcome  具体实现国际化步骤：  创建资源文件\n基名_语言_地区.properties 基名_语言.properties  中国\ni18n_zh_CH.properties\nresource.welcome=你好 resource.exist=退出  i18n_en_US.properties\nresource.welcome=WELCOME resource.exist=EXIST  i18n.properties\nxxx  系统会先查询i18n_zh_CH.properties文件中的内容，如果其他文件中没有设置一些属性的值，则在i18n.properties中寻找\n文件中存放的是ASCLL值，如果输入时，没有进行转化，可以使用jdk中的工具：\ncd到jdk安装位置/bin native2ascii.exe回车 输入要转化的值 回车  然后将转换后的值放入文件中\ni18n:internationalization的首末字符i和n，18为中间的字符数\n 配置springmvc.xml，加载资源文件\n\u0026lt;!-- 加载国际化资源文件 --\u0026gt; \u0026lt;bean id=\u0026quot;messageSource\u0026quot; class=\u0026quot;org.springframework.context.support.ResourceBundleMessageSource\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;basename\u0026quot; value=\u0026quot;i18n\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  ResourceBundleMessageSource会在springmvc响应程序时 介入（解析国际化资源文件）\nspringmvc在启动时，会自动查找一个id=\u0026ldquo;messageSource\u0026rdquo;的bean，如果有 则自动加载\n 通过jstl使用国际化\njar\njstl.jar standar.jar  导入命名空间success.jsp\n\u0026lt;%@ taglib uri=\u0026quot;http://java.sun.com/jsp/jstl/core\u0026quot; prefix=\u0026quot;fmt\u0026quot; %\u0026gt;  使用\n\u0026lt;fmt:message key=\u0026quot;resources.welcome\u0026quot;\u0026gt;\u0026lt;/fmt:message\u0026gt; \u0026lt;fmt:message key=\u0026quot;resources.exit\u0026quot;\u0026gt;\u0026lt;/fmt:message\u0026gt;  ResourceBundleMessageSource:在MVC响应时介入，因此不能直接访问success.jsp，需要响应请求后访问\n\u0026lt;a href=\u0026quot;handler/testI18n\u0026quot;\u0026gt;testI18n\u0026lt;/a\u0026gt;  @RequestMapping(value=\u0026quot;testI18n\u0026quot;) public String testI18n() { return \u0026quot;success\u0026quot;; }   InternalResourceViewResolver其他功能： \u0026lt;mvc:view-controller ...\u0026gt; index.jsp -\u0026gt; Controller(@RequsetMapping(\u0026quot;a\u0026quot;)) -\u0026gt;succes.jsp  要用SpringMVC实现：index.jsp -\u0026gt; succes.jsp ：\n\u0026lt;a href=\u0026quot;handler/testMvcViewController\u0026quot;\u0026gt;testMvcViewController\u0026lt;/a\u0026gt;  配置，springMVC.xml\n\u0026lt;!--view-name会被视图解析器 加上前缀、后缀 --\u0026gt; \u0026lt;mvc:view-controller path=\u0026quot;handler/testMvcViewController\u0026quot; view-name=\u0026quot;success\u0026quot;/\u0026gt;  以上注解 ，会让所有的请求 转入\u0026lt;mvc:..\u0026gt;标签中匹配映射地址，而会忽略调@RequsetMapping()；(controller)\n如果想让 @RequsetMapping(\u0026ldquo;a\u0026rdquo;) 和\u0026lt;mvc:..\u0026gt;共存，则需要加入一个注解：\n\u0026lt;!--此配置是SpringMVC的基础配置，很功能都需要通过该注解来协调 --\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt;  ​\t指定请求方式 指定跳转方式： 请求转发：地址栏不改变\nreturn \u0026quot;forward:/views/success.jsp\u0026quot;;  重定向：地址栏改变 return \u0026ldquo;redirect:/views/success.jsp\u0026rdquo;;\nforward: redirect: ，需要注意 此种方式，不会被视图解析器加上前缀(/views)、后缀(.jsp)\n处理静态资源： html css js 图片 视频  动态（百度：天气 ）：可以与用户交互、因为时间/地点的不同 而结果不同的内容\n在SpringMVC中，如果直接访问静态资源：404 。\n原因：之前将所有的请求 通过通配符/拦截，进而交给 SPringMVC的入口DispatcherServlet去处理：找该请求映射对应的 @requestMapping\nhttp://localhost:8888/SpringMVCProject/img.png\n@RequsetMapping(\u0026quot;img.png\u0026quot;) return sucess  解决：如果是 需要mvc处理的，则交给@RequsetMapping(\u0026ldquo;img.png\u0026rdquo;)处理；如果不需要springmvc处理，则使用 tomcat默认的Servlet去处理。\ntomcat默认的Servlet去处理：如果有 对应的请求拦截,则交给相应的Servlet去处理；如果没有对应的servlet，则直接访问。\ntomcat默认的Servlet在哪里？\n在tomcat配置文件\\conf\\web.xml中\n解决静态资源方案：如果有springmvc对应的@requestMapping则交给spring处理；如果没有对应@requestMapping,则交给服务器tomcat默认的servlet去处理 ：\n实现方法，只需要增加2个注解即可 springmvc.xml：\n\u0026lt;!-- 该注解 会让 springmvc： 接收一个请求，并且该请求 没有对应的@requestmapping时，将该请求 交给服务器默认的servlet去处理（直接访问） --\u0026gt; \u0026lt;mvc:default-servlet-handler\u0026gt;\u0026lt;/mvc:default-servlet-handler\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt;  总结：要让springmvc访问静态资源，只需要加入以下2个注解：\n\u0026lt;mvc:default-servlet-handler\u0026gt;\u0026lt;/mvc:default-servlet-handler\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt;  类型转换 Spring自带一些 常见的类型转换器 public String testDelete(@PathVariable(\u0026quot;id\u0026quot;) String id)  既可以接受int类型数据id 也可以接受String类型的id\n可以自定义类型转换器  编写 自定义类型转器的类 （实现Converter接口）\n//将字符串变成Student public class MyConverter implements Converter\u0026lt;String,Student\u0026gt;{ @Override public Student convert(String source) {//source:2-zs-23 //source接受前端传来的String:2-zs-23 String[] studentStrArr = source.split(\u0026quot;-\u0026quot;) ; Student student = new Student(); student.setId( Integer.parseInt( studentStrArr[0]) ); student.setName(studentStrArr[1]); student.setAge(Integer.parseInt(studentStrArr[2] )); return student; } }  配置：将MyConverter加入到springmvc中\n 将 自定义转换器 纳入SpringIOC容器\n\u0026lt;!-- 1将 自定义转换器 纳入SpringIOC容器 --\u0026gt; \u0026lt;bean id=\u0026quot;myConverter\u0026quot; class=\u0026quot;org.lanqiao.converter.MyConverter\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt;  将myConverter再纳入 SpringMVC提供的转换器Bean\n\u0026lt;!-- 2将myConverter再纳入 SpringMVC提供的转换器Bean --\u0026gt; \u0026lt;bean id=\u0026quot;conversionService\u0026quot; class=\u0026quot;org.springframework.context.support.ConversionServiceFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;converters\u0026quot;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;ref bean=\u0026quot;myConverter\u0026quot;/\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  将conversionService注册到annotation-driven中\n\u0026lt;!-- 3将conversionService注册到annotation-driven中 --\u0026gt; \u0026lt;!--此配置是SpringMVC的基础配置，很功能都需要通过该注解来协调 --\u0026gt; \u0026lt;mvc:annotation-driven conversion-service=\u0026quot;conversionService\u0026quot;\u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt;    测试转换器：\n\u0026lt;form action=\u0026quot;handler/testConverter\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 学生信息:\u0026lt;input name=\u0026quot;studentInfo\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt;\u0026lt;!-- 2-zs-23 --\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;转换\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  @RequestMapping(value=\u0026quot;testConverter\u0026quot;) public String testConverter(@RequestParam(\u0026quot;studentInfo\u0026quot;) Student student) {// 前端：2-zs-23 System.out.println(student.getId()+\u0026quot;,\u0026quot;+student.getName()+\u0026quot;,\u0026quot;+student.getAge()); return \u0026quot;success\u0026quot;; }  其中@RequestParam(\u0026quot;studentInfo\u0026quot;)是触发转换器的桥梁： @RequestParam(\u0026quot;studentInfo\u0026quot;)接收的数据 是前端传递过来的：2-zs-23 ，但是需要将该数据赋值给修饰的目的对象Student；因此SPringMVC可以发现 接收的数据 和目标数据不一致，并且 这两种数据分别是 String、Student,正好符合public Student convert(String source)转换器。因此将类型进行转换\n数据格式化 主要用于对数字和日期的转换\nSimpleDateForamt sdf = new SimpleDateFormat(\u0026quot;yyyy-MM-dd hh:mm:ss\u0026quot;);  SPringMVC提供了很多注解，方便我们数据格式化\n@DateTimeFormat(pattern=\u0026quot;yyyy-MM-dd\u0026quot;) @NumberFormat(parttern=\u0026quot;###,#\u0026quot;)  实现步骤： 1. 配置,springMVC.xml xml \u0026lt;!-- 配置 数据格式化 注解 所依赖的bean --\u0026gt; \u0026lt;bean id=\u0026quot;conversionService\u0026quot; class=\u0026quot;org.springframework.format.support.FormattingConversionServiceFactoryBean\u0026quot;\u0026gt; \u0026lt;/bean\u0026gt;  2. 通过注解使用\nStudent.java ```java @DateTimeFormat(pattern=\u0026quot;yyyy-MM-dd\u0026quot;) private Date birthday ;// 2018-12-13 @NumberFormat(pattern=\u0026quot;###,#\u0026quot;)  \tprivate int id; ``` 格式化：前台传递来的数据，将前台传递来到数据 固定为yyyy-MM-dd\n当输入格式不正确时会报错  测试\n\u0026lt;form action=\u0026quot;handler/testDateTimeFormat\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 编号:\u0026lt;input name=\u0026quot;id\u0026quot; type=\u0026quot;text\u0026quot; value=\u0026quot;31\u0026quot; /\u0026gt; 姓名:\u0026lt;input name=\u0026quot;name\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; 出生日期:\u0026lt;input name=\u0026quot;birthday\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;修改\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  @RequestMapping(value=\u0026quot;testDateTimeFormat\u0026quot;) //如果Student格式化出错，会将错误信息 传入result中，这样控制台会显示错误信息，但是前端不显示了，类似异常处理，将异常进行了处理 public String testDateTimeFormat(Student student , BindingResult result) { System.out.println(student.getId()+\u0026quot;,\u0026quot;+student.getName()+\u0026quot;,\u0026quot;+student.getBirthday()); if(result.getErrorCount() \u0026gt;0) { for(FieldError error: result.getFieldErrors() ) { System.out.println(error.getDefaultMessage()); } } return \u0026quot;success\u0026quot;; }  在配置时发现格式化和类型转换所用到的类为\nFormattingConversionServiceFactoryBean ConversionServiceFactoryBean  因此可以将类型转化在格式化中配置，即FormattingConversionServiceFactoryBean:既可以实现格式化、又可以实现类型转换\n由\n\u0026lt;!-- \u0026lt;bean id=\u0026quot;conversionService\u0026quot; class=\u0026quot;org.springframework.context.support.ConversionServiceFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;converters\u0026quot;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;ref bean=\u0026quot;myConverter\u0026quot;/\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; --\u0026gt;  整合到\n\u0026lt;bean id=\u0026quot;conversionService\u0026quot; class=\u0026quot;org.springframework.format.support.FormattingConversionServiceFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;converters\u0026quot;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;ref bean=\u0026quot;myConverter\u0026quot;/\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  错误消息： 上面我们可知，发生异常时在控制台打印后就不在页面打印了，此时想要两处都提示：\n思路：将异常信息传到前端页面中即可\n@RequestMapping(value=\u0026quot;testDateTimeFormat\u0026quot;)//如果Student格式化出错，会将错误信息 传入result中 public String testDateTimeFormat(@Valid Student student, BindingResult result ,Map\u0026lt;String,Object\u0026gt; map) { //System.out.println(student.getId()+\u0026quot;,\u0026quot;+student.getName()+\u0026quot;,\u0026quot;+student.getBirthday()); if(result.getErrorCount() \u0026gt;0) { for(FieldError error: result.getFieldErrors() ) { System.out.println(error.getDefaultMessage()); map.put(\u0026quot;errors\u0026quot;, result.getFieldErrors() ) ;//将错误信息传入requset域中的errors中 // result.getFieldErrors().get(0).getDefaultMessage() } } return \u0026quot;success\u0026quot;; }  \u0026lt;c:forEach items=\u0026quot;${requestScope.errors}\u0026quot; var=\u0026quot;error\u0026quot;\u0026gt; ${error.getDefaultMessage()}\u0026lt;br/\u0026gt; \u0026lt;/c:forEach\u0026gt;  取值时使用了jstl表达式，因此需要配置\njar包\njstl.jar standaed.jar  引入jstl标签库xx.jsp\n\u0026lt;%@ taglib uri=\u0026quot;http://java.sun.com/jsp/jstl/core\u0026quot; prefix=\u0026quot;c\u0026quot; %\u0026gt;  public String testDateTimeFormat(Student student, BindingResult result ,Map\u0026lt;String,Object\u0026gt; map) {}  需要验证的数据是 Student中的birthday, SPringMVC要求 如果校验失败 则将错误信息 自动放入 该对象之后紧挨着的\tBindingResult中。即Student student, BindingResult result之间 不能有其他参数。\n如果要将控制台的错误消息 传到jsp中显示，则可以将 错误消息对象放入request域中，然后 在jsp中 从request中获取。\n数据校验 \tJSR303\nHibernate Validator Hibernate Validator 是JSR 303的扩展。Hibernate Validator 提供了 JSR 303中所有内置的注解，以及自身扩展的4个注解\n使用Hibernate Validator步骤：\njar （注意各个jar之间可能存在版本不兼容）\nhibernate-validator-5.0.0.CR2.jar classmate-0.8.0.jar jboss-logging-3.1.1.GA.jar validation-api-1.1.0.CR1.jar hibernate-validator-annotation-processor-5.0.0.CR2.jar  配置springMVC.xml \u0026lt;mvc:annotation-driven \u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt;  此时mvc:annotation-driven的作用：要实现Hibernate Validator/JSR303 校验（或者其他各种校验），必须实现SpringMVC提供的一个接口：ValidatorFactory\nspringMVC已经帮我们写了一个ValidatorFactory的实现类LocalValidatorFactoryBean\n\u0026lt;mvc:annotation-driven \u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt;会在springmvc容器中 自动加载一个LocalValidatorFactoryBean类，因此可以直接实现数据校验。\n直接使用注解  在属性前加注解\npublic class Student { @Past//当前时间以前 private Date birthday ; } ``` 2. 在校验的Controller中 ，给校验的对象前增加 @Valid  java public String testDateTimeFormat(@Valid Student student, BindingResult result ,Map map) {}\n ## Ajax请求SpringMVC，并且返回JSON格式的数据 jar jackson-annotations-2.8.9.jar jackson-core-2.8.9.jar jackson-databind-2.8.9.jar ajax请求  html\n   $(document).ready(function(){ $(\u0026ldquo;#testJson\u0026rdquo;).click(function(){ //通过ajax请求springmvc $.post( \u0026ldquo;handler/testJson\u0026rdquo;,//服务器地址 //{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;zs\u0026rdquo;,\u0026ldquo;age\u0026rdquo;:23} function(result){//服务端处理完毕后的回调函数 List students， 加上@ResponseBody后， students实质是一个json数组的格式 for(var i=0;i\u0026lt;result.length ;i++){ alert(result[i].id +\u0026ldquo;-\u0026rdquo;+result[i].name +\u0026ldquo;-\u0026rdquo;+result[i].age); } } ); }); });\n java @ResponseBody//告诉SpringMVC，此时的返回 不是一个 View页面，而是一个 ajax调用的返回值（Json数组） @RequestMapping(value=\u0026ldquo;testJson\u0026rdquo;) public List testJson() { //Controller-Service-dao //StudentService studentService = new StudentServiceImp(); //List students = studentService.qeuryAllStudent(); //模拟调用service的查询操作 Student stu1 = new Student(1,\u0026ldquo;zs\u0026rdquo;,23); Student stu2 = new Student(2,\u0026ldquo;ls\u0026rdquo;,24); Student stu3 = new Student(3,\u0026ldquo;ww\u0026rdquo;,25); List students = new ArrayList\u0026lt;\u0026gt;(); students.add(stu1) ; students.add(stu2) ; students.add(stu3) ; return students; }\n ## SpringMVC实现文件上传 和Servlet方式的本质一样，都是通过 commons-fileupload.jar和commons-io.jar SpringMVC可以简化文件上传的代码，但是必须满足条件：实现`MultipartResolver`接口 ；而该接口的实现类SpringMVC也已经提供了`CommonsMultipartResolver` 具体步骤：（直接使用`CommonsMultipartResolver`实现上传） 1. jar包 commons-fileupload.jar、commons-io.jar 2. 配置`CommonsMultipartResolver` 将其加入SpringIOC容器 ```xml \u0026lt;bean id=\u0026quot;multipartResolver\u0026quot; class=\u0026quot;org.springframework.web.multipart.commons.CommonsMultipartResolver\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;defaultEncoding\u0026quot; value=\u0026quot;UTF-8\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 上传单个文件的最大值，单位Byte;如果-1，表示无限制 --\u0026gt; \u0026lt;property name=\u0026quot;maxUploadSize\u0026quot; value=\u0026quot;104857600\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; ``` 配置`CommonsMultipartResolver`，用于实现文件上传 将其加入SpringIOC容器. springIoc容器在初始化时，会自动寻找一个`Id=\u0026quot;multipartResolver\u0026quot;`的bean，并将其加入Ioc容器 1. 处理方法 ```html \u0026lt;form action=\u0026quot;handler/testUpload\u0026quot; method=\u0026quot;post\u0026quot; enctype=\u0026quot;multipart/form-data\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;file\u0026quot; /\u0026gt; 描述:\u0026lt;input name=\u0026quot;desc\u0026quot; type=\u0026quot;text\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;上传\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; ``` ```java //文件上传处理方法 @RequestMapping(value=\u0026quot;testUpload\u0026quot;) //abc.png public String testUpload(@RequestParam(\u0026quot;desc\u0026quot;) String desc , @RequestParam(\u0026quot;file\u0026quot;) MultipartFile file ) throws IOException { System.out.println(\u0026quot;文件描述信息：\u0026quot;+desc); //jsp中上传的文件：file InputStream input = file.getInputStream() ;//IO String fileName = file.getOriginalFilename() ; OutputStream out = new FileOutputStream(\u0026quot;d:\\\\\u0026quot;+fileName) ; byte[] bs = new byte[1024]; int len = -1; while(( len = input.read(bs)) !=-1 ) { out.write(bs, 0, len); } out.close(); input.close(); //将file上传到服务器中的 某一个硬盘文件中 System.out.println(\u0026quot;上传成功！\u0026quot;); return \u0026quot;success\u0026quot;; } ``` 框架： 将原来自己写的1000行代码，变成：框架帮你写900行，剩下100行自己写 控制器：handler servlet controller action ## 拦截器 ![拦截器](/resources/技术框架/Spring家族/拦截器.png \u0026quot;拦截器\u0026quot;) 拦截器的原理和过滤器相同。 SpringMVC：要想实现拦截器，必须实现一个接口 HandlerInterceptor 1. 编写拦截器 implements HandlerInterceptor 拦截器一 ```java public class MyInterceptor implements HandlerInterceptor{ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026quot;拦截请求\u0026quot;); // return true;//true:拦截操作之后，放行 ；false:拦截之后不放行，请求终止； } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026quot;拦截响应\u0026quot;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026quot;视图(jsp)被渲染完毕\u0026quot;); } } ``` 拦截器二 ```java public class MySecondInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026quot;第二个拦截器，拦截请求...22222\u0026quot;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026quot;第二个拦截器，拦截响应...22222\u0026quot;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026quot;第二个拦截器，afterCompletion\u0026quot;); } } ``` 1. 配置 将自己写的拦截器 配置到springmvc中（spring） ```xml \u0026lt;!-- 将自己写的拦截器 配置到springmvc中（spring）；默认拦截全部请求 --\u0026gt; \u0026lt;mvc:interceptors\u0026gt; \u0026lt;!--拦截一切请求时放在这 \u0026lt;bean class=\u0026quot;org.lanqiao.interceptor.MySecondInterceptor\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; --\u0026gt; \u0026lt;!-- 配置具体的拦截路径,二者取交集 --\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;!-- 指定拦截的路径,基于ant风格 --\u0026gt; \u0026lt;mvc:mapping path=\u0026quot;/**\u0026quot;/\u0026gt; \u0026lt;!-- 指定拦不截的路径 --\u0026gt; \u0026lt;mvc:exclude-mapping path=\u0026quot;/handler/testUpload\u0026quot;/\u0026gt; \u0026lt;bean class=\u0026quot;org.lanqiao.interceptor.MyInterceptor\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;!-- 配置具体的拦截路径 --\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;!-- 指定拦截的路径,基于ant风格 --\u0026gt; \u0026lt;mvc:mapping path=\u0026quot;/**\u0026quot;/\u0026gt; \u0026lt;!-- 指定拦不截的路径 --\u0026gt; \u0026lt;mvc:exclude-mapping path=\u0026quot;/handler/testUpload\u0026quot;/\u0026gt; \u0026lt;bean class=\u0026quot;org.lanqiao.interceptor.MySecondInterceptor\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt; ``` 拦截器1拦截请求- 拦截器2拦截请求 - 请求方法 - 拦截器2处理相应-拦截器1处理相应- 只会被 最后一个拦截器的afterCompletion()拦截 如果有多个拦截器，则每个拦截器的`preHandle` `postHandle` 都会在相应时机各被触发一次；但是`afterCompletion`， 只会执行最后一个拦截器的该方法。 ## 异常处理 SpringMVC实现异常处理的顶级接口 HandlerExceptionResolver 该接口的每个实现类 都是异常的一种处理方式： #### ExceptionHandlerExceptionResolver 主要提供了`@ExceptionHandler`注解，并通过该注解处理异常 controller中出现异常  java @RequestMapping(\u0026ldquo;testExceptionHandler\u0026rdquo;) public String testExceptionHandler() { //try { System.out.println( 1\u0026frasl;0 );// //}catch(ArithmeticException e) e //}catch(Exception e) e return \u0026ldquo;success\u0026rdquo; ; }\ncontroller中定义捕获异常的方法  java //该方法 可以捕获本类中 抛出的ArithmeticException异常,并返回error页面，将错误信息传递给error页面 @ExceptionHandler({ArithmeticException.class}) public ModelAndView handlerArithmeticException(ArithmeticException e) { ModelAndView mv = new ModelAndView(\u0026ldquo;error\u0026rdquo;); System.out.println(e +\u0026ldquo;============\u0026rdquo;); mv.addObject(\u0026ldquo;er\u0026rdquo;, e) ; return mv; }\nerror获取异常信息  ${requesrScope.e}\n数组越界异常  java @RequestMapping(\u0026ldquo;testExceptionHandler2\u0026rdquo;) public String testExceptionHandler2() { int[] nums = new int[2]; System.out.println(nums[2]);//ArrayIndexOutOfBoundsException return \u0026ldquo;success\u0026rdquo; ; }\n java //该方法 可以捕获本类中 抛出的ArithmeticException异常 @ExceptionHandler({ArithmeticException.class,ArrayIndexOutOfBoundsException.class}) public ModelAndView handlerArithmeticException(Exception e) { ModelAndView mv = new ModelAndView(\u0026ldquo;error\u0026rdquo;); System.out.println(e +\u0026ldquo;============\u0026rdquo;); mv.addObject(\u0026ldquo;er\u0026rdquo;, e) ; return mv; }\n`@ExceptionHandler`标识的方法的参数 必须在异常类型(Throwable或其子类) ，不能包含其他类型的参数 异常处理路径：最短优先 如果有方法抛出一个ArithmeticException异常，而该类中 有2个对应的异常处理方法：  java @ExceptionHandler({Exception.class }) public ModelAndView handlerArithmeticException2(Exception e) {}\n@ExceptionHandler({ArithmeticException.class }) public ModelAndView handlerArithmeticException1(Exception e) {}\n 则优先级： 最短优先。 @ExceptionHandler默认只能捕获 当前类中的异常方法。 如果发生异常的方法 和处理异常的方法 不在同一个类中：@ControllerAdvice  java //@ControllerAdvice public class MyExceptionHandler {//不是控制器，仅仅是 用于处理异常的类\n将处理异常的方法放到该类中  java @ExceptionHandler({Exception.class }) public ModelAndView handlerArithmeticException2(Exception e) { ModelAndView mv = new ModelAndView(\u0026ldquo;error\u0026rdquo;); System.out.println(e +\u0026ldquo;============\u0026rdquo;+\u0026ldquo;该@ControllerAdvice中的异常处理方法，可以处理任何类中的异常\u0026rdquo;); mv.addObject(\u0026ldquo;er\u0026rdquo;, e) ; return mv; } }\n总结：如果一个方法用于处理异常，并且只处理当前类中的异常：`@ExceptionHandler` 如果一个方法用于处理异常，并且处理所有类中的异常： 类前加`@ControllerAdvice`、 处理异常的方法前加`@ExceptionHandler` #### ResponseStatusExceptionResolver 自定义异常显示页面` @ResponseStatus`  java @ResponseStatus(value=HttpStatus.FORBIDDEN,reason=\u0026ldquo;数组越界222!!!\u0026rdquo;) public class MyArrayIndexOutofBoundsException extends Exception {//自定义异常 }\n java @RequestMapping(\u0026ldquo;testMyException\u0026rdquo;) public String testMyException(@RequestParam(\u0026ldquo;i\u0026rdquo;) Integer i) throws MyArrayIndexOutofBoundsException { if(i == 3) { throw new MyArrayIndexOutofBoundsException();//抛出异常 } return \u0026ldquo;success\u0026rdquo; ; }\n@ResponseStatus也可以标志在方法前：  java @RequestMapping(\u0026ldquo;testMyException2\u0026rdquo;) public String testMyException2(@RequestParam(\u0026ldquo;i\u0026rdquo;) Integer i) { if(i == 3) { return \u0026ldquo;redirect:testResponseStatus\u0026rdquo; ;//跳转到某一个 异常处理方法里 } return \u0026ldquo;success\u0026rdquo; ; } @ResponseStatus(value=HttpStatus.CONFLICT ,reason=\u0026ldquo;测试。。。\u0026rdquo;) @RequestMapping(\u0026ldquo;testResponseStatus\u0026rdquo;) public String testResponseStatus() { return \u0026ldquo;success\u0026rdquo; ; }\n #### DefaultHandlerExceptionResolver SPringMVC在一些常见异常的基础上（300 500 405），新增了一些异常，例如： * @see org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler * @see #handleNoSuchRequestHandlingMethod * @see #handleHttpRequestMethodNotSupported ：如果springmvc的处理方法限制为post方式，如果实际请求为get,则会触发此异常显示的页面 * @see #handleHttpMediaTypeNotSupported * @see #handleMissingServletRequestParameter * @see #handleServletRequestBindingException * @see #handleTypeMismatch * @see #handleHttpMessageNotReadable * @see #handleHttpMessageNotWritable * @see #handleMethodArgumentNotValidException * @see #handleMissingServletRequestParameter * @see #handleMissingServletRequestPartException * @see #handleBindException #### SimpleMappingExceptionResolver 通过配置来实现异常的处理  java @RequestMapping(value=\u0026ldquo;testSimpleMappingExceptionResolver\u0026rdquo;) public String testSimpleMappingExceptionResolver() { System.out.println(1\u0026frasl;0); return \u0026ldquo;success\u0026rdquo; ; }\n xml --  error  error    \n ${requestScope.exception}\n ## 表单标签: 启动tomcat报错：  Caused by: java.lang.IllegalArgumentException: More than one fragment with the name [spring_web] was found. This is not legal with relative ordering. See section 8.2.2 2c of the Servlet specification for details.\n需要在web.xml添加标签 \u0026lt;absolute-ordering/\u0026gt; 自定义标签el/ jstl Spring EL : 1. 支持各种类型的请求方式(查询doGet增 加doPost、删除doDelete 、修改doPut) 2. 可以将对象和表单绑定起来；对象的属性--表单path值 一一对应 #### IDEA开发springmvc SpringMVC项目: 选择Springmvc:自动下载springmvc相关的jar 处理Jar :artifacts - fix : miss all... 开发代码: #### 引入标签库  jsp \u0026lt;%@ taglib prefix=\u0026ldquo;form\u0026rdquo; uri=\u0026ldquo;http://www.springframework.org/tags/form\u0026quot; %\u0026gt;\n #### 使用： 类  java\npublic class Persion { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } }\n表单  html form:form 姓名：年龄：/form:form\n控制器  java @Controller @RequestMapping(\u0026ldquo;/FormDemo\u0026rdquo;) public class FormDemo { public String testForm(Map map){ Persion per = new Persion(); per.setAge(23); per.setName(\u0026ldquo;zs\u0026rdquo;); map.put(\u0026ldquo;command\u0026rdquo;, per);//将per放入了request域中的command中 return \u0026ldquo;forward:/views/springForm.jsp\u0026rdquo;; } }\n`\u0026lt;form id=\u0026quot;command\u0026quot;\u0026gt;`:SpringMVC标签会默认自动从名为\u0026quot;command\u0026quot;的对象中获取值，因此传值时将值放入command中 如果在map.put()时，名字不是command，则需要手工指定  html 或  则传值时 map.put(\u0026quot;person\u0026quot;, per);//将per放入了request #### 各种表单的提交方式 1. 编写method属性 ```html \u0026lt;form:form action=\u0026quot;FormDemo/testMethod\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;增加\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt; \u0026lt;form:form action=\u0026quot;FormDemo/testMethod\u0026quot; method=\u0026quot;delete\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;删除\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt; \u0026lt;form:form action=\u0026quot;FormDemo/testMethod\u0026quot; method=\u0026quot;put\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;修改\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt; \u0026lt;form:form action=\u0026quot;FormDemo/testMethod\u0026quot; method=\u0026quot;get\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;查询\u0026quot;\u0026gt; \u0026lt;/form:form\u0026gt; ``` ```java @RequestMapping(value = \u0026quot;/testMethod\u0026quot;,method = RequestMethod.POST) public String testPost(){ System.out.println(\u0026quot;post\u0026quot;); return \u0026quot;/index.jsp\u0026quot;; } @RequestMapping(value = \u0026quot;/testMethod\u0026quot;,method = RequestMethod.DELETE) public String testDelete(){ System.out.println(\u0026quot;delete\u0026quot;); return \u0026quot;/index.jsp\u0026quot;; } @RequestMapping(value = \u0026quot;/testMethod\u0026quot;,method =RequestMethod.PUT) public String testPut(){ System.out.println(\u0026quot;put\u0026quot;); return \u0026quot;/index.jsp\u0026quot;; } @RequestMapping(value = \u0026quot;/testMethod\u0026quot;,method = RequestMethod.GET) public String testGet(){ System.out.println(\u0026quot;get\u0026quot;); return \u0026quot;/index.jsp\u0026quot;; } ``` 2. 配置过滤器 ```xml \u0026lt;!--增加过滤器 支持delete和put请求--\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;HiddenHttpMethodFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.HiddenHttpMethodFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;HiddenHttpMethodFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; ``` HiddenHttpMethodFilter会将全部请求中名为\u0026quot;method\u0026quot;的隐藏域进行Put|Delete处理 可以配置  xml  HiddenHttpMethodFilter org.springframework.web.filter.HiddenHttpMethodFilter  methodParam myMethod  \n指定要处理的隐藏的名字  html \n 如果是使用的是SpringMvc标签： method=\u0026quot;put|delete\u0026quot; 如果不是SpringMVC标签，是传统的htnl标签 method=\u0026quot;post\u0026quot; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;myMethod\u0026quot; value=\u0026quot;delete|put\u0026quot;\u0026gt; #### checkbox 自动绑定request域中的值 1. 通过boolean值绑定  java @RequestMapping(\u0026ldquo;/testForm2\u0026rdquo;) public String testForm2(Map map){ Persion per = new Persion(); //per.setAge(23); //per.setName(\u0026ldquo;zs\u0026rdquo;); per.setSex(false); map.put(\u0026ldquo;per\u0026rdquo;, per); return \u0026ldquo;springForm\u0026rdquo;; //return \u0026ldquo;forward:/views/springForm.jsp\u0026rdquo;; }\n html /form:form\n绑定集合（有值的打上勾）  java @RequestMapping(\u0026ldquo;/testForm3\u0026rdquo;) public String testForm3(Map map){ Persion per = new Persion(); List hobbirs=new ArrayList\u0026lt;\u0026gt;(); hobbirs.add(\u0026ldquo;football\u0026rdquo;); hobbirs.add(\u0026ldquo;basketball\u0026rdquo;); per.setHobbies(hobbirs); map.put(\u0026ldquo;per\u0026rdquo;, per);//将per放入了request域中 return \u0026ldquo;springForm\u0026rdquo;; }\n html /form:checkbox /form:checkbox /form:checkbox /form:form\n(了解）嵌套对象的toString（）返回值  java @RequestMapping(\u0026ldquo;/testForm4\u0026rdquo;) public String testForm4(Map map){ Persion per = new Persion(); Other other = new Other(); per.setOther(other); map.put(\u0026ldquo;per\u0026rdquo;, per);//将per放入了request域中 return \u0026ldquo;springForm\u0026rdquo;; }\n html /form:checkbox /form:checkbox /form:checkbox /form:form\n java public class Other { @Override public String toString() { return \u0026ldquo;pingpang\u0026rdquo;; } }\n path:选中的选项（选中） item:所有的选项 a,b ,c d：如果是list，set，数组，则标签名默认就是选项值，如果想自定义标签名需要使用map  java @RequestMapping(\u0026ldquo;/testForm5\u0026rdquo;) public String testForm5(Map map){\nPersion per = new Persion(); List\u0026lt;String\u0026gt; hobbies=new ArrayList\u0026lt;\u0026gt;(); hobbies.add(\u0026quot;football\u0026quot;); hobbies.add(\u0026quot;basketball\u0026quot;); per.setHobbies(hobbies); map.put(\u0026quot;per\u0026quot;, per);//将per放入了request域中 List\u0026lt;String\u0026gt; allHobbies=new ArrayList\u0026lt;\u0026gt;(); allHobbies.add(\u0026quot;football\u0026quot;); allHobbies.add(\u0026quot;basketball\u0026quot;); allHobbies.add(\u0026quot;pingpang\u0026quot;); allHobbies.add(\u0026quot;aaa\u0026quot;); allHobbies.add(\u0026quot;bbb\u0026quot;); map.put(\u0026quot;allHobbies\u0026quot;, allHobbies); return \u0026quot;springForm\u0026quot;;  }\n html /form:form\n加载所有的选项allHobbies并且选中选中的hobbies 指定标签名 可以通过 `Map\u0026lt;Value值，标签名\u0026gt;`  java MapallHobbiesMap = new HashMap\u0026lt;\u0026gt;(); allHobbiesMap.put(\u0026ldquo;football\u0026rdquo;,\u0026ldquo;足球\u0026rdquo;); allHobbiesMap.put(\u0026ldquo;basketball\u0026rdquo;,\u0026ldquo;篮球\u0026rdquo;); allHobbiesMap.put(\u0026ldquo;pingpang\u0026rdquo;,\u0026ldquo;乒乓球\u0026rdquo;); allHobbiesMap.put(\u0026ldquo;aaa\u0026rdquo;,\u0026ldquo;bbb\u0026rdquo;); map.put(\u0026ldquo;allHobbies\u0026rdquo;, allHobbiesMap);\n #### 单选按钮  java @RequestMapping(\u0026ldquo;/testForm6\u0026rdquo;) public String testForm6(Map map){ Persion per = new Persion(); per.setCountry(\u0026ldquo;China\u0026rdquo;); map.put(\u0026ldquo;per\u0026rdquo;, per);//将per放入了request域中 return \u0026ldquo;springForm\u0026rdquo;; }\n html 中国：美国：/form:form\n一批  java @RequestMapping(\u0026ldquo;/testForm7\u0026rdquo;) public String testForm7(Map map){ Persion per = new Persion(); per.setFavouriteBall(\u0026ldquo;pingpang\u0026rdquo;); map.put(\u0026ldquo;per\u0026rdquo;, per);//将per放入了request域中 MapallHobbiesMap = new HashMap\u0026lt;\u0026gt;(); allHobbiesMap.put(\u0026ldquo;football\u0026rdquo;,\u0026ldquo;足球\u0026rdquo;); allHobbiesMap.put(\u0026ldquo;basketball\u0026rdquo;,\u0026ldquo;篮球\u0026rdquo;); allHobbiesMap.put(\u0026ldquo;pingpang\u0026rdquo;,\u0026ldquo;乒乓球\u0026rdquo;); allHobbiesMap.put(\u0026ldquo;aaa\u0026rdquo;,\u0026ldquo;bbb\u0026rdquo;); map.put(\u0026ldquo;allBallMap\u0026rdquo;, allHobbiesMap); return \u0026ldquo;springForm\u0026rdquo;; }\n  /form:form\n属性`delimiter`可以指定选项与选项之间的分隔符 \u0026lt;form:radiobuttons path=\u0026quot;favouriteBall\u0026quot; items=\u0026quot;${allBallMap}\u0026quot; delimiter=\u0026quot;、\u0026quot;/\u0026gt; #### select 写法一  html /form:form\n写法二：指定选定的值，选项是自己写的，后端不传所有的选项只传favouriteBall  html 足球11/form:option 篮球11/form:option 乒乓球11/form:option bbb11/form:option /form:select /form:form\n写法三  html /form:options \u0026lt;%\u0026ndash; 足球11/form:option 篮球11/form:option 乒乓球11/form:option bbb11/form:option\u0026ndash;%\u0026gt; /form:select /form:form\n java @RequestMapping(\u0026ldquo;/testForm7\u0026rdquo;) public String testForm7(Map map){ Persion per = new Persion(); per.setFavouriteBall(\u0026ldquo;pingpang\u0026rdquo;); map.put(\u0026ldquo;per\u0026rdquo;, per);//将per放入了request域中 MapallHobbiesMap = new HashMap\u0026lt;\u0026gt;(); allHobbiesMap.put(\u0026ldquo;football\u0026rdquo;,\u0026ldquo;足球\u0026rdquo;); allHobbiesMap.put(\u0026ldquo;basketball\u0026rdquo;,\u0026ldquo;篮球\u0026rdquo;); allHobbiesMap.put(\u0026ldquo;pingpang\u0026rdquo;,\u0026ldquo;乒乓球\u0026rdquo;); allHobbiesMap.put(\u0026ldquo;aaa\u0026rdquo;,\u0026ldquo;bbb\u0026rdquo;); map.put(\u0026ldquo;allBallMap\u0026rdquo;, allHobbiesMap); return \u0026ldquo;springForm\u0026rdquo;; } ``` 如果方式三和方式二同时存在则会优先选择方式二\n如果方式一和方式二同时存在则会优先选择一\n如果普通方式和springmvc方式同时存在则会使用springmvc的方式，普通的option没有匹配的功能。\ngit源码\n","id":43,"section":"posts","summary":"git源码 SpringMVC 简介 Servlet发展史 Struts1.x\u0026ndash;\u0026gt;Struts2.x\u0026ndash;\u0026gt;SpringMVC springmvc: 第一个SpringMVC程序 jar spring-aop.jar spring-bean.jar spring-context.jar spring-core.jar spring-web.jar spring-webmvc.jar commons-logging.jar 报错NoClassDefFoundError：缺少jar","tags":["Spring家族"],"title":"SpringMVC自学笔记","uri":"https://mumulx.github.io/2019/11/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" spring spring简介 2002 Rod Johnon 发布\u0026lt;Expoer One-on-one j2eedevelopment and Design\u0026gt;\n2003产生Spring，Spring两大核心IOC(DI)、Aop\nSpring data, spring boot, spring cloud, spring framework ，spring social\nIOC :控制反转 (DI:依赖注入) Inversion of control\ngit源码\n搭建Spring环境 jar包 下载jar\n使用spring-framework-4.3.9.RELEASE-dist.zip\n开发spring至少需要使用的jar(5个+1个):\nspring-aop.jar 开发AOP特性时需要的JAR spring-beans.jar 处理Bean的jar \u0026lt;bean\u0026gt; spring-context.jar 处理spring_上下文的jar\u0026lt;context\u0026gt; spring-core.jarspring 核心jar spring-expression.jar spring表达式 三方提供的日志jar commons-logging.jar 日志  xxx.jar二进制文件 xxx-javadoc.jar说明文档 xxx-sources.jar源码java文件\n编写配置文件 为了编写时有一些提示、自动生成些配置信息:\n 方式一:增加sts插件\n可以给eclipse增加支持spring的插件: spring tool suite\n下载springsource-tool-suite-3.9.4. RELEASE-e4.7.3a-updatesite.zip,然后在Eclipse中安装: Help- Instal\n 方式二:\n直接下载sts工具(相当于一个Eclipse) : 下载地址\n  新建: bean configuration ..\n文件名：applicationContext.xml\n开发Spring程序(IOC) package org.ycit.entity; public class Student { private int stuNo; private String stuName; private int stuAge; public Student() { } public Student(int stuNo, String stuName, int stuAge) { this.stuNo = stuNo; this.stuName = stuName; this.stuAge = stuAge; } public int getStuNo() { return stuNo; } public void setStuNo(int stuNo) { this.stuNo = stuNo; } public String getStuName() { return stuName; } public void setStuName(String stuName) { this.stuName = stuName; } public int getStuAge() { return stuAge; } public void setStuAge(int stuAge) { this.stuAge = stuAge; } @Override public String toString() { // TODO Auto-generated method stub return this.stuNo+\u0026quot;-\u0026quot;+this.getStuName()+\u0026quot;-\u0026quot;+this.getStuAge(); } }  \u0026lt;!-- 该文件创建的所有的对象，被spring放入了一个称之为spring ioc容器的地方 --\u0026gt; \u0026lt;!-- id唯一标识符 class：指定类型 property：代表该类 的属性 --\u0026gt; \u0026lt;bean id=\u0026quot;student\u0026quot; class=\u0026quot;org.ycit.entity.Student\u0026quot;\u0026gt; \u0026lt;!--name 属性名，value：属性值--\u0026gt; \u0026lt;property name=\u0026quot;stuNo\u0026quot; value=\u0026quot;11\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;stuName\u0026quot; value=\u0026quot;zs\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;stuAge\u0026quot; value=\u0026quot;11\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  ApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;applicationContext.xml\u0026quot;); Student student = (Student)context.getBean(\u0026quot;student\u0026quot;);  可以发现，springioc容器 帮我们new了对象，并且给对象赋了值\nSpringIOC发展史：  new\nStudent student = new Student(); student.setXxx();  此种方法创建对象new非常零散，造成后期维护较为麻烦\n 简单工厂\n将new全部放到一个工厂（类）中，根据参数的类型决定返回值\n通过简单工厂可以将new集中起来操作，方便后期的维护\n ioc （超级工厂）\nSpringIOC容器帮我们解决了工厂的问题，可以存放任何对象\n  IOC(控制反转)也可以称之为DI (依赖注入) :\n反转的是获取对象的方式由通过自己new产生对象的方式变成直接从springioc容器中获取（applicationContext）getBean()的方式\n控制反转:将创建对象、属性值的方式进行了翻转，从new、setXxx()翻转为了从springIOC容器getBean ()\n为了更加清晰地理解ioc，ioc在spring一次大会上更名为DI（依赖注入）\n依赖注入:将属性值注入给了属性，将属性注入给了bean, 将bean注入给了ioc容器;\n总结：IOC/DI ，无论要什么对象，都可以直接去springioc容器中获取，而不需要自己操作（new\\setXxx()）\n因此之后的ioc分为2步：\n 先给springioc中存放对象并赋值 拿  DI:依赖注入\n依赖：B类中有A类的对象，B类中\u0026ndash;A类的对象依赖A类\n类的右上角有s标志，标志着这个类被纳入到了ioc容器中了\nIOC容器赋值：\n如果是简单类型（8个基本+String），value\n如果是对象类型，ref=\u0026quot;需要引用的id值\u0026quot;，因此实现了 对象与对象之间的依赖关系，通过conext.getBean(需要获取的bean的id值)获取对象\n依赖注入3种方式：  set注入：通过setXxx()赋值\n赋值，默认使用的是 set方法();\n依赖注入底层是通过反射实现的。\n\u0026lt;bean id=\u0026quot;student\u0026quot; class=\u0026quot;org.ycit.entity.Student\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;stuNo\u0026quot; value=\u0026quot;11\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;stuName\u0026quot; value=\u0026quot;zs\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;stuAge\u0026quot; value=\u0026quot;11\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  构造器注入：通过构造方法赋值\n\u0026lt;bean id=\u0026quot;teacher\u0026quot; class=\u0026quot;org.ycit.entity.Teacher\u0026quot;\u0026gt; \u0026lt;!-- 通过构造方法赋值 顺序严格一致 不一致可以使用index属性指定参数的顺序 (从0开始) 可以使用属性name指定参数的名字--\u0026gt; \u0026lt;constructor-arg value=\u0026quot;ls\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg value=\u0026quot;22\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt;  \u0026lt;!--index从0开始--\u0026gt; \u0026lt;constructor-arg value=\u0026quot;ls\u0026quot; index=\u0026quot;1\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg value=\u0026quot;22\u0026quot; index=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt;  \u0026lt;!--通过name指定参数名--\u0026gt; \u0026lt;constructor-arg value=\u0026quot;ls\u0026quot; name=\u0026quot;name\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg value=\u0026quot;22\u0026quot; name=\u0026quot;age\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt;  \u0026lt;!--type--\u0026gt; \u0026lt;constructor-arg value=\u0026quot;ls\u0026quot; type=\u0026quot;String\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg value=\u0026quot;22\u0026quot; type=\u0026quot;int\u0026quot;\u0026gt;\u0026lt;/constructor-arg\u0026gt;  这几种方式也可以同时使用\n需要注意：如果 \u0026lt;constructor-arg\u0026gt;的顺序 与构造方法参数的顺序不一致，则需要通过type或者index或name指定。\n p命名空间注入\n引入p命名空间\nxmlns:p=\u0026quot;http://www.springframework.org/schema/p\u0026quot;  使用  xml \n 简单类型：  xml\n  p:属性名=\u0026ldquo;属性值\u0026rdquo; ```\n引用类型（除了String外）： ```xml p:属性名-ref=\u0026quot;引用的id\u0026quot; ``` **注意**:多个 p赋值的时候 要有空格,顺序无所谓。  注意：\n无论是String还是Int/short/long，在赋值时都是\nvalue=\u0026quot;值\u0026quot;  因此建议 此种情况 需要配合 name\\type进行区分\n注入各种集合数据类型: List Set map properties\nprivate List\u0026lt;String\u0026gt; list; private String[] array; private Set\u0026lt;String\u0026gt; set; private Map\u0026lt;String,String\u0026gt; map; private Properties props;  \u0026lt;bean id=\u0026quot;collectionDemo\u0026quot; class=\u0026quot;org.ycit.entity.AllCollectionType\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;list\u0026quot;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;足球\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;篮球\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;乒乓球\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;array\u0026quot;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;asd\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;sdf\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;asdf\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;set\u0026quot;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;asd2\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;sdf3\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;asdf4\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;map\u0026quot;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry\u0026gt; \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;aa\u0026lt;/value\u0026gt; \u0026lt;/key\u0026gt; \u0026lt;value\u0026gt;aa\u0026lt;/value\u0026gt; \u0026lt;/entry\u0026gt; \u0026lt;entry\u0026gt; \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;bb\u0026lt;/value\u0026gt; \u0026lt;/key\u0026gt; \u0026lt;value\u0026gt;bb\u0026lt;/value\u0026gt; \u0026lt;/entry\u0026gt; \u0026lt;entry\u0026gt; \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;cc\u0026lt;/value\u0026gt; \u0026lt;/key\u0026gt; \u0026lt;value\u0026gt;cc\u0026lt;/value\u0026gt; \u0026lt;/entry\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;props\u0026quot;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026quot;a4\u0026quot;\u0026gt;a4\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026quot;b4\u0026quot;\u0026gt;b4\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026quot;c4\u0026quot;\u0026gt;c4\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026quot;d4\u0026quot;\u0026gt;d4\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  set、list、数组 ;各自都有自己的标签\u0026lt;set\u0026gt; \u0026lt;list\u0026gt; \u0026lt;array\u0026gt;，但是也可以混着用,不建议混着使用\n注意：\n\u0026lt;bean id=\u0026quot;student\u0026quot; class=\u0026quot;org.ycit.entity.Student\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;stuNo\u0026quot; value=\u0026quot;11\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  与\n\u0026lt;bean id=\u0026quot;student\u0026quot; class=\u0026quot;org.ycit.entity.Student\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;stuNo\u0026quot;\u0026gt; \u0026lt;value\u0026gt;11\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;stuName\u0026quot;\u0026gt; \u0026lt;value\u0026gt;1\u0026lt;![CDATA[\u0026gt;\u0026lt;#$%\u0026gt;]]\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;stuName\u0026quot;\u0026gt; \u0026lt;value type=\u0026quot;java.lang.String\u0026quot;\u0026gt;zsss\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  两种方式的异同\n给对象类型\n赋值null：\n\u0026lt;property name=\u0026quot;name\u0026quot; \u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/property\u0026gt;  赋空值 \u0026quot;\u0026quot;\n\u0026lt;property name=\u0026quot;name\u0026quot; \u0026gt; \u0026lt;value\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt;  在ioc中定义bean的前提：该bean的类 必须提供了 无参构造\n自动装配（只适用于 ref类型 ）： 约定优于配置\n自动装配：\n\u0026lt;bean ... class=\u0026quot;org.lanqiao.entity.Course\u0026quot; autowire=\u0026quot;byName|byType|constructor|no\u0026quot; \u0026gt;  autowire=\u0026quot;byName\u0026quot;Course类中有一个ref属性teracher（属性名），并且该ioc容器中恰好有一个bean的id也是teacher。bean的id值=类的属性名，则会自动装配\nbyName本质是byId\n byName: 自动寻找：其他bean的id值=该Course类的属性名\n byType: 其他bean的类型(class) 是否与 该Course类的ref属性类型一致 （注意，此种方式 必须满足：当前Ioc容器中 只能有一个Bean满足条件 ）\n constructor： 其他bean的类型(class) 是否与 该Course类的构造方法参数 的类型一致；此种方式的本质就是byType\n no不使用\n  可以在头文件中 一次性将该ioc容器的所有bean 统一设置成自动装配：\n\u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; ... default-autowire=\u0026quot;byName\u0026quot;\u0026gt;  自动装配虽然可以减少代码量，但是会降低程序的可读性，使用时需要谨慎。子标签可以覆盖全局性，子标签可以进行覆盖设置\n使用注解定义bean： 通过注解的形式 将bean以及相应的属性值 放入ioc容器\n配置扫描器 \u0026lt;context:component-scan base-package=\u0026quot;org.lanqiao.dao,xxx\u0026quot;\u0026gt; \u0026lt;/context:component-scan\u0026gt;  多个包之间通过,分隔\nSpring在启动的时候，会根据base-package在 该包中扫描所有类，查找这些类是否有注解@Component或其他注解(\u0026ldquo;studentDao\u0026rdquo;),如果有，则将该类 加入spring Ioc容器。\n添加注解 //id为Component中设置的studentDao @Component(\u0026quot;studentDao\u0026quot;) public class StudentDaoImpl { public void addStudent(Student student) { System.out.println(\u0026quot;增加学生\u0026quot;); } }  @Component细化：\ndao层注解： @Repository service层注解： @Service 控制器层注解： @Controller  使用注解实现事务 使用注解实现事务（声明式事务）\n目标：通过事务 使以下方法 要么全成功、要么全失败\npublic void addStudent() { //增加班级 //增加学生 //crdu }  jar包 spring-tx-4.3.9.RELEASE.jar ojdbc.jar commons-dbcp.jar 连接池使用到数据源 commons-pool.jar 连接池 spring-jdbc-4.3.9.RELEASE.jar aopalliance.jar  配置 jdbc\\mybatis\\spring\n增加事务tx的命名空间\nxmlns:tx=\u0026quot;http://www.springframework.org/schema/tx\u0026quot;  增加对事务的支持\n\u0026lt;!-- 增加对事务的支持 --\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026quot;txManager\u0026quot; /\u0026gt;  配置事务管理器\n\u0026lt;!-- 配置事务管理器txManager --\u0026gt; \u0026lt;bean id = \u0026quot;txManager\u0026quot; class=\u0026quot;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  配置数据库相关的事务\n\u0026lt;!-- 配置数据库相关的事务 --\u0026gt; \u0026lt;bean id=\u0026quot;dataSource\u0026quot; class=\u0026quot;org.apache.commons.dbcp.BasicDataSource\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driverClassName\u0026quot; value=\u0026quot;oracle.jdbc.OracleDriver\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;jdbc:oracle:thin:@localhost:1521:MyOracleDB\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;scott\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;135451\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;maxActive\u0026quot; value=\u0026quot;10\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;maxIdle\u0026quot; value=\u0026quot;6\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  使用 将需要 成为事务的方法 前增加注解：\n@Transactional(readOnly = false,propagation = Propagation.REQUIRED) public void addStudent(Student student) { //if(该学生是否存在) //其他的判定条件 studentDao.addStudent(student); }  Propagation （事务的传播属性）  Propagationkey属性确定代理应该给哪个方法增加事务行为。这样的属性最重要的部份是传播行为。有以下选项可供使用：PROPAGATION_REQUIRED\u0026ndash;支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。\nPROPAGATION_SUPPORTS\u0026ndash;支持当前事务，如果当前没有事务，就以非事务方式执行。\nPROPAGATION_MANDATORY\u0026ndash;支持当前事务，如果当前没有事务，就抛出异常。\nPROPAGATION_REQUIRES_NEW\u0026ndash;新建事务，如果当前存在事务，把当前事务挂起。\nPROPAGATION_NOT_SUPPORTED\u0026ndash;以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\nPROPAGATION_NEVER\u0026ndash;以非事务方式执行，如果当前存在事务，则抛出异常。\n  PROPAGATION_REQUIRED\n加入当前正要执行的事务不在另外一个事务里，那么就起一个新的事务\n比如说，ServiceB.methodB的事务级别定义为PROPAGATION_REQUIRED, 那么由于执行ServiceA.methodA的时候，ServiceA.methodA已经起了事务，这时调用ServiceB.methodB，ServiceB.methodB看到自己已经运行在ServiceA.methodA 的事务内部，就不再起新的事务。\n而假如ServiceA.methodA运行的时候发现自己没有在事务中，他就会为自己分配一个事务。这样，在ServiceA.methodA或者在ServiceB.methodB内的任何地方出现异常，事务都会被回滚。即使ServiceB.methodB的事务已经被提交，但是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚\n PROPAGATION_SUPPORTS\n如果当前在事务中，即以事务的形式运行，如果当前不再一个事务中，那么就以非事务的形式运行\n PROPAGATION_MANDATORY\n必须在一个事务中运行。也就是说，他只能被一个父事务调用。否则，他就要抛出异常\n PROPAGATION_REQUIRES_NEW\n这个就比较绕口了。 比如我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW， 那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的事务，等待ServiceB.methodB的事务完成以后，他才继续执行。他与PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为ServiceB.methodB是新起一个事务，那么就是存在两个不同的事务。如果ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚，ServiceB.methodB是不会回滚的。如果ServiceB.methodB失败回滚， 如果他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交。\n PROPAGATION_NOT_SUPPORTED\n当前不支持事务。比如ServiceA.methodA的事务级别是PROPAGATION_REQUIRED ，ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ， 那么当执行到ServiceB.methodB时，ServiceA.methodA的事务挂起，而他以非事务的状态运行完，再继续ServiceA.methodA的事务。 6.PROPAGATION_NEVER\n不能在事务中运行。假设ServiceA.methodA的事务级别是PROPAGATION_REQUIRED， 而ServiceB.methodB的事务级别是PROPAGATION_NEVER ，那么ServiceB.methodB就要抛出异常了。\n PROPAGATION_NESTED\n理解Nested的关键是savepoint。他与PROPAGATION_REQUIRES_NEW的区别是，PROPAGATION_REQUIRES_NEW另起一个事务，将会与他的父事务相互独立，而Nested的事务和他的父事务是相依的，他的提交是要等和他的父事务一块提交的。也就是说，如果父事务最后回滚，他也要回滚的。而Nested事务的好处是他有一个savepoint。\nServiceA { /** * 事务属性配置为 PROPAGATION_REQUIRED */ void methodA() { try { //savepoint ServiceB.methodB(); //PROPAGATION_NESTED 级别 } catch (SomeException) { // 执行其他业务, 如 ServiceC.methodC(); } } }  也就是说ServiceB.methodB失败回滚，那么ServiceA.methodA也会回滚到savepoint点上，ServiceA.methodA可以选择另外一个分支，比如 ServiceC.methodC，继续执行，来尝试完成自己的事务。 但是这个事务并没有在EJB标准中定义。\n  Spring事务的隔离级别  ISOLATION_DEFAULT：\n这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应\n ISOLATION_READ_UNCOMMITTED：\n这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。\n ISOLATION_READ_COMMITTED：\n保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据\n ISOLATION_REPEATABLE_READ：\n这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。\n ISOLATION_SERIALIZABLE\n这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。\n  什么是脏数据，脏读，不可重复读，幻觉读？ 脏读: 指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。\n不可重复读: 指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。\n幻觉读: 指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。\nAOP：面向方面编程 git源码\n一个普通的类\u0026mdash;-\u0026gt;有特定功能的类\n a.继承类\nb.实现接口\nc.注解\nd.配置\n 类 -\u0026gt; “通知” ：实现接口\nxml方式的通知类型\n   通知类型 需要实现的接口 接口中的方法 执行时机     前置通知 org-springframework.aop.MethodBeforeAdvice before() 目标方法执行前。   后置通知 org-springframework.aop.AfterReturningAdvice afterRetuming() 目标方法执行后。   异常通知 org.-springframework.aop.ThrowsAdvice 无 目标方法发生异常时   环绕通知 org.aopalliance.intercept.MethodInterceptor invoke() 拦截对目标方法调用，即调用目标方法的整    前置通知 jar aopaliance.jar aspectjweaver.jar  配置 增加命名空间\nxmlns:aop=\u0026quot;http://www.springframework.org/schema/aop\u0026quot;  将两个类放入ioc容器\n\u0026lt;bean id=\u0026quot;studentServiceImpl\u0026quot; class=\u0026quot;org.ycit.service.impl.StudentServiceImpl\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;studentDao\u0026quot; ref=\u0026quot;StudentDaoImpl\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--通知所在类--\u0026gt; \u0026lt;bean id=\u0026quot;logBefore\u0026quot; class = \u0026quot;org.ycit.aop.LogBefore\u0026quot;\u0026gt; \u0026lt;/bean\u0026gt;  将二者进行关联\n\u0026lt;!-- 关联两个类 --\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--配置切入点（在哪里执行通知） --\u0026gt; \u0026lt;!-- 如果想要在多个方法执行之前 执行同一个函数则execution(aa())orexecution(bb()) --\u0026gt; \u0026lt;aop:pointcut expression=\u0026quot;execution(public void org.ycit.service.impl.StudentServiceImpl.addStudent(org.ycit.entity.Student))\u0026quot; id=\u0026quot;poioncut\u0026quot;/\u0026gt;\t\u0026lt;!--advisor：相当于连接切入点和切面的线 --\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026quot;logBefore\u0026quot; pointcut-ref=\u0026quot;poioncut\u0026quot;/\u0026gt; \u0026lt;/aop:config\u0026gt;  注意此时的全类名\n如果想在多个方法执行前执行该方法则\nexecution() or execution()  测试\npublic static void testAop() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;applicationContext.xml\u0026quot;); IsStudentService student = (IsStudentService)context.getBean(\u0026quot;studentServiceImpl\u0026quot;); Student student = new Student(); studen.addStudent(student1); }  如果出现异常：类似\njava.lang.NoClassDefFoundError: org/apache/commons/pool/impl/GenericObjectPool  则说明缺少jar\n编写 aop：每当之前add()之前 自动执行一个方法log();\naddStudent(); 业务方法（IStudentService.java中的 addStudent()）\npublic interface IsStudentService { void addStudent(Student studnet); }  log()\npublic class LogBefore implements MethodBeforeAdvice{ //前置通知的具体内容 @Override public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(\u0026quot;before....\u0026quot;); //target 对象 method 方法 args输入参数 } }  before(); 自动执行的通知，即aop前置通知  public class Xxx { @Test a(){} }  后置通知： 通知类 ，普通实现接口\npublic class LogAfter implements AfterReturningAdvice{ @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\u0026quot;**********后置通知：目标对象：\u0026quot;+target+\u0026quot;,调用的方法名：\u0026quot;+method.getName()+\u0026quot;,方法的参数个数：\u0026quot;+args.length+\u0026quot;，方法的返回值：\u0026quot;+returnValue); } }  目标对象：+target+ 调用的方法名：method.getName() 方法的参数个数：args.length 方法的返回值:returnValue  业务类、业务方法\npublic interface IsStudentService { void addStudent(Student studnet); }  配置：\n将业务类、通知 纳入springIOC容器\n定义切入点（一端）、定义通知类（另一端），通过pointcut-ref将两端连接起来\n\u0026lt;!-- 将通知纳入springIOC容器 --\u0026gt; \u0026lt;bean id=\u0026quot;logAfter\u0026quot; class=\u0026quot;org.lanqiao.aop.LogAfter\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!-- 切入点（连接线的一端：业务类的具体方法） --\u0026gt; \u0026lt;aop:pointcut expression=\u0026quot;execution(public * org.lanqiao.service.impl.StudentServiceImpl.addStudent(..))\u0026quot; id=\u0026quot;poioncut2\u0026quot;/\u0026gt; \u0026lt;!-- （连接线的另一端：通知 类） --\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026quot;logAfter\u0026quot; pointcut-ref=\u0026quot;poioncut2\u0026quot; /\u0026gt; \u0026lt;/aop:config\u0026gt;  异常通知： 通知类\npublic class LogException implements ThrowsAdvice { //异常通知的具体方法 public void afterThrowing(Method method, Object[] args ,Object target, NullPointerException ex)//只捕获NullPointerException类型的异常 { System.out.println(\u0026quot;00000000000异常通知：目标对象:\u0026quot;+target+\u0026quot;,方法名：\u0026quot;+method.getName()+\u0026quot;,方法的参数个数：\u0026quot;+args.length+\u0026quot;,异常类型:\u0026quot;+ex.getMessage()); } }  目标对象:target 方法名：method.getName() 方法的参数个数：args.length 异常类型:ex.getMessage()  根据异常通知接口的定义可以发现，异常通知的实现类 必须编写以下方法：\npublic void afterThrowing([Method, args, target], ThrowableSubclass)：  a.public void afterThrowing(Method, args, target, ThrowableSubclass) b.public void afterThrowing(ThrowableSubclass)  配置\n\u0026lt;bean id=\u0026quot;logException\u0026quot; class=\u0026quot;org.lanqiao.aop.LogException\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!-- 切入点（连接线的一端：业务类的具体方法） --\u0026gt; \u0026lt;aop:pointcut expression=\u0026quot;execution(public * org.lanqiao.service.impl.StudentServiceImpl.addStudent(..))\u0026quot; id=\u0026quot;poioncut3\u0026quot;/\u0026gt; \u0026lt;!-- （连接线的另一端：通知 类） --\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026quot;logException\u0026quot; pointcut-ref=\u0026quot;poioncut3\u0026quot; /\u0026gt; \u0026lt;/aop:config\u0026gt;  环绕通知: 在目标方法的前后、异常发生时、最终等各个地方都可以 进行的通知，最强大的一个通知；\n可以获取目标方法的 全部控制权（目标方法是否执行、执行之前、执行之后、参数、返回值等）\n在使用环绕通知时，目标方法的一切信息 都可以通过invocation参数获取到\n环绕通知 底层是通过拦截器实现的。\n通知类 public class LogAround implements MethodInterceptor{ @Override public Object invoke(MethodInvocation invocation) throws Throwable { Object result = null ; //方法体1... try { //方法体2... System.out.println(\u0026quot;用环绕通知实现的[前置通知]...\u0026quot;); // invocation.proceed() 之前的代码：前置通知 result = invocation.proceed() ;//控制着目标方法的执行 ，addStudent() //result 就是目标方法addStudent()方法的返回值 //\tinvocation.proceed() 之后的代码：后置通知 System.out.println(\u0026quot;用环绕通知实现的[后置通知]...:\u0026quot;); System.out.println(\u0026quot;-----------------目标对象target\u0026quot;+invocation.getThis()+\u0026quot;,调用的方法名：\u0026quot;+invocation.getMethod().getName()+\u0026quot;,方法的参数个数：\u0026quot;+invocation.getArguments().length+\u0026quot;,返回值：\u0026quot;+result); }catch(Exception e) { //方法体3... //异常通知 System.out.println(\u0026quot;用环绕通知实现的[异常通知]...\u0026quot;); } return result;//目标方法的返回值 } }  配置 \u0026lt;!-- 将环绕通知加入ioc容器 \u0026lt;bean id=\u0026quot;logAround\u0026quot; class=\u0026quot;org.lanqiao.aop.LogAround\u0026quot;\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 切入点（连接线的一端：业务类的具体方法）--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut expression=\u0026quot;execution(public * org.lanqiao.service.impl.StudentServiceImpl.addStudent(..))\u0026quot; id=\u0026quot;poioncut4\u0026quot;/\u0026gt; \u0026lt;!-- （连接线的另一端：通知 类） \u0026lt;aop:advisor advice-ref=\u0026quot;logAround\u0026quot; pointcut-ref=\u0026quot;poioncut4\u0026quot; /\u0026gt; \u0026lt;/aop:config\u0026gt; --\u0026gt;  实现注解实现 通知 ,aop jar 与 实现接口 的方式相同\n配置 将业务类、通知 纳入springIOC容器\n开启注解对AOP的支持\n\u0026lt;!--开启注解对AOP的支持--\u0026gt; \u0026lt;aop:aspectj-autoproxy\u0026gt;\u0026lt;/aop:aspectj-autoproxy\u0026gt; \u0026lt;!-- 配置扫描器 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;org.lanqiao.dao\u0026quot;\u0026gt;  编写 通知：\n//@Component(\u0026quot;logAnnotation\u0026quot;) //将LogAspectAnnotation纳入springIOC容器中 @Aspect //此类是一个通知 public class LogAspectAnnotation { //前置通知 @Before(\u0026quot;execution(public * addStudent(..))\u0026quot;) //属性：定义切点 public void myBefore(JoinPoint jp) { System.out.println(\u0026quot;《注解形式-前置通知》：目标对象：\u0026quot;+jp.getTarget()+\u0026quot;,方法名：\u0026quot;+jp.getSignature().getName() +\u0026quot;,参数列表：\u0026quot;+ jp.getArgs().length ); } //后置通知 @AfterReturning( pointcut= \u0026quot;execution(public * addStudent(..))\u0026quot; ,returning=\u0026quot;returningValue\u0026quot; ) public void myAfter(JoinPoint jp,Object returningValue) {//returningValue是返回值，但需要告诉spring System.out.println(\u0026quot;《注解形式-后置通知》：目标对象：\u0026quot;+jp.getTarget()+\u0026quot;,方法名：\u0026quot;+jp.getSignature().getName() +\u0026quot;,参数列表：\u0026quot;+ jp.getArgs().length+\u0026quot;,返回值：\u0026quot;+returningValue ); } /*环绕通知 ,参数ProceedingJoinPoint @Around(\u0026quot;execution(public * addStudent(..))\u0026quot;) public void myAround(ProceedingJoinPoint jp ) { //方法之前：前置通知 System.out.println(\u0026quot;《【环绕】方法之前：前置通知\u0026quot;); try { //方法执行时 jp.proceed() ;//执行方法 //方法之前之后：后置通知 System.out.println(\u0026quot;《【环绕】方法之前之后：后置通知\u0026quot;); }catch(Throwable e) { //发生异常时：异常通知 System.out.println(\u0026quot;《【环绕】发生异常时：异常通知\u0026quot;); }finally { //最终通知 System.out.println(\u0026quot;《【环绕】最终通知\u0026quot;); } }*/ //异常通知:如果只捕获特定类型的已存银行，则可以通过第二个参数实现：e @AfterThrowing(pointcut= \u0026quot;execution(public * addStudent(..))\u0026quot;,throwing=\u0026quot;e\u0026quot;) public void myException(JoinPoint pj, NullPointerException e) {//此异常通知 只会捕获NullPointerException类型的异常 System.out.println(\u0026quot;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;《注解形式-异常通知》----e:\u0026quot;+e.getMessage()); } //最终通知 @After(\u0026quot;execution(public * addStudent(..))\u0026quot;) public void myAfter() { System.out.println(\u0026quot;《[myAfter]注解形式-最终通知-----通知》----\u0026quot;); } }  注意：通过注解形式 将对象增加到 ioc容器时，需要设置 扫描器\n\u0026lt;context:component-scan base-package=\u0026quot;org.lanqiao.aop\u0026quot;\u0026gt;\u0026lt;/context:component-scan\u0026gt;  扫描器 会将 指定的包 中的 @Componet @Service @Respository @Controller修饰的类产生的对象 增加到IOC容器中\n@Aspect不需要 加入扫描器，只需要开启即可：\n\u0026lt;aop:aspectj-autoproxy\u0026gt;\u0026lt;/aop:aspectj-autoproxy\u0026gt;  通过注解形式 实现的aop，如果想获取 目标对象的一些参数，则需要使用一个对象：JointPoint\n注解形式的返回值：\n 声明返回值 的参数名：\n@AfterReturning( pointcut= \u0026quot;execution(public * addStudent(..))\u0026quot; ,returning=\u0026quot;returningValue\u0026quot; )   注解形式实现aop时，通知的方法的参数不能多、少\npublic void myAfter(JoinPoint jp,Object returningValue) {//returningValue是返回值，但需要告诉spring System.out.println(\u0026quot;返回值：\u0026quot;+returningValue );  实现接口形式、注解形式 只捕获声明的特定类型的异常，而其他类型异常不捕获。\n通过 配置将 类-\u0026gt;通知 基于Schema配置\n类似 与 实现接口的方式\n接口方式通知：\npublic class LogAfter implements AfterReturningAdvice  Schema方式通知：\n 编写一个普通类 public class LogAfter {}\n 将该类 通过配置，转为一个“通知”\n编写普通类 public class LogSchema { //后置通知方法 :JoinPoint适用于注解 public void afterReturning(JoinPoint jp,Object returnValue) throws Throwable { System.out.println(\u0026quot;》》》》》》》》》》》后置通知：目标对象：\u0026quot;+jp.getThis()+\u0026quot;,调用的方法名：\u0026quot;+jp.getSignature().getName()+\u0026quot;,方法的参数个数：\u0026quot;+jp.getArgs().length+\u0026quot;，方法的返回值：\u0026quot;+returnValue); } public void before() { System.out.println(\u0026quot;》》》》》》》》》》》前置通知...\u0026quot;); } public void whenException(JoinPoint jp,NullPointerException e) { System.out.println(\u0026quot;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;异常：\u0026quot; +e.getMessage()); } //注意：环绕通知 会返回目标方法的返回值，因此返回值为Object public Object around(ProceedingJoinPoint jp) { System.out.println(\u0026quot;''''''''''''''''''环绕通知：前置通知\u0026quot;); Object result = null ; try { result = jp.proceed() ;//执行方法 System.out.println(\u0026quot;'''''''''\u0026quot;+jp.getSignature().getName()+\u0026quot;,\u0026quot;+result); System.out.println(\u0026quot;''''''''''''''''''环绕通知：后置通知\u0026quot;); }catch(Throwable e) { System.out.println(\u0026quot;''''''''''''''''''环绕通知：异常通知\u0026quot;); } return result ; } }   配置 \u0026lt;!-- 将准备转为 通知的类 纳入ioc容器 --\u0026gt; \u0026lt;bean id=\u0026quot;logSchema\u0026quot; class=\u0026quot;org.lanqiao.aop.LogSchema\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!-- 切入点（连接线的一端：业务类的具体方法） --\u0026gt; \u0026lt;aop:pointcut expression=\u0026quot;execution(public * org.lanqiao.service.impl.StudentServiceImpl.addStudent(..))\u0026quot; id=\u0026quot;pcShema\u0026quot;/\u0026gt; \u0026lt;!-- （连接线的另一端：通知 类 --\u0026gt; \u0026lt;!-- schema方式 --\u0026gt; \u0026lt;aop:aspect ref=\u0026quot;logSchema\u0026quot;\u0026gt; \u0026lt;!-- 连接线：连接 业务 addStudent和通知before --\u0026gt; \u0026lt;aop:before method=\u0026quot;before\u0026quot; pointcut-ref=\u0026quot;pcShema\u0026quot;/\u0026gt; \u0026lt;!-- 连接线：连接 业务 addStudent 和 通知afterReturning --\u0026gt; \u0026lt;aop:after-returning method=\u0026quot;afterReturning\u0026quot; returning=\u0026quot;returnValue\u0026quot; pointcut-ref=\u0026quot;pcShema\u0026quot;/\u0026gt; \u0026lt;!--异常--\u0026gt; \u0026lt;aop:after-throwing method=\u0026quot;whenException\u0026quot; pointcut-ref=\u0026quot;pcShema\u0026quot; throwing=\u0026quot;e\u0026quot;/\u0026gt; \u0026lt;!-- 环绕 --\u0026gt; \u0026lt;aop:around method=\u0026quot;around\u0026quot; pointcut-ref=\u0026quot;pcShema\u0026quot; /\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt;  如果要获取目标对象信息：\n注解、schema：JoinPoint\n接口：Method method, Object[] args, Object target\nschema形式 和注解形式相似，\n不同之处：\n注解形式 使用了注册@After，\nschmema形式进行了多余的配置\nSpring开发Web项目 及 拆分Spring配置文件 git源码\nSpringIoc容器初始化： 1. 将容器中的所有bean实例化为对象 2. 将各个bean依赖的属性值注入进去\n在普通Java程序中\nApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;applicationContext.xml\u0026quot;);  时初始化\nJava程序的入口是统一的main()，因此只需要在main中实例化一次applicationContext.xml就可以实现Ioc容器初始化操作\nSpring开发Web项目 Web项目如何初始化SpringIOC容器 ：\n思路：当服务启动时（tomcat），通过监听器将SpringIOC容器初始化一次（该监听器 spring-web.jar已经提供）\n因此用spring开发web项目 至少需要7个jar： spring-java的6个jar + spring-web.jar，\n注意：web项目的jar包 是存入到WEB-INF/lib中\nweb项目启动时 ，会自动加载web.xml，因此需要在web.xml中加载 监听器（ioc容器初始化）。\nWeb项目启动时，启动实例化Ioc容器：\n\u0026lt;!-- 指定 Ioc容器（applicationContext.xml）的位置--\u0026gt; \u0026lt;context-param\u0026gt; \u0026lt;!-- 监听器的父类ContextLoader中有一个属性contextConfigLocation，该属性值 保存着 容器配置文件applicationContext.xml的位置 --\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;!-- 配置spring-web.jar提供的监听器，此监听器 可以在服务器启动时 初始化Ioc容器。 初始化Ioc容器（applicationContext.xml） ， 1.告诉监听器 此容器的位置：context-param 2.默认约定的位置\t:WEB-INF/applicationContext.xml --\u0026gt; \u0026lt;listener-class\u0026gt;org.springframework.web.context.ContextLoaderListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt;  初始化Ioc容器（applicationContext.xml）两种方式\n 告诉监听器 此容器的位置：context-param 默认约定的位置:WEB-INF/applicationContext.xml  拆分Spring配置文件 java项目：\napplicationContext1.xml applicationContext2.xml applicationContext3.xml ApplicationContext conext = new ClassPathXmlApplicationContext(\u0026quot;applicationContext3.xml\u0026quot;) ;  Web项目：\n根据什么拆分？\n 三层结构\nUI(html/css/jsp 、Servlet) applicationController.xml Service :applicationService.xml Dao:applicationDao.xml 公共 数据库:applicationDB.xml  功能结构\n学生相关配置\napplicationContextStudent.xml \u0026lt;bean id=\u0026quot;\u0026quot; class=\u0026quot;X...Student\u0026quot;\u0026gt;  班级相关配置\napplicationContextClass.xml   合并：如何将多个配置文件 加载 * 方式1 xml \u0026lt;context-param\u0026gt; \u0026lt;!-- 监听器的父类ContextLoader中有一个属性contextConfigLocation，该属性值 保存着 容器配置文件applicationContext.xml的位置 --\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt; classpath:applicationContext.xml, classpath:applicationContext-Dao.xml, classpath:applicationContext-Service.xml, classpath:applicationContext-Controller.xml \u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \n 方式二（推荐）\n\u0026lt;context-param\u0026gt; \u0026lt;!-- 监听器的父类ContextLoader中有一个属性contextConfigLocation，该属性值 保存着 容器配置文件applicationContext.xml的位置 --\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt; classpath:applicationContext.xml, classpath:applicationContext-*.xml \u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt;  方式三\n只在web.xml中加载主配置文件，\n\u0026lt;param-value\u0026gt; classpath:applicationContext.xml \u0026lt;/param-value\u0026gt;  然后在主配置问加中，加载其他配置文件\n\u0026lt;import resource=\u0026quot;applicationContext-*.xml\u0026quot;/\u0026gt;  bean的实例化、DI是在保存在Spring IOC容器中的\n  但是每一次request是请求Servlet容器，因此需要在二者间创建一个桥梁\n注解形式依赖注入 //\u0026lt;bean id=\u0026quot;studentService\u0026quot; class=\u0026quot;org.ycit.service.impl.StudentServiceImpl\u0026quot;\u0026gt; //@Service(\u0026quot;studentService\u0026quot;) public class StudentServiceImpl implements IsStudnetService{}  属性赋值 @Autowired//自动装配，byType private StudentMapper studentMapper;  配置扫描包\n\u0026lt;context:component-scan base-package=\u0026quot;org.ycit.service.impl\u0026quot;\u0026gt;\u0026lt;/context:component-scan\u0026gt;  注解形式\n@Autowired 自动装配，byType @Autowired @Qualifier(\u0026quot;xxx\u0026quot;) 自动装配，byName（byID），二者同时使用  SpringIOC容器 git源码\nSpring IoC容器？\n2种形式：\n xml配置文件：\napplicationContext.xml\n存bean:\n\u0026lt;bean id class\u0026gt;  取bean:\nApplicationContext context= new ClassPathXmlApplicationContext(\u0026quot;applicationContext.xml\u0026quot;); context.getBean();  注解：\n存bean、\n带有@Configuration注解的类（配置类）\n//配置类 @Configuration public class MyConfig { @Bean(value=\u0026quot;stu\u0026quot;) //id=\u0026quot;stu\u0026quot; class=\u0026quot;...Student\u0026quot; public Student myStudent( Address address){ Student student = new Student(10,\u0026quot;zs10\u0026quot;,23); return student; } }  取bean\nApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class) ; context.getBean();  注意：两种形式获取的Ioc容器是 独立的\n  IOC作用\n 存bean\n 取bean\n  XXX:注解形式 给IoC容器中存放Bean：\n 必须有@Configuration注解（配置类）\n 形式：\n三层组件加入IOC容器： 给个各类加注解 、 扫描器识别注解所在包\n 给三层组件 分别加注解（@Controller、@Service、@Repository -\u0026gt; @Component）\n 将注解所在包 纳入ioc扫描器（ComponentScan）\n纳入ioc扫描器:\n xml配置文件 :\n\u0026lt;context:component-scan base-package=\u0026quot;com.lx.controller\u0026quot;\u0026gt;\u0026lt;/context:component-scan\u0026gt;   逻辑： 在三层类上加注解 ，让ioc识别，扫描器\n会将配置类也纳入IOC容器中，id值为类名的首字母小写   注解扫描器\n@Configuration @ComponentScan(value=\u0026quot;com.lx\u0026quot;) public class MyConfig { }  component-scan：只对三层组件负责\n    给扫描器指定规则： 三层组件 @ComponentScan只负责三层组件\n过滤类型：FilterType(ANNOTATION，ASSIGNABLE_TYPE，CUSTOM)\nANNOTATION ANNOTATION：三层注解类型@Controller、@Service、@Repository -\u0026gt; @Component\nexcludeFilters：排除\nincludeFilters：有默认行为，可以通过useDefaultFilters = false禁止，默认就是包含所有，又重复包含了一次，因此包含无效\n//排除Service和Dao的扫描 @ComponentScan(value=\u0026quot;com.lx\u0026quot;,excludeFilters = { @ComponentScan.Filter(type= FilterType.ANNOTATION,classes ={Service.class,Repository.class})}) @ComponentScan(value=\u0026quot;com.lx\u0026quot;,includeFilters = {@ComponentScan.Filter(type= FilterType.ANNOTATION,classes ={Controller.class})},useDefaultFilters = false)  ASSIGNABLE_TYPE：具体的类 @ComponentScan(value=\u0026quot;com.yanqun\u0026quot;,excludeFilters = { @ComponentScan.Filter(type= FilterType.ASSIGNABLE_TYPE,classes ={StudentDao.class} )} )  区分:\n ANNOTATION:Controller.clss 指的是 所有标有@Controller的类\n ASSIGNABLE_TYPE：值得是具体的一个类 StudentController.class\n  CUSTOM自定义：自己定义包含规则 @ComponentScan.Filter(type= FilterType.CUSTOM ,value={MyFilter.class}  MyFilter implements TypeFilter 重写其中的match，如果return true则加入IoC容器\n//自定义筛选 public class MyFilter implements TypeFilter { @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException { AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); //获取类名 String className = annotationMetadata.getClassName();、 //只纳入含School的类 if(className.contains(\u0026quot;School\u0026quot;)) return true ; return false; } }  非三层组件 （Student.class 、IntToStringConver.class）：\n放入IOC  @Bean+方法的返回值\nid默认就是方法名（可以通过@Bean(\u0026ldquo;stu\u0026rdquo;) 修改id值）\n import 、FactoryBean\n  bean的作用域 @Bean(value=\u0026quot;stu\u0026quot;) @Scope(\u0026quot;singleton\u0026quot;) public Student myStudent(){ }  \u0026lt;bean id=\u0026quot;student\u0026quot; class=\u0026quot;com.lx.entity.Student\u0026quot; scope=\u0026quot;singleton\u0026quot; \u0026gt; \u0026lt;!--value:简单类型--\u0026gt; \u0026lt;property name=\u0026quot;stuNo\u0026quot; value=\u0026quot;1\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;stuName\u0026quot; value=\u0026quot;张三\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;stuAge\u0026quot; value=\u0026quot;23\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--ref:其他类型--\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026quot;address\u0026quot; ref=\u0026quot;myaddress\u0026quot;\u0026gt;\u0026lt;/property\u0026gt;--\u0026gt; \u0026lt;/bean\u0026gt;  scope: singleton(默认)| prototype  执行时机（产生bean的时机）：\nsingleton（单例）：容器在初始化时，就会创建对象（唯一的一个）；以后再getBean时，不再产生新的bean。singleton也支持延迟加载（懒加载）：在第一次使用时产生。 @Lazy\n@Bean(value=\u0026quot;stu\u0026quot;) @Scope(\u0026quot;singleton\u0026quot;) @Lazy public Student myStudent(){ }  prototype（原型，多例）：容器在初始化时，不创建对象；只是在每次使用时（每次从容器获取对象时 ，context.getBean(Xxxx)）,再创建对象;并且每次getBean()都会创建一个新的对象。\n单例和多例\nStudent stu1 = (Student)context.getBean(Student.class) ; Student stu2 = (Student)context.getBean(Student.class) ;  当从容器中拿去对象时，拿取得是否是同一个对象; 是：单例；不是：多例\n条件注解 Spring Boot 可以让某一个Bean 在某些条件下 加入Ioc容器，其他情况下不加IoC容器。\n准备 bean 编写类\n增加条件Bean：给每个Bean设置条件 ，必须实现Condition接口 public class OilCarCondition implements Condition { //如果当前环境是 oil，则加入 OilCar @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) { //获取环境 Environment environment = conditionContext.getEnvironment(); String carType = environment.getProperty(\u0026quot;car.type\u0026quot;);//car.type=\u0026quot;oil\u0026quot; if(carType.contains(\u0026quot;oil\u0026quot;)){ return true ; } return false; } }  public class EnergyCarCondition implements Condition { //如果当前环境是 oil，则加入 OilCar @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) { //获取环境 Environment environment = conditionContext.getEnvironment(); String carType = environment.getProperty(\u0026quot;car.type\u0026quot;);//car.type=\u0026quot;oil\u0026quot; if(carType.contains(\u0026quot;energy\u0026quot;)){ return true ; } return false; } }  根据条件，加入IoC容器 @Bean @Conditional(OilCarCondition.class) public Car oilCar() { return new OilCar() ; } @Bean @Conditional(EnergyCarCondition.class) public Car energyCar() { return new EnergyCar() ; }  添加虚拟参数idea\nrun\u0026ndash;\u0026gt;Edit Configurations\u0026hellip;\u0026ndash;\u0026gt;VM option\n-Dcar.type=oil  回顾给IoC加入Bean的方法 注解 ：全部在@Congiration配置中设置：\n三层组件： 扫描器 + 三层注解\n非三层组件：三种方式\n @Bean+返回值，在配置类中 @import FactoryBean(工厂Bean)  @import使用：  直接编写到@Import中，并且id值是全类名\n//配置类 @Configuration @Import({Apple.class,Banana.class}) @ComponentScan(value=\u0026quot;com.lx\u0026quot;) public class MyConfig {  自定义ImportSelector接口的实现类，通过selectimports方法实现（方法的返回值 就是要纳入IoC容器的Bean） 。\n并且 告知程序 自己编写的实现类。@Import({Orange.class,MyImportSelector.class})\npublic class MyImportSelector implements ImportSelector { @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) { return new String[]{\u0026quot;com.lx.entity.Apple\u0026quot;,\u0026quot;com.lx.entity.Banana\u0026quot;}; //返回值就是 要加入IOC容器的Bean的全类名 } }  @Configuration @Import({Apple.class,MyImportSelector.class}) @ComponentScan(value=\u0026quot;com.lx\u0026quot;) public class MyConfig {  编写ImportBeanDefinitionRegistrar接口的实现类，重写方法\npublic class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar { @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { // \u0026quot;com.lx.entity.Orange\u0026quot; //Class方式 // BeanDefinition beanDefinition = new RootBeanDefinition(Orange.class) ; //String方式 BeanDefinition beanDefinition = new RootBeanDefinition(\u0026quot;com.lx.entity.Orange\u0026quot;) ; registry.registerBeanDefinition(\u0026quot;myorange\u0026quot;, beanDefinition ); // id ,class } }  @Configuration @Import({MyImportBeanDefinitionRegistrar.class}) @ComponentScan(value=\u0026quot;com.lx\u0026quot;) public class MyConfig {  Import中可以同时放置这三种方法的Class\n@Import({Orange.class,MyImportSelector.class,MyImportBeanDefinitionRegistrar.class})\n  FactoryBean(工厂Bean)  准备bean。实现类和重写方法\npublic class MyFactoryBean implements FactoryBean { //放入对象 @Override public Object getObject() throws Exception { return new Apple(); } //类型 @Override public Class\u0026lt;?\u0026gt; getObjectType() { return Apple.class; //Apple } //是否是单例 @Override public boolean isSingleton() { return true; } }  注册bean。注册到@Bean中\n@Bean public FactoryBean\u0026lt;Apple\u0026gt; myFactoryBean(){ return new MyFactoryBean();//到底是什么？MyFactoryBean 、Apple ？ }  通过@Bean放入容器中得对象应该是myFactoryBean，而myFactoryBean中又是放入了Apple；MyFactoryBean到底是什么？MyFactoryBean 、Apple ？\n注意：需要通过\u0026amp;区分 获取的对象是哪一个 ：\n不加\u0026amp;,获取的是最内部真实的Apple；\n如果加了\u0026amp;，获取的 是FacotryBean\n//Apple Object obj = context.getBean(\u0026quot;myFactoryBean\u0026quot;); System.out.println(obj); //FacotryBean Object obj2 = context.getBean(\u0026quot;\u0026amp;myFactoryBean\u0026quot;); System.out.println(obj2);  具体得原因再源码中又说明\n  Bean的生命周期： 方式一 适用于Bean+返回值得方式\n创建(new \u0026hellip;)、初始化（赋初值init）、 \u0026hellip;.、销毁（destroy）(类似servlet)\nxml:\n\u0026lt;bean id=\u0026quot;student\u0026quot; class=\u0026quot;com.yanqun.entity.Student\u0026quot; scope=\u0026quot;singleton\u0026quot; init-method=\u0026quot;myInit\u0026quot; destroy-method=\u0026quot;myDestroy\u0026quot; \u0026gt;  注解：\n@Bean(value=\u0026quot;stu\u0026quot;,initMethod = \u0026quot;myInit\u0026quot;,destroyMethod = \u0026quot;myDestroy\u0026quot;) //id=\u0026quot;stu\u0026quot; class=\u0026quot;...Student\u0026quot; @Autowired public Student myStudent(){ }  IoC容器在初始化时，会自动创建对象(构造方法) -\u0026gt;init -\u0026gt;\u0026hellip;..-\u0026gt;当容器关闭时 调用destroy\u0026hellip;\n销毁方法\n((AnnotationConfigApplicationContext) context).close();  方式二： JAVA规范 ：JSR250；适用于三层组件的形式 三层组件： 扫描器 + 三层注解（4个）\n三层注解 （功能性注解、MyIntToStringConverter.java）：@Controller、@Service、@Repository、@Component\n\u0026ndash;\u0026gt;三层注解（功能性注解【三层、功能性类】）\n将响应组件 加入 @Component注解、 给初始化方法加\n@PostConstruct、给销毁方法加@PreDestroy @PostConstruct：相当于方法一的init @PreDestroy：相当于方法一的destroy  如果要获取@Component注解中的bean，那么该Bean的名字就是@Component（value=\u0026ldquo;xxx\u0026rdquo;）的value值\n@Component(value=\u0026quot;myConverter\u0026quot;)//@Server @COntroller @Repository public class MyIntToStringConverter { @PostConstruct public void init(){ System.out.println(\u0026quot;转换..Init...\u0026quot;); } public void myConverter(){ System.out.println(\u0026quot;转换.......\u0026quot;); } @PreDestroy public void destroy(){ System.out.println(\u0026quot;转换..destroy...\u0026quot;); } }  MyIntToStringConverter converter= (MyIntToStringConverter)context.getBean(\u0026quot;myConverter\u0026quot;) ; converter.myConverter();  方法三：两个接口 接口：适用于三层组件（扫描器+三层组件）\nInitializingBean初始化 DisposableBean 销毁  初始化：只需要 实现InitializingBean中的afterPropertiesSet()方法\n销毁：实现DisposableBean 中的destroy()方法\n问题：要在SPring IOC容器中操作：操作方式 对象：Bean+返回 ，三层组件\n 如果是注解形式\n随便写一个方法 ，然后加上相应注解即可\n 如果是接口形式\n必须 实现接口中规定的方法\n@Component public class MyFunction implements InitializingBean , DisposableBean { public void myMethod(){ } @Override public void afterPropertiesSet() throws Exception { System.out.println(\u0026quot;MyFunction初始化...afterPropertiesSet\u0026quot;); } @Override public void destroy() throws Exception { System.out.println(\u0026quot;MyFunction销毁。。。destroy\u0026quot;); } }   方法四：（给容器中的所有Bean加初始化、销毁）一个接口 接口：适用于三层组件\n接口BeanPostProcessor：拦截了所有中容器的Bean\n@Controller //(4个) public class MyXxx implements BeanPostProcessor { //拦截器 @Override//bean:Student(zs) public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { // System.out.println(\u0026quot;初始化:\u0026quot;+beanName+\u0026quot;:\u0026quot;+bean); // bean.setName(\u0026quot;ls\u0026quot;) if(bean instanceof Student){ System.out.println(\u0026quot;MyXxx...初始化..\u0026quot;); Student stu = (Student)bean ; stu.setStuName(\u0026quot;zs123456\u0026quot;); stu.setStuNo(123); return stu ; } return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { if(bean instanceof Student) { // System.out.println(\u0026quot;销毁:\u0026quot; + beanName + \u0026quot;:\u0026quot; + bean); System.out.println(\u0026quot;MyXxx...销毁..\u0026quot;); } return bean; } }  自动装配 : 三层组件(4个注册+扫描器) @Autowired  Controller-\u0026gt;Service-\u0026gt;Dao\n三层组件\n通过@Autowired从Ioc容器中 根据类型自动注入（没有调用setXxx()方法）\n 如果@Autowired在属性前标注，则不调用setXxx；如果标注在setXxx前面 ，则调用setXxx\n 不能放在方法的参数前\n@Autowired private StudentDao studentDao ;   或\n@Autowired public void setStudentDao(StudentDao studentDao) { this.studentDao = studentDao; }  Bean+返回值：\n@Autowired 在方法的参数前（也可以省略）、方法前 （构造方法：特殊，如果只有一个有参构造方法，则构造方法前的@Autowired也可以省略）\n参数前\n@Bean(value=\u0026quot;stu\u0026quot;) public Student myStudent(@Autowired Address address){ Student student = new Student(10,\u0026quot;zs10\u0026quot;,23); return student; }  方法前\n@Autowired @Bean(value=\u0026quot;stu\u0026quot;) public Student myStudent(Address address){ Student student = new Student(10,\u0026quot;zs10\u0026quot;,23); return student; }  构造方法前\n@Autowired public StudentService(StudentDao studentDao){ this.studentDao= studentDao ; }  之前：@Autowired 根据类型匹配：\n三层注入方式/@Bean+返回值\n 如果有多个类型相同的，匹配哪个？\n报错。\n可以指定默认值@primary，就不会报错\n@Primary @Repository(\u0026quot;stuDao1\u0026quot;) public class StudentDaoImpl1 implements StudentDao { }  @Repository(\u0026quot;stuDao2\u0026quot;) public class StudentDaoImpl2 implements StudentDao { }  @Autowired private StudentDao studentDao ;  值为stuDao1\n 能否根据名字匹配？\n可以，结合 @Qualifier(\u0026ldquo;stuDao2\u0026rdquo;)使用。\n@Qualifier(\u0026quot;stuDao2\u0026quot;) @Autowired private StudentDao studentDao ;  如果有0个类型相同，默认报错；可以修改成不注入（值为null），\n@Autowired(required=false) private StudentDao studentDao ;   自动注入方式一：@Autowired (Spring) ，默认根据类型\n自动注入方式二 @Resource（JSR250，来自jdk），默认根据名字 （如果 有名字，根据名字匹配；如果没有名字，先根据名字查找，如果没找到，再根据类型查找）；也可以通过name或type属性 指定根据名字 或类型找。也可以使用@Primary指定默认\n@Resource @Resource(name=\u0026quot;studentDao1\u0026quot;) @Resource(type=StudentDao.class)  自动注入方式三：@Inject（JSR330），额外引入javax.inject.jar，默认根据类型匹配\n利用Spring底层组件进行开发 (三层组件+扫描器方式) 能够供我们使用的组件，都是Aware的子接口，即XxxxAware\n以ApplicationContextAware为例:实现步骤  实现ApplicationContextAware\n 重写其中的方法，都包含了一个对象。只需要将该对象 赋值到属性中即可\n@Component(\u0026quot;myComponent\u0026quot;) //id name public class MyComponent implements ApplicationContextAware{ private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { System.out.println(\u0026quot;------\u0026quot;+applicationContext); this.applicationContext= applicationContext ; } }  有什么用：例如ApplicationContextAware，可以通过该接口 获取到Ioc容器对象。\n  执行时间：如果在main（）中new Ioc容器： 先执行ApplicationContextAware实现类中的方法，通过该方法传入IoC容器 供我们自己使用； 然后再将该容器通过new返回给用户\nBeanNameAware： @Component(\u0026quot;myComponent\u0026quot;) //id name public class MyComponent implements BeanNameAware { private String beanName ; @Override public void setBeanName(String name) { System.out.println(\u0026quot;获取当前bean的name\u0026quot;+name); this.beanName = name ; } }  环境切换：@Profile Spring:切换环境\n@Profile(\u0026quot;myApple\u0026quot;) @Bean(\u0026quot;apple\u0026quot;) public Fruit apple(){ return new Apple() ; } @Profile(\u0026quot;myBanana\u0026quot;) @Bean(\u0026quot;banana\u0026quot;) public Fruit banana(){ return new Banana() ; }  激活方式一：\n-Dspring.profiles.active=@Profile环境名 -Dspring.profiles.active=myApple  有什么用：可以用于切换数据库环境：\n激活方式二：硬编码\n坑：错误写法\nApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class) ; ConfigurableEnvironment environment = (ConfigurableEnvironment)context.getEnvironment(); environment.setActiveProfiles(\u0026quot;myBanana\u0026quot;);  其中AnnotationConfigApplicationContext中有一个refresh()操作：会将我们设置的一些参数还原\n没激活 |-\u0026gt;进行激活 -\u0026gt;刷新 -\u0026gt;没激活\n流程调整：\n没激活-\u0026gt;进行激活 | -\u0026gt;刷新  什么时候设置 保存点|： 配置类的编写处 IoC容器在使用时必须refresh() ;如果是有参构造，内部已经刷新；如果无参构造，需要手工刷新。\n正确方式\n//注解方式 AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext() ; ConfigurableEnvironment environment = (ConfigurableEnvironment)context.getEnvironment(); environment.setActiveProfiles(\u0026quot;myApple\u0026quot;); //保存点 context.register(MyConfig.class); context.refresh();  Spring重要组件 接口BeanPostProcessor：拦截了所有中容器的Bean，并且可以进行bean的初始化 、销毁\n创建-\u0026gt;初始化-\u0026gt;使用\u0026hellip;-》销毁\nBeanPostProcessor BeanFactoryPostProcessor：拦截了容器 BeanDefinitionRegistryPostProcessor：即将被加载之前（解析之前，称为BeanDefination对象之前）  BeanPostProcessor\n@Controller //(4个) public class MyXxx implements BeanPostProcessor { //拦截器 @Override//bean:Student(zs) public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { // System.out.println(\u0026quot;初始化:\u0026quot;+beanName+\u0026quot;:\u0026quot;+bean); // bean.setName(\u0026quot;ls\u0026quot;) if(bean instanceof Student){ System.out.println(\u0026quot;MyXxx...初始化..\u0026quot;); Student stu = (Student)bean ; stu.setStuName(\u0026quot;zs123456\u0026quot;); stu.setStuNo(123); return stu ; } return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { if(bean instanceof Student) { // System.out.println(\u0026quot;销毁:\u0026quot; + beanName + \u0026quot;:\u0026quot; + bean); System.out.println(\u0026quot;MyXxx...销毁..\u0026quot;); } return bean; } }  BeanFactoryPostProcessor\n@Component public class MyYYY implements BeanFactoryPostProcessor { @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { // beanFactory.getBeanDefinition(\u0026quot;id\u0026quot;);//根据bean的名字(id)获取bean int count = beanFactory.getBeanDefinitionCount(); System.out.println(\u0026quot;【b】\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;容器中bean的个数：\u0026quot;+count); String[] names = beanFactory.getBeanDefinitionNames();//name-\u0026gt;id \u0026lt;bean id =\u0026quot;\u0026quot;\u0026gt; System.out.println(\u0026quot;【b】\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;容器中所有bean的名字：\u0026quot; +Arrays.asList( names ) ); } }  BeanDefinitionRegistryPostProcessor\n@Component public class MyZZZ implements BeanDefinitionRegistryPostProcessor { //继承自BeanFactoryPostProcessor的方法 （bean的工厂） @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { System.out.println(\u0026quot;【a后】postProcessBeanFactory:容器中注册的bean的数量:\u0026quot;+beanFactory.getBeanDefinitionCount()); Object myBean = beanFactory.getBean(\u0026quot;myBean\u0026quot;); System.out.println( myBean.getClass().getName() ); } // ApplicationListener， //BeanDefinitionRegistryPostProcessor接口自己的方法 （维护着容器中所有bean的注册信息） @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException { System.out.println(\u0026quot;【a先】postProcessBeanDefinitionRegistry:容器中注册的bean的数量:\u0026quot;+registry.getBeanDefinitionCount()); //额外增加一个：postProcessBeanDefinitionRegistry （可以为容器 额外增加一些bean的注册） //Orange BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.rootBeanDefinition(Orange.class);//产生BeanDefinition // beanDefinitionBuilder.getBeanDefinition();;//AbstractBeanDefinition registry.registerBeanDefinition(\u0026quot;myBean\u0026quot;, beanDefinitionBuilder.getBeanDefinition()); } }  BeanDefinitionRegistryPostProcessor(a) -》加载bean-\u0026gt;BeanFactoryPostProcessor(b)-\u0026gt;实例化bean-\u0026gt;BeanPostProcessor\n同一个方法 在不同地方（类、接口）的出现时机问题：\na继承b，因此a中必然包含b中的方法(记c )：虽然a和b中都有c，但是 因此c出现的时机不同， 则c的执行顺序也不同： 如果是在a中出现，则先执行；如果是在b中执行 则后执行\n在同一个地方（类、接口），的不同方法的出现时机问题\n监听器： 可以监听事件 ，监听的对象必须是 ApplicationEvent自身或其子类/子接口\n方式一：\n必须实现ApplicationListener接口，\n//监听器 @Component public class MyListener implements ApplicationListener { //监听对象 @Override public void onApplicationEvent(ApplicationEvent event) { System.out.println(\u0026quot;=======\u0026quot;+event+\u0026quot;======\u0026quot;); } }  方式二：注解\n(语法上 可以监听任意事件，但建议 ApplicationEvent自身或其子类/子接口) Spring：要让SPring识别自己，必须加入IOc容器（Bean+返回值| 注解+扫描器）\n@Component public class MyListener2 { //本方法是一个 监听方法 @EventListener(classes = {ApplicationEvent.class}) public void myListenerMethod(ApplicationEvent event){ System.out.println(\u0026quot;--0000000--------\u0026quot;+event); } }  自定被监听事件\n 自定义类 实现ApplicationEvent接口（自定义事件） 发布事件\ncontext.publishEvent(自定义事件);  //创建一个事件并发布 context.publishEvent(new ApplicationEven(\u0026quot;my event...\u0026quot;)) ;  或\npublic class MyEvent3 extends ApplicationEvent { public MyEvent3(Object source) { super(source); } }  MyEvent3 evn = new MyEvent3(\u0026quot;my Event3...\u0026quot;); context.publishEvent(evn) ;   ","id":44,"section":"posts","summary":"spring spring简介 2002 Rod Johnon 发布\u0026lt;Expoer One-on-one j2eedevelopment and Design\u0026gt; 2003产生Spring，Spring两大核心IOC(DI)、Aop Spring data, spring boot, spring cloud, spring framework","tags":["Spring家族"],"title":"Spring自学笔记-01","uri":"https://mumulx.github.io/2019/11/spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" Spring整合MyBatis git源码\nSpring - MyBatis\n思路：\nSqlSessionFactory -\u0026gt; SqlSession -\u0026gt;StudentMapper -\u0026gt;CRUD  可以发现 ，MyBatis最终是通过SqlSessionFactory来操作数据库，\nSpring整合MyBatis 其实就是 将MyBatis的SqlSessionFactory 交给Spring\nSM整合步骤： java项目\njar mybatis-spring.jar spring-tx.jar spring-jdbc.jar spring-expression.jar spring-context-support.jar spring-core.jar spring-context.jar spring-beans.jar spring-aop.jar spring-web.jar commons-logging.jar commons-dbcp.jar ojdbc.jar mybatis.jar log4j.jar commons-pool.jar  类-表 package org.ycit.entity; public class Student { private int stuNo; private String stuName; private int stuAge; public Student() { }\tpublic Student(int stuNo, String stuName, int stuAge) { this.stuNo = stuNo; this.stuName = stuName; this.stuAge = stuAge; } public int getStuNo() { return stuNo; } public void setStuNo(int stuNo) { this.stuNo = stuNo; } public String getStuName() { return stuName; } public void setStuName(String stuName) { this.stuName = stuName; } public int getStuAge() { return stuAge; } public void setStuAge(int stuAge) { this.stuAge = stuAge; } }  MyBatis配置文件conf.xml \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026quot;-//mybatis.org//DTD Config 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026quot;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 数据库信息 --\u0026gt; \u0026lt;!-- 在spring容器中配置 --\u0026gt; \u0026lt;!-- 加载映射文件studentmapper.xml \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026quot;org/ycit/mapper/StudentMapper.xml\u0026quot;\u0026gt;\u0026lt;/mapper\u0026gt; \u0026lt;/mappers\u0026gt; --\u0026gt; \u0026lt;/configuration\u0026gt;  driver=oracle.jdbc.OracleDriver url=jdbc:oracle:thin:@localhost:1521:MyOracleDB username=scott password=135451 maxIdle=1000 maxActive=500  通过mapper.xml将 类、表建立映射关系 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot;\u0026gt; \u0026lt;!--namespace：该mapper.xml映射文件的唯一标识符 --\u0026gt; \u0026lt;mapper namespace=\u0026quot;org.ycit.mapper.StudentMapper\u0026quot;\u0026gt; \u0026lt;select id=\u0026quot;queryStudentbyStuno\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;org.ycit.entity.Student\u0026quot;\u0026gt; select * from student where stuno = #{stuNo} \u0026lt;/select\u0026gt; \u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;org.ycit.entity.Student\u0026quot;\u0026gt; insert into student(stuno,stuname,stuage) values(#{stuNo},#{stuName},#{stuAge}) \u0026lt;/insert\u0026gt; \u0026lt;/mapper\u0026gt;  public interface StudentMapper { public void addStudent(Student student); }  整合 之前使用MyBatis:conf.xml -\u0026gt;SqlSessionFacotry\n现在整合的时候，需要通过Spring管理SqlSessionFacotry ，因此 产生的sqlSessionFacotry 所需要的数据库信息 不在放入conf.xml 而需要放入spring配置文件中\n配置Spring配置文件（applicationContext.xml）\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026quot;\u0026gt; \u0026lt;!-- 加载db.properties文件 --\u0026gt; \u0026lt;bean id=\u0026quot;config\u0026quot; class=\u0026quot;org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;locations\u0026quot; \u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;classpath:db.properties\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置数据库的信息（代替mybatis的配置i文件conf.xml） --\u0026gt; \u0026lt;bean id=\u0026quot;dataSource\u0026quot; class=\u0026quot;org.apache.commons.dbcp.BasicDataSource\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driverClassName\u0026quot; value=\u0026quot;${driver}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name= \u0026quot;url\u0026quot; value= \u0026quot;${url}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name= \u0026quot;username\u0026quot; value= \u0026quot;${username}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name= \u0026quot;password\u0026quot; value= \u0026quot;${password}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;maxActive\u0026quot; value=\u0026quot;${maxActive}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;maxIdle\u0026quot; value=\u0026quot;${maxIdle}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 在SpringIoc容器中创建MyBatis的核心类SqlSessionFactory --\u0026gt; \u0026lt;bean id=\u0026quot;sqlSessionFactory\u0026quot; class=\u0026quot;org.mybatis.spring.SqlSessionFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 加载mybatis的配置文件 \u0026lt;property name=\u0026quot;configLocation\u0026quot; value=\u0026quot;classpath:conf.xml\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; --\u0026gt; \u0026lt;!-- 加载，mapper的文件路径 --\u0026gt; \u0026lt;property name=\u0026quot;mapperLocations\u0026quot; value=\u0026quot;org/ycit/mapper/*.xml\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026quot;studentService\u0026quot; class= \u0026quot;org.ycit.service.impl.StudentServiceImpl\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;studentMapper\u0026quot; ref=\u0026quot;studentMapper\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;\t\u0026lt;!--第一种方式生成mapper对象 \u0026lt;bean id=\u0026quot;studentMapper\u0026quot; class= \u0026quot;org.ycit.dao.impl.StudentDaoImpl\u0026quot;\u0026gt; dao层注入sqlSessionFactory \u0026lt;property name=\u0026quot;sqlSessionFactory\u0026quot; ref=\u0026quot;sqlSessionFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; --\u0026gt; \u0026lt;!-- 第二种方式生成mapper对象 \u0026lt;bean id=\u0026quot;studentMapper\u0026quot; class= \u0026quot;org.mybatis.spring.mapper.MapperFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;mapperInterface\u0026quot; value=\u0026quot;org.ycit.mapper.StudentMapper\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;sqlSessionFactory\u0026quot; ref=\u0026quot;sqlSessionFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; --\u0026gt; \u0026lt;!-- 第三种方式生成mapper对象(批量产生了 多个mapper) 批量产生的mapper对象在springioc中的id值默认为 （首字母小写） 接口名 --\u0026gt; \u0026lt;bean id=\u0026quot;mappers\u0026quot; class= \u0026quot;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;sqlSessionFactoryBeanName\u0026quot; value=\u0026quot;sqlSessionFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 指定批量产生 那个包中的mapper对象 多个包使用,隔开 --\u0026gt; \u0026lt;property name=\u0026quot;basePackage\u0026quot; value=\u0026quot;org.ycit.mapper\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;  使用Spring-MyBatis整合产物开发程序 目标：通过spring产生mybatis最终操作需要的 动态mapper对象(StudentMapper对象)\nSpring产生 动态mapper对象 有3种方法：\n 第一种方式\nDAO层实现类 继承 SqlSessionDaoSupport类\nSqlSessionDaoSupport类提供了一个属性 SqlSession  public class StudentDaoImpl extends SqlSessionDaoSupport implements StudentMapper{ public void addStudent(Student student) { SqlSession session = super.getSqlSession(); StudentMapper stuDao = session.getMapper(StudentMapper.class); stuDao.addStudent(student); } }  \u0026lt;insert id=\u0026quot;addStudent\u0026quot; parameterType=\u0026quot;org.ycit.entity.Student\u0026quot;\u0026gt; insert into student(stuno,stuname,stuage) values(#{stuNo},#{stuName},#{stuAge}) \u0026lt;/insert\u0026gt;  \u0026lt;!--第一种方式生成mapper对象 要在dao层注入sqlSessionFactory --\u0026gt; \u0026lt;bean id=\u0026quot;studentMapper\u0026quot; class= \u0026quot;org.ycit.dao.impl.StudentDaoImpl\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;sqlSessionFactory\u0026quot; ref=\u0026quot;sqlSessionFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  \u0026lt;!-- 在SpringIoc容器中创建MyBatis的核心类SqlSessionFactory --\u0026gt; \u0026lt;bean id=\u0026quot;sqlSessionFactory\u0026quot; class=\u0026quot;org.mybatis.spring.SqlSessionFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 加载mybatis的配置文件 \u0026lt;property name=\u0026quot;configLocation\u0026quot; value=\u0026quot;classpath:conf.xml\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; --\u0026gt; \u0026lt;!-- 加载，mapper的文件路径 --\u0026gt; \u0026lt;property name=\u0026quot;mapperLocations\u0026quot; value=\u0026quot;org/ycit/mapper/*.xml\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  这时可以在spring中配置mapper文件的路径，以前是在mybatis的配置文件conf.xml文件中配置的，此时我们可以在spring中配置，发现mybatis配置文件形同虚设，里面没有配置的信息，因此，spring也不需要加载mybatis的配置文件，所以把加载mybatis的配置文件配置信息注释掉。\n此时不在需要我们手动提交，交给spring后会自动提交，以前采用mybatis，采用jdbc手动提交的方式。\n 第二种方式\n就是省略掉 第一种方式的 实现类 直接MyBatis提供的 Mapper实现类：org.mybatis.spring.mapper.MapperFactoryBean\n不需要自己再编写实现类\n缺点：每个mapper都需要一个配置一次\n\u0026lt;bean id=\u0026quot;studentMapper\u0026quot; class= \u0026quot;org.mybatis.spring.mapper.MapperFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;mapperInterface\u0026quot; value=\u0026quot;org.ycit.mapper.StudentMapper\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;sqlSessionFactory\u0026quot; ref=\u0026quot;sqlSessionFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  第三种方式\n批量配置 实现类\n\u0026lt;!-- 第三种方式生成mapper对象(批量产生了 多个mapper) 批量产生的mapper对象在springioc中的id值默认为 （首字母小写） 接口名 --\u0026gt; \u0026lt;bean id=\u0026quot;mappers\u0026quot; class= \u0026quot;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;sqlSessionFactoryBeanName\u0026quot; value=\u0026quot;sqlSessionFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 指定批量产生 那个包中的mapper对象 多个包使用,隔开 --\u0026gt; \u0026lt;property name=\u0026quot;basePackage\u0026quot; value=\u0026quot;org.ycit.mapper\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  批量产生的mapper对象在springioc中的id值默认为 （首字母小写） 接口名\n  SSM整合： Spring - SpringMVC - MyBatis\n SM\nSpring - MyBatis : 需要整合：将MyBatis的SqlSessionFactory 交给Spring\n SSM\n  Spring - SpringMVC ： 就是将Spring - SpringMVC 各自配置一遍\n思路： SqlSessionFactory -\u0026gt; SqlSession -\u0026gt;StudentMapper -\u0026gt;CRUD 可以发现 ，MyBatis最终是通过SqlSessionFactory来操作数据库， Spring整合MyBatis 其实就是 将MyBatis的SqlSessionFactory 交给Spring\nSM整合步骤：  jar\nmybatis-spring.jar spring-tx.jar spring-jdbc.jar spring-expression.jar spring-context-support.jar spring-core.jar spring-context.jar spring-beans.jar spring-aop.jar spring-web.jar commons-logging.jar commons-dbcp.jar ojdbc.jar mybatis.jar log4j.jar commons-pool.jar  类-表\nStudent类 -student表\n 配置\n（与Spring整合时，conf.xml可省）\u0026ndash;MyBatis配置文件conf.xml（数据源、mapper.xml） \u0026ndash;可省，将该文件中的配置 全部交由spring管理\nspring配置文件 applicationContext.xml\n 通过mapper.xml将 类、表建立映射关系\n 配置spring配置文件\n配置Spring配置文件（applicationContext.xml） （Web项目）：\nweb.xml\n\u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;org.springframework.web.context.ContextLoaderListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt;  之前使用MyBatis: conf.xml -\u0026gt;SqlSessionFacotry\n现在整合的时候，需要通过Spring管理SqlSessionFacotry ，因此 产生SqlSessionFacotry 所需要的数据库信息 不在放入conf.xml 而需要放入spring配置文件中\n在applicationContext中配置mybatis信息\n配置数据库信息\n\u0026lt;!-- 加载db.properties文件 --\u0026gt; \u0026lt;bean id=\u0026quot;config\u0026quot; class=\u0026quot;org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;locations\u0026quot;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;classpath:db.properties\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 配置配置数据库信息（替代mybatis的配置文件conf.xml） --\u0026gt; \u0026lt;bean id=\u0026quot;dataSource\u0026quot; class=\u0026quot;org.apache.commons.dbcp.BasicDataSource\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driverClassName\u0026quot; value=\u0026quot;${driver}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;${url}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;${username}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${password}\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  使用Spring整合MyBatis ：\n在SpringIoc容器中 创建MyBatis的核心类\n\u0026lt;!-- 在SpringIoc容器中 创建MyBatis的核心类 SqlSesionFactory --\u0026gt; \u0026lt;bean id=\u0026quot;sqlSessionFactory\u0026quot; class=\u0026quot;org.mybatis.spring.SqlSessionFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!-- 加载mapper.xml路径 --\u0026gt; \u0026lt;property name=\u0026quot;mapperLocations\u0026quot; value=\u0026quot;classpath:org/lanqiao/mapper/*.xml\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  将MyBatis的SqlSessionFactory 交给Spring\n\u0026lt;!-- 将MyBatis的SqlSessionFactory 交给Spring --\u0026gt; \u0026lt;bean class=\u0026quot;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;sqlSessionFactoryBeanName\u0026quot; value=\u0026quot;sqlSessionFactory\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;basePackage\u0026quot; value=\u0026quot;org.lanqiao.mapper\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--上面basePackage所在的property的作用： 将org.lanqiao.mapper包中，所有的接口 产生与之对应的 动态代理对象 （对象名 就是 首字母小写的接口名） --\u0026gt; \u0026lt;/bean\u0026gt;  继续整合SpringMVC\n将springmvc加入项目即可\n 加入SpringMVC需要的jar\nspring-webmvc.jar  给项目加入SpringMVC支持\nweb.xml: dispatcherServlet\n\u0026lt;!-- 整合SPringMVC --\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springDispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext-controller.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!-- Map all requests to the DispatcherServlet for handling --\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springDispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;  编写springmvc配置文件：\napplicationContext-controller.xml：视图解析器、基础配置\n\u0026lt;!-- 将控制器所在包 加入IOC容器 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;org.lanqiao.controller\u0026quot;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;!-- 配置视图解析器 --\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;prefix\u0026quot; value=\u0026quot;/views/\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;suffix\u0026quot; value=\u0026quot;.jsp\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- SPringMVC基础配置、标配 --\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt;    示例 git源码\n","id":45,"section":"posts","summary":"Spring整合MyBatis git源码 Spring - MyBatis 思路： SqlSessionFactory -\u0026gt; SqlSession -\u0026gt;StudentMapper -\u0026gt;CRUD 可以发现 ，MyBatis最终是通过SqlSessionFactory来操作数据","tags":["Spring家族"],"title":"SSM整合自学笔记","uri":"https://mumulx.github.io/2019/11/ssm%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0/","year":"2019"},{"content":" 记录自己的第一篇博客 \u0026emsp;2019-10-31，抓住10月的小尾巴，创建了人生的第一个博客。经过一天的努力，终于是在22：13的时候创建好了人生的第一个博客。也不知道要写一些什么，就简单的记录一下这特殊的一天。\n\u0026emsp;其实很早的时候就计划着要建立自己的博客，一直也没有着手弄。今天的话就心血来潮，仿佛是命运在召唤，促使着我建立了这个网站。就这么的，忙了一个晚上，经过了一系列的难关终于是将博客建立了起来。以后的话会分享一些自己的学习笔记和学习过程中遇到过的各种问题。说来也是惭愧，自出生二十年以来，一直也没养成什么习惯，也没有什么爱好，也没能长时间坚持做过什么事情。也是希望能把本站当作一件自己能够一直坚持想做的事情。\n\u0026emsp;此时的我呢是一名普通的本科大三的学生，在 这个时间段又再一次处在了一个人生的十字路口，一方是考研，一方是预就业。两个各有各的好处吧，于我来说可能预就业是一个更好的选择吧，当然我也不是很确定这次的选择是正确的。我呢是一个不是很能认清自己的人，也是一个每当要做选择的时候，总会错过最重要选项的那个人，很是害怕这次的选择又错过了。\n\u0026emsp;迷茫和矛盾两个词可能是我现在最真实的状态了。迷茫，更多的是对自己未来的迷茫，看不清也说不透。我对于人生没有什么规划，总是随遇而安，秉着车到山前必有路的理念，不争也不抢。可是这次与往常不同，学校和社会是两个完全不同的地方，而我又是一个不善交际的人，对于自己即将步入的社会还是没有什么概念的。这次是即将告别学校，离开这个困住了十几年的地方，要去一个更加复杂，更加混乱的地方。而这个地方充满了未知，你不知道你能否适应这个地方，能否承受的住生活的压力，能否找到一份满意的工作，能否顺利的从学生这个身份过渡到社会人士这个身份，只知道自己现在能做的只能是一个更好的自己。对于我这种不善交际，不喜争抢，性格内向的人来说，步入社会四个字就像是哈利波特里面的摄魂怪一样，令人畏惧与害怕。\n\u0026emsp;矛盾的是不能坚定自己的选择，总是患得患失，即不甘于平庸，又陷于平庸。心里想的，嘴上说的，实际做的，往往是三种样子。每当要自己做一个决定的时候，总是犹犹豫豫，患得患失，担心这担心那，考虑这考虑那，越想越复杂。最后反而会选择自己的第一映像做出的决定，而做出这个决定后呢，又总是觉着自己的选择是错误的，不能肯定自己。内心是非常矛盾的。\n\u0026emsp;懒惰是毁掉一个人的罪魁祸首，它让你逐渐的安于现状，丧失对未来拼搏的动力。我觉着自己是一个很懒惰的人，而又不是一个懒惰的人。很是矛盾吧！懒惰的背后是自己没什么奋斗目标，没什梦想，没什么理想，没什么信念。所以整个人是懒懒散散的。而每当自己有了一个奋斗的目标后，我会为之努力奋斗，整个人的状态像是上了劲的发条，充满干劲。\n\u0026emsp;我是一个完美主义者，和强迫症晚期的人，我会尽量的把自己的每一项工作和目标完成的很完美。当天的事情必须完成，什么时候完成什么时候睡觉，绝不会留到第二天，有些人可能不会理解这一点，但这确确实实是发生在我身上的。人是一个复杂的动物，真是因为这些完美的和不完美的，才构成了一个第一无二的自己。我希望呢，每个人都应该得认识自己，了解自己，知道自己的不足，知道自己想要什么，尽量让自己活得明白一点。而未来是属于我们的，时间会洗涤一切，现时的烦恼是阻挡不了自己前进的脚步的。几年后的自己回看现在的自己就像现在的自己回看过去的自己一样，肯定会觉得自己那个时候怎么那么的幼稚，可笑。\n\u0026emsp;也是希望自己在回首往事的时，不因虚度年华而悔恨，也不因碌碌无为而羞愧。珍惜当下的时间，做自己该做的事情，充实自己的脑袋，多思考，未来的你会感谢现在这样拼搏的你。\n\u0026emsp;下面给大家分享一段话，这段话，感觉还是很适合现在的自己。\n 每天认真洗脸，多读书，按时睡，少食多餐，变得温柔，大度，继续善良，保持爱心。不在人前矫情，四处诉说以求宽慰，而是学会一个人静静面对，自己把道理想通。这样的你，暂时单身也无所谓啊，你那么虔诚的做更好的自己，一定会遇到最好的，而那个人也一定值得你所有等待。\n ","id":46,"section":"posts","summary":"记录自己的第一篇博客 \u0026emsp;2019-10-31，抓住10月的小尾巴，创建了人生的第一个博客。经过一天的努力，终于是在22：13的时候创","tags":["日记"],"title":"自己的第一篇博客","uri":"https://mumulx.github.io/2019/10/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","year":"2019"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }","id":47,"section":"posts","summary":"\u003cp\u003eEmoji can be enabled in a Hugo project in a number of ways.\u003c/p\u003e","tags":["杂七杂八"],"title":"Emoji Support","uri":"https://mumulx.github.io/2019/01/emoji-support/","year":"2019"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline\u0026nbsp;\u0026nbsp;\u0026nbsp; Markdown\u0026nbsp;\u0026nbsp;\u0026nbsp; In\u0026nbsp;\u0026nbsp;\u0026nbsp; Table     italics bold strikethrough\u0026nbsp;\u0026nbsp;\u0026nbsp; code    Code Blocks Code block with backticks html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. ↩  ","id":48,"section":"posts","summary":"\u003cp\u003eThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","tags":["杂七杂八"],"title":"Markdown Syntax Guide","uri":"https://mumulx.github.io/2019/01/markdown-syntax/","year":"2019"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt  The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","id":49,"section":"posts","summary":"\u003cp\u003eLorem est tota propiore conpellat pectoribus de\npectora summo.\u003c/p\u003e","tags":["杂七杂八"],"title":"Placeholder Text","uri":"https://mumulx.github.io/2019/01/placeholder-text/","year":"2019"}],"tags":[{"title":"J2EE","uri":"https://mumulx.github.io/tags/j2ee/"},{"title":"Java","uri":"https://mumulx.github.io/tags/java/"},{"title":"Java并发编程","uri":"https://mumulx.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"title":"Linux","uri":"https://mumulx.github.io/tags/linux/"},{"title":"node","uri":"https://mumulx.github.io/tags/node/"},{"title":"Spring家族","uri":"https://mumulx.github.io/tags/spring%E5%AE%B6%E6%97%8F/"},{"title":"中间件","uri":"https://mumulx.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"title":"其他问题","uri":"https://mumulx.github.io/tags/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/"},{"title":"前端框架","uri":"https://mumulx.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"title":"开发软件","uri":"https://mumulx.github.io/tags/%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6/"},{"title":"数据库","uri":"https://mumulx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"日记","uri":"https://mumulx.github.io/tags/%E6%97%A5%E8%AE%B0/"},{"title":"杂七杂八","uri":"https://mumulx.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"title":"版本控制","uri":"https://mumulx.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}]}