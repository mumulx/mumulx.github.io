<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>
        Java设计模式 - 木木的个人博客
      </title>
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  
  <meta name="theme-color" content="#000000" />
  
  <meta http-equiv="window-target" content="_top" />
  
  
  <meta name="description" content="Java设计模式." />
  <meta name="generator" content="Hugo 0.59.1 with theme pure" />
  <title>Java设计模式 - 木木的个人博客</title>
  

  <link rel="stylesheet" href="https://mumulx.github.io/css/style.css">
  <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.15.10/styles/github.min.css"> 
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <meta property="og:title" content="Java设计模式" />
<meta property="og:description" content="Java设计模式." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mumulx.github.io/2020/05/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />
<meta property="article:published_time" content="2020-05-21T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-05-21T00:00:00+00:00" />

<meta itemprop="name" content="Java设计模式">
<meta itemprop="description" content="Java设计模式.">


<meta itemprop="datePublished" content="2020-05-21T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-05-21T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="11152">



<meta itemprop="keywords" content="Java," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java设计模式"/>
<meta name="twitter:description" content="Java设计模式."/>

  <!--[if lte IE 9]>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
    <![endif]-->

  <!--[if lt IE 9]>
      <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
    <![endif]-->

</head>
  </head>
  

  <body class="main-center" itemscope itemtype="https://schema.org/WebPage"><header class="header" itemscope itemtype="https://schema.org/WPHeader">
    <div class="slimContent">
      <div class="navbar-header">
        <div class="profile-block text-center">
          <a id="avatar" href="https://github.com/mumulx" target="_blank">
            <img class="img-circle img-rotate" src="https://mumulx.github.io/avatar.png" width="200" height="200">
          </a>
          <h2 id="name" class="hidden-xs hidden-sm">木木就是两个木</h2>
          <h3 id="title" class="hidden-xs hidden-sm hidden-md">木木</h3>
          <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i>xuzhou, China</small>
        </div><div class="search" id="search-form-wrap">
    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i
                        class="icon icon-search"></i></button>
            </span>
        </div>
        <div class="ins-search">
            <div class="ins-search-mask"></div>
            <div class="ins-search-container">
                <div class="ins-input-wrapper">
                    <input type="text" class="ins-search-input" placeholder="想要查找什么..."
                        x-webkit-speech />
                    <button type="button" class="close ins-close ins-selectable" data-dismiss="modal"
                        aria-label="Close"><span aria-hidden="true">×</span></button>
                </div>
                <div class="ins-section-wrapper">
                    <div class="ins-section-container"></div>
                </div>
            </div>
        </div>
    </form>
</div>
        <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
      <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="https://schema.org/SiteNavigationElement" role="navigation">
        <ul class="nav navbar-nav main-nav">
            <li class="menu-item menu-item-home">
                <a href="/">
                    <i class="icon icon-home-fill"></i>
                  <span class="menu-title">Home</span>
                </a>
            </li>
            <li class="menu-item menu-item-archives">
                <a href="/posts">
                    <i class="icon icon-archives-fill"></i>
                  <span class="menu-title">Archives</span>
                </a>
            </li>
            <li class="menu-item menu-item-categories">
                <a href="/categories">
                    <i class="icon icon-folder"></i>
                  <span class="menu-title">Categories</span>
                </a>
            </li>
            <li class="menu-item menu-item-tags">
                <a href="/tags">
                    <i class="icon icon-tags"></i>
                  <span class="menu-title">Tags</span>
                </a>
            </li>
            <li class="menu-item menu-item-about">
                <a href="/about">
                    <i class="icon icon-cup-fill"></i>
                  <span class="menu-title">About</span>
                </a>
            </li>
        </ul>
      </nav>
    </div>
  </header>
  <aside class="sidebar" itemscope itemtype="https://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content"><p>我们的征途是星辰大海！</p>
            </div>
        </div>
    </div>
</div>

      <div class="widget">
    <h3 class="widget-title"> 分类</h3>
    <div class="widget-body">
        <ul class="category-list">
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/java%E9%9D%A2%E8%AF%95/" class="category-list-link">java面试</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/%E6%8A%80%E6%9C%AF%E6%94%B6%E5%BD%95/" class="category-list-link">技术收录</a><span class="category-list-count">28</span></li>
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/" class="category-list-link">技术框架</a><span class="category-list-count">13</span></li>
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" class="category-list-link">杂七杂八</a><span class="category-list-count">10</span></li>
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/" class="category-list-link">私人博客</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95/" class="category-list-link">问题收录</a><span class="category-list-count">2</span></li>
        </ul>
    </div>
</div>
      <div class="widget">
    <h3 class="widget-title"> 标签</h3>
    <div class="widget-body">
        <ul class="tag-list">
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/j2ee/" class="tag-list-link">j2ee</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/java/" class="tag-list-link">java</a><span
                    class="tag-list-count">12</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="tag-list-link">java并发编程</a><span
                    class="tag-list-count">5</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/linux/" class="tag-list-link">linux</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/node/" class="tag-list-link">node</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/spring%E5%AE%B6%E6%97%8F/" class="tag-list-link">spring家族</a><span
                    class="tag-list-count">12</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="tag-list-link">中间件</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/" class="tag-list-link">其他问题</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" class="tag-list-link">前端框架</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6/" class="tag-list-link">开发软件</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="tag-list-link">数据库</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E6%97%A5%E8%AE%B0/" class="tag-list-link">日记</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" class="tag-list-link">杂七杂八</a><span
                    class="tag-list-count">11</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" class="tag-list-link">版本控制</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E7%AE%97%E6%B3%95/" class="tag-list-link">算法</a><span
                    class="tag-list-count">2</span></li>
            
        </ul>

    </div>
</div>
      
<div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
        <ul class="recent-post-list list-unstyled no-thumbnail">
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.github.io/2020/10/java%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/" class="title">Java底层知识汇总</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-10-09 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-10-09</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.github.io/2020/08/java%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="title">Java算法笔记</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-08-13 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-08-13</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.github.io/2020/08/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B8%80/" class="title">Java面试准备一</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-08-13 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-08-13</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.github.io/2020/08/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/" class="title">背包九讲问题汇总</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-08-13 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-08-13</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.github.io/2020/06/tc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="title">Teamcenter定制学习笔记</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-06-21 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-06-21</time>
                    </p>
                </div>
            </li>
        </ul>
    </div>
</div>
  </div>
</aside>

    
    
  <aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="https://schema.org/WPSideBar">
    <div class="slimContent">
      <nav id="toc" class="article-toc">
        <h3 class="toc-title">文章目录</h3>
        <div class="toc-content always-active"><nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#学习路线-掌握">学习路线（掌握）</a>
<ul>
<li><a href="#java语法">JAVA语法</a>
<ul>
<li><a href="#java基础">Java基础</a></li>
<li><a href="#jvm">JVM</a></li>
<li><a href="#多线程">多线程</a></li>
<li><a href="#数据结构">数据结构</a></li>
<li><a href="#算法">算法</a></li>
</ul></li>
<li><a href="#计算机网络">计算机网络</a></li>
<li><a href="#mysql数据库">MySQL数据库</a></li>
<li><a href="#操作系统">操作系统</a></li>
<li><a href="#设计模式">设计模式</a></li>
</ul></li>
</ul></li>
<li><a href="#模式类别">模式类别</a></li>
<li><a href="#单例模式">单例模式</a></li>
<li><a href="#工厂模式">工厂模式</a>
<ul>
<li><a href="#简单工厂模式">简单工厂模式</a></li>
<li><a href="#工厂方法模式">工厂方法模式</a></li>
</ul></li>
<li><a href="#抽象工厂模式">抽象工厂模式</a></li>
<li><a href="#建造者模式">建造者模式</a></li>
<li><a href="#原型模式">原型模式</a></li>
<li><a href="#适配器模式">适配器模式</a></li>
<li><a href="#代理模式">代理模式</a>
<ul>
<li><a href="#静态代理">静态代理</a>
<ul>
<li><a href="#加深理解">加深理解</a></li>
</ul></li>
<li><a href="#动态代理">动态代理</a>
<ul>
<li><a href="#万能代理">万能代理</a></li>
</ul></li>
</ul></li>
<li><a href="#桥接模式">桥接模式</a></li>
</ul>
</nav>
        </div>
      </nav>
    </div>
  </aside>
<main class="main" role="main"><div class="content">
  <article id="-" class="article article-type-" itemscope
    itemtype="https://schema.org/BlogPosting">
    
    <div class="article-header">
      <h1 itemprop="name">
  <a
    class="article-title"
    href="/2020/05/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
    >Java设计模式</a
  >
</h1>

      <div class="article-meta">
        <span class="article-date">
  <i class="icon icon-calendar-check"></i>
<a href="https://mumulx.github.io/2020/05/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-05-21 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-05-21</time>
</a>
</span><span class="article-category">
  <i class="icon icon-folder"></i>
  <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E6%94%B6%E5%BD%95/"> 技术收录 </a>
</span>  
  <span class="article-tag">
    <i class="icon icon-tags"></i>
    <a class="article-tag-link" href="/tags/java/"> Java </a>
  </span>

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/05/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#comments"
            class="article-comment-link">评论</a></span>
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计:11152字</span>
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长:23分 </span>
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      

<h2 id="学习路线-掌握">学习路线（掌握）</h2>

<h3 id="java语法">JAVA语法</h3>

<h4 id="java基础">Java基础</h4>

<h4 id="jvm">JVM</h4>

<ul>
<li>类加载机制</li>
<li>字节码执行机制</li>
<li>JVM内存模型</li>
<li>GC垃圾回收</li>
<li>JVM性能监控与故障定位</li>
<li>JVM调优</li>
</ul>

<h4 id="多线程">多线程</h4>

<ul>
<li>并发编程的基础</li>
<li>线程池</li>
<li>锁</li>
<li>并发容器</li>
<li>原子类</li>
<li>JUC并发工具类### 数据结构和算法</li>
</ul>

<h4 id="数据结构">数据结构</h4>

<ul>
<li>字符串</li>
<li>数组</li>
<li>链表</li>
<li>堆、栈、队列</li>
<li>二叉树</li>
<li>哈希</li>
<li>图</li>
</ul>

<h4 id="算法">算法</h4>

<ul>
<li><p>排序</p></li>

<li><p>查找</p></li>

<li><p>贪心</p></li>

<li><p>分治</p></li>

<li><p>动态规划</p></li>

<li><p>回溯</p></li>
</ul>

<h3 id="计算机网络">计算机网络</h3>

<ul>
<li>ARP协议</li>
<li>IP、ICMP协议</li>
<li>TCP、UDP协议</li>
<li>DNS、HTTP/HTTPS协议</li>
<li>Session/Cookie</li>
</ul>

<h3 id="mysql数据库">MySQL数据库</h3>

<ul>
<li>SQL语句的书写</li>
<li>SQL语句的优化</li>
<li>事务、隔离级别</li>
<li>索引</li>
<li>锁</li>
</ul>

<h3 id="操作系统">操作系统</h3>

<ul>
<li>进程、线程</li>
<li>并发、锁</li>
<li>内存管理和调度</li>
<li>I/O原理</li>
</ul>

<h3 id="设计模式">设计模式</h3>

<ul>
<li>单例</li>
<li>工厂</li>
<li>代理</li>
<li>策略</li>
<li>模板方法</li>
<li>观察者</li>
<li>适配器</li>
<li>责任链</li>
<li>建造者</li>
</ul>

<h1 id="模式类别">模式类别</h1>

<ul>
<li>创建型模式:

<ul>
<li>单例模式</li>
<li>工厂模式</li>
<li>抽象工厂模式</li>
<li>建造者模式</li>
<li>原型模式</li>
</ul></li>
<li>结构型模式:

<ul>
<li>适配器模式</li>
<li>桥接模式</li>
<li>装饰模式</li>
<li>组合模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>代理模式</li>
</ul></li>
<li>行为型模式:

<ul>
<li>模板方法模式</li>
<li>命令模式</li>
<li>迭代器模式</li>
<li>观察者模式</li>
<li>中介者模式</li>
<li>备忘录模式</li>
<li>解释器模式</li>
<li>状态模式</li>
<li>策略模式</li>
<li>职责链模式</li>
<li>访问者模式</li>
</ul></li>
</ul>

<h1 id="单例模式">单例模式</h1>

<p>在JUC中有详细介绍</p>

<p><a href="https://mumulx.github.io/2020/05/juc/#18-%E5%BD%BB%E5%BA%95%E7%8E%A9%E8%BD%AC%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">彻底玩转单例模式</a></p>

<h1 id="工厂模式">工厂模式</h1>

<p><strong>作用:</strong></p>

<ul>
<li>实现了创建者和调用者的分离</li>
<li>详细分类:

<ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul></li>
</ul>

<p><strong>OOP七大原则</strong></p>

<ul>
<li>开闭原则: -个软件的实体应当对扩展开放,对修改关闭</li>
<li>依赖倒转原则:要针对接口编程，不要针对实现编程</li>
<li>迪米特法则:只与你直接的朋友通信，而避免和陌生人通信</li>
</ul>

<p><strong>PBP/OBP/OOP的特征</strong>
PBP（基于过程）：函数、域与生命周期的概念、函数重载、函数模板、异常处理、范型算法。
OBP（基于对象）：类（接口）、类的生命周期、类模板。
OOP（面向对象）：继承、多态。
三个概念步步深入，后者包括前者。其目的是实现软件开发的可重用性，解决软件危机（软件工程思想未引入之前）。
OOP不可避免设计原则的发展与设计模式的产生，这是OOP独具的特征决定的（正如前面所说，特征的产生是由其产生目的决定的）。</p>

<p><strong>OOP的方法论（高内聚、低耦合、易复用）</strong>
OOP的方法论－－如何实现基于OOP特征的抽象?</p>

<p><strong>OOP设计原则</strong>：</p>

<p><strong>OCP（Open-Closed Principle），开放封闭原则</strong>：软件实体应该扩展开放、修改封闭。
实现：合理划分构件，一种可变性不应当散落在代码的很多角落里，而应当被封装到一个对象里；一种可变性不应当与另一个可变性混合在一起。</p>

<p><strong>DIP(Dependency Inversion Principle)，依赖倒置原则：</strong>摆脱面向过程编程思想中高层模块依赖于低层实现，抽象依赖于具体细节。OOP中要做到的是，高层模块不依赖于低层模块实现，二者都依赖于抽象；抽象不依赖于具体实现细节，细节依赖于抽象。
实现：应该通过抽象耦合的方式，使具体类最大可能的仅与其抽象类（接口）发生耦合；程序在需要引用一个对象时,应当尽可能的使用抽象类型作为变量的静态类型,这就是针对接口编程的含义。</p>

<p><strong>LSP(Liskov Substitution Principle)，Liskov替换原则：</strong>继承思想的基础。“只有当衍生类可以替换掉基类，软件单位的功能不会受到影响时，基类才真正被复用，而衍生类也才能够在基类的基础上增加新的行为。”</p>

<p><strong>ISP（Interface Insolation Principle），接口隔离原则：</strong>接口功能单一，避免接口污染。
实现：一个类对另外一个类的依赖性应当是建立在最小的接口上的。<strong>使用多个专门的接口比使用单一的总接口要好。</strong></p>

<p><strong>SRP(Single Resposibility Principle)，单一职责原则：</strong>就一个类而言，应该仅有一个引起它变化的原因。 如果一个类的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会抑止这个类完成其他职责的能力。</p>

<p><strong>CARP（Composite/Aggregate Reuse Principle），合成/聚合复用原则：</strong>设计模式告诉我们对象委托优于类继承，从UML的角度讲，就是关联关系优于继承关系。尽量使用合成/聚合、尽量不使用继承。
实现：在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，以整合其功能。</p>

<p><strong>LoD(Law Of Demeter or Principle of Least Knowledge)，迪米特原则或最少知识原则：</strong>就是说一个对象应当对其他对象尽可能少的了解。即只直接与朋友通信，或者通过朋友与陌生人通信。
朋友的定义（或关系）：
（1）当前对象本身。
（2）以参量的形式传入到当前对象方法中的对象。
（3）当前对象的实例变量直接引用的对象。
（4）当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友。
（5）当前对象所创建的对象。
实现：
（1）在类的划分上，应当创建有弱耦合的类。类之间的耦合越弱，就越有利于复用。
（2）在类的结构设计上，每一个类都应当尽量降低成员的访问权限。一个类不应当public自己的属性，而应当提供取值和赋值的方法让外界间接访问自己的属性。
（3）在类的设计上，只要有可能，一个类应当设计成不变类。
（4）在对其它对象的引用上，一个类对其它对象的引用应该降到最低。
（5）尽量限制局部变量的有效范围.</p>

<blockquote>
<p>核心本质:</p>
</blockquote>

<ul>
<li>实例化对象不使用new,用工厂方法代替</li>
<li>将选择实现类, 创建对象统一管理和控制。 从而将调用者跟我们的实现类解耦。</li>
</ul>

<blockquote>
<p>三种模式:</p>
</blockquote>

<ul>
<li>简单工厂模式

<ul>
<li>用来生产同一等级结构中的任意产品(对于增加新的产品，需要覆盖已有代码)</li>
</ul></li>
<li>工厂方法模式

<ul>
<li>用来生产同一等级结构中的固定产品(支持增加任意产品)</li>
</ul></li>
<li>抽象工厂模式

<ul>
<li>围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。</li>
</ul></li>
</ul>

<p>XXXXFactory</p>

<h2 id="简单工厂模式">简单工厂模式</h2>

<pre><code class="language-java">
public interface Car {
    void name();
}

</code></pre>

<pre><code class="language-java">public class Tesla implements Car {
    @Override
    public void name() {
        System.out.println(&quot;Tesla!!&quot;);
    }
}

</code></pre>

<pre><code class="language-java">public class WuLing implements Car{


    @Override
    public void name() {
        System.out.println(&quot;五菱宏光！&quot;);
    }
}

</code></pre>

<pre><code class="language-java">//简单工厂又叫做静态工厂，因为其中的方法都是静态的
//增加一个新的产品，如果你不修改代码，做不到!
//开闭原则
public class CarFactory {

    /*方法一：车工厂，去里面拿车*/
    public static Car getCar(String car) {
        if (car.equals(&quot;五菱&quot;)) {
            return new WuLing();
        } else if (car.equals(&quot;特斯拉&quot;)) {
            return new Tesla();
        } else {
            return null;
        }
    }
    //方法二
    public  static Car getWuling(){
        return new WuLing();
    }
    public static Car getTesla(){
        return new Tesla();
    }
}
</code></pre>

<pre><code class="language-java">public class Consumer {
    public static void main(String[] args) {
        /*买车
        接口，所有的实现类！我们要直到Car接口及其实现类
        * 我们买车的时候只需要去买某种车，而不需要关注有那些车
        *
        Car car = new WuLing();
        Car car2 = new Tesla();
        car.name();
        car2.name(); */
          /*使用工厂创建*/
        Car car1 = CarFactory.getCar(&quot;五菱&quot;);
    }
}

</code></pre>

<p><img src="/resources/技术收录/Java/Java设计模式/image-20200519230335065.png" alt="image-20200519230335065" /></p>

<h2 id="工厂方法模式">工厂方法模式</h2>

<pre><code class="language-java">public interface Car {
    void name();
}

</code></pre>

<pre><code class="language-java">public class Tesla implements Car {
    @Override
    public void name() {
        System.out.println(&quot;Tesla!!&quot;);
    }
}

</code></pre>

<pre><code class="language-java">public class WuLing implements Car {
    @Override
    public void name() {
        System.out.println(&quot;五菱宏光！&quot;);
    }
}

</code></pre>

<pre><code class="language-java">public interface CarFactor {
    Car getCar();
}
</code></pre>

<pre><code class="language-java">public class TeslaFactory implements CarFactor {
    @Override
    public Car getCar() {
        return new Tesla();
    }
}
</code></pre>

<pre><code class="language-java">public class WulingFactory implements  CarFactor {
    @Override
    public Car getCar() {
        return new WuLing();
    }
}
</code></pre>

<pre><code class="language-java">public class Consumer {
    public static void main(String[] args) {
        Car car = new WulingFactory().getCar();
        Car car1 = new TeslaFactory().getCar();
        System.out.println(car);
        System.out.println(car1);
    }
}
</code></pre>

<p><img src="/resources/技术收录/Java/Java设计模式/image-20200519230941248.png" alt="image-20200519230941248" /></p>

<table>
<thead>
<tr>
<th>结构复杂度:</th>
<th>simple</th>
</tr>
</thead>

<tbody>
<tr>
<td>代码复杂度</td>
<td>simple</td>
</tr>

<tr>
<td>编程复杂度:</td>
<td>simple</td>
</tr>

<tr>
<td>管理上的复杂度</td>
<td>simple</td>
</tr>
</tbody>
</table>

<p>根据设计原则:工厂方法模式!
根据实际业务:简单工厂模式!</p>

<p>小结:</p>

<ul>
<li><p>简单工厂模式(静态工厂模式)</p>

<ul>
<li>虽然某种程度上不符合设计原则，但实际使用最多!</li>
</ul></li>

<li><p>工厂方法模式</p>

<ul>
<li>不修改已有类的前提下，通过增加新的工厂类实现扩展。</li>
</ul></li>

<li><p>抽象工厂 模式</p>

<ul>
<li>不可以增加产品，可以增加产品族!</li>
</ul></li>
</ul>

<p>应用场景:</p>

<ul>
<li>JDK中Calendar的getInstance方法</li>
<li>JDBC中的Connection对象的获取</li>
<li>Spring中IOC容器创建管理bean对象</li>
<li>反射中Class对象的newInstance方法</li>
</ul>

<h1 id="抽象工厂模式">抽象工厂模式</h1>

<p>定义:抽象工厂模式提供了一个创建一系列相关或者相互依赖对象的接口，无需指定它们具体的类</p>

<p>适用场景:</p>

<ul>
<li>客户端(应用层)不依赖于产品类实例如何被创建、实现等细节</li>
<li>强调一系列相关的产品对象(属于同一产品族) 一起使用创建对象需要大量的重复代码</li>
<li>提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体的实现</li>
</ul>

<p>优点:</p>

<ul>
<li>具体产品在应用层的代码隔离，无需关心创建的细节</li>
<li>将一个系列的产品统一到一起创建</li>
</ul>

<p>缺点:</p>

<ul>
<li>规定了所有可能被创建的产品集合，产品簇中扩展新的产品困难;</li>
<li>增加了系统的抽象性和理解难度</li>
</ul>

<p><img src="/resources/技术收录/Java/Java设计模式/image-20200519224144512.png" alt="image-20200519224144512" /></p>

<pre><code class="language-java">//手机产品接口
public interface IphoneProduct {
    void start();

    void shutdown();

    void callup();

    void sendsms();
}
</code></pre>

<pre><code class="language-java">//路由器接口
public interface IrouterProduct {

    void start() ;

    void shutdown();

    void openwifi();

    void setting();
}
</code></pre>

<pre><code class="language-java">public class XiaomiPhone implements IphoneProduct {
    @Override
    public void start() {
        System.out.println(&quot;开启小米手机&quot;);
    }
    @Override
    public void shutdown() {
        System.out.println(&quot;小米手机关机&quot;);
    }
    @Override
    public void callup() {
        System.out.println(&quot;小米手机打电话&quot;);
    }
    @Override
    public void sendsms() {
        System.out.println(&quot;小米手机发短信&quot;);
    }
}
</code></pre>

<pre><code class="language-java">public class XiaomiRouter implements IrouterProduct {
    @Override
    public void start() {
        System.out.println(&quot;小米路由器启动&quot;);
    }
    @Override
    public void shutdown() {
        System.out.println(&quot;小米路由器关闭&quot;);
    }
    @Override
    public void openwifi() {
        System.out.println(&quot;小米路由器打开wifi&quot;);
    }
    @Override
    public void setting() {
        System.out.println(&quot;小米路由器设置&quot;);
    }
}
</code></pre>

<pre><code class="language-java">public class HuaWeiPhone implements IphoneProduct {
    @Override
    public void start() {
        System.out.println(&quot;华为手机开启&quot;);
    }
    @Override
    public void shutdown() {
        System.out.println(&quot;华为手机关机&quot;);
    }
    @Override
    public void callup() {
        System.out.println(&quot;华为手机打电话&quot;);
    }
    @Override
    public void sendsms() {
        System.out.println(&quot;华为手机发短信&quot;);
    }
}

</code></pre>

<pre><code class="language-java">public class HuaWeiRouter implements IrouterProduct {
    @Override
    public void start() {
        System.out.println(&quot;华为路由器开启&quot;);
    }
    @Override
    public void shutdown() {
        System.out.println(&quot;华为路由器关闭&quot;);
    }
    @Override
    public void openwifi() {
        System.out.println(&quot;华为路由器开启wifi&quot;);
    }
    @Override
    public void setting() {
        System.out.println(&quot;华为路由器设置&quot;);
    }
}

</code></pre>

<pre><code class="language-java">//抽象产品工厂
public interface IProductFactory {
    //生产手机
    IphoneProduct iphoneProduct();

    //生产路由器
    IrouterProduct irouterProduct();
}
</code></pre>

<pre><code class="language-java">public class XiaomiFactory implements IProductFactory {
    @Override
    public IphoneProduct iphoneProduct() {
        return new XiaomiPhone();
    }
    @Override
    public IrouterProduct irouterProduct() {
        return new XiaomiRouter();
    }
}

</code></pre>

<pre><code class="language-java">public class HuaWeiFactory implements IProductFactory {
    @Override
    public IphoneProduct iphoneProduct() {
        return new HuaWeiPhone();
    }
    @Override
    public IrouterProduct irouterProduct() {
        return new HuaWeiRouter();
    }
}

</code></pre>

<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        System.out.println(&quot;=====================小米系类产品&quot;);
        
        XiaomiFactory xiaomiFactory = new XiaomiFactory();
        IphoneProduct iphoneProduct = xiaomiFactory.iphoneProduct();
        iphoneProduct.start();
        IrouterProduct irouterProduct = xiaomiFactory.irouterProduct();
        irouterProduct.start();

        System.out.println(&quot;==================华为系列产品&quot;);
        
        HuaWeiFactory huaWeiFactory = new HuaWeiFactory();
        IphoneProduct iphoneProduct1 = huaWeiFactory.iphoneProduct();
        iphoneProduct1.start();
        IrouterProduct irouterProduct1 = huaWeiFactory.irouterProduct();
        irouterProduct1.start();
    }
}
</code></pre>

<h1 id="建造者模式">建造者模式</h1>

<p>建造者模式也属于创建型模式,它提供了一种创建对象的最佳方式。</p>

<p>定义:将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p>

<p>主要作用:在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。</p>

<p>用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象(把内部的建造过程和细
节隐藏起来)</p>

<p>例子:</p>

<ul>
<li>工厂(建造者模式) :负责制造汽车(组装过&gt;程和细节在工厂内)</li>
<li>汽车购买者(用户) :你只需要说出你需要的&gt;型号(对象的类型和内容)，然后直接购买就可以使用了(不需要知道汽车是怎么组装的 (车轮、车门、&gt;发动机、方向盘等等) )</li>
</ul>

<p>既然是建造者模式，那么我们还是继续造房吧，其实我也想不到更简单的例子。假设造房简化为如下步骤:
(1)地基(2) 钢筋工程(3)铺电线(4) 粉刷; &ldquo;如果”要盖一座房子，首先要找一个建筑公司或工程
承包商(指挥者)。承包商指挥工人(具体建造者)过来造房子(产品) ，最后验收。</p>

<pre><code class="language-java">public abstract class Builder {

    abstract void buildA();//地基
    abstract void buildB();//钢筋工程
    abstract void buildC();//铺电线
    abstract void buildD();//粉刷
    //完工了
    abstract Product getProject();
}

</code></pre>

<pre><code class="language-java">@Setter
@Getter
@ToString
public class Product {

    private String buildA;
    private String buildB;
    private String buildC;
    private String buildD;

}

</code></pre>

<pre><code class="language-java">//具体的工人；具体的建造者
public class Worker extends Builder {
    //产品
    private Product product;
    public Worker(){
        //使用new创建，而不是通过参数传递
        product = new Product();
    }




    @Override
    void buildA() {
        product.setBuildA(&quot;地基&quot;);

    }

    @Override
    void buildB() {

        product.setBuildB(&quot;B&quot;);
    }

    @Override
    void buildC() {
        product.setBuildC(&quot;C&quot;);
    }

    @Override
    void buildD() {
        product.setBuildD(&quot;D&quot;);
    }

    @Override
    Product getProject() {
        return product;
    }
}
</code></pre>

<pre><code class="language-java">//指挥:核心。负责指挥构建一一个工程， 工程如何构建，由它决定
public class Director {

    public Product build(Builder builder){
        //指挥工人建房子
        builder.buildA();
        builder.buildB();
        builder.buildC();
        builder.buildD();
        return builder.getProject();
    }
}

</code></pre>

<pre><code class="language-java">public class Test {
    public static void main(String[] args) {

        //指挥
        Director director = new Director();
        //指挥 具体的工人完成产品
        Product build = director.build(new Worker());

        System.out.println(build);

    }
}

</code></pre>

<p>上面示例是Builder模式的常规用法，导演类Director在Builder模式中具有很重要的作用，它用于指导具
体构建者如何构建产品，控制调用先后次序,并向调用者返回完整的产品类,但是有些情况下需要简化系统
结构，可以把Director和抽象建造者进行结合。</p>

<p>通过静态内部类方式实现零件无序装配构造,这种方式使用更加灵活，更符合定义。内部有复杂对象的默认
实现，使用时可以根据用户需求自由定义更改内容,并且无需改变具体的构造方式。就可以生产出不同复杂
产品</p>

<p>比如:比如麦当劳的套餐，服务员(具体建造者)可以随意搭配任意几种产品(零件)组成一款套餐(产
品)，然后出售给客户。比第一 种方式少了指挥者,主要是因为第二种方式把指挥者交给用户来操作,使得
产品的创建更加简单灵活。</p>

<pre><code class="language-java">public abstract class Builder {
    abstract Builder buildA(String msg);//汉堡
    abstract Builder buildB(String msg);//可乐
    abstract Builder buildC(String msg);//薯条
    abstract Builder buildD(String msg);//甜点
    //生产了
    abstract Product getProject();
}
</code></pre>

<pre><code class="language-java">//套餐
@Setter
@Getter
@ToString
public class Product {
    //默认值
    private String buildA=&quot;汉堡&quot;;
    private String buildB=&quot;可乐&quot;;
    private String buildC=&quot;薯条&quot;;
    private String buildD=&quot;甜点&quot;;
}
</code></pre>

<pre><code class="language-java">//既是工人，又是指挥者
public class worker extends Builder {
    Product product;
    public worker(){
        product = new Product();
    }


    @Override
    Builder buildA(String msg) {
        product.setBuildB(msg);

        return this;
    }

    @Override
    Builder buildB(String msg) {
        product.setBuildA(msg);

        return this;
    }

    @Override
    Builder buildC(String msg) {
        product.setBuildC(msg);

        return this;
    }

    @Override
    Builder buildD(String msg) {
        product.setBuildD(msg);

        return this;
    }

    @Override
    Product getProject() {
        return product;
    }
}
</code></pre>

<pre><code class="language-java">public class Test {

    public static void main(String[] args) {
        //服务员
        worker worker = new worker();
        //具有产品的默认值   在原来的基础上可以自由组合了，如果不组合，也有默认的套餐
        //Product project = worker.getProject();
        //链式编程  return this的功劳
        Product project = worker
                            .buildA(&quot;AAAAAA&quot;)
                            .getProject();
        System.out.println(project);

    }
}

</code></pre>

<p>优点:</p>

<ul>
<li>产品的建造和表示分离，实现了解耦。使用建造者模式可以使客户端不必知道产品内部组成的细节。</li>
<li>将复杂产品的创建步骤分解在不同的方法中， 使得创建过程更加清晰</li>
<li>具体的建造者类之间是相互独立的，这有利于系统的扩展。增加新的具体建造者无需修改原有类库的代码，符合“开闭原则”。</li>
</ul>

<p>缺点:</p>

<ul>
<li>建造者模式所创建的产品一-般具有较多的共同点，其组成部分相似;如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一-定的限制。</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li>
</ul>

<p>应用场景:</p>

<ul>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象具备共性;</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li>
<li>适合于一个具有较多的零件(属性)的产品(对象)的创建过程。</li>
</ul>

<p>建造者与抽象工厂模式的比较:</p>

<ul>
<li>与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回-系列相关的产品，这些产品位于不同的产品等级结构,构成了一个产品族。</li>
<li>在抽象工厂模式中，客户端实例化工厂类,然后调用工厂方法获取所需产品对象,而在建造者模式中,客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于- -步步构造一个复杂对象, 返回-一个完整的对象。</li>
<li>如果将抽象工厂模式看成汽车配件生产工厂,生产- -个产品族的产品，那么建造者模式就是一个汽车组装工厂,通过对部件的组装可以返回一辆完整的汽车!</li>
</ul>

<h1 id="原型模式">原型模式</h1>

<p>克隆（在js的继承中有原型的概念）</p>

<pre><code class="language-java">/*
1. 实现一个接口
2. 重写一个方法
* **/
//Video:视频类
@Setter
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class Video implements Cloneable{
    private String name;
    private Date createTime;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
</code></pre>

<pre><code class="language-java">/*客户端 ：   克隆*/
public class BiliBili {

    public static void main(String[] args) throws CloneNotSupportedException {
        //原型对象
        Date date = new Date();

        Video v1 = new Video(&quot;hahah&quot;, date);

        System.out.println(&quot;v1====&gt;&quot;+v1);
        System.out.println(&quot;v1====&gt;hash&quot;+v1.hashCode());
        //v1可以克隆出v2
        Video v2 = (Video)v1.clone();
        System.out.println(&quot;v2====&gt;&quot;+v2);
        //克隆出来的对象是属性值一摸一样的（但是hashcode是不同的）
    }
}
</code></pre>

<p><img src="/resources/技术收录/Java/Java设计模式/image-20200520220932216.png" alt="image-20200520220932216" /></p>

<p>这样的克隆是浅克隆，不仅会将对象的值克隆过来也会将属性值的引用也克隆过来</p>

<p>当我们修改了v1属性date的时候会发现v2的date的值也会发生发了改变</p>

<p>深克隆方法一：改造clone方法</p>

<pre><code class="language-java">@Setter
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class Video implements Cloneable{
    private String name;
    private Date createTime;

    @Override
    protected Object clone() throws CloneNotSupportedException {

        //实现深克隆：或者使用序列化、反序列化
        Object obj = super.clone();
        Video v = (Video) obj;
        //将这个对象的属性也进行克隆
        v.createTime = (Date)this.createTime.clone();
        return obj;
    }
}

</code></pre>

<p><img src="/resources/技术收录/Java/Java设计模式/image-20200520221234630.png" alt="image-20200520221234630" /></p>

<p>在我们的spring框架中就体现了这点（Bean）：单例模式、原型模式</p>

<p>原型模式+工厂模式===&gt;new&lt;=&gt;原型模式clone</p>

<h1 id="适配器模式">适配器模式</h1>

<p>结构性模式作用：</p>

<p>从程序的结构上实现松耦合,从而可以扩大整体的类结构,用来解决更大的问题。</p>

<pre><code class="language-java">//要被适配的类： 网线（许多笔记本电脑没有网线接口，因此需要usb转接）
public class Adaptee {
    public void request() {
        System.out.println(&quot;连接网线上网&quot;);
    }
}

</code></pre>

<pre><code class="language-java">/**
 * 1. 继承（类适配器，单继承）
 * 2. 组合（对象适配器，常用）
 * */
//真正的适配器！，需要连接USB，连接上网线
public class Adapter extends Adaptee implements NetToUsb{
    @Override
    public void handleRequest() {
        super.request();//可以上网了
    }
}
</code></pre>

<pre><code class="language-java">//客户端类：想上网，插不上网线
public class Computer {
    //我们的电脑需要连接上转接器才可以上网
    public void net(NetToUsb adapter) {//插上一个转接头
        //上网的具体实现~，找一个转接头
        adapter.handleRequest();
    }
    public static void main(String[] args) {
        //电脑、适配器、网线~
        Computer computer = new Computer();//电脑
        Adaptee adaptee = new Adaptee();//网线
        Adapter adapter = new Adapter();//适配器
        computer.net(adapter);
    }
}
</code></pre>

<pre><code class="language-java">public interface NetToUsb {
    //作用：处理请求，网线===》usb
    public void handleRequest();
}
</code></pre>

<p>使用组合</p>

<pre><code class="language-java">public interface NetToUsb {
    //作用：处理请求，网线===》usb
    public void handleRequest();
}
</code></pre>

<pre><code class="language-java">/**
 * 1. 继承（类适配器，单继承）
 * 2. 组合（对象适配器，常用）
 * */
//真正的适配器！，需要连接USB，连接上网线
@AllArgsConstructor
public class Adapter implements NetToUsb{
    private Adaptee adaptee;

    @Override
    public void handleRequest() {
        adaptee.request();//可以上网了
    }
}

</code></pre>

<pre><code class="language-java">//要被适配的类： 网线（许多笔记本电脑没有网线接口，因此需要usb转接）
public class Adaptee {
    public void request() {
        System.out.println(&quot;连接网线上网&quot;);
    }
}
</code></pre>

<pre><code class="language-java">//客户端类：想上网，插不上网线
public class Computer {
    //我们的电脑需要连接上转接器才可以上网
    public void net(NetToUsb adapter) {//插上一个转接头
        //上网的具体实现~，找一个转接头
        adapter.handleRequest();
    }
    public static void main(String[] args) {
        //电脑、适配器、网线~
        Computer computer = new Computer();//电脑
        Adaptee adaptee = new Adaptee();//网线
        Adapter adapter = new Adapter(adaptee);//适配器
        computer.net(adapter);
    }
}
</code></pre>

<p>将一个类的接口转换成客户希望的另外一个接口。 Adapter模式使得原本由于接口不兼容而不能一起工作的
那些类可以在一起工作!</p>

<p>角色分析</p>

<ul>
<li>目标接口:客户所期待的接口，目标可以是具体的或抽象的类,也可以是接口。</li>
<li>需要适配的类: 需要适配的类或适配者类。</li>
<li>适配器:通过包装-一个需要适配的对象，把原接口转换成目标对象!</li>
</ul>

<p><img src="/resources/技术收录/Java/Java设计模式/image-20200520224059956.png" alt="image-20200520224059956" /></p>

<p>对象适配器优点</p>

<ul>
<li>一个对象适配器可以把多个不同的适配者适配到同一个目标</li>
<li>可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据&rdquo;里氏代换原则”，适配者的子类也可通过该适配器进行适配。</li>
</ul>

<p>类适配器缺点</p>

<ul>
<li>对于Java、 C#等不支持多重类继承的语言，一-次最 多只能适配一个适配者类，不能同时适配多个适配者;</li>
<li>在Java、 C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类,其使用有一定的局限性。</li>
</ul>

<p>适用场景</p>

<ul>
<li>系统需要使用一 -些现有的类，而这些类的接口(如方法名)不符合系统的需要，甚至没有这些类的源代码。</li>
<li>想创建一个可以重复使用的类，用于与- -些彼此之间没有太大关联的一-些类， 包括- -些可能在将来引进的类一起工作。</li>
</ul>

<p>优先使用组合方法</p>

<p>InputStreamReader(InputStream)使用了适配器</p>

<p>springMVC中就使用了适配器：处理器映射器、处理器适配器</p>

<p>GUI中也含有了许多适配器</p>

<p>springboot自动装配中也使用了许多适配器</p>

<h1 id="代理模式">代理模式</h1>

<p>为什么要学习代理模式?因为这就是SpringAOP的底层! [SpringAOP 和SpringMVC]</p>

<p>代理模式的分类:</p>

<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>

<p><img src="/resources/技术收录/Java/Java设计模式/image-20200520225045711.png" alt="image-20200520225045711" /></p>

<h2 id="静态代理">静态代理</h2>

<p>直接找房东租房</p>

<pre><code class="language-java">//房东
public class Host {
    public void rent() {
        System.out.println(&quot;房东要出租房间了&quot;);
    }
}
</code></pre>

<pre><code class="language-java">//我：要去租房
public class Client {
    public static void main(String[] args) {
        Host host = new Host();
        host.rent();
    }
}
</code></pre>

<p>代理</p>

<pre><code class="language-java">//我：要去租房
public class Client {
    public static void main(String[] args) {
        //房东要出租房子
        Host host = new Host();
        //代理，中介帮房东租房子，代理角色一般会有一些符数操作
        Proxy proxy = new Proxy(host);
        //你不要面对房东直接去租房即可
        proxy.rent();

    }
}

</code></pre>

<pre><code class="language-java">//中介
@AllArgsConstructor
public class Proxy implements Rent{
    private Host host;
    @Override
    public void rent() {
        seeHouse();
        host.rent();
        fare();
        hetong();
    }
    //看房
    public void seeHouse(){
        System.out.println(&quot;中介带你看房&quot;);
    }
    //收中介费
    public void fare() {
        System.out.println(&quot;收中介费&quot;);
    }
    //签租赁合同
    public void hetong() {
        System.out.println(&quot;签租赁合同&quot;);
    }
}
</code></pre>

<pre><code class="language-java">//房东
public class Host {
    public void rent() {
        System.out.println(&quot;房东要出租房间了&quot;);
    }
}
</code></pre>

<pre><code class="language-java">//租房的接口
public interface Rent {
    public void rent();
}
</code></pre>

<p>角色分析:</p>

<ul>
<li>抽象角色: 一般会使用接口或者抽象类来解决</li>
<li>真实角色:被代理的角色</li>
<li>代理角色:代理真实角色，代理真实角色后，我们一般会做一些附属操作</li>
<li>客户:访问代理对象的人!</li>
</ul>

<p>代理模式的好处:</p>

<ul>
<li>可以使真实角色的操作更加纯粹!不用去关注一些公共的业务</li>
<li>公共也就就交给代理角色!实现了业务的分工!</li>
<li>公共业务发生扩展的时候，方便集中管理!|</li>
</ul>

<p>缺点:</p>

<ul>
<li>一个真实角色就会产生一个代理角色;代码量会翻倍开发效率会变低</li>
</ul>

<p>代码步骤:</p>

<ol>
<li>接口</li>
<li>真实角色</li>
<li>代理角色</li>
<li>客户端访问代理角色</li>
</ol>

<h3 id="加深理解">加深理解</h3>

<pre><code class="language-java">public interface UserService {
    void add();
    void delete();
    void update();
    void query();
}
</code></pre>

<pre><code class="language-java">public class UserServiceImpl implements  UserService {
    @Override
    public void add() {
        System.out.println(&quot;add了一个用户&quot;);
    }
    @Override
    public void delete() {
        System.out.println(&quot;delete了一个用户&quot;);
    }
    @Override
    public void update() {
        System.out.println(&quot;update了一个用户&quot;);
    }
    @Override
    public void query() {
        System.out.println(&quot;query了一个用户&quot;);
    }
}
</code></pre>

<pre><code class="language-java">@Setter
public class UserServiceProxy implements UserService {
    UserService userService = new UserServiceImpl();
    @Override
    public void add() {
        msg(&quot;add&quot;);
        userService.add();
    }
    @Override
    public void delete() {
        msg(&quot;delete&quot;);
        userService.delete();
    }
    @Override
    public void update() {
        msg(&quot;update&quot;);
        userService.update();
    }
    @Override
    public void query() {
        msg(&quot;query&quot;);
        userService.query();
    }
    public void msg(String msg) {
        System.out.println(msg);
    }
}
</code></pre>

<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        UserService userService = new UserServiceImpl();
        //使用代理增加功能而不修改原有代码；只做增强，不做改变
        UserServiceProxy userServiceProxy = new UserServiceProxy();
        userServiceProxy.setUserService(userService);
        userServiceProxy.add();
    }
}
</code></pre>

<h2 id="动态代理">动态代理</h2>

<p>底层使用反射</p>

<ul>
<li>动态代理和静态代理角色一样</li>
<li>动态代理的代理类是动态生成的，不是我们直接写好的!</li>
<li>动态代理分为两大类:基于接口的动态代理，基于类的动态代理

<ul>
<li>基于接口&mdash;-JDK动态代理[我们在这里使用]</li>
<li>基于类: cglib</li>
<li>java字节码实现: javasist</li>
</ul></li>
</ul>

<p>需要了解两个类: Proxy: 代理，InvocationHandler: 调用处理程序</p>

<p><strong>InvocationHandler</strong></p>

<p><img src="/resources/技术收录/Java/Java设计模式/image-20200521164515889.png" alt="image-20200521164515889" /></p>

<p><img src="/resources/技术收录/Java/Java设计模式/image-20200521164615618.png" alt="image-20200521164615618" /></p>

<p><img src="/resources/技术收录/Java/Java设计模式/image-20200521164641357.png" alt="image-20200521164641357" /></p>

<p><strong>Proxy</strong></p>

<p><img src="/resources/技术收录/Java/Java设计模式/image-20200521164815426.png" alt="image-20200521164815426" /></p>

<pre><code class="language-java">//租房的接口
public interface Rent {
    public void rent();
}
</code></pre>

<pre><code class="language-java">//房东
public class Host implements Rent {
    @Override
    public void rent() {
        System.out.println(&quot;房东要出租房间了&quot;);
    }
}
</code></pre>

<pre><code class="language-java">//等会我们使用这个类，自动生成代理类
@Setter
@Getter
public class ProxyInvocationHandler implements InvocationHandler {
    //被代理的接口
    private Rent rent;
    //生成得到代理类
    public Object getProxy() {
/**
 *
 * this.getClass().getClassLoader():加载的类的位置
 * rent.getClass().getInterfaces()：要代理的接口
 * this：代表自己的InvocationHandler，调用InvocationHandler来处理
 * */
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(),this);
    }
    //处理代理实例，并返回结果
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        seeHouse();
        //动态代理的本质，就是使用反射机制来实现的
        Object invoke = method.invoke(rent, args);
        fare();
        return invoke;
    }
    public void seeHouse() {
        System.out.println(&quot;看房子啦~~&quot;);
    }
    public void fare() {
        System.out.println(&quot;收中介费了~~&quot;);
    }
}
</code></pre>

<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        //真实角色
        Host host = new Host();
        //代理角色：现在没有
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
        //通过调用程序处理角色来处理我们要调用的接口对象
        pih.setRent(host);
        //获得代理类rent
        Rent rent = (Rent)pih.getProxy();//这里的就是动态生成的，我们并没有写
        rent.rent();
    }
}
</code></pre>

<h3 id="万能代理">万能代理</h3>

<pre><code class="language-java">//等会我们使用这个类，自动生成代理类
@Setter
@Getter
public class ProxyInvocationHandler implements InvocationHandler {

    //被代理的接口
    private Object target;

    //生成得到代理类
    public Object getProxy() {

/**
 *
 * this.getClass().getClassLoader():加载的类的位置
 * rent.getClass().getInterfaces()：要代理的接口
 * this：代表自己的InvocationHandler，调用InvocationHandler来处理
 * */
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
    }
    //处理代理实例，并返回结果
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //动态代理的本质，就是使用反射机制来实现的
        Object invoke = method.invoke(target, args);
        return invoke;
    }

}
</code></pre>

<pre><code class="language-java">public class Cleint {

    public static void main(String[] args) {
        //真实角色
        UserService userService = new UserServiceImpl();
        //代理角色，不存在
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
        //设置要代理的对象
        pih.setTarget(userService);
        UserService proxy = (UserService)pih.getProxy();
        proxy.query();
    }
}

</code></pre>

<p>动态代理的好处:</p>

<ul>
<li>可以使真实角色的操作更加纯粹!不用去关注一些公共的业务</li>
<li>公共也就就交给代理角色!实现了业务的分工!</li>
<li>公共业务发生扩展的时候，方便集中管理!</li>
<li>一个动态代理类代理的是一一个接口， 一般就是对应的一类业务</li>
<li>一个动态代理类可以代理多个类,只要是实现了同一个接口即可!</li>
</ul>

<h1 id="桥接模式">桥接模式</h1>

<p>桥接模式是将抽象部分与它的实现部分分离,使它们都可以独立地变化。它是一种对象结构型模式， 又称为柄体(Handle and Body)模式或接口(Interfce)模式。</p>

<p><img src="/resources/技术收录/Java/Java设计模式/image-20200521185119368.png" alt="image-20200521185119368" /></p>

<p>分析:这个场景中有两个变化的维度:品牌、类型。</p>

<p><img src="/resources/技术收录/Java/Java设计模式/image-20200521185405746.png" alt="image-20200521185405746" /></p>

<p>抽象出两个类：品牌类、类型类</p>

<pre><code class="language-java">//品牌
public interface Brand {
    void info();
}
</code></pre>

<pre><code class="language-java">public class Apple implements Brand {
    @Override
    public void info() {
        System.out.println(&quot;苹果&quot;);
    }
}

</code></pre>

<pre><code class="language-java">public class Lenovo implements Brand {

    @Override
    public void info() {
        System.out.println(&quot;联想&quot;);
    }
}

</code></pre>

<pre><code class="language-java">//电脑类型 抽象的电脑类
@AllArgsConstructor
@Setter
@Getter
public class Computer {

    //组合，品牌~桥

    protected Brand brand;

    public void info(){
        brand.info();//电脑自带的品牌

    }

}

class Desktop extends Computer {

    public Desktop(Brand brand) {

        super(brand);
    }

    @Override
    public void info() {
        super.info();
        System.out.println(&quot;台式电脑&quot;);
    }
}

class Laptop extends Computer {

    public Laptop(Brand brand) {

        super(brand);
    }

    @Override
    public void info() {
        super.info();
        System.out.println(&quot;笔记本点啊弄&quot;);
    }
}

</code></pre>

<pre><code class="language-java">public class Test {
    public static void main(String[] args) {

        //苹果笔记本
        Computer computer = new Laptop(new Apple());
        computer.info();

        //联想笔记本
        Computer computer1 = new Desktop(new Lenovo());
        computer1.info();
    }
}

</code></pre>

<p><img src="/resources/技术收录/Java/Java设计模式/image-20200521191040543.png" alt="image-20200521191040543" /></p>

<p>好处分析:</p>

<ul>
<li>桥接模式偶尔类似于多继承方案，但是多继承方案违背了类的单- -职责原则，复用性比较差,类的个数也非常多，桥接模式是比多继承方案更好的解决方法。极大的减少了子类的个数，从而降低管理和维护的成本</li>
<li>桥接模式提高了系统的可扩充性,在两个变化维度中任意扩展一个维度, 都不需要修改原有系统。符合开闭原则，就像一座桥， 可以把两个变化的维度连接起来!</li>
</ul>

<p>劣势分析:</p>

<ul>
<li>桥接模式的弓|入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</li>
<li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</li>
</ul>

<p>最佳实践:</p>

<p>如果一个系统需要在构建的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立-个关联关系。抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将- -个抽象化子类的对象和一个实现化子类的对象进行组合,即系统需要对抽象化角色和实现化角色进行动态耦合。</p>

<ul>
<li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li>
<li>虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统,桥接模式尤为适用。</li>
</ul>

<p>场景:</p>

<ul>
<li>Java语言通过Java虚拟机实现了平台的无关性。</li>
<li>AWT中的Peer架构</li>
<li>JDBC驱动程序也是桥接模式的应用之一。</li>
</ul>

    </div>
    <div class="article-footer">
<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接: </strong>
      <a href="https://mumulx.github.io/2020/05/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="Java设计模式" target="_blank" rel="external">https://mumulx.github.io/2020/05/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a>
    </li>
    <li class="post-copyright-license">
      <strong>License：</strong><a href="https://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN</a>
    </li>
  </ul>
</blockquote>

<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/mumulx" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="https://mumulx.github.io/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/mumulx" target="_blank"><span class="text-dark">木木就是两个木</span><small class="ml-1x">木木</small></a></h3>
        <div>愿生活不太拥挤，愿笑容不必刻意。</div>
      </div>
    </figure>
  </div>
</div>
    </div>
  </article>
<section id="comments">
</section>

</div><nav class="bar bar-footer clearfix" data-stick-bottom>
    <div class="bar-inner">
        <ul class="pager pull-left">
            <li class="prev">
                <a href="https://mumulx.github.io/2020/05/java%E7%9F%A5%E8%AF%86%E7%82%B901/" title="Java知识点01"><i
                        class="icon icon-angle-left"
                        aria-hidden="true"></i><span>&nbsp;&nbsp;下一篇</span></a>
            </li>
            <li class="next">
                <a href="https://mumulx.github.io/2020/05/onjava8/"
                    title="OnJava8学习与理解"><span>上一篇&nbsp;&nbsp;</span><i
                        class="icon icon-angle-right" aria-hidden="true"></i></a>
            </li>
            
            <li class="toggle-toc">
                <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false"
                    title="文章目录" role="button">
                    <span>[&nbsp;</span><span>文章目录</span>
                    <i class="text-collapsed icon icon-anchor"></i>
                    <i class="text-in icon icon-close"></i>
                    <span>]</span>
                </a>
            </li>
        </ul>
        
        <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal"
            data-target="#donateModal"><span>赏</span></button>
        
        <div class="bar-right">
            <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter"
                data-mobile-sites="weibo,qq,qzone"></div>
        </div>
    </div>
</nav>


<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content donate">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                    aria-hidden="true">&times;</span></button>
            <div class="modal-body">
                <div class="donate-box">
                    <div class="donate-head">
                        <p>感谢您的支持,我会继续努力的!</p>
                    </div>
                    <div class="tab-content">
                        <div role="tabpanel" class="tab-pane fade active in" id="alipay">
                            <div class="donate-payimg">
                                <img src="https://mumulx.github.io/donate/alipayimg.png"
                                    alt="扫码支持" title="扫一扫" />
                            </div>
                            <p class="text-muted mv">扫码打赏, 多少你说了算~</p>
                            <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦~</p>
                        </div>
                        <div role="tabpanel" class="tab-pane fade" id="wechatpay">
                            <div class="donate-payimg">
                                <img src="https://mumulx.github.io/donate/wechatpayimg.png"
                                    alt="扫码支持" title="扫一扫" />
                            </div>
                            <p class="text-muted mv">扫码打赏, 多少你说了算~</p>
                            <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
                        </div>
                    </div>
                    <div class="donate-footer">
                        <ul class="nav nav-tabs nav-justified" role="tablist">
                            <li role="presentation" class="active">
                                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay"
                                    aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
                            </li>
                            <li role="presentation" class="">
                                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab"
                                    aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i>
                                    微信支付</a>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
</main><footer class="footer" itemscope itemtype="https://schema.org/WPFooter">
<ul class="social-links">
    <li><a href="https://github.com/mumulx" target="_blank" title="github" data-toggle=tooltip data-placement=top >
            <i class="icon icon-github"></i></a></li>
    <li><a href="https://mumulx.github.io/index.xml" target="_blank" title="rss" data-toggle=tooltip data-placement=top >
            <i class="icon icon-rss"></i></a></li>
    <li><a href="https://weibo.com/u/5459389722" target="_blank" title="weibo" data-toggle=tooltip data-placement=top >
            <i class="icon icon-weibo"></i></a></li>
</ul>
  <div class="copyright">
    &copy;2019  -
    2020
    <div class="publishby">
        联系邮箱：<a target="_blank" title="木木的邮箱"> 1819778796@qq.com </a>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script>
   window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/highlight.min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/rust.min.js"></script>
<script type="text/javascript"
   src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script>
hljs.configure({
  tabReplace: '    ', 
  classPrefix: ''     
                      
})
hljs.initHighlightingOnLoad();
</script>
<script type="text/javascript" src="https://mumulx.github.io/js/application.js"></script>
<script type="text/javascript" src="https://mumulx.github.io/js/plugin.js"></script>
<script>
      (function (window) {
          var INSIGHT_CONFIG = {
              TRANSLATION: {
                  POSTS: '文章',
                  PAGES: '页面',
                  CATEGORIES: '分类',
                  TAGS: '标签',
                  UNTITLED: '(未命名)',
              },
              ROOT_URL: 'https:\/\/mumulx.github.io\/',
              CONTENT_URL: 'https:\/\/mumulx.github.io\/\/searchindex.json ',
          };
          window.INSIGHT_CONFIG = INSIGHT_CONFIG;
      })(window);
      </script>
<script type="text/javascript" src="https://mumulx.github.io/js/insight.js"></script>


<script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '1ccf8dc9e86b3575cfb2',
        clientSecret: '048ae422c4a6207a4e89c58ba1d4ebf820136bb0',
        repo: 'gittalk',
        owner: 'mumulx',
        admin: ['mumulx'],
        id: md5(location.pathname),
        distractionFreeMode: true
    });
    gitalk.render('comments');
</script>

  </body>
</html>
