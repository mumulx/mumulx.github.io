<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>
        SQL优化Mysql版 - 木木的个人博客
      </title>
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  
  <meta name="theme-color" content="#000000" />
  
  <meta http-equiv="window-target" content="_top" />
  
  
  <meta name="description" content="SQL优化Mysql版" />
  <meta name="generator" content="Hugo 0.59.1 with theme pure" />
  <title>SQL优化Mysql版 - 木木的个人博客</title>
  

  <link rel="stylesheet" href="https://mumulx.github.io/css/style.css">
  <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.15.10/styles/github.min.css"> 
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <meta property="og:title" content="SQL优化Mysql版" />
<meta property="og:description" content="SQL优化Mysql版" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mumulx.github.io/2020/01/sql%E4%BC%98%E5%8C%96mysql%E7%89%88/" />
<meta property="article:published_time" content="2020-01-20T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-01-20T00:00:00+00:00" />

<meta itemprop="name" content="SQL优化Mysql版">
<meta itemprop="description" content="SQL优化Mysql版">


<meta itemprop="datePublished" content="2020-01-20T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-01-20T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="15981">



<meta itemprop="keywords" content="数据库," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SQL优化Mysql版"/>
<meta name="twitter:description" content="SQL优化Mysql版"/>

  <!--[if lte IE 9]>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
    <![endif]-->

  <!--[if lt IE 9]>
      <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
    <![endif]-->

</head>
  </head>
  

  <body class="main-center" itemscope itemtype="https://schema.org/WebPage"><header class="header" itemscope itemtype="https://schema.org/WPHeader">
    <div class="slimContent">
      <div class="navbar-header">
        <div class="profile-block text-center">
          <a id="avatar" href="https://github.com/mumulx" target="_blank">
            <img class="img-circle img-rotate" src="https://mumulx.github.io/avatar.png" width="200" height="200">
          </a>
          <h2 id="name" class="hidden-xs hidden-sm">木木就是两个木</h2>
          <h3 id="title" class="hidden-xs hidden-sm hidden-md">木木</h3>
          <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i>xuzhou, China</small>
        </div><div class="search" id="search-form-wrap">
    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i
                        class="icon icon-search"></i></button>
            </span>
        </div>
        <div class="ins-search">
            <div class="ins-search-mask"></div>
            <div class="ins-search-container">
                <div class="ins-input-wrapper">
                    <input type="text" class="ins-search-input" placeholder="想要查找什么..."
                        x-webkit-speech />
                    <button type="button" class="close ins-close ins-selectable" data-dismiss="modal"
                        aria-label="Close"><span aria-hidden="true">×</span></button>
                </div>
                <div class="ins-section-wrapper">
                    <div class="ins-section-container"></div>
                </div>
            </div>
        </div>
    </form>
</div>
        <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
      <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="https://schema.org/SiteNavigationElement" role="navigation">
        <ul class="nav navbar-nav main-nav">
            <li class="menu-item menu-item-home">
                <a href="/">
                    <i class="icon icon-home-fill"></i>
                  <span class="menu-title">Home</span>
                </a>
            </li>
            <li class="menu-item menu-item-archives">
                <a href="/posts">
                    <i class="icon icon-archives-fill"></i>
                  <span class="menu-title">Archives</span>
                </a>
            </li>
            <li class="menu-item menu-item-categories">
                <a href="/categories">
                    <i class="icon icon-folder"></i>
                  <span class="menu-title">Categories</span>
                </a>
            </li>
            <li class="menu-item menu-item-tags">
                <a href="/tags">
                    <i class="icon icon-tags"></i>
                  <span class="menu-title">Tags</span>
                </a>
            </li>
            <li class="menu-item menu-item-about">
                <a href="/about">
                    <i class="icon icon-cup-fill"></i>
                  <span class="menu-title">About</span>
                </a>
            </li>
        </ul>
      </nav>
    </div>
  </header>
  <aside class="sidebar" itemscope itemtype="https://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content"><p>我们的征途是星辰大海！</p>
            </div>
        </div>
    </div>
</div>

      <div class="widget">
    <h3 class="widget-title"> 分类</h3>
    <div class="widget-body">
        <ul class="category-list">
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/java%E9%9D%A2%E8%AF%95/" class="category-list-link">java面试</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/%E6%8A%80%E6%9C%AF%E6%94%B6%E5%BD%95/" class="category-list-link">技术收录</a><span class="category-list-count">29</span></li>
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/" class="category-list-link">技术框架</a><span class="category-list-count">14</span></li>
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" class="category-list-link">杂七杂八</a><span class="category-list-count">10</span></li>
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/" class="category-list-link">私人博客</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95/" class="category-list-link">问题收录</a><span class="category-list-count">2</span></li>
        </ul>
    </div>
</div>
      <div class="widget">
    <h3 class="widget-title"> 标签</h3>
    <div class="widget-body">
        <ul class="tag-list">
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/j2ee/" class="tag-list-link">j2ee</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/java/" class="tag-list-link">java</a><span
                    class="tag-list-count">12</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="tag-list-link">java并发编程</a><span
                    class="tag-list-count">5</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/linux/" class="tag-list-link">linux</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/node/" class="tag-list-link">node</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/spring%E5%AE%B6%E6%97%8F/" class="tag-list-link">spring家族</a><span
                    class="tag-list-count">12</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="tag-list-link">中间件</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/" class="tag-list-link">其他问题</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" class="tag-list-link">分布式</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" class="tag-list-link">前端框架</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6/" class="tag-list-link">开发软件</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="tag-list-link">数据库</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E6%97%A5%E8%AE%B0/" class="tag-list-link">日记</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" class="tag-list-link">杂七杂八</a><span
                    class="tag-list-count">12</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" class="tag-list-link">版本控制</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E7%AE%97%E6%B3%95/" class="tag-list-link">算法</a><span
                    class="tag-list-count">2</span></li>
            
        </ul>

    </div>
</div>
      
<div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
        <ul class="recent-post-list list-unstyled no-thumbnail">
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.github.io/2020/11/fastdfs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="title">FastDfs学习笔记</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-11-03 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-11-03</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.github.io/2020/10/java%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/" class="title">Java底层知识汇总</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-10-09 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-10-09</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.github.io/2020/09/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/" class="title">背包九讲问题汇总</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-09-23 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-09-23</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.github.io/2020/08/java%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="title">Java算法笔记</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-08-13 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-08-13</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.github.io/2020/08/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B8%80/" class="title">Java面试准备一</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-08-13 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-08-13</time>
                    </p>
                </div>
            </li>
        </ul>
    </div>
</div>
  </div>
</aside>

    
    
  <aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="https://schema.org/WPSideBar">
    <div class="slimContent">
      <nav id="toc" class="article-toc">
        <h3 class="toc-title">文章目录</h3>
        <div class="toc-content always-active"><nav id="TableOfContents">
<ul>
<li><a href="#mysql版本">MySQL版本：</a>
<ul>
<li><a href="#基础">基础</a>
<ul>
<li><a href="#原理">原理</a></li>
<li><a href="#sql优化">SQL优化</a>
<ul>
<li><a href="#sql">SQL ：</a></li>
<li><a href="#sql优化-主要就是-在优化索引">SQL优化， 主要就是 在优化索引</a></li>
</ul></li>
<li><a href="#索引">索引</a>
<ul>
<li><a href="#分类">分类：</a></li>
<li><a href="#创建索引">创建索引：</a></li>
</ul></li>
<li><a href="#sql性能问题">SQL性能问题</a>
<ul>
<li><a href="#准备数据">准备数据：</a></li>
</ul></li>
</ul></li>
<li><a href="#表字段">表字段</a>
<ul>
<li><a href="#id">id:</a></li>
<li><a href="#select-type">select_type:</a>
<ul>
<li><a href="#union">union</a></li>
</ul></li>
<li><a href="#type">type</a>
<ul>
<li><a href="#system">system</a></li>
<li><a href="#const">const</a></li>
<li><a href="#eq-ref">eq_ref</a></li>
<li><a href="#ref">ref</a></li>
<li><a href="#range">range</a></li>
<li><a href="#index">index</a></li>
<li><a href="#all">all</a></li>
<li><a href="#小结">小结</a></li>
</ul></li>
<li><a href="#possible-keys">possible_keys</a></li>
<li><a href="#key">key</a></li>
<li><a href="#key-len">key_len</a></li>
<li><a href="#ref-1">ref</a></li>
<li><a href="#rows">rows</a></li>
<li><a href="#extra">Extra：</a>
<ul>
<li><a href="#using-filesort">using filesort ：</a></li>
<li><a href="#using-temporary">using temporary:</a></li>
<li><a href="#using-index">using index :</a></li>
<li><a href="#演示">演示：</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
        </div>
      </nav>
    </div>
  </aside>
<main class="main" role="main"><div class="content">
  <article id="-" class="article article-type-" itemscope
    itemtype="https://schema.org/BlogPosting">
    
    <div class="article-header">
      <h1 itemprop="name">
  <a
    class="article-title"
    href="/2020/01/sql%E4%BC%98%E5%8C%96mysql%E7%89%88/"
    >SQL优化Mysql版</a
  >
</h1>

      <div class="article-meta">
        <span class="article-date">
  <i class="icon icon-calendar-check"></i>
<a href="https://mumulx.github.io/2020/01/sql%E4%BC%98%E5%8C%96mysql%E7%89%88/" class="article-date">
  <time datetime="2020-01-20 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-01-20</time>
</a>
</span><span class="article-category">
  <i class="icon icon-folder"></i>
  <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E6%94%B6%E5%BD%95/"> 技术收录 </a>
</span>  
  <span class="article-tag">
    <i class="icon icon-tags"></i>
    <a class="article-tag-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"> 数据库 </a>
  </span>

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/01/sql%E4%BC%98%E5%8C%96mysql%E7%89%88/#comments"
            class="article-comment-link">评论</a></span>
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计:15981字</span>
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长:32分 </span>
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      

<p>系统使用的Linux Centos6</p>

<h1 id="mysql版本">MySQL版本：</h1>

<h2 id="基础">基础</h2>

<p>5.x:</p>

<p>5.0-5.1:早期产品的延续，升级维护</p>

<p>5.4 - 5.x :  MySQL整合了三方公司的新存储引擎 （推荐5.5）
本次使用的是
* MySQL-client-5.5.58-1.el6.x86_64.rpm
* MySQL-server-5.5.58-1.el6.x86_64.rpm</p>

<p>安装：rpm -ivh rpm软件名</p>

<pre><code class="language-shell">rpm -ivh MySQL-server-5.5.58-1.el6.x86_64.rpm
</code></pre>

<p>如果安装时 与某个软件  xxx冲突，则需要将冲突的软件卸载掉：</p>

<pre><code class="language-shell">yum -y remove xxx
yum -y remove mysql-libs-5.1.73-8.el6*
</code></pre>

<p>安装时 有日志提示我们可以修改密码：</p>

<pre><code class="language-shell">PLEASE REMEMBER TO SET A PASSWORD FOR THE MySQL root USER !
To do so, start the server, then issue the following commands:

/usr/bin/mysqladmin -u root password 'new-password'
/usr/bin/mysqladmin -u root -h localhost.centos6 password 'new-password'
</code></pre>

<pre><code class="language-shell">rpm -ivh MySQL-client-5.5.58-1.el6.x86_64.rpm
</code></pre>

<p><strong>注意：</strong></p>

<p>如果提示“GPG keys&hellip;”安装失败，解决方案：</p>

<pre><code class="language-shell"> rpm -ivh rpm软件名  --force --nodoeps
</code></pre>

<p>验证：</p>

<pre><code class="language-shell">mysqladmin --version
</code></pre>

<pre><code>启动mysql应用： service mysql start

关闭： service mysql stop

重启： service mysql restart
</code></pre>

<p>在计算机reboot后 登陆MySQL :</p>

<pre><code> mysql
</code></pre>

<p>退出mysql</p>

<pre><code>exit
</code></pre>

<p>可能会报错：</p>

<pre><code> &quot;/var/lib/mysql/mysql.sock不存在&quot;  
</code></pre>

<p>&ndash;原因：是Mysql服务没有启动</p>

<p>解决 ：<br />
启动服务：
1. 每次使用前 手动启动服务</p>

<pre><code>    /etc/init.d/mysql start
</code></pre>

<ol>
<li><p>开机自启</p>

<pre><code>chkconfig mysql on      开启开机自启

chkconfig mysql off     关闭开机自启

ntsysv                  检查开机是否自动启动：
</code></pre>

<p>​</p></li>
</ol>

<p>给mysql 的超级管理员root 增加密码：</p>

<pre><code>/usr/bin/mysqladmin -u root password root
</code></pre>

<p>登陆：</p>

<pre><code>mysql -u root -p
回车之后输入密码
</code></pre>

<p>数据库存放目录：</p>

<pre><code>ps -ef|grep mysql       可以看到：

数据库目录：     datadir=/var/lib/mysql 

pid文件目录： --pid-file=/var/lib/mysql/bigdata01.pid
</code></pre>

<p>MySQL核心目录：</p>

<pre><code>/var/lib/mysql :mysql 安装目录

/usr/share/mysql:  配置文件

/usr/bin：命令目录（mysqladmin、mysqldump等）

/etc/init.d/mysql启停脚本
</code></pre>

<p>MySQL配置文件</p>

<pre><code>my-huge.cnf 高端服务器  1-2G内存
my-large.cnf   中等规模
my-medium.cnf  一般
my-small.cnf   较小
</code></pre>

<p>但是，以上配置文件mysql默认不能识别，默认只能识别</p>

<pre><code>/etc/my.cnf
</code></pre>

<p>因此需要将上面四个文件之一复制到默认配置文件中</p>

<p>采用 my-huge.cnf ：</p>

<pre><code class="language-shell">cp /usr/share/mysql/my-huge.cnf /etc/my.cnf
</code></pre>

<p>注意
 mysql5.5默认配置文件</p>

<pre><code>/etc/my.cnf；
</code></pre>

<p>Mysql5.6 默认配置文件</p>

<pre><code>/etc/mysql-default.cnf
</code></pre>

<p>默认端口 3306</p>

<p>mysql字符编码：</p>

<p>sql  :</p>

<pre><code class="language-shell">show variables like '%char%';
</code></pre>

<p>可以发现部分编码是 latin,需要统一设置为utf-8</p>

<p>设置编码：</p>

<pre><code class="language-shell">vi /etc/my.cnf

[mysql]
default-character-set=utf8
[client]
default-character-set=utf8

[mysqld]
character_set_server=utf8
character_set_client=utf8
collation_server=utf8_general_ci
</code></pre>

<p>重启Mysql:</p>

<pre><code class="language-shell">service mysql restart
</code></pre>

<p>sql  :</p>

<pre><code class="language-shell">show variables like '%char%' ;
</code></pre>

<p>注意事项：修改编码 只对“之后”创建的数据库生效，因此 我们建议 在mysql安装完毕后，第一时间 统一编码。</p>

<p>mysql:清屏</p>

<pre><code>ctrl+L  

system clear
</code></pre>

<p>​</p>

<h3 id="原理">原理</h3>

<p>MYSQL逻辑分层 ：连接层 服务层 引擎层 存储层</p>

<p><img src="/resources/技术收录/数据库/MySQL逻辑分层.png" alt="逻辑分层" title="逻辑分层" /></p>

<p>InnoDB(默认) ：事务优先 （适合高并发操作；行锁）</p>

<p>MyISAM ：性能优先  （表锁）</p>

<p>查询数据库引擎：  支持哪些引擎？</p>

<pre><code class="language-sql">show engines ;
</code></pre>

<p>查看当前使用的引擎</p>

<pre><code class="language-sql">show variables like '%storage_engine%' ;
</code></pre>

<p>指定数据库对象的引擎：</p>

<pre><code class="language-sql">create table tb(
	id int(4) auto_increment ,
	name varchar(5),
	dept varchar(5) ,
	primary key(id)		
)ENGINE=MyISAM AUTO_INCREMENT=1
 DEFAULT CHARSET=utf8   ;
</code></pre>

<p>由<code>Welcome to the MySQL monitor.  Commands end with ; or \g.</code>可知sql语句的结尾符有两种<code>;</code>和<code>\g</code></p>

<h3 id="sql优化">SQL优化</h3>

<p>原因：性能低、执行时间太长、等待时间太长、SQL语句欠佳（连接查询）、索引失效、服务器参数设置不合理（缓冲、线程数）</p>

<p><a href="https://www.cnblogs.com/annsshadow/p/5037667.html">参考文章</a></p>

<h4 id="sql">SQL ：</h4>

<p>编写过程：</p>

<pre><code class="language-sql">select dinstinct  ..from  ..join ..on ..where ..group by ...having ..order by ..limit ..
</code></pre>

<p>解析过程：</p>

<pre><code class="language-sql">from .. on.. join ..where ..group by ....having ...select dinstinct ..order by limit ...
</code></pre>

<h4 id="sql优化-主要就是-在优化索引">SQL优化， 主要就是 在优化索引</h4>

<p>索引： 相当于书的目录</p>

<p>索引： index是帮助MYSQL高效获取数据的数据结构。索引是数据结构（树：B树(默认)、Hash树&hellip;）</p>

<p>索引的弊端：</p>

<ol>
<li>索引本身很大， 可以存放在内存/硬盘（通常为 硬盘）</li>
<li>索引不是所有情况均适用： a.少量数据  b.频繁更新的字段   c.很少使用的字段</li>
<li>索引会降低增删改的效率，提高查询的效率（增删改  查）</li>
</ol>

<p>优势：</p>

<ol>
<li><p>提高查询效率（降低IO使用率）</p></li>

<li><p>降低CPU使用率 （&hellip;order by age desc,因为 B树索引 本身就是一个 好排序的结构，因此在排序时  可以直接使用）</p></li>
</ol>

<p>三层Btree可以存放上百万条的数据</p>

<p>Btree：一般指B+树，数据全部存放在叶结点中</p>

<p>B+树中查询任意的数据的次数：n次(B+树的高度)</p>

<h3 id="索引">索引</h3>

<h4 id="分类">分类：</h4>

<p>主键索引：  不能重复。id    不能是null</p>

<p>唯一索引  ：不能重复。id    可以是null</p>

<p>单值索引  ： 单列， age ;一个表可以多个单值索引,name。</p>

<p>复合索引  ：多个列构成的索引 （相当于 二级目录 ：  z: zhao）  (name,age)   (a,b,c,d,&hellip;,n)</p>

<h4 id="创建索引">创建索引：</h4>

<p>方式一：</p>

<pre><code class="language-sql">create 索引类型  索引名  on 表(字段)

单值：
create index   dept_index on  tb(dept);

唯一：
create unique index  name_index on tb(name) ;

复合索引
create index dept_name_index on tb(dept,name);
</code></pre>

<p>方式二：</p>

<pre><code class="language-sql">alter table 表名 索引类型  索引名（字段）

单值：
alter table tb add index dept_index(dept) ;

唯一：
alter table tb add unique index name_index(name);

复合索引
alter table tb add index dept_name_index(dept,name);
</code></pre>

<p>注意：如果一个字段是primary key，则该字段默认就是 主键索引</p>

<p>此时的语句是DDL，会自动提交，因此不需要commit;</p>

<p>DML语句需要自己commit，增删改</p>

<p>删除索引：</p>

<pre><code class="language-sql">drop index 索引名 on 表名 ;

drop index name_index on tb ;
</code></pre>

<p>查询索引：</p>

<pre><code class="language-sql">show index from 表名 ;

show index from 表名 \G
</code></pre>

<p>注意：结尾符需要写成<code>\G</code>,结果以行的顺序以列的形式显示出来</p>

<h3 id="sql性能问题">SQL性能问题</h3>

<ul>
<li>分析SQL的执行计划  : explain   ，可以模拟SQL优化器执行SQL语句，从而让开发人员 知道自己编写的SQL状况</li>
<li>MySQL查询优化器会干扰我们的优化</li>
</ul>

<p>优化方法，<a href="https://dev.mysql.com/doc/refman/5.5/en/optimization.html">官网</a></p>

<p>查询执行计划：</p>

<pre><code class="language-sql">explain +SQL语句

explain  select  * from tb ;
</code></pre>

<pre><code> id :                   编号	

 select_type ：         查询类型

 table ：               表

 type   ：              类型

 possible_keys ：       预测用到的索引 

 key  ：                实际使用的索引

 key_len ：             实际使用索引的长度

 ref  :                 表之间的引用

 rows ：                通过索引查询到的数据量 

 Extra:                 额外的信息

</code></pre>

<h4 id="准备数据">准备数据：</h4>

<pre><code class="language-sql">create table course
(
cid int(3),
cname varchar(20),
tid int(3)
);
create table teacher
(
tid int(3),
tname varchar(20),
tcid int(3)
);

create table teacherCard
(
tcid int(3),
tcdesc varchar(200)
);


insert into course values(1,'java',1);
insert into course values(2,'html',1);
insert into course values(3,'sql',2);
insert into course values(4,'web',3);

insert into teacher values(1,'tz',1);
insert into teacher values(2,'tw',2);
insert into teacher values(3,'tl',3);

insert into teacherCard values(1,'tzdesc') ;
insert into teacherCard values(2,'twdesc') ;
insert into teacherCard values(3,'tldesc') ;

</code></pre>

<p>查询课程编号为2  或 教师证编号为3  的老师信息</p>

<p>SQL语句</p>

<pre><code class="language-sql">select t.* from teacherCard tc,course c,teacher t where c.tid = t.tid
and t.tcid = tc.tcid and (c.cid = 2 or tc.tcid=3);
</code></pre>

<pre><code class="language-sql">explain +sql:
</code></pre>

<h2 id="表字段">表字段</h2>

<h3 id="id">id:</h3>

<ul>
<li><p>id值相同，从上往下 顺序执行。</p>

<pre><code>t(3)-tc(3)-c(4)
</code></pre>

<p>t表中添加数据后在执行</p>

<pre><code>tc（3）--c（4）-（t6）
</code></pre>

<p>表的执行顺序  因数量的个数改变而改变的原因： <strong>笛卡儿积</strong></p>

<pre><code>    a    b       c
    2    3       4   =  2*3=6 * 4   =24
    3    4       2   =  3*4=12* 2   =24
</code></pre>

<p>虽然结果最终的结果相同但是中间的过程是不同的，程序喜欢数据越小越好。(小表驱动大表)</p>

<p>数据小的表 优先查询；</p></li>

<li><p>id值不同：id值越大越优先查询 (本质：在嵌套子查询时，先查内层 再查外层)</p>

<p>查询教授SQL课程的老师的描述（desc），纯多表查询</p>

<pre><code class="language-sql">explain select tc.tcdesc from teacherCard tc,course c,teacher t where c.tid = t.tid and t.tcid = tc.tcid and c.cname = 'sql' ;
</code></pre>

<p>将以上 多表查询 转为子查询形式（纯子查询）：会先执行括号中的</p>

<pre><code class="language-sql">explain select tc.tcdesc from teacherCard tc where tc.tcid = 
(select t.tcid from teacher t where  t.tid =  
 (select c.tid from course c where c.cname = 'sql')
);
</code></pre></li>
</ul>

<p>子查询+多表：</p>

<pre><code class="language-sql">    explain select t.tname ,tc.tcdesc from teacher t,teacherCard tc where t.tcid= tc.tcid
    and t.tid = (select c.tid from course c where cname = 'sql') ;
</code></pre>

<p><strong>结论</strong>: id值有相同，又有不同： id值越大越优先；id值相同，从上往下 顺序执行（c-tc-t）</p>

<h3 id="select-type">select_type:</h3>

<p>select_type:查询类型</p>

<ul>
<li>PRIMARY:包含子查询SQL中的 主查询 （最外层）</li>
<li>SUBQUERY：包含子查询SQL中的 子查询 （非最外层）</li>
<li>simple:简单查询（不包含子查询、union）<code>select * from teacher</code></li>
<li>derived:衍生查询(使用到了临时表)(在table列中derived 字段的后面有一个数字指向了id为该数据的临时表)</li>
</ul>

<p>衍生查询的两种情况</p>

<ol>
<li><p>在from子查询中只有一张表</p>

<pre><code class="language-sql">explain select  cr.cname    from ( select * from course where tid in (1,2) ) cr ;
</code></pre></li>

<li><p>在from子查询中， 如果有table1 union table2 ，则table1 就是derived,table2就是union</p>

<pre><code class="language-sql">explain select  cr.cname    from ( select * from course where tid = 1  union select * from course where tid = 2 ) cr ;
</code></pre></li>
</ol>

<h4 id="union">union</h4>

<p>看上面的例子。</p>

<p>union result :告知开发人员，那些表之间存union查询（在table列<union x,y>表示x表和y表之间有union）</p>

<pre><code>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL
</code></pre>

<h3 id="type">type</h3>

<p>type:索引类型、类型</p>

<pre><code>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all   ，要对type进行优化的前提：有索引
</code></pre>

<p>越往左边性能越高。其中：system,const只是理想情况；实际能达到 ref&gt;range</p>

<h4 id="system">system</h4>

<p><strong>system</strong>（忽略，不切实际。。）: 只有一条数据的系统表 ；或 衍生表只有一条数据的主查询</p>

<pre><code class="language-sql">create table test01
(
    tid int(3),
    tname varchar(20)
);
insert into test01 values(1,'a') ;
commit;
</code></pre>

<p>增加索引（主键索引）</p>

<pre><code class="language-sql">alter table test01 add constraint tid_pk primary key(tid) ;

explain select * from (select * from test01 )t where tid =1 ;
</code></pre>

<h4 id="const">const</h4>

<p><strong>const</strong>:仅仅能查到一条数据的SQL ,用于Primary key 或unique索引  （类型 与索引类型有关）</p>

<pre><code class="language-sql">explain select tid from test01 where tid =1 ;
</code></pre>

<p>删除主键索引，创建一个一般索引,在查询</p>

<pre><code class="language-sql">alter table test01 drop primary key ;

create index test01_index on test01(tid) ;

explain select tid from test01 where tid =1 ;
</code></pre>

<p>则不行</p>

<h4 id="eq-ref">eq_ref</h4>

<p><strong>eq_ref</strong>:唯一性索引：对于每个索引键的查询，返回匹配唯一行数据（有且只有1个，不能多 、不能0）（每一行数据唯一，且表数据一对一不能多也不能少）
select &hellip; from ..where name = &hellip; .常见于唯一索引 和主键索引(因为主键索引和唯一索引会保证唯一)。</p>

<p>增加主键：给teacherCard表增加一个主键索引，给teacher表增加一个唯一索引</p>

<pre><code class="language-sql">alter table teacherCard add constraint pk_tcid primary key(tcid);

alter table teacher add constraint uk_tcid unique index(tcid) ;
</code></pre>

<pre><code class="language-sql">explain select t.tcid from teacher t,teacherCard tc where t.tcid = tc.tcid ;
</code></pre>

<p>以上SQL，用到的索引是 t.tcid,即teacher表中的tcid字段；如果teacher表的数据个数 和 连接查询的数据个数一致（都是3条数据），则有可能满足eq_ref级别；否则无法满足。</p>

<h4 id="ref">ref</h4>

<p><strong>ref</strong>：非唯一性索引，对于每个索引键的查询，返回匹配的所有行（0，多）</p>

<p>准备数据：</p>

<pre><code class="language-sql">insert into teacher values(4,'tz',4) ;
insert into teacher values(5,'tz',4) ;
insert into teacherCard values(4,'tz222');
</code></pre>

<p>测试：先给name增加索引</p>

<pre><code class="language-sql">alter table teacher add index index_name (tname) ;

explain select * from teacher 	where tname = 'tz';
</code></pre>

<p>查询到的索引列的结果有两个tz所以是ref</p>

<h4 id="range">range</h4>

<p><strong>range</strong>：检索指定范围的行 ,where后面是一个范围查询(between   ,&gt; &lt; &gt;=,     特殊:in有时候会失效 ，从而转为 无索引all)</p>

<pre><code class="language-sql">alter table teacher add index tid_index (tid) ;

explain select t.* from teacher t where t.tid in (1,2) ;

explain select t.* from teacher t where t.tid &lt;3 ;
</code></pre>

<h4 id="index">index</h4>

<p><strong>index</strong>：查询全部索引中数据</p>

<pre><code class="language-sql">explain select tid from teacher ; 
</code></pre>

<p>&ndash;tid 是索引，只需要扫描索引表，不需要查询所有表中的所有数据</p>

<h4 id="all">all</h4>

<p><strong>all</strong>：查询全部表中的数据</p>

<pre><code class="language-sql">explain select cid from course ;  
</code></pre>

<p>&ndash;cid不是索引，需要全表扫描，即需要查询所有表中的所有数据</p>

<h4 id="小结">小结</h4>

<p>system/const: 结果只有一条数据</p>

<p>eq_ref:结果多条；但是每条数据是唯一的 ；</p>

<p>ref：结果多条；但是每条数据是是0或多条 ；</p>

<h3 id="possible-keys">possible_keys</h3>

<p>possible_keys ：可能用到的索引，是一种预测，不准。</p>

<pre><code class="language-sql">alter table  course add index cname_index (cname);

explain select t.tname ,tc.tcdesc from teacher t,teacherCard tc
where t.tcid= tc.tcid
and t.tid = (select c.tid from course c where cname = 'sql') ;
</code></pre>

<p>如果 possible_key/key是NULL，则说明没用索引</p>

<pre><code class="language-sql">explain select tc.tcdesc from teacherCard tc,course c,teacher t where c.tid = t.tid
and t.tcid = tc.tcid and c.cname = 'sql' ;
</code></pre>

<p>这个预测就不准</p>

<h3 id="key">key</h3>

<p>key ：实际使用到的索引</p>

<h3 id="key-len">key_len</h3>

<p>key_len ：索引的长度 ;</p>

<p>作用：用于判断复合索引是否被完全使用</p>

<pre><code class="language-sql">create table test_kl
(
    name char(20) not null default ''
);

alter table test_kl add index index_name(name) ;

explain select * from test_kl where name ='' ;   --长度为60
</code></pre>

<p>&ndash; key_len :60</p>

<p>在utf8：1个字符站3个字节</p>

<pre><code class="language-sql">alter table test_kl add column name1 char(20) ;  --name1可以为null

alter table test_kl add index index_name1(name1) ;

explain select * from test_kl where name1 ='' ; -- 长度为61
</code></pre>

<p>&ndash;如果索引字段可以为Null,则会使用1个字节用于标识。</p>

<pre><code class="language-sql">drop index index_name on test_kl ;--删除两个索引
drop index index_name1 on test_kl ;
</code></pre>

<p>增加一个复合索引</p>

<pre><code class="language-sql">alter table test_kl add index name_name1_index (name,name1) ; --会先查name，查到就不用name1，没查到会用name1

explain select * from test_kl where name1 = '' ; --复合索引会先查name在查name1
</code></pre>

<p>&ndash;121；用到了name1，但是name1和name符合起来了，因此两者都被使用。20*3+20*3+1=121</p>

<pre><code class="language-sql">explain select * from test_kl where name = '' ; 
</code></pre>

<p>&ndash;60；只用到了name，20*3=60</p>

<p>varchar(20)</p>

<pre><code class="language-sql">alter table test_kl add column name2 varchar(20) ; 
</code></pre>

<p>&ndash;可以为Null</p>

<pre><code class="language-sql">alter table test_kl add index name2_index (name2) ;

explain select * from test_kl where name2 = '' ;  
</code></pre>

<p>&ndash;63</p>

<p>20*3=60 +  1(null)  +2(用2个字节 标识可变长度)  =63</p>

<ul>
<li>utf8:1个字符3个字节</li>
<li>gbk:1个字符2个字节</li>
<li>latin:1个字符1个字节</li>
</ul>

<h3 id="ref-1">ref</h3>

<p>ref : 注意与type中的ref值区分。</p>

<p>作用： 指明当前表所参照的字段。</p>

<pre><code class="language-sql">select ....where a.c = b.x ;(其中b.x可以是常量:const a表中c字段引用了b表中的x字段)

alter table course  add index tid_index (tid) ;--研究的前提是使用到的字段都加上了索引

explain select * from course c,teacher t where c.tid = t.tid  and t.tname ='tw' ;
</code></pre>

<p>其中<code>t.tname ='tw'</code>中的tw是一个常量因此是const</p>

<p><code>c.tid = t.tid</code>c表的tid用到了t表的tid</p>

<h3 id="rows">rows</h3>

<p>rows: 被索引优化查询的 数据个数 (实际通过索引而查询到的 数据个数)</p>

<pre><code class="language-sql">explain select * from course c,teacher t  where c.tid = t.tid
and t.tname = 'tz' ;
</code></pre>

<h3 id="extra">Extra：</h3>

<h4 id="using-filesort">using filesort ：</h4>

<p>性能消耗大；需要“额外”的一次排序（查询）  。常见于 order by 语句中。</p>

<p>排序之前要先查询</p>

<pre><code class="language-sql">create table test02
(
    a1 char(3),
    a2 char(3),
    a3 char(3),
    index idx_a1(a1),
    index idx_a2(a2),
    index idx_a3(a3)
);

explain select * from test02 where a1 ='' order by a1 ;--不是using filesort
</code></pre>

<pre><code class="language-sql">explain select * from test02 where a1 ='' order by a2 ; --using filesort 根据a2排序但是a2没查，因此需要额外的一次查询
</code></pre>

<p>小结：对于单索引， 如果排序和查找是同一个字段，则不会出现using filesort；如果排序和查找不是同一个字段，则会出现using filesort；</p>

<p>避免： where哪些字段，就order by那些字段</p>

<p>复合索引：不能跨列（最佳左前缀）</p>

<pre><code class="language-sql">drop index idx_a1 on test02;
drop index idx_a2 on test02;
drop index idx_a3 on test02;

alter table test02 add index idx_a1_a2_a3 (a1,a2,a3) ;

explain select *from test02 where a1='' order by a3 ; --using filesort  跨列了 跨过了a2
</code></pre>

<pre><code class="language-sql">explain select *from test02 where a2='' order by a3 ; --using filesort  跨列了 跨过了a1
</code></pre>

<pre><code class="language-sql">explain select *from test02 where a1='' order by a2 ;--没有--using filesort
</code></pre>

<pre><code class="language-sql">explain select *from test02 where a2='' order by a1 ; --using filesort
</code></pre>

<p>小结：避免： where和order by 按照复合索引的顺序使用，不要跨列或无序使用。</p>

<h4 id="using-temporary">using temporary:</h4>

<p>性能损耗大 ，用到了临时表。一般出现在group by 语句中。</p>

<pre><code class="language-sql">explain select a1 from test02 where a1 in ('1','2','3') group by a1 ;--没有--using temporary
</code></pre>

<pre><code class="language-sql">explain select a1 from test02 where a1 in ('1','2','3') group by a2 ; --using temporary
</code></pre>

<p>避免：查询那些列，就根据那些列 group by .</p>

<p>using temporary:需要额外再多使用一张表. 一般出现在group by语句中；已经有表了，但不适用，必须再来一张表。</p>

<p>解析过程：</p>

<pre><code>from .. on.. join ..where ..group by ....having ...select dinstinct ..order by limit ...
</code></pre>

<pre><code class="language-sql">explain select * from test03 where a2=2 and a4=4 group by a2,a4 ;
</code></pre>

<p>​     &ndash;没有using temporary；先where a2\a4在group by a2\a4,在原先的基础上在分组，因此没有用到额外的一张表</p>

<pre><code class="language-sql">explain select * from test03 where a2=2 and a4=4 group by a3 ;
</code></pre>

<p>&ndash;using temporary；先where a2\a4在group by a3，在原先的基础上按照a3进行分组，因此用到额外的一张表a3</p>

<h4 id="using-index">using index :</h4>

<p>性能提升; 索引覆盖（覆盖索引）。</p>

<p>原因：不读取原文件，只从索引文件中获取数据 （不需要回表查询）</p>

<p>不需要回表查询:用到的数据都是索引中的数据，不需要再在表中使用没加索引的数据</p>

<p>只要使用到的列 全部都在索引中，就是索引覆盖using index</p>

<p>例如：test02表中有一个复合索引(a1,a2,a3)</p>

<pre><code class="language-sql">explain select a1,a2 from test02 where a1='' or a2= '' ; --using index 用到的a1和a2都在复合索引中
</code></pre>

<p>​    反例</p>

<pre><code class="language-sql">drop index idx_a1_a2_a3 on test02;

alter table test02 add index idx_a1_a2(a1,a2) ;

explain select a1,a3 from test02 where a1='' or a3= '' ;--用到的a3不是索引因此没有--using index   
</code></pre>

<p>如果用到了索引覆盖(using index时)，会对 possible_keys和key造成影响：</p>

<ul>
<li><p>如果没有where，则索引只出现在key中；</p></li>

<li><p>如果有where，则索引 出现在key和possible_keys中。</p>

<pre><code>```sql
</code></pre>

<p>explain select a1,a2 from test02 where a1=&rdquo; or a2= &ldquo; ;
explain select a1,a2 from test02  ;</p>

<pre><code>
#### using where

using where （需要回表查询）

假设age是索引列，但查询语句`select age,name from ...where age =...,`此语句中必须回原表查Name，因此会显示using where.
</code></pre>

<p>sql</p></li>
</ul>

<p>explain select a1,a3 from test02 where a3 = &ldquo; ;&ndash;a3需要回原表查询</p>

<pre><code>
#### impossible where

impossible where ： where子句永远为false

</code></pre>

<p>sql
explain select * from test02 where a1=&lsquo;x&rsquo; and a1=&lsquo;y&rsquo;  ;&ndash;impossible where</p>

<pre><code>
### 优化实例

</code></pre>

<p>sql
create table test03(
    a1 int(4) not null,
    a2 int(4) not null,
    a3 int(4) not null,
    a4 int(4) not null
);
alter table test03 add index idx_a1_a2_a3_a4(a1,a2,a3,a4);</p>

<pre><code></code></pre>

<p>mssql
explain select a1,a2,a3,a4 from test03 where a1=1 and a2=1 and a3=1 and a4=1;&ndash;using index</p>

<pre><code>--推荐写法，因为索引的使用属性顺序（where）后面的顺序和复合索引的顺序一致

</code></pre>

<p>mssql
explain select a1,a2,a3,a4 from test03 where a4=1 and a3=1 and a2=1 and a1=1;&ndash;using index</p>

<pre><code>虽然编写的顺序和索引的顺序不一致，但是我们发现两者结果一致：是因为mysql的服务层的sql优化器对该语句进行了优化

以上2个sql，使用了全部的符合索引：通过key_len=16
</code></pre>

<p>mssql
explain select a1,a2,a3,a4 from test03 where a1=1 and a2=1 and a4=1 order by a3;</p>

<pre><code>a1,a2按顺序，显示using index，不需要回表查询

a4:无效索引，因为跨列使用(变为无效索引)会回表查询显示using where

可以通过key_len校验  ：8



</code></pre>

<p>sql
explain select a1,a2,a3,a4 from test03 where a1=1 and a4=4 order by a3;</p>

<pre><code>
以上sql出现了--using filesort(文件内排序，“多了一次额外的查找、排序”)
不要跨列使用(where和order by拼起来不要跨列使用)

a1--(a4无效)--a3:1-3结果跨列

</code></pre>

<p>sql
explain select a1,a2,a3,a4 from test03 where a1=1 and a4=1 order by a2,a3;</p>

<pre><code>结果没有--using filesort，没有进行跨列使用

a1--a2--（a4失效）--a3:1-2-3

结果没有跨列

小结：

如果（a,b,c,d）复合索引和使用的顺序一致（且不跨列使用），则复合索引全部使用。如果部分一致，则使用部分索引

where和order by拼起来，不要跨列使用



## 优化案例

单表优化、两表优化、三表优化

### 单表优化

</code></pre>

<p>mssql
create table book
(
    bid int(4) primary key,
    name varchar(20) not null,
    authorid int(4) not null,
    publicid int(4) not null,
    typeid int(4) not null
);
insert into book values(1,&lsquo;tjava&rsquo;,1,1,2) ;
insert into book values(2,&lsquo;tc&rsquo;,2,1,2) ;
insert into book values(3,&lsquo;wx&rsquo;,3,2,1) ;
insert into book values(4,&lsquo;math&rsquo;,4,2,3) ;	
commit;	</p>

<pre><code>
查询authorid=1且 typeid为2或3的   bid

</code></pre>

<p>mssql
explain select bid from book where typeid in(2,3) and authorid=1  order by typeid desc ;</p>

<pre><code>

优化：加索引

</code></pre>

<p>mssql
alter table book add index idx_bta (bid,typeid,authorid);</p>

<pre><code>
索引一旦进行 升级优化，需要将之前废弃的索引删掉，防止干扰。

</code></pre>

<p>sql
drop index idx_bta on book;</p>

<pre><code>
根据SQL实际解析的顺序，调整索引的顺序：

</code></pre>

<p>from .. on.. join ..where ..group by &hellip;.having &hellip;select dinstinct ..order by limit &hellip;</p>

<pre><code>
</code></pre>

<p>sql
alter table book add index idx_tab (typeid,authorid,bid);</p>

<pre><code>
--虽然可以回表查询bid，但是将bid放到索引中 可以提升使用using index ;
    
再次优化（之前是index级别）：思路,因为范围查询in有时会失效(in失效后a也会失效)，因此交换索引的顺序，将typeid in(2,3) 放到最后（这样即使in失效了我们的a还有用）。

</code></pre>

<p>sql
drop index idx_tab on book;</p>

<p>alter table book add index idx_atb (authorid,typeid,bid);</p>

<p>explain select bid from book where  authorid=1 and  typeid in(2,3) order by typeid desc ;</p>

<pre><code>
--小结：   

1. 最佳左前缀，保持索引的定义和使用的顺序一致性  
1. 索引需要逐步优化  
1. 将含In的范围查询 放到where条件的最后，防止失效。

本例中同时出现了Using where（需要回原表）; Using index（不需要回原表）：

原因，`where  authorid=1 and  typeid in(2,3)`中authorid在索引(authorid,typeid,bid)中，因此不需要回原表（直接在索引表中能查到）；

而typeid虽然也在索引(authorid,typeid,bid)中，但是含in的范围查询已经使该typeid索引失效，因此相当于没有typeid这个索引，所以需要回原表（using where）；

例如以下没有了In，则不会出现using where

</code></pre>

<p>sql
explain select bid from book where  authorid=1 and  typeid =3 order by typeid desc ;</p>

<pre><code>
还可以通过key_len证明in可以使索引失效。

* 有in时索引长度为4
* 没in时索引长度为8

### 两表优化

</code></pre>

<p>sql
create table teacher2
(
    tid int(4) primary key,
    cid int(4) not null
);</p>

<p>insert into teacher2 values(1,2);
insert into teacher2 values(2,1);
insert into teacher2 values(3,3);</p>

<p>create table course2
(
    cid int(4) ,
    cname varchar(20)
);</p>

<p>insert into course2 values(1,&lsquo;java&rsquo;);
insert into course2 values(2,&lsquo;python&rsquo;);
insert into course2 values(3,&lsquo;kotlin&rsquo;);
commit;</p>

<pre><code>
左连接：

</code></pre>

<p>sql
explain select *from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname=&lsquo;java&rsquo;;</p>

<pre><code>

索引往哪张表加？   

小表驱动大表  (where 小表.x = 大表.y)

索引建立经常使用的字段上 （本题 t.cid=c.cid可知，t.cid字段使用频繁，因此给该字段加索引）,一般情况对于左外连接(以左表为基础：左表的数据要全部匹配)，给左表加索引；右外连接（以右表为基准），给右表加索引

</code></pre>

<pre><code>小表:10
大表:300

select ...where 小表.x10=大表.x300 ;
for(int i=0;i&lt;小表.length 10;i++)
{
    for(int j=0;j&lt;大表.length 300;j++)
    {
        ...
    }
}

select ...where 大表.x300=小表.x10 ;

for(int i=0;i&lt;大表.length300;i++)
{
    for(int j=0;j&lt;小表.length10;j++)
    {
        ...
    }
}
</code></pre>

<pre><code>
以上2个FOR循环，最终都会循环3000次；但是 对于双层循环来说：一般建议 将数据小的循环 放外层；数据大的循环放内层。小表驱动大表

当编写 ..on t.cid=c.cid 时，将数据量小的表 放左边（假设此时t表数据量小）
优化

</code></pre>

<p>	sql
	alter table teacher2 add index index_teacher2_cid(cid) ;</p>

<p>	alter table course2 add index index_course2_cname(cname);&ndash;where后面的字段一定要加索引</p>

<pre><code></code></pre>

<p>sql
	explain select *from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname=&lsquo;java&rsquo;;</p>

<pre><code>
Using join buffer:extra中的一个选项，作用：Mysql引擎使用了 连接缓存。写的sql太差了mysql看不下去了，动了你的sql，给加了一个连接缓存。

---

左连接（left join）即为两张表进行连接时,是以处于left join语句左侧的表为基准去匹配left join语句右边的表，如果左表中的一条数据在右表中能找到与之对应的一条数据，那么就会出现在以虚表形式存在的结果表中，如果没有找到，那么会以null来代替右表中的数据去匹配左表。这样会有一个鲜明的对比，左表中的每一条数据中的对象在右表中的某个属性的存在性是一目了然的。同时在使用on 进行连接时，on的作用仅仅是进行两张表的上诉连接，发挥匹配的功能，它选出来的是满足这种匹配的所有结果，而并不一定是用户所需要的，这时候就要使用where进行条件判断，从而筛选出真正需要的信息。

----

右连接（right join）本质上是相当于将上述的左连接的这个过程反过来，以连接语句right join右侧的表为基准去匹配左边的表，剩下的道理是一样的，不再赘述。

-----

内连接（inner join）就是在用两张表进行匹配的时候，如果表中任意一条数据在另一张表中都是找不到对应数据的话，那么在结果表中是不会有这一条数据的。也就是说必须是两张表中任意两条能够互相对应着的数据才能被存入到结果表中，有点类似于取交集的味道。这种适用于一旦某条数据为空便没有意义的场景，这时给它设成null也就毫无意义了。表中的数据也因此显得简练很多。

----

外链接（outer join）与内连接是相反的，就是说，如果某张表中的数据在另一张中找不到对应的条目并不影响它依然出现在查询的结果中，这对于两张表都是满足的，两边都有出现null的可能，这就有一点数学里的并集的意思。

-----

自连接(self join)可能看起来有点晦涩难懂，但是实际上换个角度你就会豁然开朗，你可以把它这个过程想象成两张一样的表进行左连接或右连接，这样就会简单多了，其中一张表通过设别名的方式成为了虚表，但是共享原标中的信息。应用场景是这样的，就是表的一个字段和另一个字段是相同性质的东西，譬如员工与上司，他们本质也都是员工，在员工表中，员工的直接上司编号会以另一个字段的形式出现，但是他的上司的编号也是会出现在员工编号这个字段里。那么在这种情况下，假如需要去查询某一位员工的上司的信息，在已知该员工编号的条件下，可以根据他的编号去获得上司的编号，进而通过上司的编号去获得上司的信息。

### 三张表优化A B C

* 小表驱动大表  
* 索引建立在经常查询的字段上


## 避免索引失效的一些原则 

#### 复合索引

* 复合索引，不要跨列或无序使用（最佳左前缀）

* 复合索引，尽量使用全索引匹配

复合索引可以看为是书的目录(a,b,c)一级目录a二级目录b三级目录c

#### 索引操作

不要在索引上进行任何操作（计算、函数、类型转换），否则索引失效

</code></pre>

<p>sql
select ..where A.x = .. ;  &ndash;假设A.x是索引</p>

<p>&ndash;不要：select ..where A.x*3 = .. ;</p>

<p>explain select * from book where authorid = 1 and typeid = 2 ;&ndash;用到了at2个索引</p>

<p>explain select * from book where authorid = 1 and typeid*2 = 2 ;&ndash;用到了a1个索引</p>

<p>explain select * from book where authorid*2 = 1 and typeid*2 = 2 ;&mdash;-用到了0个索引</p>

<p>explain select * from book where authorid*2 = 1 and typeid = 2 ;&mdash;-用到了0个索引,</p>

<pre><code>
原因：对于复合索引，如果左边失效，右侧全部失效。(a,b,c)，例如如果 b失效，则b c同时失效。

如果是单独的索引就没有这种问题

</code></pre>

<p>sql
drop index idx_atb on book ;</p>

<p>alter table book add index idx_authroid (authorid) ;</p>

<p>alter table book add index idx_typeid (typeid) ;</p>

<pre><code>
独立索引，不影响

</code></pre>

<p>sql
explain select * from book where authorid*2 = 1 and typeid = 2 ;&ndash;使用到了0个索引
explain select * from book where authorid*2 = 1 and typeid = 2 ;&ndash;使用到了一个索引</p>

<pre><code>
#### 复合索引关键判断

复合索引不能使用不等于（!=  &lt;&gt;）或is null (is not null)，否则自身以及右侧索引全部失效。

复合索引中如果有&gt;，则自身和右侧索引全部失效。

</code></pre>

<p>sql
explain select * from book where authorid = 1 and typeid =2 ;&ndash;预测使用两个索引，实际使用到了一个索引</p>

<pre><code>
-- SQL优化，是一种概率层面的优化。至于是否实际使用了我们的优化，需要通过explain进行推测。

</code></pre>

<p>sql
explain select * from book where authorid != 1 and typeid =2 ;&ndash;authorid失效</p>

<p>explain select * from book where authorid != 1 and typeid !=2 ;&ndash;两个索引都失效</p>

<pre><code>

​   
体验概率情况(&lt; &gt; =)：

原因是服务层中有SQL优化器，可能会影响我们的优化。

</code></pre>

<p>sql
show index from book;
drop index idx_typeid on book;</p>

<p>drop index idx_authroid on book;</p>

<p>alter table book add index idx_book_at (authorid,typeid);</p>

<p>explain select * from book where authorid = 1 and typeid =2 ;&ndash;复合索引at全部使用</p>

<pre><code>

    explain select * from book where authorid &gt; 1 and typeid =2 ; 
--复合索引中如果有&gt;，则自身和右侧索引全部失效。(大部分的情况下是这种)

</code></pre>

<p>sql
explain select * from book where authorid = 1 and typeid &gt;2 ;</p>

<pre><code>
--复合索引at全部使用

明显的概率问题：下面几个很明显

</code></pre>

<p>sql
explain select * from book where authorid &lt; 1 and typeid =2 ;</p>

<pre><code>--复合索引at只用到了1个索引

</code></pre>

<p>sql
explain select * from book where authorid &lt; 4 and typeid =2 ;&ndash; 只是将1改为了4</p>

<pre><code>--复合索引全部失效

* 我们学习的索引优化 ，是一个大部分情况适用的结论，但由于SQL优化器等原因  该结论不是100%正确。
* 一般而言， 范围查询（&gt; &lt;  in），之后的索引失效。

**补救尽量使用索引覆盖（using index）**

不会出错，永远成立

</code></pre>

<p>sql
（a,b,c）</p>

<p>select a,b,c from xx..where a=  .. and b =.. ;</p>

<pre><code>
#### Like问题

**like尽量以“常量”开头，不要以'%'开头，否则索引失效**

</code></pre>

<p>sql
select * from xx where name like &lsquo;%x%&rsquo; ;</p>

<pre><code>--name即使是一个索引，也会失效
    

</code></pre>

<p>sql
explain select * from teacher  where tname like &lsquo;%x%&rsquo;;</p>

<pre><code>--tname索引失效（开发过程中不要使用*）

</code></pre>

<p>sql
explain select * from teacher  where tname like &lsquo;x%&rsquo;;</p>

<pre><code> --使用name索引，索引为没失效

</code></pre>

<p>sql
explain select tname from teacher  where tname like &lsquo;%x%&rsquo;;</p>

<pre><code>
--如果必须使用like '%x%'进行模糊查询，可以使用索引覆盖 挽救一部分。

#### 类型转换

**尽量不要使用类型转换（显示、隐式），否则索引失效**

</code></pre>

<p>sql
explain select * from teacher where tname = &lsquo;abc&rsquo; ;&ndash;使用了索引没问题
explain select * from teacher where tname = 123 ;&ndash;程序底层将 123 -&gt; &lsquo;123&rsquo;，即进行了类型转换，因此索引失效</p>

<pre><code>
#### or

尽量不要使用or，否则索引失效

</code></pre>

<p>sql
explain select * from teacher where tname =&ldquo;;&ndash;索引正常
explain select * from teacher where tname =&rdquo; or tcid &gt;1 ; &ndash;将or左侧的tname 失效。</p>

<pre><code>

## 一些其他的优化方法

### exist和in

</code></pre>

<p>sql
select ..from table where exist (子查询) ;
select ..from table where 字段 in  (子查询) ;</p>

<pre><code>
如果主查询的数据集大，则使用In ,效率高。

如果子查询的数据集大，则使用exist,效率高。    

---
exist语法： 将主查询的结果，放到子查询结果中进行条件校验（看子查询是否有数据，如果有数据则校验成功）  ，如果符合校验，则保留数据；

</code></pre>

<p>sql
select tname from teacher where exists (select * from teacher) ;</p>

<pre><code>--等价于`select tname from teacher`

</code></pre>

<p>sql
select tname from teacher where exists (select * from teacher where tid =9999) ;</p>

<pre><code>子查询没数据,校验失败

---
in:

</code></pre>

<p>sql
select ..from table where tid in  (1,3,5) ;</p>

<pre><code>
### order by 优化

using filesort 有两种算法：双路排序、单路排序 （根据IO（访问硬盘文件）的次数）

MySQL4.1之前 默认使用 双路排序；

双路：扫描2次磁盘

1. 从磁盘读取排序字段 ,对排序字段进行排序（在buffer(缓冲区)中进行的排序）

2. 扫描其他字段

    --IO较消耗性能

MySQL4.1之后 默认使用 单路排序  ： 

只读取一次（全部字段），在buffer中进行排序。

但此种单路排序 会有一定的隐患 （不一定真的是“单路|1次IO”，有可能多次IO）。

原因：如果数据量特别大，则无法 将所有字段的数据 一次性读取完毕，因此 会进行“分片读取、多次读取”。

注意：单路排序 比双路排序 会占用更多的buffer。

单路排序在使用时，如果数据大，可以考虑调大buffer的容量大小：  sql命令

</code></pre>

<p>sql
set max_length_for_sort_data = 1024;  &ndash;单位byte</p>

<pre><code>
如果max_length_for_sort_data值太低，则mysql会自动从 单路-&gt;双路   （太低：需要排序的列的总大小超过了max_length_for_sort_data定义的字节数）

提高order by查询的策略：

1. 选择使用单路、双路 ；调整buffer的容量大小；

2. 避免select * ...  用什么查什么

1. 复合索引 不要跨列使用 ，避免using filesort

1. 保证全部的排序字段 排序的一致性（都是升序 或 降序）
        
        
## SQL排查 - 慢查询日志:

MySQL提供的一种日志记录，用于记录MySQL种响应时间超过阀值的SQL语句 （long_query_time，默认10秒）

慢查询日志默认是关闭的；

建议：开发调优是 打开，而 最终部署时关闭。
    
检查是否开启了 慢查询日志 ：   

</code></pre>

<p>sql
show variables like &lsquo;%slow_query_log%&rsquo; ;</p>

<pre><code>
临时开启：mysql退出重启服务后关闭

</code></pre>

<p>sql
set global slow_query_log = 1 ;  &ndash;在内存中开启</p>

<p>exit</p>

<p>service mysql restart</p>

<pre><code>
永久开启：

/etc/my.cnf 中追加配置：

    vi /etc/my.cnf 
    [mysqld]
    slow_query_log=1
    slow_query_log_file=/var/lib/mysql/localhost-slow.log


慢查询阀值：

</code></pre>

<p>sql
show variables like &lsquo;%long_query_time%&rsquo; ;</p>

<pre><code>
临时设置阀值：

</code></pre>

<p>sql
set global long_query_time = 5 ; &ndash;设置完毕后，重新登陆后起效 （不需要重启服务）</p>

<pre><code>
永久设置阀值：
            
/etc/my.cnf 中追加配置：

    vi /etc/my.cnf 
    [mysqld]
    long_query_time=3

实例

    select sleep(4);
    select sleep(5);
    select sleep(3);
    select sleep(3);

--查询超过阀值的SQL： 

</code></pre>

<p>sql
 show global status like &lsquo;%slow_queries%&rsquo; ;</p>

<pre><code>
1. 慢查询的sql被记录在了日志中，因此可以通过日志 查看具体的慢SQL。

</code></pre>

<p>shell
   cat /var/lib/mysql/localhost-slow.log</p>

<pre><code>
1. 通过mysqldumpslow工具查看慢SQL,可以通过一些过滤条件 快速查找出需要定位的慢SQL

        mysqldumpslow --help
        s：排序方式
        r:逆序
        l:锁定时间
        g:正则匹配模式        

**linux命令**

获取返回记录最多的3个SQL

    mysqldumpslow -s r -t 3  /var/lib/mysql/localhost-slow.log

获取访问次数最多的3个SQL

    mysqldumpslow -s c -t 3 /var/lib/mysql/localhost-slow.log

按照时间排序，前10条包含left join查询语句的SQL

    mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/localhost-slow.log

语法：

    mysqldumpslow 各种参数  慢查询日志的文件



## 分析海量数据

**模拟海量数据  存储过程（无return）/存储函数（有return）**

</code></pre>

<p>sql
create database testdata ;
use testdata</p>

<p>create table dept
(
    dno int(5) primary key default 0,
    dname varchar(20) not null default &ldquo;,
    loc varchar(30) default &ldquo;
)engine=innodb default charset=utf8;</p>

<p>create table emp
(
    eid int(5) primary key,
    ename varchar(20) not null default &ldquo;,
    job varchar(20) not null default &ldquo;,
    deptno int(5) not null default 0
)engine=innodb default charset=utf8;</p>

<pre><code>
#### 通过存储函数 插入海量数据：

1. 创建存储函数：

    ```sql
    randstring(6)  -&gt;aXiayx  用于模拟员工名称
    
    delimiter $ 
    
    create function randstring(n int)   returns varchar(255) 
    begin
        declare  all_str varchar(100) default 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ;
        declare return_str varchar(255) default '' ;
        declare i int default 0 ; 
        while i&lt;n        
        do                                  
            set return_str = concat(  return_str,      substring(all_str,   FLOOR(1+rand()*52)   ,1)       );
            set i=i+1 ;
        end while ;
        return return_str;
        
    end $ 
    ```
    

--如果报错：You have an error in your SQL syntax，说明SQL语句语法有错，需要修改SQL语句；

 如果报错`This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)`
是因为 存储过程/存储函数在创建时 与之前的 开启慢查询日志冲突了 

解决冲突：

临时解决( 开启log_bin_trust_function_creators )

</code></pre>

<p>sql
	show variables like &lsquo;%log_bin_trust_function_creators%&lsquo;;</p>

<p>	set global log_bin_trust_function_creators = 1;</p>

<pre><code>
永久解决：

</code></pre>

<p>s
/etc/my.cnf
[mysqld]
log_bin_trust_function_creators = 1</p>

<pre><code>
**创建产生随机整数存储函数（0-99）**

</code></pre>

<p>sql
create function ran_num() returns int(5)
begin
	declare i int default 0;
	set i =floor( rand()*100 ) ;
	return i ;
end $</p>

<pre><code>
**通过存储过程插入海量数据：**

emp表中，从eid_start开始插入data_times条数据

</code></pre>

<p>sql
create procedure insert_emp( in eid_start int(10),in data_times int(10))
begin
	declare i int default 0;
	set autocommit = 0 ;
	repeat
		insert into emp values(eid_start + i, randstring(5) ,&lsquo;other&rsquo; ,ran_num()) ;
		set i=i+1 ;
		until i=data_times
	end repeat ;
	commit ;
end $</p>

<pre><code>
**--通过存储过程插入海量数据：dept表中**  

</code></pre>

<p>sql
create procedure insert_dept(in dno_start int(10) ,in data_times int(10))
begin
    declare i int default 0;
    set autocommit = 0 ;
    repeat</p>

<pre><code>    insert into dept values(dno_start+i ,randstring(6),randstring(8)) ;
    set i=i+1 ;
    until i=data_times
end repeat ;
</code></pre>

<p>commit ;
end$</p>

<pre><code>
**--插入数据**

</code></pre>

<p>sql
	delimiter ;
	call insert_emp(1000,800000) ;
	call insert_dept(10,30) ;</p>

<pre><code>
#### 分析海量数据:

##### profiles

</code></pre>

<p>shell
show profiles ; &ndash;默认关闭</p>

<p>show variables like &lsquo;%profiling%&rsquo;;</p>

<p>set profiling = on ;</p>

<p>show profiles  ：会记录所有profiling打开之后的  全部SQL查询语句所花费的时间。缺点：不够精确，只能看到 总共消费的时间，不能看到各个硬件消费的时间（cpu  io ）</p>

<pre><code>
##### 精确分析:sql诊断

</code></pre>

<p>sql
 show profile all for query 上一步查询的的Query_Id</p>

<p>show profile cpu,block io for query 上一步查询的的Query_Id</p>

<pre><code>
##### 全局查询日志 ：

记录开启之后的 全部SQL语句。 （这次全局的记录操作 仅仅在调优、开发过程中打开即可，在最终的部署实施时 一定关闭）

</code></pre>

<p>sql
show variables like &lsquo;%general_log%&lsquo;;</p>

<pre><code>
* --执行的所有SQL记录在表中

    ```sql
    set global general_log = 1 ;--开启全局日志
    set global log_output='table' ; --设置 将全部的SQL 记录在表中
    ```
    
* --执行的所有SQL记录在文件中

    ```sql
    set global log_output='file' ;
    set global general_log = on ;
    set global general_log_file='/tmp/general.log' ;
    ```
    

开启后，会记录所有SQL ： 会被记录mysql.general_log表中。

</code></pre>

<p>sql
select * from  mysql.general_log ;</p>

<pre><code>
## 锁机制

锁机制 ：解决因资源共享 而造成的并发问题。

示例：买最后一件衣服X

    A:      X   买 ：  X加锁 -&gt;试衣服...下单..付款..打包 -&gt;X解锁
    B:  X       买：发现X已被加锁，等待X解锁，   X已售空

分类：

1. 操作类型：

    1. 读锁（共享锁）： 对同一个数据（衣服），多个读操作可以同时进行，互不干扰。

    2. 写锁（互斥锁）： 如果当前写操作没有完毕（买衣服的一系列操作），则无法进行其他的读操作、写操作

1. 操作范围：

    1. 表锁 ：一次性对一张表整体加锁。如MyISAM存储引擎使用表锁，开销小、加锁快；无死锁；但锁的范围大，容易发生锁冲突、并发度低。

    1. 行锁 ：一次性对一条数据加锁。如InnoDB存储引擎使用行锁，开销大，加锁慢；容易出现死锁；锁的范围较小，不易发生锁冲突，并发度高（很小概率 发生高并发问题：脏读、幻读、不可重复度、丢失更新等问题）。

    1. 页锁       
    

示例：

### 表锁 ：  

--自增操作 MYSQL/SQLSERVER 支持；oracle需要借助于序列来实现自增

</code></pre>

<p>sql
create table tablelock
(
    id int primary key auto_increment ,
    name varchar(20)
)engine myisam;
insert into tablelock(name) values(&lsquo;a1&rsquo;);
insert into tablelock(name) values(&lsquo;a2&rsquo;);
insert into tablelock(name) values(&lsquo;a3&rsquo;);
insert into tablelock(name) values(&lsquo;a4&rsquo;);
insert into tablelock(name) values(&lsquo;a5&rsquo;);
commit;</p>

<pre><code>
增加锁：

</code></pre>

<p>sql
locak table 表1  read/write  ,表2  read/write   ,&hellip;</p>

<pre><code>
查看加锁的表：

</code></pre>

<p>sql
show open tables ;</p>

<pre><code>
会话：session :每一个访问数据的dos命令行、数据库客户端工具  都是一个会话

### 加读锁：
1. 会话0：

    ```sql
    lock table  tablelock read ;
    
    select * from tablelock; --读（查），可以
    
    delete from tablelock where id =1 ; --写（增删改），不可以
    ```

    其他表

    ```sql
    select * from emp ; --读，不可以
    delete from emp where eid = 1; --写，不可以
    ```

    结论1：

    * --如果某一个会话 对A表加了read锁，则 该会话 可以对A表进行读操作、不能进行写操作：且该会话不能对其他表进行读、写操作。

    * --即如果给A表加了读锁，则当前会话只能对A表进行读操作。

2. 会话1（其他会话）：

    ```sql
    select * from tablelock;   --读（查），可以
    
    delete from tablelock where id =1 ; --写，会“等待”会话0将锁释放
    ```


2. 会话2（其他会话）：操作其他表

    ```sql
    select * from emp ;  --读（查），可以
    
    ```

delete from emp where eid = 1; --写，可以
    ```

    --总结：
    
    会话0给A表加了锁；其他会话的操作：
    
    1. 可以对其他表（A表以外的表）进行读、写操作
    1. 对A表：读-可以；  写-需要等待释放锁。

释放锁: 

</code></pre>

<p>sql
unlock tables ;</p>

<pre><code>


### 加写锁：

1. 会话0：

    ```sql
    lock table tablelock write ;
    ```

    当前会话（会话0） 可以对加了写锁的表  进行任何操作（增删改查）；但是不能 操作（增删改查）其他表

1. 其他会话：

    对会话0中加写锁的表 可以进行增删改查的前提是：等待会话0释放写锁

### MySQL表级锁的锁模式

MyISAM

在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，

在执行更新操作（DML）前，会自动给涉及的表加写锁。

所以对MyISAM表进行操作，会有以下情况：

* 对MyISAM表的读操作（加读锁），不会阻塞其他进程（会话）对同一表的读请求，
但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。

* 对MyISAM表的写操作（加写锁），会阻塞其他进程（会话）对同一表的读和写操作，
只有当写锁释放后，才会执行其它进程的读写操作。

### 分析表锁定：

查看哪些表加了锁：   

</code></pre>

<p>sql
show open tables ;  1代表被加了锁</p>

<pre><code>
分析表锁定的严重程度： 

</code></pre>

<p>sql
show status like &lsquo;table%&rsquo; ;</p>

<p>Table_locks_immediate :即可能获取到的锁数</p>

<p>Table_locks_waited：需要等待的表锁数(如果该值越大，说明存在越大的锁竞争)</p>

<pre><code>
一般建议：

Table_locks_immediate/Table_locks_waited &gt; 5000， 建议采用InnoDB引擎，否则MyISAM引擎


### 行锁（InnoDB）

</code></pre>

<p>sql
create table linelock(
    id int(5) primary key auto_increment,
    name varchar(20)
)engine=innodb ;
insert into linelock(name) values(&lsquo;1&rsquo;)  ;
insert into linelock(name) values(&lsquo;2&rsquo;)  ;
insert into linelock(name) values(&lsquo;3&rsquo;)  ;
insert into linelock(name) values(&lsquo;4&rsquo;)  ;
insert into linelock(name) values(&lsquo;5&rsquo;)  ;</p>

<pre><code>

--mysql默认自动commit;  oracle默认不会自动commit ;

为了研究行锁，暂时将自动commit关闭; 

</code></pre>

<p>sql
set autocommit =0 ;</p>

<pre><code>
以后需要通过commit


会话0： 写操作

</code></pre>

<p>sql
insert into linelock values(6,&lsquo;a6&rsquo;) ;</p>

<pre><code>
会话1： 写操作 同样的数据

</code></pre>

<p>sql
update linelock set name=&lsquo;ax&rsquo; where id = 6;</p>

<pre><code>
对行锁情况：

1. 如果会话x对某条数据a进行 DML操作（研究时：关闭了自动commit的情况下），则其他会话必须等待会话x结束事务(commit/rollback)后  才能对数据a进行操作。

2. 表锁 是通过unlock tables，也可以通过事务解锁 ; 行锁 是通过事务解锁。  

行锁，操作不同数据：
    
会话0： 写操作
    

</code></pre>

<p>sql
insert into linelock values(8,&lsquo;a8&rsquo;) ;</p>

<pre><code>
会话1： 写操作， 不同的数据

</code></pre>

<p>sql
update linelock set name=&lsquo;ax&rsquo; where id = 5;</p>

<pre><code>
行锁，一次锁一行数据；因此 如果操作的是不同数据，则不干扰。


行锁的注意事项：

1. 如果没有索引，则行锁会转为表锁

    ```sql
    show index from linelock ;
    
    alter table linelock add index idx_linelock_name(name);
    ```


    会话0： 写操作
    
    ```sql
    update linelock set name = 'ai' where name = '3' ;
    ```
    
    会话1： 写操作， 不同的数据
    
    ```sql
    update linelock set name = 'aiX' where name = '4' ;
    ```
    
    两者互不干扰
    
    会话0： 写操作
    
    ```sql
    update linelock set name = 'ai' where name = 3 ;
    ```
    
    会话1： 写操作， 不同的数据
    
    ```sql
    update linelock set name = 'aiX' where name = 4 ;
    ```
    
    --可以发现，数据被阻塞了（加锁）
    
    -- 原因：如果索引类 发生了类型转换，则索引失效。 因此 此次操作，会从行锁 转为表锁。

1. 行锁的一种特殊情况：间隙锁：值在范围内，但却不存在

     --此时linelock表中 没有id=7的数据

    ```sql
update linelock set name ='x' where id &gt;1 and id&lt;9 ;  
    ```
    
    --即在此where范围中，没有id=7的数据，则id=7的数据成为间隙。
    
    ```sql
insert into linelock values(7,&quot;zs&quot;);
    ```

    --结果被锁住了

    间隙：Mysql会自动给 间隙 加锁 -&gt;间隙锁。即 本题 会自动给id=7的数据加 间隙锁（行锁）。
    
    行锁：如果有where，则实际加锁的范围 就是where后面的范围（不是实际的值）（2-8之间都加上锁）
    
    

如果仅仅是查询数据，能否加锁？ 

可以   `for update `

研究学习时，将自动提交关闭：(三种方式)

</code></pre>

<p>sql
set autocommit =0 ;</p>

<p>start transaction ;</p>

<p>begin ;</p>

<pre><code></code></pre>

<p>sql
	select * from linelock where id =2 for update ;</p>

<pre><code>通过`for update`对`query`语句进行加锁。

**行锁**：

InnoDB默认采用行锁；

缺点： 比表锁性能损耗大。

优点：并发能力强，效率高。

因此建议，高并发用InnoDB，否则用MyISAM。

行锁分析：


</code></pre>

<p>sql
show status like &lsquo;%innodb_row_lock%&rsquo; ;</p>

<p>Innodb_row_lock_current_waits :当前正在等待锁的数量<br />
Innodb_row_lock_time：等待总时长。从系统启到现在 一共等待的时间
Innodb_row_lock_time_avg  ：平均等待时长。从系统启到现在平均等待的时间
Innodb_row_lock_time_max  ：最大等待时长。从系统启到现在最大一次等待的时间
Innodb_row_lock_waits ：	等待次数。从系统启到现在一共等待的次数</p>

<pre><code>

### 主从复制  （集群在数据库的一种实现）

集群的优点
1. 负载均衡
2. 失败迁移

windows:mysql 主

linux:mysql从

安装windows版mysql:

如果之前计算机中安装过Mysql，要重新再安装  则需要：先卸载 再安装

#### 先卸载：

1. 通过电脑自带卸载工具卸载Mysql (电脑管家也可以)
    
2. 删除一个mysql缓存文件夹C:\ProgramData\MySQL
   
3. 删除注册表regedit中所有mysql相关配置

4. --重启计算机
   
#### 安装MYSQL：

[下载官网](https://dev.mysql.com/downloads/mysql/5.5.html#downloads)

安装时，如果出现未响应：  则重新打开

    xxx\bin\MySQLInstanceConfig.exe

图形化客户端： SQLyog, Navicat

如果要远程连接数据库，则需要授权远程访问。 

在linux中授权远程访问 :(A-&gt;B,则再B计算机的Mysql中执行以下命令)

    GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;
    
    FLUSH PRIVILEGES;

如果仍然报错：可能是防火墙没关闭 ：  在B关闭防火墙

</code></pre>

<p>shell
service iptables stop</p>

<pre><code>
实现主从同步（主从复制）：

主从同步的核心：通过二进制日志

1. master将改变的数 记录在本地的 二进制日志中（binary log） ；该过程 称之为：二进制日志事件

2. slave将master的binary log拷贝到自己的 relay log（中继日志文件）中

3. 中继日志事件，将数据读取到自己的数据库之中
    MYSQL主从复制 是异步的，串行化的， 有延迟

MYSQL主从复制是异步的，串行化的，有延迟的

    master:slave = 1:n

配置： 

windows(mysql: my.ini)

linux(mysql: my.cnf)

配置前，为了无误，先将权限(远程访问)、防火墙等处理：

关闭windows/linux防火墙： 

1. windows：右键“网络”   

2. linux: 

    ```shell
    service iptables stop
    ```

Mysql允许远程连接(windowos/linux)：

    GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;
    FLUSH PRIVILEGES;

window mysql8.0 版本修改允许访问远程权限

    use mysql;
    
    select host, user, authentication_string, plugin from user;
    
    update user set host='%' where user='root';
    
    grant all privileges on *.* to root@'%';
    
    flush privileges;

#### 主机（以下代码和操作 全部在主机windows中操作）：my.ini

    [mysqld]
    #id
    server-id=1
    #二进制日志文件（注意是/  不是\）
    log-bin=&quot;C:/Program Files/MySQL/MySQL Server 8.0/data/mysql-bin&quot;
    #错误记录文件
    log-error=&quot;C:/Program Files/MySQL/MySQL Server 8.0/data/mysql-error&quot;
    #主从同步时 忽略的数据库
    binlog-ignore-db=mysql
    #(可选)指定主从同步时，同步哪些数据库
    binlog-do-db=test   

windows中的数据库 授权哪台计算机中的数据库 是自己的从数据库：

    GRANT REPLICATION slave,reload,super ON *.* TO 'root'@'192.168.2.%' IDENTIFIED BY 'root';
    flush privileges ; 

查看主数据库的状态（每次在左主从同步前，需要观察 主机状态的最新值）

</code></pre>

<p>sql
show master status;（mysql-bin.000001、 107）</p>

<pre><code>（mysql-bin.000001、 107）：二进制文件名和位置


#### 从机（以下代码和操作 全部在从机linux中操作）：

    my.cnf
    [mysqld]
    server-id=2
    log-bin=mysql-bin
    replicate-do-db=test

linux中的数据 授权哪台计算机中的数控 是自己的主计算机

    CHANGE MASTER TO 
    MASTER_HOST = '192.168.2.2', 
    MASTER_USER = 'root', 
    MASTER_PASSWORD = 'root', 
    MASTER_PORT = 3306,
    master_log_file='mysql-bin.000001',
    master_log_pos=107;

如果报错：This operation cannot be performed with a running slave; run STOP SLAVE first

解决：

</code></pre>

<p>shell
STOP SLAVE ;</p>

<pre><code>
再次执行上条授权语句

#### 开启主从同步：

从机linux:

</code></pre>

<p>shell
start slave ;</p>

<pre><code>
检验  

</code></pre>

<p>sql
show slave status \G</p>

<pre><code>
主要观察： Slave_IO_Running和 Slave_SQL_Running，确保二者都是yes；如果不都是yes，则看下方的 Last_IO_Error。

本次 通过 Last_IO_Error发现错误的原因是 主从使用了相同的server-id， 检查:在主从中分别查看serverid:  

</code></pre>

<p>sql
show variables like &lsquo;server_id&rsquo; ;</p>

<pre><code>
可以发现，在Linux中的my.cnf中设置了server-id=2，但实际执行时 确实server-id=1，原因：可能是 linux版Mysql的一个bug，也可能是 windows和Linux版本不一致造成的兼容性问题。

解决改bug： 

</code></pre>

<p>sql
set global server_id =2 ;</p>

<pre><code>重复执行上面

</code></pre>

<p>shell
stop slave ;</p>

<p>set global server_id =2 ;</p>

<p>start slave ;</p>

<p>show slave status \G
```
确保两个是yes</p>

<h4 id="演示">演示：</h4>

<p>主windows =&gt;从</p>

<p>windows:</p>

<pre><code>将表，插入数据 
</code></pre>

<p>linux</p>

<pre><code>观察从数据库中该表的数据
</code></pre>

    </div>
    <div class="article-footer">
<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接: </strong>
      <a href="https://mumulx.github.io/2020/01/sql%E4%BC%98%E5%8C%96mysql%E7%89%88/" title="SQL优化Mysql版" target="_blank" rel="external">https://mumulx.github.io/2020/01/sql%E4%BC%98%E5%8C%96mysql%E7%89%88/</a>
    </li>
    <li class="post-copyright-license">
      <strong>License：</strong><a href="https://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN</a>
    </li>
  </ul>
</blockquote>

<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/mumulx" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="https://mumulx.github.io/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/mumulx" target="_blank"><span class="text-dark">木木就是两个木</span><small class="ml-1x">木木</small></a></h3>
        <div>愿生活不太拥挤，愿笑容不必刻意。</div>
      </div>
    </figure>
  </div>
</div>
    </div>
  </article>
<section id="comments">
</section>

</div><nav class="bar bar-footer clearfix" data-stick-bottom>
    <div class="bar-inner">
        <ul class="pager pull-left">
            <li class="prev">
                <a href="https://mumulx.github.io/2020/01/mybatisplus%E5%92%8Cmapper%E6%A1%86%E6%9E%B6/" title="MybatisPlus和Mapper框架"><i
                        class="icon icon-angle-left"
                        aria-hidden="true"></i><span>&nbsp;&nbsp;下一篇</span></a>
            </li>
            <li class="next">
                <a href="https://mumulx.github.io/2020/01/dubbo%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"
                    title="Dubbo自学笔记"><span>上一篇&nbsp;&nbsp;</span><i
                        class="icon icon-angle-right" aria-hidden="true"></i></a>
            </li>
            
            <li class="toggle-toc">
                <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false"
                    title="文章目录" role="button">
                    <span>[&nbsp;</span><span>文章目录</span>
                    <i class="text-collapsed icon icon-anchor"></i>
                    <i class="text-in icon icon-close"></i>
                    <span>]</span>
                </a>
            </li>
        </ul>
        
        <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal"
            data-target="#donateModal"><span>赏</span></button>
        
        <div class="bar-right">
            <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter"
                data-mobile-sites="weibo,qq,qzone"></div>
        </div>
    </div>
</nav>


<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content donate">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                    aria-hidden="true">&times;</span></button>
            <div class="modal-body">
                <div class="donate-box">
                    <div class="donate-head">
                        <p>感谢您的支持,我会继续努力的!</p>
                    </div>
                    <div class="tab-content">
                        <div role="tabpanel" class="tab-pane fade active in" id="alipay">
                            <div class="donate-payimg">
                                <img src="https://mumulx.github.io/donate/alipayimg.png"
                                    alt="扫码支持" title="扫一扫" />
                            </div>
                            <p class="text-muted mv">扫码打赏, 多少你说了算~</p>
                            <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦~</p>
                        </div>
                        <div role="tabpanel" class="tab-pane fade" id="wechatpay">
                            <div class="donate-payimg">
                                <img src="https://mumulx.github.io/donate/wechatpayimg.png"
                                    alt="扫码支持" title="扫一扫" />
                            </div>
                            <p class="text-muted mv">扫码打赏, 多少你说了算~</p>
                            <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
                        </div>
                    </div>
                    <div class="donate-footer">
                        <ul class="nav nav-tabs nav-justified" role="tablist">
                            <li role="presentation" class="active">
                                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay"
                                    aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
                            </li>
                            <li role="presentation" class="">
                                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab"
                                    aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i>
                                    微信支付</a>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
</main><footer class="footer" itemscope itemtype="https://schema.org/WPFooter">
<ul class="social-links">
    <li><a href="https://github.com/mumulx" target="_blank" title="github" data-toggle=tooltip data-placement=top >
            <i class="icon icon-github"></i></a></li>
    <li><a href="https://mumulx.github.io/index.xml" target="_blank" title="rss" data-toggle=tooltip data-placement=top >
            <i class="icon icon-rss"></i></a></li>
    <li><a href="https://weibo.com/u/5459389722" target="_blank" title="weibo" data-toggle=tooltip data-placement=top >
            <i class="icon icon-weibo"></i></a></li>
</ul>
  <div class="copyright">
    &copy;2019  -
    2020
    <div class="publishby">
        联系邮箱：<a target="_blank" title="木木的邮箱"> 1819778796@qq.com </a>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script>
   window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/highlight.min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/rust.min.js"></script>
<script type="text/javascript"
   src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script>
hljs.configure({
  tabReplace: '    ', 
  classPrefix: ''     
                      
})
hljs.initHighlightingOnLoad();
</script>
<script type="text/javascript" src="https://mumulx.github.io/js/application.js"></script>
<script type="text/javascript" src="https://mumulx.github.io/js/plugin.js"></script>
<script>
      (function (window) {
          var INSIGHT_CONFIG = {
              TRANSLATION: {
                  POSTS: '文章',
                  PAGES: '页面',
                  CATEGORIES: '分类',
                  TAGS: '标签',
                  UNTITLED: '(未命名)',
              },
              ROOT_URL: 'https:\/\/mumulx.github.io\/',
              CONTENT_URL: 'https:\/\/mumulx.github.io\/\/searchindex.json ',
          };
          window.INSIGHT_CONFIG = INSIGHT_CONFIG;
      })(window);
      </script>
<script type="text/javascript" src="https://mumulx.github.io/js/insight.js"></script>


<script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '1ccf8dc9e86b3575cfb2',
        clientSecret: '048ae422c4a6207a4e89c58ba1d4ebf820136bb0',
        repo: 'gittalk',
        owner: 'mumulx',
        admin: ['mumulx'],
        id: md5(location.pathname),
        distractionFreeMode: true
    });
    gitalk.render('comments');
</script>

  </body>
</html>
