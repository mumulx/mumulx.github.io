<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>
        Java并发编程 - 木木的个人博客
      </title>
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  
  <meta name="theme-color" content="#000000" />
  
  <meta http-equiv="window-target" content="_top" />
  
  
  <meta name="description" content="Java并发编程" />
  <meta name="generator" content="Hugo 0.59.1 with theme pure" />
  <title>Java并发编程 - 木木的个人博客</title>
  

  <link rel="stylesheet" href="https://gitee.com/mumulx/blog/css/style.css">
  <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.15.10/styles/github.min.css"> 
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <meta property="og:title" content="Java并发编程" />
<meta property="og:description" content="Java并发编程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://gitee.com/mumulx/blog/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" />
<meta property="article:published_time" content="2020-04-25T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-04-25T00:00:00+00:00" />

<meta itemprop="name" content="Java并发编程">
<meta itemprop="description" content="Java并发编程">


<meta itemprop="datePublished" content="2020-04-25T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-04-25T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="58352">



<meta itemprop="keywords" content="Java,Java并发编程," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java并发编程"/>
<meta name="twitter:description" content="Java并发编程"/>

  <!--[if lte IE 9]>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
    <![endif]-->

  <!--[if lt IE 9]>
      <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
    <![endif]-->

</head>
  </head>
  

  <body class="main-center" itemscope itemtype="https://schema.org/WebPage"><header class="header" itemscope itemtype="https://schema.org/WPHeader">
    <div class="slimContent">
      <div class="navbar-header">
        <div class="profile-block text-center">
          <a id="avatar" href="https://github.com/mumulx" target="_blank">
            <img class="img-circle img-rotate" src="https://gitee.com/mumulx/blog/avatar.png" width="200" height="200">
          </a>
          <h2 id="name" class="hidden-xs hidden-sm">木木就是两个木</h2>
          <h3 id="title" class="hidden-xs hidden-sm hidden-md">木木</h3>
          <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i>xuzhou, China</small>
        </div><div class="search" id="search-form-wrap">
    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i
                        class="icon icon-search"></i></button>
            </span>
        </div>
        <div class="ins-search">
            <div class="ins-search-mask"></div>
            <div class="ins-search-container">
                <div class="ins-input-wrapper">
                    <input type="text" class="ins-search-input" placeholder="想要查找什么..."
                        x-webkit-speech />
                    <button type="button" class="close ins-close ins-selectable" data-dismiss="modal"
                        aria-label="Close"><span aria-hidden="true">×</span></button>
                </div>
                <div class="ins-section-wrapper">
                    <div class="ins-section-container"></div>
                </div>
            </div>
        </div>
    </form>
</div>
        <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
      <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="https://schema.org/SiteNavigationElement" role="navigation">
        <ul class="nav navbar-nav main-nav">
            <li class="menu-item menu-item-home">
                <a href="/mumulx/blog/">
                    <i class="icon icon-home-fill"></i>
                  <span class="menu-title">Home</span>
                </a>
            </li>
            <li class="menu-item menu-item-archives">
                <a href="/mumulx/blog/posts">
                    <i class="icon icon-archives-fill"></i>
                  <span class="menu-title">Archives</span>
                </a>
            </li>
            <li class="menu-item menu-item-categories">
                <a href="/mumulx/blog/categories">
                    <i class="icon icon-folder"></i>
                  <span class="menu-title">Categories</span>
                </a>
            </li>
            <li class="menu-item menu-item-tags">
                <a href="/mumulx/blog/tags">
                    <i class="icon icon-tags"></i>
                  <span class="menu-title">Tags</span>
                </a>
            </li>
            <li class="menu-item menu-item-about">
                <a href="/mumulx/blog/about">
                    <i class="icon icon-cup-fill"></i>
                  <span class="menu-title">About</span>
                </a>
            </li>
        </ul>
      </nav>
    </div>
  </header>
  <aside class="sidebar" itemscope itemtype="https://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content"><p>我们的征途是星辰大海！</p>
            </div>
        </div>
    </div>
</div>

      <div class="widget">
    <h3 class="widget-title"> 分类</h3>
    <div class="widget-body">
        <ul class="category-list">
            <li class="category-list-item"><a href="https://gitee.com/mumulx/blog/categories/java%E9%9D%A2%E8%AF%95/" class="category-list-link">java面试</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://gitee.com/mumulx/blog/categories/%E6%8A%80%E6%9C%AF%E6%94%B6%E5%BD%95/" class="category-list-link">技术收录</a><span class="category-list-count">29</span></li>
            <li class="category-list-item"><a href="https://gitee.com/mumulx/blog/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/" class="category-list-link">技术框架</a><span class="category-list-count">14</span></li>
            <li class="category-list-item"><a href="https://gitee.com/mumulx/blog/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" class="category-list-link">杂七杂八</a><span class="category-list-count">10</span></li>
            <li class="category-list-item"><a href="https://gitee.com/mumulx/blog/categories/%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/" class="category-list-link">私人博客</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://gitee.com/mumulx/blog/categories/%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95/" class="category-list-link">问题收录</a><span class="category-list-count">2</span></li>
        </ul>
    </div>
</div>
      <div class="widget">
    <h3 class="widget-title"> 标签</h3>
    <div class="widget-body">
        <ul class="tag-list">
            
            
            <li class="tag-list-item"><a href="https://gitee.com/mumulx/blog/tags/j2ee/" class="tag-list-link">j2ee</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://gitee.com/mumulx/blog/tags/java/" class="tag-list-link">java</a><span
                    class="tag-list-count">12</span></li>
            
            
            <li class="tag-list-item"><a href="https://gitee.com/mumulx/blog/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="tag-list-link">java并发编程</a><span
                    class="tag-list-count">5</span></li>
            
            
            <li class="tag-list-item"><a href="https://gitee.com/mumulx/blog/tags/linux/" class="tag-list-link">linux</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://gitee.com/mumulx/blog/tags/node/" class="tag-list-link">node</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://gitee.com/mumulx/blog/tags/spring%E5%AE%B6%E6%97%8F/" class="tag-list-link">spring家族</a><span
                    class="tag-list-count">12</span></li>
            
            
            <li class="tag-list-item"><a href="https://gitee.com/mumulx/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="tag-list-link">中间件</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://gitee.com/mumulx/blog/tags/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/" class="tag-list-link">其他问题</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://gitee.com/mumulx/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" class="tag-list-link">分布式</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://gitee.com/mumulx/blog/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" class="tag-list-link">前端框架</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://gitee.com/mumulx/blog/tags/%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6/" class="tag-list-link">开发软件</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://gitee.com/mumulx/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="tag-list-link">数据库</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://gitee.com/mumulx/blog/tags/%E6%97%A5%E8%AE%B0/" class="tag-list-link">日记</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://gitee.com/mumulx/blog/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" class="tag-list-link">杂七杂八</a><span
                    class="tag-list-count">12</span></li>
            
            
            <li class="tag-list-item"><a href="https://gitee.com/mumulx/blog/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" class="tag-list-link">版本控制</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://gitee.com/mumulx/blog/tags/%E7%AE%97%E6%B3%95/" class="tag-list-link">算法</a><span
                    class="tag-list-count">2</span></li>
            
        </ul>

    </div>
</div>
      
<div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
        <ul class="recent-post-list list-unstyled no-thumbnail">
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://gitee.com/mumulx/blog/2020/11/fastdfs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="title">FastDFS学习笔记</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-11-03 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-11-03</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://gitee.com/mumulx/blog/2020/10/java%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/" class="title">Java底层知识汇总</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-10-09 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-10-09</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://gitee.com/mumulx/blog/2020/09/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/" class="title">背包九讲问题汇总</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-09-23 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-09-23</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://gitee.com/mumulx/blog/2020/08/java%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="title">Java算法笔记</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-08-13 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-08-13</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://gitee.com/mumulx/blog/2020/08/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B8%80/" class="title">Java面试准备一</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-08-13 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-08-13</time>
                    </p>
                </div>
            </li>
        </ul>
    </div>
</div>
  </div>
</aside>

    
    
  <aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="https://schema.org/WPSideBar">
    <div class="slimContent">
      <nav id="toc" class="article-toc">
        <h3 class="toc-title">文章目录</h3>
        <div class="toc-content always-active"><nav id="TableOfContents">
<ul>
<li><a href="#1-概览">1.概览</a>
<ul>
<li><a href="#1-1-预备知识">1.1 预备知识</a></li>
</ul></li>
<li><a href="#2-进程与线程">2. 进程与线程</a>
<ul>
<li><a href="#2-1-进程与线程">2.1 进程与线程</a>
<ul>
<li><a href="#二者对比">二者对比</a></li>
</ul></li>
<li><a href="#2-2-并行与并发">2.2 并行与并发</a></li>
<li><a href="#2-3-应用">2.3 应用</a>
<ul>
<li><a href="#应用之异步调用-案例-1">* 应用之异步调用（案例 1 ）</a></li>
<li><a href="#1-设计">1) 设计</a></li>
<li><a href="#2-结论">2) 结论</a></li>
<li><a href="#应用之提高效率-案例-1">应用之提高效率（案例 1 ）</a></li>
</ul></li>
</ul></li>
<li><a href="#3-java-线程">3. Java 线程</a>
<ul>
<li><a href="#3-1-创建和运行线程">3.1 创建和运行线程</a>
<ul>
<li><a href="#方法一-直接使用-thread">方法一，直接使用 Thread</a></li>
<li><a href="#方法二-使用-runnable-配合-thread">方法二，使用 Runnable 配合 Thread</a></li>
<li><a href="#方法三-futuretask-配合-thread">方法三，FutureTask 配合 Thread</a></li>
</ul></li>
<li><a href="#3-2-观察多个线程同时运行">3.2 观察多个线程同时运行</a></li>
<li><a href="#3-3-查看进程线程的方法">3.3 查看进程线程的方法</a>
<ul>
<li>
<ul>
<li><a href="#windows">windows</a></li>
<li><a href="#linux">linux</a></li>
<li><a href="#java-jdk提供">Java(jdk提供)</a></li>
</ul></li>
</ul></li>
<li><a href="#3-4-原理之线程运行">3.4  *原理之线程运行</a>
<ul>
<li><a href="#栈与栈帧">栈与栈帧</a></li>
<li><a href="#线程上下文切换-thread-context-switch">线程上下文切换（Thread Context Switch）</a></li>
</ul></li>
<li><a href="#3-5-常见方法">3.5 常见方法</a></li>
<li><a href="#3-6-start-与-run">3.6 start 与 run</a>
<ul>
<li><a href="#小结">小结</a></li>
</ul></li>
<li><a href="#3-7-sleep-与-yield">3.7 sleep 与 yield</a>
<ul>
<li><a href="#线程优先级">线程优先级</a></li>
<li><a href="#应用之限制">* 应用之限制</a></li>
</ul></li>
<li><a href="#3-8-join-方法详解">3.8 join 方法详解</a>
<ul>
<li><a href="#分析">分析</a></li>
<li><a href="#应用之同步-案例-1">* 应用之同步（案例 1 ）</a></li>
</ul></li>
<li><a href="#3-9-interrupt-方法详解">3.9 interrupt 方法详解</a>
<ul>
<li><a href="#模式之两阶段终止">* 模式之两阶段终止</a></li>
</ul></li>
<li><a href="#3-10-不推荐的方法">3.10 不推荐的方法</a></li>
<li><a href="#3-11-主线程与守护线程">3.11 主线程与守护线程</a>
<ul>
<li><a href="#注意">注意</a></li>
</ul></li>
<li><a href="#3-12-五种状态">3.12 五种状态</a></li>
<li><a href="#3-13-六种状态">3.13 六种状态</a></li>
<li><a href="#3-14-习题">3.14 习题</a></li>
<li><a href="#本章小结">本章小结</a></li>
</ul></li>
<li><a href="#4-共享模型之管程">4. 共享模型之管程</a>
<ul>
<li><a href="#本章内容">本章内容</a></li>
<li><a href="#4-1-共享带来的问题">4.1 共享带来的问题</a>
<ul>
<li><a href="#问题分析">问题分析</a></li>
</ul></li>
<li><a href="#4-2-synchronized-解决方案">4.2 synchronized 解决方案</a>
<ul>
<li><a href="#应用之互斥">* 应用之互斥</a></li>
<li><a href="#用图来表示">用图来表示</a></li>
<li><a href="#面向对象改进">面向对象改进</a></li>
</ul></li>
<li><a href="#4-3-方法上的-synchronized">4.3 方法上的 synchronized</a>
<ul>
<li><a href="#所谓的-线程八锁">所谓的“线程八锁”</a></li>
</ul></li>
<li><a href="#4-4-变量的线程安全分析">4.4 变量的线程安全分析</a>
<ul>
<li><a href="#分析-1">分析：</a></li>
<li><a href="#常见线程安全类">常见线程安全类</a></li>
<li><a href="#不可变类线程安全性">不可变类线程安全性</a></li>
<li><a href="#实例分析">实例分析</a></li>
</ul></li>
<li><a href="#4-5-习题">4.5 习题</a>
<ul>
<li><a href="#卖票练习">卖票练习</a></li>
<li><a href="#转账练习">转账练习</a></li>
</ul></li>
<li><a href="#4-6-monitor-概念">4.6 Monitor 概念</a>
<ul>
<li><a href="#java-对象头">Java 对象头</a></li>
<li><a href="#小故事">小故事</a></li>
</ul></li>
<li><a href="#4-7-wait-notify">4.7 wait notify</a>
<ul>
<li><a href="#api-介绍">API 介绍</a></li>
</ul></li>
<li><a href="#4-8-wait-notify-的正确姿势">4.8 wait notify 的正确姿势</a>
<ul>
<li><a href="#sleep-long-n-和-wait-long-n-的区别">sleep(long n) 和 wait(long n) 的区别</a></li>
</ul></li>
<li><a href="#4-9-park-unpark">4.9 Park &amp; Unpark</a>
<ul>
<li><a href="#基本使用">基本使用</a></li>
<li><a href="#特点">特点</a></li>
</ul></li>
<li><a href="#4-10-重新理解线程状态转换">4.10 重新理解线程状态转换</a>
<ul>
<li><a href="#情况-1-new-runnable">情况 1 NEW &ndash;&gt; RUNNABLE</a></li>
<li><a href="#情况-2-runnable-waiting">情况 2 RUNNABLE &lt;&ndash;&gt; WAITING</a></li>
<li><a href="#情况-3-runnable-waiting">情况 3 RUNNABLE &lt;&ndash;&gt; WAITING</a></li>
<li><a href="#情况-4-runnable-waiting">情况 4 RUNNABLE &lt;&ndash;&gt; WAITING</a></li>
<li><a href="#情况-5-runnable-timed-waiting">情况 5 RUNNABLE &lt;&ndash;&gt; TIMED_WAITING</a></li>
<li><a href="#情况-6-runnable-timed-waiting">情况 6 RUNNABLE &lt;&ndash;&gt; TIMED_WAITING</a></li>
<li><a href="#情况-7-runnable-timed-waiting">情况 7 RUNNABLE &lt;&ndash;&gt; TIMED_WAITING</a></li>
<li><a href="#情况-8-runnable-timed-waiting">情况 8 RUNNABLE &lt;&ndash;&gt; TIMED_WAITING</a></li>
<li><a href="#情况-9-runnable-blocked">情况 9 RUNNABLE &lt;&ndash;&gt; BLOCKED</a></li>
<li><a href="#情况-10-runnable-terminated">情况 10 RUNNABLE &lt;&ndash;&gt; TERMINATED</a></li>
</ul></li>
<li><a href="#4-11-多把锁">4.11 多把锁</a>
<ul>
<li><a href="#多把不相干的锁">多把不相干的锁</a></li>
</ul></li>
<li><a href="#4-12-活跃性">4.12 活跃性</a>
<ul>
<li><a href="#死锁">死锁</a>
<ul>
<li><a href="#定位死锁">定位死锁</a>
<ul>
<li><a href="#jps">jps</a></li>
<li><a href="#jconsole">jconsole</a></li>
</ul></li>
</ul></li>
<li><a href="#哲学家就餐问题">哲学家就餐问题</a></li>
<li><a href="#活锁">活锁</a></li>
<li><a href="#饥饿">饥饿</a></li>
</ul></li>
<li><a href="#4-13-reentrantlock">4.13 ReentrantLock</a>
<ul>
<li><a href="#可重入">可重入</a></li>
<li><a href="#可打断">可打断</a></li>
<li><a href="#锁超时">锁超时</a></li>
<li><a href="#公平锁">公平锁</a></li>
<li><a href="#条件变量">条件变量</a></li>
<li><a href="#同步模式之顺序控制">* 同步模式之顺序控制</a></li>
</ul></li>
<li><a href="#本章小结-1">本章小结</a></li>
</ul></li>
<li><a href="#5-共享模型之内存">5. 共享模型之内存</a>
<ul>
<li><a href="#5-1-java-内存模型">5.1 Java 内存模型</a></li>
<li><a href="#5-2-可见性">5.2 可见性</a>
<ul>
<li><a href="#解决方法">解决方法</a></li>
<li><a href="#可见性-vs-原子性">可见性 vs 原子性</a></li>
<li><a href="#原理之-cpu-缓存结构">* 原理之 CPU 缓存结构</a></li>
</ul></li>
<li><a href="#5-3-有序性">5.3 有序性</a>
<ul>
<li><a href="#原理之指令级并行">* 原理之指令级并行</a></li>
<li><a href="#诡异的结果">诡异的结果</a>
<ul>
<li><a href="#解决方法-1">解决方法</a></li>
</ul></li>
<li><a href="#原理之-volatile">* 原理之 volatile</a></li>
<li><a href="#happens-before">happens-before</a>
<ul>
<li><a href="#规则1">规则1</a></li>
<li><a href="#规则2">规则2</a></li>
<li><a href="#规则3">规则3</a></li>
<li><a href="#规则4">规则4</a></li>
<li><a href="#规则5">规则5</a></li>
<li><a href="#规则6">规则6</a></li>
<li><a href="#规则7">规则7</a></li>
</ul></li>
</ul></li>
<li><a href="#习题">习题</a>
<ul>
<li><a href="#balking-模式习题">balking 模式习题</a></li>
<li><a href="#线程安全单例习题">线程安全单例习题</a>
<ul>
<li><a href="#实现-1">实现 1</a></li>
<li><a href="#实现-2">实现 2</a></li>
<li><a href="#实现-3">实现 3 ：</a></li>
<li><a href="#实现-4-dcl">实现 4 ：DCL</a></li>
<li><a href="#实现-5">实现 5 ：</a></li>
</ul></li>
</ul></li>
<li><a href="#本章小结-2">本章小结</a></li>
</ul></li>
<li><a href="#6-共享模型之无锁">6. 共享模型之无锁</a>
<ul>
<li><a href="#本章内容-1">本章内容</a></li>
<li><a href="#6-1-问题提出">6.1 问题提出</a>
<ul>
<li><a href="#为什么不安全">为什么不安全</a></li>
<li><a href="#解决思路-锁">解决思路-锁</a></li>
<li><a href="#解决思路-无锁">解决思路-无锁</a></li>
</ul></li>
<li><a href="#6-2-cas-与-volatile">6.2 CAS 与 volatile</a>
<ul>
<li><a href="#注意-1">注意</a></li>
<li><a href="#慢动作分析">慢动作分析</a></li>
<li><a href="#为什么无锁效率高">为什么无锁效率高</a></li>
<li><a href="#cas-的特点">CAS 的特点</a></li>
</ul></li>
<li><a href="#6-3-原子整数">6.3 原子整数</a></li>
<li><a href="#6-4-原子引用">6.4 原子引用</a>
<ul>
<li><a href="#不安全实现">不安全实现</a></li>
<li><a href="#安全实现-使用锁">安全实现-使用锁</a></li>
<li><a href="#安全实现-使用-cas">安全实现-使用 CAS</a></li>
<li><a href="#aba-问题及解决">ABA 问题及解决</a></li>
<li><a href="#atomicstampedreference">AtomicStampedReference</a></li>
<li><a href="#atomicmarkablereference">AtomicMarkableReference</a></li>
</ul></li>
<li><a href="#6-5-原子数组">6.5 原子数组</a>
<ul>
<li><a href="#不安全的数组">不安全的数组</a></li>
<li><a href="#安全的数组">安全的数组</a></li>
</ul></li>
<li><a href="#6-6-字段更新器">6.6 字段更新器</a></li>
<li><a href="#6-7-原子累加器">6.7 原子累加器</a>
<ul>
<li><a href="#累加器性能比较">累加器性能比较</a></li>
<li><a href="#原理之伪共享">* 原理之伪共享</a></li>
</ul></li>
<li><a href="#6-8-unsafe">6.8 Unsafe</a></li>
<li><a href="#本章小结-3">本章小结</a></li>
</ul></li>
<li><a href="#7-共享模型之不可变">7. 共享模型之不可变</a>
<ul>
<li><a href="#本章内容-2">本章内容</a></li>
<li><a href="#7-1-日期转换的问题">7.1 日期转换的问题</a>
<ul>
<li><a href="#问题提出">问题提出</a></li>
<li><a href="#思路-同步锁">思路 - 同步锁</a></li>
<li><a href="#思路-不可变">思路 - 不可变</a></li>
</ul></li>
<li><a href="#7-2-不可变设计">7.2 不可变设计</a>
<ul>
<li><a href="#保护性拷贝">保护性拷贝</a></li>
<li><a href="#模式之享元">* 模式之享元</a></li>
<li><a href="#原理之-final">* 原理之 final</a></li>
</ul></li>
<li><a href="#7-3-无状态">7.3 无状态</a></li>
<li><a href="#本章小结-4">本章小结</a></li>
</ul></li>
<li><a href="#8-共享模型之工具">8. 共享模型之工具</a>
<ul>
<li><a href="#8-1-线程池">8.1 线程池</a>
<ul>
<li><a href="#1-自定义线程池">1. 自定义线程池</a></li>
<li><a href="#1-线程池状态">1) 线程池状态</a></li>
<li><a href="#2-构造方法">2) 构造方法</a></li>
<li><a href="#3-newfixedthreadpool">3)newFixedThreadPool</a></li>
<li><a href="#4-newcachedthreadpool">4)newCachedThreadPool</a></li>
<li><a href="#5-newsinglethreadexecutor">5)newSingleThreadExecutor</a></li>
<li><a href="#6-提交任务">6) 提交任务</a></li>
<li><a href="#7-关闭线程池">7) 关闭线程池</a></li>
<li><a href="#其它方法">其它方法</a></li>
<li><a href="#模式之-worker-thread">* 模式之 Worker Thread</a></li>
<li><a href="#8-任务调度线程池">8) 任务调度线程池</a></li>
<li><a href="#9-正确处理执行任务异常">9) 正确处理执行任务异常</a>
<ul>
<li><a href="#方法-1-主动捉异常">方法 1 ：主动捉异常</a></li>
<li><a href="#方法-2-使用-future">方法 2 ：使用 Future</a></li>
</ul></li>
<li><a href="#应用之定时任务">* 应用之定时任务</a></li>
<li><a href="#tomcat-线程池">Tomcat 线程池</a></li>
<li><a href="#fork-join">Fork/Join</a></li>
<li><a href="#用图来表示-1">用图来表示</a></li>
</ul></li>
<li><a href="#8-2-j-u-c">8.2 J.U.C</a>
<ul>
<li><a href="#1-aqs-原理">1.* AQS 原理</a></li>
<li><a href="#2-reentrantlock-原理">2.* ReentrantLock 原理</a></li>
<li><a href="#3-读写锁">3.读写锁</a>
<ul>
<li><a href="#3-1-reentrantreadwritelock">3.1 ReentrantReadWriteLock</a></li>
<li><a href="#应用之缓存">* 应用之缓存</a></li>
<li><a href="#读写锁原理">* 读写锁原理</a></li>
<li><a href="#3-2-stampedlock">3.2 StampedLock</a></li>
</ul></li>
<li><a href="#4-semaphore">4.Semaphore</a>
<ul>
<li><a href="#基本使用-1">基本使用</a></li>
<li><a href="#应用-限制-限制对共享资源的使用">* 应用 &ndash;限制 &ndash; 限制对共享资源的使用</a></li>
<li><a href="#semaphore-原理">* Semaphore 原理</a></li>
</ul></li>
<li><a href="#5-countdownlatch">5.CountdownLatch</a>
<ul>
<li><a href="#应用之同步等待多线程准备完毕">* 应用之同步等待多线程准备完毕</a></li>
</ul></li>
<li><a href="#6-cyclicbarrier">6.CyclicBarrier</a></li>
<li><a href="#7-线程安全集合类概述">7. 线程安全集合类概述</a></li>
<li><a href="#8-concurrenthashmap">8.ConcurrentHashMap</a>
<ul>
<li><a href="#concurrenthashmap-原理">* ConcurrentHashMap 原理</a></li>
</ul></li>
<li><a href="#9-blockingqueue">9.BlockingQueue</a>
<ul>
<li><a href="#blockingqueue-原理">* BlockingQueue 原理</a></li>
</ul></li>
<li><a href="#10-concurrentlinkedqueue">10.ConcurrentLinkedQueue</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
        </div>
      </nav>
    </div>
  </aside>
<main class="main" role="main"><div class="content">
  <article id="-" class="article article-type-" itemscope
    itemtype="https://schema.org/BlogPosting">
    
    <div class="article-header">
      <h1 itemprop="name">
  <a
    class="article-title"
    href="/mumulx/blog/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
    >Java并发编程</a
  >
</h1>

      <div class="article-meta">
        <span class="article-date">
  <i class="icon icon-calendar-check"></i>
<a href="https://gitee.com/mumulx/blog/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2020-04-25 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-04-25</time>
</a>
</span><span class="article-category">
  <i class="icon icon-folder"></i>
  <a class="article-category-link" href="/mumulx/blog/categories/%E6%8A%80%E6%9C%AF%E6%94%B6%E5%BD%95/"> 技术收录 </a>
</span>  
  <span class="article-tag">
    <i class="icon icon-tags"></i>
    <a class="article-tag-link" href="/mumulx/blog/tags/java/"> Java </a>
    <a class="article-tag-link" href="/mumulx/blog/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"> Java并发编程 </a>
  </span>

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/mumulx/blog/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/#comments"
            class="article-comment-link">评论</a></span>
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计:58352字</span>
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长:117分 </span>
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      

<h1 id="1-概览">1.概览</h1>

<h2 id="1-1-预备知识">1.1 预备知识</h2>

<blockquote>
<p>希望你不是一个初学者</p>

<p>线程安全问题，需要你接触过 Java Web 开发、Jdbc 开发、Web 服务器、分布式框架时才会遇到
基于 JDK 8，最好对函数式编程、lambda 有一定了解
采用了 slf4j 打印日志，这是好的实践
采用了 lombok 简化 java bean 编写
给每个线程好名字，这也是一项好的实践</p>
</blockquote>

<p>pom.xml 依赖如下</p>

<pre><code class="language-xml">&lt;properties&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.18.10&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
        &lt;version&gt;1.2.3&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p>logback.xml 配置如下</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration
               xmlns=&quot;http://ch.qos.logback/xml/ns/logback&quot;
               xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
               xsi:schemaLocation=&quot;http://ch.qos.logback/xml/ns/logback logback.xsd&quot;&gt;
    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%date{HH:mm:ss} [%t] %logger - %m%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;logger name=&quot;c&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;
        &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;
    &lt;/logger&gt;
    &lt;root level=&quot;ERROR&quot;&gt;
        &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>

<h1 id="2-进程与线程">2. 进程与线程</h1>

<p>本章内容</p>

<blockquote>
<p>进程和线程的概念</p>

<p>并行和并发的概念</p>

<p>线程基本应用</p>
</blockquote>

<h2 id="2-1-进程与线程">2.1 进程与线程</h2>

<p>进程</p>

<ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的</li>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li>
<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、 360 安全卫士等）</li>
</ul>

<p>线程</p>

<ul>
<li>一个进程之内可以分为一到多个线程。</li>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li>
<li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</li>
</ul>

<h3 id="二者对比">二者对比</h3>

<ul>
<li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li>
<li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li>
<li>进程间通信较为复杂

<ul>
<li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li>
</ul></li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li>
</ul>

<h2 id="2-2-并行与并发">2.2 并行与并发</h2>

<p>单核 cpu 下，线程实际还是 串行执行 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是 同时运行的 。总结为一句话就是：<code>微观串行，宏观并行</code>，</p>

<p>一般会将这种 线程轮流使用 CPU 的做法称为并发：concurrent</p>

<table>
<thead>
<tr>
<th>CPU</th>
<th>时间片1</th>
<th>时间片2</th>
<th>时间片3</th>
<th>时间片4</th>
</tr>
</thead>

<tbody>
<tr>
<td>core</td>
<td>线程1</td>
<td>线程2</td>
<td>线程3</td>
<td>线程4</td>
</tr>
</tbody>
</table>

<p><img src="/resources/技术收录/Java/java并发/image-20200419124408218.png" alt="image-20200419124408218" /></p>

<p>java并发</p>

<p>多核 cpu下，每个 核（core）都可以调度运行线程，这时候线程可以是并行的。</p>

<table>
<thead>
<tr>
<th>CPU</th>
<th>时间片 1</th>
<th>时间片 2</th>
<th>时间片 3</th>
<th>时间片 4</th>
</tr>
</thead>

<tbody>
<tr>
<td>core 1</td>
<td>线程 1</td>
<td>线程 1</td>
<td>线程 3</td>
<td>线程 3</td>
</tr>

<tr>
<td>core 2</td>
<td>线程2</td>
<td>线程4</td>
<td>线程2</td>
<td>线程4</td>
</tr>
</tbody>
</table>

<p><img src="/resources/技术收录/Java/java并发/image-20200420090851070.png" alt="image-20200420090851070" /></p>

<p>引用 Rob Pike 的一段描述：</p>

<ul>
<li>并发（concurrent）是同一时间应对（dealing with）多件事情的能力</li>
<li>并行（parallel）是同一时间动手做（doing）多件事情的能力</li>
</ul>

<p>例子</p>

<blockquote>
<p>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发
家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一
个人用锅时，另一个人就得等待）</p>

<p>雇了 3 个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</p>
</blockquote>

<p>Rob Pike 资料</p>

<ul>
<li>golang 语言的创造者</li>
<li>Rob Pike - 百度百科</li>
</ul>

<h2 id="2-3-应用">2.3 应用</h2>

<h3 id="应用之异步调用-案例-1">* 应用之异步调用（案例 1 ）</h3>

<p><a href="https://mumulx.github.io/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8%E7%AF%87/#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5">应用之异步调用（案例 1 ）</a></p>

<p>以调用方角度来讲，如果</p>

<ul>
<li><p>需要等待结果返回，才能继续运行就是同步</p></li>

<li><p>不需要等待结果返回，就能继续运行就是异步</p></li>
</ul>

<h3 id="1-设计">1) 设计</h3>

<p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停&hellip;</p>

<h3 id="2-结论">2) 结论</h3>

<ul>
<li><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</p></li>

<li><p>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</p></li>

<li><p>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</p></li>
</ul>

<h3 id="应用之提高效率-案例-1">应用之提高效率（案例 1 ）</h3>

<p><a href="https://mumulx.github.io/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8%E7%AF%87/#%E6%95%88%E7%8E%87">应用之提高效率（案例 1 ）</a></p>

<p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p>

<pre><code>计算 1 花费 10 ms
计算 2 花费 11 ms
计算 3 花费 9 ms
汇总需要 1 ms
</code></pre>

<p>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms
但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1 ，线程 2 执行计算 2 ，线程 3 执行计算 3 ，那么 3 个
线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms 最后加上汇总时间只会花费 12ms</p>

<p><strong>注意</strong></p>

<p>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p>

<p>结论</p>

<ol>
<li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用
cpu ，不至于一个线程总占用 cpu，别的线程没法干活</li>
<li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的
有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任
务都能拆分（参考后文的【阿姆达尔定律】）
也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li>
<li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一
直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</li>
</ol>

<h1 id="3-java-线程">3. Java 线程</h1>

<p>本章内容</p>

<ul>
<li>创建和运行线程</li>
<li>查看线程</li>
<li>线程 API</li>
<li>线程状态</li>
</ul>

<h2 id="3-1-创建和运行线程">3.1 创建和运行线程</h2>

<p>java默认有两个线程（主线程Main线程和GC垃圾回收线程）</p>

<h3 id="方法一-直接使用-thread">方法一，直接使用 Thread</h3>

<p>创建线程，启动线程</p>

<pre><code class="language-java">// 创建线程对象
Thread t = new Thread() {
 public void run() {
 // 要执行的任务
 }
};
// 启动线程
t.start();
</code></pre>

<p>例如：</p>

<pre><code class="language-java">// 构造方法的参数是给线程指定名字，推荐
Thread t1 = new Thread(&quot;t1&quot;) {
 @Override
 // run 方法内实现了要执行的任务
 public void run() {
 log.debug(&quot;hello&quot;);
 }
};
t1.start();
</code></pre>

<h3 id="方法二-使用-runnable-配合-thread">方法二，使用 Runnable 配合 Thread</h3>

<p>把【线程】和【任务】（要执行的代码）分开</p>

<ul>
<li>Thread 代表线程</li>

<li><p>Runnable 可运行的任务（线程要执行的代码）</p>

<pre><code class="language-java">// 创建任务对象
Runnable task2 = new Runnable() {
@Override
public void run() {
log.debug(&quot;hello&quot;);
}
};
// 参数1 是任务对象; 参数2 是线程名字，推荐
Thread t2 = new Thread(task2, &quot;t2&quot;);
t2.start();
</code></pre></li>
</ul>

<p>Java 8 以后可以使用 lambda 精简代码</p>

<pre><code class="language-java">// 创建任务对象
Runnable task2 = () -&gt; log.debug(&quot;hello&quot;);
// 参数1 是任务对象; 参数2 是线程名字，推荐
Thread t2 = new Thread(task2, &quot;t2&quot;);
t2.start();
</code></pre>

<ul>
<li>*<strong>原理之 Thread 与 Runnable 的关系</strong></li>
</ul>

<p>分析 Thread 的源码，理清它与 Runnable 的关系</p>

<pre><code class="language-java">Thread t = new Thread(()-&gt;{ log.debug(&quot;running&quot;); }, &quot;t2&quot;);
//会去调用
public Thread(Runnable target, String name) {
    init(null, target, name, 0);
}

private void init(ThreadGroup g, Runnable target, String name,long stackSize) {
    init(g, target, name, stackSize, null);
}
private void init(ThreadGroup g, Runnable target, String name,
                  long stackSize, AccessControlContext acc) {
    //......
    this.target = target;//在这对target进行赋值
    //.........
}
//在run的时候使用了target成员变量
@Override
public void run() {
    if (target != null) {//如果不为空则调用runnable的run方法
        target.run();
    }
}
</code></pre>

<p>(java中提倡组合优先于继承)</p>

<p>小结</p>

<ul>
<li>方法 1 是把线程和任务合并在了一起，方法 2 是把线程和任务分开了</li>
<li>用 Runnable 更容易与线程池等高级 API 配合</li>
<li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li>
</ul>

<h3 id="方法三-futuretask-配合-thread">方法三，FutureTask 配合 Thread</h3>

<pre><code class="language-java">// 创建任务对象
FutureTask&lt;Integer&gt; task3 = new FutureTask&lt;&gt;(() -&gt; {
    log.debug(&quot;hello&quot;);
    return 100;
});
// 参数1 是任务对象; 参数2 是线程名字，推荐
new Thread(task3, &quot;t3&quot;).start();
// 主线程阻塞，同步等待 task 执行完毕的结果
Integer result = task3.get();
log.debug(&quot;结果是:{}&quot;, result)
</code></pre>

<p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p>

<p><a href="https://mumulx.github.io/2020/05/juc/#7-callable-%E7%AE%80%E5%8D%95">Callable</a></p>

<h2 id="3-2-观察多个线程同时运行">3.2 观察多个线程同时运行</h2>

<ul>
<li><p>主要是理解交替执行</p></li>

<li><p>谁先谁后，不由我们控制(由底层的任务调度器进行决定)</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.TestMultiThread&quot;)
public class TestMultiThread {
public static void main(String[] args) {
    new Thread(() -&gt; {
        while(true) {
            log.debug(&quot;running&quot;);
        }
    },&quot;t1&quot;).start();
    new Thread(() -&gt; {
        while(true) {
            log.debug(&quot;running&quot;);
        }
    },&quot;t2&quot;).start();
}
}
</code></pre></li>
</ul>

<h2 id="3-3-查看进程线程的方法">3.3 查看进程线程的方法</h2>

<h4 id="windows">windows</h4>

<ul>
<li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li>
<li>tasklist 查看进程</li>

<li><p>taskkill 杀死进程</p>

<pre><code class="language-shell">tasklist | findstr java
taskkill /F /PID xxxxx
</code></pre></li>
</ul>

<h4 id="linux">linux</h4>

<blockquote>
<p>ps -fe 查看所有进程</p>

<p>ps -re | grep xx</p>

<p>ps -fT -p <PID> 查看某个进程（PID）的所有线程
kill 杀死进程
top 按大写 H 切换是否显示线程
top -H -p <PID> 查看某个进程（PID）的所有线程</p>
</blockquote>

<h4 id="java-jdk提供">Java(jdk提供)</h4>

<blockquote>
<p>jps 命令查看所有 Java 进程
jstack <PID> 查看某个 Java 进程（PID）的所有线程状态(某一个时刻的状态)
jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</p>
</blockquote>

<p>jconsole 远程监控配置</p>

<pre><code>win+r  ：jconsole
</code></pre>

<ul>
<li><p>需要以如下方式运行你的 java 类</p>

<pre><code>java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote -
Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 -
Dcom.sun.management.jmxremote.authenticate=是否认证 java类
</code></pre>

<pre><code>java -Djava.rmi.server.hostname=xx.xx.xx.xx -Dcom.sun.management.jmxremote -
Dcom.sun.management.jmxremote.port=123 -Dcom.sun.management.jmxremote.ssl=false -
Dcom.sun.management.jmxremote.authenticate=false
</code></pre></li>

<li><p>修改 /etc/hosts 文件将 127.0.0.1 映射至主机名</p></li>
</ul>

<p>如果要认证访问，还需要做如下步骤</p>

<ul>
<li>复制 jmxremote.password 文件</li>
<li>修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写</li>
<li>连接时填入 controlRole（用户名），R&amp;D（密码）</li>
</ul>

<h2 id="3-4-原理之线程运行">3.4  *原理之线程运行</h2>

<h3 id="栈与栈帧">栈与栈帧</h3>

<p>Java Virtual Machine Stacks （Java 虚拟机栈）</p>

<p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟
机就会为其分配一块栈内存。</p>

<ul>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>

<li><p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p>

<pre><code class="language-java">public class TestFrames {
public static void main(String[] args) {
    Thread t1 = new Thread(){
        @Override
        public void run() {
            method1(20);
        }
    };
    t1.setName(&quot;t1&quot;);
    t1.start();
    method1(10);
}

private static void method1(int x) {
    int y = x + 1;
    Object m = method2();
    System.out.println(m);
}

private static Object method2() {
    Object n = new Object();
    return n;
}
}
</code></pre></li>
</ul>

<p>方法存在栈中（栈：是一种先进后出的结构）</p>

<p>每调用一个方法，就生成一个栈帧，方法结束后就释放栈的空间</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200419151132178.png" alt="image-20200419151132178" /></p>

<p>程序计数器：每一行(句)代码，当前执行的是哪一代码</p>

<blockquote>
<p>类加载，先将TestFrames类的字节码加载到java虚拟机中，加载到方法区中（二进制字节码）</p>

<p>Java虚拟机去启动一个main的主线程，并且分配main线程栈内存，线程交给任务调度器，去调度执行</p>

<p>cpu准备运行主线程中的代码，分配主方法main的栈帧内存（由xxx等组成）</p>

<p>main栈帧的局部变量表存放args引用java虚拟机产生的new String[]数组</p>

<p>程序计数器运行 method1(10);，为method1分配栈帧内存，</p>

<p>局部变量表中存放x,y,m(在栈帧创建时就为变量分配好内存)，返回地址就会指向方法区中的method1方法，执行完毕后执行method1后面的代码</p>

<p>局部变量x赋值为10，执行method1中的每一行代码，读到程序计数器，由cpu进行执行（为y赋值）</p>

<p>为method2生成栈帧，在堆中为n分配内存，n指向堆中的内存地址，menthod1中的m的地址就指向堆中的地址</p>

<p>m2内存释放，m1释放内存，main运行结束</p>
</blockquote>

<p><a href="https://www.bilibili.com/video/BV16J411h7Rd?p=21">视频地址</a></p>

<p><strong>两个线程时的栈帧内存</strong></p>

<pre><code class="language-java">public class TestFrames {
    public static void main(String[] args) {
        Thread t1 = new Thread(){
            @Override
            public void run() {
                method1(20);
            }
        };
        t1.setName(&quot;t1&quot;);
        t1.start();
        method1(10);
    }

    private static void method1(int x) {
        int y = x + 1;
        Object m = method2();
        System.out.println(m);
    }

    private static Object method2() {
        Object n = new Object();
        return n;
    }
}
</code></pre>

<p>断点的运行方式要设置成thread</p>

<p>栈帧是以线程为单位，相互是独立的，每个线程都有自己的栈帧空间互不干扰，相互独立</p>

<h3 id="线程上下文切换-thread-context-switch">线程上下文切换（Thread Context Switch）</h3>

<p>当任务调度器把时间片分给每个线程运行的时候，每个线程的时间片总会有用完的时候，用完了你就得把cpu的使用权交给其他的线程，当前线程就会发生一次上下文切换。</p>

<p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码（从使用cpu到不使用cpu）</p>

<ul>
<li>线程的 cpu 时间片用完</li>
<li>垃圾回收（暂停所有线程，运行垃圾回收线程，进行垃圾回收）</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li>
</ul>

<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念
就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p>

<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>Context Switch 频繁发生会影响性能（因此线程数不是越多越好）</li>
</ul>

<h2 id="3-5-常见方法">3.5 常见方法</h2>

<table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>功能说明</th>
<th>注意</th>
</tr>
</thead>

<tbody>
<tr>
<td>start()</td>
<td></td>
<td>启动一个新线 程，在新的线程 运行 run 方法 中的代码</td>
<td>start 方法只是让线程进入就绪，里面代码不一定立刻 运行（CPU 的时间片还没分给它）。每个线程对象的 start方法只能调用一次，如果调用了多次会出现 IllegalThreadStateException</td>
</tr>

<tr>
<td>run()</td>
<td></td>
<td>新线程启动后会 调用的方法</td>
<td>如果在构造 Thread 对象时传递了 Runnable 参数，则 线程启动后会调用 Runnable 中的 run 方法，否则默 认不执行任何操作。但可以创建 Thread 的子类对象， 来覆盖默认行为</td>
</tr>

<tr>
<td>join())</td>
<td></td>
<td>等待线程运行结 束</td>
<td></td>
</tr>

<tr>
<td>join(longn)</td>
<td></td>
<td>等待线程运行结 束,最多等待 n  毫秒</td>
<td></td>
</tr>

<tr>
<td>getld0</td>
<td></td>
<td>获取线程长整型 的 id</td>
<td>id 唯一</td>
</tr>

<tr>
<td>getName()</td>
<td></td>
<td>获取线程名</td>
<td></td>
</tr>

<tr>
<td>setName(String)</td>
<td></td>
<td>修改线程名</td>
<td></td>
</tr>

<tr>
<td>getPriority()</td>
<td></td>
<td>获取线程优先级</td>
<td></td>
</tr>

<tr>
<td>setPriority(int)</td>
<td></td>
<td>修改线程优先级</td>
<td>java中规定线程优先级是1~10 的整数，较大的优先级 能提高该线程被 CPU 调度的机率</td>
</tr>

<tr>
<td>getState0</td>
<td></td>
<td>获取线程状态</td>
<td>Java 中线程状态是用 6 个 enum 表示，分别为： NEW, RUNNABLE, BLOCKED, WAITING,  TIMED_WAITING, TERMINATED</td>
</tr>

<tr>
<td>isInterrupted(</td>
<td></td>
<td>判断是否被打 断，</td>
<td>不会清除 打断标记</td>
</tr>

<tr>
<td>isAlive0</td>
<td></td>
<td>线程是否存活 （还没有运行完 毕）</td>
<td></td>
</tr>

<tr>
<td>interrupt()</td>
<td></td>
<td>打断线程</td>
<td>如果被打断线程正在 sleep，wait，join 会导致被打断 的线程抛出 InterruptedException，并清除 打断标 记 ；如果打断的正在运行的线程，则会设置 打断标 记 ；park 的线程被打断，也会设置 打断标记</td>
</tr>

<tr>
<td>interrupted()</td>
<td>static</td>
<td>判断当前线程是 否被打断</td>
<td>会清除 打断标记</td>
</tr>

<tr>
<td>currentThread)</td>
<td>static</td>
<td>获取当前正在执 行的线程</td>
<td></td>
</tr>

<tr>
<td>sleep(long n)</td>
<td>static</td>
<td>让当前执行的线 程休眠n毫秒， 休眠时让出 cpu  的时间片给其它 线程</td>
<td></td>
</tr>

<tr>
<td>yield()</td>
<td>static</td>
<td>提示线程调度器 让出当前线程对 CPU的使用</td>
<td>主要是为了测试和调试</td>
</tr>
</tbody>
</table>

<h2 id="3-6-start-与-run">3.6 start 与 run</h2>

<p>调用 run</p>

<p>程序仍在 main 线程运行，FileReader.read() 方法调用还是同步的调用 start</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test4&quot;)
public class Test4 {
    public static void main(String[] args) {
        Thread t1 = new Thread(&quot;t1&quot;) {
            @Override
            public void run() {
                log.debug(&quot;running...&quot;);
                FileReader.read(Constants.MP4_FULL_PATH);
            }
        };
        t1.start();
        log.debug(&quot;do other things...&quot;);
    }
}
</code></pre>

<p>程序在 t1 线程运行，FileReader.read() 方法调用是异步的</p>

<p>调用start()方法后线程的状态会变为runnable，再次调用start方法就会报错（线程变为runnable的状态就不能再调用start方法了）。</p>

<h3 id="小结">小结</h3>

<blockquote>
<p>直接调用 run 是在主线程中执行了 run，没有启动新的线程
使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</p>
</blockquote>

<h2 id="3-7-sleep-与-yield">3.7 sleep 与 yield</h2>

<p>sleep</p>

<ol>
<li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</li>
<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>
<li>睡眠结束后的线程未必会立刻得到执行(线程结束以后cpu也许正在执行别的代码，需要系统任务调度器分配时间片)</li>

<li><p>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test6&quot;)
public class Test6 {
public static void main(String[] args) {
    Thread t1 = new Thread(&quot;t1&quot;) {
        @Override
        public void run() {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    };
    t1.start();
    log.debug(&quot;t1 state: {}&quot;, t1.getState());
    try {
        Thread.sleep(500);//在哪一个线程中调用该方法，哪一个线程就休眠
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    log.debug(&quot;t1 state: {}&quot;, t1.getState());
}
}
</code></pre>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test7&quot;)
public class Test7 {
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(&quot;t1&quot;) {
        @Override
        public void run() {
            log.debug(&quot;enter sleep...&quot;);
            try {
                Thread.sleep(2000);//当线程被唤醒会报InterruptedException异常
            } catch (InterruptedException e) {
                log.debug(&quot;wake up...&quot;);
                e.printStackTrace();
            }
        }
    };
    t1.start();
    Thread.sleep(1000);
    log.debug(&quot;interrupt...&quot;);
    t1.interrupt();
}
}
</code></pre>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test8&quot;)
public class Test8 {

public static void main(String[] args) throws InterruptedException {
    log.debug(&quot;enter&quot;);
    TimeUnit.SECONDS.sleep(1);
    log.debug(&quot;end&quot;);
//        Thread.sleep(1000);
}
}
</code></pre></li>
</ol>

<p>yield</p>

<ol>
<li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</li>
<li>具体的实现依赖于操作系统的任务调度器（将cpu使用权让出去之后，可能任务调度器又将时间片分配给了当前线程）</li>
</ol>

<blockquote>
<p>就绪状态:还是有机会被任务调度器调用，任务调度器还是会分时间片给该线程；将该时间点的cpu使用让出去，如果没有其他线程了，就会把时间片分给它，没有真正的等待时间</p>

<p>Timed Waiting 状态（阻塞）：任务调度器不会分时间片；有休眠时间，有真正的等待时间</p>
</blockquote>

<h3 id="线程优先级">线程优先级</h3>

<blockquote>
<p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它
如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu空闲时，优先级几乎没作用（与yield相似）</p>
</blockquote>

<p>1-10级看一下源码</p>

<pre><code class="language-java">/* @see        #MAX_PRIORITY
     * @see        #MIN_PRIORITY
     * @see        ThreadGroup#getMaxPriority()
     */
    public final void setPriority(int newPriority) {
        ThreadGroup g;
        checkAccess();
        if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) {
            throw new IllegalArgumentException();
        }
        if((g = getThreadGroup()) != null) {
            if (newPriority &gt; g.getMaxPriority()) {
                newPriority = g.getMaxPriority();
            }
            setPriority0(priority = newPriority);
        }
    }
    /**
     * The minimum priority that a thread can have.
     */
    public final static int MIN_PRIORITY = 1;

   /**
     * The default priority that is assigned to a thread.
     */
    public final static int NORM_PRIORITY = 5;

    /**
     * The maximum priority that a thread can have.
     */
    public final static int MAX_PRIORITY = 10;
</code></pre>

<p>数字越大优先级越高</p>

<pre><code class="language-java">Runnable task1 = () -&gt; {
 int count = 0;
 for (;;) {
 System.out.println(&quot;----&gt;1 &quot; + count++);
 }
};
Runnable task2 = () -&gt; {
 int count = 0;
 for (;;) {
 // Thread.yield();
 System.out.println(&quot; ----&gt;2 &quot; + count++);
 }
};
Thread t1 = new Thread(task1, &quot;t1&quot;);
Thread t2 = new Thread(task2, &quot;t2&quot;);
// t1.setPriority(Thread.MIN_PRIORITY);
// t2.setPriority(Thread.MAX_PRIORITY);
t1.start();
t2.start();
</code></pre>

<p>数字越大优先级越高，默认优先级是5</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test9&quot;)
public class Test9 {

    public static void main(String[] args) {
        Runnable task1 = () -&gt; {
            int count = 0;
            for (;;) {
                System.out.println(&quot;----&gt;1 &quot; + count++);
            }
        };
        Runnable task2 = () -&gt; {
            int count = 0;
            for (;;) {
//                Thread.yield();
                System.out.println(&quot;              ----&gt;2 &quot; + count++);
            }
        };
        Thread t1 = new Thread(task1, &quot;t1&quot;);
        Thread t2 = new Thread(task2, &quot;t2&quot;);
        t1.setPriority(Thread.MIN_PRIORITY);
        t2.setPriority(Thread.MAX_PRIORITY);
        t1.start();
        t2.start();
    }
}
</code></pre>

<h3 id="应用之限制">* 应用之限制</h3>

<p><a href="https://mumulx.github.io/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8%E7%AF%87/#%E9%99%90%E5%88%B6">应用之限制</a></p>

<h2 id="3-8-join-方法详解">3.8 join 方法详解</h2>

<p>为什么需要 join</p>

<p>下面的代码执行，打印 r 是什么？</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test10&quot;)
public class Test10 {
    static int r = 0;
    public static void main(String[] args) throws InterruptedException {
        test1();
    }
    private static void test1() throws InterruptedException {
        log.debug(&quot;开始&quot;);
        Thread t1 = new Thread(() -&gt; {
            log.debug(&quot;开始&quot;);
            sleep(1);
            log.debug(&quot;结束&quot;);
            r = 10;
        },&quot;t1&quot;);
        t1.start();
        //t1.join();//等待t1线程计算完成后，才恢复主线程
        log.debug(&quot;结果为:{}&quot;, r);
        log.debug(&quot;结束&quot;);
    }
}
//结果为0
</code></pre>

<h3 id="分析">分析</h3>

<blockquote>
<p>因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 r=10
而主线程一开始就要打印 r 的结果，所以只能打印出 r=0</p>
</blockquote>

<p>解决方法</p>

<blockquote>
<p>用 sleep 行不行？为什么？
用 join，加在 t1.start() 之后即可</p>
</blockquote>

<h3 id="应用之同步-案例-1">* 应用之同步（案例 1 ）</h3>

<p>以调用方角度来讲，如果</p>

<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>

<li><p>不需要等待结果返回，就能继续运行就是异步</p>

<pre><code class="language-java">static int r1 = 0;
static int r2 = 0;
public static void main(String[] args) throws InterruptedException {
test2();
}
private static void test2() throws InterruptedException {
Thread t1 = new Thread(() -&gt; {
    sleep(1);
    r1 = 10;
});
Thread t2 = new Thread(() -&gt; {
    sleep(2);
    r2 = 20;
});
long start = System.currentTimeMillis();
t1.start();
t2.start();
t1.join();
t2.join();
long end = System.currentTimeMillis();
log.debug(&quot;r1: {} r2: {} cost: {}&quot;, r1, r2, end - start);//结果为2s
}
</code></pre></li>
</ul>

<p>分析如下</p>

<blockquote>
<p>第一个 join：等待 t1 时, t2 并没有停止, 而在运行
第二个 join：1s 后, 执行到此, t2 也运行了 1s, 因此也只需再等待 1s</p>
</blockquote>

<p>如果颠倒两个 join 呢？(结果一样)</p>

<p>最终都是输出</p>

<pre><code>20:45:43.239 [main] c.TestJoin - r1: 10 r2: 20 cost: 2005
</code></pre>

<pre><code class="language-mermaid">graph TB
    a(&quot;main&quot;)--&gt; b(&quot;t1.start&quot;)
    b(&quot;t1.start&quot;)--1s后--&gt;c(&quot;r=10&quot;)
    c(&quot;r=10&quot;)--t1终止--&gt;d(&quot;t1.join&quot;)
    a(&quot;main&quot;)--&gt;d(&quot;t1.join&quot;)
     a(&quot;main&quot;)--&gt;e(&quot;t2.start&quot;)
     e(&quot;t2.start&quot;)--2s后--&gt;f(&quot;r=20&quot;)
     f(&quot;r=20&quot;)--t2终止--&gt;g(&quot;t2.join-仅需等1s&quot;)
     d(&quot;t1.join&quot;)--&gt;g(&quot;t2.join-仅需等1s&quot;)
</code></pre>

<pre><code class="language-mermaid">graph TB
    a(&quot;main&quot;)--&gt; b(&quot;t2.start&quot;)
    b(&quot;t1.start&quot;)--2s后--&gt;c(&quot;r=20&quot;)
    c(&quot;r=20&quot;)--t2终止--&gt;d(&quot;t2.join&quot;)
    a(&quot;main&quot;)--&gt;d(&quot;t2.join&quot;)
     a(&quot;main&quot;)--&gt;e(&quot;t1.start&quot;)
     e(&quot;t1.start&quot;)--1s后--&gt;f(&quot;r=10&quot;)
     f(&quot;r=10&quot;)--t1终止--&gt;g(&quot;t1.join-无需等待&quot;)
     d(&quot;t2.join&quot;)--&gt;g(&quot;t1.join-无需等待&quot;)
</code></pre>

<p><strong>有时效的</strong> <strong>join</strong></p>

<pre><code class="language-java">static int r1 = 0;
static int r2 = 0;
public static void main(String[] args) throws InterruptedException {
 test3();
}
public static void test3() throws InterruptedException {
 Thread t1 = new Thread(() -&gt; {
 sleep(2);
 r1 = 10;
 });
 long start = System.currentTimeMillis();
 t1.start();
 // 线程执行结束会导致 join 结束
 t1.join(1500);
 long end = System.currentTimeMillis();
 log.debug(&quot;r1: {} r2: {} cost: {}&quot;, r1, r2, end - start);
}
</code></pre>

<p>输出</p>

<pre><code>20:52:15.623 [main] c.TestJoin - r1: 0 r2: 0 cost: 1502
</code></pre>

<p>可以提前结束</p>

<h2 id="3-9-interrupt-方法详解">3.9 interrupt 方法详解</h2>

<p>打断 sleep，wait，join （join底层就是wait）的线程，这几个方法都会让线程进入阻塞状态</p>

<p>打断 sleep 的线程, 会清空打断状态，以 sleep 为例</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test11&quot;)
public class Test11 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -&gt; {
            log.debug(&quot;sleep...&quot;);
            try {
                Thread.sleep(5000); // wait, join ,sleep在被打断后会重置打断标记为false
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },&quot;t1&quot;);
        t1.start();
        Thread.sleep(1000);
        log.debug(&quot;interrupt&quot;);
        t1.interrupt();
        log.debug(&quot;打断标记:{}&quot;, t1.isInterrupted());
    }
}
</code></pre>

<p>打断正常运行的线程</p>

<p>打断正常运行的线程, 不会清空打断状态，也不会停止线程。需要线程判断自己的打断标记是否被打断了，如果被打断了，自己则停止（要做一个乖宝宝）</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test12&quot;)
public class Test12 {

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -&gt; {
            while(true) {
                boolean interrupted = Thread.currentThread().isInterrupted();//Thread.currentThread()获取当前线程，被打断时打断标记会被标记成真true
                if(interrupted) {
                    log.debug(&quot;被打断了, 退出循环&quot;);
                    break;
                }
            }
        }, &quot;t1&quot;);
        t1.start();

        Thread.sleep(1000);
        log.debug(&quot;interrupt&quot;);
        t1.interrupt();
    }
}

</code></pre>

<h3 id="模式之两阶段终止">* 模式之两阶段终止</h3>

<p><a href="https://mumulx.github.io/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E7%AF%87/#2-%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F">模式之两阶段终止</a></p>

<p>打断 park 线程</p>

<p>打断 park 线程, 不会清空打断状态</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test14&quot;)
public class Test14 {
    private static void test3() throws InterruptedException {
        Thread t1 = new Thread(() -&gt; {
            log.debug(&quot;park...&quot;);
            LockSupport.park();
            log.debug(&quot;unpark...&quot;);
            log.debug(&quot;打断状态：{}&quot;, Thread.currentThread().isInterrupted());//此时打断标记为真true，对park无效， LockSupport.park();没有用，就会执行log.debug(&quot;unpark....&quot;);
            // log.debug(&quot;打断状态：{}&quot;, Thread.interrupted());//Thread.interrupted()返回打断标记，然后将该打断标记设为假，打断标记为假park就生效了  LockSupport.park();又会执行，就不会执行log.debug(&quot;unpark....&quot;);
            LockSupport.park();
            log.debug(&quot;unpark....&quot;);
        }, &quot;t1&quot;);
        t1.start();
        sleep(1);
        t1.interrupt();
    }
    public static void main(String[] args) throws InterruptedException {
        test3();
    }
}

</code></pre>

<p>提示</p>

<p>可以使用 Thread.interrupted() 清除打断状态</p>

<p>如果打断标记已经是 true, 则 park 会失效</p>

<h2 id="3-10-不推荐的方法">3.10 不推荐的方法</h2>

<p>还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁</p>

<table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>功能说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>stop()</td>
<td></td>
<td>停止线程运行(两阶段终止模式替代)</td>
</tr>

<tr>
<td>suspend()</td>
<td></td>
<td>挂起(暂停)线程运行（wait方法代替）</td>
</tr>

<tr>
<td>resume()</td>
<td></td>
<td>恢复线程运行(notify方法代替)</td>
</tr>
</tbody>
</table>

<h2 id="3-11-主线程与守护线程">3.11 主线程与守护线程</h2>

<p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束（即使main线程已经结束了，还有其他的额外的线程在运行，程序也不会停止）。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p>

<p>例：</p>

<pre><code class="language-java">log.debug(&quot;开始运行...&quot;);
Thread t1 = new Thread(() -&gt; {
     log.debug(&quot;开始运行...&quot;);
     sleep(2);
     log.debug(&quot;运行结束...&quot;);
}, &quot;daemon&quot;);
t1.setDaemon(true);// 设置该线程为守护线程   默认不是守护线程
t1.start();
sleep(1);
log.debug(&quot;运行结束...&quot;);
</code></pre>

<p>输出</p>

<pre><code>08:26:38.123 [main] c.TestDaemon - 开始运行...
08:26:38.213 [daemon] c.TestDaemon - 开始运行...
08:26:39.215 [main] c.TestDaemon - 运行结束...
</code></pre>

<h3 id="注意">注意</h3>

<ul>
<li><p>垃圾回收器线程就是一种守护线程</p></li>

<li><p>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等
待它们处理完当前请求</p></li>
</ul>

<h2 id="3-12-五种状态">3.12 五种状态</h2>

<p>这是从 操作系统 层面来描述的</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200419214127727.png" alt="image-20200419214127727" /></p>

<ul>
<li><p>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</p></li>

<li><p>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行，暂时还没有分配到时间片</p></li>

<li><p>【运行状态】指获取了 CPU 时间片运行中的状态；</p>

<ul>
<li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
</ul></li>

<li><p>【阻塞状态】</p>

<ul>
<li><p>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】</p></li>

<li><p>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</p></li>

<li><p>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</p></li>
</ul></li>

<li><p>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li>
</ul>

<h2 id="3-13-六种状态">3.13 六种状态</h2>

<p>这是从 Java API 层面来描述的</p>

<p>根据 Thread.State 枚举，分为六种状态</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200419214600177.png" alt="image-20200419214600177" /></p>

<ul>
<li>NEW 线程刚被创建，但是还没有调用 start() 方法</li>
<li>RUNNABLE 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的
【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为
是可运行）</li>
<li>BLOCKED，WAITING，TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节
详述</li>

<li><p>TERMINATED 当线程代码运行结束</p>

<pre><code class="language-java">public class TestState2 {
public static void main(String[] args) throws InterruptedException {
    new Thread(() -&gt; {
        FileReader.read(Constants.MP4_FULL_PATH);
        FileReader.read(Constants.MP4_FULL_PATH);
        FileReader.read(Constants.MP4_FULL_PATH);
    }, &quot;t1&quot;).start();
    Thread.sleep(1000);
    System.out.println(&quot;ok&quot;);
}
}
@Slf4j(topic = &quot;c.TestState&quot;)
public class TestState {
public static void main(String[] args) throws IOException {
    Thread t1 = new Thread(&quot;t1&quot;) {
        @Override
        public void run() {
            log.debug(&quot;running...&quot;);
        }
    };

    Thread t2 = new Thread(&quot;t2&quot;) {
        @Override
        public void run() {
            while(true) { // runnable
            }
        }
    };
    t2.start();
        
    Thread t3 = new Thread(&quot;t3&quot;) {
        @Override
        public void run() {
            log.debug(&quot;running...&quot;);
        }
    };
    t3.start();

    Thread t4 = new Thread(&quot;t4&quot;) {
        @Override
        public void run() {
            synchronized (TestState.class) {
                try {
                    Thread.sleep(1000000); // timed_waiting
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    };
    t4.start();

    Thread t5 = new Thread(&quot;t5&quot;) {
        @Override
        public void run() {
            try {
                t2.join(); // waiting
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    };
    t5.start();

    Thread t6 = new Thread(&quot;t6&quot;) {
        @Override
        public void run() {
            synchronized (TestState.class) { // blocked
                try {
                    Thread.sleep(1000000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    };
    t6.start();

    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    log.debug(&quot;t1 state {}&quot;, t1.getState());
    log.debug(&quot;t2 state {}&quot;, t2.getState());
    log.debug(&quot;t3 state {}&quot;, t3.getState());
    log.debug(&quot;t4 state {}&quot;, t4.getState());
    log.debug(&quot;t5 state {}&quot;, t5.getState());
    log.debug(&quot;t6 state {}&quot;, t6.getState());
    System.in.read();
}
}
</code></pre></li>
</ul>

<h2 id="3-14-习题">3.14 习题</h2>

<p>阅读华罗庚《统筹方法》，给出烧水泡茶的多线程解决方案，提示</p>

<ul>
<li><p>参考图二，用两个线程（两个人协作）模拟烧水泡茶过程</p>

<ul>
<li><p>文中办法乙、丙都相当于任务串行</p></li>

<li><p>而图一相当于启动了 4 个线程，有点浪费</p></li>
</ul></li>

<li><p>用 sleep(n) 模拟洗茶壶、洗水壶等耗费的时间</p></li>
</ul>

<p>附：华罗庚《统筹方法》</p>

<blockquote>
<p>统筹方法，是一种安排工作进程的数学方法。它的实用范围极广泛，在企业管理和基本建设中，以及关系复</p>

<p>杂的科研项目的组织与管理中，都可以应用。</p>

<p>怎样应用呢？主要是把工序安排好。</p>

<p>比如，想泡壶茶喝。当时的情况是：开水没有；水壶要洗，茶壶、茶杯要洗；火已生了，茶叶也有了。怎么</p>

<p>办？</p>

<p>办法甲：洗好水壶，灌上凉水，放在火上；在等待水开的时间里，洗茶壶、洗茶杯、拿茶叶；等水开</p>

<p>了，泡茶喝。</p>

<p>办法乙：先做好一些准备工作，洗水壶，洗茶壶茶杯，拿茶叶；一切就绪，灌水烧水；坐待水开了，泡</p>

<p>茶喝。</p>

<p>办法丙：洗净水壶，灌上凉水，放在火上，坐待水开；水开了之后，急急忙忙找茶叶，洗茶壶茶杯，泡</p>

<p>茶喝。</p>

<p>哪一种办法省时间？我们能一眼看出，第一种办法好，后两种办法都窝了工。</p>

<p>这是小事，但这是引子，可以引出生产管理等方面有用的方法来。</p>

<p>水壶不洗，不能烧开水，因而洗水壶是烧开水的前提。没开水、没茶叶、不洗茶壶茶杯，就不能泡茶，因而</p>

<p>这些又是泡茶的前提。它们的相互关系，可以用下边的箭头图来表示：</p>
</blockquote>

<pre><code class="language-mermaid">graph LR
a(洗水壶1分钟) --&gt; b(烧开水15分钟)
c(洗茶壶 1分钟)
d(洗茶杯 2分钟)
e(拿茶叶 1分钟)
b --&gt; f(泡茶)
c --&gt; f(泡茶)
d --&gt; f(泡茶)
e --&gt; f(泡茶)
</code></pre>

<p>从这个图上可以一眼看出，办法甲总共要16分钟（而办法乙、丙需要20分钟）。如果要缩短工时、提高工作</p>

<p>效率，应当主要抓烧开水这个环节，而不是抓拿茶叶等环节。同时，洗茶壶茶杯、拿茶叶总共不过4分钟，大</p>

<p>可利用“等水开”的时间来做。</p>

<p>是的，这好像是废话，卑之无甚高论。有如走路要用两条腿走，吃饭要一口一口吃，这些道理谁都懂得。但</p>

<p>稍有变化，临事而迷的情况，常常是存在的。在近代工业的错综复杂的工艺过程中，往往就不是像泡茶喝这</p>

<p>么简单了。任务多了，几百几千，甚至有好几万个任务。关系多了，错综复杂，千头万绪，往往出现“万事俱</p>

<p>备，只欠东风”的情况。由于一两个零件没完成，耽误了一台复杂机器的出厂时间。或往往因为抓的不是关</p>

<p>键，连夜三班，急急忙忙，完成这一环节之后，还得等待旁的环节才能装配。</p>

<p>洗茶壶，洗茶杯，拿茶叶，或先或后，关系不大，而且同是一个人的活儿，因而可以合并成为：</p>

<pre><code class="language-mermaid">graph LR
a(洗水壶1分钟) --&gt; b(烧开水15分钟)
c(洗茶壶,洗茶杯,拿茶叶 4分钟)
b --&gt; f(泡茶)
c --&gt; f(泡茶)
</code></pre>

<p>看来这是“小题大做”，但在工作环节太多的时候，这样做就非常必要了。</p>

<p>这里讲的主要是时间方面的事，但在具体生产实践中，还有其他方面的许多事。这种方法虽然不一定能直接</p>

<p>解决所有问题，但是，我们利用这种方法来考虑问题，也是不无裨益的。</p>

<p>解法</p>

<p><strong>应用篇-统筹</strong></p>

<h2 id="本章小结">本章小结</h2>

<p>本章的重点在于掌握</p>

<ul>
<li><p>线程创建</p></li>

<li><p>线程重要 api，如 start，run，sleep，join，interrupt 等</p></li>

<li><p>线程状态</p></li>

<li><p>应用方面</p>

<ul>
<li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li>
<li>提高效率：并行计算，缩短运算时间</li>
<li>同步等待：join</li>
<li>统筹规划：合理使用线程，得到最优效果</li>
</ul></li>

<li><p>原理方面</p>

<ul>
<li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li>
<li>Thread 两种创建方式 的源码</li>
</ul></li>

<li><p>模式方面</p>

<ul>
<li>终止模式之两阶段终止</li>
</ul></li>
</ul>

<h1 id="4-共享模型之管程">4. 共享模型之管程</h1>

<h2 id="本章内容">本章内容</h2>

<ul>
<li>共享问题</li>
<li>synchronized</li>
<li>线程安全分析</li>
<li>Monitor</li>
<li>wait/notify</li>
<li>线程状态转换</li>
<li>活跃性</li>
<li>Lock</li>
</ul>

<p>Monitor两大作用：互斥、同步</p>

<p>synchronized：在JVM(c++)的层面上实现关联Monitor</p>

<p>rentryLock:在Java层面上实现关联monitor</p>

<h2 id="4-1-共享带来的问题">4.1 共享带来的问题</h2>

<p>小故事</p>

<p>老王（操作系统）有一个功能强大的算盘（CPU），现在想把它租出去，赚一点外快</p>

<p>小南、小女（线程）来使用这个算盘来进行一些计算，并按照时间给老王支付费用</p>

<p>但小南不能一天 24 小时使用算盘，他经常要小憩一会（sleep），又或是去吃饭上厕所（阻塞 io 操作），有
时还需要一根烟，没烟时思路全无（wait）这些情况统称为（阻塞）</p>

<p>在这些时候，算盘没利用起来（不能收钱了），老王觉得有点不划算</p>

<p>另外，小女也想用用算盘，如果总是小南占着算盘，让小女觉得不公平</p>

<p>于是，老王灵机一动，想了个办法 [ 让他们每人用一会，轮流使用算盘 ]</p>

<p>这样，当小南阻塞的时候，算盘可以分给小女使用，不会浪费，反之亦然</p>

<p>最近执行的计算比较复杂，需要存储一些中间结果，而学生们的脑容量（工作内存）不够，所以老王申请了一个笔记本（主存），把一些中间结果先记在本上</p>

<p>计算流程是这样的</p>

<p>但是由于分时系统，有一天还是发生了事故</p>

<p>小南刚读取了初始值 0 做了个 +1 运算，还没来得及写回结果</p>

<p>老王说 [ 小南，你的时间到了，该别人了，记住结果走吧 ]，于是小南念叨着 [ 结果是 1 ，结果是1&hellip;] 不甘心地</p>

<p>到一边待着去了（上下文切换）</p>

<p>老王说 [ 小女，该你了 ]，小女看到了笔记本上还写着 0 做了一个 -1 运算，将结果 -1 写入笔记本</p>

<p>这时小女的时间也用完了，老王又叫醒了小南：[小南，把你上次的题目算完吧]，小南将他脑海中的结果 1 写入了笔记本</p>

<p>小南和小女都觉得自己没做错，但笔记本里的结果是 1 而不是 0</p>

<p>Java 的体现</p>

<p>两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p>

<pre><code class="language-java">static int counter = 0;
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -&gt; {
        for (int i = 0; i &lt; 5000; i++) {
            counter++;
        }
    }, &quot;t1&quot;);
    Thread t2 = new Thread(() -&gt; {
        for (int i = 0; i &lt; 5000; i++) {
            counter--;
        }
    }, &quot;t2&quot;);
    t1.start();
    t2.start();
    t1.join();
    t2.join();
    log.debug(&quot;{}&quot;,counter);
}
</code></pre>

<h3 id="问题分析">问题分析</h3>

<p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作，要彻底理解，必须从字节码来进行分析</p>

<p>例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p>

<pre><code>getstatic i // 获取静态变量i的值
iconst_1 // 准备常量1
iadd // 自增
putstatic i // 将修改后的值存入静态变量i
</code></pre>

<p>而对应 i&ndash; 也是类似：</p>

<pre><code>getstatic i // 获取静态变量i的值
iconst_1 // 准备常量1
isub // 自减
putstatic i // 将修改后的值存入静态变量i
</code></pre>

<p>而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200620162309624.png" alt="image-20200620162309624" /></p>

<p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：</p>

<p>但多线程下这 8 行代码可能交错运行：</p>

<pre><code class="language-mermaid">sequenceDiagram
  # 通过设定参与者(participants)的顺序控制展示模块顺序
  participant 线程1
　participant static i
  static i-&gt;线程1:getstatic i 读取 0
　线程1-&gt;线程1:iconst_1 准备常数1
　线程1-&gt;线程1:iadd 加法，线程内i=1
　线程1-&gt;static i:putstatic i 写入1
　static i -&gt;线程1:getstatic i 读取1
　线程1-&gt;线程1:iconst_1准备常数  1
　线程1-&gt;线程1:isub 减法,线程内i=0
　线程1-&gt;static i:putstatic i 写入0

</code></pre>

<p>出现负数的情况：</p>

<pre><code class="language-mermaid">sequenceDiagram
  # 通过设定参与者(participants)的顺序控制展示模块顺序
  participant 线程1
  participant 线程2
　participant static i
  static i-&gt;线程2:getstatic i 读取 0
　线程2-&gt;线程2:iconst_1 准备常数1
　线程2-&gt;线程2:iadd 加法，线程内i=1
　线程2--&gt;线程1:上下文切换
　static i-&gt;线程1:getstatic i 读取 0
　线程1-&gt;线程1:iconst_1准备常数  1
　线程1-&gt;线程1:iadd 加法,线程内i=1
　线程1-&gt;static i:putstatic i 写入1
　线程1--&gt;线程2:上下文切换
　线程1-&gt;static i:putstatic i 写入-1
</code></pre>

<p>出现正数的情况</p>

<pre><code class="language-mermaid">sequenceDiagram
  # 通过设定参与者(participants)的顺序控制展示模块顺序
  participant 线程1
  participant 线程2
　participant static i
  static i-&gt;线程1:getstatic i 读取 0
　线程1-&gt;线程1:iconst_1 准备常数1
　线程1-&gt;线程1:iadd 加法，线程内i=1
　线程1--&gt;线程2:上下文切换
　static i-&gt;线程2:getstatic i 读取 0
　线程2-&gt;线程2:iconst_1准备常数  1
　线程1-&gt;线程1:isub 减法,线程内i=-1
　线程2-&gt;static i:putstatic i 写入-1
　线程2--&gt;线程1:上下文切换
　线程1-&gt;static i:putstatic i 写入1
</code></pre>

<p><strong>临界区 Critical Section</strong></p>

<ul>
<li>一个程序运行多个线程本身是没有问题的</li>
<li>问题出在多个线程访问共享资源

<ul>
<li>多个线程读共享资源其实也没有问题</li>
<li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li>
</ul></li>
<li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区</li>
</ul>

<p>例如，下面代码中的临界区</p>

<pre><code class="language-java">static int counter = 0;
static void increment() 
// 临界区
{ 
 counter++; }
static void decrement() 
// 临界区
{ 
 counter--; }
</code></pre>

<p><strong>竞态条件 Race Condition</strong></p>

<p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p>

<h2 id="4-2-synchronized-解决方案">4.2 synchronized 解决方案</h2>

<h3 id="应用之互斥">* 应用之互斥</h3>

<p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p>

<ul>
<li>阻塞式的解决方案：synchronized，Lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>

<p>本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】（要配合对象使用）时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p>

<blockquote>
<p>注意
虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p>

<ul>
<li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li>
<li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li>
</ul>
</blockquote>

<p>synchronized</p>

<p>语法</p>

<pre><code class="language-java">synchronized(对象) // 线程1， 线程2(blocked)
{
 临界区
}
</code></pre>

<p>解决</p>

<pre><code class="language-java">static int counter = 0 ;
static final Object room = new Object();
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -&gt; {
        for (int i = 0 ; i &lt; 5000 ; i++) {
            synchronized (room) {
            	counter++;
            }
        }
    }, &quot;t1&quot;);
	Thread t2 = new Thread(() -&gt; {
        for (int i = 0 ; i &lt; 5000 ; i++) {
            synchronized (room) {
                counter--;
            }
        }
    }, &quot;t2&quot;);
t1.start();
t2.start();
t1.join();
t2.join();
log.debug(&quot;{}&quot;,counter);
}
</code></pre>

<p>你可以做这样的类比：</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200421093754691.png" alt="image-20200421093754691" /></p>

<ul>
<li>synchronized(对象) 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人进行计算，线程 t1，t2 想象成两个人</li>
<li>当线程 t1 执行到 synchronized(room) 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行count++ 代码</li>
<li>这时候如果 t2 也运行到了 synchronized(room) 时，它发现门被锁住了，只能在门外等待，发生了上下文切换，阻塞住了</li>
<li>这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦），这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才能开门进入</li>
<li>当 t1 执行完 synchronized{} 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 count&ndash; 代码</li>
</ul>

<h3 id="用图来表示">用图来表示</h3>

<pre><code class="language-mermaid">sequenceDiagram
  # 通过设定参与者(participants)的顺序控制展示模块顺序
  participant 线程1
  participant 线程2
　participant static i
　participant 锁对象
　线程2-&gt;锁对象:尝试获取锁
note over 线程2,锁对象: 拥有锁
  static i-&gt;线程2:getstatic i 读取 0
　线程2-&gt;线程2:iconst_1 准备常数1
　线程2-&gt;线程2:isub 减法，线程内i=-1
　线程2--&gt;线程1:上下文切换
　线程1-&gt;锁对象:尝试获取锁，被阻塞(BLOCKED)
　线程1--&gt;线程2:上下文切换
　线程2-&gt;static i:pitstatic i 写入-1
　note over 线程2,锁对象:拥有锁
　线程2-&gt;锁对象:释放锁，并唤醒阻塞的线程
　note over 线程1,锁对象:拥有锁
　static i-&gt;线程1:getstatic i 读取 -1
　线程1-&gt;线程1:iconst_1准备常数  1
　线程1-&gt;线程1:iadd 加法,线程内i=0
　线程1-&gt;static i:putstatic i 写入0
　note over 线程1,锁对象:拥有锁
　线程1--&gt;锁对象:释放锁，并唤醒阻塞的线程
</code></pre>

<p><strong>思考</strong></p>

<p>synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切
换所打断。</p>

<p>为了加深理解，请思考下面的问题</p>

<ul>
<li>如果把 synchronized(obj) 放在 for 循环的外面，如何理解？（将synchronized范围内的代码作为一个整体）&ndash; 原子性</li>
<li>如果 t1 synchronized(obj1) 而 t2 synchronized(obj2) 会怎样运作？(失效，因为是不同的对象)&ndash; 锁对象</li>
<li>如果 t1 synchronized(obj) 而 t2 没有加会怎么样？如何理解？&ndash; 锁对象 都要对这个对象进行加锁</li>
</ul>

<h3 id="面向对象改进">面向对象改进</h3>

<p>把需要保护的共享变量放入一个类</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test17&quot;)
public class Test17 {
    public static void main(String[] args) throws InterruptedException {
        Room room = new Room();
        Thread t1 = new Thread(() -&gt; {
            for (int i = 0; i &lt; 5000; i++) {
                room.increment();
            }
        }, &quot;t1&quot;);

        Thread t2 = new Thread(() -&gt; {
            for (int i = 0; i &lt; 5000; i++) {
                room.decrement();
            }
        }, &quot;t2&quot;);

        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug(&quot;{}&quot;, room.getCounter());
    }
}
class Room {
    private int counter = 0;
 /* public void increment() {
        synchronized (this){
            counter++;
        }
    }

    public void decrement() {
        synchronized (this){
            counter--;
        }
    }
    public int getCounter() {
        synchronized (this){
            return counter;
        }
    }*/
    public synchronized void increment() {
        counter++;
    }
    public synchronized void decrement() {
        counter--;
    }
    public synchronized int getCounter() {
        return counter;
    }
}
</code></pre>

<h2 id="4-3-方法上的-synchronized">4.3 方法上的 synchronized</h2>

<pre><code class="language-java">class Test{
 public synchronized void test() {
 
 }
}
等价于
class Test{
     public void test() {
         synchronized(this) {

         }
     }
}
</code></pre>

<pre><code class="language-java">class Test{
     public synchronized static void test() {
     }
}
等价于
class Test{
     public static void test() {
         synchronized(Test.class) {
         }
     }
}
</code></pre>

<p>synchronized只能锁对象，加在普通方法上锁的是调用它的对象。加载类的静态方法上锁的是类的Class对象。</p>

<p>不加 synchronized 的方法</p>

<ul>
<li>不加 synchronzied 的方法就好比不遵守规则的人，不去老实排队（好比翻窗户进去的），没办法保证原子性</li>
</ul>

<h3 id="所谓的-线程八锁">所谓的“线程八锁”</h3>

<p>其实就是考察 synchronized 锁住的是哪个对象</p>

<p>情况 1 ： 12 或 21（不容易出现）;锁的都是n1这个对象，哪个线程先被调用，哪个就先打印。</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Number&quot;)
class Number{
 public synchronized void a() {
 	log.debug(&quot;1&quot;);
 }
 public synchronized void b() {
 	log.debug(&quot;2&quot;);
 }
}
public static void main(String[] args) {
 Number n1 = new Number();
 new Thread(()-&gt;{ n1.a(); }).start();
 new Thread(()-&gt;{ n1.b(); }).start();
}
</code></pre>

<p>情况 2 ：1s后&ndash;2 ，或 2&ndash; 1s后 1；锁的都是n1这个对象，哪个线程先被调用，哪个就先打印。</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Number&quot;)
class Number{
     public synchronized void a() {
        sleep(1);
        log.debug(&quot;1&quot;);
     }
     public synchronized void b() {
        log.debug(&quot;2&quot;);
     }
}
public static void main(String[] args) {
 Number n1 = new Number();
 new Thread(()-&gt;{ n1.a(); }).start();
 new Thread(()-&gt;{ n1.b(); }).start();
}
</code></pre>

<p>情况 3 ：<code>3-1s-1-2</code> 或 <code>2-3-1s-1</code> 或 <code>3-2-1s-1</code></p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Number&quot;)
class Number{
 public synchronized void a() {
 	sleep(1);
 	log.debug(&quot;1&quot;);
 }
 public synchronized void b() {
 	log.debug(&quot;2&quot;);
 }
 public void c() {//普通方法没锁
 	log.debug(&quot;3&quot;);
 }
}
public static void main(String[] args) {
 Number n1 = new Number();
 new Thread(()-&gt;{ n1.a(); }).start();
 new Thread(()-&gt;{ n1.b(); }).start();
 new Thread(()-&gt;{ n1.c(); }).start();
}
</code></pre>

<p>情况 4 ：2 1s 后 1</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Number&quot;)
class Number{
 public synchronized void a() {
 	sleep(1);
 	log.debug(&quot;1&quot;);
 }
 public synchronized void b() {
 	log.debug(&quot;2&quot;);
 }
}
public static void main(String[] args) {
 Number n1 = new Number();//两个对象，两把锁
 Number n2 = new Number();
 new Thread(()-&gt;{ n1.a(); }).start();
 new Thread(()-&gt;{ n2.b(); }).start();
}
</code></pre>

<p>情况 5 ：2 1s 后 1</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Number&quot;)
class Number{
     public static synchronized void a() {//锁住的是Number这个类对象(类对象在内存中只有一份)
         sleep(1);
        log.debug(&quot;1&quot;);
     }
     public synchronized void b() {//锁住的是当前对象
        log.debug(&quot;2&quot;);
     }
 }
public static void main(String[] args) {
 Number n1 = new Number();
 new Thread(()-&gt;{ n1.a(); }).start();
 new Thread(()-&gt;{ n1.b(); }).start();
}
</code></pre>

<p>情况 6 ：1s 后 12 ， 或 2 1s后 1</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Number&quot;)
class Number{
 public static synchronized void a() {
	 sleep(1);
 	log.debug(&quot;1&quot;);
 }
 public static synchronized void b() {
 	log.debug(&quot;2&quot;);
 }
}
public static void main(String[] args) {
 Number n1 = new Number();
 new Thread(()-&gt;{ n1.a(); }).start();
 new Thread(()-&gt;{ n1.b(); }).start();
}
</code></pre>

<p>情况 7 ：2 1s 后 1</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Number&quot;)
class Number{
     public static synchronized void a() {
        sleep(1);
        log.debug(&quot;1&quot;);
     }
     public synchronized void b() {
        log.debug(&quot;2&quot;);
     }
}
public static void main(String[] args) {
     Number n1 = new Number();
     Number n2 = new Number();
     new Thread(()-&gt;{ n1.a(); }).start();
     new Thread(()-&gt;{ n2.b(); }).start();
}
</code></pre>

<p>情况 8 ：1s 后 12 ， 或 2 1s后 1</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Number&quot;)
class Number{
 public static synchronized void a() {
	sleep(1);
 	log.debug(&quot;1&quot;);
 }
 public static synchronized void b() {
 	log.debug(&quot;2&quot;);
 }
}
public static void main(String[] args) {
 Number n1 = new Number();
 Number n2 = new Number();
 new Thread(()-&gt;{ n1.a(); }).start();
 new Thread(()-&gt;{ n2.b(); }).start();
}
</code></pre>

<h2 id="4-4-变量的线程安全分析">4.4 变量的线程安全分析</h2>

<p><strong>成员变量和静态变量是否线程安全？</strong></p>

<ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况

<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul></li>
</ul>

<p><strong>局部变量是否线程安全？</strong></p>

<ul>
<li>局部变量是线程安全的</li>
<li>但局部变量引用的对象则未必

<ul>
<li>如果该对象没有逃离方法的作用范围，它是线程安全的</li>
<li>如果该对象逃离方法的作用范围(return)，需要考虑线程安全</li>
</ul></li>
</ul>

<p><strong>局部变量线程安全分析</strong></p>

<pre><code class="language-java">public static void test1() {
     int i = 10;
     i++; 
}
</code></pre>

<p>每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</p>

<p>将代码反编译后</p>

<pre><code class="language-java">public static void test1();
 descriptor: ()V
 flags: ACC_PUBLIC, ACC_STATIC
 Code:
 stack=1, locals=1, args_size=0
 0: bipush 10
 2: istore_0
 3: iinc 0, 1
 6: return
 LineNumberTable:
 line 10: 0
 line 11: 3
 line 12: 6
 LocalVariableTable:
 Start Length Slot Name Signature
 3 4 0 i I
</code></pre>

<p>如图</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200420130910826.png" alt="image-20200420130910826" /></p>

<p>局部变量的引用稍有不同</p>

<p>先看一个成员变量的例子</p>

<pre><code class="language-java">class ThreadUnsafe {
 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
 public void method1(int loopNumber) {
     for (int i = 0; i &lt; loopNumber; i++) {
         // { 临界区, 会产生竞态条件
         method2();
         method3();
         // } 临界区
     }
 }
 private void method2() {
 	list.add(&quot;1&quot;);
 }
 private void method3() {
 	list.remove(0);
 }
}
</code></pre>

<p>执行</p>

<pre><code class="language-java">static final int THREAD_NUMBER = 2;
static final int LOOP_NUMBER = 200;
public static void main(String[] args) {
 ThreadUnsafe test = new ThreadUnsafe();
 for (int i = 0; i &lt; THREAD_NUMBER; i++) {
     new Thread(() -&gt; {
     test.method1(LOOP_NUMBER);
     }, &quot;Thread&quot; + i).start();
 }
}
</code></pre>

<p>其中一种情况是，如果线程 2 还未 add，线程1 remove 就会报错：</p>

<pre><code>Exception in thread &quot;Thread1&quot; java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 
 at java.util.ArrayList.rangeCheck(ArrayList.java:657) 
 at java.util.ArrayList.remove(ArrayList.java:496) 
 at cn.itcast.n6.ThreadUnsafe.method3(TestThreadSafe.java:35) 
 at cn.itcast.n6.ThreadUnsafe.method1(TestThreadSafe.java:26) 
 at cn.itcast.n6.TestThreadSafe.lambda$main$0(TestThreadSafe.java:14) 
 at java.lang.Thread.run(Thread.java:748)
</code></pre>

<h3 id="分析-1">分析：</h3>

<ul>
<li>无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量</li>
<li>method3 与 method2 分析相同</li>
</ul>

<p><img src="/resources/技术收录/Java/java并发/image-20200420131045455.png" alt="image-20200420131045455" /></p>

<p>将 list 修改为局部变量</p>

<p>那么就不会有上述问题了</p>

<pre><code class="language-java">class ThreadSafe {
     public final void method1(int loopNumber) {
         ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
         for (int i = 0; i &lt; loopNumber; i++) {
         method2(list);
         method3(list);
     }
 }
 private void method2(ArrayList&lt;String&gt; list) {
 	list.add(&quot;1&quot;);
 }
 private void method3(ArrayList&lt;String&gt; list) {
 	list.remove(0);
 }
}
</code></pre>

<p>那么就不会有上述问题了</p>

<p>分析：</p>

<ul>
<li>list 是局部变量，每个线程调用时会创建其不同实例，没有共享</li>
<li>而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象</li>
<li>method3 的参数分析与 method2 相同</li>
</ul>

<p><img src="/resources/技术收录/Java/java并发/image-20200420131208734.png" alt="image-20200420131208734" /></p>

<p>方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会代理线程安全问题？</p>

<ul>
<li>情况 1 ：有其它线程调用 method2 和 method3</li>

<li><p>情况 2 ：在 情况 1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即</p>

<pre><code class="language-java">class ThreadSafe {
public final void method1(int loopNumber) {
 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
 for (int i = 0; i &lt; loopNumber; i++) {
 	method2(list);
 	method3(list);
 }
}
private void method2(ArrayList&lt;String&gt; list) {
	list.add(&quot;1&quot;);
}
private void method3(ArrayList&lt;String&gt; list) {
	list.remove(0);
}
}
class ThreadSafeSubClass extends ThreadSafe{
@Override
public void method3(ArrayList&lt;String&gt; list) {
 new Thread(() -&gt; {
 list.remove(0);
 }).start();
}
}
public class TestThreadSafe {
static final int THREAD_NUMBER = 2;
static final int LOOP_NUMBER = 200;
public static void main(String[] args) {
    ThreadSafeSubClass test = new ThreadSafeSubClass();
    for (int i = 0; i &lt; THREAD_NUMBER; i++) {
        new Thread(() -&gt; {
            test.method1(LOOP_NUMBER);
        }, &quot;Thread&quot; + (i+1)).start();
    }
}
}
</code></pre></li>
</ul>

<blockquote>
<p>从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】</p>
</blockquote>

<h3 id="常见线程安全类">常见线程安全类</h3>

<blockquote>
<p>String
Integer
StringBuffer
Random
Vector
Hashtable
java.util.concurrent 包下的类</p>
</blockquote>

<p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为</p>

<pre><code class="language-java">Hashtable table = new Hashtable();
new Thread(()-&gt;{
    table.put(&quot;key&quot;, &quot;value1&quot;);
}).start();
new Thread(()-&gt;{
    table.put(&quot;key&quot;, &quot;value2&quot;);
}).start();
</code></pre>

<ul>
<li>它们的每个方法是原子的</li>
<li>但注意它们多个方法的组合不是原子的，见后面分析</li>
</ul>

<p><strong>线程安全类方法的组合</strong></p>

<p>分析下面代码是否线程安全？</p>

<pre><code class="language-java">Hashtable table = new Hashtable();
// 线程1，线程2
if( table.get(&quot;key&quot;) == null) {
    table.put(&quot;key&quot;, value);
}
</code></pre>

<p><img src="/resources/技术收录/Java/java并发/image-20200620201831733.png" alt="image-20200620201831733" /></p>

<pre><code class="language-mermaid">sequenceDiagram
  participant 线程1
  participant 线程2
　participant table1
　participant table2
　线程1-&gt;table2:get(&quot;key&quot;)==null
　线程2-&gt;table2:get(&quot;key&quot;)==null
　线程2-&gt;table2:put(&quot;key&quot;,v2)
  线程1-&gt;table2:put(&quot;key&quot;,v1)
</code></pre>

<h3 id="不可变类线程安全性">不可变类线程安全性</h3>

<p>String、Integer 等都是不可变类，因为其内部的状态（属性）不可以改变，因此它们的方法都是线程安全的</p>

<p>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安全的呢？</p>

<pre><code class="language-java">public class Immutable{
    private int value = 0;
    public Immutable(int value){
        this.value = value;
    }
    public int getValue(){
        return this.value;
    }
}
</code></pre>

<p>如果想增加一个增加的方法呢？</p>

<pre><code class="language-java">public class Immutable{
    private int value = 0;
    public Immutable(int value){
        this.value = value;
    }
    public int getValue(){
        return this.value;
    }

    public Immutable add(int v){
        return new Immutable(this.value + v);
    } 
}
</code></pre>

<h3 id="实例分析">实例分析</h3>

<p>例 1 ：</p>

<pre><code class="language-java">public class MyServlet extends HttpServlet {
 // 是否安全？不是
 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
 // 是否安全？是
 String S1 = &quot;...&quot;;
 // 是否安全？是
 final String S2 = &quot;...&quot;;
 // 是否安全？不是
 Date D1 = new Date();
 // 是否安全？不是（引用是不可变的，但是日期内部的值(引用的对象改变了)是可以变化的）
 final Date D2 = new Date();
 public void doGet(HttpServletRequest request, HttpServletResponse response) {
 // 使用上述变量
 }
}
</code></pre>

<p>例 2 ：</p>

<pre><code class="language-java">public class MyServlet extends HttpServlet {
    // 是否安全？不是
    private UserService userService = new UserServiceImpl();

    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}
public class UserServiceImpl implements UserService {
    // 记录调用次数
    private int count = 0;
    public void update() {
        // ...
        count++;
    }
}
</code></pre>

<p>例 3 ：</p>

<pre><code class="language-java">@Aspect
@Component
public class MyAspect {
    // 是否安全？不是；是单例的，意味着该类被共享，那么类中的成员变量也要被共享
    private long start = 0L;

    @Before(&quot;execution(* *(..))&quot;)
    public void before() {
        start = System.nanoTime();
    }
    @After(&quot;execution(* *(..))&quot;)
    public void after() {
        long end = System.nanoTime();
        System.out.println(&quot;cost time:&quot; + (end-start));
    }
}
</code></pre>

<p>例 4 ：</p>

<pre><code class="language-java">public class MyServlet extends HttpServlet {
    // 是否安全，是：UserService虽然有成员变量，但它是私有的不能修改，也意味着它是不可变的
    private UserService userService = new UserServiceImpl();
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}
public class UserServiceImpl implements UserService {
    // 是否安全:是，虽然它是成员变量，能被共享，但是它中没有可更改的属性（无状态的，无状态的一般都是线程安全的）
    private UserDao userDao = new UserDaoImpl();
    public void update() {
        userDao.update();
    }
}
public class UserDaoImpl implements UserDao { 
    public void update() {
        String sql = &quot;update user set password = ? where username = ?&quot;;
        // 是否安全，是：，没有成员变量的类，一般都是线程安全的
        try (Connection conn = DriverManager.getConnection(&quot;&quot;,&quot;&quot;,&quot;&quot;)){
            // ...
        } catch (Exception e) {
            // ...
        }
    }
}
</code></pre>

<p>例 5 ：</p>

<pre><code class="language-java">public class MyServlet extends HttpServlet {
    // 是否安全
    private UserService userService = new UserServiceImpl();

    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}
public class UserServiceImpl implements UserService {
    // 是否安全
    private UserDao userDao = new UserDaoImpl();

    public void update() {
        userDao.update();
    }
}
public class UserDaoImpl implements UserDao {
    // 是否安全，否：没有将Connection作为方法内的局部变量，而是作为了类的成员变量
    private Connection conn = null;
    public void update() throws SQLException {
        String sql = &quot;update user set password = ? where username = ?&quot;;
        conn = DriverManager.getConnection(&quot;&quot;,&quot;&quot;,&quot;&quot;);
        // ...
        conn.close();
    }
}
</code></pre>

<p>例 6 ：</p>

<pre><code class="language-java">public class MyServlet extends HttpServlet {
 // 是否安全
 private UserService userService = new UserServiceImpl();
 
 public void doGet(HttpServletRequest request, HttpServletResponse response) {
 	userService.update(...);
 }
}
public class UserServiceImpl implements UserService { 
   	//线程安全：作为方法的局部变量
     public void update() {
             UserDao userDao = new UserDaoImpl();
             userDao.update();
     }
}
public class UserDaoImpl implements UserDao {
     // 是否安全
     private Connection = null;
     public void update() throws SQLException {
         String sql = &quot;update user set password = ? where username = ?&quot;;
         conn = DriverManager.getConnection(&quot;&quot;,&quot;&quot;,&quot;&quot;);
         // ...
         conn.close();
     }
}
</code></pre>

<p>例 7 ：</p>

<pre><code class="language-java">public abstract class Test {

    public void bar() {
        // 是否安全，否：虽然是局部变量，但是它还可能暴漏给其他线程
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        foo(sdf);
    }
    public abstract foo(SimpleDateFormat sdf);
    public static void main(String[] args) {
        new Test().bar();
    }
}
</code></pre>

<p>其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为<strong>外星方法</strong></p>

<pre><code class="language-java">public void foo(SimpleDateFormat sdf) {
 String dateStr = &quot;1999-10-11 00:00:00&quot;;
 for (int i = 0; i &lt; 20; i++) {
     new Thread(() -&gt; {
     try {
     	sdf.parse(dateStr);
     } catch (ParseException e) {
     	e.printStackTrace();
     }
     }).start();
 }
}
</code></pre>

<p>请比较 JDK 中 String 类的实现</p>

<pre><code>public final class String
</code></pre>

<p>为什么要定义成final：因为String本身是线程安全的，他的子类可能就会覆盖掉父类中的行为方法，导致不安全的发生（体现了闭合原则）</p>

<p>例 8 ：</p>

<pre><code class="language-java">private static Integer i = 0;
public static void main(String[] args) throws InterruptedException {
    List&lt;Thread&gt; list = new ArrayList&lt;&gt;();
    for (int j = 0; j &lt; 2; j++) {
        Thread thread = new Thread(() -&gt; {
            for (int k = 0; k &lt; 5000; k++) {
                synchronized (i) {
                    i++;
                }
            }
        }, &quot;&quot; + j);
        list.add(thread);
    }
    list.stream().forEach(t -&gt; t.start());
    list.stream().forEach(t -&gt; {
        try {
            t.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
    log.debug(&quot;{}&quot;, i);
}
</code></pre>

<h2 id="4-5-习题">4.5 习题</h2>

<h3 id="卖票练习">卖票练习</h3>

<p>测试下面代码是否存在线程安全问题，并尝试改正</p>

<p>临界区：对共享变量有读写操作的代码片段称为临界区</p>

<pre><code class="language-java">public class ExerciseSell {
    public static void main(String[] args) {
        //模拟多人买票
        TicketWindow ticketWindow = new TicketWindow(2000);
        //使用的是ArrayList而不是线程安全的Vector是因为：list只会在主线程中使用，并没有被多个线程所共享
        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();
        // 用来存储买出去多少张票
        List&lt;Integer&gt; sellCount = new Vector&lt;&gt;();
        for (int i = 0; i &lt; 2000; i++) {
            Thread t = new Thread(() -&gt; {
                // 分析这里的竞态条件
                //非线程安全
                int count = ticketWindow.sell(randomAmount());

                //线程安全的
                sellCount.add(count);
                //不需要考虑二者的方法组合的线程安全问题：因为二者是两个不同的共享变量，他俩二者没有关系
            });
            //不影响
            list.add(t);
            t.start();
        }
        list.forEach((t) -&gt; {
            try {
                //等待每一个线程都结束
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        // 卖出去的票求和
        log.debug(&quot;selled count:{}&quot;,sellCount.stream().mapToInt(c -&gt; c).sum());
        // 剩余票数
        log.debug(&quot;remainder count:{}&quot;, ticketWindow.getCount());
    }
    // Random 为线程安全
    static Random random = new Random();
    // 随机 1~5
    public static int randomAmount() {
        return random.nextInt(5) + 1;
    }
}
class TicketWindow {
    private int count;
    public TicketWindow(int count) {
        this.count = count;
    }
    public int getCount() {
        return count;
    }
    //属于临界区需要保护
    /*public int sell(int amount) {
             if (this.count &gt;= amount) {
                this.count -= amount;
                return amount;
             } else {
                return 0;
             }
         }*/
    //对this对象进行加锁，保证线程安全
    public synchronized int sell(int amount) {
        if (this.count &gt;= amount) {
            this.count -= amount;
            return amount;
        } else {
            return 0;
        }
    }
}
</code></pre>

<p>另外，用下面的代码行不行，为什么？</p>

<pre><code>List&lt;Integer&gt; sellCount = new ArrayList&lt;&gt;();
</code></pre>

<p>测试脚本</p>

<pre><code class="language-shell">for /L %n in (1,1,10) do java -cp &quot;.;C:\Users\manyh\.m2\repository\ch\qos\logback\logbackclassic\1.2.3\logback-classic-1.2.3.jar;C:\Users\manyh\.m2\repository\ch\qos\logback\logbackcore\1.2.3\logback-core-1.2.3.jar;C:\Users\manyh\.m2\repository\org\slf4j\slf4japi\1.7.25\slf4j-api-1.7.25.jar&quot; cn.itcast.n4.exercise.ExerciseSell
</code></pre>

<h3 id="转账练习">转账练习</h3>

<p>测试下面代码是否存在线程安全问题，并尝试改正</p>

<pre><code class="language-java">public class ExerciseTransfer {
 public static void main(String[] args) throws InterruptedException {
     Account a = new Account(1000);
     Account b = new Account(1000);
     Thread t1 = new Thread(() -&gt; {
         for (int i = 0; i &lt; 1000; i++) {
             a.transfer(b, randomAmount());
        }
     }, &quot;t1&quot;);
     Thread t2 = new Thread(() -&gt; {
        for (int i = 0; i &lt; 1000; i++) {
           b.transfer(a, randomAmount());
         }
     }, &quot;t2&quot;);
     t1.start();
     t2.start();
     t1.join();
     t2.join();
     // 查看转账2000次后的总金额
     log.debug(&quot;total:{}&quot;,(a.getMoney() + b.getMoney()));
 }
 // Random 为线程安全
 static Random random = new Random();
 // 随机 1~100
 public static int randomAmount() {
 	return random.nextInt(100) +1;
 }
}
class Account {
 private int money;
 public Account(int money) {
 	this.money = money;
 }
 public int getMoney() {
 	return money;
 }
 public void setMoney(int money) {
 	this.money = money;
 }
    //加锁，共享变量为：this.money和target中的money着两个对象，不能对这两个对象分别进行加锁，这样的话没用；二者有一个共同的属性Account这个类，因此可以对Account.class进行加锁。（效率不高，后面会详解）
 public void transfer(Account target, int amount) {
     /*if (this.money &gt; amount) {
     	this.setMoney(this.getMoney() - amount);
     	target.setMoney(target.getMoney() + amount);
     }*/
     synchronized(Account.class) {
         if (this.money &gt;= amount) {
             this.setMoney(this.getMoney() - amount);
             target.setMoney(target.getMoney() + amount);
         }
     }
 }
}
</code></pre>

<p>这样改正行不行，为什么？</p>

<pre><code class="language-java">public synchronized void transfer(Account target, int amount) {
    if (this.money &gt; amount) {
        this.setMoney(this.getMoney() - amount);
        target.setMoney(target.getMoney() + amount);
    }
}
</code></pre>

<p>不行这样只是对synchronized（this）{}进行加锁</p>

<h2 id="4-6-monitor-概念">4.6 Monitor 概念</h2>

<h3 id="java-对象头">Java 对象头</h3>

<p>以 32 位虚拟机为例</p>

<p>Integer:8（对象头）+4（值）</p>

<p>int:4</p>

<p>普通对象</p>

<pre><code class="language-java">|--------------------------------------------------------------|
| 				Object Header (64 bits) 					|
|------------------------------------|-------------------------| 
| 			Mark Word (32 bits) 	| Klass Word (32 bits)	  |
|------------------------------------|-------------------------|
</code></pre>

<p>Klass Word：指针，指向了该对象的class（该对象是什么类型的）</p>

<p>Mark Word:见下面解析</p>

<p>数组对象</p>

<pre><code class="language-java">|---------------------------------------------------------------------------------|
| 								Object Header (96 bits)  					 |
|--------------------------------|-----------------------|------------------------|
| 	Mark Word(32bits)		    | Klass Word(32bits)    | array length(32bits)   |
|--------------------------------|-----------------------|------------------------|
</code></pre>

<p>其中 Mark Word 结构为</p>

<pre><code class="language-java">|-------------------------------------------------------|--------------------|
| 			  Mark Word (32 bits) 					 | State 	  		 |
|-------------------------------------------------------|--------------------|
| hashcode:25 		| age:4 	| biased_lock:0 | 01   | Normal			   |
|-------------------------------------------------------|--------------------|
| thread:23 | epoch:2 | age:4 | biased_lock:1    | 01   | Biased 			|
|-------------------------------------------------------|--------------------|
| 			ptr_to_lock_record:30			   | 00  | Lightweight Locked |
|-------------------------------------------------------|--------------------|
| 		ptr_to_heavyweight_monitor:30		    | 10   | Heavyweight Locked |
|-------------------------------------------------------|--------------------|
| 											  |  11 | 		Marked for GC|
|-------------------------------------------------------|--------------------|
</code></pre>

<p>普通对象是Normal；hashcode为hash值、age为垃圾回收的分代年龄、biased_lock对象是否启用偏向锁标记</p>

<p>当对象与系统的monitor关联后变为Heavyweight Locked；其中ptr_to_heavyweight_monitor存储的是指向monitor的指针</p>

<p>64 位虚拟机 Mark Word</p>

<pre><code class="language-java">--------------------------------------------------------------------|--------------------|
| Mark Word (64 bits) | State |
|--------------------------------------------------------------------|--------------------|
| unused:25 | hashcode:31 | unused:1 | age:4 | biased_lock:0 | 01 | Normal |
|--------------------------------------------------------------------|--------------------|
| thread:54 | epoch:2 | unused:1 | age:4 | biased_lock:1 | 01 | Biased |
|--------------------------------------------------------------------|--------------------|
| ptr_to_lock_record:62 | 00 | Lightweight Locked |
|--------------------------------------------------------------------|--------------------|
| ptr_to_heavyweight_monitor:62 | 10 | Heavyweight Locked |
|--------------------------------------------------------------------|--------------------|
| | 11 | Marked for GC |
|--------------------------------------------------------------------|--------------------|
</code></pre>

<ul>
<li><strong>原理之 Monitor(锁)</strong></li>
<li>原理之 synchronized</li>
</ul>

<h3 id="小故事">小故事</h3>

<p>故事角色</p>

<ul>
<li>老王 - JVM</li>
<li>小南 - 线程</li>
<li>小女 - 线程</li>
<li>房间 - 对象</li>
<li>房间门上 - 防盗锁 - Monitor</li>
<li>房间门上 - 小南书包 - 轻量级锁</li>
<li>房间门上 - 刻上小南大名 - 偏向锁</li>
<li>批量重刻名 - 一个类的偏向锁撤销到达 20 阈值</li>
<li>不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向</li>
</ul>

<p>小南要使用房间保证计算不被其它人干扰（原子性），最初，他用的是防盗锁，当上下文切换时，锁住门。这样，即使他离开了，别人也进不了门，他的工作就是安全的。</p>

<p>但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女晚上用。每次上锁太麻烦了，有没有更简单的办法呢？</p>

<p>小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因此每次进门前得翻翻书包，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是自己的，那么就在门外等，并通知对方下次用锁门的方式。</p>

<p>后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍然觉得麻烦。</p>

<p>于是，小南干脆在门上刻上了自己的名字：【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦掉，升级为挂书包的方式。</p>

<p>同学们都放假回老家了，小南就膨胀了，在 20 个房间刻上了自己的名字，想进哪个进哪个。后来他自己放假回老家了，这时小女回来了（她也要用这些房间），结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字</p>

<p>后来，刻名的现象越来越频繁，老王受不了了：算了，这些房间都不能刻名了，只能挂书包</p>

<ul>
<li>原理之 synchronized 进阶</li>
</ul>

<h2 id="4-7-wait-notify">4.7 wait notify</h2>

<p>小故事 - 为什么需要 wait</p>

<ul>
<li>由于条件不满足，小南不能继续进行计算</li>
<li>但小南如果一直占用着锁，其它人就得一直阻塞，效率太低</li>
<li>于是老王单开了一间休息室（调用 wait 方法），让小南到休息室（WaitSet）等着去了，但这时锁释放开，</li>
<li>其它人可以由老王随机安排进屋</li>
<li>直到小M将烟送来，大叫一声 [ 你的烟到了 ] （调用 notify 方法）</li>
<li>小南于是可以离开休息室，重新进入竞争锁的队列</li>
</ul>

<p><strong>原理之 wait / notify</strong></p>

<h3 id="api-介绍">API 介绍</h3>

<ul>
<li>obj.wait() 让进入 object 监视器的线程到 waitSet 等待</li>
<li>obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒（随机挑选）</li>
<li>obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒</li>
</ul>

<p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法</p>

<p>直接调用obj.wait()方法会报错的，这是因为obj对象还没有上锁，还没有和monitor进行关联。因此wait方法一定是要在同步代码块中执行的。</p>

<pre><code class="language-java">final static Object obj = new Object();
public static void main(String[] args) {
     new Thread(() -&gt; {
         synchronized (obj) {
             log.debug(&quot;执行....&quot;);
             try {
                 obj.wait(); // 让线程在obj上一直等待下去
             } catch (InterruptedException e) {
                e.printStackTrace();
             }
         	log.debug(&quot;其它代码....&quot;);
         }
     }).start();
     new Thread(() -&gt; {
         synchronized (obj) {
             log.debug(&quot;执行....&quot;);
             try {
                obj.wait(); // 让线程在obj上一直等待下去
             } catch (InterruptedException e) {
                e.printStackTrace();
             }
         	log.debug(&quot;其它代码....&quot;);
         }
     }).start();
     // 主线程两秒后执行
     sleep(2);
     log.debug(&quot;唤醒 obj 上其它线程&quot;);
     synchronized (obj) {
     obj.notify(); // 唤醒obj上一个线程
     // obj.notifyAll(); // 唤醒obj上所有等待线程
     }
}
</code></pre>

<p>notify 的一种结果</p>

<pre><code>20:00:53.096 [Thread-0] c.TestWaitNotify - 执行.... 
20:00:53.099 [Thread-1] c.TestWaitNotify - 执行.... 
20:00:55.096 [main] c.TestWaitNotify - 唤醒 obj 上其它线程
20:00:55.096 [Thread-0] c.TestWaitNotify - 其它代码....
</code></pre>

<p>notifyAll 的结果</p>

<pre><code>19:58:15.457 [Thread-0] c.TestWaitNotify - 执行.... 
19:58:15.460 [Thread-1] c.TestWaitNotify - 执行.... 
19:58:17.456 [main] c.TestWaitNotify - 唤醒 obj 上其它线程
19:58:17.456 [Thread-1] c.TestWaitNotify - 其它代码.... 
19:58:17.456 [Thread-0] c.TestWaitNotify - 其它代码....
</code></pre>

<p>wait() 方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到notify 为止</p>

<ul>
<li>wait(long n) 有时限的等待, 到 n 毫秒后结束等待，或是被 notify（wait无参或0都是无限等待下去）</li>
</ul>

<h2 id="4-8-wait-notify-的正确姿势">4.8 wait notify 的正确姿势</h2>

<p>开始之前先看看</p>

<h3 id="sleep-long-n-和-wait-long-n-的区别">sleep(long n) 和 wait(long n) 的区别</h3>

<ul>
<li>1）sleep 是 Thread 的静态方法，而 wait 是 Object 的方法</li>
<li>2) sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用</li>
<li>3) sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 4) 它们状态 TIMED_WAITING</li>

<li><p>4） 他们的状态都是TIMED_WATING</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test19&quot;)
public class Test19 {
static final Object lock = new Object();
public static void main(String[] args) {
    new Thread(() -&gt; {
        synchronized (lock) {
            log.debug(&quot;获得锁&quot;);
            try {
//                    Thread.sleep(20000);
                lock.wait(20000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }, &quot;t1&quot;).start();

    Sleeper.sleep(1);
    synchronized (lock) {
        log.debug(&quot;获得锁&quot;);
    }
}
}
</code></pre></li>
</ul>

<p>step 1</p>

<pre><code>static final Object room = new Object();
static boolean hasCigarette = false;
static boolean hasTakeout = false;
</code></pre>

<p>思考下面的解决方案好不好，为什么？</p>

<pre><code class="language-java">new Thread(() -&gt; {
     synchronized (room) {
         log.debug(&quot;有烟没？[{}]&quot;, hasCigarette);
         if (!hasCigarette) {
            log.debug(&quot;没烟，先歇会！&quot;);
            sleep(2);
         }
            log.debug(&quot;有烟没？[{}]&quot;, hasCigarette);
         if (hasCigarette) {
            log.debug(&quot;可以开始干活了&quot;);
         }
     }
}, &quot;小南&quot;).start();
for (int i = 0; i &lt; 5; i++) {
     new Thread(() -&gt; {
         synchronized (room) {
         	log.debug(&quot;可以开始干活了&quot;);
         }
     }, &quot;其它人&quot;).start();
 }
sleep(1);
new Thread(() -&gt; {
	 // 这里能不能加 synchronized (room)？
	 hasCigarette = true;
 	log.debug(&quot;烟到了噢！&quot;);
}, &quot;送烟的&quot;).start();
</code></pre>

<p>输出</p>

<pre><code>20:49:49.883 [小南] c.TestCorrectPosture - 有烟没？[false]
20:49:49.887 [小南] c.TestCorrectPosture - 没烟，先歇会！
20:49:50.882 [送烟的] c.TestCorrectPosture - 烟到了噢！
20:49:51.887 [小南] c.TestCorrectPosture - 有烟没？[true]
20:49:51.887 [小南] c.TestCorrectPosture - 可以开始干活了
20:49:51.887 [其它人] c.TestCorrectPosture - 可以开始干活了
20:49:51.887 [其它人] c.TestCorrectPosture - 可以开始干活了
20:49:51.888 [其它人] c.TestCorrectPosture - 可以开始干活了
20:49:51.888 [其它人] c.TestCorrectPosture - 可以开始干活了
20:49:51.888 [其它人] c.TestCorrectPosture - 可以开始干活了
</code></pre>

<ul>
<li>其它干活的线程，都要一直阻塞，效率太低</li>
<li>小南线程必须睡足 2s 后才能醒来，就算烟提前送到，也无法立刻醒来</li>
<li>加了 synchronized (room) 后，就好比小南在里面反锁了门睡觉，烟根本没法送进门，main 没加
synchronized 就好像 main 线程是翻窗户进来的</li>
<li>解决方法，使用 wait - notify 机制</li>
</ul>

<p>step 2</p>

<p>思考下面的实现行吗，为什么？</p>

<pre><code class="language-java">new Thread(() -&gt; {
     synchronized (room) {
         log.debug(&quot;有烟没？[{}]&quot;, hasCigarette);
         if (!hasCigarette) {
             log.debug(&quot;没烟，先歇会！&quot;);
             try {
             	room.wait(2000);
             } catch (InterruptedException e) {
             	e.printStackTrace();
             }
         }
         log.debug(&quot;有烟没？[{}]&quot;, hasCigarette);
         if (hasCigarette) {
         	log.debug(&quot;可以开始干活了&quot;);
         }
     }
}, &quot;小南&quot;).start();
for (int i = 0; i &lt; 5; i++) {
     new Thread(() -&gt; {
         synchronized (room) {
         	log.debug(&quot;可以开始干活了&quot;);
         }
     }, &quot;其它人&quot;).start();
}
sleep(1);
new Thread(() -&gt; {
     synchronized (room) {
     	hasCigarette = true;
     	log.debug(&quot;烟到了噢！&quot;);
     	room.notify();
     }
}, &quot;送烟的&quot;).start();
</code></pre>

<p>输出</p>

<pre><code>20:51:42.489 [小南] c.TestCorrectPosture - 有烟没？[false] 
20:51:42.493 [小南] c.TestCorrectPosture - 没烟，先歇会！
20:51:42.493 [其它人] c.TestCorrectPosture - 可以开始干活了
20:51:42.493 [其它人] c.TestCorrectPosture - 可以开始干活了
20:51:42.494 [其它人] c.TestCorrectPosture - 可以开始干活了
20:51:42.494 [其它人] c.TestCorrectPosture - 可以开始干活了
20:51:42.494 [其它人] c.TestCorrectPosture - 可以开始干活了
20:51:43.490 [送烟的] c.TestCorrectPosture - 烟到了噢！
20:51:43.490 [小南] c.TestCorrectPosture - 有烟没？[true] 
20:51:43.490 [小南] c.TestCorrectPosture - 可以开始干活了
</code></pre>

<ul>
<li>解决了其它干活的线程阻塞的问题</li>
<li>但如果有其它线程也在等待条件呢？</li>
</ul>

<p>step 3</p>

<pre><code class="language-java">new Thread(() -&gt; {
     synchronized (room) {
         log.debug(&quot;有烟没？[{}]&quot;, hasCigarette);
         if (!hasCigarette) {
         	log.debug(&quot;没烟，先歇会！&quot;);
             try {
                room.wait();
             } catch (InterruptedException e) {
                e.printStackTrace();
             }
         }
         log.debug(&quot;有烟没？[{}]&quot;, hasCigarette);
         if (hasCigarette) {
         	log.debug(&quot;可以开始干活了&quot;);
         } else {
         	log.debug(&quot;没干成活...&quot;);
         }
     }
}, &quot;小南&quot;).start();
new Thread(() -&gt; {
     synchronized (room) {
         Thread thread = Thread.currentThread();
         log.debug(&quot;外卖送到没？[{}]&quot;, hasTakeout);
         if (!hasTakeout) {
             log.debug(&quot;没外卖，先歇会！&quot;);
             try {
             	room.wait();
             } catch (InterruptedException e) {
            	 e.printStackTrace();
             }
         }
         log.debug(&quot;外卖送到没？[{}]&quot;, hasTakeout);
         if (hasTakeout) {
         	log.debug(&quot;可以开始干活了&quot;);
         } else {
         	log.debug(&quot;没干成活...&quot;);
         }
     }
}, &quot;小女&quot;).start();
sleep(1);
new Thread(() -&gt; {
 	synchronized (room) {
     	hasTakeout = true;
     	log.debug(&quot;外卖到了噢！&quot;);
     	room.notify();
     }
}, &quot;送外卖的&quot;).start();
</code></pre>

<p>输出</p>

<pre><code>20:53:12.173 [小南] c.TestCorrectPosture - 有烟没？[false] 
20:53:12.176 [小南] c.TestCorrectPosture - 没烟，先歇会！
20:53:12.176 [小女] c.TestCorrectPosture - 外卖送到没？[false] 
20:53:12.176 [小女] c.TestCorrectPosture - 没外卖，先歇会！
20:53:13.174 [送外卖的] c.TestCorrectPosture - 外卖到了噢！
20:53:13.174 [小南] c.TestCorrectPosture - 有烟没？[false] 
20:53:13.174 [小南] c.TestCorrectPosture - 没干成活...
</code></pre>

<ul>
<li>notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程，称之为【虚假唤醒】</li>
<li>解决方法，改为 notifyAll</li>
</ul>

<p>step 4</p>

<pre><code class="language-java">new Thread(() -&gt; {
     synchronized (room) {
         hasTakeout = true;
         log.debug(&quot;外卖到了噢！&quot;);
         room.notifyAll();
     }
}, &quot;送外卖的&quot;).start();
</code></pre>

<p>输出</p>

<pre><code>20:55:23.978 [小南] c.TestCorrectPosture - 有烟没？[false] 
20:55:23.982 [小南] c.TestCorrectPosture - 没烟，先歇会！
20:55:23.982 [小女] c.TestCorrectPosture - 外卖送到没？[false] 
20:55:23.982 [小女] c.TestCorrectPosture - 没外卖，先歇会！
20:55:24.979 [送外卖的] c.TestCorrectPosture - 外卖到了噢！
20:55:24.979 [小女] c.TestCorrectPosture - 外卖送到没？[true] 
20:55:24.980 [小女] c.TestCorrectPosture - 可以开始干活了
20:55:24.980 [小南] c.TestCorrectPosture - 有烟没？[false] 
20:55:24.980 [小南] c.TestCorrectPosture - 没干成活...
</code></pre>

<ul>
<li>用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新判断的机会了</li>
<li>解决方法，用 while + wait，当条件不成立，再次 wait</li>
</ul>

<p>step 5</p>

<p>将 if 改为 while</p>

<pre><code class="language-java">if (!hasCigarette) {
    log.debug(&quot;没烟，先歇会！&quot;);
    try {
        room.wait();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>改动后</p>

<pre><code class="language-java">while (!hasCigarette) {
    log.debug(&quot;没烟，先歇会！&quot;);
    try {
        room.wait();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>输出</p>

<pre><code>20:58:34.322 [小南] c.TestCorrectPosture - 有烟没？[false] 
20:58:34.326 [小南] c.TestCorrectPosture - 没烟，先歇会！
20:58:34.326 [小女] c.TestCorrectPosture - 外卖送到没？[false] 
20:58:34.326 [小女] c.TestCorrectPosture - 没外卖，先歇会！
20:58:35.323 [送外卖的] c.TestCorrectPosture - 外卖到了噢！
20:58:35.324 [小女] c.TestCorrectPosture - 外卖送到没？[true] 
20:58:35.324 [小女] c.TestCorrectPosture - 可以开始干活了
20:58:35.324 [小南] c.TestCorrectPosture - 没烟，先歇会！
</code></pre>

<pre><code class="language-java">synchronized(lock) {
     while(条件不成立) {
     	lock.wait();
     }
 // 干活
}
//另一个线程
synchronized(lock) {
 	lock.notifyAll();
}
</code></pre>

<ul>
<li><p><strong>模式之保护性暂停</strong></p></li>

<li><p><strong>模式之生产者消费者</strong></p></li>
</ul>

<h2 id="4-9-park-unpark">4.9 Park &amp; Unpark</h2>

<h3 id="基本使用">基本使用</h3>

<p>它们是 LockSupport 类中的方法</p>

<pre><code class="language-java">// 暂停当前线程
LockSupport.park(); 
// 恢复某个线程的运行  可以在暂停之前调用，也可以在线程之后调用
LockSupport.unpark(暂停线程对象)
</code></pre>

<p>先 park 再 unpark</p>

<pre><code class="language-java">Thread t1 = new Thread(() -&gt; {
     log.debug(&quot;start...&quot;);
     sleep(1);
     log.debug(&quot;park...&quot;);
     LockSupport.park();
     log.debug(&quot;resume...&quot;);
},&quot;t1&quot;);
t1.start();
sleep(2);
log.debug(&quot;unpark...&quot;);
LockSupport.unpark(t1);
</code></pre>

<p>输出</p>

<pre><code>18:42:52.585 c.TestParkUnpark [t1] - start... 
18:42:53.589 c.TestParkUnpark [t1] - park... 
18:42:54.583 c.TestParkUnpark [main] - unpark... 
18:42:54.583 c.TestParkUnpark [t1] - resume...
</code></pre>

<p>先 unpark 再 park</p>

<pre><code class="language-java">Thread t1 = new Thread(() -&gt; {
    log.debug(&quot;start...&quot;);
    sleep(2);
    log.debug(&quot;park...&quot;);
    LockSupport.park();
    log.debug(&quot;resume...&quot;);
}, &quot;t1&quot;);
t1.start();
sleep(1);
log.debug(&quot;unpark...&quot;);
LockSupport.unpark(t1);
</code></pre>

<p>输出</p>

<pre><code>18:43:50.765 c.TestParkUnpark [t1] - start... 
18:43:51.764 c.TestParkUnpark [main] - unpark... 
18:43:52.769 c.TestParkUnpark [t1] - park... 
18:43:52.769 c.TestParkUnpark [t1] - resume...
</code></pre>

<h3 id="特点">特点</h3>

<p>与 Object 的 wait &amp; notify 相比</p>

<ul>
<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用（在同步代码块中使用），而 park，unpark 不必</li>
<li>park &amp; unpark是以线程为单位来【阻塞】和【唤醒】线程，而 notify只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】</li>
<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>
</ul>

<p>*** 原理之 park &amp; unpark**</p>

<h2 id="4-10-重新理解线程状态转换">4.10 重新理解线程状态转换</h2>

<p><img src="/resources/技术收录/Java/java并发/image-20200420133945020.png" alt="image-20200420133945020" /></p>

<p>假设有线程 Thread t</p>

<h3 id="情况-1-new-runnable">情况 1 NEW &ndash;&gt; RUNNABLE</h3>

<ul>
<li>当调用 t.start() 方法时，由 NEW &ndash;&gt; RUNNABLE</li>
</ul>

<h3 id="情况-2-runnable-waiting">情况 2 RUNNABLE &lt;&ndash;&gt; WAITING</h3>

<p>t 线程用 synchronized(obj) 获取了对象锁后</p>

<ul>
<li>调用 obj.wait() 方法时，t 线程从 RUNNABLE &ndash;&gt; WAITING</li>

<li><p>调用 obj.notify()，obj.notifyAll()，t.interrupt() 时</p>

<ul>
<li>竞争锁成功，t 线程从 WAITING &ndash;&gt; RUNNABLE</li>

<li><p>竞争锁失败，t 线程从 WAITING &ndash;&gt; BLOCKED</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.TestWaitNotify&quot;)
public class TestWaitNotify {
final static Object obj = new Object();
public static void main(String[] args) {
new Thread(() -&gt; {
    synchronized (obj) {
        log.debug(&quot;执行....&quot;);
        try {
            obj.wait(); // 让线程在obj上一直等待下去
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.debug(&quot;其它代码....&quot;);
    }
},&quot;t1&quot;).start();
new Thread(() -&gt; {
    synchronized (obj) {
        log.debug(&quot;执行....&quot;);
        try {
            obj.wait(); // 让线程在obj上一直等待下去
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.debug(&quot;其它代码....&quot;);
    }
},&quot;t2&quot;).start();
// 主线程两秒后执行
sleep(0.5);
log.debug(&quot;唤醒 obj 上其它线程&quot;);
synchronized (obj) {
//            obj.notify(); // 唤醒obj上一个线程
    obj.notifyAll(); // 唤醒obj上所有等待线程
}
}
}
</code></pre></li>
</ul></li>
</ul>

<h3 id="情况-3-runnable-waiting">情况 3 RUNNABLE &lt;&ndash;&gt; WAITING</h3>

<ul>
<li>当前线程调用 t.join() 方法时，当前线程从 RUNNABLE &ndash;&gt; WAITING

<ul>
<li>注意是当前线程在t 线程对象的监视器上等待</li>
</ul></li>
<li>t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING &ndash;&gt; RUNNABLE</li>
</ul>

<h3 id="情况-4-runnable-waiting">情况 4 RUNNABLE &lt;&ndash;&gt; WAITING</h3>

<ul>
<li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE &ndash;&gt; WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt()，会让目标线程从 WAITING &ndash;&gt;
RUNNABLE</li>
</ul>

<h3 id="情况-5-runnable-timed-waiting">情况 5 RUNNABLE &lt;&ndash;&gt; TIMED_WAITING</h3>

<p>t 线程用 synchronized(obj) 获取了对象锁后</p>

<ul>
<li>调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE &ndash;&gt; TIMED_WAITING</li>
<li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify()，obj.notifyAll()，t.interrupt() 时

<ul>
<li>竞争锁成功，t 线程从 TIMED_WAITING &ndash;&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从 TIMED_WAITING &ndash;&gt; BLOCKED</li>
</ul></li>
</ul>

<h3 id="情况-6-runnable-timed-waiting">情况 6 RUNNABLE &lt;&ndash;&gt; TIMED_WAITING</h3>

<ul>
<li>当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE &ndash;&gt; TIMED_WAITING

<ul>
<li>注意是当前线程在t 线程对象的监视器上等待</li>
</ul></li>
<li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从TIMED_WAITING &ndash;&gt; RUNNABLE</li>
</ul>

<h3 id="情况-7-runnable-timed-waiting">情况 7 RUNNABLE &lt;&ndash;&gt; TIMED_WAITING</h3>

<ul>
<li>当前线程调用 Thread.sleep(long n)，当前线程从 RUNNABLE &ndash;&gt; TIMED_WAITING</li>
<li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING &ndash;&gt; RUNNABLE</li>
</ul>

<h3 id="情况-8-runnable-timed-waiting">情况 8 RUNNABLE &lt;&ndash;&gt; TIMED_WAITING</h3>

<ul>
<li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线程从 RUNNABLE &ndash;&gt; TIMED_WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt()，或是等待超时，会让目标线程从TIMED_WAITING&ndash;&gt; RUNNABLE</li>
</ul>

<h3 id="情况-9-runnable-blocked">情况 9 RUNNABLE &lt;&ndash;&gt; BLOCKED</h3>

<ul>
<li>t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE &ndash;&gt; BLOCKED</li>
<li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED &ndash;&gt; RUNNABLE，其它失败的线程仍然 BLOCKED</li>
</ul>

<h3 id="情况-10-runnable-terminated">情况 10 RUNNABLE &lt;&ndash;&gt; TERMINATED</h3>

<p>当前线程所有代码运行完毕，进入TERMINATED</p>

<h2 id="4-11-多把锁">4.11 多把锁</h2>

<h3 id="多把不相干的锁">多把不相干的锁</h3>

<p>一间大屋子有两个功能：睡觉、学习，互不相干。</p>

<p>现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低</p>

<p>解决方法是准备多个房间（多个对象锁）</p>

<p>例如</p>

<pre><code class="language-java">class BigRoom {
 public void sleep() {
     synchronized (this) {
     	log.debug(&quot;sleeping 2 小时&quot;);
     	Sleeper.sleep(2);
     }
 }
 public void study() {
     synchronized (this) {
     	log.debug(&quot;study 1 小时&quot;);
    	Sleeper.sleep(1);
     }
 }
}
</code></pre>

<p>执行</p>

<pre><code class="language-java">BigRoom bigRoom = new BigRoom();
new Thread(() -&gt; {
 	bigRoom.compute();
},&quot;小南&quot;).start();
new Thread(() -&gt; {
 	bigRoom.sleep();
},&quot;小女&quot;).start();
</code></pre>

<p>某次结果</p>

<pre><code>12:13:54.471 [小南] c.BigRoom - study 1 小时
12:13:55.476 [小女] c.BigRoom - sleeping 2 小时
</code></pre>

<p>改进</p>

<pre><code class="language-java">class BigRoom {
     private final Object studyRoom = new Object();
     private final Object bedRoom = new Object();
     public void sleep() {
         synchronized (bedRoom) {
         	log.debug(&quot;sleeping 2 小时&quot;);
         	Sleeper.sleep(2);
         }
     }
     public void study() {
         synchronized (studyRoom) {
         	log.debug(&quot;study 1 小时&quot;);
         	Sleeper.sleep(1);
         }
     }
}
</code></pre>

<p>某次执行结果</p>

<pre><code>12:15:35.069 [小南] c.BigRoom - study 1 小时
12:15:35.069 [小女] c.BigRoom - sleeping 2 小时
</code></pre>

<p>二者之间没有相互关联</p>

<p>将锁的粒度细分</p>

<ul>
<li>好处，是可以增强并发度</li>
<li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li>
</ul>

<h2 id="4-12-活跃性">4.12 活跃性</h2>

<h3 id="死锁">死锁</h3>

<p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁</p>

<p>t1 线程 获得 A对象 锁，接下来想获取 B对象的锁 t2 线程 获得 B对象 锁，接下来想获取 A对象的锁 例：</p>

<pre><code class="language-java">
@Slf4j(topic = &quot;c.TestDeadLock&quot;)
public class TestDeadLock {
    public static void main(String[] args) {
        test1();
    }
    private static void test1() {
        Object A = new Object();
        Object B = new Object();
        Thread t1 = new Thread(() -&gt; {
            synchronized (A) {
                log.debug(&quot;lock A&quot;);
                sleep(1);
                synchronized (B) {
                    log.debug(&quot;lock B&quot;);
                    log.debug(&quot;操作...&quot;);
                }
            }
        }, &quot;t1&quot;);
        Thread t2 = new Thread(() -&gt; {
            synchronized (B) {
                log.debug(&quot;lock B&quot;);
                sleep(0.5);
                synchronized (A) {
                    log.debug(&quot;lock A&quot;);
                    log.debug(&quot;操作...&quot;);
                }
            }
        }, &quot;t2&quot;);
        t1.start();
        t2.start();
    }
}
</code></pre>

<p>结果</p>

<pre><code>12:22:06.962 [t2] c.TestDeadLock - lock B
12:22:06.962 [t1] c.TestDeadLock - lock A
</code></pre>

<h4 id="定位死锁">定位死锁</h4>

<ul>
<li>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁：</li>
</ul>

<h5 id="jps">jps</h5>

<p>jps查看所有的java进程</p>

<pre><code>cmd &gt; jps
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8
12320 Jps
22816 KotlinCompileDaemon
33200 TestDeadLock // JVM 进程
11508 Main
28468 Launcher
</code></pre>

<p>查看进程信息</p>

<pre><code>jstack 进程号
</code></pre>

<pre><code>
cmd &gt; jstack 33200
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8
2018-12-29 05:51:40
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.91-b14 mixed mode):
&quot;DestroyJavaVM&quot; #13 prio=5 os_prio=0 tid=0x0000000003525000 nid=0x2f60 waiting on condition 
[0x0000000000000000]
 java.lang.Thread.State: RUNNABLE
&quot;Thread-1&quot; #12 prio=5 os_prio=0 tid=0x000000001eb69000 nid=0xd40 waiting for monitor entry 
[0x000000001f54f000]
 java.lang.Thread.State: BLOCKED (on object monitor)
 at thread.TestDeadLock.lambda$main$1(TestDeadLock.java:28)
 - waiting to lock &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)
 - locked &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)
 at thread.TestDeadLock$$Lambda$2/883049899.run(Unknown Source)
 at java.lang.Thread.run(Thread.java:745)
&quot;Thread-0&quot; #11 prio=5 os_prio=0 tid=0x000000001eb68800 nid=0x1b28 waiting for monitor entry 
[0x000000001f44f000]
 java.lang.Thread.State: BLOCKED (on object monitor)
 at thread.TestDeadLock.lambda$main$0(TestDeadLock.java:15)
 - waiting to lock &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)
 - locked &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)
 at thread.TestDeadLock$$Lambda$1/495053715.run(Unknown Source)
 at java.lang.Thread.run(Thread.java:745)
 
// 略去部分输出
Found one Java-level deadlock:
=============================
&quot;Thread-1&quot;:
 waiting to lock monitor 0x000000000361d378 (object 0x000000076b5bf1c0, a java.lang.Object),
 which is held by &quot;Thread-0&quot;
&quot;Thread-0&quot;:
 waiting to lock monitor 0x000000000361e768 (object 0x000000076b5bf1d0, a java.lang.Object),
 which is held by &quot;Thread-1&quot;
Java stack information for the threads listed above:
===================================================
&quot;Thread-1&quot;:
 at thread.TestDeadLock.lambda$main$1(TestDeadLock.java:28)
 - waiting to lock &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)
 - locked &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)
 at thread.TestDeadLock$$Lambda$2/883049899.run(Unknown Source)
 at java.lang.Thread.run(Thread.java:745)
&quot;Thread-0&quot;:
 at thread.TestDeadLock.lambda$main$0(TestDeadLock.java:15)
 - waiting to lock &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)
 - locked &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)
 at thread.TestDeadLock$$Lambda$1/495053715.run(Unknown Source)
 at java.lang.Thread.run(Thread.java:745)
Found 1 deadlock.
</code></pre>

<ul>
<li>避免死锁要注意加锁顺序</li>
<li>另外如果由于某个线程进入了死循环，导致其它线程一直等待，对于这种情况 linux 下可以通过 top 先定位到CPU 占用高的 Java 进程，再利用 top -Hp 进程id 来定位是哪个线程，最后再用 jstack 排查</li>
</ul>

<h5 id="jconsole">jconsole</h5>

<pre><code>win +r :jconsole
</code></pre>

<p>图形化界面，线程&ndash;&gt;检测死锁：查看死锁</p>

<h3 id="哲学家就餐问题">哲学家就餐问题</h3>

<p><img src="/resources/技术收录/Java/java并发/image-20200420134728979.png" alt="image-20200420134728979" /></p>

<p>有五位哲学家，围坐在圆桌旁。</p>

<ul>
<li>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。</li>
<li>吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。</li>
<li>如果筷子被身边的人拿着，自己就得等待</li>
</ul>

<p>筷子类</p>

<pre><code class="language-java">class Chopstick {
 String name;
 public Chopstick(String name) {
 	this.name = name;
 }
 @Override
 public String toString() {
	return &quot;筷子{&quot; + name + '}';
 }
}
</code></pre>

<p>哲学家类</p>

<pre><code class="language-java">
@Slf4j(topic = &quot;c.Philosopher&quot;)
class Philosopher extends Thread {
    Chopstick left;
    Chopstick right;
    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }
    @Override
    public void run() {
        while (true) {
            //　尝试获得左手筷子
            synchronized (left) {
                // 尝试获得右手筷子
                synchronized (right) {
                    eat();
                }
            }
        }
    }
    Random random = new Random();
    private void eat() {
        log.debug(&quot;eating...&quot;);
        Sleeper.sleep(random.nextInt(5));
    }
}
</code></pre>

<p>就餐</p>

<pre><code class="language-java">Chopstick c1 = new Chopstick(&quot;1&quot;);
Chopstick c2 = new Chopstick(&quot;2&quot;);
Chopstick c3 = new Chopstick(&quot;3&quot;);
Chopstick c4 = new Chopstick(&quot;4&quot;);
Chopstick c5 = new Chopstick(&quot;5&quot;);
new Philosopher(&quot;苏格拉底&quot;, c1, c2).start();
new Philosopher(&quot;柏拉图&quot;, c2, c3).start();
new Philosopher(&quot;亚里士多德&quot;, c3, c4).start();
new Philosopher(&quot;赫拉克利特&quot;, c4, c5).start();
new Philosopher(&quot;阿基米德&quot;, c5, c1).start();
</code></pre>

<p>执行不多会，就执行不下去了</p>

<pre><code>12:33:15.575 [苏格拉底] c.Philosopher - eating...
12:33:15.575 [亚里士多德] c.Philosopher - eating...
12:33:16.580 [阿基米德] c.Philosopher - eating...
12:33:17.580 [阿基米德] c.Philosopher - eating...
// 卡在这里, 不向下运行
</code></pre>

<p>使用 jconsole 检测死锁，发现</p>

<pre><code>-------------------------------------------------------------------------
名称: 阿基米德
状态: cn.itcast.Chopstick@1540e19d (筷子1) 上的BLOCKED, 拥有者: 苏格拉底
总阻止数: 2, 总等待数: 1
堆栈跟踪:
cn.itcast.Philosopher.run(TestDinner.java:48)
 - 已锁定 cn.itcast.Chopstick@6d6f6e28 (筷子5)
-------------------------------------------------------------------------
名称: 苏格拉底
状态: cn.itcast.Chopstick@677327b6 (筷子2) 上的BLOCKED, 拥有者: 柏拉图
总阻止数: 2, 总等待数: 1
堆栈跟踪:
cn.itcast.Philosopher.run(TestDinner.java:48)
 - 已锁定 cn.itcast.Chopstick@1540e19d (筷子1)
-------------------------------------------------------------------------
名称: 柏拉图
状态: cn.itcast.Chopstick@14ae5a5 (筷子3) 上的BLOCKED, 拥有者: 亚里士多德
总阻止数: 2, 总等待数: 0
堆栈跟踪:
cn.itcast.Philosopher.run(TestDinner.java:48)
 - 已锁定 cn.itcast.Chopstick@677327b6 (筷子2)
-------------------------------------------------------------------------
名称: 亚里士多德
状态: cn.itcast.Chopstick@7f31245a (筷子4) 上的BLOCKED, 拥有者: 赫拉克利特
总阻止数: 1, 总等待数: 1
堆栈跟踪:
cn.itcast.Philosopher.run(TestDinner.java:48)
 - 已锁定 cn.itcast.Chopstick@14ae5a5 (筷子3)
-------------------------------------------------------------------------
名称: 赫拉克利特
状态: cn.itcast.Chopstick@6d6f6e28 (筷子5) 上的BLOCKED, 拥有者: 阿基米德
总阻止数: 2, 总等待数: 0
堆栈跟踪:
cn.itcast.Philosopher.run(TestDinner.java:48)
 - 已锁定 cn.itcast.Chopstick@7f31245a (筷子4)
</code></pre>

<p>这种线程没有按预期结束，执行不下去的情况，归类为【活跃性】问题，除了死锁以外，还有活锁和饥饿者两种情况</p>

<p>死锁是由于互相持有对方想要的锁，导致谁都无法继续向下运行，都阻塞住了</p>

<p>活锁是，线程都没有阻塞住，都在使用CPU，都在不断地运行，改变对方地结束条件，导致结束不了</p>

<h3 id="活锁">活锁</h3>

<p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束，例如</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.TestLiveLock&quot;)
public class TestLiveLock {
    static volatile int count = 10;
    static final Object lock = new Object();

    public static void main(String[] args) {
        new Thread(() -&gt; {
            // 期望减到 0 退出循环
            while (count &gt; 0) {
                sleep(0.2);
                count--;
                log.debug(&quot;count: {}&quot;, count);
            }
        }, &quot;t1&quot;).start();
        new Thread(() -&gt; {
            // 期望超过 20 退出循环
            while (count &lt; 20) {
                sleep(0.2);
                count++;
                log.debug(&quot;count: {}&quot;, count);
            }
        }, &quot;t2&quot;).start();
    }
}
</code></pre>

<p>解决办法：增加随机地睡眠时间，避免活锁地产生</p>

<h3 id="饥饿">饥饿</h3>

<p>很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束，饥饿的情况不</p>

<p>易演示，讲读写锁时会涉及饥饿问题</p>

<p>下面我讲一下我遇到的一个线程饥饿的例子，先来看看使用顺序加锁的方式解决之前的死锁问题</p>

<pre><code class="language-mermaid">sequenceDiagram
  # 通过设定参与者(participants)的顺序控制展示模块顺序
  participant 线程1
  participant 线程2
　participant 对象A
　participant 对象B
　线程1--&gt;对象A:尝试获取锁
  note over 线程1,对象A: 拥有锁
  线程2-&gt;对象B:尝试获取锁
　note over 线程2,对象B:拥有锁
　线程1-&gt;对象B:尝试获取锁
　线程2-&gt;对象A:尝试获取锁
</code></pre>

<p>顺序加锁的解决方案</p>

<pre><code class="language-mermaid">sequenceDiagram
  # 通过设定参与者(participants)的顺序控制展示模块顺序
  participant 线程1
  participant 线程2
　participant 对象A
　participant 对象B
　线程1--&gt;对象A:尝试获取锁
  note over 线程1,对象A: 拥有锁
  线程2-&gt;对象A:尝试获取锁
  线程2-&gt;对象A:阻塞
  线程1-&gt;对象B:尝试获取锁
　note over 线程1,对象B:拥有锁
</code></pre>

<pre><code class="language-java">
public class TestDeadLock {
    public static void main(String[] args) {
        Chopstick c1 = new Chopstick(&quot;1&quot;);
        Chopstick c2 = new Chopstick(&quot;2&quot;);
        Chopstick c3 = new Chopstick(&quot;3&quot;);
        Chopstick c4 = new Chopstick(&quot;4&quot;);
        Chopstick c5 = new Chopstick(&quot;5&quot;);
        new Philosopher(&quot;苏格拉底&quot;, c1, c2).start();
        new Philosopher(&quot;柏拉图&quot;, c2, c3).start();
        new Philosopher(&quot;亚里士多德&quot;, c3, c4).start();
        new Philosopher(&quot;赫拉克利特&quot;, c4, c5).start();
        new Philosopher(&quot;阿基米德&quot;, c1, c5).start();
    }
}
@Slf4j(topic = &quot;c.Philosopher&quot;)
class Philosopher extends Thread {
    Chopstick left;
    Chopstick right;
    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }
    @Override
    public void run() {
        while (true) {
            //　尝试获得左手筷子
            synchronized (left) {
                // 尝试获得右手筷子
                synchronized (right) {
                    eat();
                }
            }
        }
    }
    Random random = new Random();
    private void eat() {
        log.debug(&quot;eating...&quot;);
        Sleeper.sleep(0.5);
    }
}
class Chopstick {
    String name;
    public Chopstick(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return &quot;筷子{&quot; + name + '}';
    }
}
</code></pre>

<p>虽然没有死锁，但是阿基米德执行地概率非常低，就是饥饿现象</p>

<h2 id="4-13-reentrantlock">4.13 ReentrantLock</h2>

<p>相对于 synchronized 它具备如下特点</p>

<ul>
<li>可中断</li>
<li>可以设置超时时间（获取锁时获取不到直接进入entryList中等待，死等）</li>
<li>可以设置为公平锁（防止线程饥饿，先进先出）</li>
<li>支持多个条件变量（有多个休息室，waitSet）</li>
</ul>

<p>与 synchronized 一样，都支持可重入(对一个对象进行重复加锁)</p>

<p>synchronized 在关键字的级别保护临界区ReentrantLock在对象的级别保护临界区</p>

<p>基本语法</p>

<pre><code class="language-java">//创建ReentrantLock对象
static ReentrantLock lock = new ReentrantLock();
// 获取锁
reentrantLock.lock();
try {
 // 临界区
} finally {
 // 释放锁
 reentrantLock.unlock();
}
</code></pre>

<h3 id="可重入">可重入</h3>

<p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</p>

<p>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p>

<pre><code class="language-java">static ReentrantLock lock = new ReentrantLock();
public static void main(String[] args) {
 	method1();
}
public static void method1() {
     lock.lock();
     try {
     	log.debug(&quot;execute method1&quot;);
    	method2();
     } finally {
     lock.unlock();
     }
}
public static void method2() {
     lock.lock();
     try {
        log.debug(&quot;execute method2&quot;);
        method3();
     } finally {
        lock.unlock();
     }
}
public static void method3() {
     lock.lock();
     try {
     	log.debug(&quot;execute method3&quot;);
     } finally {
     	lock.unlock();
     }
}
</code></pre>

<p>输出</p>

<pre><code>17:59:11.862 [main] c.TestReentrant - execute method1
17:59:11.865 [main] c.TestReentrant - execute method2
17:59:11.865 [main] c.TestReentrant - execute method3
</code></pre>

<h3 id="可打断">可打断</h3>

<p>示例</p>

<pre><code class="language-java">ReentrantLock lock = new ReentrantLock();
Thread t1 = new Thread(() -&gt; {
    log.debug(&quot;启动...&quot;);
     try {
         // 如果没有竞争那么此方法就会获取Lock对象
         // 如果有竞争进入阻塞队列，可以被其他线程用interrupt方法打断
     	lock.lockInterruptibly();
     } catch (InterruptedException e) {
     	e.printStackTrace();
     	log.debug(&quot;等锁的过程中被打断&quot;);
    	 return;
     }
     try {
     	log.debug(&quot;获得了锁&quot;);
     } finally {
     	lock.unlock();
     }
}, &quot;t1&quot;);
lock.lock();
log.debug(&quot;获得了锁&quot;);
t1.start();
try {
 	sleep(1);
 	t1.interrupt();//打断锁，可以避免死锁地形成
 	log.debug(&quot;执行打断&quot;);
} finally {
 	lock.unlock();
}
</code></pre>

<p>输出</p>

<pre><code>18:02:40.520 [main] c.TestInterrupt - 获得了锁
18:02:40.524 [t1] c.TestInterrupt - 启动... 
18:02:41.530 [main] c.TestInterrupt - 执行打断
java.lang.InterruptedException 
 at 
java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchr
onizer.java:898) 
 at 
java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchron
izer.java:1222) 
 at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335) 
 at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$0(TestInterrupt.java:17) 
 at java.lang.Thread.run(Thread.java:748) 
18:02:41.532 [t1] c.TestInterrupt - 等锁的过程中被打断
</code></pre>

<p>注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断</p>

<pre><code class="language-java">ReentrantLock lock = new ReentrantLock();
Thread t1 = new Thread(() -&gt; {
     log.debug(&quot;启动...&quot;);
     lock.lock();
     try {
     	log.debug(&quot;获得了锁&quot;);
     } finally {
     	lock.unlock();
     }
}, &quot;t1&quot;);
lock.lock();
log.debug(&quot;获得了锁&quot;);
t1.start();
try {
     sleep(1);
     t1.interrupt();
     log.debug(&quot;执行打断&quot;);
     sleep(1);
} finally {
 	log.debug(&quot;释放了锁&quot;);
 	lock.unlock();
}
</code></pre>

<p>输出</p>

<pre><code>18:06:56.261 [main] c.TestInterrupt - 获得了锁
18:06:56.265 [t1] c.TestInterrupt - 启动... 
18:06:57.266 [main] c.TestInterrupt - 执行打断 // 这时 t1 并没有被真正打断, 而是仍继续等待锁
18:06:58.267 [main] c.TestInterrupt - 释放了锁
18:06:58.267 [t1] c.TestInterrupt - 获得了锁
</code></pre>

<h3 id="锁超时">锁超时</h3>

<p>在获取锁的过程中，如果其他线程持有该对象的锁一直没有释放。尝试获得锁的线程也不会死等，只会等待一段时间，如果一段时间超过了，其他线程还没有释放锁，我们就放弃等待，表示此次获取锁失败</p>

<p>立刻失败</p>

<pre><code class="language-java">ReentrantLock lock = new ReentrantLock();
Thread t1 = new Thread(() -&gt; {
    log.debug(&quot;启动...&quot;);
    if (!lock.tryLock()) {
        log.debug(&quot;获取立刻失败，返回&quot;);
        return;
    }
    try {
        log.debug(&quot;获得了锁&quot;);
    } finally {
        lock.unlock();
    }
}, &quot;t1&quot;);
lock.lock();
log.debug(&quot;获得了锁&quot;);
t1.start();
try {
    sleep(2);
} finally {
    lock.unlock();
}
</code></pre>

<p>输出</p>

<pre><code>18:15:02.918 [main] c.TestTimeout - 获得了锁
18:15:02.921 [t1] c.TestTimeout - 启动...
18:15:02.921 [t1] c.TestTimeout - 获取立刻失败，返回
</code></pre>

<p>超时失败</p>

<pre><code class="language-java">ReentrantLock lock = new ReentrantLock();
Thread t1 = new Thread(() -&gt; {
     log.debug(&quot;启动...&quot;);
     try {
         if (!lock.tryLock(1, TimeUnit.SECONDS)) {
            log.debug(&quot;获取等待 1s 后失败，返回&quot;);
            return;
         }
     } catch (InterruptedException e) {
     	e.printStackTrace();
         //支持打断
         log.debug(&quot;获取不到锁&quot;);
         return;
     }
     try {
     	log.debug(&quot;获得了锁&quot;);
     } finally {
     	lock.unlock();
     }
}, &quot;t1&quot;);
lock.lock();
log.debug(&quot;获得了锁&quot;);
t1.start();
try {
 	sleep(2);
} finally {
 	lock.unlock();
}
</code></pre>

<p>输出</p>

<pre><code>18:19:40.537 [main] c.TestTimeout - 获得了锁
18:19:40.544 [t1] c.TestTimeout - 启动... 
18:19:41.547 [t1] c.TestTimeout - 获取等待 1s 后失败，返回
</code></pre>

<p>使用 tryLock 解决哲学家就餐问题</p>

<pre><code class="language-java">class Chopstick extends ReentrantLock {
 String name;
 public Chopstick(String name) {
 this.name = name;
 }
 @Override
 public String toString() {
 return &quot;筷子{&quot; + name + '}';
 }
}
</code></pre>

<pre><code class="language-java">public class Test23 {public static void main(String[] args) {
    Chopstick c1 = new Chopstick(&quot;1&quot;);
    Chopstick c2 = new Chopstick(&quot;2&quot;);
    Chopstick c3 = new Chopstick(&quot;3&quot;);
    Chopstick c4 = new Chopstick(&quot;4&quot;);
    Chopstick c5 = new Chopstick(&quot;5&quot;);
    new Philosopher(&quot;苏格拉底&quot;, c1, c2).start();
    new Philosopher(&quot;柏拉图&quot;, c2, c3).start();
    new Philosopher(&quot;亚里士多德&quot;, c3, c4).start();
    new Philosopher(&quot;赫拉克利特&quot;, c4, c5).start();
    new Philosopher(&quot;阿基米德&quot;, c5, c1).start();
}
}
@Slf4j(topic = &quot;c.Philosopher&quot;)
class Philosopher extends Thread {
    Chopstick left;
    Chopstick right;
    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }
    @Override
    public void run() {
        while (true) {
            //　尝试获得左手筷子
            if(left.tryLock()) {
                try {
                    // 尝试获得右手筷子
                    if(right.tryLock()) {
                        try {
                            eat();
                        } finally {
                            right.unlock();
                        }
                    }
                } finally {
                    left.unlock(); // 释放自己手里的筷子
                }
            }
        }
    }
    Random random = new Random();
    private void eat() {
        log.debug(&quot;eating...&quot;);
        Sleeper.sleep(0.5);
    }
}
class Chopstick extends ReentrantLock {
    String name;
    public Chopstick(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return &quot;筷子{&quot; + name + '}';
    }
}
</code></pre>

<h3 id="公平锁">公平锁</h3>

<p>synchronized是一种不公平锁，当一个线程获得锁，其他线程就得进入等待队列中去等待，当锁的持有者释放锁的时候，这些线程就会一拥而上，谁先抢到锁谁就先执行。不会按照进入阻塞队列中的顺序先来先得。</p>

<p>再等待地时候是按照先到先得地顺序进行排队等候地，而非公平锁是随机选择在等待地锁</p>

<p>ReentrantLock 默认是不公平的</p>

<pre><code class="language-java">ReentrantLock lock = new ReentrantLock(false);
lock.lock();
for (int i = 0; i &lt; 500; i++) {
 new Thread(() -&gt; {
 lock.lock();
 try {
 System.out.println(Thread.currentThread().getName() + &quot; running...&quot;);
 } finally {
 lock.unlock();
 }
 }, &quot;t&quot; + i).start();
}
// 1s 之后去争抢锁
Thread.sleep(1000);
new Thread(() -&gt; {
 System.out.println(Thread.currentThread().getName() + &quot; start...&quot;);
 lock.lock();
 try {
 System.out.println(Thread.currentThread().getName() + &quot; running...&quot;);
 } finally {
 lock.unlock();
 }
}, &quot;强行插入&quot;).start();
lock.unlock();
</code></pre>

<p>强行插入，有机会在中间输出</p>

<blockquote>
<p>注意：该实验不一定总能复现</p>
</blockquote>

<pre><code>t39 running...
t40 running...
t41 running...
t42 running...
t43 running...
强行插入 start...
强行插入 running...
t44 running...
t45 running...
t46 running...
t47 running...
t49 running...
</code></pre>

<p>改为公平锁后</p>

<pre><code>ReentrantLock lock = new ReentrantLock(true);
</code></pre>

<p>强行插入，总是在最后输出</p>

<pre><code>t465 running...
t464 running...
t477 running...
t442 running...
t468 running...
t493 running...
t482 running...
t485 running...
t481 running...
强行插入 running...
</code></pre>

<p><strong>公平锁一般没有必要，会降低并发度，后面分析原理时会讲解</strong></p>

<h3 id="条件变量">条件变量</h3>

<p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待（waitSet就是synchronized中的条件变量，是单一的。就意味着只有一间休息室，要唤醒时，要么随机，要么全部唤醒）</p>

<p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比</p>

<ul>
<li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li>
<li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤
醒</li>
</ul>

<p>使用要点：</p>

<blockquote>
<ul>
<li>await 前需要获得锁</li>
<li>await 执行后，会释放锁，进入 conditionObject 等待</li>
<li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li>
<li>竞争 lock 锁成功后，从 await 后继续执行</li>
</ul>
</blockquote>

<p>例子：</p>

<pre><code class="language-java">
@Slf4j(topic = &quot;c.Test24&quot;)
public class Test24 {
    static final Object room = new Object();
    static boolean hasCigarette = false;
    static boolean hasTakeout = false;
    static ReentrantLock ROOM = new ReentrantLock();
    // 等待烟的休息室
    static Condition waitCigaretteSet = ROOM.newCondition();
    // 等外卖的休息室
    static Condition waitTakeoutSet = ROOM.newCondition();

    public static void main(String[] args) {


        new Thread(() -&gt; {
            ROOM.lock();
            try {
                log.debug(&quot;有烟没？[{}]&quot;, hasCigarette);
                while (!hasCigarette) {
                    log.debug(&quot;没烟，先歇会！&quot;);
                    try {
                        waitCigaretteSet.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug(&quot;可以开始干活了&quot;);
            } finally {
                ROOM.unlock();
            }
        }, &quot;小南&quot;).start();

        new Thread(() -&gt; {
            ROOM.lock();
            try {
                log.debug(&quot;外卖送到没？[{}]&quot;, hasTakeout);
                while (!hasTakeout) {
                    log.debug(&quot;没外卖，先歇会！&quot;);
                    try {
                        waitTakeoutSet.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug(&quot;可以开始干活了&quot;);
            } finally {
                ROOM.unlock();
            }
        }, &quot;小女&quot;).start();

        sleep(1);
        new Thread(() -&gt; {
            ROOM.lock();
            try {
                hasTakeout = true;
                waitTakeoutSet.signal();
            } finally {
                ROOM.unlock();
            }
        }, &quot;送外卖的&quot;).start();

        sleep(1);

        new Thread(() -&gt; {
            ROOM.lock();
            try {
                hasCigarette = true;
                waitCigaretteSet.signal();
            } finally {
                ROOM.unlock();
            }
        }, &quot;送烟的&quot;).start();
    }

}

</code></pre>

<p>输出</p>

<pre><code>10:41:08.694 c.Test24 [小南] - 有烟没？[false]
10:41:08.698 c.Test24 [小南] - 没烟，先歇会！
10:41:08.698 c.Test24 [小女] - 外卖送到没？[false]
10:41:08.698 c.Test24 [小女] - 没外卖，先歇会！
10:41:09.700 c.Test24 [小女] - 可以开始干活了
10:41:10.713 c.Test24 [小南] - 可以开始干活了
</code></pre>

<h3 id="同步模式之顺序控制">* 同步模式之顺序控制</h3>

<h2 id="本章小结-1">本章小结</h2>

<p>本章我们需要重点掌握的是</p>

<ul>
<li>分析多线程访问共享资源时，哪些代码片段属于临界区</li>
<li>使用 synchronized 互斥解决临界区的线程安全问题

<ul>
<li>掌握 synchronized 锁对象语法</li>
<li>掌握 synchronzied 加载成员方法和静态方法语法</li>
<li>掌握 wait/notify 同步方法</li>
</ul></li>
<li>使用 lock 互斥解决临界区的线程安全问题

<ul>
<li>掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量</li>
</ul></li>
<li>学会分析变量的线程安全性、掌握常见线程安全类的使用</li>
<li>了解线程活跃性问题：死锁、活锁、饥饿</li>
<li>应用方面

<ul>
<li>互斥：使用 synchronized 或 Lock 达到共享资源互斥效果</li>
<li>同步：使用 wait/notify 或 Lock 的条件变量来达到线程间通信效果</li>
</ul></li>
<li>原理方面

<ul>
<li>monitor、synchronized 、wait/notify 原理</li>
<li>synchronized 进阶原理</li>
<li>park &amp; unpark 原理</li>
</ul></li>
<li>模式方面

<ul>
<li>同步模式之保护性暂停</li>
<li>异步模式之生产者消费者</li>
<li>同步模式之顺序控制</li>
</ul></li>
</ul>

<h1 id="5-共享模型之内存">5. 共享模型之内存</h1>

<p>本章内容</p>

<p>上一章讲解的 <strong>Monitor</strong> 主要关注的是访问共享变量时，保证临界区代码的<strong>原子性</strong></p>

<p>这一章我们进一步深入学习共享变量在多线程间的【<strong>可见性</strong>】问题与多条指令执行时的【<strong>有序性</strong>】问题</p>

<h2 id="5-1-java-内存模型">5.1 Java 内存模型</h2>

<p>JMM 即 Java Memory Model，它定义了主存（所有线程都共享的数据：静态成员变量，成员变量等）、工作内存（每个线程私有的数据：局部变量等）抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。（为了简化Java程序员不要直接面对底层这些复杂的内存管理）</p>

<p>JMM 体现在以下几个方面</p>

<pre><code>原子性 - 保证指令不会受到线程上下文切换的影响
可见性 - 保证指令不会受 cpu 缓存的影响
有序性 - 保证指令不会受 cpu 指令并行优化的影响
</code></pre>

<h2 id="5-2-可见性">5.2 可见性</h2>

<p>退不出的循环</p>

<p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p>

<pre><code class="language-java">static boolean run = true;
public static void main(String[] args) throws InterruptedException {
 Thread t = new Thread(()-&gt;{
 while(run){
 	// ....
 }
 });
 t.start();
 sleep(1);
 run = false; // 线程t不会如预想的停下来
}
</code></pre>

<p>为什么呢？分析一下：</p>

<ol>
<li><p>初始状态， t 线程刚开始从主内存（所有共享信息存储的位置）读取了 run 的值到工作内存（每个线程的私有 信息存储的位置）。</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200420145244825.png" alt="image-20200420145244825" /></p></li>
</ol>

<p>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200420145309010.png" alt="image-20200420145309010" /></p>

<p>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量
的值，结果永远是旧值</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200420145333934.png" alt="image-20200420145333934" /></p>

<h3 id="解决方法">解决方法</h3>

<p>volatile（易变关键字：不能从缓存中进行读取了，每次都要从主内存中读取变量的最新值）</p>

<pre><code class="language-java">
@Slf4j(topic = &quot;c.Test32&quot;)
public class Test32 {
    // 易变
    volatile static boolean run = true;

    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(()-&gt;{
            while(true){
                    if(!run) {
                        break;
                    }
            }
        });
        t.start();

        sleep(1);
            run = false; // 线程t不会如预想的停下来
    }
}

</code></pre>

<p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p>

<p>还可以使用synchronized保证</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test32&quot;)
public class Test32 {
    // 易变
    static boolean run = true;
    final static Object lock = new Object();
    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(()-&gt;{
            while(true){
                synchronized (lock){
                    if(!run) {
                        break;
                    }
                }
            }
        });
        t.start();
        sleep(1);
        synchronized (lock){
            run = false; // 线程t不会如预想的停下来
        }
    }
}
</code></pre>

<h3 id="可见性-vs-原子性">可见性 vs 原子性</h3>

<p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可
见， 不能保证原子性，仅用在一个写线程，多个读线程的情况：</p>

<p>上例从字节码理解是这样的：</p>

<pre><code>getstatic run // 线程 t 获取 run true
getstatic run // 线程 t 获取 run true
getstatic run // 线程 t 获取 run true
getstatic run // 线程 t 获取 run true
putstatic run // 线程 main 修改 run 为 false， 仅此一次
getstatic run // 线程 t 获取 run false
</code></pre>

<p>比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i&ndash; ，volatile只能保证看到最新值，不能解决指令交错</p>

<pre><code>// 假设i的初始值为 0
getstatic i // 线程2-获取静态变量i的值 线程内i=0

getstatic i // 线程1-获取静态变量i的值 线程内i=0
iconst_1 // 线程1-准备常量 1
iadd // 线程1-自增 线程内i=1
putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1

iconst_1 // 线程2-准备常量 1
isub // 线程2-自减 线程内i=-1
putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1
</code></pre>

<blockquote>
<p>注意 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是
synchronized 是属于重量级操作，性能相对更低</p>

<p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到
对 run 变量的修改了，想一想为什么？</p>
</blockquote>

<p>System.out.println()源码</p>

<pre><code class="language-java">    public void println(String x) {
        synchronized (this) {
            print(x);
            newLine();
        }
    }
</code></pre>

<p>可以发现println语句中有一个上锁的操作：</p>

<p>通过查资料发现，在使用了synchronized上锁这个操作后线程会做以下操作：</p>

<p>　　1.获得同步锁</p>

<p>　　2.清空工作内存</p>

<p>　　3.从主内存中拷贝对象副本到本地内存</p>

<p>　　4.执行代码（打印语句或加加操作）</p>

<p>　　5.刷新主内存数据</p>

<p>　　6.释放同步锁</p>

<p>这也就是System.out.println()为何会影响内存可见性的原因了。</p>

<h3 id="原理之-cpu-缓存结构">* 原理之 CPU 缓存结构</h3>

<ul>
<li><p>模式之两阶段终止</p></li>

<li><p>模式之 Balking</p></li>
</ul>

<h2 id="5-3-有序性">5.3 有序性</h2>

<p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p>

<pre><code class="language-java">static int i;
static int j;
// 在某个线程内执行如下赋值操作
i = ...; 
j = ...;
</code></pre>

<p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是</p>

<pre><code>i = ...; 
j = ...;
</code></pre>

<p>也可以是</p>

<pre><code>j = ...;
i = ...;
</code></pre>

<p>这种特性称之为『<strong>指令重排</strong>』，多线程下『指令重排』会影响正确性。为什么要有重排指令这项优化呢？从 CPU</p>

<p>执行指令的原理来理解一下吧</p>

<h3 id="原理之指令级并行">* 原理之指令级并行</h3>

<h3 id="诡异的结果">诡异的结果</h3>

<pre><code class="language-java">int num = 0 ;
boolean ready = false;
// 线程1 执行此方法
public void actor1(I_Result r) {
 if(ready) {
 	r.r1 = num + num;
 } else {
 	r.r1 = 1;
 }
}
// 线程2 执行此方法
public void actor2(I_Result r) { 
 	num = 2;
 	ready = true; 
}
</code></pre>

<p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？</p>

<p>有同学这么分析</p>

<p>情况 1 ：线程 1 先执行，这时 ready = false，所以进入 else 分支结果为 1</p>

<p>情况 2 ：线程 2 先执行 num = 2，但没来得及执行 ready = true，线程 1 执行，还是进入 else 分支，结果为 1</p>

<p>情况 3 ：线程 2 执行到 ready = true，线程 1 执行，这回进入 if 分支，结果为 4 （因为 num 已经执行过了）</p>

<p>但我告诉你，结果还有可能是 0，信不信吧！</p>

<p>这种情况下是：线程 2 执行 ready = true，切换到线程 1 ，进入 if 分支，相加为 0 ，再切回线程 2 执行 num = 2</p>

<p>相信很多人已经晕了</p>

<p>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现：</p>

<p>借助 java 并发压测工具 jcstress <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p>

<pre><code>mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jcstress -
DarchetypeArtifactId=jcstress-java-test-archetype -DarchetypeVersion=0.5 -DgroupId=cn.itcast -
DartifactId=ordering -Dversion=1.0
</code></pre>

<p>创建 maven 项目，提供如下测试类</p>

<pre><code class="language-java">
@JCStressTest
@Outcome(id = {&quot;1&quot;, &quot;4&quot;}, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)
@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)
@State
public class ConcurrencyTest {

    int num = 0;
    boolean ready = false;
    @Actor
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }

    @Actor
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }

}
</code></pre>

<p>执行</p>

<pre><code>mvn clean install
java -jar target/jcstress.jar
</code></pre>

<p>会输出我们感兴趣的结果，摘录其中一次结果：</p>

<pre><code>*** INTERESTING tests
Some interesting behaviors observed. This is for the plain curiosity.
2 matching test results.
[OK] test.ConcurrencyTest
(JVM args: [-XX:-TieredCompilation])
Observed state Occurrences Expectation Interpretation
0 1,729 ACCEPTABLE_INTERESTING !!!!
1 42,617,915 ACCEPTABLE ok
4 5,146,627 ACCEPTABLE ok
[OK] test.ConcurrencyTest
(JVM args: [])
Observed state Occurrences Expectation Interpretation
0 1,652 ACCEPTABLE_INTERESTING !!!!
1 46,460,657 ACCEPTABLE ok
4 4,571,072 ACCEPTABLE ok
</code></pre>

<p>可以看到，出现结果为 0 的情况有 638 次，虽然次数相对很少，但毕竟是出现了。</p>

<h4 id="解决方法-1">解决方法</h4>

<p>volatile 修饰的变量，可以禁用指令重排</p>

<pre><code class="language-java">
@JCStressTest
@Outcome(id = {&quot;1&quot;, &quot;4&quot;}, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)
@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)
@State
public class ConcurrencyTest {

    int num = 0;
    volatile boolean ready = false;//保证之前的代码不会重新排序
    @Actor
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }

    @Actor
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }

}
</code></pre>

<p>结果为：</p>

<pre><code>*** INTERESTING tests
Some interesting behaviors observed. This is for the plain curiosity.
0 matching test results.
</code></pre>

<h3 id="原理之-volatile">* 原理之 volatile</h3>

<h3 id="happens-before">happens-before</h3>

<p>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛
开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p>

<h4 id="规则1">规则1</h4>

<p>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</p>

<pre><code class="language-java">static int x;
static Object m = new Object();
new Thread(()-&gt;{
    synchronized(m) {
    	x = 10 ;//写
    }
},&quot;t1&quot;).start();
new Thread(()-&gt;{
     synchronized(m) {
     	System.out.println(x);//读
     }
},&quot;t2&quot;).start();
</code></pre>

<h4 id="规则2">规则2</h4>

<p>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</p>

<pre><code class="language-java">volatile static int x;
new Thread(()-&gt;{
 	x = 10;
},&quot;t1&quot;).start();
new Thread(()-&gt;{
 	System.out.println(x);
},&quot;t2&quot;).start();
</code></pre>

<h4 id="规则3">规则3</h4>

<p>线程 start 前对变量的写，对该线程开始后对该变量的读可见</p>

<pre><code class="language-java">static int x;
x = 10;
new Thread(()-&gt;{
 	System.out.println(x);
},&quot;t2&quot;).start();
</code></pre>

<h4 id="规则4">规则4</h4>

<p>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p>

<pre><code class="language-java">static int x;
Thread t1 = new Thread(()-&gt;{
 	x = 10;
},&quot;t1&quot;);
t1.start();
t1.join();
System.out.println(x);
</code></pre>

<h4 id="规则5">规则5</h4>

<p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</p>

<pre><code class="language-java">static int x;
public static void main(String[] args) {
     Thread t2 = new Thread(()-&gt;{
         while(true) {
             if(Thread.currentThread().isInterrupted()) {
                 System.out.println(x);
                 break;
             }
         }
     },&quot;t2&quot;);
     t2.start();
     new Thread(()-&gt;{
         sleep(1);
         x = 10;
         t2.interrupt();
     },&quot;t1&quot;).start();
     while(!t2.isInterrupted()) {
        Thread.yield();
     }
     System.out.println(x);
}
</code></pre>

<h4 id="规则6">规则6</h4>

<p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p>

<h4 id="规则7">规则7</h4>

<p>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子</p>

<pre><code class="language-java">volatile static int x;
static int y;
new Thread(()-&gt;{ 
     y = 10;
     x = 20;//写屏障之前都有序
    //写屏障
},&quot;t1&quot;).start();
new Thread(()-&gt;{
     // x=20 对 t2 可见, 同时 y=10 也对 t2 可见
     System.out.println(x); 
},&quot;t2&quot;).start();
</code></pre>

<p>变量都是指成员变量或静态成员变量</p>

<h2 id="习题">习题</h2>

<h3 id="balking-模式习题">balking 模式习题</h3>

<p>希望 doInit() 方法仅被调用一次，下面的实现是否有问题，为什么？</p>

<p>有问题，</p>

<pre><code class="language-java">public class TestVolatile {
 volatile boolean initialized = false;
 void init() {
     if (initialized) { 
     	return;
     } 
 	doInit();//t1执行到这就进行上下文切换
 	initialized = true;
 }
 private void doInit() {
 }
}
</code></pre>

<p>解决办法</p>

<pre><code class="language-java">public class TestVolatile {
boolean initialized = false;
static final Object lock = new Object();
 void init() {
     synchronized(lock){
         if (initialized) { 
     		return;
         } 
        doInit();
        initialized = true;  
     }  
 }
 private void doInit() {
 }
}
</code></pre>

<h3 id="线程安全单例习题">线程安全单例习题</h3>

<p>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用getInstance）时的线程安全，并思考注释中的问题</p>

<blockquote>
<p>饿汉式：类加载就会导致该单实例对象被创建
懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p>
</blockquote>

<h4 id="实现-1">实现 1</h4>

<pre><code class="language-java">// 问题1：为什么加 final
/*怕将来它有子类，字类不适当的覆盖了父类中的方法，破坏了他的单例*/
// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例 增加readResolve方法
public final class Singleton implements Serializable {
 // 问题3：为什么设置为私有? 是否能防止反射创建新的实例?
 /*要设置为其他的，那么别的类就可以无限的创建它的对象；就不能是单例了
 不能防止反射创建新的实例，反射可以暴力获取私有方法
 */
 private Singleton() {}
 // 问题4：这样初始化是否能保证单例对象创建时的线程安全?
 /*能 静态成员的初始化操作是在类加载前完成的；类加载的阶段由jvm保证代码的线程安全性
 类加载阶段，对这些静态变量进行赋值都是线程安全的，可以相信jvm
 */
 private static final Singleton INSTANCE = new Singleton();
 // 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由
 /*用方法可以提供更好的封装性，内部实现一些懒惰的初始化；直接提供静态成员变量将来就不能改进成懒惰的初始化方式了，然后还可以创建单例对象时进行更好的控制；还可以提供泛型的支持，用成员变量没法提供泛型的支持
 */
 public static Singleton getInstance() {
 	return INSTANCE;
 }
 /*解决问题2：防止反序列化破坏单例
 在反序列化的过程中一旦发现readResolve返回了一个对象，就会采用你返回的对象；不是反序列化字节码生成的对象；把readResolve方法返回的对象当作反序列化的结果；保证了我们即使使用的是反序列化，返回的也是同一个对象，而不是新的对象
 */
 public Object readResolve() {
 	 return INSTANCE;
 }
}
</code></pre>

<h4 id="实现-2">实现 2</h4>

<pre><code class="language-java">// 问题1：枚举单例是如何限制实例个数的
/*枚举中定义的枚举对象，你定义几个，将来就有几个对象；相当于是枚举类的静态成员变量*/
// 问题2：枚举单例在创建时是否有并发问题
/*没有，因为它也是静态成员变量，它的线程安全性也是在在类加载阶段完成的，所以他不会有多线程的并发问题，创建时是线程安全的*/
// 问题3：枚举单例能否被反射破坏单例
/*不能：*/
// 问题4：枚举单例能否被反序列化破坏单例
/*枚举类默认都是实现了序列化接口的，可以被序列化和反序列化的；但是枚举类在设计的时候就考虑到了序列化破坏单例的情况，所以它可以避免反序列化时出现问题，无需自己做额外的操作*/
// 问题5：枚举单例属于懒汉式还是饿汉式
/**饿汉式的：类的静态成员对象在类加载的时候就进行创建了，也是饿汉式的*/
// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做
/*加构造方法*/
enum Singleton { 
 INSTANCE; 
}
</code></pre>

<p>反编译后</p>

<pre><code class="language-java">final enum cn/itcast/test/Singleton extends java/lang/Enum {
//可以发现它就是枚举类中的一个静态的成员变量
public final static enum Lcn/itcast/test/Singleton; INSTANCE

</code></pre>

<p>枚举的父类Enum实现了Serializable接口</p>

<pre><code class="language-java">public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;
        implements Comparable&lt;E&gt;, Serializable {
</code></pre>

<p><strong>下面对单件模式的懒汉式与饿汉式进行简单介绍：</strong>
1、饿汉式：在程序启动或单件模式类被加载的时候，单件模式实例就已经被创建。
2、懒汉式：当程序第一次访问单件模式实例时才进行创建。</p>

<h4 id="实现-3">实现 3 ：</h4>

<pre><code class="language-java">public final class Singleton {
     private Singleton() { }
    //一开始静态成员变量并没有赋值，在你第一次getInstance才去创建这个对象
     private static Singleton INSTANCE = null;
     // 分析这里的线程安全, 并说明有什么缺点
    /*是线程安全的：对Singleton类进行加锁，类和静态成员变量是一一对应的，对Singleton类加锁就相当于对静态成员变量INSTANCE进行加锁
    一定不能将synchronized加在静态成员变量INSTANCE上，首先INSTANCE不是final的，他要重新赋一次值；还有它的值可能是null，null上不能加任何的synchronized：synchronized要找到一个对象，根据对象分配Monitor锁；null没有关联的对象，所以不行；synchronized不能锁在INSTANCE这个静态成员变量，要锁在一个相对不变的对象上
    
    锁住的对象有点大，第一次调用getInstance的时候要加锁，后面这个对象创建好了，第二次，第三次后续的调用仍然要加锁，导致性能较低
    */
     public static synchronized Singleton getInstance() {
         if( INSTANCE != null ){
            return INSTANCE;
         } 
         INSTANCE = new Singleton();
         return INSTANCE;
     }
}
</code></pre>

<p>懒汉式单例</p>

<h4 id="实现-4-dcl">实现 4 ：DCL</h4>

<p>double-checked locking 原理</p>

<p>构造过程是线程安全的</p>

<pre><code class="language-java">public final class Singleton {
     private Singleton() { }
     // 问题1：解释为什么要加 volatile ?
    /*synchronized代码块中指令还是会重排序的，构造方法的指令和赋值指令还是会重排序的
    重排序的话，第二个线程线程二如果在进synchronized代码块之前获取INSTANCE对象引用的时候就有可能是这样做的：先赋值操作，再构造方法，在synchronized代码块外面的线程来讲，获取的引用，可能还没有调用构造方法，因此就可能造成拿到的是一个不完整的对象就会有问题，因此要保证指令不要发生重排序；需要在INSTANCE前面加上volatile，防止在synchronized代码块内发生重排序；就不会将赋值方法放到构造方法的后面去；其他线程即使在synchronized代码块外拿到的引用肯定是已经调用完构造方法之后的引用，就不会有问题。
    */
     private static volatile Singleton INSTANCE = null;
     // 问题2：对比实现3, 说出这样做的意义 
    /**
    当第一调用getInstance时INSTANCE是null进入下面的代码块，创建INSTANCE实例，后续的第二，第三次调用getInstance发现INSTANCE不为空直接就返回这个对象了；if判断没有加synchronized代码块性能上比较优越些
    */
     public static Singleton getInstance() {
         if (INSTANCE != null) { 
         	return INSTANCE;
         }
         synchronized (Singleton.class) { //(1)
             // 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗
             /*为了防止首次访问getInstance创建INSTANCE对象时多个线程并发的问题*/
             if (INSTANCE != null) { //(2)
             	return INSTANCE;
             }
             INSTANCE = new Singleton(); //(3)
             return INSTANCE;
         } 
     }
}
</code></pre>

<p>问题三</p>

<p>比如说线程一执行到(1)的位置它发现INSTANCE对象是null，就锁住了Singleton，进入下面的代码执行，当它执行到(2)的时候发现INSTANCE还是null就继续向下执行，执行到(3)的位置去创建INSTANCE对象；</p>

<p>此时假设第二个线程开始执行，与此同时线程一在(3)的位置还没有赋值成功，线程二发现INSTANCE对象为空执行到(1)的位置，在(1)的位置阻塞着；等线程一在(3)的位置执行完了，锁释放开，INSTANCE变量也赋好值了；线程二就能继续向下执行，如果没有(2)位置的判断，线程2就会直接执行(3)位置的代码，又会创建一个INSTANCE对象，并且会覆盖掉线程一创建的INSTANCE实例；</p>

<p>所以(2)位置的第二次判断是为了防止第一次并发访问时的单例对象不要被重复创建</p>

<h4 id="实现-5">实现 5 ：</h4>

<p><strong>推荐</strong></p>

<pre><code class="language-java">public final class Singleton {
 private Singleton() { }
 // 问题1：属于懒汉式还是饿汉式
    /*采用的是静态的内部类，静态内部类的目的是为了完成懒汉式的创建
类加载本身就是懒惰的，类总是在第一次被用到时才会触发类加载动作，如果只是用到外面的Singleton类，而没有使用getInstance方法，就不会触发内部的LazyHolder类的类加载方法，既然LazyHolder类的类加载动作没有被触发，那么LazyHolder中的静态成员变量也不会进行初始化操作；所以当你使用getInstance方法是才会进行LazyHolder类的类加载动作，才会对LazyHolder类中的静态变量进行初始化操作，所以这种操作是懒汉式的
    */
 private static class LazyHolder {
 	static final Singleton INSTANCE = new Singleton();
 }
 // 问题2：在创建时是否有并发问题
    /*没有：类加载时对静态成员变量的赋值操作是由JVM来保证它的线程安全性，不用担心他的线程安全性*/
 public static Singleton getInstance() {
 	return LazyHolder.INSTANCE;
 }
}
</code></pre>

<h2 id="本章小结-2">本章小结</h2>

<p>都是由于java虚拟机进行的一些优化造成的多线程下的问题</p>

<p>本章重点讲解了 JMM 中的</p>

<ul>
<li>可见性 - 由 JVM 缓存优化引起</li>

<li><p>有序性 - 由 JVM 指令重排序优化引起</p></li>

<li><p>happens-before 规则</p></li>

<li><p>原理方面</p>

<ul>
<li>CPU 指令并行</li>
<li>volatile</li>
</ul></li>

<li><p>模式方面</p>

<ul>
<li>两阶段终止模式的 volatile 改进</li>
<li>同步模式之 balking</li>
</ul></li>
</ul>

<h1 id="6-共享模型之无锁">6. 共享模型之无锁</h1>

<h2 id="本章内容-1">本章内容</h2>

<ul>
<li>CAS 与 volatile</li>
<li>原子整数</li>
<li>原子引用</li>
<li>原子累加器</li>
<li>Unsafe</li>
</ul>

<h2 id="6-1-问题提出">6.1 问题提出</h2>

<p>有如下需求，保证 account.withdraw 取款方法的线程安全</p>

<pre><code class="language-java">interface Account {
     // 获取余额
     Integer getBalance();
     // 取款
     void withdraw(Integer amount);
     /**
     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作
     * 如果初始余额为 10000 那么正确的结果应当是 0
     */
     static void demo(Account account) {
         List&lt;Thread&gt; ts = new ArrayList&lt;&gt;();
         long start = System.nanoTime();
         for (int i = 0; i &lt; 1000; i++) {
             ts.add(new Thread(() -&gt; {
             	account.withdraw(10);
             }));
         }
         ts.forEach(Thread::start);
         ts.forEach(t -&gt; {
             try {
             	t.join();
             } catch (InterruptedException e) {
             	e.printStackTrace();
             }
         });
         long end = System.nanoTime();
         System.out.println(account.getBalance()+ &quot; cost: &quot; + (end-start)/1000_000 + &quot; ms&quot;);
     }
}
</code></pre>

<p>原有实现并不是线程安全的</p>

<pre><code class="language-java">class AccountUnsafe implements Account {
 	private Integer balance;
     public AccountUnsafe(Integer balance) {
        this.balance = balance;
     }
     @Override
     public Integer getBalance() {
        return balance;
     }
     @Override
     public void withdraw(Integer amount) {//临界区，会有多个线程的读写操作
        balance -= amount;
     }
}
</code></pre>

<p>执行测试代码</p>

<pre><code class="language-java">public static void main(String[] args) {
 	Account.demo(new AccountUnsafe(10000));
}
</code></pre>

<p>某次的执行结果</p>

<pre><code class="language-java">330 cost: 306 ms
</code></pre>

<h3 id="为什么不安全">为什么不安全</h3>

<p>withdraw 方法</p>

<p>对应的字节码</p>

<pre><code>ALOAD 0 // &lt;- this
ALOAD 0
GETFIELD cn/itcast/AccountUnsafe.balance : Ljava/lang/Integer; // &lt;- this.balance
INVOKEVIRTUAL java/lang/Integer.intValue ()I // 拆箱
ALOAD 1 // &lt;- amount
INVOKEVIRTUAL java/lang/Integer.intValue ()I // 拆箱
ISUB // 减法
INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer; // 结果装箱
PUTFIELD cn/itcast/AccountUnsafe.balance : Ljava/lang/Integer; // -&gt; this.balance
</code></pre>

<p>多线程执行流程</p>

<pre><code>ALOAD 0 // thread-0 &lt;- this 
ALOAD 0 
GETFIELD cn/itcast/AccountUnsafe.balance // thread-0 &lt;- this.balance 
INVOKEVIRTUAL java/lang/Integer.intValue // thread-0 拆箱
ALOAD 1 // thread-0 &lt;- amount 
INVOKEVIRTUAL java/lang/Integer.intValue // thread-0 拆箱
ISUB // thread-0 减法
INVOKESTATIC java/lang/Integer.valueOf // thread-0 结果装箱
PUTFIELD cn/itcast/AccountUnsafe.balance // thread-0 -&gt; this.balance 
 
 
ALOAD 0 // thread-1 &lt;- this 
ALOAD 0 
GETFIELD cn/itcast/AccountUnsafe.balance // thread-1 &lt;- this.balance 
INVOKEVIRTUAL java/lang/Integer.intValue // thread-1 拆箱
ALOAD 1 // thread-1 &lt;- amount 
INVOKEVIRTUAL java/lang/Integer.intValue // thread-1 拆箱
ISUB // thread-1 减法
INVOKESTATIC java/lang/Integer.valueOf // thread-1 结果装箱
PUTFIELD cn/itcast/AccountUnsafe.balance // thread-1 -&gt; this.balance
</code></pre>

<ul>
<li>单核的指令交错</li>
<li>多核的指令交错</li>
</ul>

<h3 id="解决思路-锁">解决思路-锁</h3>

<p>首先想到的是给 Account 对象加锁</p>

<pre><code class="language-java">class AccountUnsafe implements Account {
     private Integer balance;
     public AccountUnsafe(Integer balance) {
     	this.balance = balance;
     }
     @Override
     public synchronized Integer getBalance() {
     	return balance;
     }
     @Override
     public synchronized void withdraw(Integer amount) {
     	balance -= amount;
     }
}
</code></pre>

<p>结果为</p>

<pre><code>0 cost: 399 ms
</code></pre>

<h3 id="解决思路-无锁">解决思路-无锁</h3>

<pre><code class="language-java">class AccountSafe implements Account {
     private AtomicInteger balance;
     public AccountSafe(Integer balance) {
     	this.balance = new AtomicInteger(balance);
     }
     @Override
     public Integer getBalance() {
     	return balance.get();
     }
     @Override
     public void withdraw(Integer amount) {
         while (true) {
             //获取余额的最新值
            int prev = balance.get();
             //修改后的余额
            int next = prev - amount;
             //同步到主存中
            if (balance.compareAndSet(prev, next)) {
                break;
            }
         }
         // 可以简化为下面的方法
         // balance.addAndGet(-1 * amount);
     }
}
</code></pre>

<p>执行测试代码</p>

<pre><code class="language-java">public static void main(String[] args) {
    Account.demo(new AccountSafe(10000));
}
</code></pre>

<p>某次的执行结果</p>

<pre><code>0 cost: 302 ms
</code></pre>

<h2 id="6-2-cas-与-volatile">6.2 CAS 与 volatile</h2>

<p>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p>

<pre><code class="language-java">public void withdraw(Integer amount) {
    // 需要不断尝试，直到成功为止
    while (true) {
        // 比如拿到了旧值 1000
        int prev = balance.get();
        // 在这个基础上 1000-10 = 990
        int next = prev - amount;
        /*
         compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值
         - 不一致了，next 作废，返回 false 表示失败
         比如，别的线程已经做了减法，当前值已经被减成了 990
         那么本线程的这次 990 就作废了，进入 while 下次循环重试
         - 一致，以 next 设置为新值，返回 true 表示成功
         比较并设置值(cas：方法名缩写)
         */
        if (balance.compareAndSet(prev, next)) {
            break;
        }
    }
}
</code></pre>

<p>其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</p>

<pre><code class="language-mermaid">sequenceDiagram
  # 通过设定参与者(participants)的顺序控制展示模块顺序
  participant 线程1
  participant Account对象
　participant 线程2
　线程1-&gt;&gt;Account对象:获取余额100
　线程1-&gt;&gt;线程1:减10=90
　线程2--&gt;&gt;Account对象:已经修改为90了
　线程1-&gt;&gt;Account对象:cas(100,90)
　线程1-&gt;&gt;Account对象:获取余额90
　线程1-&gt;&gt;线程1:减10=80
　线程2--&gt;&gt;Account对象:已经修改为80了
　线程1-&gt;&gt;Account对象:cas(90,80)
　线程1-&gt;&gt;Account对象:获取余额80
　线程1-&gt;&gt;线程1:减10=70
　线程1-&gt;&gt;Account对象:cas(80,70)
</code></pre>

<h3 id="注意-1">注意</h3>

<blockquote>
<p>其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交
换】的原子性。</p>

<p>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再
开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子
的。</p>
</blockquote>

<h3 id="慢动作分析">慢动作分析</h3>

<pre><code class="language-java">@Slf4j
public class SlowMotion {
    public static void main(String[] args) {
        AtomicInteger balance = new AtomicInteger(10000);
        int mainPrev = balance.get();
        log.debug(&quot;try get {}&quot;, mainPrev);
        new Thread(() -&gt; {
            sleep(1000);
            int prev = balance.get();
            balance.compareAndSet(prev, 9000);
            log.debug(balance.toString());
        }, &quot;t1&quot;).start();
        sleep(2000);
        log.debug(&quot;try set 8000...&quot;);
        boolean isSuccess = balance.compareAndSet(mainPrev, 8000);
        log.debug(&quot;is success ? {}&quot;, isSuccess);
        if(!isSuccess){
            mainPrev = balance.get();
            log.debug(&quot;try set 8000...&quot;);
            isSuccess = balance.compareAndSet(mainPrev, 8000);
            log.debug(&quot;is success ? {}&quot;, isSuccess);
        }
    }
    private static void sleep(int millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>输出结果</p>

<pre><code>2019-10-13 11:28:37.134 [main] try get 10000 
2019-10-13 11:28:38.154 [t1] 9000 
2019-10-13 11:28:39.154 [main] try set 8000... 
2019-10-13 11:28:39.154 [main] is success ? false 
2019-10-13 11:28:39.154 [main] try set 8000... 
2019-10-13 11:28:39.154 [main] is success ? true 
</code></pre>

<p><strong>volatile</strong></p>

<pre><code class="language-java">//AtomicInteger类中的value是使用volatile关键字修饰的
private volatile int value;
</code></pre>

<p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。</p>

<p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取
它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p>

<blockquote>
<p>注意
volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原
子性）</p>
</blockquote>

<p><strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</strong></p>

<h3 id="为什么无锁效率高">为什么无锁效率高</h3>

<ul>
<li><p>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时
候，发生上下文切换，进入阻塞。打个比喻</p></li>

<li><p>线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，
等被唤醒又得重新打火、启动、加速&hellip; 恢复到高速运行，代价比较大</p></li>

<li><p>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑
道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还
是会导致上下文切换。(所以在多核的情况下cas才能发挥优势，并且线程数不能炒超过cpu的核心数)</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200420152048629.png" alt="image-20200420152048629" /></p></li>
</ul>

<h3 id="cas-的特点">CAS 的特点</h3>

<p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</p>

<ul>
<li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再
重试呗。</li>
<li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想
改，我改完了解开锁，你们才有机会。</li>
<li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思

<ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul></li>
</ul>

<h2 id="6-3-原子整数">6.3 原子整数</h2>

<p>J.U.C 并发包提供了：</p>

<blockquote>
<ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
</blockquote>

<p>以 AtomicInteger 为例</p>

<pre><code class="language-java">AtomicInteger i = new AtomicInteger(0);
// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++
System.out.println(i.getAndIncrement());
// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i
System.out.println(i.incrementAndGet());
// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i
System.out.println(i.decrementAndGet());
// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--
System.out.println(i.getAndDecrement());
// 获取并加值（i = 0, 结果 i = 5, 返回 0）
System.out.println(i.getAndAdd(5));
// 加值并获取（i = 5, 结果 i = 0, 返回 0）
System.out.println(i.addAndGet(-5));
// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）
// 其中函数中的操作能保证原子，但函数需要无副作用
System.out.println(i.getAndUpdate(p -&gt; p - 2));
// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）
// 其中函数中的操作能保证原子，但函数需要无副作用
System.out.println(i.updateAndGet(p -&gt; p + 2));
// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）
// 其中函数中的操作能保证原子，但函数需要无副作用
// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的
// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final
System.out.println(i.getAndAccumulate(10, (p, x) -&gt; p + x));
// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）
// 其中函数中的操作能保证原子，但函数需要无副作用
System.out.println(i.accumulateAndGet(-10, (p, x) -&gt; p + x));
</code></pre>

<h2 id="6-4-原子引用">6.4 原子引用</h2>

<p>为什么需要原子引用类型？</p>

<blockquote>
<ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference</li>
<li>AtomicStampedReference</li>
</ul>
</blockquote>

<p>有如下方法</p>

<pre><code class="language-java">public interface DecimalAccount {
    // 获取余额
    BigDecimal getBalance();
    // 取款
    void withdraw(BigDecimal amount);
    /**
     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作
     * 如果初始余额为 10000 那么正确的结果应当是 0
     */
    static void demo(DecimalAccount account) {
        List&lt;Thread&gt; ts = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 1000; i++) {
            ts.add(new Thread(() -&gt; {
                account.withdraw(BigDecimal.TEN);
            }));
        }
        ts.forEach(Thread::start);
        ts.forEach(t -&gt; {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        System.out.println(account.getBalance());
    }
}
</code></pre>

<p>Cas不适合于大量线程的场景，它适用的场景为最大线程数不超过CPU核心数</p>

<p>试着提供不同的 DecimalAccount 实现，实现安全的取款操作</p>

<h3 id="不安全实现">不安全实现</h3>

<pre><code class="language-java">class DecimalAccountUnsafe implements DecimalAccount {
    BigDecimal balance;
    public DecimalAccountUnsafe(BigDecimal balance) {
        this.balance = balance;
    }
    @Override
    public BigDecimal getBalance() {
        return balance;
    }
    @Override
    public void withdraw(BigDecimal amount) {
        BigDecimal balance = this.getBalance();
        this.balance = balance.subtract(amount);
    }
}
</code></pre>

<h3 id="安全实现-使用锁">安全实现-使用锁</h3>

<pre><code class="language-java">class DecimalAccountSafeLock implements DecimalAccount {
    private final Object lock = new Object();
    BigDecimal balance;
    public DecimalAccountSafeLock(BigDecimal balance) {
        this.balance = balance;
    }
    @Override
    public BigDecimal getBalance() {
        return balance;
    }
    @Override
    public void withdraw(BigDecimal amount) {
        synchronized (lock) {
            BigDecimal balance = this.getBalance();
            this.balance = balance.subtract(amount);
        }
    }
}
</code></pre>

<h3 id="安全实现-使用-cas">安全实现-使用 CAS</h3>

<pre><code class="language-java">class DecimalAccountSafeCas implements DecimalAccount {
 AtomicReference&lt;BigDecimal&gt; ref;
 public DecimalAccountSafeCas(BigDecimal balance) {
 	ref = new AtomicReference&lt;&gt;(balance);
 }
 @Override
 public BigDecimal getBalance() {
 	return ref.get();
 }
 @Override
 public void withdraw(BigDecimal amount) {
     while (true) {
         BigDecimal prev = ref.get();
         BigDecimal next = prev.subtract(amount);
         if (ref.compareAndSet(prev, next)) {
         	break;
         }
     }
 }
}
</code></pre>

<p>测试代码</p>

<pre><code class="language-java">DecimalAccount.demo(new DecimalAccountUnsafe(new BigDecimal(&quot;10000&quot;)));
DecimalAccount.demo(new DecimalAccountSafeLock(new BigDecimal(&quot;10000&quot;)));
DecimalAccount.demo(new DecimalAccountSafeCas(new BigDecimal(&quot;10000&quot;)));
</code></pre>

<p>运行结果</p>

<pre><code>4310 cost: 425 ms
0 cost: 285 ms
0 cost: 274 ms
</code></pre>

<h3 id="aba-问题及解决">ABA 问题及解决</h3>

<p>ABA 问题</p>

<pre><code class="language-java">static AtomicReference&lt;String&gt; ref = new AtomicReference&lt;&gt;(&quot;A&quot;);
public static void main(String[] args) throws InterruptedException {
    log.debug(&quot;main start...&quot;);
    // 获取值 A
    // 这个共享变量被它线程修改过？
    String prev = ref.get();
    other();
    sleep(1);
    // 尝试改为 C
    log.debug(&quot;change A-&gt;C {}&quot;, ref.compareAndSet(prev, &quot;C&quot;));
}
private static void other() {
    new Thread(() -&gt; {
        log.debug(&quot;change A-&gt;B {}&quot;, ref.compareAndSet(ref.get(), &quot;B&quot;));
    }, &quot;t1&quot;).start();
    sleep(0.5);
    new Thread(() -&gt; {
        log.debug(&quot;change B-&gt;A {}&quot;, ref.compareAndSet(ref.get(), &quot;A&quot;));
    }, &quot;t2&quot;).start();
}
</code></pre>

<p>输出</p>

<pre><code>11:29:52.325 c.Test36 [main] - main start...
11:29:52.379 c.Test36 [t1] - change A-&gt;B true
11:29:52.879 c.Test36 [t2] - change B-&gt;A true
11:29:53.880 c.Test36 [main] - change A-&gt;C true
</code></pre>

<p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程</p>

<p>希望：</p>

<p>只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号使用AtomicStampedReference原子引用</p>

<h3 id="atomicstampedreference">AtomicStampedReference</h3>

<pre><code class="language-java">static AtomicStampedReference&lt;String&gt; ref = new AtomicStampedReference&lt;&gt;(&quot;A&quot;, 0);
public static void main(String[] args) throws InterruptedException {
    log.debug(&quot;main start...&quot;);
    // 获取值 A
    String prev = ref.getReference();
    // 获取版本号
    int stamp = ref.getStamp();
    log.debug(&quot;版本 {}&quot;, stamp);
    // 如果中间有其它线程干扰，发生了 ABA 现象
    other();
    sleep(1);
    // 尝试改为 C
    log.debug(&quot;change A-&gt;C {}&quot;, ref.compareAndSet(prev, &quot;C&quot;, stamp, stamp + 1));
}
private static void other() {
    new Thread(() -&gt; {
        log.debug(&quot;change A-&gt;B {}&quot;, ref.compareAndSet(ref.getReference(), &quot;B&quot;, 
                                                      ref.getStamp(), ref.getStamp() + 1));
        log.debug(&quot;更新版本为 {}&quot;, ref.getStamp());
    }, &quot;t1&quot;).start();
    sleep(0.5);
    new Thread(() -&gt; {
        log.debug(&quot;change B-&gt;A {}&quot;, ref.compareAndSet(ref.getReference(), &quot;A&quot;, 
                                                      ref.getStamp(), ref.getStamp() + 1));
        log.debug(&quot;更新版本为 {}&quot;, ref.getStamp());
    }, &quot;t2&quot;).start();
}
</code></pre>

<p>输出为</p>

<pre><code>15:41:34.891 c.Test36 [main] - main start... 
15:41:34.894 c.Test36 [main] - 版本 0 
15:41:34.956 c.Test36 [t1] - change A-&gt;B true 
15:41:34.956 c.Test36 [t1] - 更新版本为 1 
15:41:35.457 c.Test36 [t2] - change B-&gt;A true 
15:41:35.457 c.Test36 [t2] - 更新版本为 2 
15:41:36.457 c.Test36 [main] - change A-&gt;C false
</code></pre>

<p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。</p>

<p>但是有时候，并不关心引用变量更改了几次，只是单纯的关心<strong>是否更改过</strong>，所以就有了AtomicMarkableReference</p>

<pre><code class="language-mermaid">graph TD
a(&quot;保洁阿姨&quot;)-. 倒空 .-&gt;b(&quot;垃圾袋&quot;)
c(&quot;主人&quot;)--检查--&gt;b(&quot;垃圾袋&quot;)
b(&quot;垃圾袋&quot;)--还空--&gt;b(&quot;垃圾袋&quot;)
b(&quot;垃圾袋&quot;)--已满--&gt;d(&quot;新垃圾袋&quot;)

</code></pre>

<h3 id="atomicmarkablereference">AtomicMarkableReference</h3>

<pre><code class="language-java">class GarbageBag {
     String desc;
     public GarbageBag(String desc) {
        this.desc = desc;
     }
     public void setDesc(String desc) {
        this.desc = desc;
     }
     @Override
     public String toString() {
        return super.toString() + &quot; &quot; + desc;
     }
}
</code></pre>

<pre><code class="language-java">@Slf4j
public class TestABAAtomicMarkableReference {
 public static void main(String[] args) throws InterruptedException {
     GarbageBag bag = new GarbageBag(&quot;装满了垃圾&quot;);
     // 参数2 mark 可以看作一个标记，表示垃圾袋满了
     AtomicMarkableReference&lt;GarbageBag&gt; ref = new AtomicMarkableReference&lt;&gt;(bag, true);
     log.debug(&quot;主线程 start...&quot;);
     
     GarbageBag prev = ref.getReference();
     log.debug(prev.toString());
     new Thread(() -&gt; {
         log.debug(&quot;打扫卫生的线程 start...&quot;);
         bag.setDesc(&quot;空垃圾袋&quot;);
         while (!ref.compareAndSet(bag, bag, true, false)) {}
         log.debug(bag.toString());
     }).start();
     Thread.sleep(1000);
     log.debug(&quot;主线程想换一只新垃圾袋？&quot;);
     boolean success = ref.compareAndSet(prev, new GarbageBag(&quot;空垃圾袋&quot;), true, false);
     log.debug(&quot;换了么？&quot; + success);
     log.debug(ref.getReference().toString());
 }
}
</code></pre>

<p>输出</p>

<pre><code>2019-10-13 15:30:09.264 [main] 主线程 start... 
2019-10-13 15:30:09.270 [main] cn.itcast.GarbageBag@5f0fd5a0 装满了垃圾
2019-10-13 15:30:09.293 [Thread-1] 打扫卫生的线程 start... 
2019-10-13 15:30:09.294 [Thread-1] cn.itcast.GarbageBag@5f0fd5a0 空垃圾袋
2019-10-13 15:30:10.294 [main] 主线程想换一只新垃圾袋？
2019-10-13 15:30:10.294 [main] 换了么？false 
2019-10-13 15:30:10.294 [main] cn.itcast.GarbageBag@5f0fd5a0 空垃圾袋
</code></pre>

<h2 id="6-5-原子数组">6.5 原子数组</h2>

<ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>

<p>有如下方法</p>

<pre><code class="language-java">/**
 参数1，提供数组、可以是线程不安全数组或线程安全数组
 参数2，获取数组长度的方法
 参数3，自增方法，回传 array, index
 参数4，打印数组的方法
*/
// supplier 提供者 无中生有 ()-&gt;结果
// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果
// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;
private static &lt;T&gt; void demo(
 Supplier&lt;T&gt; arraySupplier,
 Function&lt;T, Integer&gt; lengthFun,
 BiConsumer&lt;T, Integer&gt; putConsumer,
 Consumer&lt;T&gt; printConsumer ) {
     List&lt;Thread&gt; ts = new ArrayList&lt;&gt;();
     T array = arraySupplier.get();
     int length = lengthFun.apply(array);
     for (int i = 0; i &lt; length; i++) {
         // 每个线程对数组作 10000 次操作
         ts.add(new Thread(() -&gt; {
             for (int j = 0; j &lt; 10000; j++) {
                putConsumer.accept(array, j%length);
             }
         }));
     }
     ts.forEach(t -&gt; t.start()); // 启动所有线程
     ts.forEach(t -&gt; {
     try {
     	t.join();
     } catch (InterruptedException e) {
     	e.printStackTrace();
     }
     }); // 等所有线程结束
     printConsumer.accept(array);
}
</code></pre>

<h3 id="不安全的数组">不安全的数组</h3>

<pre><code class="language-java">demo( ()-&gt;new int[10],
     (array)-&gt;array.length,
     (array, index) -&gt; array[index]++,
     array-&gt; System.out.println(Arrays.toString(array))
);
</code></pre>

<p>结果</p>

<pre><code>[9870, 9862, 9774, 9697, 9683, 9678, 9679, 9668, 9680, 9698]
</code></pre>

<h3 id="安全的数组">安全的数组</h3>

<pre><code class="language-java">demo(
 ()-&gt; new AtomicIntegerArray(10),
 (array) -&gt; array.length(),
 (array, index) -&gt; array.getAndIncrement(index),
 array -&gt; System.out.println(array)
);
</code></pre>

<p>结果</p>

<pre><code>[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]
</code></pre>

<h2 id="6-6-字段更新器">6.6 字段更新器</h2>

<ul>
<li>AtomicReferenceFieldUpdater // 域 字段</li>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdater</li>
</ul>

<p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现
异常</p>

<pre><code class="language-java">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Must be volatile type
</code></pre>

<pre><code class="language-java">public class Test5 {
 private volatile int field;
 public static void main(String[] args) {
     AtomicIntegerFieldUpdater fieldUpdater =
     AtomicIntegerFieldUpdater.newUpdater(Test5.class, &quot;field&quot;);
     Test5 test5 = new Test5();
     fieldUpdater.compareAndSet(test5, 0, 10);
     // 修改成功 field = 10
     System.out.println(test5.field);
     // 修改成功 field = 20
     fieldUpdater.compareAndSet(test5, 10, 20);
     System.out.println(test5.field);
     // 修改失败 field = 20
     fieldUpdater.compareAndSet(test5, 10, 30);
     System.out.println(test5.field);
 }
}
</code></pre>

<p>输出</p>

<pre><code>10 
20 
20
</code></pre>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test40&quot;)
public class Test40 {

    public static void main(String[] args) {
        Student stu = new Student();

        AtomicReferenceFieldUpdater updater =
                AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, &quot;name&quot;);

        System.out.println(updater.compareAndSet(stu, null, &quot;张三&quot;));
        System.out.println(stu);
    }
}

class Student {
    volatile String name;

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}';
    }
}
</code></pre>

<h2 id="6-7-原子累加器">6.7 原子累加器</h2>

<blockquote>
<ul>
<li>AtomicLong</li>
<li>LongAdder</li>
</ul>
</blockquote>

<h3 id="累加器性能比较">累加器性能比较</h3>

<pre><code class="language-java">private static &lt;T&gt; void demo(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action) {
     T adder = adderSupplier.get();
     long start = System.nanoTime();
     List&lt;Thread&gt; ts = new ArrayList&lt;&gt;();
     // 4 个线程，每人累加 50 万
     for (int i = 0; i &lt; 40; i++) {
         ts.add(new Thread(() -&gt; {
             for (int j = 0; j &lt; 500000; j++) {
                action.accept(adder);
             }
         }));
     }
     ts.forEach(t -&gt; t.start());
     ts.forEach(t -&gt; {
         try {
         	t.join();
         } catch (InterruptedException e) {
         	e.printStackTrace();
         }
     });
     long end = System.nanoTime();
     System.out.println(adder + &quot; cost:&quot; + (end - start)/1000_000);
    }
</code></pre>

<p>比较 AtomicLong 与 LongAdder</p>

<pre><code class="language-java">for (int i = 0; i &lt; 5; i++) {
 demo(() -&gt; new LongAdder(), adder -&gt; adder.increment());
}
for (int i = 0; i &lt; 5; i++) {
 demo(() -&gt; new AtomicLong(), adder -&gt; adder.getAndIncrement());
}
</code></pre>

<p>输出</p>

<pre><code>1000000 cost:43
1000000 cost:9
1000000 cost:7
1000000 cost:7
1000000 cost:7
1000000 cost:31
1000000 cost:27
1000000 cost:28
1000000 cost:24
1000000 cost:22
</code></pre>

<p>性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]&hellip; 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。(累加单元不会超过CPU的核心数)</p>

<ul>
<li><strong>源码之 LongAdder</strong></li>
</ul>

<p>LongAdder 是并发大师 @author Doug Lea （大哥李）的作品，设计的非常精巧</p>

<p>LongAdder 类有几个关键域</p>

<pre><code class="language-java">// 累加单元数组, 懒惰初始化
transient volatile Cell[] cells;
// 基础值, 如果没有竞争, 则用 cas 累加这个域
transient volatile long base;
// 在 cells 创建或扩容时, 置为 1, 表示加锁（cas锁的加锁标记，来保护对某些资源访问时的线程安全）
transient volatile int cellsBusy;
</code></pre>

<p>transient关键字：在序列化时不会把这些信息进行序列化</p>

<p><strong>cas锁</strong></p>

<pre><code class="language-java">// 不要用于实践！！！
public class LockCas {
    private AtomicInteger state = new AtomicInteger(0);
    public void lock() {
        while (true) {
            if (state.compareAndSet(0, 1)) {
                break;
            }
        }
    }
    public void unlock() {
        log.debug(&quot;unlock...&quot;);
        state.set(0);
    }
}
</code></pre>

<p>测试</p>

<pre><code class="language-java">LockCas lock = new LockCas();
new Thread(() -&gt; {
    log.debug(&quot;begin...&quot;);
    lock.lock();
    try {
        log.debug(&quot;lock...&quot;);
        sleep(1);
    } finally {
        lock.unlock();
    }
}).start();
new Thread(() -&gt; {
    log.debug(&quot;begin...&quot;);
    lock.lock();
    try {
        log.debug(&quot;lock...&quot;);
    } finally {
        lock.unlock();
    }
}).start();
</code></pre>

<p>输出</p>

<pre><code>18:27:07.198 c.Test42 [Thread-0] - begin... 
18:27:07.202 c.Test42 [Thread-0] - lock... 
18:27:07.198 c.Test42 [Thread-1] - begin... 
18:27:08.204 c.Test42 [Thread-0] - unlock... 
18:27:08.204 c.Test42 [Thread-1] - lock... 
18:27:08.204 c.Test42 [Thread-1] - unlock...
</code></pre>

<h3 id="原理之伪共享">* 原理之伪共享</h3>

<p>其中 Cell 即为累加单元</p>

<pre><code class="language-java">//Contended注解：防止缓存行伪共享
//由于一个缓存行加入了多个cell对象称为伪共享
@sun.misc.Contended
    static final class Cell {
        volatile long value;
        Cell(long x) { value = x; }

        // 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值
        final boolean cas(long prev, long next) {
            return UNSAFE.compareAndSwapLong(this, valueOffset, prev, next);
        }
        // 省略不重要代码
    }
</code></pre>

<p>得从缓存说起</p>

<p>缓存与内存的速度比较</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200420160059673.png" alt="image-20200420160059673" /></p>

<table>
<thead>
<tr>
<th>从CPU到</th>
<th>大约需要的时间</th>
</tr>
</thead>

<tbody>
<tr>
<td>寄存器</td>
<td>1 cycle (4GHz 的 CPU 约为0.25ns)</td>
</tr>

<tr>
<td>L1</td>
<td>3~4 cycle</td>
</tr>

<tr>
<td>L2</td>
<td>10~20 cycle</td>
</tr>

<tr>
<td>L3</td>
<td>40~45 cycle</td>
</tr>

<tr>
<td>内存</td>
<td>120~240 cycle</td>
</tr>
</tbody>
</table>

<p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。</p>

<p>而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（ 8 个 long）</p>

<p>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中</p>

<p>CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200420160303519.png" alt="image-20200420160303519" /></p>

<p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（ 16 字节的对象头和 8 字节的 value），因
此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p>

<pre><code>Core-0 要修改 Cell[0]
Core-1 要修改 Cell[1]
</code></pre>

<p>无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加
Cell[0]=6001, Cell[1]=8000，这时会让 Core-1 的缓存行失效</p>

<p><code>@sun.misc.Contended</code> 用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的
padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200420160325796.png" alt="image-20200420160325796" /></p>

<p>累加主要调用下面的方法</p>

<pre><code class="language-java">public void add(long x) {
     // as 为累加单元数组
     // b 为基础值
     // x 为累加值
     Cell[] as; long b, v; int m; Cell a;
     // 进入 if 的两个条件
     // 1. as 有值, 表示已经发生过竞争, 进入 if
     // 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if
     if ((as = cells) != null || !casBase(b = base, b + x)) {
        // uncontended 表示 cell 没有竞争
        boolean uncontended = true;
        if (
             // as 还没有创建
             as == null || (m = as.length - 1) &lt; 0 ||
             // 当前线程对应的 cell 还没有
             (a = as[getProbe() &amp; m]) == null ||
             // cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )
             !(uncontended = a.cas(v = a.value, v + x))
         ) {
            // 进入 cell 数组创建、cell 创建的流程
            longAccumulate(x, null, uncontended);
         }
     }
}
</code></pre>

<p>add 流程图</p>

<pre><code class="language-mermaid">graph LR
a(&quot;当前线程&quot;)--&gt;b(cells)
b(cells)--为空--&gt;c(cas base 累加)
b(cells)--不为空--&gt;d(当前线程cell是否创建)
c(cas base 累加)--成功--&gt;e(return)
c(cas base 累加)--失败--&gt;f(longAccumulate)
d(当前线程cell是否创建)--创建了--&gt;g(cas cell累加)
d(当前线程cell是否创建)--没创建--&gt;f
g--成功--&gt;e
g--失败--&gt;f
</code></pre>

<pre><code class="language-java">final void longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended) {
    int h;
    // 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell
    if ((h = getProbe()) == 0) {
        // 初始化 probe
        ThreadLocalRandom.current();
        // h 对应新的 probe 值, 用来对应 cell
        h = getProbe();
        wasUncontended = true;
    }
    // collide 为 true 表示需要扩容
    boolean collide = false; 
    for (;;) {
        Cell[] as; Cell a; int n; long v;
        // 已经有了 cells
        if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) {
            // 还没有 cell
            if ((a = as[(n - 1) &amp; h]) == null) {
                // 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x
                // 成功则 break, 否则继续 continue 循环
                //cells存在&amp;cell没创建
                if (cellsBusy == 0) {       // Try to attach new Cell
                    Cell r = new Cell(x);   // Optimistically create
                    if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {
                        boolean created = false;
                        try {               // Recheck under lock
                            Cell[] rs; int m, j;
                            if ((rs = cells) != null &amp;&amp;
                                (m = rs.length) &gt; 0 &amp;&amp;
                                rs[j = (m - 1) &amp; h] == null) {
                                rs[j] = r;
                                created = true;
                            }
                        } finally {
                            cellsBusy = 0;
                        }
                        if (created)
                            break;
                        continue;           // Slot is now non-empty
                    }
                }
                collide = false;
            }
            // 有竞争, 改变线程对应的 cell 来重试 cas
            else if (!wasUncontended)
                wasUncontended = true;
            // cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null
            //cells存在&amp;cells已创建
            else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x))))
                break;
            // 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas
            else if (n &gt;= NCPU || cells != as)
                collide = false;
            // 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了
            else if (!collide)
                collide = true;
            // 加锁
            else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {
                try {
                    if (cells == as) {      // Expand table unless stale
                        Cell[] rs = new Cell[n &lt;&lt; 1];
                        for (int i = 0; i &lt; n; ++i)
                            rs[i] = as[i];
                        cells = rs;
                    }
                } finally {
                    cellsBusy = 0;
                }
                collide = false;
                // 加锁成功, 扩容
                continue;
            }
            // 改变线程对应的 cell
            h = advanceProbe(h);
        }
        // 还没有 cells, 尝试给 cellsBusy 加锁
        //cellsBusy 0:未加锁；1：加锁
        //cells == as 还没有其他线程改变cells数组
        //casCellsBusy():尝试加锁
        else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) {
            // 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell
            // 成功则 break;
            boolean init = false;
            try { 
                // 没有别人把cells创建好，那我们就创建
                if (cells == as) {
                    Cell[] rs = new Cell[2];
                    rs[h &amp; 1] = new Cell(x);
                    cells = rs;
                    init = true;
                }
            } finally {
                cellsBusy = 0;//解锁
            }
            if (init)
                break;
        }
        // 上两种情况失败, 尝试给 base 累加
        //
        else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x)))){
            break;
        }
    }
}
</code></pre>

<p>longAccumulate 流程图</p>

<pre><code class="language-mermaid">graph LR
a(&quot;循环入口&quot;)--&gt;b(cells不存在&amp;未加锁&amp;未新建)
a--失败--&gt;c(&quot;cas base 累加&quot;)
b--&gt;d(&quot;加锁&quot;)
d--成功--&gt;e(创建cells并初始化一个cell)
d--失败--&gt;c
c--成功--&gt;f(returnn)
e--&gt;f
</code></pre>

<pre><code class="language-mermaid">graph LR
a(&quot;循环入口&quot;)--&gt;b(cells不存在&amp;cell没创建)
c(&quot;槽位为空&quot;)--失败--&gt;a
d(&quot;加锁&quot;)--失败--&gt;a
b--创建cell--&gt;d
d--成功--&gt;c
c--成功--&gt;f(return)
</code></pre>

<p>每个线程刚进入 longAccumulate 时，会尝试对应一个 cell 对象（找到一个坑位）</p>

<pre><code class="language-mermaid">graph LR
a(循环入口)--cells存在&amp;&amp;cell已创建--&gt;b(cas cell 累加)
b--成功--&gt;c(return)
b--失败--&gt;d(是否超过CPU上限)
d--是--&gt;e(改变线程对应的cell)
d--否--&gt;f(加锁)
f--失败--&gt;e
e--&gt;a
f--成功--&gt;g(扩容)
g--&gt;a
</code></pre>

<p>获取最终结果通过 sum 方法</p>

<pre><code class="language-java">public long sum() {
 Cell[] as = cells; Cell a;
 long sum = base;
 if (as != null) {
 for (int i = 0; i &lt; as.length; ++i) {
 if ((a = as[i]) != null)
 	sum += a.value;
 }
 }
 return sum; }
</code></pre>

<h2 id="6-8-unsafe">6.8 Unsafe</h2>

<p><strong>概述</strong></p>

<p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得</p>

<pre><code class="language-java">public class UnsafeAccessor {
 static Unsafe unsafe;
 static {
     try { 
         Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
         theUnsafe.setAccessible(true);
         unsafe = (Unsafe) theUnsafe.get(null);
     } catch (NoSuchFieldException | IllegalAccessException e) {
        throw new Error(e);
     }
 }
 static Unsafe getUnsafe() {
 	return unsafe;
 }
}
</code></pre>

<p>Unsafe CAS 操作</p>

<pre><code class="language-java">@Data
class Student {
 volatile int id;
 volatile String name;
}
</code></pre>

<pre><code class="language-java">Unsafe unsafe = UnsafeAccessor.getUnsafe();
Field id = Student.class.getDeclaredField(&quot;id&quot;);
Field name = Student.class.getDeclaredField(&quot;name&quot;);
// 获得成员变量的偏移量
long idOffset = UnsafeAccessor.unsafe.objectFieldOffset(id);
long nameOffset = UnsafeAccessor.unsafe.objectFieldOffset(name);
Student student = new Student();
// 使用 cas 方法替换成员变量的值
UnsafeAccessor.unsafe.compareAndSwapInt(student, idOffset, 0, 20); // 返回 true
UnsafeAccessor.unsafe.compareAndSwapObject(student, nameOffset, null, &quot;张三&quot;); // 返回 true
System.out.println(student);
</code></pre>

<p>输出</p>

<pre><code>Student(id=20, name=张三)
</code></pre>

<p>使用自定义的 MyAtomicInteger 实现之前线程安全的原子整数 Account 实现</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test42&quot;)
public class Test42 {
    public static void main(String[] args) {
        Account.demo(new MyAtomicInteger(10000));
    }
}
class MyAtomicInteger implements Account {
    private volatile int value;
    private static final long valueOffset;
    private static final Unsafe UNSAFE;
    static {
        UNSAFE = UnsafeAccessor.getUnsafe();
        try {
            valueOffset = UNSAFE.objectFieldOffset(MyAtomicInteger.class.getDeclaredField(&quot;value&quot;));
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }
    public int getValue() {
        return value;
    }
    public void decrement(int amount) {
        while(true) {
            int prev = this.value;
            int next = prev - amount;
            if (UNSAFE.compareAndSwapInt(this, valueOffset, prev, next)) {
                break;
            }
        }
    }
    public MyAtomicInteger(int value) {
        this.value = value;
    }
    @Override
    public Integer getBalance() {
        return getValue();
    }
    @Override
    public void withdraw(Integer amount) {
        decrement(amount);
    }
}
</code></pre>

<h2 id="本章小结-3">本章小结</h2>

<ul>
<li>CAS 与 volatile</li>
<li>API

<ul>
<li>原子整数</li>
<li>原子引用</li>
<li>原子数组</li>
<li>字段更新器</li>
<li>原子累加器</li>
</ul></li>

<li><p>Unsafe</p></li>

<li><p>原理方面</p></li>

<li><p>LongAdder 源码</p></li>

<li><p>伪共享</p></li>
</ul>

<h1 id="7-共享模型之不可变">7. 共享模型之不可变</h1>

<h2 id="本章内容-2">本章内容</h2>

<p>可变类都不是线程安全的</p>

<ul>
<li>不可变类的使用</li>
<li>不可变类设计</li>
<li>无状态类设计</li>
</ul>

<h2 id="7-1-日期转换的问题">7.1 日期转换的问题</h2>

<h3 id="问题提出">问题提出</h3>

<p>下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的</p>

<pre><code class="language-java">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
for (int i = 0; i &lt; 10; i++) {
     new Thread(() -&gt; {
         try {
            log.debug(&quot;{}&quot;, sdf.parse(&quot;1951-04-21&quot;));
         } catch (Exception e) {
            log.error(&quot;{}&quot;, e);
         }
     }).start();
}
</code></pre>

<p>有很大几率出现 java.lang.NumberFormatException 或者出现不正确的日期解析结果，例如：</p>

<pre><code>19:10:40.859 [Thread-2] c.TestDateParse - {} 
java.lang.NumberFormatException: For input string: &quot;&quot; 
 at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) 
 at java.lang.Long.parseLong(Long.java:601) 
 at java.lang.Long.parseLong(Long.java:631) 
 at java.text.DigitList.getLong(DigitList.java:195) 
 at java.text.DecimalFormat.parse(DecimalFormat.java:2084) 
 at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2162) 
 at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514) 
 at java.text.DateFormat.parse(DateFormat.java:364) 
 at cn.itcast.n7.TestDateParse.lambda$test1$0(TestDateParse.java:18) 
 at java.lang.Thread.run(Thread.java:748) 
19:10:40.859 [Thread-1] c.TestDateParse - {} 
java.lang.NumberFormatException: empty String 
 at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1842) 
 at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110) 
 at java.lang.Double.parseDouble(Double.java:538) 
 at java.text.DigitList.getDouble(DigitList.java:169) 
 at java.text.DecimalFormat.parse(DecimalFormat.java:2089) 
 at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2162) 
 at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514) 
 at java.text.DateFormat.parse(DateFormat.java:364) 
 at cn.itcast.n7.TestDateParse.lambda$test1$0(TestDateParse.java:18) 
 at java.lang.Thread.run(Thread.java:748) 
19:10:40.857 [Thread-8] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 
19:10:40.857 [Thread-9] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 
19:10:40.857 [Thread-6] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 
19:10:40.857 [Thread-4] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 
19:10:40.857 [Thread-5] c.TestDateParse - Mon Apr 21 00:00:00 CST 178960645 
19:10:40.857 [Thread-0] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 
19:10:40.857 [Thread-7] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951 
19:10:40.857 [Thread-3] c.TestDateParse - Sat Apr 21 00:00:00 CST 1951
</code></pre>

<h3 id="思路-同步锁">思路 - 同步锁</h3>

<p>这样虽能解决问题，但带来的是性能上的损失，并不算很好：</p>

<pre><code class="language-java">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
for (int i = 0; i &lt; 50; i++) {
     new Thread(() -&gt; {
         synchronized (sdf) {
             try {
                log.debug(&quot;{}&quot;, sdf.parse(&quot;1951-04-21&quot;));
             } catch (Exception e) {
                log.error(&quot;{}&quot;, e);
             }
         }
     }).start();
}
</code></pre>

<h3 id="思路-不可变">思路 - 不可变</h3>

<p>如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊！这样的对象在Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类：</p>

<pre><code class="language-java">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);
for (int i = 0; i &lt; 10; i++) {
     new Thread(() -&gt; {
         LocalDate date = dtf.parse(&quot;2018-10-01&quot;, LocalDate::from);
         log.debug(&quot;{}&quot;, date);
     }).start();
}
</code></pre>

<p>可以看 DateTimeFormatter 的文档：</p>

<pre><code class="language-java">@implSpec
This class is immutable and thread-safe.
</code></pre>

<p>不可变对象，实际是另一种避免竞争的方式。</p>

<pre><code class="language-java">
@Slf4j(topic = &quot;c.TestDateParse&quot;)
public class TestDateParse {
    public static void main(String[] args) {
        test3();
    }

    private static void test1() {
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        for (int i = 0; i &lt; 10; i++) {
            new Thread(() -&gt; {
                try {
                    log.debug(&quot;{}&quot;, sdf.parse(&quot;1951-04-21&quot;));
                } catch (Exception e) {
                    log.error(&quot;{}&quot;, e);
                }
            }).start();
        }
    }

    private static void test2() {
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        for (int i = 0; i &lt; 10; i++) {
            new Thread(() -&gt; {
                synchronized (sdf) {
                    try {
                        log.debug(&quot;{}&quot;, sdf.parse(&quot;1951-04-21&quot;));
                    } catch (Exception e) {
                        log.error(&quot;{}&quot;, e);
                    }
                }
            }).start();
        }
    }

    private static void test3() {
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);
        for (int i = 0; i &lt; 10; i++) {
            new Thread(() -&gt; {
                LocalDate date = dtf.parse(&quot;2018-10-01&quot;, LocalDate::from);
                log.debug(&quot;{}&quot;, date);
            }).start();
        }
    }
}
</code></pre>

<h2 id="7-2-不可变设计">7.2 不可变设计</h2>

<p>另一个大家更为熟悉的 String 类也是不可变的，以它为例，说明一下不可变设计的要素</p>

<pre><code class="language-java">public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
    /** Cache the hash code for the string */
    private int hash; // Default to 0

    // ...

}
</code></pre>

<p>final 的使用(final只能保证对象的引用时不能够改变的，但是它的内容是可以改变的)</p>

<p>发现该类、类中所有属性都是 final 的</p>

<ul>
<li>属性用 final 修饰保证了该属性是只读的，不能修改</li>
<li>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</li>
</ul>

<h3 id="保护性拷贝">保护性拷贝</h3>

<p>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是
如何实现的，就以 substring 为例：</p>

<pre><code class="language-java">public String substring(int beginIndex) {
 if (beginIndex &lt; 0) {
 	throw new StringIndexOutOfBoundsException(beginIndex);
 }
 int subLen = value.length - beginIndex;
 if (subLen &lt; 0) {
 	throw new StringIndexOutOfBoundsException(subLen);
 }
 return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);
}
</code></pre>

<p>发现其内部是调用 String 的构造方法创建了一个新字符串，再进入这个构造看看，是否对 final char[] value 做出
了修改：</p>

<pre><code class="language-java">public String(char value[], int offset, int count) {
 if (offset &lt; 0) {
 	throw new StringIndexOutOfBoundsException(offset);
 }
 if (count &lt;= 0) {
     if (count &lt; 0) {
     	throw new StringIndexOutOfBoundsException(count);
     }
     if (offset &lt;= value.length) {
     	this.value = &quot;&quot;.value;
     	return;
     }
 }
 if (offset &gt; value.length - count) {
 	throw new StringIndexOutOfBoundsException(offset + count);
 }
 this.value = Arrays.copyOfRange(value, offset, offset+count);
}
</code></pre>

<p>结果发现也没有，构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避
免共享的手段称之为【<strong>保护性拷贝（defensive copy）</strong>】</p>

<p>为了保证对象的不可变性，需要使用一种保护性拷贝的机制。在对象有修改发生的情况下会创建一个新的对象。这样虽然能避免共享保证这些方法的线程安全，但是也带来了一个严重的问题，就是对象创建的太频繁，对象的个数较多。因此对于这种不可变类的设计会关联一种设计模式：享元模式</p>

<h3 id="模式之享元">* 模式之享元</h3>

<h3 id="原理之-final">* 原理之 final</h3>

<h2 id="7-3-无状态">7.3 无状态</h2>

<p>在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这
种没有任何成员变量的类是线程安全的</p>

<pre><code>因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】
</code></pre>

<h2 id="本章小结-4">本章小结</h2>

<ul>
<li>不可变类使用</li>

<li><p>不可变类设计</p></li>

<li><p>原理方面</p>

<ul>
<li>final</li>
<li>模式方面</li>
<li>享元</li>
</ul></li>
</ul>

<h1 id="8-共享模型之工具">8. 共享模型之工具</h1>

<h2 id="8-1-线程池">8.1 线程池</h2>

<p>类似享元模式的思想</p>

<h3 id="1-自定义线程池">1. 自定义线程池</h3>

<pre><code class="language-mermaid">graph LR
  subgraph Blocking Queue
   task1(task 1)--&gt; task2(task 2)
  
   task2--&gt;task3(task 3)
  end
  subgraph Thread Pool
    t1(t1)
    t2(t2)
    t3(t3)
  end
  t1(t1)--poll--&gt;task1
  t2(t2)-.poll.-&gt;task1
  t3(t3)-.poll.-&gt;task1
  task3--put--&gt;main(main)

  
</code></pre>

<p>步骤 1 ：自定义拒绝策略接口</p>

<pre><code class="language-java">@FunctionalInterface // 拒绝策略
interface RejectPolicy&lt;T&gt; {
 void reject(BlockingQueue&lt;T&gt; queue, T task);
}
</code></pre>

<p>步骤 2 ：自定义任务队列</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.BlockingQueue&quot;)
class BlockingQueue&lt;T&gt; {
    // 1. 任务队列
    private Deque&lt;T&gt; queue = new ArrayDeque&lt;&gt;();

    // 2. 锁
    private ReentrantLock lock = new ReentrantLock();

    // 3. 生产者条件变量
    
    private Condition fullWaitSet = lock.newCondition();

    // 4. 消费者条件变量
    private Condition emptyWaitSet = lock.newCondition();

    // 5. 容量
    private int capcity;

    public BlockingQueue(int capcity) {
        this.capcity = capcity;
    }

    // 带超时阻塞获取
    public T poll(long timeout, TimeUnit unit) {
        lock.lock();
        try {
            // 将 timeout 统一转换为 纳秒
            long nanos = unit.toNanos(timeout);
            while (queue.isEmpty()) {
                try {
                    // 返回值是剩余时间
                    if (nanos &lt;= 0) {
                        return null;
                    }
                    nanos = emptyWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.removeFirst();
            fullWaitSet.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }
    // 阻塞获取
    public T take() {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                try {
                    emptyWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.removeFirst();
            fullWaitSet.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }
    // 阻塞添加
    public void put(T task) {
        lock.lock();
        try {
            while (queue.size() == capcity) {
                try {
                    log.debug(&quot;等待加入任务队列 {} ...&quot;, task);
                    fullWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug(&quot;加入任务队列 {}&quot;, task);
            queue.addLast(task);
            emptyWaitSet.signal();
        } finally {
            lock.unlock();
        }
    }
    // 带超时时间阻塞添加
    public boolean offer(T task, long timeout, TimeUnit timeUnit) {
        lock.lock();
        try {
            long nanos = timeUnit.toNanos(timeout);
            while (queue.size() == capcity) {
                try {
                    if(nanos &lt;= 0) {
                        return false;
                    }
                    log.debug(&quot;等待加入任务队列 {} ...&quot;, task);
                    nanos = fullWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug(&quot;加入任务队列 {}&quot;, task);
            queue.addLast(task);
            emptyWaitSet.signal();
            return true;
        } finally {
            lock.unlock();
        }
    }
    public int size() {
        lock.lock();
        try {
            return queue.size();
        } finally {
            lock.unlock();
        }
    }
    public void tryPut(RejectPolicy&lt;T&gt; rejectPolicy, T task) {
        lock.lock();
        try {
            // 判断队列是否满
            if(queue.size() == capcity) {
                rejectPolicy.reject(this, task);
            } else {  // 有空闲
                log.debug(&quot;加入任务队列 {}&quot;, task);
                queue.addLast(task);
                emptyWaitSet.signal();
            }
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>

<p>步骤 3 ：自定义线程池</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.ThreadPool&quot;)
class ThreadPool {
    // 任务队列
    private BlockingQueue&lt;Runnable&gt; taskQueue;

    // 线程集合
    private HashSet&lt;Worker&gt; workers = new HashSet&lt;&gt;();

    // 核心线程数
    private int coreSize;

    // 获取任务时的超时时间
    private long timeout;

    private TimeUnit timeUnit;

    private RejectPolicy&lt;Runnable&gt; rejectPolicy;

    // 执行任务
    public void execute(Runnable task) {
        // 当任务数没有超过 coreSize 时，直接交给 worker 对象执行
        // 如果任务数超过 coreSize 时，加入任务队列暂存
        synchronized (workers) {
            if(workers.size() &lt; coreSize) {
                Worker worker = new Worker(task);
                log.debug(&quot;新增 worker{}, {}&quot;, worker, task);
                workers.add(worker);
                worker.start();
            } else {
//                taskQueue.put(task);
                // 1) 死等
                // 2) 带超时等待
                // 3) 让调用者放弃任务执行
                // 4) 让调用者抛出异常
                // 5) 让调用者自己执行任务
                taskQueue.tryPut(rejectPolicy, task);
            }
        }
    }

    public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapcity, RejectPolicy&lt;Runnable&gt; rejectPolicy) {
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
        this.taskQueue = new BlockingQueue&lt;&gt;(queueCapcity);
        this.rejectPolicy = rejectPolicy;
    }

    class Worker extends Thread{
        private Runnable task;

        public Worker(Runnable task) {
            this.task = task;
        }

        @Override
        public void run() {
            // 执行任务
            // 1) 当 task 不为空，执行任务
            // 2) 当 task 执行完毕，再接着从任务队列获取任务并执行
//            while(task != null || (task = taskQueue.take()) != null) {
            while(task != null || (task = taskQueue.poll(timeout, timeUnit)) != null) {
                try {
                    log.debug(&quot;正在执行...{}&quot;, task);
                    task.run();
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    task = null;
                }
            }
            synchronized (workers) {
                log.debug(&quot;worker 被移除{}&quot;, this);
                workers.remove(this);
            }
        }
    }
}
</code></pre>

<p>步骤 4 ：测试</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.TestPool&quot;)
public class TestPool {
    public static void main(String[] args) {
        ThreadPool threadPool = new ThreadPool(1,
                1000, TimeUnit.MILLISECONDS, 1, (queue, task)-&gt;{
            // 1. 死等
//            queue.put(task);
            // 2) 带超时等待
//            queue.offer(task, 1500, TimeUnit.MILLISECONDS);
            // 3) 让调用者放弃任务执行
//            log.debug(&quot;放弃{}&quot;, task);
            // 4) 让调用者抛出异常
//            throw new RuntimeException(&quot;任务执行失败 &quot; + task);
            // 5) 让调用者自己执行任务
            task.run();
        });
        for (int i = 0; i &lt; 4; i++) {
            int j = i;
            threadPool.execute(() -&gt; {
                try {
                    Thread.sleep(1000L);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug(&quot;{}&quot;, j);
            });
        }
    }
}
</code></pre>

<p>ThreadPoolExecutor</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200420163805818.png" alt="image-20200420163805818" /></p>

<h3 id="1-线程池状态">1) 线程池状态</h3>

<p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p>

<table>
<thead>
<tr>
<th>状态名</th>
<th>高3位</th>
<th>接受新任务</th>
<th>处理阻塞队列任务</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>RUNNING</td>
<td>111</td>
<td>Y</td>
<td>Y</td>
<td></td>
</tr>

<tr>
<td>SHUTDOWN</td>
<td>000</td>
<td>N</td>
<td>Y</td>
<td>不会接收新任务，但会处理阻塞队列剩余 任务</td>
</tr>

<tr>
<td>STOP</td>
<td>001</td>
<td>N</td>
<td>N</td>
<td>会中断正在执行的任务，并抛弃阻塞队列 任务</td>
</tr>

<tr>
<td>TIDYING</td>
<td>010</td>
<td>-</td>
<td>-</td>
<td>任务全执行完毕，活动线程为 0 即将进入 终结</td>
</tr>

<tr>
<td>TERMINATED</td>
<td>011</td>
<td>-</td>
<td>-</td>
<td>终结状态</td>
</tr>
</tbody>
</table>

<p>从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</p>

<p>这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作
进行赋值</p>

<pre><code class="language-java">// c 为旧值， ctlOf 返回结果为新值
ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));
// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们
private static int ctlOf(int rs, int wc) { return rs | wc; }
</code></pre>

<h3 id="2-构造方法">2) 构造方法</h3>

<pre><code class="language-java">public ThreadPoolExecutor(int corePoolSize,
 int maximumPoolSize,
 long keepAliveTime,
 TimeUnit unit,
 BlockingQueue&lt;Runnable&gt; workQueue,
 ThreadFactory threadFactory,
 RejectedExecutionHandler handler)
</code></pre>

<ul>
<li>corePoolSize 核心线程数目 (最多保留的线程数)</li>
<li>maximumPoolSize 最大线程数目</li>
<li>keepAliveTime 生存时间 - 针对救急线程</li>
<li>unit 时间单位 - 针对救急线程</li>
<li>workQueue 阻塞队列</li>
<li>threadFactory 线程工厂 - 可以为线程创建时起个好名字</li>
<li>handler 拒绝策略</li>
</ul>

<p>工作方式：</p>

<pre><code class="language-mermaid">graph LR
  subgraph 线程池c=2,m=3
    a1(救急线程1)
    a2(核心线程1)--&gt;a3(任务1)
    a5(核心线程2)--&gt;a4(任务2)
  end
  subgraph 阻塞队列
    q1(size=2)
    q2(任务3)
    13(任务4)
  end
  
</code></pre>

<ul>
<li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</li>
<li>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排
队，直到有空闲的线程。</li>
<li>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线
程来救急。</li>
<li>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，其它
著名框架也提供了实现

<ul>
<li>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li>
<li>CallerRunsPolicy 让调用者运行任务</li>
<li>DiscardPolicy 放弃本次任务</li>
<li>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li>
<li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方
便定位问题</li>
<li>Netty 的实现，是创建一个新线程来执行任务</li>
<li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</li>
<li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li>
</ul></li>
<li>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由
keepAliveTime 和 unit 来控制。</li>
</ul>

<p><img src="/resources/技术收录/Java/java并发/image-20200420164754738.png" alt="image-20200420164754738" /></p>

<p>根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池</p>

<h3 id="3-newfixedthreadpool">3)newFixedThreadPool</h3>

<pre><code class="language-java">public static ExecutorService newFixedThreadPool(int nThreads) {
 	return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,
 new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre>

<p>特点</p>

<ul>
<li>核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li>阻塞队列是无界的，可以放任意数量的任务</li>
</ul>

<blockquote>
<p>评价 适用于任务量已知，相对耗时的任务</p>
</blockquote>

<p>创建的都是核心线程，因此即使线程池中没有任务执行了，程序也不会主动停止（非守护线程）</p>

<pre><code class="language-java">private static void test2() throws InterruptedException {
        AtomicInteger num = new AtomicInteger(0);
        ExecutorService service = Executors.newFixedThreadPool(10, (r) -&gt; {
            return new Thread(r, &quot;t&quot; + num.getAndIncrement());
        });
        CountDownLatch latch = new CountDownLatch(10);
        String[] all = new String[10];
        Random r = new Random();
        for (int j = 0; j &lt; 10; j++) {
            int x = j;
            service.submit(() -&gt; {
                for (int i = 0; i &lt;= 100; i++) {
                    try {
                        Thread.sleep(r.nextInt(100));
                    } catch (InterruptedException e) {
                    }
                    all[x] = Thread.currentThread().getName() + &quot;(&quot; + (i + &quot;%&quot;) + &quot;)&quot;;
                    System.out.print(&quot;\r&quot; + Arrays.toString(all));
                }
                latch.countDown();
            });
        }
        latch.await();
        System.out.println(&quot;\n游戏开始...&quot;);
        service.shutdown();
    }
</code></pre>

<h3 id="4-newcachedthreadpool">4)newCachedThreadPool</h3>

<pre><code class="language-java">public static ExecutorService newCachedThreadPool() {
 return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
 60L, TimeUnit.SECONDS,
 new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre>

<p>特点</p>

<ul>
<li><p>核心线程数是 0 ， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着</p>

<ul>
<li>全部都是救急线程（60s 后可以回收）</li>
<li>救急线程可以无限创建</li>
</ul></li>

<li><p>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交
货）</p>

<pre><code class="language-java">SynchronousQueue&lt;Integer&gt; integers = new SynchronousQueue&lt;&gt;();
new Thread(() -&gt; {
     try {
         log.debug(&quot;putting {} &quot;, 1);
         integers.put(1);
         log.debug(&quot;{} putted...&quot;, 1);
         log.debug(&quot;putting...{} &quot;, 2);
         integers.put(2);
         log.debug(&quot;{} putted...&quot;, 2);
     } catch (InterruptedException e) {
        e.printStackTrace();
     }
},&quot;t1&quot;).start();
sleep(1);
new Thread(() -&gt; {
     try {
        log.debug(&quot;taking {}&quot;, 1);
        integers.take();
     } catch (InterruptedException e) {
        e.printStackTrace();
     }
},&quot;t2&quot;).start();
sleep(1);
new Thread(() -&gt; {
     try {
        log.debug(&quot;taking {}&quot;, 2);
        integers.take();
     } catch (InterruptedException e) {
        e.printStackTrace();
     }
},&quot;t3&quot;).start();
</code></pre></li>
</ul>

<p>输出</p>

<pre><code>11:48:15.500 c.TestSynchronousQueue [t1] - putting 1 
11:48:16.500 c.TestSynchronousQueue [t2] - taking 1 
11:48:16.500 c.TestSynchronousQueue [t1] - 1 putted... 
11:48:16.500 c.TestSynchronousQueue [t1] - putting...2 
11:48:17.502 c.TestSynchronousQueue [t3] - taking 2 
11:48:17.503 c.TestSynchronousQueue [t1] - 2 putted...
</code></pre>

<blockquote>
<p>评价</p>

<p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1 分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况</p>
</blockquote>

<h3 id="5-newsinglethreadexecutor">5)newSingleThreadExecutor</h3>

<pre><code class="language-java">public static ExecutorService newSingleThreadExecutor() {//使用了装饰器模式
    return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1,
                                                                          0L, TimeUnit.MILLISECONDS,
                                                                          new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre>

<p>使用场景：</p>

<p>希望多个任务排队执行。线程数固定为 1 (即使某一次执行任务时出现一些异常或意想不到的错误，导致线程池中的线程崩溃，线程池也会重新创建一个线程来执行剩下的任务)，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p>

<p>区别：</p>

<ul>
<li><p>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</p></li>

<li><p>Executors.newSingleThreadExecutor() 线程个数始终为 1 ，不能修改</p>

<ul>
<li>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因
此不能调用 ThreadPoolExecutor 中特有的方法</li>
</ul></li>

<li><p>Executors.newFixedThreadPool(1) 初始时为 1 ，以后还可以修改
对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</p>

<pre><code class="language-java">ExecutorService pool = Executors.newSingleThreadExecutor();
    pool.execute(() -&gt; {
        log.debug(&quot;1&quot;);
        int i = 1 / 0;
    });

    pool.execute(() -&gt; {
        log.debug(&quot;2&quot;);
    });

    pool.execute(() -&gt; {
        log.debug(&quot;3&quot;);
    });
</code></pre></li>
</ul>

<h3 id="6-提交任务">6) 提交任务</h3>

<pre><code class="language-java">// 执行任务
void execute(Runnable command);
// 提交任务 task，用返回值 Future 获得任务执行结果
&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
// 提交 tasks 中所有任务
&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
 throws InterruptedException;
// 提交 tasks 中所有任务，带超时时间
&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
 long timeout, TimeUnit unit)
 throws InterruptedException;
// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消
&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
 throws InterruptedException, ExecutionException;
 // 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间
&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
 long timeout, TimeUnit unit)
 throws InterruptedException, ExecutionException, TimeoutException;
</code></pre>

<pre><code class="language-java">
@Slf4j(topic = &quot;c.TestSubmit&quot;)
public class TestSubmit {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(1);

    }

    private static void method3(ExecutorService pool) throws InterruptedException, ExecutionException {
        String result = pool.invokeAny(Arrays.asList(
                () -&gt; {
                    log.debug(&quot;begin 1&quot;);
                    Thread.sleep(1000);
                    log.debug(&quot;end 1&quot;);
                    return &quot;1&quot;;
                },
                () -&gt; {
                    log.debug(&quot;begin 2&quot;);
                    Thread.sleep(500);
                    log.debug(&quot;end 2&quot;);
                    return &quot;2&quot;;
                },
                () -&gt; {
                    log.debug(&quot;begin 3&quot;);
                    Thread.sleep(2000);
                    log.debug(&quot;end 3&quot;);
                    return &quot;3&quot;;
                }
        ));
        log.debug(&quot;{}&quot;, result);
    }

    private static void method2(ExecutorService pool) throws InterruptedException {
        List&lt;Future&lt;String&gt;&gt; futures = pool.invokeAll(Arrays.asList(
                () -&gt; {
                    log.debug(&quot;begin&quot;);
                    Thread.sleep(1000);
                    return &quot;1&quot;;
                },
                () -&gt; {
                    log.debug(&quot;begin&quot;);
                    Thread.sleep(500);
                    return &quot;2&quot;;
                },
                () -&gt; {
                    log.debug(&quot;begin&quot;);
                    Thread.sleep(2000);
                    return &quot;3&quot;;
                }
        ));

        futures.forEach( f -&gt;  {
            try {
                log.debug(&quot;{}&quot;, f.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
    }

    private static void method1(ExecutorService pool) throws InterruptedException, ExecutionException {
        Future&lt;String&gt; future = pool.submit(() -&gt; {
            log.debug(&quot;running&quot;);
            Thread.sleep(1000);
            return &quot;ok&quot;;
        });

        log.debug(&quot;{}&quot;, future.get());
    }
}

</code></pre>

<h3 id="7-关闭线程池">7) 关闭线程池</h3>

<p>shutdown</p>

<pre><code class="language-java">/*
线程池状态变为 SHUTDOWN
- 不会接收新任务
- 但已提交任务会执行完
- 此方法不会阻塞调用线程的执行
*/
void shutdown();
</code></pre>

<pre><code class="language-java">public void shutdown() {
 final ReentrantLock mainLock = this.mainLock;
 mainLock.lock();
 try {
     checkShutdownAccess();
     // 修改线程池状态
     advanceRunState(SHUTDOWN);
     // 仅会打断空闲线程
     interruptIdleWorkers();
     onShutdown(); // 扩展点 ScheduledThreadPoolExecutor
 } finally {
 	mainLock.unlock();
 }
     // 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)
     tryTerminate();
}
</code></pre>

<p><strong>shutdownNow</strong></p>

<pre><code class="language-java">/*
线程池状态变为 STOP
- 不会接收新任务
- 会将队列中的任务返回
- 并用 interrupt 的方式中断正在执行的任务
*/
List&lt;Runnable&gt; shutdownNow();
</code></pre>

<pre><code class="language-java">public List&lt;Runnable&gt; shutdownNow() {List&lt;Runnable&gt; tasks;
 final ReentrantLock mainLock = this.mainLock;
 mainLock.lock();
 try {
 checkShutdownAccess();
 // 修改线程池状态
 advanceRunState(STOP);
 // 打断所有线程
 interruptWorkers();
 // 获取队列中剩余任务
 tasks = drainQueue();
 } finally {
 mainLock.unlock();
 }
 // 尝试终结
 tryTerminate();
 return tasks; }
</code></pre>

<pre><code class="language-java">void shutdown();
public void shutdown() {
final ReentrantLock mainLock = this.mainLock;
mainLock.lock();
try {
checkShutdownAccess();
// 修改线程池状态
advanceRunState(SHUTDOWN);
// 仅会打断空闲线程
interruptIdleWorkers();
onShutdown(); // 扩展点 ScheduledThreadPoolExecutor
} finally {
mainLock.unlock();
}
// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)
tryTerminate();
}
</code></pre>

<h3 id="其它方法">其它方法</h3>

<pre><code class="language-java">// 不在 RUNNING 状态的线程池，此方法就返回 true
boolean isShutdown();
// 线程池状态是否是 TERMINATED
boolean isTerminated();
// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事
情，可以利用此方法等待
boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
</code></pre>

<pre><code class="language-java">
@Slf4j(topic = &quot;c.TestShutDown&quot;)
public class TestShutDown {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(2);

        Future&lt;Integer&gt; result1 = pool.submit(() -&gt; {
            log.debug(&quot;task 1 running...&quot;);
            Thread.sleep(1000);
            log.debug(&quot;task 1 finish...&quot;);
            return 1;
        });

        Future&lt;Integer&gt; result2 = pool.submit(() -&gt; {
            log.debug(&quot;task 2 running...&quot;);
            Thread.sleep(1000);
            log.debug(&quot;task 2 finish...&quot;);
            return 2;
        });

        Future&lt;Integer&gt; result3 = pool.submit(() -&gt; {
            log.debug(&quot;task 3 running...&quot;);
            Thread.sleep(1000);
            log.debug(&quot;task 3 finish...&quot;);
            return 3;
        });

        log.debug(&quot;shutdown&quot;);
//        pool.shutdown();//并不会等待其他线程结束（也就是不会等其他线程结束了之后再执行下面的代码，而会立即执行下面的代码）
//        pool.awaitTermination(3, TimeUnit.SECONDS);//如果需要等待 使用awaitTermination（这样的话不知道要等多久） 也可以使用feature的get方法阻塞住（不需要知道等多久，会一直等待结束）
        List&lt;Runnable&gt; runnables = pool.shutdownNow();//正在运行中的线程都会被打断   会返回还没有执行的线程
        log.debug(&quot;other.... {}&quot; , runnables);
    }
}

</code></pre>

<h3 id="模式之-worker-thread">* 模式之 Worker Thread</h3>

<h3 id="8-任务调度线程池">8) 任务调度线程池</h3>

<p>在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。</p>

<pre><code class="language-java">public static void main(String[] args) {
    Timer timer = new Timer();
    TimerTask task1 = new TimerTask() {
        @Override
        public void run() {
            log.debug(&quot;task 1&quot;);
            sleep(2);
            //任务一中出现了异常那么任务而也就没法接着执行下去
        }
    };
    TimerTask task2 = new TimerTask() {
        @Override
        public void run() {
            log.debug(&quot;task 2&quot;);
        }
    };
    // 使用 timer 添加两个任务，希望它们都在 1s 后执行
    // 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行
    timer.schedule(task1, 1000);
    timer.schedule(task2, 1000);
}
</code></pre>

<p>输出</p>

<pre><code>20:46:09.444 c.TestTimer [main] - start...
20:46:10.447 c.TestTimer [Timer-0] - task 1
20:46:12.448 c.TestTimer [Timer-0] - task 2
</code></pre>

<p>使用 ScheduledExecutorService 改写：</p>

<pre><code class="language-java">//线程池大小为2
ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);
// 添加两个任务，希望它们都在 1s 后执行
executor.schedule(() -&gt; {
    System.out.println(&quot;任务1，执行时间：&quot; + new Date());
    try { 
        Thread.sleep(2000); 
        //即使线程池设为1，任务一中即使出现异常也不会中断
    }catch (InterruptedException e) { 
    }
}, 1000, TimeUnit.MILLISECONDS);
executor.schedule(() -&gt; {
    System.out.println(&quot;任务2，执行时间：&quot; + new Date());
}, 1000, TimeUnit.MILLISECONDS);
</code></pre>

<p>输出</p>

<pre><code>任务 1 ，执行时间：Thu Jan 03 12:45:17 CST 2019
任务 2 ，执行时间：Thu Jan 03 12:45:17 CST 2019
</code></pre>

<p>scheduleAtFixedRate 例子：</p>

<p>每隔多少秒执行该任务(循环重复的执行)</p>

<pre><code class="language-java">ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
log.debug(&quot;start...&quot;);
pool.scheduleAtFixedRate(() -&gt; {
    //任务执行时间过长的话会等待任务执行完在执行(不会在延迟)
    log.debug(&quot;running...&quot;);
}, 1, 1, TimeUnit.SECONDS);
</code></pre>

<p>输出</p>

<pre><code>21:45:43.167 c.TestTimer [main] - start... 
21:45:44.215 c.TestTimer [pool-1-thread-1] - running... 
21:45:45.215 c.TestTimer [pool-1-thread-1] - running... 
21:45:46.215 c.TestTimer [pool-1-thread-1] - running... 
21:45:47.215 c.TestTimer [pool-1-thread-1] - running...
</code></pre>

<p>scheduleAtFixedRate 例子（任务执行时间超过了间隔时间）：</p>

<pre><code class="language-java">ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
log.debug(&quot;start...&quot;);
pool.scheduleAtFixedRate(() -&gt; {
    log.debug(&quot;running...&quot;);
    sleep(2);
    //任务执行时间过长的话会等待任务执行完在执行(会在执行完的基础上再延迟)
}, 1, 1, TimeUnit.SECONDS);
</code></pre>

<p>输出分析：一开始，延时 1s，接下来，由于任务执行时间 &gt; 间隔时间，间隔被『撑』到了 2s</p>

<pre><code>21:44:30.311 c.TestTimer [main] - start...
21:44:31.360 c.TestTimer [pool-1-thread-1] - running...
21:44:33.361 c.TestTimer [pool-1-thread-1] - running...
21:44:35.362 c.TestTimer [pool-1-thread-1] - running...
21:44:37.362 c.TestTimer [pool-1-thread-1] - running...
</code></pre>

<p>scheduleWithFixedDelay 例子：</p>

<pre><code class="language-java">ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
log.debug(&quot;start...&quot;);
pool.scheduleWithFixedDelay(()-&gt; {
    log.debug(&quot;running...&quot;);
    sleep(2);
}, 1, 1, TimeUnit.SECONDS);
</code></pre>

<p>输出分析：一开始，延时 1s，scheduleWithFixedDelay 的间隔是 上一个任务结束 &lt;-&gt; 延时 &lt;-&gt; 下一个任务开始 所 以间隔都是 3s</p>

<pre><code>21:40:55.078 c.TestTimer [main] - start...
21:40:56.140 c.TestTimer [pool-1-thread-1] - running...
21:40:59.143 c.TestTimer [pool-1-thread-1] - running...
21:41:02.145 c.TestTimer [pool-1-thread-1] - running...
21:41:05.147 c.TestTimer [pool-1-thread-1] - running...
</code></pre>

<blockquote>
<p>评价 整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放。用来执行延迟或反复执行的任务</p>
</blockquote>

<h3 id="9-正确处理执行任务异常">9) 正确处理执行任务异常</h3>

<h4 id="方法-1-主动捉异常">方法 1 ：主动捉异常</h4>

<pre><code class="language-java">ExecutorService pool = Executors.newFixedThreadPool(1);
pool.submit(() -&gt; {
 try {
     log.debug(&quot;task1&quot;);
     int i = 1 / 0;
 } catch (Exception e) {
 	log.error(&quot;error:&quot;, e);
 }
});
</code></pre>

<p>输出</p>

<pre><code>21:59:04.558 c.TestTimer [pool-1-thread-1] - task1 
21:59:04.562 c.TestTimer [pool-1-thread-1] - error: 
java.lang.ArithmeticException: / by zero 
 at cn.itcast.n8.TestTimer.lambda$main$0(TestTimer.java:28) 
 at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) 
 at java.util.concurrent.FutureTask.run(FutureTask.java:266) 
 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) 
 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 
 at java.lang.Thread.run(Thread.java:748)
</code></pre>

<h4 id="方法-2-使用-future">方法 2 ：使用 Future</h4>

<p>在任务执行时出现的异常信息会封装再Future对象中，调用get方法拿到的就不是返回值了，是异常信息</p>

<pre><code class="language-java">ExecutorService pool = Executors.newFixedThreadPool(1);
Future&lt;Boolean&gt; f = pool.submit(() -&gt; {
     log.debug(&quot;task1&quot;);
     int i = 1 / 0;
     return true;
});
log.debug(&quot;result:{}&quot;, f.get());
</code></pre>

<p>输出</p>

<pre><code>21:54:58.208 c.TestTimer [pool-1-thread-1] - task1 
Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: 
java.lang.ArithmeticException: / by zero 
 at java.util.concurrent.FutureTask.report(FutureTask.java:122) 
 at java.util.concurrent.FutureTask.get(FutureTask.java:192) 
 at cn.itcast.n8.TestTimer.main(TestTimer.java:31) 
Caused by: java.lang.ArithmeticException: / by zero 
 at cn.itcast.n8.TestTimer.lambda$main$0(TestTimer.java:28) 
 at java.util.concurrent.FutureTask.run(FutureTask.java:266) 
 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) 
 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 
 at java.lang.Thread.run(Thread.java:748);
</code></pre>

<h3 id="应用之定时任务">* 应用之定时任务</h3>

<h3 id="tomcat-线程池">Tomcat 线程池</h3>

<p>Tomcat 在哪里用到了线程池呢</p>

<pre><code class="language-mermaid">graph LR
  subgraph &quot;Connentor(NIO EndPoint)&quot;
	a1(LimitLatch)--&gt;b1(Acceptor)
	b1--&gt;c1(SocketChannel 1)
	b1--&gt;c2(SocketChannel 2)
	c1--有读--&gt;d1(Poller)
	c2--有读--&gt;d1
	subgraph Excutor
	q1(worker1)
	q2(worker2)
	end
	d1--socketProcesser--&gt;q1
	d1--socketProcesser--&gt;q2
  end


</code></pre>

<ul>
<li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲</li>
<li>Acceptor 只负责【接收新的 socket 连接】</li>
<li>Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】</li>
<li>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li>
<li>Executor 线程池中的工作线程最终负责【处理请求】</li>
</ul>

<p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</p>

<ul>
<li>如果总线程数达到 maximumPoolSize

<ul>
<li>这时不会立刻抛 RejectedExecutionException 异常</li>
<li>而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</li>
</ul></li>
</ul>

<p>合理分工是实现高并发的基础</p>

<p>源码 tomcat-7.0.42</p>

<pre><code class="language-java">public void execute(Runnable command, long timeout, TimeUnit unit) {
	 submittedCount.incrementAndGet();
     try {
        super.execute(command);
     } catch (RejectedExecutionException rx) {
         if (super.getQueue() instanceof TaskQueue) {
             final TaskQueue queue = (TaskQueue)super.getQueue();
             try {
                 if (!queue.force(command, timeout, unit)) {
                     submittedCount.decrementAndGet();
                     throw new RejectedExecutionException(&quot;Queue capacity is full.&quot;);
                 }
             } catch (InterruptedException x) {
                submittedCount.decrementAndGet();
                Thread.interrupted();
                throw new RejectedExecutionException(x);
             }
         } else {
            submittedCount.decrementAndGet();
            throw rx;
         }
     }
}
</code></pre>

<p>TaskQueue.java</p>

<pre><code class="language-java">public boolean force(Runnable o, long timeout, TimeUnit unit) throws InterruptedException {
 if ( parent.isShutdown() ) 
     throw new RejectedExecutionException(&quot;Executor not running, can't force a command into the queue&quot;);
 	return super.offer(o,timeout,unit); //forces the item onto the queue, to be used if the task is rejected
}
</code></pre>

<p>Connector 配置</p>

<table>
<thead>
<tr>
<th>配置项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>acceptorThreadCount</td>
<td>1</td>
<td>acceptor 线程数量</td>
</tr>

<tr>
<td>pollerThreadCount</td>
<td>1</td>
<td>poller 线程数量</td>
</tr>

<tr>
<td>minSpareThreads</td>
<td>10</td>
<td>核心线程数，即 corePoolSize</td>
</tr>

<tr>
<td>maxThreads</td>
<td>200</td>
<td>最大线程数，即 maximumPoolSize</td>
</tr>

<tr>
<td>executor</td>
<td>-</td>
<td>Executor 名称，用来引用下面的 Executor</td>
</tr>
</tbody>
</table>

<p>Executor 线程配置</p>

<table>
<thead>
<tr>
<th>配置项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>threadPriority</td>
<td>5</td>
<td>线程优先级</td>
</tr>

<tr>
<td>daemon</td>
<td>true</td>
<td>是否守护线程</td>
</tr>

<tr>
<td>minSpareThreads</td>
<td>25</td>
<td>核心线程数，即 corePoolSize</td>
</tr>

<tr>
<td>maxThreads</td>
<td>200</td>
<td>最大线程数，即 maximumPoolSize</td>
</tr>

<tr>
<td>maxIdleTime</td>
<td>60000</td>
<td>线程生存时间，单位是毫秒，默认值即 1 分钟</td>
</tr>

<tr>
<td>maxQueueSize</td>
<td>Integer.MAX_VALUE</td>
<td>队列长度</td>
</tr>

<tr>
<td>prestartminSpareThreads</td>
<td>false</td>
<td>核心线程是否在服务器启动时启动</td>
</tr>
</tbody>
</table>

<pre><code class="language-mermaid">graph LR
a(添加新任务)--&gt;b(提交任务&lt;核心线程)
b--是--&gt;c(加入队列)
b--否--&gt;d(提交任务&lt;最大线程)
d--否--&gt;c
d--是--&gt;e(创建急救线程)
</code></pre>

<p>tomcat中的线程是守护线程这就意味着一但tomcat的主线程停止，那么这些守护线程也都会停止。普通的线程池都是非守护线程。</p>

<p>tomcat会先给最大线程进行比较然后创建救急线程，然后再加入队列。</p>

<h3 id="fork-join">Fork/Join</h3>

<ol>
<li>概念</li>
</ol>

<p>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型
运算</p>

<p>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计
算，如归并排序、斐波那契数列、都可以用分治思想进行求解</p>

<p>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运
算效率</p>

<p><strong>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池</strong></p>

<p><strong>使用</strong></p>

<p>提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下
面定义了一个对 1~n 之间的整数求和的任务</p>

<pre><code class="language-java">
@Slf4j(topic = &quot;c.TestForkJoin2&quot;)
public class TestForkJoin2 {

    public static void main(String[] args) {
        ForkJoinPool pool = new ForkJoinPool(4);
        System.out.println(pool.invoke(new MyTask(5)));

        // new MyTask(5)  5+ new MyTask(4)  4 + new MyTask(3)  3 + new MyTask(2)  2 + new MyTask(1)
    }
}

// 1~n 之间整数的和
@Slf4j(topic = &quot;c.MyTask&quot;)
class MyTask extends RecursiveTask&lt;Integer&gt; {

    private int n;

    public MyTask(int n) {
        this.n = n;
    }

    @Override
    public String toString() {
        return &quot;{&quot; + n + '}';
    }
    @Override
    protected Integer compute() {
        // 如果 n 已经为 1，可以求得结果了
        if (n == 1) {
            log.debug(&quot;join() {}&quot;, n);
            return n;
        }
        // 将任务进行拆分(fork)
        AddTask1 t1 = new AddTask1(n - 1);
        t1.fork();
        log.debug(&quot;fork() {} + {}&quot;, n, t1);
        // 合并(join)结果
        int result = n + t1.join();
        log.debug(&quot;join() {} + {} = {}&quot;, n, t1, result);
        return result;
    }
}
</code></pre>

<p>结果</p>

<pre><code>[ForkJoinPool-1-worker-0] - fork() 2 + {1} 
[ForkJoinPool-1-worker-1] - fork() 5 + {4} 
[ForkJoinPool-1-worker-0] - join() 1 
[ForkJoinPool-1-worker-0] - join() 2 + {1} = 3 
[ForkJoinPool-1-worker-2] - fork() 4 + {3} 
[ForkJoinPool-1-worker-3] - fork() 3 + {2} 
[ForkJoinPool-1-worker-3] - join() 3 + {2} = 6 
[ForkJoinPool-1-worker-2] - join() 4 + {3} = 10 
[ForkJoinPool-1-worker-1] - join() 5 + {4} = 15 
15
</code></pre>

<p>用图来表示</p>

<pre><code class="language-mermaid">graph LR
a(&quot;t1 5 + {4}&quot;)-.15.-&gt;b(&quot;结果&quot;)
a--&quot;{4}&quot;--&gt;c(&quot;t2 4 + {3}&quot;)
c-.&quot;10&quot;.-&gt;a
c--&quot;{3}&quot;--&gt;d(&quot;t3 3 + {2}&quot;)
d-.6.-&gt;c
d--&quot;{2}&quot;--&gt;e(&quot;t0 2 + {1}&quot;)
e-.3.-&gt;d
e--&quot;{1}&quot;--&gt;f(t0)
f-.1.-&gt;e
</code></pre>

<p>改进</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.AddTask&quot;)
class AddTask3 extends RecursiveTask&lt;Integer&gt; {
    int begin;
    int end;
    public AddTask3(int begin, int end) {
        this.begin = begin;
        this.end = end;
    }
    @Override
    public String toString() {
        return &quot;{&quot; + begin + &quot;,&quot; + end + '}';
    }
    @Override
    protected Integer compute() {
        if (begin == end) {
            log.debug(&quot;join() {}&quot;, begin);
            return begin;
        }
        if (end - begin == 1) {
            log.debug(&quot;join() {} + {} = {}&quot;, begin, end, end + begin);
            return end + begin;
        }
        int mid = (end + begin) / 2;
        AddTask3 t1 = new AddTask3(begin, mid);
        t1.fork();
        AddTask3 t2 = new AddTask3(mid + 1, end);
        t2.fork();
        log.debug(&quot;fork() {} + {} = ?&quot;, t1, t2);
        int result = t1.join() + t2.join();
        log.debug(&quot;join() {} + {} = {}&quot;, t1, t2, result);
        return result;
    }
}
</code></pre>

<p>然后提交给 ForkJoinPool 来执行</p>

<pre><code class="language-java">public static void main(String[] args) {
     ForkJoinPool pool = new ForkJoinPool(4);
     System.out.println(pool.invoke(new AddTask3(1, 10)));
}
</code></pre>

<p>结果</p>

<pre><code>[ForkJoinPool-1-worker-0] - join() 1 + 2 = 3
[ForkJoinPool-1-worker-3] - join() 4 + 5 = 9
[ForkJoinPool-1-worker-0] - join() 3
[ForkJoinPool-1-worker-1] - fork() {1,3} + {4,5} =?
[ForkJoinPool-1-worker-2] - fork() {1,2} + {3,3} =?
[ForkJoinPool-1-worker-2] - join() {1,2} + {3,3} = 6
[ForkJoinPool-1-worker-1] - join() {1,3} + {4,5} = 15
15
</code></pre>

<h3 id="用图来表示-1">用图来表示</h3>

<pre><code class="language-mermaid">graph LR
a(&quot;t1 {1,3} + {4,5}&quot;)--&quot;{1,3}&quot;--&gt;b(&quot;t2 {1,2} + {3,3}&quot;)
b--&quot;{3,3}&quot;--&gt;c(&quot;t0&quot;)
a--&quot;{4,5}&quot;--&gt;d(&quot;t3&quot;)
a-.&quot;15&quot;.-&gt;e(结果)
d-.9.-&gt;a
b-.6.-&gt;a
b--&quot;{1,2}&quot;--&gt;c
c-.3.-&gt;b
c-.3.-&gt;b
</code></pre>

<h2 id="8-2-j-u-c">8.2 J.U.C</h2>

<h3 id="1-aqs-原理">1.* AQS 原理</h3>

<h3 id="2-reentrantlock-原理">2.* ReentrantLock 原理</h3>

<h3 id="3-读写锁">3.读写锁</h3>

<h4 id="3-1-reentrantreadwritelock">3.1 ReentrantReadWriteLock</h4>

<p>当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。 类似于数据库中的 select &hellip;
from &hellip; lock in share mode</p>

<p>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p>

<pre><code class="language-java">class DataContainer {
    private Object data;
    //读写锁
    private ReentrantReadWriteLock rw = new ReentrantReadWriteLock();
    //读锁
    private ReentrantReadWriteLock.ReadLock r = rw.readLock();
    //写锁
    private ReentrantReadWriteLock.WriteLock w = rw.writeLock();
    public Object read() {
        log.debug(&quot;获取读锁...&quot;);
        r.lock();
        try {
            log.debug(&quot;读取&quot;);
            sleep(1);
            return data;
        } finally {
            log.debug(&quot;释放读锁...&quot;);r.unlock();
        }
    }
    public void write() {
        log.debug(&quot;获取写锁...&quot;);
        w.lock();
        try {
            log.debug(&quot;写入&quot;);
            sleep(1);
        } finally {
            log.debug(&quot;释放写锁...&quot;);
            w.unlock();
        }
    }
}
</code></pre>

<p>测试 读锁-读锁 可以并发</p>

<pre><code class="language-java">DataContainer dataContainer = new DataContainer();
new Thread(() -&gt; {
    dataContainer.read();
}, &quot;t1&quot;).start();
new Thread(() -&gt; {
    dataContainer.read();
}, &quot;t2&quot;).start();
</code></pre>

<p>输出结果，从这里可以看到 Thread-0 锁定期间，Thread-1 的读操作不受影响</p>

<pre><code>14:05:14.341 c.DataContainer [t2] - 获取读锁...
14:05:14.341 c.DataContainer [t1] - 获取读锁...
14:05:14.345 c.DataContainer [t1] - 读取
14:05:14.345 c.DataContainer [t2] - 读取
14:05:15.365 c.DataContainer [t2] - 释放读锁...
14:05:15.386 c.DataContainer [t1] - 释放读锁...
</code></pre>

<p>测试 读锁-写锁 相互阻塞</p>

<pre><code class="language-java">DataContainer dataContainer = new DataContainer();
new Thread(() -&gt; {
    dataContainer.read();
}, &quot;t1&quot;).start();
Thread.sleep(100);
new Thread(() -&gt; {
    dataContainer.write();
}, &quot;t2&quot;).start();
</code></pre>

<p>输出结果</p>

<pre><code>14:04:21.838 c.DataContainer [t1] - 获取读锁... 
14:04:21.838 c.DataContainer [t2] - 获取写锁... 
14:04:21.841 c.DataContainer [t2] - 写入
14:04:22.843 c.DataContainer [t2] - 释放写锁... 
14:04:22.843 c.DataContainer [t1] - 读取
14:04:23.843 c.DataContainer [t1] - 释放读锁...
</code></pre>

<p>写锁-写锁 也是相互阻塞的，这里就不测试了</p>

<p>读读可以并发，读写、写写是互斥的</p>

<p>注意事项</p>

<ul>
<li><p>读锁不支持条件变量</p></li>

<li><p>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</p>

<pre><code class="language-java">r.lock();
try {
 // ...
 w.lock();
 try {
 // ...
 } finally{
 w.unlock();
 }
} finally{
 r.unlock();
}
</code></pre></li>

<li><p>重入时降级支持：即持有写锁的情况下去获取读锁</p>

<pre><code class="language-java">class CachedData {
Object data;
// 是否有效，如果失效，需要重新计算 data
volatile boolean cacheValid;
final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
void processCachedData() {
    rwl.readLock().lock();
    if (!cacheValid) {
        // 获取写锁前必须释放读锁
        rwl.readLock().unlock();
        rwl.writeLock().lock();
        try {
            // 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新
            if (!cacheValid) {
                data = ...
                    cacheValid = true;
            }
            // 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存
            rwl.readLock().lock();
        } finally {rwl.writeLock().unlock();
                  }
    }
    // 自己用完数据, 释放读锁 
    try {
        use(data);
    } finally {
        rwl.readLock().unlock();
    }
}
}
</code></pre></li>
</ul>

<h4 id="应用之缓存">* 应用之缓存</h4>

<h4 id="读写锁原理">* 读写锁原理</h4>

<h4 id="3-2-stampedlock">3.2 StampedLock</h4>

<p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p>

<p>加解读锁</p>

<pre><code class="language-java">long stamp = lock.readLock();
lock.unlockRead(stamp);
</code></pre>

<p>加解写锁</p>

<pre><code class="language-java">long stamp = lock.writeLock();
lock.unlockWrite(stamp);
</code></pre>

<p>乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通
过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p>

<pre><code class="language-java">long stamp = lock.tryOptimisticRead();
// 验戳
if(!lock.validate(stamp)){
 // 锁升级
}
</code></pre>

<p>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p>

<pre><code class="language-java">class DataContainerStamped {
    private int data;private final StampedLock lock = new StampedLock();
    public DataContainerStamped(int data) {
        this.data = data;
    }
    public int read(int readTime) {
        long stamp = lock.tryOptimisticRead();
        log.debug(&quot;optimistic read locking...{}&quot;, stamp);
        sleep(readTime);
        if (lock.validate(stamp)) {
            log.debug(&quot;read finish...{}, data:{}&quot;, stamp, data);
            return data;
        }
        // 锁升级 - 读锁
        log.debug(&quot;updating to read lock... {}&quot;, stamp);
        try {
            stamp = lock.readLock();
            log.debug(&quot;read lock {}&quot;, stamp);
            sleep(readTime);
            log.debug(&quot;read finish...{}, data:{}&quot;, stamp, data);
            return data;
        } finally {
            log.debug(&quot;read unlock {}&quot;, stamp);
            lock.unlockRead(stamp);
        }
    }
    public void write(int newData) {
        long stamp = lock.writeLock();
        log.debug(&quot;write lock {}&quot;, stamp);
        try {
            sleep(2);
            this.data = newData;
        } finally {
            log.debug(&quot;write unlock {}&quot;, stamp);
            lock.unlockWrite(stamp);
        }
    }
}
</code></pre>

<p>测试 读-读 可以优化</p>

<pre><code class="language-java">public static void main(String[] args) {
    DataContainerStamped dataContainer = new DataContainerStamped(1);
    new Thread(() -&gt; {
        dataContainer.read(1);
    }, &quot;t1&quot;).start();
    sleep(0.5);
    new Thread(() -&gt; {
        dataContainer.read(0);
    }, &quot;t2&quot;).start();
}
</code></pre>

<p>输出结果，可以看到实际没有加读锁</p>

<pre><code>15:58:50.217 c.DataContainerStamped [t1] - optimistic read locking...256 
15:58:50.717 c.DataContainerStamped [t2] - optimistic read locking...256 
15:58:50.717 c.DataContainerStamped [t2] - read finish...256, data:1 
15:58:51.220 c.DataContainerStamped [t1] - read finish...256, data:1
</code></pre>

<p>测试 读-写 时优化读补加读锁</p>

<pre><code class="language-java">public static void main(String[] args) {
    DataContainerStamped dataContainer = new DataContainerStamped(1);
    new Thread(() -&gt; {
        dataContainer.read(1);
    }, &quot;t1&quot;).start();
    sleep(0.5);
    new Thread(() -&gt; {
        dataContainer.write(100);
    }, &quot;t2&quot;).start();
}
</code></pre>

<p>输出结果</p>

<pre><code>15:57:00.219 c.DataContainerStamped [t1] - optimistic read locking...256 
15:57:00.717 c.DataContainerStamped [t2] - write lock 384 
15:57:01.225 c.DataContainerStamped [t1] - updating to read lock... 256 
15:57:02.719 c.DataContainerStamped [t2] - write unlock 384 
15:57:02.719 c.DataContainerStamped [t1] - read lock 513 
15:57:03.719 c.DataContainerStamped [t1] - read finish...513, data:1000 
15:57:03.719 c.DataContainerStamped [t1] - read unlock 513
</code></pre>

<p>注意</p>

<blockquote>
<p>StampedLock 不支持条件变量
StampedLock 不支持可重入</p>
</blockquote>

<h3 id="4-semaphore">4.Semaphore</h3>

<h4 id="基本使用-1">基本使用</h4>

<p>信号量，用来限制能同时访问共享资源的线程上限。</p>

<pre><code class="language-java">public static void main(String[] args) {
    // 1. 创建 semaphore 对象
    Semaphore semaphore = new Semaphore(3);
    // 2. 10个线程同时运行
    for (int i = 0; i &lt; 10; i++) {
        new Thread(() -&gt; {
            // 3. 获取许可
            try {
                semaphore.acquire();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            try {
                log.debug(&quot;running...&quot;);
                sleep(1);
                log.debug(&quot;end...&quot;);
            } finally {
                // 4. 释放许可
                semaphore.release();
            }
        }).start();
    }
}
</code></pre>

<p>输出</p>

<pre><code>07:35:15.485 c.TestSemaphore [Thread-2] - running... 
07:35:15.485 c.TestSemaphore [Thread-1] - running... 
07:35:15.485 c.TestSemaphore [Thread-0] - running... 
07:35:16.490 c.TestSemaphore [Thread-2] - end... 
07:35:16.490 c.TestSemaphore [Thread-0] - end... 
07:35:16.490 c.TestSemaphore [Thread-1] - end... 
07:35:16.490 c.TestSemaphore [Thread-3] - running... 
07:35:16.490 c.TestSemaphore [Thread-5] - running... 
07:35:16.490 c.TestSemaphore [Thread-4] - running... 
07:35:17.490 c.TestSemaphore [Thread-5] - end... 
07:35:17.490 c.TestSemaphore [Thread-4] - end... 
07:35:17.490 c.TestSemaphore [Thread-3] - end... 
07:35:17.490 c.TestSemaphore [Thread-6] - running... 
07:35:17.490 c.TestSemaphore [Thread-7] - running... 
07:35:17.490 c.TestSemaphore [Thread-9] - running... 
07:35:18.491 c.TestSemaphore [Thread-6] - end... 
07:35:18.491 c.TestSemaphore [Thread-7] - end... 
07:35:18.491 c.TestSemaphore [Thread-9] - end... 
07:35:18.491 c.TestSemaphore [Thread-8] - running... 
07:35:19.492 c.TestSemaphore [Thread-8] - end...
</code></pre>

<h4 id="应用-限制-限制对共享资源的使用">* 应用 &ndash;限制 &ndash; 限制对共享资源的使用</h4>

<h4 id="semaphore-原理">* Semaphore 原理</h4>

<h3 id="5-countdownlatch">5.CountdownLatch</h3>

<p>用来进行线程同步协作，等待所有线程完成倒计时。</p>

<p>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</p>

<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(3);
    new Thread(() -&gt; {
        log.debug(&quot;begin...&quot;);
        sleep(1);
        latch.countDown();
        log.debug(&quot;end...{}&quot;, latch.getCount());
    }).start();
    new Thread(() -&gt; {
        log.debug(&quot;begin...&quot;);
        sleep(2);
        latch.countDown();
        log.debug(&quot;end...{}&quot;, latch.getCount());
    }).start();
    new Thread(() -&gt; {
        log.debug(&quot;begin...&quot;);
        sleep(1.5);
        latch.countDown();
        log.debug(&quot;end...{}&quot;, latch.getCount());
    }).start();
    log.debug(&quot;waiting...&quot;);
    latch.await();
    log.debug(&quot;wait end...&quot;);
}
</code></pre>

<p>输出</p>

<pre><code>18:44:00.778 c.TestCountDownLatch [main] - waiting... 
18:44:00.778 c.TestCountDownLatch [Thread-2] - begin... 
18:44:00.778 c.TestCountDownLatch [Thread-0] - begin... 
18:44:00.778 c.TestCountDownLatch [Thread-1] - begin... 
18:44:01.782 c.TestCountDownLatch [Thread-0] - end...2 
18:44:02.283 c.TestCountDownLatch [Thread-2] - end...1 
18:44:02.782 c.TestCountDownLatch [Thread-1] - end...0 
18:44:02.782 c.TestCountDownLatch [main] - wait end...
</code></pre>

<p>可以配合线程池使用，改进如下</p>

<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(3);
    ExecutorService service = Executors.newFixedThreadPool(4);
    service.submit(() -&gt; {
        log.debug(&quot;begin...&quot;);
        sleep(1);
        latch.countDown();
        log.debug(&quot;end...{}&quot;, latch.getCount());
    });
    service.submit(() -&gt; {
        log.debug(&quot;begin...&quot;);
        sleep(1.5);
        latch.countDown();
        log.debug(&quot;end...{}&quot;, latch.getCount());
    });
    service.submit(() -&gt; {
        log.debug(&quot;begin...&quot;);
        sleep(2);
        latch.countDown();
        log.debug(&quot;end...{}&quot;, latch.getCount());
    });
    service.submit(()-&gt;{
        try {
            log.debug(&quot;waiting...&quot;);
            latch.await();
            log.debug(&quot;wait end...&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
}
</code></pre>

<p>输出</p>

<pre><code>18:52:25.831 c.TestCountDownLatch [pool-1-thread-3] - begin...
18:52:25.831 c.TestCountDownLatch [pool-1-thread-1] - begin...
18:52:25.831 c.TestCountDownLatch [pool-1-thread-2] - begin...
18:52:25.831 c.TestCountDownLatch [pool-1-thread-4] - waiting...
18:52:26.835 c.TestCountDownLatch [pool-1-thread-1] - end...2
18:52:27.335 c.TestCountDownLatch [pool-1-thread-2] - end...1
18:52:27.835 c.TestCountDownLatch [pool-1-thread-3] - end...0
18:52:27.835 c.TestCountDownLatch [pool-1-thread-4] - wait end...
</code></pre>

<h4 id="应用之同步等待多线程准备完毕">* 应用之同步等待多线程准备完毕</h4>

<pre><code class="language-java">AtomicInteger num = new AtomicInteger(0);
        ExecutorService service = Executors.newFixedThreadPool(10, (r) -&gt; {
            return new Thread(r, &quot;t&quot; + num.getAndIncrement());
        });
        CountDownLatch latch = new CountDownLatch(10);
        String[] all = new String[10];
        Random r = new Random();
        for (int j = 0; j &lt; 10; j++) {
            int x = j;
            service.submit(() -&gt; {
                for (int i = 0; i &lt;= 100; i++) {
                    try {
                        Thread.sleep(r.nextInt(100));
                    } catch (InterruptedException e) {
                    }
                    all[x] = Thread.currentThread().getName() + &quot;(&quot; + (i + &quot;%&quot;) + &quot;)&quot;;
                    System.out.print(&quot;\r&quot; + Arrays.toString(all));
                }
                latch.countDown();
            });
        }
        latch.await();
        System.out.println(&quot;\n游戏开始...&quot;);
        service.shutdown();
</code></pre>

<p>中间输出</p>

<pre><code>[t0(52%), t1(47%), t2(51%), t3(40%), t4(49%), t5(44%), t6(49%), t7(52%), t8(46%), t9(46%)]
</code></pre>

<p>最后输出</p>

<pre><code>[t0(100%), t1(100%), t2(100%), t3(100%), t4(100%), t5(100%), t6(100%), t7(100%), t8(100%),
t9(100%)]
游戏开始...
</code></pre>

<p>*** 应用之同步等待多个远程调用结束**</p>

<pre><code class="language-java">
@RestController
public class TestCountDownlatchController {

    @GetMapping(&quot;/order/{id}&quot;)
    public Map&lt;String, Object&gt; order(@PathVariable int id) {
        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;id&quot;, id);
        map.put(&quot;total&quot;, &quot;2300.00&quot;);
        sleep(2000);
        return map;
    }

    @GetMapping(&quot;/product/{id}&quot;)
    public Map&lt;String, Object&gt; product(@PathVariable int id) {
        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        if (id == 1) {
            map.put(&quot;name&quot;, &quot;小爱音箱&quot;);
            map.put(&quot;price&quot;, 300);
        } else if (id == 2) {
            map.put(&quot;name&quot;, &quot;小米手机&quot;);
            map.put(&quot;price&quot;, 2000);
        }
        map.put(&quot;id&quot;, id);
        sleep(1000);
        return map;
    }

    @GetMapping(&quot;/logistics/{id}&quot;)
    public Map&lt;String, Object&gt; logistics(@PathVariable int id) {
        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;id&quot;, id);
        map.put(&quot;name&quot;, &quot;中通快递&quot;);
        sleep(2500);
        return map;
    }

    private void sleep(int millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

</code></pre>

<p>rest 远程调用</p>

<pre><code class="language-java"> private static void test3() throws InterruptedException, ExecutionException {
        RestTemplate restTemplate = new RestTemplate();
        log.debug(&quot;begin&quot;);
        ExecutorService service = Executors.newCachedThreadPool();
        CountDownLatch latch = new CountDownLatch(4);
        Future&lt;Map&lt;String,Object&gt;&gt; f1 = service.submit(() -&gt; {
            Map&lt;String, Object&gt; response = restTemplate.getForObject(&quot;http://localhost:8080/order/{1}&quot;, Map.class, 1);
            return response;
        });
        Future&lt;Map&lt;String, Object&gt;&gt; f2 = service.submit(() -&gt; {
            Map&lt;String, Object&gt; response1 = restTemplate.getForObject(&quot;http://localhost:8080/product/{1}&quot;, Map.class, 1);
            return response1;
        });
        Future&lt;Map&lt;String, Object&gt;&gt; f3 = service.submit(() -&gt; {
            Map&lt;String, Object&gt; response1 = restTemplate.getForObject(&quot;http://localhost:8080/product/{1}&quot;, Map.class, 2);
            return response1;
        });
        Future&lt;Map&lt;String, Object&gt;&gt; f4 = service.submit(() -&gt; {
            Map&lt;String, Object&gt; response3 = restTemplate.getForObject(&quot;http://localhost:8080/logistics/{1}&quot;, Map.class, 1);
            return response3;
        });

        System.out.println(f1.get());
        System.out.println(f2.get());
        System.out.println(f3.get());
        System.out.println(f4.get());
        log.debug(&quot;执行完毕&quot;);
        service.shutdown();
    }
</code></pre>

<p>执行结果</p>

<pre><code>19:51:39.711 c.TestCountDownLatch [main] - begin
{total=2300.00, id=1}
{price=300, name=小爱音箱, id=1}
{price=2000, name=小米手机, id=2}
{name=中通快递, id=1}
19:51:42.407 c.TestCountDownLatch [main] - 执行完毕
</code></pre>

<h3 id="6-cyclicbarrier">6.CyclicBarrier</h3>

<p>循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p>

<pre><code class="language-java">CyclicBarrier cb = new CyclicBarrier(2); // 个数为2时才会继续执行
new Thread(()-&gt;{
    System.out.println(&quot;线程1开始..&quot;+new Date());
    try {
        cb.await(); // 当个数不足时，等待
    } catch (InterruptedException | BrokenBarrierException e) {
        e.printStackTrace();
    }
    System.out.println(&quot;线程1继续向下运行...&quot;+new Date());
}).start();
new Thread(()-&gt;{
    System.out.println(&quot;线程2开始..&quot;+new Date());
    try { Thread.sleep(2000); } catch (InterruptedException e) { }
    try {
        cb.await(); // 2 秒后，线程个数够2，继续运行
    } catch (InterruptedException | BrokenBarrierException e) {
        e.printStackTrace();
    }
    System.out.println(&quot;线程2继续向下运行...&quot;+new Date());
}).start();
</code></pre>

<blockquote>
<p><strong>注意</strong> CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是可以重用的 CyclicBarrier 可以被比</p>

<p>喻为『人满发车』</p>
</blockquote>

<pre><code class="language-java">
@Slf4j(topic = &quot;c.TestCyclicBarrier&quot;)
public class TestCyclicBarrier {

    public static void main(String[] args) {
        //二者的计数要一样才会有效果
        ExecutorService service = Executors.newFixedThreadPool(2);
        CyclicBarrier barrier = new CyclicBarrier(2, ()-&gt; {
            log.debug(&quot;task1, task2 finish...&quot;);
        });
        //当线程数为newFixedThreadPool(3);的时候会执行task1(1s)  task2(2s)  task1(1s),那么此时的先结束的两个是test1和第二轮的test1，就不是task1和task2
        for (int i = 0; i &lt; 3; i++) { // task1  task2  task1
            service.submit(() -&gt; {
                log.debug(&quot;task1 begin...&quot;);
                sleep(1);
                try {
                    barrier.await(); // 2-1=1
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            });
            service.submit(() -&gt; {
                log.debug(&quot;task2 begin...&quot;);
                sleep(2);
                try {
                    barrier.await(); // 1-1=0
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            });
        }
        service.shutdown();

    }

    private static void test1() {
        ExecutorService service = Executors.newFixedThreadPool(5);
        for (int i = 0; i &lt; 3; i++) {
            CountDownLatch latch = new CountDownLatch(2);
            service.submit(() -&gt; {
                log.debug(&quot;task1 start...&quot;);
                sleep(1);
                latch.countDown();
            });
            service.submit(() -&gt; {
                log.debug(&quot;task2 start...&quot;);
                sleep(2);
                latch.countDown();
            });
            try {
                latch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.debug(&quot;task1 task2 finish...&quot;);
        }
        service.shutdown();
    }
}

</code></pre>

<h3 id="7-线程安全集合类概述">7. 线程安全集合类概述</h3>

<pre><code class="language-mermaid">graph TB
a(遗留的安全集合)--&gt;b(Hashtable)
a--&gt;c(Ventor)
a2(修饰的安全集合)--使用Collections的方法修饰--&gt;b2(SynchronizedMap)
a2--使用Collections的方法修饰--&gt;c2(SynchronizedList)
a3(J.U.C安全集合)--&gt;b3(Blocking类)
a3--&gt;c3(CopyOnWrite类)
a3--&gt;d3(Concurrent类)
</code></pre>

<p>线程安全集合类可以分为三大类：</p>

<ul>
<li>遗留的线程安全集合如 Hashtable，Vector</li>
<li>使用 Collections 装饰的线程安全集合，如：

<ul>
<li>Collections.synchronizedCollection</li>
<li>Collections.synchronizedList</li>
<li>Collections.synchronizedMap</li>
<li>Collections.synchronizedSet</li>
<li>Collections.synchronizedNavigableMap</li>
<li>Collections.synchronizedNavigableSet</li>
<li>Collections.synchronizedSortedMap</li>
<li>Collections.synchronizedSortedSet</li>
</ul></li>
<li>java.util.concurrent.*</li>
</ul>

<p>重点介绍java.util.concurrent.* 下的线程安全集合类，可以发现它们有规律，里面包含三类关键词：
Blocking、CopyOnWrite、Concurrent</p>

<ul>
<li><p>Blocking 大部分实现基于锁，并提供用来阻塞的方法</p></li>

<li><p>CopyOnWrite 之类容器修改开销相对较重（适用于读多写少的场景）</p></li>

<li><p>Concurrent 类型的容器（推荐使用）</p>

<ul>
<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量</li>
<li>弱一致性

<ul>
<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍
历，这时内容是旧的</li>
<li>求大小弱一致性，size 操作未必是 100% 准确</li>
<li>读取弱一致性</li>
</ul></li>
</ul>

<blockquote>
<p>遍历时如果发生了修改，对于非安全容器来讲，使用 fail-fast 机制也就是让遍历立刻失败，抛出
ConcurrentModificationException，不再继续遍历</p>
</blockquote></li>
</ul>

<h3 id="8-concurrenthashmap">8.ConcurrentHashMap</h3>

<p>练习：单词计数</p>

<p>生成测试数据</p>

<pre><code class="language-java">static final String ALPHA = &quot;abcedfghijklmnopqrstuvwxyz&quot;;
public static void main(String[] args) {
    int length = ALPHA.length();
    int count = 200;
    List&lt;String&gt; list = new ArrayList&lt;&gt;(length * count);
    for (int i = 0; i &lt; length; i++) {
        char ch = ALPHA.charAt(i);
        for (int j = 0; j &lt; count; j++) {
            list.add(String.valueOf(ch));
        }
    }
    Collections.shuffle(list);
    for (int i = 0; i &lt; 26; i++) {
        try (PrintWriter out = new PrintWriter(
            new OutputStreamWriter(
                new FileOutputStream(&quot;tmp/&quot; + (i+1) + &quot;.txt&quot;)))) {
            String collect = list.subList(i * count, (i + 1) * count).stream()
                .collect(Collectors.joining(&quot;\n&quot;));
            out.print(collect);
        } catch (IOException e) {
        }
    }
}
</code></pre>

<p>模版代码，模版代码中封装了多线程读取文件的代码</p>

<pre><code class="language-java">private static &lt;V&gt; void demo(Supplier&lt;Map&lt;String,V&gt;&gt; supplier, 
                             BiConsumer&lt;Map&lt;String,V&gt;,List&lt;String&gt;&gt; consumer) {
    Map&lt;String, V&gt; counterMap = supplier.get();
    List&lt;Thread&gt; ts = new ArrayList&lt;&gt;();
    for (int i = 1; i &lt;= 26; i++) {
        int idx = i;
        Thread thread = new Thread(() -&gt; {
            List&lt;String&gt; words = readFromFile(idx);
            consumer.accept(counterMap, words);
        });
        ts.add(thread);
    }
    ts.forEach(t-&gt;t.start());
    ts.forEach(t-&gt; {
        try {
            t.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
    System.out.println(counterMap);
}
public static List&lt;String&gt; readFromFile(int i) {
    ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;();
    try (BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;tmp/&quot;
                                                                                          + i +&quot;.txt&quot;)))) {
        while(true) {
            String word = in.readLine();
            if(word == null) {
                break;
            }
            words.add(word);
        }
        return words;
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
</code></pre>

<p>你要做的是实现两个参数</p>

<ul>
<li>一是提供一个 map 集合，用来存放每个单词的计数结果，key 为单词，value 为计数</li>
<li>二是提供一组操作，保证计数的安全性，会传递 map 集合以及 单词 List</li>
</ul>

<p>正确结果输出应该是每个单词出现 200 次</p>

<pre><code>{a=200, b=200, c=200, d=200, e=200, f=200, g=200, h=200, i=200, j=200, k=200, l=200, m=200,
n=200, o=200, p=200, q=200, r=200, s=200, t=200, u=200, v=200, w=200, x=200, y=200, z=200}
</code></pre>

<p>下面的实现为：</p>

<pre><code class="language-java">demo(
    // 创建 map 集合
    // 创建 ConcurrentHashMap 对不对？
    () -&gt; new HashMap&lt;String, Integer&gt;(),
    // 进行计数
    (map, words) -&gt; {
        for (String word : words) {
            Integer counter = map.get(word);
            int newValue = counter == null ? 1 : counter + 1;
            map.put(word, newValue);
        }
    }
);
</code></pre>

<p>有没有问题？请改进</p>

<p>参考解答 1</p>

<pre><code class="language-java">demo(
    //LongAdder累加器
    () -&gt; new ConcurrentHashMap&lt;String, LongAdder&gt;(),
    (map, words) -&gt; {
        for (String word : words) {
            // 注意不能使用 putIfAbsent，此方法返回的是上一次的 value，首次调用返回 null
            //如果缺少一个key，则计算生成一个value，然后将key value放入map 
            map.computeIfAbsent(word, (key) -&gt; new LongAdder()).increment();
        }
    }
);
</code></pre>

<p>参考解答 2</p>

<pre><code class="language-java">demo(
    () -&gt; new ConcurrentHashMap&lt;String, Integer&gt;(),
    (map, words) -&gt; {
        for (String word : words) {
            // 函数式编程，无需原子变量
            map.merge(word, 1, Integer::sum);
        }
    }
);
</code></pre>

<h4 id="concurrenthashmap-原理">* ConcurrentHashMap 原理</h4>

<h3 id="9-blockingqueue">9.BlockingQueue</h3>

<h4 id="blockingqueue-原理">* BlockingQueue 原理</h4>

<h3 id="10-concurrentlinkedqueue">10.ConcurrentLinkedQueue</h3>

<p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是</p>

<ul>
<li>两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</li>
<li>dummy 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争</li>
<li>只是这【锁】使用了 cas 来实现</li>
</ul>

<p>事实上，ConcurrentLinkedQueue 应用还是非常广泛的</p>

<p>例如之前讲的 Tomcat 的 Connector 结构时，Acceptor 作为生产者向 Poller 消费者传递事件信息时，正是采用了
ConcurrentLinkedQueue 将 SocketChannel 给 Poller 使用</p>

<p><strong>CopyOnWriteArrayList</strong></p>

<p>CopyOnWriteArraySet 是它的马甲 底层实现采用了 写入时拷贝 的思想，增删改操作会将底层数组拷贝一份，更
改操作在新数组上执行，这时不影响其它线程的并发读，读写分离。 以新增为例：</p>

<pre><code class="language-java">public boolean add(E e) {
    synchronized (lock) {
        // 获取旧的数组
        Object[] es = getArray();
        int len = es.length;
        // 拷贝新的数组（这里是比较耗时的操作，但不影响其它读线程）
        es = Arrays.copyOf(es, len + 1);
        // 添加新元素
        es[len] = e;
        // 替换旧的数组
        setArray(es);
        return true;
    }
}
</code></pre>

<p>其它读操作并未加锁，例如：</p>

<pre><code class="language-java">public void forEach(Consumer&lt;? super E&gt; action) {
    Objects.requireNonNull(action);
    for (Object x : getArray()) {
        @SuppressWarnings(&quot;unchecked&quot;) E e = (E) x;
        action.accept(e);
    }
}
</code></pre>

<p>适合『读多写少』的应用场景</p>

<p>get 弱一致性</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200420185306331.png" alt="image-20200420185306331" /></p>

<table>
<thead>
<tr>
<th>时间点</th>
<th>操作</th>
</tr>
</thead>

<tbody>
<tr>
<td>1</td>
<td>Thread-0 getArray()</td>
</tr>

<tr>
<td>2</td>
<td>Thread-1 getArray()</td>
</tr>

<tr>
<td>3</td>
<td>Thread-1 setArray(arrayCopy)</td>
</tr>

<tr>
<td>4</td>
<td>Thread-0 array[index]</td>
</tr>
</tbody>
</table>

<blockquote>
<p>不容易测试，但问题确实存在</p>
</blockquote>

<p>迭代器弱一致性</p>

<pre><code class="language-java">CopyOnWriteArrayList&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;(); list.add(1); 
list.add(2); 
list.add(3); 
Iterator&lt;Integer&gt; iter = list.iterator(); 
new Thread(() -&gt; { 
    list.remove(0); 
    System.out.println(list); 
}).start(); 
  
sleep1s(); 
while (iter.hasNext()) { 
    System.out.println(iter.next()); 
} 

</code></pre>

<blockquote>
<p>不要觉得弱一致性就不好</p>

<ul>
<li><p>数据库的 MVCC 都是弱一致性的表现</p></li>

<li><p>并发高和一致性是矛盾的，需要权衡</p></li>
</ul>
</blockquote>

    </div>
    <div class="article-footer">
<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接: </strong>
      <a href="https://gitee.com/mumulx/blog/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程" target="_blank" rel="external">https://gitee.com/mumulx/blog/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</a>
    </li>
    <li class="post-copyright-license">
      <strong>License：</strong><a href="https://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN</a>
    </li>
  </ul>
</blockquote>

<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/mumulx" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="https://gitee.com/mumulx/blog/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/mumulx" target="_blank"><span class="text-dark">木木就是两个木</span><small class="ml-1x">木木</small></a></h3>
        <div>愿生活不太拥挤，愿笑容不必刻意。</div>
      </div>
    </figure>
  </div>
</div>
    </div>
  </article>
<section id="comments">
</section>

</div><nav class="bar bar-footer clearfix" data-stick-bottom>
    <div class="bar-inner">
        <ul class="pager pull-left">
            <li class="prev">
                <a href="https://gitee.com/mumulx/blog/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86%E7%AF%87/" title="Java并发编程原理篇"><i
                        class="icon icon-angle-left"
                        aria-hidden="true"></i><span>&nbsp;&nbsp;下一篇</span></a>
            </li>
            <li class="next">
                <a href="https://gitee.com/mumulx/blog/2020/05/juc/"
                    title="Java并发编程JUC"><span>上一篇&nbsp;&nbsp;</span><i
                        class="icon icon-angle-right" aria-hidden="true"></i></a>
            </li>
            
            <li class="toggle-toc">
                <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false"
                    title="文章目录" role="button">
                    <span>[&nbsp;</span><span>文章目录</span>
                    <i class="text-collapsed icon icon-anchor"></i>
                    <i class="text-in icon icon-close"></i>
                    <span>]</span>
                </a>
            </li>
        </ul>
        
        <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal"
            data-target="#donateModal"><span>赏</span></button>
        
        <div class="bar-right">
            <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter"
                data-mobile-sites="weibo,qq,qzone"></div>
        </div>
    </div>
</nav>


<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content donate">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                    aria-hidden="true">&times;</span></button>
            <div class="modal-body">
                <div class="donate-box">
                    <div class="donate-head">
                        <p>感谢您的支持,我会继续努力的!</p>
                    </div>
                    <div class="tab-content">
                        <div role="tabpanel" class="tab-pane fade active in" id="alipay">
                            <div class="donate-payimg">
                                <img src="https://gitee.com/mumulx/blog/donate/alipayimg.png"
                                    alt="扫码支持" title="扫一扫" />
                            </div>
                            <p class="text-muted mv">扫码打赏, 多少你说了算~</p>
                            <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦~</p>
                        </div>
                        <div role="tabpanel" class="tab-pane fade" id="wechatpay">
                            <div class="donate-payimg">
                                <img src="https://gitee.com/mumulx/blog/donate/wechatpayimg.png"
                                    alt="扫码支持" title="扫一扫" />
                            </div>
                            <p class="text-muted mv">扫码打赏, 多少你说了算~</p>
                            <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
                        </div>
                    </div>
                    <div class="donate-footer">
                        <ul class="nav nav-tabs nav-justified" role="tablist">
                            <li role="presentation" class="active">
                                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay"
                                    aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
                            </li>
                            <li role="presentation" class="">
                                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab"
                                    aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i>
                                    微信支付</a>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
</main><footer class="footer" itemscope itemtype="https://schema.org/WPFooter">
<ul class="social-links">
    <li><a href="https://github.com/mumulx" target="_blank" title="github" data-toggle=tooltip data-placement=top >
            <i class="icon icon-github"></i></a></li>
    <li><a href="https://gitee.com/index.xml" target="_blank" title="rss" data-toggle=tooltip data-placement=top >
            <i class="icon icon-rss"></i></a></li>
    <li><a href="https://weibo.com/u/5459389722" target="_blank" title="weibo" data-toggle=tooltip data-placement=top >
            <i class="icon icon-weibo"></i></a></li>
</ul>
  <div class="copyright">
    &copy;2019  -
    2020
    <div class="publishby">
        联系邮箱：<a target="_blank" title="木木的邮箱"> 1819778796@qq.com </a>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script>
   window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/highlight.min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/rust.min.js"></script>
<script type="text/javascript"
   src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script>
hljs.configure({
  tabReplace: '    ', 
  classPrefix: ''     
                      
})
hljs.initHighlightingOnLoad();
</script>
<script type="text/javascript" src="https://gitee.com/mumulx/blog/js/application.js"></script>
<script type="text/javascript" src="https://gitee.com/mumulx/blog/js/plugin.js"></script>
<script>
      (function (window) {
          var INSIGHT_CONFIG = {
              TRANSLATION: {
                  POSTS: '文章',
                  PAGES: '页面',
                  CATEGORIES: '分类',
                  TAGS: '标签',
                  UNTITLED: '(未命名)',
              },
              ROOT_URL: 'https:\/\/gitee.com\/mumulx\/blog',
              CONTENT_URL: 'https:\/\/gitee.com\/mumulx\/blog\/searchindex.json ',
          };
          window.INSIGHT_CONFIG = INSIGHT_CONFIG;
      })(window);
      </script>
<script type="text/javascript" src="https://gitee.com/mumulx/blog/js/insight.js"></script>


<script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '1ccf8dc9e86b3575cfb2',
        clientSecret: '048ae422c4a6207a4e89c58ba1d4ebf820136bb0',
        repo: 'gittalk',
        owner: 'mumulx',
        admin: ['mumulx'],
        id: md5(location.pathname),
        distractionFreeMode: true
    });
    gitalk.render('comments');
</script>

  </body>
</html>
