<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>
        Java并发编程模式篇 - 木木的个人博客
      </title>
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  
  <meta name="theme-color" content="#000000" />
  
  <meta http-equiv="window-target" content="_top" />
  
  
  <meta name="description" content="Java并发编程模式篇" />
  <meta name="generator" content="Hugo 0.59.1 with theme pure" />
  <title>Java并发编程模式篇 - 木木的个人博客</title>
  

  <link rel="stylesheet" href="https://mumulx.github.io/css/style.css">
  <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.15.10/styles/github.min.css"> 
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <meta property="og:title" content="Java并发编程模式篇" />
<meta property="og:description" content="Java并发编程模式篇" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mumulx.github.io/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E7%AF%87/" />
<meta property="article:published_time" content="2020-04-25T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-04-25T00:00:00+00:00" />

<meta itemprop="name" content="Java并发编程模式篇">
<meta itemprop="description" content="Java并发编程模式篇">


<meta itemprop="datePublished" content="2020-04-25T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-04-25T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="8631">



<meta itemprop="keywords" content="Java,Java并发编程," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java并发编程模式篇"/>
<meta name="twitter:description" content="Java并发编程模式篇"/>

  <!--[if lte IE 9]>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
    <![endif]-->

  <!--[if lt IE 9]>
      <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
    <![endif]-->

</head>
  </head>
  

  <body class="main-center" itemscope itemtype="https://schema.org/WebPage"><header class="header" itemscope itemtype="https://schema.org/WPHeader">
    <div class="slimContent">
      <div class="navbar-header">
        <div class="profile-block text-center">
          <a id="avatar" href="https://github.com/mumulx" target="_blank">
            <img class="img-circle img-rotate" src="https://mumulx.github.io/avatar.png" width="200" height="200">
          </a>
          <h2 id="name" class="hidden-xs hidden-sm">木木就是两个木</h2>
          <h3 id="title" class="hidden-xs hidden-sm hidden-md">木木</h3>
          <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i>xuzhou, China</small>
        </div><div class="search" id="search-form-wrap">
    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i
                        class="icon icon-search"></i></button>
            </span>
        </div>
        <div class="ins-search">
            <div class="ins-search-mask"></div>
            <div class="ins-search-container">
                <div class="ins-input-wrapper">
                    <input type="text" class="ins-search-input" placeholder="想要查找什么..."
                        x-webkit-speech />
                    <button type="button" class="close ins-close ins-selectable" data-dismiss="modal"
                        aria-label="Close"><span aria-hidden="true">×</span></button>
                </div>
                <div class="ins-section-wrapper">
                    <div class="ins-section-container"></div>
                </div>
            </div>
        </div>
    </form>
</div>
        <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
      <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="https://schema.org/SiteNavigationElement" role="navigation">
        <ul class="nav navbar-nav main-nav">
            <li class="menu-item menu-item-home">
                <a href="/">
                    <i class="icon icon-home-fill"></i>
                  <span class="menu-title">Home</span>
                </a>
            </li>
            <li class="menu-item menu-item-archives">
                <a href="/posts">
                    <i class="icon icon-archives-fill"></i>
                  <span class="menu-title">Archives</span>
                </a>
            </li>
            <li class="menu-item menu-item-categories">
                <a href="/categories">
                    <i class="icon icon-folder"></i>
                  <span class="menu-title">Categories</span>
                </a>
            </li>
            <li class="menu-item menu-item-tags">
                <a href="/tags">
                    <i class="icon icon-tags"></i>
                  <span class="menu-title">Tags</span>
                </a>
            </li>
            <li class="menu-item menu-item-about">
                <a href="/about">
                    <i class="icon icon-cup-fill"></i>
                  <span class="menu-title">About</span>
                </a>
            </li>
        </ul>
      </nav>
    </div>
  </header>
  <aside class="sidebar" itemscope itemtype="https://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content"><p>我们的征途是星辰大海！</p>
            </div>
        </div>
    </div>
</div>

      <div class="widget">
    <h3 class="widget-title"> 分类</h3>
    <div class="widget-body">
        <ul class="category-list">
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/java%E9%9D%A2%E8%AF%95/" class="category-list-link">java面试</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/%E6%8A%80%E6%9C%AF%E6%94%B6%E5%BD%95/" class="category-list-link">技术收录</a><span class="category-list-count">28</span></li>
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/" class="category-list-link">技术框架</a><span class="category-list-count">13</span></li>
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" class="category-list-link">杂七杂八</a><span class="category-list-count">10</span></li>
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/" class="category-list-link">私人博客</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://mumulx.github.io/categories/%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95/" class="category-list-link">问题收录</a><span class="category-list-count">2</span></li>
        </ul>
    </div>
</div>
      <div class="widget">
    <h3 class="widget-title"> 标签</h3>
    <div class="widget-body">
        <ul class="tag-list">
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/j2ee/" class="tag-list-link">j2ee</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/java/" class="tag-list-link">java</a><span
                    class="tag-list-count">12</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="tag-list-link">java并发编程</a><span
                    class="tag-list-count">5</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/linux/" class="tag-list-link">linux</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/node/" class="tag-list-link">node</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/spring%E5%AE%B6%E6%97%8F/" class="tag-list-link">spring家族</a><span
                    class="tag-list-count">12</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="tag-list-link">中间件</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/" class="tag-list-link">其他问题</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" class="tag-list-link">前端框架</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6/" class="tag-list-link">开发软件</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="tag-list-link">数据库</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E6%97%A5%E8%AE%B0/" class="tag-list-link">日记</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" class="tag-list-link">杂七杂八</a><span
                    class="tag-list-count">11</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" class="tag-list-link">版本控制</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://mumulx.github.io/tags/%E7%AE%97%E6%B3%95/" class="tag-list-link">算法</a><span
                    class="tag-list-count">2</span></li>
            
        </ul>

    </div>
</div>
      
<div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
        <ul class="recent-post-list list-unstyled no-thumbnail">
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.github.io/2020/10/java%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/" class="title">Java底层知识汇总</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-10-09 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-10-09</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.github.io/2020/08/java%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="title">Java算法笔记</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-08-13 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-08-13</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.github.io/2020/08/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E4%B8%80/" class="title">Java面试准备一</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-08-13 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-08-13</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.github.io/2020/08/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/" class="title">背包九讲问题汇总</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-08-13 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-08-13</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://mumulx.github.io/2020/06/tc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="title">Teamcenter定制学习笔记</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2020-06-21 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-06-21</time>
                    </p>
                </div>
            </li>
        </ul>
    </div>
</div>
  </div>
</aside>

    
    
  <aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="https://schema.org/WPSideBar">
    <div class="slimContent">
      <nav id="toc" class="article-toc">
        <h3 class="toc-title">文章目录</h3>
        <div class="toc-content always-active"><nav id="TableOfContents">
<ul>
<li><a href="#模式篇">模式篇</a>
<ul>
<li><a href="#同步模式之保护性暂停">同步模式之保护性暂停</a>
<ul>
<li><a href="#1-定义">1.定义</a></li>
<li><a href="#2-实现">2.实现</a></li>
<li><a href="#应用">*应用</a></li>
<li><a href="#3-带超时版-guardedobject">3.带超时版 GuardedObject</a></li>
<li><a href="#4-多任务版-guardedobject">4.多任务版 GuardedObject</a></li>
</ul></li>
<li><a href="#同步模式之-balking">同步模式之 Balking</a>
<ul>
<li><a href="#1-定义-1">1. 定义</a></li>
<li><a href="#2-实现-1">2. 实现</a></li>
</ul></li>
<li><a href="#同步模式之顺序控制">同步模式之顺序控制</a>
<ul>
<li><a href="#1-固定运行顺序">1. 固定运行顺序</a>
<ul>
<li><a href="#1-1-wait-notify-版">1.1 wait notify 版</a></li>
<li><a href="#1-2-park-unpark-版">1.2 Park Unpark 版</a></li>
</ul></li>
<li><a href="#2-交替输出">2. 交替输出</a>
<ul>
<li><a href="#2-1-wait-notify-版">2.1 wait notify 版</a></li>
<li><a href="#2-2-lock-条件变量版">2.2 Lock 条件变量版</a></li>
<li><a href="#2-3-park-unpark-版">2.3 Park Unpark 版</a></li>
</ul></li>
</ul></li>
<li><a href="#异步模式之生产者-消费者">异步模式之生产者/消费者</a>
<ul>
<li><a href="#1-定义-2">1. 定义</a>
<ul>
<li><a href="#要点">要点</a></li>
</ul></li>
<li><a href="#2-实现-2">2. 实现</a></li>
<li><a href="#应用-1">* 应用</a></li>
</ul></li>
<li><a href="#异步模式之工作线程">异步模式之工作线程</a>
<ul>
<li><a href="#1-定义-3">1. 定义</a></li>
<li><a href="#2-饥饿">2. 饥饿</a></li>
<li><a href="#3-创建多少线程池合适">3. 创建多少线程池合适</a>
<ul>
<li><a href="#3-1-cpu-密集型运算">3.1 CPU 密集型运算</a></li>
<li><a href="#3-2-i-o-密集型运算">3.2 I/O 密集型运算</a></li>
</ul></li>
<li><a href="#4-自定义线程池">4. 自定义线程池</a></li>
</ul></li>
<li><a href="#终止模式之两阶段终止模式">终止模式之两阶段终止模式</a>
<ul>
<li><a href="#1-错误思路">1. 错误思路</a></li>
<li><a href="#2-两阶段终止模式">2. 两阶段终止模式</a>
<ul>
<li><a href="#2-1-利用-isinterrupted">2.1 利用 isInterrupted</a></li>
<li><a href="#2-2-利用停止标记">2.2 利用停止标记</a></li>
</ul></li>
<li><a href="#案例-jvm-内存监控">案例：JVM 内存监控</a></li>
</ul></li>
<li><a href="#线程安全单例">线程安全单例</a>
<ul>
<li><a href="#1-饿汉单例">1. 饿汉单例</a></li>
<li><a href="#2-枚举单例">2. 枚举单例</a></li>
<li><a href="#3-懒汉单例">3. 懒汉单例</a></li>
<li><a href="#4-dcl-懒汉单例">4. DCL 懒汉单例</a></li>
<li><a href="#5-静态内部类懒汉单例">5. 静态内部类懒汉单例</a></li>
</ul></li>
<li><a href="#享元模式">享元模式</a>
<ul>
<li><a href="#1-简介">1. 简介</a></li>
<li><a href="#2-体现">2. 体现</a>
<ul>
<li><a href="#2-1-包装类">2.1 包装类</a></li>
<li><a href="#2-2-string-串池">2.2 String 串池</a></li>
<li><a href="#2-3-bigdecimal-biginteger">2.3 BigDecimal BigInteger</a></li>
</ul></li>
<li><a href="#3-diy">3. DIY</a></li>
<li><a href="#使用连接池">使用连接池：</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
        </div>
      </nav>
    </div>
  </aside>
<main class="main" role="main"><div class="content">
  <article id="-" class="article article-type-" itemscope
    itemtype="https://schema.org/BlogPosting">
    
    <div class="article-header">
      <h1 itemprop="name">
  <a
    class="article-title"
    href="/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E7%AF%87/"
    >Java并发编程模式篇</a
  >
</h1>

      <div class="article-meta">
        <span class="article-date">
  <i class="icon icon-calendar-check"></i>
<a href="https://mumulx.github.io/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E7%AF%87/" class="article-date">
  <time datetime="2020-04-25 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-04-25</time>
</a>
</span><span class="article-category">
  <i class="icon icon-folder"></i>
  <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E6%94%B6%E5%BD%95/"> 技术收录 </a>
</span>  
  <span class="article-tag">
    <i class="icon icon-tags"></i>
    <a class="article-tag-link" href="/tags/java/"> Java </a>
    <a class="article-tag-link" href="/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"> Java并发编程 </a>
  </span>

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E7%AF%87/#comments"
            class="article-comment-link">评论</a></span>
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计:8631字</span>
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长:18分 </span>
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      

<h1 id="模式篇">模式篇</h1>

<h2 id="同步模式之保护性暂停">同步模式之保护性暂停</h2>

<h3 id="1-定义">1.定义</h3>

<p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果</p>

<p>要点</p>

<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）</li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此归类到同步模式</li>
</ul>

<p><img src="/resources/技术收录/Java/java并发/image-20200420205103309.png" alt="image-20200420205103309" /></p>

<h3 id="2-实现">2.实现</h3>

<pre><code class="language-java">class GuardedObject {
 //结果
 private Object response;
 private final Object lock = new Object();
    //获取结果
 public Object get() {
    synchronized (lock) {
        // 条件不满足则等待，没有结果
        while (response == null) {
        try {
        	lock.wait();
        } catch (InterruptedException e) {
        	e.printStackTrace();
        } 
    }
    return response; }
 }
    //产生结果
 public void complete(Object response) {
    synchronized (lock) {
        // 条件满足，通知等待线程；给结果成员变量赋值
        this.response = response;
        lock.notifyAll();
    }
  }
}
</code></pre>

<h3 id="应用">*应用</h3>

<p>一个线程等待另一个线程的执行结果；线程1等待线程2的下载结果</p>

<pre><code class="language-java">
public static void main(String[] args) {
    GuardedObject guardedObject = new GuardedObject();
    new Thread(() -&gt; {
        // 等待结果
        log.debug(&quot;等待结果&quot;);
        List&lt;String&gt; list =(List&lt;String&gt;)guardedObject.get();
        log.debug(&quot;结果大小：{}&quot;,list.size());
    },&quot;t1&quot;).start();
    new Thread(() -&gt; {
        log.debug(&quot;执行下载&quot;);
        try {
            // 子线程执行下载
            List&lt;String&gt; response = Downloader.download();
            guardedObject.complete(list);
        } catch (IOException e) {
            e.printStackTrace();
        }
    },&quot;t2&quot;).start();
    log.debug(&quot;waiting...&quot;);
}
</code></pre>

<pre><code class="language-java">public class Downloader {
    public static List&lt;String&gt; download() throws IOException {
        HttpURLConnection conn = (HttpURLConnection) new URL(&quot;https://www.baidu.com/&quot;).openConnection();
        List&lt;String&gt; lines = new ArrayList&lt;&gt;();
        try (BufferedReader reader =
                     new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null) {
                lines.add(line);
            }
        }
        return lines;
    }
}
</code></pre>

<p>执行结果</p>

<pre><code>08:42:18.568 [main] c.TestGuardedObject - waiting...
08:42:23.312 [Thread-0] c.TestGuardedObject - download complete...
08:42:23.312 [main] c.TestGuardedObject - get response: [3] lines
</code></pre>

<h3 id="3-带超时版-guardedobject">3.带超时版 GuardedObject</h3>

<p>如果要控制超时时间呢</p>

<pre><code class="language-java">// 增加超时效果
class GuardedObject {
    // 结果
    private Object response;
    // 获取结果
    // timeout 表示要等待多久 2000
    public Object get(long timeout) {
        synchronized (this) {
            // 开始时间 15:00:00
            long begin = System.currentTimeMillis();
            // 经历的时间
            long passedTime = 0;
            while (response == null) {
                // 这一轮循环应该等待的时间
                long waitTime = timeout - passedTime;
                // 经历的时间超过了最大等待时间时，退出循环
                if (waitTime&lt;= 0) {
                    break;
                }
                try {
                    this.wait(waitTime); // 虚假唤醒 15:00:01
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 求得经历时间
                passedTime = System.currentTimeMillis() - begin; // 15:00:02  1s
            }
            return response;
        }
    }
    // 产生结果
    public void complete(Object response) {
        synchronized (this) {
            // 给结果成员变量赋值
            this.response = response;
            this.notifyAll();
        }
    }
}
</code></pre>

<p>测试，没有超时</p>

<pre><code class="language-java">public static void main(String[] args) {
    GuardedObjectV2 v2 = new GuardedObjectV2();
    new Thread(() -&gt; {
        log.debug(&quot;begin&quot;);
        Object response = v2.get(2000);
        log.debug(&quot;结果是&quot;,response);
    },&quot;t1&quot;).start();
    new Thread(() -&gt; {
        log.debug(&quot;begin t2&quot;);
        Sleeper.sleep(1);
        v2.complete(new Object());
    },&quot;t2&quot;).start();
 }
</code></pre>

<p>*<strong>原理之 join</strong></p>

<h3 id="4-多任务版-guardedobject">4.多任务版 GuardedObject</h3>

<p>图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右
侧的 t1，t3，t5 就好比邮递员</p>

<p>如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，
这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200420205329584.png" alt="image-20200420205329584" /></p>

<p>新增 id 用来标识 Guarded Object</p>

<pre><code class="language-java">// 增加超时效果
class GuardedObject {
    // 标识 Guarded Object
    private int id;
    public GuardedObject(int id) {
        this.id = id;
    }
    public int getId() {
        return id;
    }
    // 结果
    private Object response;
    // 获取结果
    // timeout 表示要等待多久 2000
    public Object get(long timeout) {
        synchronized (this) {
            // 开始时间 15:00:00
            long begin = System.currentTimeMillis();
            // 经历的时间
            long passedTime = 0;
            while (response == null) {
                // 这一轮循环应该等待的时间
                long waitTime = timeout - passedTime;
                // 经历的时间超过了最大等待时间时，退出循环
                if (timeout - passedTime &lt;= 0) {
                    break;
                }
                try {
                    this.wait(waitTime); // 虚假唤醒 15:00:01
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 求得经历时间
                passedTime = System.currentTimeMillis() - begin; // 15:00:02  1s
            }
            return response;
        }
    }
    // 产生结果
    public void complete(Object response) {
        synchronized (this) {
            // 给结果成员变量赋值
            this.response = response;
            this.notifyAll();
        }
    }
}
</code></pre>

<p>中间解耦类</p>

<pre><code class="language-java">class Mailboxes {
    private static Map&lt;Integer, GuardedObject&gt; boxes = new Hashtable&lt;&gt;();
    private static int id = 1;
    // 产生唯一 id
    private static synchronized int generateId() {
        return id++;//自增不是原子性的，再多线程下有问题
    }
    public static GuardedObject getGuardedObject(int id) {
        return boxes.remove(id);
    }
    public static GuardedObject createGuardedObject() {
        GuardedObject go = new GuardedObject(generateId());
         //boxes对象是线程安全的
        boxes.put(go.getId(), go);
        return go;
    }
    public static Set&lt;Integer&gt; getIds() {
        //boxes对象是线程安全的
        return boxes.keySet();
    }
}
</code></pre>

<p>业务相关类</p>

<pre><code class="language-java">
@Slf4j(topic = &quot;c.People&quot;)
class People extends Thread{
    @Override
    public void run() {
        // 收信
        GuardedObject guardedObject = Mailboxes.createGuardedObject();
        log.debug(&quot;开始收信 id:{}&quot;, guardedObject.getId());
        Object mail = guardedObject.get(5000);
        log.debug(&quot;收到信 id:{}, 内容:{}&quot;, guardedObject.getId(), mail);
    }
}
@Slf4j(topic = &quot;c.Postman&quot;)
class Postman extends Thread {
    private int id;
    private String mail;
    public Postman(int id, String mail) {
        this.id = id;
        this.mail = mail;
    }
    @Override
    public void run() {
        GuardedObject guardedObject = Mailboxes.getGuardedObject(id);
        log.debug(&quot;送信 id:{}, 内容:{}&quot;, id, mail);
        guardedObject.complete(mail);
    }
}
</code></pre>

<p>测试</p>

<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    for (int i = 0; i &lt; 3; i++) {
        new People().start();
    }
    Sleeper.sleep(1);
    for (Integer id : Mailboxes.getIds()) {
        new Postman(id, &quot;内容&quot; + id).start();
    }
}
</code></pre>

<p>某次运行结果</p>

<pre><code>10:35:05.689 c.People [Thread-1] - 开始收信 id:3
10:35:05.689 c.People [Thread-2] - 开始收信 id:1
10:35:05.689 c.People [Thread-0] - 开始收信 id:2
10:35:06.688 c.Postman [Thread-4] - 送信 id:2, 内容:内容2
10:35:06.688 c.Postman [Thread-5] - 送信 id:1, 内容:内容1
10:35:06.688 c.People [Thread-0] - 收到信 id:2, 内容:内容2
10:35:06.688 c.People [Thread-2] - 收到信 id:1, 内容:内容1
10:35:06.688 c.Postman [Thread-3] - 送信 id:3, 内容:内容3
10:35:06.689 c.People [Thread-1] - 收到信 id:3, 内容:内容3
</code></pre>

<h2 id="同步模式之-balking">同步模式之 Balking</h2>

<h3 id="1-定义-1">1. 定义</h3>

<p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做
了，直接结束返回</p>

<h3 id="2-实现-1">2. 实现</h3>

<p>例如：</p>

<p>*** 终止模式之两阶段终止模式**中的利用停止标记的优化</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)
public class Test13 {
    public static void main(String[] args) throws InterruptedException {
        TwoPhaseTermination tpt = new TwoPhaseTermination();
        tpt.start();
        tpt.start();
        tpt.start();

        /*Thread.sleep(3500);
        log.debug(&quot;停止监控&quot;);
        tpt.stop();*/
    }
}
@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)
class TwoPhaseTermination {
    // 监控线程
    private Thread monitorThread;
    // 停止标记
    private volatile boolean stop = false;
    // 判断是否执行过 start 方法
    private boolean starting = false;

    // 启动监控线程
    public void start() {
        synchronized (this) {
            if (starting) { // false
                return;
            }
            starting = true;
        }
        monitorThread = new Thread(() -&gt; {
            while (true) {
                Thread current = Thread.currentThread();
                // 是否被打断
                if (stop) {
                    log.debug(&quot;料理后事&quot;);
                    break;
                }
                try {
                    Thread.sleep(1000);
                    log.debug(&quot;执行监控记录&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;monitor&quot;);
        monitorThread.start();
    }
    // 停止监控线程
    public void stop() {
        stop = true;
        monitorThread.interrupt();
    }
}
</code></pre>

<p>尽量让sychronized同步代码块中的代码尽可能的少，只保护需要保护的资源</p>

<p>例二</p>

<pre><code class="language-java">@RestController
public class MonitorController {
    public static ArrayBlockingQueue&lt;Info&gt; QUEUE = new ArrayBlockingQueue(30);

    @Autowired
    private MonitorService monitorService;

    @GetMapping(&quot;/info&quot;)
    public List&lt;Info&gt; info() {
        ArrayList&lt;Info&gt; infos = new ArrayList&lt;&gt;();
        QUEUE.drainTo(infos);
        return infos;
    }

    @GetMapping(&quot;/start&quot;)
    public void start() {
        monitorService.start();
    }

    @GetMapping(&quot;/stop&quot;)
    public void stop() {
        monitorService.stop();
    }
}

</code></pre>

<pre><code class="language-java">@Service
@Slf4j
public class MonitorService {
    private volatile boolean stop;
    private volatile boolean starting;
    private Thread monitorThread;
    public void start() {
        // 缩小同步范围，提升性能
        synchronized (this) {
            log.info(&quot;该监控线程已启动?({})&quot;, starting);
            if (starting) {
                return;
            }
            starting = true;
        }
        // 由于之前的 balking 模式，以下代码只可能被一个线程执行，因此无需互斥
        monitorThread = new Thread(() -&gt; {
            while (!stop) {
                report();
                sleep(2);
            }
            // 这里的监控线程只可能启动一个，因此只需要用 volatile 保证 starting 的可见性
            log.info(&quot;监控线程已停止...&quot;);
            starting = false;
        });
        stop = false;
        log.info(&quot;监控线程已启动...&quot;);
        monitorThread.start();
    }
    private void report() {
        Info info = new Info();
        info.setTotal(Runtime.getRuntime().totalMemory());
        info.setFree(Runtime.getRuntime().freeMemory());
        info.setMax(Runtime.getRuntime().maxMemory());
        info.setTime(System.currentTimeMillis());
        MonitorController.QUEUE.offer(info);
    }
    private void sleep(long seconds) {
        try {
            TimeUnit.SECONDS.sleep(seconds);
        } catch (InterruptedException e) {
        }
    }
    public synchronized void stop() {
        stop = true;
        // 不加打断需要等到下一次 sleep 结束才能退出循环，这里是为了更快结束
        monitorThread.interrupt();
    }
}
</code></pre>

<pre><code class="language-java">@Data
public class Info {
    private long free;
    private long total;
    private long max;
    private long time;
}

</code></pre>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;监控程序&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;/js/echarts.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body style=&quot;height: 500px; margin: 0&quot;&gt;
&lt;div id=&quot;container&quot; style=&quot;height: 100%&quot;&gt;&lt;/div&gt;
&lt;div&gt;
    &lt;input type=&quot;button&quot; value=&quot;开始&quot; id=&quot;start&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;停止&quot; id=&quot;stop&quot;&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(&quot;#start&quot;).click(function(){
        $.get(&quot;start&quot;);
    });
    $(&quot;#stop&quot;).click(function(){
        $.get(&quot;stop&quot;);
    });

    const dom = document.getElementById(&quot;container&quot;);
    const myChart = echarts.init(dom);
    option = null;
    let data = [];
    option = {
        title: {
            text: '动态数据 + 时间坐标轴'
        },
        xAxis: {
            type: 'time',
            splitLine: {
                show: false
            }
        },
        yAxis: {
            type: 'value',
            boundaryGap: [0, '100%'],
            splitLine: {
                show: false
            }
        },
        series: [{
            name: '总内存',
            type: 'line',
            showSymbol: true,
            areaStyle: {color: 'rgba(0, 200, 40, 0.7)'},
            hoverAnimation: true,
            data: []
        }, {
            name: '已使用',
            type: 'line',
            showSymbol: true,
            areaStyle: {color: 'rgba(0, 0, 200, 0.7)'},
            hoverAnimation: true,
            data: []
        }]
    };

    setInterval(function () {
        $.get(&quot;info&quot;).done(function (infos) {
            while (data.length &gt;= 10) {
                data.shift();
            }
            data.push(...infos);
            let max = data.map(d =&gt; [d.time, d.max]);
            let total = data.map(d =&gt; [d.time, d.total]);
            let used = data.map(d =&gt; [d.time, d.total - d.free]);
            myChart.setOption({
                series: [{
                    data: total
                }, {
                    data: used
                }]
            });
        });
    }, 2000);
    myChart.setOption(option, true);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>当前端页面多次点击按钮调用 start 时</p>

<p>输出</p>

<pre><code>[http-nio-8080-exec-1] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(false)
[http-nio-8080-exec-1] cn.itcast.monitor.service.MonitorService - 监控线程已启动...
[http-nio-8080-exec-2] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(true)
[http-nio-8080-exec-3] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(true)
[http-nio-8080-exec-4] cn.itcast.monitor.service.MonitorService - 该监控线程已启动?(true)
</code></pre>

<p>它还经常用来实现线程安全的单例</p>

<pre><code class="language-java">public final class Singleton {
 private Singleton() {
 }
 private static Singleton INSTANCE = null;
 public static synchronized Singleton getInstance() {
 	if (INSTANCE != null) {
 	return INSTANCE;
 }
 
 INSTANCE = new Singleton();
 	return INSTANCE;
 }
}
</code></pre>

<p>对比一下保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待。</p>

<h2 id="同步模式之顺序控制">同步模式之顺序控制</h2>

<h3 id="1-固定运行顺序">1. 固定运行顺序</h3>

<p>比如，必须先 2 后 1 打印</p>

<h4 id="1-1-wait-notify-版">1.1 wait notify 版</h4>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test25&quot;)
public class Test25 {
    static final Object lock = new Object();
    // 表示 t2 是否运行过
    static boolean t2runned = false;
    public static void main(String[] args) {
        Thread t1 = new Thread(() -&gt; {
            synchronized (lock) {
                while (!t2runned) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug(&quot;1&quot;);
            }
        }, &quot;t1&quot;);
        Thread t2 = new Thread(() -&gt; {
            synchronized (lock) {
                log.debug(&quot;2&quot;);
                t2runned = true;
                lock.notify();
            }
        }, &quot;t2&quot;);
        t1.start();
        t2.start();
    }
}
</code></pre>

<h4 id="1-2-park-unpark-版">1.2 Park Unpark 版</h4>

<p>可以看到，实现上很麻烦：</p>

<ul>
<li>首先，需要保证先 wait 再 notify，否则 wait 线程永远得不到唤醒。因此使用了『运行标记』来判断该不该
wait</li>
<li>第二，如果有些干扰线程错误地 notify 了 wait 线程，条件不满足时还要重新等待，使用了 while 循环来解决
此问题</li>
<li>最后，唤醒对象上的 wait 线程需要使用 notifyAll，因为『同步对象』上的等待线程可能不止一个</li>
</ul>

<p>可以使用 LockSupport 类的 park 和 unpark 来简化上面的题目：</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test26&quot;)
public class Test26 {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -&gt; {
            LockSupport.park();
            log.debug(&quot;1&quot;);
        }, &quot;t1&quot;);
        t1.start();
        new Thread(() -&gt; {
            log.debug(&quot;2&quot;);
            LockSupport.unpark(t1);
        },&quot;t2&quot;).start();
    }
}
</code></pre>

<p>park 和 unpark 方法比较灵活，他俩谁先调用，谁后调用无所谓。并且是以线程为单位进行『暂停』和『恢复』，
不需要『同步对象』和『运行标记』</p>

<h3 id="2-交替输出">2. 交替输出</h3>

<p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现</p>

<h4 id="2-1-wait-notify-版">2.1 wait notify 版</h4>

<pre><code class="language-java">
@Slf4j(topic = &quot;c.Test27&quot;)
public class Test27 {
    public static void main(String[] args) {
        WaitNotify wn = new WaitNotify(1, 5);
        new Thread(() -&gt; {
            wn.print(&quot;a&quot;, 1, 2);
        }).start();
        new Thread(() -&gt; {
            wn.print(&quot;b&quot;, 2, 3);
        }).start();
        new Thread(() -&gt; {
            wn.print(&quot;c&quot;, 3, 1);
        }).start();
    }
}
/*
输出内容       等待标记     下一个标记
   a           1             2
   b           2             3
   c           3             1
 */
class WaitNotify {
    // 打印               a           1             2
    public void print(String str, int waitFlag, int nextFlag) {
        for (int i = 0; i &lt; loopNumber; i++) {
            synchronized (this) {
                while(flag != waitFlag) {
                    try {
                        this.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.print(str);
                flag = nextFlag;
                this.notifyAll();
            }
        }
    }
    // 等待标记
    private int flag; // 2
    // 循环次数
    private int loopNumber;
    public WaitNotify(int flag, int loopNumber) {
        this.flag = flag;
        this.loopNumber = loopNumber;
    }
}
</code></pre>

<h4 id="2-2-lock-条件变量版">2.2 Lock 条件变量版</h4>

<pre><code class="language-java">public class Test30 {
    public static void main(String[] args) throws InterruptedException {
        AwaitSignal awaitSignal = new AwaitSignal(5);
        Condition a = awaitSignal.newCondition();
        Condition b = awaitSignal.newCondition();
        Condition c = awaitSignal.newCondition();
        new Thread(() -&gt; {
            awaitSignal.print(&quot;a&quot;, a, b);
        }).start();
        new Thread(() -&gt; {
            awaitSignal.print(&quot;b&quot;, b, c);
        }).start();
        new Thread(() -&gt; {
            awaitSignal.print(&quot;c&quot;, c, a);
        }).start();
        Thread.sleep(1000);
        awaitSignal.lock();
        try {
            System.out.println(&quot;开始...&quot;);
            a.signal();
        } finally {
            awaitSignal.unlock();
        }
    }
}
class AwaitSignal extends ReentrantLock{
    //循环次数
    private int loopNumber;
    public AwaitSignal(int loopNumber) {
        this.loopNumber = loopNumber;
    }
    //            参数1 打印内容， 参数2 进入哪一间休息室, 参数3 下一间休息室
    public void print(String str, Condition current, Condition next) {
        for (int i = 0; i &lt; loopNumber; i++) {
            lock();
            try {
                current.await();
                System.out.print(str);
                next.signal();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                unlock();
            }
        }
    }
}
</code></pre>

<p>注意</p>

<pre><code>该实现没有考虑 a，b，c 线程都就绪再开始
</code></pre>

<h4 id="2-3-park-unpark-版">2.3 Park Unpark 版</h4>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Test31&quot;)
public class Test31 {

    static Thread t1;
    static Thread t2;
    static Thread t3;
    public static void main(String[] args) {
        ParkUnpark pu = new ParkUnpark(5);
        t1 = new Thread(() -&gt; {
            pu.print(&quot;a&quot;, t2);
        });
        t2 = new Thread(() -&gt; {
            pu.print(&quot;b&quot;, t3);
        });
        t3 = new Thread(() -&gt; {
            pu.print(&quot;c&quot;, t1);
        });
        t1.start();
        t2.start();
        t3.start();

        LockSupport.unpark(t1);
    }
}

class ParkUnpark {
    public void print(String str, Thread next) {
        for (int i = 0; i &lt; loopNumber; i++) {
            LockSupport.park();
            System.out.print(str);
            LockSupport.unpark(next);
        }
    }
    private int loopNumber;

    public ParkUnpark(int loopNumber) {
        this.loopNumber = loopNumber;
    }
}
</code></pre>

<h2 id="异步模式之生产者-消费者">异步模式之生产者/消费者</h2>

<h3 id="1-定义-2">1. 定义</h3>

<p>异步的原因是，生产后可能不会立刻被消费。</p>

<h4 id="要点">要点</h4>

<ul>
<li><p>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应</p></li>

<li><p>消费队列可以用来平衡生产和消费的线程资源</p></li>

<li><p>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</p></li>

<li><p>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</p></li>

<li><p>JDK 中各种阻塞队列，采用的就是这种模式</p>

<p><img src="/resources/技术收录/Java/java并发/image-20200420205940529.png" alt="image-20200420205940529" /></p></li>
</ul>

<h3 id="2-实现-2">2. 实现</h3>

<pre><code class="language-java">// 消息队列类 ， java 线程之间通信
@Slf4j(topic = &quot;c.MessageQueue&quot;)
class MessageQueue {
    // 消息的队列集合
    private LinkedList&lt;Message&gt; list = new LinkedList&lt;&gt;();
    // 队列容量
    private int capcity;

    public MessageQueue(int capcity) {
        this.capcity = capcity;
    }

    // 获取消息
    public Message take() {
        // 检查队列是否为空
        synchronized (list) {
            while(list.isEmpty()) {
                try {
                    log.debug(&quot;队列为空, 消费者线程等待&quot;);
                    list.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            // 从队列头部获取消息并返回
            Message message = list.removeFirst();
            log.debug(&quot;已消费消息 {}&quot;, message);
            list.notifyAll();
            return message;
        }
    }

    // 存入消息
    public void put(Message message) {
        synchronized (list) {
            // 检查对象是否已满
            while(list.size() == capcity) {
                try {
                    log.debug(&quot;队列已满, 生产者线程等待&quot;);
                    list.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            // 将消息加入队列尾部
            list.addLast(message);
            log.debug(&quot;已生产消息 {}&quot;, message);
            list.notifyAll();
        }
    }
}
//线程安全(只能读取)
final class Message {
    private int id;
    private Object value;

    public Message(int id, Object value) {
        this.id = id;
        this.value = value;
    }

    public int getId() {
        return id;
    }

    public Object getValue() {
        return value;
    }

    @Override
    public String toString() {
        return &quot;Message{&quot; +
                &quot;id=&quot; + id +
                &quot;, value=&quot; + value +
                '}';
    }
}
</code></pre>

<h3 id="应用-1">* 应用</h3>

<pre><code class="language-java"> public static void main(String[] args) {
        MessageQueue queue = new MessageQueue(2);
        for (int i = 0; i &lt; 3; i++) {
            int id = i;
            new Thread(() -&gt; {
                queue.put(new Message(id , &quot;值&quot;+id));
            }, &quot;生产者&quot; + i).start();
        }
        new Thread(() -&gt; {
            while(true) {
                sleep(1);
                Message message = queue.take();
            }
        }, &quot;消费者&quot;).start();
    }
</code></pre>

<h2 id="异步模式之工作线程">异步模式之工作线程</h2>

<h3 id="1-定义-3">1. 定义</h3>

<p>让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现
就是线程池，也体现了经典设计模式中的享元模式。</p>

<p>例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）</p>

<p>注意，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率</p>

<p>例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成
服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工</p>

<h3 id="2-饥饿">2. 饥饿</h3>

<p>固定大小线程池会有饥饿现象</p>

<ul>
<li>两个工人是同一个线程池中的两个线程</li>
<li>他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作

<ul>
<li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待</li>
<li>后厨做菜：没啥说的，做就是了</li>
</ul></li>
<li>比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好</li>

<li><p>但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿</p>

<pre><code class="language-java">public class TestDeadLock {
static final List&lt;String&gt; MENU = Arrays.asList(&quot;地三鲜&quot;, &quot;宫保鸡丁&quot;, &quot;辣子鸡丁&quot;, &quot;烤鸡翅&quot;);
static Random RANDOM = new Random();
static String cooking() {
return MENU.get(RANDOM.nextInt(MENU.size()));
}
public static void main(String[] args) {
 ExecutorService executorService = Executors.newFixedThreadPool(2);
 executorService.execute(() -&gt; {
     log.debug(&quot;处理点餐...&quot;);
     Future&lt;String&gt; f = executorService.submit(() -&gt; {
     	log.debug(&quot;做菜&quot;);
     	return cooking();
 	});
     try {
        log.debug(&quot;上菜: {}&quot;, f.get());
     } catch (InterruptedException | ExecutionException e) {
        e.printStackTrace();
     }
 });
 /*   executorService.execute(() -&gt; {
     log.debug(&quot;处理点餐...&quot;);
     Future&lt;String&gt; f = executorService.submit(() -&gt; {
     	log.debug(&quot;做菜&quot;);
     	return cooking();
 	});
     try {
        log.debug(&quot;上菜: {}&quot;, f.get());
     } catch (InterruptedException | ExecutionException e) {
        e.printStackTrace();
     }
 });*/
}
}
</code></pre></li>
</ul>

<p>输出</p>

<pre><code>17:21:27.883 c.TestDeadLock [pool-1-thread-1] - 处理点餐...
17:21:27.891 c.TestDeadLock [pool-1-thread-2] - 做菜
17:21:27.891 c.TestDeadLock [pool-1-thread-1] - 上菜: 烤鸡翅
</code></pre>

<p>当注释取消后，可能的输出</p>

<pre><code>17:08:41.339 c.TestDeadLock [pool-1-thread-2] - 处理点餐...
17:08:41.339 c.TestDeadLock [pool-1-thread-1] - 处理点餐...
</code></pre>

<p>解决方法可以增加线程池的大小，不过不是根本解决方案，还是前面提到的，不同的任务类型，采用不同的线程池，例如：</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.TestDeadLock&quot;)
public class TestStarvation {
    static final List&lt;String&gt; MENU = Arrays.asList(&quot;地三鲜&quot;, &quot;宫保鸡丁&quot;, &quot;辣子鸡丁&quot;, &quot;烤鸡翅&quot;);
    static Random RANDOM = new Random();
    static String cooking() {
        return MENU.get(RANDOM.nextInt(MENU.size()));
    }
    public static void main(String[] args) {
        ExecutorService waiterPool = Executors.newFixedThreadPool(1);
        ExecutorService cookPool = Executors.newFixedThreadPool(1);

        waiterPool.execute(() -&gt; {
            log.debug(&quot;处理点餐...&quot;);
            Future&lt;String&gt; f = cookPool.submit(() -&gt; {
                log.debug(&quot;做菜&quot;);
                return cooking();
            });
            try {
                log.debug(&quot;上菜: {}&quot;, f.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
        waiterPool.execute(() -&gt; {
            log.debug(&quot;处理点餐...&quot;);
            Future&lt;String&gt; f = cookPool.submit(() -&gt; {
                log.debug(&quot;做菜&quot;);
                return cooking();
            });
            try {
                log.debug(&quot;上菜: {}&quot;, f.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });

    }
}
</code></pre>

<p>输出</p>

<pre><code>17:25:14.626 c.TestDeadLock [pool-1-thread-1] - 处理点餐...
17:25:14.630 c.TestDeadLock [pool-2-thread-1] - 做菜
17:25:14.631 c.TestDeadLock [pool-1-thread-1] - 上菜: 地三鲜
17:25:14.632 c.TestDeadLock [pool-1-thread-1] - 处理点餐...
17:25:14.632 c.TestDeadLock [pool-2-thread-1] - 做菜
17:25:14.632 c.TestDeadLock [pool-1-thread-1] - 上菜: 辣子鸡丁
</code></pre>

<h3 id="3-创建多少线程池合适">3. 创建多少线程池合适</h3>

<ul>
<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿</li>
<li>过大会导致更多的线程上下文切换，占用更多内存</li>
</ul>

<h4 id="3-1-cpu-密集型运算">3.1 CPU 密集型运算</h4>

<p>通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费（进行数据分析）</p>

<h4 id="3-2-i-o-密集型运算">3.2 I/O 密集型运算</h4>

<p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。</p>

<p>经验公式如下</p>

<pre><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间
</code></pre>

<p>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式</p>

<pre><code>4 * 100% * 100% / 50% = 8
</code></pre>

<p>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式</p>

<pre><code>4 * 100% * 100% / 10% = 40
</code></pre>

<h3 id="4-自定义线程池">4. 自定义线程池</h3>

<pre><code class="language-mermaid">graph LR
  subgraph Thread Pool
  t1(t1)
  t2(t2)
  t3(t3)
  end
  subgraph Blocking Queue
  task1(&quot;task 1&quot;)--&gt;task2(&quot;task 2&quot;)
  task2--&gt;task3(&quot;task 3&quot;)
  end
t1--poll--&gt;task1
t2-.poll.-&gt;task1
t3-.poll.-&gt;task1
task3--put--&gt;main(main)
</code></pre>

<p>见并发编程</p>

<h2 id="终止模式之两阶段终止模式">终止模式之两阶段终止模式</h2>

<p>Two Phase Termination</p>

<p>在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。</p>

<h3 id="1-错误思路">1. 错误思路</h3>

<ul>
<li>使用线程对象的 stop() 方法停止线程

<ul>
<li>stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，
其它线程将永远无法获取锁</li>
</ul></li>
<li>使用 System.exit(int) 方法停止线程

<ul>
<li>目的仅是停止一个线程，但这种做法会让整个程序都停止</li>
</ul></li>
</ul>

<h3 id="2-两阶段终止模式">2. 两阶段终止模式</h3>

<p>Two Phase Termination
在一个线程T1中如何“优雅&rdquo;终止线程T2?这里的[优雅]指的是给T2-个料理后事的机会。</p>

<p>错误思路</p>

<ul>
<li>使用线程对象的stop0方法停止线程

<ul>
<li>stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</li>
</ul></li>
<li>使用System.exit(int)方法停止线程

<ul>
<li>目的仅是停止一个线程，但这种做法会让整个程序都停止</li>
</ul></li>
</ul>

<p><img src="/resources/技术收录/Java/java并发/image-20200419195747027.png" alt="image-20200419195747027" /></p>

<h4 id="2-1-利用-isinterrupted">2.1 利用 isInterrupted</h4>

<p>interrupt 可以打断正在执行的线程，无论这个线程是在 sleep，wait，还是正常运行</p>

<pre><code class="language-java">class TPTInterrupt {
    private Thread thread;
    public void start(){
        thread = new Thread(() -&gt; {
            while(true) {
                Thread current = Thread.currentThread();
                if(current.isInterrupted()) {
                    log.debug(&quot;料理后事&quot;);
                    break;
                }
                try {
                    Thread.sleep(1000);
                    log.debug(&quot;将结果保存&quot;);
                } catch (InterruptedException e) {
                    current.interrupt();}
                // 执行监控操作 
            }
        },&quot;监控线程&quot;);
        thread.start();
    }
    public void stop() {
        thread.interrupt();
    }
}
</code></pre>

<p>调用</p>

<pre><code class="language-java">TPTInterrupt t = new TPTInterrupt();
t.start();
Thread.sleep(3500);
log.debug(&quot;stop&quot;);
t.stop();
</code></pre>

<p>结果</p>

<pre><code>11:49:42.915 c.TwoPhaseTermination [监控线程] - 将结果保存
11:49:43.919 c.TwoPhaseTermination [监控线程] - 将结果保存
11:49:44.919 c.TwoPhaseTermination [监控线程] - 将结果保存
11:49:45.413 c.TestTwoPhaseTermination [main] - stop 
11:49:45.413 c.TwoPhaseTermination [监控线程] - 料理后事
</code></pre>

<h4 id="2-2-利用停止标记">2.2 利用停止标记</h4>

<pre><code class="language-java">// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性
// 我们的例子中，即主线程把它修改为 true 对 t1 线程可见
@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)
public class Test13 {
    public static void main(String[] args) throws InterruptedException {
        TwoPhaseTermination tpt = new TwoPhaseTermination();
        tpt.start();
        Thread.sleep(3500);
        log.debug(&quot;停止监控&quot;);
        tpt.stop();
    }
}
@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)
class TwoPhaseTermination {
    // 监控线程
    private Thread monitorThread;
    // 停止标记
    private volatile boolean stop = false;
    // 启动监控线程
    public void start() {
        monitorThread = new Thread(() -&gt; {
            while (true) {
                Thread current = Thread.currentThread();
                // 是否被打断
                if (stop) {
                    log.debug(&quot;料理后事&quot;);
                    break;
                }
                try {
                    Thread.sleep(1000);
                    log.debug(&quot;执行监控记录&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;monitor&quot;);
        monitorThread.start();
    }
    // 停止监控线程
    public void stop() {
        stop = true;
        monitorThread.interrupt();
    }
}
</code></pre>

<h3 id="案例-jvm-内存监控">案例：JVM 内存监控</h3>

<h2 id="线程安全单例">线程安全单例</h2>

<p>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用getInstance）时的线程安全，并思考注释中的问题</p>

<pre><code>饿汉式：类加载就会导致该单实例对象被创建
懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建
</code></pre>

<h3 id="1-饿汉单例">1. 饿汉单例</h3>

<pre><code>// 问题1：为什么加 final
// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例
public final class Singleton implements Serializable {
 // 问题3：为什么设置为私有? 是否能防止反射创建新的实例?
 private Singleton() {}
 // 问题4：这样初始化是否能保证单例对象创建时的线程安全?
 private static final Singleton INSTANCE = new Singleton();
 // 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由
 public static Singleton getInstance() {
 return INSTANCE;
 }
 public Object readResolve() {
 return INSTANCE;
 }
}
</code></pre>

<h3 id="2-枚举单例">2. 枚举单例</h3>

<pre><code>// 问题1：枚举单例是如何限制实例个数的
// 问题2：枚举单例在创建时是否有并发问题
// 问题3：枚举单例能否被反射破坏单例
// 问题4：枚举单例能否被反序列化破坏单例
// 问题5：枚举单例属于懒汉式还是饿汉式
// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做
enum Singleton { 
 INSTANCE; 
}
</code></pre>

<h3 id="3-懒汉单例">3. 懒汉单例</h3>

<pre><code> private Singleton() { }
 private static Singleton INSTANCE = null;
 // 分析这里的线程安全, 并说明有什么缺点
 public static synchronized Singleton getInstance() {
 if( INSTANCE != null ){
 return INSTANCE;
 } 
 INSTANCE = new Singleton();
 return INSTANCE;
 }
}
</code></pre>

<h3 id="4-dcl-懒汉单例">4. DCL 懒汉单例</h3>

<pre><code>public final class Singleton {
 private Singleton() { }
 // 问题1：解释为什么要加 volatile ?
 private static volatile Singleton INSTANCE = null;
 
 // 问题2：对比实现3, 说出这样做的意义 
 public static Singleton getInstance() {
 if (INSTANCE != null) {return INSTANCE;
 }
 synchronized (Singleton.class) { 
 // 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗
 if (INSTANCE != null) { // t2 
 return INSTANCE;
 }
 INSTANCE = new Singleton(); 
 return INSTANCE;
 } 
 }
}
</code></pre>

<h3 id="5-静态内部类懒汉单例">5. 静态内部类懒汉单例</h3>

<pre><code>public final class Singleton {
 private Singleton() { }
 // 问题1：属于懒汉式还是饿汉式
 private static class LazyHolder {
 static final Singleton INSTANCE = new Singleton();
 }
 // 问题2：在创建时是否有并发问题
 public static Singleton getInstance() {
 return LazyHolder.INSTANCE;
 }
}
</code></pre>

<h2 id="享元模式">享元模式</h2>

<h3 id="1-简介">1. 简介</h3>

<p>定义 英文名称：Flyweight pattern. 当需要重用数量有限的同一类对象时</p>

<pre><code>wikipedia： 
A flyweight is an object that minimizes memory usage by sharing as much data as possible with other similar objects
</code></pre>

<p>出自 &ldquo;Gang of Four&rdquo; design patterns</p>

<p>归类 Structual patterns</p>

<h3 id="2-体现">2. 体现</h3>

<h4 id="2-1-包装类">2.1 包装类</h4>

<p>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对
象：</p>

<pre><code class="language-java">public static Long valueOf(long l) {
 final int offset = 128;
 if (l &gt;= -128 &amp;&amp; l &lt;= 127) { // will cache
 	return LongCache.cache[(int)l + offset];
 }
 return new Long(l);
}
</code></pre>

<p>注意：</p>

<blockquote>
<ul>
<li>Byte, Short, Long 缓存的范围都是 -128~127</li>
<li>Character 缓存的范围是 0~127</li>
<li>Integer的默认范围是 -128~127

<ul>
<li>最小值不能变</li>
<li>但最大值可以通过调整虚拟机参数 <code>
-Djava.lang.Integer.IntegerCache.high</code> 来改变</li>
</ul></li>
<li>Boolean 缓存了 TRUE 和 FALSE</li>
</ul>
</blockquote>

<h4 id="2-2-string-串池">2.2 String 串池</h4>

<h4 id="2-3-bigdecimal-biginteger">2.3 BigDecimal BigInteger</h4>

<p>这些类都是线程安全的，他们其中的每一个方法都是线程安全的，因此单独使用的时候不会有线程安全的问题，但是当它们在一起使用的时候（组合多个方法进行使用）就不能保证他们是线程安全的了。</p>

<h3 id="3-diy">3. DIY</h3>

<p>例如：一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。</p>

<pre><code class="language-java">@Slf4j(topic = &quot;c.Pool&quot;)
class Pool {
    // 1. 连接池大小
    private final int poolSize;

    // 2. 连接对象数组
    private Connection[] connections;

    // 3. 连接状态数组 0 表示空闲， 1 表示繁忙
    private AtomicIntegerArray states;

    // 4. 构造方法初始化
    public Pool(int poolSize) {
        this.poolSize = poolSize;
        this.connections = new Connection[poolSize];
        this.states = new AtomicIntegerArray(new int[poolSize]);
        for (int i = 0; i &lt; poolSize; i++) {
            connections[i] = new MockConnection(&quot;连接&quot; + (i+1));
        }
    }
    // 5. 借连接
    public Connection borrow() {
        while(true) {
            for (int i = 0; i &lt; poolSize; i++) {
                // 获取空闲连接
                if(states.get(i) == 0) {
                    if (states.compareAndSet(i, 0, 1)) {
                        log.debug(&quot;borrow {}&quot;, connections[i]);
                        return connections[i];
                    }
                }
            }
            // 如果没有空闲连接，当前线程进入等待
            synchronized (this) {
                try {
                    log.debug(&quot;wait...&quot;);
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    // 6. 归还连接
    public void free(Connection conn) {
        for (int i = 0; i &lt; poolSize; i++) {
            if (connections[i] == conn) {
                states.set(i, 0);
                synchronized (this) {
                    log.debug(&quot;free {}&quot;, conn);
                    this.notifyAll();
                }
                break;
            }
        }
    }
}
class MockConnection implements Connection {
    private String name;
    public MockConnection(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return &quot;MockConnection{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}';
    }
}
</code></pre>

<h3 id="使用连接池">使用连接池：</h3>

<pre><code class="language-java">Pool pool = new Pool(2);
for (int i = 0; i &lt; 5; i++) {
    new Thread(() -&gt; {
        Connection conn = pool.borrow();
        try {
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        pool.free(conn);
    }).start();
}
</code></pre>

<p>以上实现没有考虑：</p>

<ul>
<li>连接的动态增长与收缩</li>
<li>连接保活（可用性检测）</li>
<li>等待超时处理</li>
<li>分布式 hash</li>
</ul>

<p>对于关系型数据库，有比较成熟的连接池实现，例如c3p0, druid等 对于更通用的对象池，可以考虑使用apache
commons pool，例如redis连接池可以参考jedis中关于连接池的实现</p>

    </div>
    <div class="article-footer">
<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接: </strong>
      <a href="https://mumulx.github.io/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E7%AF%87/" title="Java并发编程模式篇" target="_blank" rel="external">https://mumulx.github.io/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E7%AF%87/</a>
    </li>
    <li class="post-copyright-license">
      <strong>License：</strong><a href="https://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN</a>
    </li>
  </ul>
</blockquote>

<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/mumulx" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="https://mumulx.github.io/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/mumulx" target="_blank"><span class="text-dark">木木就是两个木</span><small class="ml-1x">木木</small></a></h3>
        <div>愿生活不太拥挤，愿笑容不必刻意。</div>
      </div>
    </figure>
  </div>
</div>
    </div>
  </article>
<section id="comments">
</section>

</div><nav class="bar bar-footer clearfix" data-stick-bottom>
    <div class="bar-inner">
        <ul class="pager pull-left">
            <li class="prev">
                <a href="https://mumulx.github.io/2020/03/nginx%E7%AC%94%E8%AE%B0/" title="Nginx进阶学习笔记"><i
                        class="icon icon-angle-left"
                        aria-hidden="true"></i><span>&nbsp;&nbsp;下一篇</span></a>
            </li>
            <li class="next">
                <a href="https://mumulx.github.io/2020/04/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8%E7%AF%87/"
                    title="Java并发编程应用篇"><span>上一篇&nbsp;&nbsp;</span><i
                        class="icon icon-angle-right" aria-hidden="true"></i></a>
            </li>
            
            <li class="toggle-toc">
                <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false"
                    title="文章目录" role="button">
                    <span>[&nbsp;</span><span>文章目录</span>
                    <i class="text-collapsed icon icon-anchor"></i>
                    <i class="text-in icon icon-close"></i>
                    <span>]</span>
                </a>
            </li>
        </ul>
        
        <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal"
            data-target="#donateModal"><span>赏</span></button>
        
        <div class="bar-right">
            <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter"
                data-mobile-sites="weibo,qq,qzone"></div>
        </div>
    </div>
</nav>


<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content donate">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                    aria-hidden="true">&times;</span></button>
            <div class="modal-body">
                <div class="donate-box">
                    <div class="donate-head">
                        <p>感谢您的支持,我会继续努力的!</p>
                    </div>
                    <div class="tab-content">
                        <div role="tabpanel" class="tab-pane fade active in" id="alipay">
                            <div class="donate-payimg">
                                <img src="https://mumulx.github.io/donate/alipayimg.png"
                                    alt="扫码支持" title="扫一扫" />
                            </div>
                            <p class="text-muted mv">扫码打赏, 多少你说了算~</p>
                            <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦~</p>
                        </div>
                        <div role="tabpanel" class="tab-pane fade" id="wechatpay">
                            <div class="donate-payimg">
                                <img src="https://mumulx.github.io/donate/wechatpayimg.png"
                                    alt="扫码支持" title="扫一扫" />
                            </div>
                            <p class="text-muted mv">扫码打赏, 多少你说了算~</p>
                            <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
                        </div>
                    </div>
                    <div class="donate-footer">
                        <ul class="nav nav-tabs nav-justified" role="tablist">
                            <li role="presentation" class="active">
                                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay"
                                    aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
                            </li>
                            <li role="presentation" class="">
                                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab"
                                    aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i>
                                    微信支付</a>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
</main><footer class="footer" itemscope itemtype="https://schema.org/WPFooter">
<ul class="social-links">
    <li><a href="https://github.com/mumulx" target="_blank" title="github" data-toggle=tooltip data-placement=top >
            <i class="icon icon-github"></i></a></li>
    <li><a href="https://mumulx.github.io/index.xml" target="_blank" title="rss" data-toggle=tooltip data-placement=top >
            <i class="icon icon-rss"></i></a></li>
    <li><a href="https://weibo.com/u/5459389722" target="_blank" title="weibo" data-toggle=tooltip data-placement=top >
            <i class="icon icon-weibo"></i></a></li>
</ul>
  <div class="copyright">
    &copy;2019  -
    2020
    <div class="publishby">
        联系邮箱：<a target="_blank" title="木木的邮箱"> 1819778796@qq.com </a>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script>
   window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/highlight.min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/rust.min.js"></script>
<script type="text/javascript"
   src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script>
hljs.configure({
  tabReplace: '    ', 
  classPrefix: ''     
                      
})
hljs.initHighlightingOnLoad();
</script>
<script type="text/javascript" src="https://mumulx.github.io/js/application.js"></script>
<script type="text/javascript" src="https://mumulx.github.io/js/plugin.js"></script>
<script>
      (function (window) {
          var INSIGHT_CONFIG = {
              TRANSLATION: {
                  POSTS: '文章',
                  PAGES: '页面',
                  CATEGORIES: '分类',
                  TAGS: '标签',
                  UNTITLED: '(未命名)',
              },
              ROOT_URL: 'https:\/\/mumulx.github.io\/',
              CONTENT_URL: 'https:\/\/mumulx.github.io\/\/searchindex.json ',
          };
          window.INSIGHT_CONFIG = INSIGHT_CONFIG;
      })(window);
      </script>
<script type="text/javascript" src="https://mumulx.github.io/js/insight.js"></script>


<script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '1ccf8dc9e86b3575cfb2',
        clientSecret: '048ae422c4a6207a4e89c58ba1d4ebf820136bb0',
        repo: 'gittalk',
        owner: 'mumulx',
        admin: ['mumulx'],
        id: md5(location.pathname),
        distractionFreeMode: true
    });
    gitalk.render('comments');
</script>

  </body>
</html>
